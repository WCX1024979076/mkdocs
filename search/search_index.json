{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u6b22\u8fce\u8bbf\u95ee \u00b6 \u53cb\u60c5\u94fe\u63a5\uff1a \u00b6 \u4e2a\u4eba\u5bfc\u822a\u754c\u9762\uff1a http://8.131.54.221:7000/ Gtihub\u4e3b\u9875\uff1a https://github.com/WCX1024979076 \u4e2a\u4eba\u535a\u5ba2\uff1a https://tim-wcx.ltd/ Github\u535a\u5ba2CDN\uff1a https://blog.tim-wcx.workers.dev/ \u4ee3\u7801paste\uff1a http://paste.tim-wcx.ltd/ \u53c2\u8003\u94fe\u63a5\uff1a \u00b6 Cloudflare rawgithub\u52a0\u901f\uff1a https://rawgithub.tim-wcx.workers.dev/ Github\u56fe\u5e8a\uff1a https://github.com/WCX1024979076/image1 docsify\uff1a https://docsify.js.org/ <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=1302286775&auto=0&height=66\"></iframe>","title":"Home"},{"location":"#_1","text":"","title":"\u6b22\u8fce\u8bbf\u95ee"},{"location":"#_2","text":"\u4e2a\u4eba\u5bfc\u822a\u754c\u9762\uff1a http://8.131.54.221:7000/ Gtihub\u4e3b\u9875\uff1a https://github.com/WCX1024979076 \u4e2a\u4eba\u535a\u5ba2\uff1a https://tim-wcx.ltd/ Github\u535a\u5ba2CDN\uff1a https://blog.tim-wcx.workers.dev/ \u4ee3\u7801paste\uff1a http://paste.tim-wcx.ltd/","title":"\u53cb\u60c5\u94fe\u63a5\uff1a"},{"location":"#_3","text":"Cloudflare rawgithub\u52a0\u901f\uff1a https://rawgithub.tim-wcx.workers.dev/ Github\u56fe\u5e8a\uff1a https://github.com/WCX1024979076/image1 docsify\uff1a https://docsify.js.org/ <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=1302286775&auto=0&height=66\"></iframe>","title":"\u53c2\u8003\u94fe\u63a5\uff1a"},{"location":"_coverpage/","text":"Tim-wcx \u00b6 \u4e2a\u4eba\u6587\u6863\u7f51\u7ad9 \u00b6 GitHub Get Started","title":"Tim-wcx"},{"location":"_coverpage/#tim-wcx","text":"","title":"Tim-wcx"},{"location":"_coverpage/#_1","text":"GitHub Get Started","title":"\u4e2a\u4eba\u6587\u6863\u7f51\u7ad9"},{"location":"_sidebar/","text":"ICPC\u9898\u89e3 ICPC\u6a21\u677f ICPC\u9898\u5355 \u8bfe\u7a0b\u590d\u4e60","title":" sidebar"},{"location":"course/","text":"\u8bfe\u7a0b\u590d\u4e60\u7cfb\u5217","title":"Index"},{"location":"course/_coverpage/","text":"Tim-wcx \u00b6 \u4e2a\u4eba\u6587\u6863\u7f51\u7ad9 \u00b6 GitHub Get Started","title":"Tim-wcx"},{"location":"course/_coverpage/#tim-wcx","text":"","title":"Tim-wcx"},{"location":"course/_coverpage/#_1","text":"GitHub Get Started","title":"\u4e2a\u4eba\u6587\u6863\u7f51\u7ad9"},{"location":"course/_sidebar/","text":"\u4e0a\u4e00\u7ea7 \u8bfe\u7a0b\u590d\u4e60 \u6570\u5b57\u56fe\u50cf\u5904\u7406 \u73b0\u4ee3\u5bc6\u7801\u5b66 \u8f6f\u4ef6\u5de5\u7a0b","title":" sidebar"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","text":"\u6570\u5b57\u56fe\u50cf\u5904\u7406\u603b\u590d\u4e60 \u00b6 \u7b2c\u4e00\u7ae0 \u7eea\u8bba \u00b6 \u56fe\u50cf\u548c\u6570\u5b57\u56fe\u50cf \u56fe\u50cf\u4e3a\u53ef\u4ee5\u770b\u4f5c\u662f\u5bf9\u7269\u4f53\u6216\u573a\u666f\u7684\u4e00\u79cd\u8868\u73b0\u5f62\u5f0f\uff0c\u62bd\u8c61\u5b9a\u4e49\uff1a\u4e8c\u7ef4\u51fd\u6570f(x, y) \u6570\u5b57\u56fe\u50cf\u4e3a\u79bb\u6563\u5316\u4e86\u7684\u56fe\u50cf\uff0c\u5373\u5bf9x\uff0cy \u548c f \u8fdb\u884c\u79bb\u6563\u5316 \u6570\u5b57\u56fe\u50cf\u5904\u7406\u6982\u5ff5 1.\u72ed\u4e49\uff08\u8f93\u5165\u548c\u8f93\u51fa\uff09\uff1a\u5bf9\u56fe\u50cf\u8fdb\u884c\u5404\u79cd\u52a0\u5de5\uff0c\u4ee5\u6539\u5584\u56fe\u50cf\u7684\u89c6\u89c9\u6548\u679c\u6216\u7a81\u51fa\u76ee\u6807\uff0c\u5f3a\u8c03\u56fe\u50cf\u4e4b\u95f4\u8fdb\u884c\u7684\u53d8\u6362\uff0c\u662f\u4e00\u4e2a\u4ece\u56fe\u50cf\u5230\u56fe\u50cf\u7684\u8fc7\u7a0b 2.\u5e7f\u4e49\uff1a\u4e0e\u56fe\u50cf\u76f8\u5173\u7684\u5904\u7406\uff08\u56fe\u50cf\u5206\u6790\u3001\u7406\u89e3\u548c\u673a\u5668\u89c6\u89c9\uff09 3.\u5e7f\u4e49\u4e0a\u5206\u4e3a\u4e09\u79cd\u7c7b\u578b\uff1a\u4f4e\u3001\u4e2d\u3001\u9ad8\u7ea7\u5904\u7406 \u200b 1\uff09\u4f4e\u7ea7\u5904\u7406\uff1a\u8f93\u5165\u8f93\u51fa\u90fd\u662f\u56fe\u50cf\uff08\u589e\u5f3a\uff0c\u590d\u539f\uff0c\u7f16\u7801\uff0c\u538b\u7f29\uff09 \u200b 2\uff09\u4e2d\u7ea7\u5904\u7406\uff1a\u56fe\u50cf\u5206\u5272\u53ca\u76ee\u6807\u7684\u63cf\u8ff0\uff0c\u8f93\u51fa\u662f\u76ee\u6807\u7684\u7279\u5f81\u6570\u636e \uff08\u68c0\u6d4b\uff0c\u5206\u5272\uff09 \u200b 3\uff09\u9ad8\u7ea7\u5904\u7406\uff1a\u76ee\u6807\u7269\u4f53\u53ca\u76f8\u4e92\u5173\u7cfb\u7684\u7406\u89e3\uff0c\u8f93\u51fa\u662f\u66f4\u62bd\u8c61\u7684\u6570\u636e\uff08\u5206\u7c7b\uff0c\u8bc6\u522b\uff0c\u89e3\u91ca\uff09 \u56fe\u50cf\u5904\u7406\u4e3b\u8981\u662f\u4f4e\u7ea7\u5904\u7406\u53ca\u90e8\u5206\u4e2d\u7ea7\u5904\u7406\u3002 \u7b2c\u4e8c\u7ae0 \u6570\u5b57\u56fe\u50cf\u57fa\u7840 \u00b6 \u56fe\u50cf\u83b7\u53d6 \u4eba\u7c7b\u89c6\u89c9\u7cfb\u7edf\u3001\u5149\u548c\u7535\u78c1\u6ce2\u7406\u8bba\u662f\u6570\u5b57\u56fe\u50cf\u6765\u6e90\u7684\u57fa\u7840 \u4eae\u5ea6\u6210\u50cf\u6a21\u578b 2-D\u4eae\u5ea6\u51fd\u6570\uff1af (x, y)=r (x, y) (\u6ce8\uff1a\u53cd\u5c04\u6210\u5206) * i (x, y) (\u6ce8\uff1a\u7167\u5ea6\u6210\u5206) \u89c6\u7f51\u819c\u4e2d\u592e\u7684\u201c\u89c6\u9525\u7ec6\u80de\u89c6\u89c9\u201d\u548c\u89c6\u7f51\u819c\u8fb9\u7f18\u7684\u201c\u89c6\u6746\u7ec6\u80de\u89c6\u89c9\u201d\uff0c\u4e5f\u53eb\u505a\u660e\u89c6\u89c9\u548c\u6697\u89c6\u89c9\u3002 \u9525\u72b6\u7ec6\u80de\u8d1f\u8d23\u611f\u53d7\u989c\u8272\u4fe1\u606f\u7684\u3002 \u56fe\u50cf\u6570\u5b57\u5316 \u5c06\u4ee3\u8868\u56fe\u50cf\u7684\u8fde\u7eed(\u6a21\u62df)\u4fe1\u53f7\u8f6c\u6362\u4e3a\u79bb\u6563(\u6570\u5b57)\u4fe1\u53f7\u7684\u8fc7\u7a0b\u79f0\u4e3a\u56fe\u50cf\u6570\u5b57\u5316 \u6b65\u9aa4\uff1a\u91c7\u6837\u548c\u91cf\u5316 \u4e3b\u8981\u6280\u672f\uff1a 1) \u6210\u50cf\uff1a\u5149\u4fe1\u606f\uff0d>\u7535\u4fe1\u53f7 2) \u6a21\u6570\u8f6c\u6362\uff08A/D Converter \uff09 \u56fe\u50cf\u91c7\u6837\u548c\u91cf\u5316 \u91c7\u6837\u662f\u5747\u5300\u7684\uff0c\u91cf\u5316\u53ef\u4ee5\u5747\u5300\uff0c\u53ef\u4ee5\u975e\u5747\u5300\u3002 \u91c7\u6837\u548c\u91cf\u5316\u662f\u56fe\u50cf\u83b7\u53d6\u4e2d\u7684\u4e24\u5927\u6280\u672f\u3002 \u7a7a\u95f4\u548c\u7070\u5ea6\u5206\u8fa8\u7387\u662f\u56fe\u50cf\u7684\u57fa\u672c\u5c5e\u6027 1\uff09\u91c7\u6837 \u7a7a\u95f4\u5750\u6807\u7684\u79bb\u6563\u5316\u79f0\u4e3a\u7a7a\u95f4\u91c7\u6837\uff0c\u7b80\u79f0\u91c7\u6837\uff0c\u786e\u5b9a\u4e86\u56fe\u50cf\u7684\u7a7a\u95f4\u5206\u8fa8\u7387 \u5373\u7528\u7a7a\u95f4\u4e0a\u90e8\u5206\u70b9\u7684\u7070\u5ea6\u503c\u4ee3\u8868\u56fe\u50cf\u3002\u8fd9\u4e9b\u70b9\u79f0\u4e3a\u91c7 \u6837\u70b9 \u65b9\u5f0f\u4e3a\u70b9\u9635\u91c7\u6837\uff1a\u76f4\u63a5\u5bf9\u8868\u793a\u56fe\u50cf\u7684\u4e8c\u7ef4\u51fd\u6570\u503c\u8fdb\u884c\u91c7\u6837\uff0c \u6240\u5f97\u7684\u7ed3\u679c\u5c31\u662f\u4e00\u4e2a\u6837\u70b9\u503c\u5e8f\u5217 2\uff09\u91cf\u5316 \u5bf9\u91c7\u6837\u70b9\u4eae\u5ea6\uff08\u7070\u5ea6\uff09\u503c\u7684\u79bb\u6563\u5316\u8fc7\u7a0b\u3002\u786e\u5b9a\u4e86\u56fe\u50cf \u7684\u7070\uff08\u5e45\uff09\u5ea6\u5206\u8fa8\u7387 \u4e24\u79cd\u91cf\u5316\uff1a\u5747\u5300\u91cf\u5316\u3001\u975e\u5747\u5300\u91cf\u5316 \u5747\u5300\u91cf\u5316: \u5c06\u6837\u70b9\u7070\u5ea6\u7ea7\u503c\u7b49\u95f4\u9694\u5206\u6863\u53d6\u6574\uff0c\u79f0\u4e3a\u5747\u5300\u91cf\u5316 \u975e\u5747\u5300\u91cf\u5316: \u5c06\u6837\u70b9\u7070\u5ea6\u7ea7\u503c\u4e0d\u7b49\u95f4\u9694\u5206\u6863\u53d6\u6574 3\uff09\u91c7\u6837\u548c\u91cf\u5316\u7684\u7ea7\u6570 \u5047\u5b9a\u56fe\u50cf\u53d6M\u00d7N\u4e2a\u91c7\u6837\u70b9\uff0c\u5bf9\u6837\u672c\u70b9\u7070\u5ea6\u503c\u8fdb\u884cG\u7ea7\u5206\u6863\u53d6\u6574 \u2013 M, N, G \u4e00\u822c\u53d62\u7684\u6574\u6570\u6b21\u5e42 \u2013M= 2^m 2^m \uff1bN= 2^n 2^n \uff1bG= 2^k 2^k \u50cf\u7d20\u7a7a\u95f4\u7684\u5173\u7cfb 1\uff09\u50cf\u7d20\u7684\u90bb\u57df\u4e0e\u8fde\u63a5 \u90bb\u63a5---\u50cf\u7d20\u95f4\u7684\u7a7a\u95f4\u5173\u7cfb \u2460 \u56db\u90bb\u57df N_4(p),p(x,y)=(x+1,y),(x-1,y),(x,y+1),(x,y-1) N_4(p),p(x,y)=(x+1,y),(x-1,y),(x,y+1),(x,y-1) \u2461 \u5bf9\u89d2\u90bb\u57df N_D(p):p(x,y)=(x-1,y-1),(x+1,y-1),(x-1,y+1),(x+1,y+1) N_D(p):p(x,y)=(x-1,y-1),(x+1,y-1),(x-1,y+1),(x+1,y+1) \u2462 8-\u90bb\u57df N_8(P):p(x,y)=N_4(p)+N_D(p) N_8(P):p(x,y)=N_4(p)+N_D(p) 2\uff09\u8fde\u63a5 \u8fde\u63a5\uff1a\u7a7a\u95f4\u4e0a\u90bb\u63a5\u4e14\u50cf\u7d20\u7070\u5ea6\u503c\u76f8\u4f3c \u4e24\u4e2a\u50cf\u7d20\u662f\u5426\u8fde\u63a5\uff1a (1) \u662f\u5426\u63a5\u89e6\uff08\u90bb\u63a5\uff09 (2) \u7070\u5ea6\u503c\u662f\u5426\u6ee1\u8db3\u67d0\u4e2a\u7279\u5b9a\u7684\u76f8\u4f3c\u51c6\u5219 \u7070\u5ea6\u503c\u76f8\u7b49 \u6216 \u540c\u5728\u4e00\u4e2a\u7070\u5ea6\u503c\u96c6\u5408\u4e2d \u4e09\u79cd\u8fde\u63a5\u65b9\u5f0f\uff0c\u5047\u8bbeV\u4e3a\u7070\u5ea6\u503c\u96c6\u5408 \u2460 4-\u8fde\u63a5 2\u4e2a\u50cf\u7d20 p \u548c r \u5728V \u4e2d\u53d6\u503c \u4e14 r \u5728N4 (p)\u4e2d \u2461 8-\u8fde\u63a5 2\u4e2a\u50cf\u7d20 p \u548c r \u5728V \u4e2d\u53d6\u503c \u4e14 r \u5728N8 (p)\u4e2d \u2462 m-\u8fde\u63a5\uff08\u6df7\u5408\u8fde\u63a5\uff09 2\u4e2a\u50cf\u7d20 p \u548c r \u5728V \u4e2d\u53d6\u503c\uff0c\u4e14\u6ee1\u8db3\u4e0b\u5217\u6761\u4ef6\u4e4b\u4e00 (a) r \u5728 N_4 (p) N_4 (p) \u4e2d (b) r \u5728 N_D (p) N_D (p) \u4e2d\u4e14\u96c6\u5408 N_4 (p) \u2229 N_4 (r) N_4 (p) \u2229 N_4 (r) \u662f\u7a7a\u96c6 \uff08\u8fd9\u4e2a\u96c6\u5408\u662f\u7531 p \u548c r \u7684\u5728V\u4e2d\u53d6\u503c\u76844-\u8fde\u63a5\u50cf\u7d20\u7ec4\u6210\u7684\uff09 3\uff09\u8fde\u901a\u6027 \u50cf\u7d20\u7684\u8fde\u901a \u2013 \u53cd\u6620\u4e24\u4e2a\u50cf\u7d20\u95f4\u7684\u7a7a\u95f4\u5173\u7cfb \u901a\u8def\u548c\u8fde\u901a\uff0c\u79cd\u7c7b\u5206\u4e3a\u56db\u8fde\u901a\uff0c\u516b\u8fde\u901a\uff0cm\u8fde\u901a 4\uff09\u8ddd\u79bb\u5ea6\u91cf \u8ddd\u79bb\u51fd\u6570\u5b9a\u4e49\uff1a \u5bf9\u4e8e\u50cf\u7d20p, q\u548cz, \u5206\u522b\u5177\u6709\u5750\u6807(x, y), (s, t), (u, v), \u5982\u679c\uff1a (a) D(p, q)\u22650 [D(p, q)= 0, \u5f53\u4e14\u4ec5\u5f53 p=q] (b) D(p, q)= D(q, p) \u00a9 D(p, z) \u2264 D(p, q) + D(q, z) \u5219D\u662f\u8ddd\u79bb\u51fd\u6570\u6216\u5ea6\u91cf \u2460 \u6b27\u6c0f\u8ddd\u79bb D_e(p,q)=[(x-s)^2+(y-t)^2]^{1/2} D_e(p,q)=[(x-s)^2+(y-t)^2]^{1/2} \u2461 D4\u8ddd\u79bb\uff08\u57ce\u5e02\u8ddd\u79bb\uff09 D_4( p,q) = |x \u2212 s| + |y \u2212t| D_4( p,q) = |x \u2212 s| + |y \u2212t| \u2462 D8\u8ddd\u79bb\uff08\u68cb\u76d8\u8ddd\u79bb\uff09 D_8(p,q) = max(|x \u2212 s|,| y \u2212t|) D_8(p,q) = max(|x \u2212 s|,| y \u2212t|) \u6ce8\u610f\uff1a De\u8ddd\u79bb\u4e0e\u50cf\u7d20\u7684\u70b9\u5750\u6807\u76f8\u5173\uff0c\u4e0e\u50cf\u7d20\u95f4\u7684\u8fde\u901a\u6027\u65e0\u5173 D4\u548cD8\u8ddd\u79bb\u53ef\u4ee5\u770b\u4f5c\u662f\u901a\u8def\u4e0a\u8fde\u63a5\u7684\u6570\u76ee\u6700\u5c0f\u503c \u5bf9\u4e8eD4\u3001D8\u548cDm\uff0c\u5982\u679c\u50cf\u7d20p\u548cq\u95f4\u65e0\u8fde\u63a5\uff0c\u5219\u8ddd\u79bb\u662f\u65e0\u7a77\u5927 \u4ee5\u540e\u7684\u8ddd\u79bb\u9690\u542b\u8fde\u901a\u6027 \u56fe\u50cf\u7684\u8fd0\u7b97 \u52a0\u6cd5\uff1aC(x, y) = A(x, y) + B(x, y) \u51cf\u6cd5\uff1aC(x, y) = A(x, y) - B(x, y) \u4e58\u6cd5\uff1aC(x, y) = A(x, y) * B(x, y) \u6c42\u53cd\uff1ag(x, y) = 255 - f(x, y) \u5f02\u6216\uff1ag(x, y) = f(x, y) \u2295 h(x, y) \u6216\u8fd0\u7b97\uff1ag(x, y) = f(x, y) | h(x, y) \u4e0e\u8fd0\u7b97\uff1a g(x, y) = f(x, y) & h(x, y) \u56fe\u50cf\u5185\u63d2 \u56fe\u50cf\u5185\u63d2\uff1a\u653e\u5927\uff0c\u6536\u7f29\uff0c\u65cb\u8f6c\uff0c\u51e0\u4f55\u77eb\u6b63 \u653e\u5927\u8fc7\u7a0b\uff1a \u00bb \u539f\u6765\u56fe\u50cf\u5206\u8fa8\u7387\u4e3am\u00d7n \u00bb \u5c06\u56fe\u50cf\u653e\u59271.5\u500d\u4e4b\u540e\uff0c\u5177\u67091.5m\u00d71.5n= 2.25m\u00d7n\u4e2a\u50cf\u7d20 \u00bb \u4e0e\u539f\u6765\u56fe\u50cf\u5177\u6709\u76f8\u540c\u7684\u50cf\u7d20\uff0c\u50cf\u7d20\u6570\u91cf\u662f\u539f\u67652.25\u500d \u00bb \u5c06\u5176\u6536\u7f29\uff0c\u4e0e\u539f\u6765\u56fe\u50cf\u5339\u914d \u00bb \u50cf\u7d20\u95f4\u9694\u5c0f\u4e8e\u539f\u6765\u56fe\u50cf\u50cf\u7d20\u95f4\u9694 \u00bb \u4ece\u539f\u6765\u56fe\u50cf\u50cf\u7d20\u503c\u63d0\u53d6\u4fe1\u606f\u8d4b\u7ed9\u65b0\u56fe\u50cf\u76f8\u5e94\u50cf\u7d20 \u56fe\u50cf\u5185\u63d2\u7684\u4e3b\u8981\u65b9\u6cd5 \u6700\u8fd1\u90bb\u5185\u63d2\u6cd5 \u53cc\u7ebf\u6027\u5185\u63d2\u6cd5 \u53cc\u4e09\u6b21\u5185\u63d2\u6cd5\u3002 \u56fe\u50cf\u7cfb\u7edf \u56fe\u50cf\u5904\u7406\u7cfb\u7edf\u5177\u6709\u56fe\u50cf\u8f93\u5165\u3001\u8f93\u51fa\u3001\u5b58\u50a8\u548c\u5904\u7406\u529f\u80fd\u3002 \u56fe\u50cf\u4e4b\u95f4\u7684\u56db\u5219\u8fd0\u7b97\uff0c\u53ea\u8981\u76f4\u63a5\u8fd0\u7b97\u5c31\u884c\u3002--\u9700\u5bf9\u8d85\u51fa\u7070\u5ea6\u8303\u56f4\u7684\u50cf\u7d20\u8fdb\u884c\u5904\u7406\u3002 \u7b2c\u4e09\u7ae0 \u7a7a\u57df\u589e\u5f3a\u6280\u672f \u00b6 \u7a7a\u57df\u589e\u5f3a\u57fa\u7840 \ud835\udc88(\ud835\udc99, \ud835\udc9a)= \ud835\udc7b[\ud835\udc87(\ud835\udc99, y)] \ud835\udc88(\ud835\udc99, \ud835\udc9a)= \ud835\udc7b[\ud835\udc87(\ud835\udc99, y)] \u5176\u4e2d\ud835\udc87(\ud835\udc99, \ud835\udc9a) \u662f\u8f93\u5165\u56fe\u50cf\uff0c \ud835\udc88(\ud835\udc99, \ud835\udc9a) \u662f\u5904\u7406\u540e\u56fe\u50cf \ud835\udc7b\u662f\u5728\u70b9 (\ud835\udc99, \ud835\udc9a) \u90bb\u57df\u4e0a\u5b9a\u4e49\u7684\u5173\u4e8e\ud835\udc87\u7684\u589e\u5f3a\u64cd\u4f5c\u3002 \u7a7a\u57df\u589e\u5f3a\u8ba1\u7b97\u8fc7\u7a0b\uff1a-\u904d\u5386\u56fe\u50cf\u6240\u6709\u50cf\u7d20 \u2013 \u6bcf\u4e2a\u50cf\u7d20\u5904\uff0c\u7528T\u8ddf\u4ee5(x,y)\u4e3a\u4e2d\u5fc3\u7684\u90bb\u57df\u8fdb\u884c\u8ba1\u7b97 \u2013 \u8fb9\u7f18\u5904\u7406\uff1a\u586b\u96f6 \u76f4\u63a5\u7070\u5ea6\u6620\u5c04 \u5c06 f (x, y)\u4e2d\u7684\u6bcf\u4e2a\u50cf\u7d20\u7070\u5ea6\u6309\ud835\udc7b\u64cd\u4f5c\u76f4\u63a5\u53d8\u6362\u4ee5\u5f97\u5230 g(x, y) \u5178\u578b\u65b9\u6cd5\uff1a \u5bf9\u6570\u53d8\u6362 s=c*log(r+1) s=c*log(r+1) \u6307\u6570\u53d8\u6362 s=cr^{\\gamma} s=cr^{\\gamma} \u03b3>1\u4f4e\u7070\u5ea6\u538b\u7f29\uff0c\u9ad8\u7070\u5ea6\u62c9\u4f38 \u03b3<1\u4f4e\u7070\u5ea6\u62c9\u4f38\uff0c\u9ad8\u7070\u5ea6\u538b\u7f29 \u03b3=1\u5c31\u662f\u6052\u7b49\u53d8\u6362 \u76f4\u65b9\u56fe\u53d8\u6362 \u76f4\u65b9\u56fe\uff08Histogram \uff09 \u6570\u5b57\u56fe\u50cf\u4e2d\u6bcf\u4e00\u7070\u5ea6\u7ea7\uff0c\u5b83\u51fa\u73b0\u7684\u9891\u6570\u7684\u7edf\u8ba1 \u63d0\u4f9b\u4e86\u56fe\u50cf\u50cf\u7d20\u7684\u7070\u5ea6\u503c\u5206\u5e03\u60c5\u51b5 1\uff09\u76f4\u65b9\u56fe\u5747\u8861\u5316 \u76f4\u65b9\u56fe\u5747\u8861\u5316\uff1a\u6307\u56fe\u50cf\u7ecf\u7070\u5ea6\u53d8\u6362\u540e\uff0c\u4f7f\u5f97\u7070\u5ea6\u7684\u6982\u7387\u5bc6\u5ea6\u5206\u5e03\u53d8\u4e3a\u5e38 \u6570\uff0c\u5373\u5747\u5300\u5206\u5e03 \u6ce8\uff1a\u5728\u8be5\u76f4\u65b9\u56fe\u4e2d\uff0c\u5171\u67098\u949f\u7070\u5ea6\uff0c\u5373L=8\u3002 2\uff09\u76f4\u65b9\u56fe\u89c4\u5b9a\u5316 \u901a\u8fc7\u6307\u5b9a\u7684\u51fd\u6570\u5c06\u539f\u56fe\u50cf\u7684\u7070\u5ea6\u76f4\u65b9\u56fe\u53d8\u6362\u6210\u53e6\u4e00\u79cd\u5206\u5e03\u7684\u7070\u5ea6\u76f4\u65b9\u56fe\uff0c\u5373\u786e\u5b9a\u4e00\u4e2aT\u51fd\u6570\uff0c\u6839\u636e\u8fd9\u4e2a\u76f4\u65b9\u56fe\u786e\u5b9a\u4e00\u7070\u5ea6\u7ea7\u53d8\u6362 T\u00ae, \u4f7f\u7531 T\u4ea7\u751f\u7684 \u65b0\u56fe\u8c61\u7684\u76f4\u65b9\u7b26\u5408\u6307\u5b9a\u7684\u76f4\u65b9\u56fe\u3002 3\uff09\u5c40\u90e8\u76f4\u65b9\u56fe\u5904\u7406 \u6709\u65f6\u9700\u8981\u5bf9\u56fe\u50cf\u5c0f\u533a\u57df\u7ec6\u8282\u7684\u5c40\u90e8\u589e\u5f3a\u3002\u89e3\u51b3\u7684\u529e\u6cd5\u5c31\u662f\u5728\u56fe\u50cf\u4e2d\u6bcf\u4e00\u4e2a\u7d20\u7684\u90bb\u57df\u5c31\u662f\u5728\u56fe\u50cf\u4e2d\uff0c\u6839\u636e\u7070\u5ea6\u7ea7\u5206\u5e03 \u8bbe\u8ba1\u53d8\u6362\u51fd\u6570\u3002\u7136\u540e\u5229\u7528\u524d\u9762\u4ecb\u7ecd\u7684\u6280\u672f\u6765\u8fdb\u884c\u5c40\u90e8\u589e\u5f3a\u3002 \u7ebf\u6027\u6ee4\u6ce2 \u6ee4\u6ce2\u5668\u53ef\u5206\u4e3a\u7ebf\u6027\u6ee4\u6ce2\u5668\u548c\u975e\u7ebf\u6027\u6ee4\u6ce2\u5668\uff0c\u9510\u5316\u548c\u5e73\u6ed1\u3002 \u975e\u7ebf\u6027\u6ee4\u6ce2\u5668\u4f5c\u7528\uff1a\u65e2\u6d88\u9664\u566a\u58f0\u53c8\u4fdd\u6301\u7ec6\u8282\uff08\u4e0d\u6a21\u7cca\uff09 \u5e38\u89c1\u6ee4\u6ce2\u5668\uff1a \u90bb\u57df\u5e73\u5747 --\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u6a21\u7248\u7cfb\u6570\u90fd\u662f\u6b63\u7684\uff0c\u4fdd\u6301\u7070\u5ea6\u503c\u8303\u56f4\uff08\u7cfb\u6570\u4e4b\u548c\u4e3a1\uff09 z=\\frac{1}{M} \\sum ^{M-1}_{i=0} (k_i*s_i) z=\\frac{1}{M} \\sum ^{M-1}_{i=0} (k_i*s_i) M\u7684\u5927\u5c0f\u4e0d\u540c\uff0c\u5e73\u6ed1\u7684\u6548\u679c\u4e5f\u4e0d\u540c\u3002 \u6a21\u677f\u5c3a\u5bf8\u589e\u5927\u65f6\uff0c\u5bf9\u566a\u58f0\u6d88\u9664\u6548\u679c\u589e\u5f3a\uff0c\u4f46\u56fe\u50cf\u53d8\u5f97\u6a21\u7cca\uff0c\u5373\u8fb9\u7f18\u7ec6\u8282\u51cf\u5c11\u3002 \u52a0\u6743\u5e73\u5747 --\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u4e0d\u540c\u4f4d\u7f6e\u7684\u7cfb\u6570\u91c7\u7528\u4e0d\u540c\u7684\u503c\uff0c\u4e00\u822c\u8ba4\u4e3a\uff1a\u79bb\u6a21\u677f\u4e2d\u5fc3\u8fd1\u7684\u50cf\u7d20\u5bf9\u6ee4\u6ce2\u8d21\u732e\u5927\uff0c\u6240\u4ee5\u7cfb\u6570\u5927\uff1b \u800c\u5468\u56f4\u7cfb\u6570\u5c0f\u3002 \u4e2d\u503c\u6ee4\u6ce2\u5668 --\u975e\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u5c06\u6a21\u677f\u4e2d\u5fc3\u4e0e\u50cf\u7d20\u4f4d\u7f6e\u91cd\u5408\uff0c\u8bfb\u53d6\u6a21\u677f\u4e0b\u5404\u5bf9\u5e94\u50cf\u7d20\u7684\u7070\u5ea6\u503c\uff0c\u5c06\u8fd9\u4e9b\u7070\u5ea6\u503c\u4ece\u5c0f\u5230\u5927\u6392\u6210 1\u5217\uff0c\u627e\u51fa\u8fd9\u4e9b\u503c\u91cc\u6392\u5728\u4e2d\u95f4\u7684 1\u4e2a\uff0c\u5c06\u8fd9\u4e2a\u4e2d\u95f4\u503c\u8d4b\u7ed9\u6a21\u677f\u5fc3\u4f4d\u7f6e\u50cf\u7d20\u3002 \u4e2d\u503c\u6ee4\u6ce2\u5668\u7684\u6d88\u566a\u58f0\u6548\u679c\u4e0e\u6a21\u677f\u7684\u5c3a\u5bf8\u548c\u53c2\u4e0e\u8fd0\u7b97\u7684\u50cf\u7d20\u6570\u6709\u5173\u3002 \u56fe\u50cf\u4e2d\u5c3a\u5bf8\u5c0f\u4e8e\u6a21\u677f\u5c3a\u5bf8\u4e00\u534a\u7684\u8fc7\u4eae\u6216\u8fc7\u6697\u533a\u57df\u5c06\u4f1a\u5728\u6ee4\u6ce2\u540e\u4f1a\u88ab\u6d88\u9664\u6389\u3002 \u767e\u5206\u6bd4\u6ee4\u6ce2\u5668 --\u975e\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u6700\u5927\u503c\u6ee4\u6ce2\u5668\uff1a g_{max}(x,y)=max_{(s,t)\u2208N(x,y)}[f(s,t)] g_{max}(x,y)=max_{(s,t)\u2208N(x,y)}[f(s,t)] \u6700\u5c0f\u503c\u6ee4\u6ce2\u5668\uff1a g_{min}(x,y)=min_{(s,t)\u2208N(x,y)}[f(s,t)] g_{min}(x,y)=min_{(s,t)\u2208N(x,y)}[f(s,t)] \u4e2d\u70b9\u6ee4\u6ce2\u5668\uff1a g_{mid}(x,y)=\\frac{1}{2}(g_{max}(x,y)+g_{min}(x,y)) g_{mid}(x,y)=\\frac{1}{2}(g_{max}(x,y)+g_{min}(x,y)) \u68af\u5ea6\u6ee4\u6ce2\u5668 --\u975e\u7ebf\u6027\u9510\u5316\u6ee4\u6ce2\u5668 \u5404\u5411\u5f02\u6027\uff0c\u5728X\u548cY\u4e24\u4e2a\u65b9\u5411\u4e0d\u540c\u3002 \u200b \u68af\u5ea6\u66ff\u4ee3\u8ba1\u7b97\u65b9\u6cd5 \u62c9\u666e\u62c9\u65af\u7b97\u5b50\uff0c\u4e8c\u9636\u5bfc\u6570 --\u975e\u7ebf\u6027\u9510\u5316\u6ee4\u6ce2\u5668 \u5fae\u5206\u7b97\u5b50\uff0c\u4f7f\u7528\u540e\u589e\u5f3a\u4e86\u56fe\u50cf\u4e2d\u7070\u5ea6\u7684\u7a81\u53d8\uff0c\u4e0d\u7ea7\u7f13\u6162\u53d8\u5316\u533a\u57df \u628a\u539f\u56fe\u50cf\u4e0e laplace laplace \u56fe\u50cf\u7ebf\u6027\u7ec4\u5408\uff0c\u53ef\u4ee5\u540c\u65f6\u4fdd\u6301 laplace laplace laplace\u9510\u5316\u548c\u539f\u56fe\u50cf\u80cc\u666f\u3002 \u5982\u679c laplace \u7b97\u5b50\u4e2d\u5fc3\u7cfb\u6570\u4e3a\u6b63\uff0c\u5219\u7528\u539f\u56fe\u50cf\u52a0\u4e0a laplace \u56fe\u50cf\uff1b \u5982\u679c laplace \u7b97\u5b50\u4e2d\u5fc3\u7cfb\u6570\u4e3a\u8d1f\uff0c\u5219\u7528\u539f\u56fe\u50cf\u51cf\u53bb laplace\u56fe\u50cf\u3002 \u5c40\u90e8\u589e\u5f3a \u7a7a\u95f4\u57df\u5c40\u90e8\u589e\u5f3a-\u5c40\u90e8\u9009\u62e9\u6839\u636e\u5b9e\u9645\u95ee\u9898\u8981\u6c42\u7075\u6d3b\u8bbe\u5b9a\u3002 \u5bf9\u56fe\u50cf\u5c40\u90e8\u7ec6\u8282\u7684\u589e\u5f3a\u5904\u7406 \u56fe\u50cf\u7684\u7edf\u8ba1\u91cf\uff1a \u7070\u5ea6\u5e73\u5747\u503c m=\\sum^{L-1}_{i=0}r_i*p(r_i) m=\\sum^{L-1}_{i=0}r_i*p(r_i) \u65b9\u5dee\uff08\u4e8c\u9636\u77e9\uff09 \\mu_2(r)=\\sum^{L-1}_{i=0}(r_i-m)^2p(r_i) \\mu_2(r)=\\sum^{L-1}_{i=0}(r_i-m)^2p(r_i) r\u7684n\u9636\u77e9\uff1a \\mu_n(r)=\\sum^{L-1}_{i=0}(r_i-m)^np(r_i) \\mu_n(r)=\\sum^{L-1}_{i=0}(r_i-m)^np(r_i) \u5c40\u90e8\u589e\u5f3a\u7684\u65b9\u6cd5\uff1a g(x,y)=A(x,y)[f(x,y)-m(x,y)]+m(x,y),\u5176\u4e2dA(x,y)=\\frac{k*M}{\\sigma(x,y)} g(x,y)=A(x,y)[f(x,y)-m(x,y)]+m(x,y),\u5176\u4e2dA(x,y)=\\frac{k*M}{\\sigma(x,y)} M\u4e3af(x,y)\u7684\u5747\u503c,m(x,y)\u548c\\sigma(x,y)\u4e3a\u4ee5(x,y)\u4e3a\u4e2d\u5fc3\u90bb\u57df\u5185\u7684\u5747\u503c\u548c\u5747\u65b9\u5dee\u503c M\u4e3af(x,y)\u7684\u5747\u503c,m(x,y)\u548c\\sigma(x,y)\u4e3a\u4ee5(x,y)\u4e3a\u4e2d\u5fc3\u90bb\u57df\u5185\u7684\u5747\u503c\u548c\u5747\u65b9\u5dee\u503c \u57fa\u4e8e\u5c40\u90e8\u7edf\u8ba1\u7684\u589e\u5f3a\u65b9\u6cd5\uff1a \u4ee4 (x,y) (x,y) \u4e3a\u4e00\u50cf\u7d20\u5750\u6807\uff0c S_{xy} S_{xy} \u8868\u793a\u4e00\u786e\u5b9a\u5927\u5c0f\u7684\u90bb\u57df\uff08\u5b50\u56fe\u50cf\uff09\uff0c\u5219 S_{xy} S_{xy} \u7684\u5e73\u5747\u503c m_{xy} m_{xy} \u4e3a\uff1a m_{xy}=\\sum_{(s,t)\u2208(S_{xy}))}(r_{s,t}\u00d7p(r_{s,t})) m_{xy}=\\sum_{(s,t)\u2208(S_{xy}))}(r_{s,t}\u00d7p(r_{s,t})) S_{xy} S_{xy} \u4e2d\u50cf\u7d20\u7684\u65b9\u5dee\u4e3a\uff1a \\sigma^2_{S_{xy}}=\\sum^{(L-1)}_{(s,t)\u2208S_{xy}}\\{[r_{s,t}-m_{s_{xy}}]^2\u00d7p(s_{s,t})\\} \\sigma^2_{S_{xy}}=\\sum^{(L-1)}_{(s,t)\u2208S_{xy}}\\{[r_{s,t}-m_{s_{xy}}]^2\u00d7p(s_{s,t})\\} \u6839\u636e\u4eae\u6697\u548c\u5bf9\u6bd4\u5ea6\u6765\u5224\u65ad\u662f\u5426\u589e\u5f3a\u67d0\u4e00\u70b9\u7684\u4eae\u5ea6\uff0c\u7136\u540e\u5bf9\u5176\u8fdb\u884c\u589e\u5f3a \u4ee4\u6761\u4ef6T=m_{s_{xy}}<=k_0*M_G,k_0<=1.0\u4e14k_1D_G<=\\sigma_{S_{xy}}<=k_2D_G,k_1<=k_2 \u4ee4\u6761\u4ef6T=m_{s_{xy}}<=k_0*M_G,k_0<=1.0\u4e14k_1D_G<=\\sigma_{S_{xy}}<=k_2D_G,k_1<=k_2 g(x,y)=T?E*f(x,y):f(x,y) g(x,y)=T?E*f(x,y):f(x,y) \u7b2c\u56db\u7ae0 \u9891\u57df\u5904\u7406 \u00b6 \u5085\u91cc\u53f6\u53d8\u6362 \u65f6\u57df\u56fe\u50cf\u662f\u4e00\u4e2a\u5468\u671f\u4e14\u8fde\u7eed\u7684\u51fd\u6570\uff0c\u9891\u57df\u56fe\u50cf\u548c\u76f8\u4f4d\u56fe\u50cf\u662f\u4e00\u4e2a\u975e\u5468\u671f\u79bb\u6563\u7684\u51fd\u6570\u3002 \u6b27\u62c9\u516c\u5f0f\uff1a e^{ix}=cos(x)+i*sin(x) e^{ix}=cos(x)+i*sin(x) \u5085\u91cc\u53f6\u53d8\u6362\u7684\u5b9a\u4e49 1\uff09\u4e00\u7ef4\u5085\u91cc\u53f6\u53d8\u6362 \u8fde\u7eed\u51fd\u6570 \u6b63\u53d8\u6362 F\\{f(x)\\}=F(u)=\\int^{+\\infty}_{-\\infty}f(x)e^{-j2*\\pi ux}dx F\\{f(x)\\}=F(u)=\\int^{+\\infty}_{-\\infty}f(x)e^{-j2*\\pi ux}dx \u9006\uff08\u53cd\uff09\u53d8\u6362 f(x)=\\int^{+\\infty}_{-\\infty}F(u)e^{j*2\\pi ux}du f(x)=\\int^{+\\infty}_{-\\infty}F(u)e^{j*2\\pi ux}du \u79bb\u6563\u51fd\u6570 \u6b63\u53d8\u6362 F\\{f(x)\\}=F(u)=\\sum^{N-1}_{x=0}f(x)e^{-2j\\pi ux/N} F\\{f(x)\\}=F(u)=\\sum^{N-1}_{x=0}f(x)e^{-2j\\pi ux/N} \u9006\uff08\u53cd\uff09\u53d8\u6362 F^{-1}\\{f(x)\\}=f(x)=\\frac{1}{N}\\sum^{N-1}_{x=0}F(u)e^{2j\\pi ux} F^{-1}\\{f(x)\\}=f(x)=\\frac{1}{N}\\sum^{N-1}_{x=0}F(u)e^{2j\\pi ux} u=0,1,2,...,N-1 u=0,1,2,...,N-1 2\uff09\u4e8c\u7ef4\u5085\u91cc\u53f6\u53d8\u6362 \u8fde\u7eed\u51fd\u6570 \u6b63\u53d8\u6362 F\\{f(x,y)\\}=F(u,v)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} f(x,y)e^{-j2\\pi ux}dxdy F\\{f(x,y)\\}=F(u,v)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} f(x,y)e^{-j2\\pi ux}dxdy \u9006\uff08\u53cd\uff09\u53d8\u6362 F^{-1}\\{f(x,y)\\}=f(x,y)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} F(u,v)e^{j2\\pi ux}dudv F^{-1}\\{f(x,y)\\}=f(x,y)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} F(u,v)e^{j2\\pi ux}dudv \u79bb\u6563\u51fd\u6570 \u6b63\u53d8\u6362 F(u,v)=\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} f(x,y) e^{-j2\\pi (ux/M+vy/N)} F(u,v)=\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} f(x,y) e^{-j2\\pi (ux/M+vy/N)} u=0,1,2,...,M-1,v=0,1,2,...,N-1 u=0,1,2,...,M-1,v=0,1,2,...,N-1 \u9006\u53d8\u6362 f(x,y)=\\frac{1}{MN}\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} F(u,v) e^{j2\\pi (ux/M+vy/N)} f(x,y)=\\frac{1}{MN}\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} F(u,v) e^{j2\\pi (ux/M+vy/N)} x=0,1,2,...,M-1,y=0,1,2,...,N-1 x=0,1,2,...,M-1,y=0,1,2,...,N-1 3\uff09\u9891\u8c31\u57df \u5b9a\u4e49\uff1a\u7531\u5085\u7acb\u53f6\u53d8\u6362\u548c\u9891\u7387\u53d8\u91cf( u, v)\u5b9a\u4e49\u7684\u7a7a\u95f4 \u6027\u8d28\uff1a \u53d8\u6362\u6700\u6162\u7684\u9891\u7387\u6210\u5206(u=0,v=0)\u5bf9\u5e94\u4e00\u5e45\u56fe\u50cf\u7684\u5e73\u5747\u7070\u5ea6\uff0c\u8bc1\u660e\u4e3a\uff1a F(0,0)=\\sum_{x=0}^{M-1}\\sum^{N-1}_{y=0}f(x,y) F(0,0)=\\sum_{x=0}^{M-1}\\sum^{N-1}_{y=0}f(x,y) \u5373 F(0,0)=mean(f(x,y))*M*N F(0,0)=mean(f(x,y))*M*N \uff0c\u6240\u4ee5 |F(0,0)| |F(0,0)| \u662f\u9891\u8c31\u7684\u6700\u5927\u5206\u91cf\u3002 \u9891\u57df\u6709\u67d0\u4e00\u65b9\u5411\u7684\u4eae\u7ebf\u6761\uff0c\u8bf4\u660e\u56fe\u50cf\u4e2d\u4e0e\u4e4b\u5782\u76f4\u65b9\u5411\u4e0a\u6709\u8f83\u591a\u7ebf\u6761\u3002 \u5085\u91cc\u53f6\u53d8\u6362\u662f\u5171\u8f6d\u5bf9\u79f0\u7684\uff0c\u5373 F^*(u,v)=F(-u,-v) F^*(u,v)=F(-u,-v) \u6570\u5b57\u56fe\u50cf\u7684\u9891\u8c31\u662f\u5173\u4e8e\u539f\u70b9\u5076\u5bf9\u79f0\u7684\uff0c\u5373 |F(u,v)|=|F(-u,-v)| |F(u,v)|=|F(-u,-v)| \u6570\u5b57\u56fe\u50cf\u7684\u76f8\u4f4d\u89d2\u662f\u5173\u4e8e\u8fdc\u70b9\u5947\u5bf9\u79f0\u7684\uff0c\u5373 \\varphi(u,v)=-\\varphi(-u,-v) \\varphi(u,v)=-\\varphi(-u,-v) \u5e73\u79fb\u6027\u8d28 \u5085\u7acb\u53f6\u53d8\u6362\u5e73\u79fb\u6027\u8d28\uff0c\u662f\u6307\u5f53\u7a7a\u57df\u56fe\u50cf\u76ee\u6807\u4f4d\u7f6e\u53d8\u5316\u4e4b\u540e\uff0c\u5176\u9891\u8c31\u4e0d\u53d1\u751f\u6539\u53d8\u3002 \u65cb\u8f6c\u6027\u8d28 \u5c3a\u5ea6\u5b9a\u7406 \u5468\u671f\u6027 \u5e94\u7528\uff1a f(x)(-1)^x==F(u-\\frac{M}{2}) f(x)(-1)^x==F(u-\\frac{M}{2}) \u8bc1\u660e\u4e3a\uff1a \u4e8c\u7ef4\u540c\u6837\uff1a 4\uff09\u5085\u91cc\u53f6\u53d8\u6362\u76f8\u4f4d\u8c31 \u7531\u5085\u7acb\u53f6\u53d8\u6362\u7684\u76f8\u4f4d\u6784\u6210\u7684\u77e9\u9635\u3002 \u76f8\u4f4d\u5206\u91cf\u662f\u6307\u5404\u4e2a\u6b63\u5f26\u5206\u91cf\u5173\u4e8e\u539f\u70b9\u7684\u4f4d\u79fb\u7684\u5ea6\u91cf\uff0c\u51b3\u5b9a\u4e86\u56fe\u50cf\u4e2d\u53ef\u8fa8\u522b\u7269\u4f53\u5b9a\u4f4d\u4fe1\u606f\u3002 5\uff09\u5377\u79ef\u5b9a\u7406 6\uff09\u5085\u91cc\u53f6\u53d8\u6362\u65f6\u95f4\u590d\u6742\u5ea6 \u8ba1\u7b97\u4e00\u7ef4\u79bb\u6563\u5085\u91cc\u53f6\u53d8\u6362\uff08DFT\uff09\u516c\u5f0f\u5982\u4e0b\uff1a \u200b \u5176\u4e2d\uff0cN\u8868\u793a\u6570\u636e\u957f\u5ea6\u3002\u7531\u4e0a\u5f0f\u53ef\u77e5\uff0cDFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(N*N) \u4e00\u7ef4FFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(N*logN)\uff0c\u5176\u4e2dN\u8868\u793a\u6570\u636e\u957f\u5ea6 \u5bf9\u4e8e\u4e00\u4e2aM*N\u7684\u4e8c\u7ef4\u6570\u636e\uff0cFFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO( M*N*log(M*N) ) \u82e5M=N\uff0c\u5219\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u7b80\u5316\u4e3aO(N^2*logN) \u5bf9\u4e8eM\u7ef4\u7684\u6570\u636e\uff08\u6bcf\u4e00\u7ef4\u957f\u5ea6\u4e3aA\uff0cB\uff0cC\uff0c...\uff09\uff0c\u5219FFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO( A*B*C*...* log(A*B*C*...) ) \u82e5\u6bcf\u4e00\u7ef4\u957f\u5ea6\u76f8\u540c\uff0c\u5373A=B=C=...=N\uff0c\u5219\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u7b80\u5316\u4e3aO(N^M*logN) \u79bb\u6563\u4f59\u5f26\u53d8\u6362 1\uff09\u4e8c\u7ef4\u79bb\u6563\u4f59\u5f26\u53d8\u6362\u5b9a\u4e49 \u6c83\u5c14\u4ec0\u53d8\u6362 \u7b2c\u4e94\u7ae0 \u9891\u7387\u57df\u56fe\u50cf\u589e\u5f3a \u00b6 \u9891\u7387\u57df\u589e\u5f3a\u539f\u7406 1\uff09\u5377\u79ef\u4ee5\u53ca\u5377\u79ef\u5b9a\u7406 \u8bbe\u51fd\u6570f (x, y)\u4e0e\u7b97\u5b50h(x, y)\u7684\u5377\u79ef\u7ed3\u679c\u662fg(x, y)\uff0c\u5373 g(x, y) = h(x, y) * f (x, y)\uff0c\u90a3\u4e48\u6839\u636e\u5377\u79ef\u5b9a\u7406\u5728\u9891\u57df\u6709\uff1a G(u,v) = H(u,v)F(u,v)\uff0c\u5176\u4e2dG(u, v)\uff0cH(u, v)\uff0cF(u, v)\u5206\u522b\u662fg(x, y)\uff0ch(x, y)\uff0cf (x, y)\u7684\u5085\u7acb\u53f6(\u6216\u5176\u5b83)\u53d8\u6362\uff0c\u79f0H(u, v)\u4e3a\u8f6c\u79fb\u51fd\u6570 G(u,v) = H(u,v)F(u,v) 2\uff09\u56fe\u50cf\u589e\u5f3a\u539f\u7406 \u5176\u4e2dT\u4ee3\u8868\u5085\u91cc\u53f6\u53d8\u6362 3\uff09\u56fe\u50cf\u589e\u5f3a\u5177\u4f53\u5b9e\u73b0 \u5377\u79ef\u5b9a\u7406\uff1a G(u,v)=H(u,v)F(u,v) G(u,v)=H(u,v)F(u,v) \u589e\u5f3a\u56fe\u50cf\uff1a g(x,y)=T^{-1}[H(u,v)F(u,v)] g(x,y)=T^{-1}[H(u,v)F(u,v)] \u6b65 \u9aa4\uff1a (1) \u8ba1\u7b97\u56fe\u50cf\u7684\u9891\u57df\u53d8\u6362 (2) \u5728\u9891\u57df\u6ee4\u6ce2 (3) \u53cd\u53d8\u6362\u56de\u56fe\u50cf\u7a7a\u95f4 \u9891\u57df\u6ee4\u6ce2: \u4f4e\u901a\uff0c\u9ad8\u901a\uff0c\u540c\u6001 \u9891\u7387\u57df\u5e73\u6ed1\u6ee4\u6ce2\u5668 1\uff09\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u56fe\u50cf\u4e2d\u7684\u8fb9\u7f18\u548c\u566a\u58f0\u90fd\u5bf9\u5e94\u56fe\u50cf\u5085\u7acb\u53f6\u53d8\u6362\u4e2d\u7684\u9ad8\u9891\u90e8\u5206 \uff0c\u6240\u4ee5\u5982\u8981\u5728\u9891\u57df\u4e2d\u6d88\u5f31\u5176\u5f71\u54cd\u5c31\u8981\u8bbe\u6cd5\u51cf\u5f31\u8fd9\u90e8\u5206\u9891\u7387\u7684\u5206\u91cf\u3002 2\uff09\u7406\u60f3\u4f4e\u901a\u6ee4\u6ce2\u5668 H(u,v)=1:0?D(u,v)<D_0\uff0c\u5176\u4e2dD(u,v)=(u^2+v^2)^{1/2} H(u,v)=1:0?D(u,v)<D_0\uff0c\u5176\u4e2dD(u,v)=(u^2+v^2)^{1/2} \u95ee\u9898\uff1a\u6a21\u7cca\uff0c\u632f\u94c3\u6548\u5e94\u3002 3\uff09\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668 \u51cf\u5c11\u632f\u94c3\u6548\u5e94\uff0c\u9ad8\u4f4e\u9891\u7387\u95f4\u7684\u8fc7\u6e21\u6bd4\u8f83\u5149\u6ed1\u3002 \u9636\u6570\u4e3an\u7684\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668\u516c\u5f0f\u4e3a\uff1a H(u,v)=\\frac{1}{1+D(u,v)^{2n}} H(u,v)=\\frac{1}{1+D(u,v)^{2n}} \u9636\u6570\u5bf9\u632f\u94c3\u73b0\u8c61\u7684\u5f71\u54cd\uff1a\u9636\u6570\u8d8a\u9ad8\uff0c\u8d8a\u660e\u663e\u3002 \u5f53\u9636\u6570\u8d8b\u4e8e\u65e0\u7a77\u65f6\uff0c\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u53d8\u6210\u7406\u60f3\u4f4e\u901a\u6ee4\u6ce2\u3002 4\uff09\u5e94\u7528 \u56fe\u50cf\u7531\u4e8e\u91cf\u5316\u4e0d\u8db3\u4ea7\u751f\u865a\u5047\u8f6e\u5ed3\u65f6\u5e38\u53ef\u7528\u4f4e\u901a\u6ee4\u6ce2\u8fdb\u884c\u5e73\u6ed1\u4ee5\u6539\u8fdb\u56fe\u50cf\u8d28\u91cf\u3002 5\uff09\u9ad8\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668 \u9ad8\u65af\u6ee4\u6ce2\u5668\u662f\u5b8c\u5168\u4e0d\u4f1a\u4ea7\u751f\u632f\u94c3\u6548\u5e94\u7684\u3002 H(u,v)=e^{-D^2(u,v)/2D_0)^2} H(u,v)=e^{-D^2(u,v)/2D_0)^2} 6\uff09\u5176\u4ed6\u4f4e\u901a\u6ee4\u6ce2\u5668 \u9891\u7387\u57df\u9510\u5316\u6ee4\u6ce2\u5668 1\uff09\u7406\u60f3\u9ad8\u901a\u6ee4\u6ce2\u5668 \u5f62\u72b6\u4e0e\u4f4e\u901a\u6ee4\u6ce2\u5668\u7684\u5f62\u72b6\u6b63\u597d\u76f8\u53cd H(u,v)=0:1?D(u,v)>D_0 H(u,v)=0:1?D(u,v)>D_0 2\uff09\u5df4\u7279\u6c83\u65af\u9ad8\u901a\u6ee4\u6ce2\u5668 \u5f62\u72b6\u4e0e\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668\u7684\u5f62\u72b6\u6b63\u597d\u76f8\u53cd H(u,v)=\\frac{1}{1+[D_0/D(u,v)]^{2n}} H(u,v)=\\frac{1}{1+[D_0/D(u,v)]^{2n}} 3\uff09\u9ad8\u65af\u9ad8\u901a\u6ee4\u6ce2\u5668 \u5f62\u72b6\u4e0e\u9ad8\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668\u7684\u5f62\u72b6\u6b63\u597d\u76f8\u53cd H(u,v)=1-e^{-D^2(u,v)/2D_0)^2} H(u,v)=1-e^{-D^2(u,v)/2D_0)^2} \u9ad8\u9891\u5f3a\u8c03\u6ee4\u6ce2\u5668 \u9ad8\u901a\u6ee4\u6ce2\u7684\u7ed3\u679c\uff1a\u8fb9\u7f18\u52a0\u5f3a\uff0c\u5149\u6ed1\u533a\u57df\u53d8\u6697 \u9ad8\u901a\u6ee4\u6ce2\uff1a G(u,v)=H(u,v)F(u,v) G(u,v)=H(u,v)F(u,v) \u9ad8\u901a\u5f3a\u8c03\u8f6c\u79fb\u51fd\u6570\uff1a H_c(u,v)=k\u00d7H(u,v)+c H_c(u,v)=k\u00d7H(u,v)+c \u9ad8\u9891\u5f3a\u8c03\u8f93\u51fa\u56fe\u7684\u5085\u7acb\u53f6\u53d8\u6362\uff1a G_c(u,v)=k\u00d7G(u,v)+c\u00d7F(u,c) G_c(u,v)=k\u00d7G(u,v)+c\u00d7F(u,c) \u53cd\u53d8\u6362\u4e3a\uff1a g(x,y)=k\u00d7g(x,y)+c\u00d7f(x,y) g(x,y)=k\u00d7g(x,y)+c\u00d7f(x,y) \u9ad8\u9891\u63d0\u5347\u6ee4\u6ce2\u5668 \u7528\u539f\u59cb\u56fe\u51cf\u53bb\u4f4e\u901a\u56fe\u5f97\u5230\u9ad8\u901a\u6ee4\u6ce2\u5668\u7684\u6548\u679c\u3002 \u628a\u539f\u59cb\u56fe\u4e58\u4ee5\u4e00\u4e2a\u653e\u5927\u7cfb\u6570A\u518d\u51cf\u53bb\u4f4e\u901a\u56fe\u5c31\u53ef\u6784 \u6210\u9ad8\u9891\u63d0\u5347\uff08high-boost\uff09\u6ee4\u6ce2\u5668 G_{HB}(u,v)=A\u00d7F(u,v)-F_L(u,v)=(A-1)F(u,v)+F_H(u,v) G_{HB}(u,v)=A\u00d7F(u,v)-F_L(u,v)=(A-1)F(u,v)+F_H(u,v) A = 1 \uff1a\u9ad8\u901a\u6ee4\u6ce2\u5668 A > 1 \uff1a\u539f\u59cb\u56fe\u7684\u4e00\u90e8\u5206\u4e0e\u9ad8\u901a\u56fe\u76f8\u52a0\uff0c\u6062\u590d\u4e86\u9ad8\u901a\u6ee4\u6ce2\u65f6\u4e22\u5931\u7684\u4f4e\u9891\u5206\u91cf \u540c\u6001\u6ee4\u6ce2 \u5c06\u660e\u4eae\u5747\u8861\u5316\uff0c\u4f7f\u4eae\u5ea6\u548c\u7070\u5ea6\u5747\u8861\u5316\u3002 \u9009\u62e9\u6027\u6ee4\u6ce2 \u5206\u4e3a\u4e24\u79cd\uff1a \u5e26\u963b\u6ee4\u6ce2\u5668&\u5e26\u901a\u6ee4\u6ce2\u5668 1\uff09\u5e26\u963b\u6ee4\u6ce2\u5668 \u5e26\u963b\u6ee4\u6ce2\u5668\u4e5f\u6709\u4e09\u79cd\u7279\u6027\u3002\u7406\u60f3\u3001\u5df4\u7279\u6c83\u65af\u548c\u9ad8\u65af 2\uff09\u5e26\u901a\u6ee4\u6ce2\u5668 \u5e26\u963b\u6ee4\u6ce2\u5668\u4e5f\u6709\u4e09\u79cd\u7279\u6027\u3002\u7406\u60f3\u3001\u5df4\u7279\u6c83\u65af\u548c\u9ad8\u65af 3\uff09\u9677\u6ce2\u6ee4\u6ce2\u5668(Notch Filter) \u9677\u6ce2\u6ee4\u6ce2\u5668\u672c\u8d28\u4e0a\u662f\u591a\u4e2a\u9ad8\u901a\u6ee4\u6ce2\u5668\u8fdb\u884c\u5e73\u79fb\u540e\u518d\u76f8\u4e58\u3002 \u591a\u4e2a\u5e26\u963b\u6ee4\u6ce2\u5668\u7ecf\u8fc7\u5e73\u79fb\u83b7\u5f97\u3002 \u9891\u57df\u6280\u672f\u4e0e\u7a7a\u57df\u6280\u672f 1\uff09\u7a7a\u95f4\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u6d88\u9664\u6216\u51cf\u5f31\u56fe\u50cf\u4e2d\u7070\u5ea6\u503c\u5177\u6709\u8f83\u5927\u8f83\u5feb\u53d8\u5316\u90e8\u5206\u7684\u5f71\u54cd\uff0c \u8fd9\u4e9b\u90e8\u5206\u5bf9\u5e94\u9891\u57df\u4e2d\u7684\u9ad8\u9891\u5206\u91cf\uff0c\u6240\u4ee5\u53ef\u7528\u9891\u57df\u4f4e\u901a\u6ee4\u6ce2\u6765\u5b9e\u73b0 \u9891\u57df\u8d8a\u5bbd\uff0c\u7a7a\u57df\u8d8a\u7a84\uff0c\u5e73\u6ed1\u4f5c\u7528\u8d8a\u5f31 \u9891\u57df\u8d8a\u7a84\uff0c\u7a7a\u57df\u8d8a\u5bbd\uff0c\u6a21\u7cca\u4f5c\u7528\u8d8a\u5f3a \u5e73\u6ed1\u6a21\u677f\u7cfb\u6570\u4e3a\u6b63\uff0c\u4e14\u4e2d\u90e8\u7cfb\u6570\u503c\u8f83\u5927 2\uff09\u7a7a\u95f4\u9510\u5316\u6ee4\u6ce2\u5668 \u6d88\u9664\u6216\u51cf\u5f31\u56fe\u50cf\u4e2d\u7070\u5ea6\u503c\u7f13\u6162\u53d8\u5316\u7684\u90e8\u5206\uff0c\u8fd9\u4e9b\u90e8\u5206\u5bf9\u5e94 \u9891\u57df\u4e2d\u7684\u4f4e\u9891\u5206\u91cf\uff0c\u6240\u4ee5\u53ef\u7528\u9891\u57df\u9ad8\u901a\u6ee4\u6ce2\u6765\u5b9e\u73b0 \u7a7a\u57df\u6709\u6b63\u8d1f\u503c\uff0c\u6a21\u677f\u4e2d\u5fc3\u7cfb\u6570\u503c\u8f83\u5927 \u7b2c\u516d\u7ae0 \u56fe\u50cf\u6062\u590d \u00b6 \u56fe\u50cf\u6062\u590dvs.\u56fe\u50cf\u589e\u5f3a \u76f8\u540c\u4e4b\u5904\uff1a \u6539\u8fdb\u8f93\u5165\u56fe\u50cf\u7684\u89c6\u89c9\u8d28\u91cf \u4e0d\u540c\u4e4b\u5904\uff1a \u4e0d\u8003\u8651\u56fe\u50cf\u964d\u8d28\u7684\u539f\u56e0\uff0c\u53ea\u5c06\u56fe\u50cf\u4e2d\u611f\u5174\u8da3\u7684\u7279\u5f81\u6709\u9009\u62e9\u5730 \u7a81\u51fa\uff08\u589e\u5f3a\uff09\uff0c\u800c\u8870\u51cf\u5176\u4e0d\u9700\u8981\u7684\u7279\u5f81\uff0c\u6539\u5584\u540e\u7684\u56fe\u50cf\u4e0d\u4e00\u5b9a\u8981\u53bb \u903c\u8fd1\u539f\u56fe\u50cf\u3002\u56fe\u50cf\u589e\u5f3a\u501f\u52a9\u4eba\u7684\u89c6\u89c9\u7cfb\u7edf\u7279\u6027\uff0c\u4ee5\u53d6\u5f97\u8f83\u597d\u7684\u89c6 \u89c9\u7ed3\u679c\uff08\u4e0d\u8003\u8651\u9000\u5316\u539f\u56e0\uff09 \u56fe\u50cf\u6062\u590d\u6839\u636e\u76f8\u5e94\u7684\u9000\u5316\u6a21\u578b\u548c\u77e5\u8bc6\u91cd\u5efa\u6216\u6062\u590d\u539f\u59cb\u7684\u56fe\u50cf \uff08\u8003\u8651\u9000\u5316\u539f\u56e0\uff09 \u56fe\u50cf\u9000\u5316\u793a\u4f8b \u56fe\u50cf\u9000\u5316\u6307\u7531\u573a\u666f\u5f97\u5230\u7684\u56fe\u50cf\u6ca1\u80fd\u5b8c\u5168\u5730\u53cd\u6620\u573a\u666f\u7684\u771f \u5b9e\u5185\u5bb9\uff0c\u4ea7\u751f\u4e86\u5931\u771f\u7b49\u95ee\u9898 \u539f\u56e0\uff1a\u900f\u955c\u50cf\u5dee/\u8272\u5dee\u3001\u805a\u7126\u4e0d\u51c6\uff08\u5931\u7126\uff0c\u9650\u5236\u4e86\u56fe\u50cf\u9510\u5ea6\uff09\u3001\u6a21\u7cca\uff08\u9650\u5236\u9891\u8c31\u5bbd\u5ea6\uff09\u3001\u566a\u58f0\uff08\u662f\u4e00\u4e2a\u7edf\u8ba1\u8fc7\u7a0b\uff09\u3001\u6296\u52a8\uff08\u673a\u68b0\u3001\u7535\u5b50\uff09 \u56fe\u50cf\u9000\u5316\u590d\u539f\u8fc7\u7a0b\u6a21\u578b \u9000\u5316\u8fc7\u7a0b\u662f\u4e00\u4e2a\u9000\u5316\u51fd\u6570\ud835\udc6f(\u2219) \u548c\u4e00\u4e2a\u52a0\u6027\u566a\u58f0 \ud835\udf3c (\ud835\udc99, \ud835\udc9a) \uff0c\u4f5c\u7528\u5230\u4e00\u5e45\u56fe\u50cf\ud835\udc87(\ud835\udc99, \ud835\udc9a)\u4e0a\uff0c\u4ea7\u751f\u9000\u5316\u540e\u7684 \u56fe\u50cf\ud835\udc88(\ud835\udc99, \ud835\udc9a)\u3002 \u590d\u539f\u8fc7\u7a0b\u662f\u7ed9\u5b9a\u9000\u5316\u56fe\ud835\udc88(\ud835\udc99, \ud835\udc9a)\u548c\u5173\u4e8e\u9000\u5316\u51fd\u6570\ud835\udc6f(\u2219)\u7684\u4e00\u4e9b\u77e5\u8bc6\u53ca\u5173\u4e8e\u52a0\u6027\u566a\u58f0\u9879\ud835\udf3c(\ud835\udc99, \ud835\udc9a)\u7684\u77e5\u8bc6\uff0c\u83b7\u5f97 \u539f\u59cb\u56fe\u50cf\u7684\u4e00\u4e2a\u4f30\u8ba1\ud835\udc87(x,y)\u3002 \u9000\u5316\u6a21\u578b\uff1a g(x,y)=H[f(x,y)]+\\eta(x,y)=h(x,y)*f(x,y)+\\eta(x,y),*\u4e3a\u5377\u79ef g(x,y)=H[f(x,y)]+\\eta(x,y)=h(x,y)*f(x,y)+\\eta(x,y),*\u4e3a\u5377\u79ef G(x,y)=H(x,y)F(x,y+N(x,y)) G(x,y)=H(x,y)F(x,y+N(x,y)) \u566a\u58f0\u6a21\u578b 1\uff09\u5e38\u89c1\u566a\u58f0 \u70ed\u566a\u58f0\uff1a\u4e0e\u7269\u4f53\u7684\u7edd\u5bf9\u6e29\u5ea6\u6709\u5173\u3002 \u4e5f\u79f0\uff1a \u767d\u566a\u58f0 \uff08\u9891\u7387\u8986\u76d6\u6574\u4e2a\u9891\u8c31\uff09 \u9ad8\u65af\u566a\u58f0\uff08\u5e45\u5ea6\u7b26\u5408\u9ad8\u65af\u5206\u5e03\uff09 \u95ea\u70c1\u566a\u58f0\uff1a\u7535\u6d41\u8fd0\u52a8\u4ea7\u751f\u3002 \u5177\u6709\u53cd\u6bd4\u4e8e\u9891\u7387\uff081/f\uff09\u7684\u9891\u8c31 \u4e5f\u79f0\u7c89\u8272\u566a\u58f0\uff08\u5728\u5bf9\u6570\u9891\u7387\u95f4\u9694\u5185\u6709\u76f8\u540c\u7684\u80fd\u91cf\uff09 \u53d1\u5c04\u566a\u58f0\uff1a\u9ad8\u65af\u5206\u5e03\uff08\u7535\u5b50\u8fd0\u52a8\u7684\u968f\u673a\u6027\uff09 **\u52a0\u6027\u566a\u58f0**\u4e00\u822c\u6307\u70ed\u566a\u58f0\u3001\u6563\u5f39\u566a\u58f0\u7b49\uff0c\u5b83\u4eec\u4e0e\u4fe1\u53f7\u7684\u5173\u7cfb\u662f\u76f8\u52a0\uff0c\u4e0d\u7ba1\u6709\u6ca1\u6709\u4fe1\u53f7\uff0c\u8be5\u7c7b\u566a\u58f0\u662f\u4e00\u76f4\u5b58\u5728\u7684\u3002\u4e00\u822c\u901a\u4fe1\u4e2d\u628a\u52a0\u6027\u968f\u673a\u6027\u770b\u6210\u662f\u7cfb\u7edf\u7684\u80cc\u666f\u566a\u58f0\u3002 **\u4e58\u6027\u566a\u58f0**\u4e00\u822c\u7531\u4fe1\u9053\u4e0d\u7406\u60f3\u5f15\u8d77\uff0c\u5b83\u4eec\u4e0e\u4fe1\u53f7\u7684\u5173\u7cfb\u662f\u76f8\u4e58\uff0c\u4fe1\u53f7\u5728\u5b83\u5728\uff0c\u4fe1\u53f7\u4e0d\u5728\u4ed6\u4e5f\u5c31\u4e0d\u5728\u3002\u4e58\u6027\u968f\u673a\u6027\u770b\u6210\u7cfb\u7edf\u7684\u65f6\u53d8\u6027\uff08\u5982\u8870\u843d\u6216\u8005\u591a\u666e\u52d2\uff09\u6216\u8005\u975e\u7ebf\u6027\u6240\u9020\u6210\u7684\u3002 2\uff09\u566a\u58f0\u6982\u7387\u5bc6\u5ea6\u51fd\u6570 3\uff09\u5468\u671f\u566a\u58f0 \u4e00\u5e45\u56fe\u50cf\u7684\u5468\u671f\u566a\u58f0\u662f\u5728\u56fe\u50cf\u83b7\u53d6\u671f\u95f4\u7531\u7535\u529b\u6216\u673a\u7535\u5e72\u6270\u4ea7\u751f\u7684\u3002 \u662f\u4e00\u79cd\u7a7a\u95f4\u76f8\u5173\u566a\u58f0\u3002 \u5468\u671f\u566a\u58f0\uff08\u6b63\u5f26\uff09\u5728\u5085\u91cc\u53f6\u53d8\u6362\u540e\uff0c\u662f\u4f4d\u4e8e\u6b63\u5f26\u6ce2\u5171\u8f6d\u9891\u7387\u5904\u7684\u4e00\u5bf9\u5171\u8f6d\u8109\u51b2\u3002 \u5468\u671f\u566a\u58f0\u53c2\u6570\u4f30\u8ba1\uff1a \u901a\u8fc7\u68c0\u9a8c\u5085\u91cc\u53f6\u8c31\u6765\u4f30\u8ba1\u5468\u671f\u3002 \u5468\u671f\u566a\u58f0\u901a\u5e38\u4f1a\u4ea7\u751f\u9891\u7387\u5c16\u5cf0\uff0c\u53ef\u4ee5\u8fdb\u884c\u68c0\u6d4b\u3002 \u566a\u58f0\u53c2\u6570\u4f30\u8ba1 \u566a\u58f0\u7684PDF\u53c2\u6570 \u6210\u50cf\u7cfb\u7edf\u53ef\u4f7f\u7528 \u4f7f\u7528\u6210\u50cf\u7cfb\u7edf\u83b7\u53d6\u4e00\u7ec4\u201c\u5e73\u5766\u201d\u73af\u5883\u56fe\u50cf\uff0c\u4f5c\u4e3a\u6837\u672c\uff1b\u5373\uff1a\u62cd\u6444\u5149\u7167\u5747\u5300\u7684\u7eaf\u8272\u7070\u5ea6\u56fe\u50cf \u6210\u50cf\u7cfb\u7edf\u4e0d\u53ef\u4f7f\u7528\uff0c\u53ea\u6709\u5176\u751f\u6210\u56fe\u50cf \u4ece\u56fe\u50cf\u4e2d\uff0c\u627e\u4e00\u5757\u5408\u7406\u7684\u6052\u5b9a\u7070\u5ea6\u503c\u533a\u57df\uff0c\u4f5c\u4e3a\u6837\u672c \u56fe\u50cf\u566a\u58f0\u7684\u6982\u7387\u5bc6\u5ea6\u51fd\u6570\u8868\u793a\uff0c\u5176\u81ea\u53d8\u91cf\u662f\u56fe\u50cf\u7070\u5ea6\u503c\u3002 \u53ea\u6709\u566a\u58f0\u7684\u590d\u539f-\u7a7a\u95f4\u6ee4\u6ce2 \u5bf9\u4e8e\u5468\u671f\u566a\u58f0\uff0c\u5728\u9891\u57df\u4f30\u8ba1\ud835\udc75(\ud835\udc96, \ud835\udc97) \uff0c\u76f4\u63a5\u53bb\u6389\uff0c\u53d8\u6362\u5230\u7a7a\u95f4\u57df\u3002 \u52a0\u6027\u566a\u58f0\uff0c\u7a7a\u95f4\u6ee4\u6ce2\u3002 \u5bf9\u4e8e\u56fe\u50cf\u4e2d\u7684\u52a0\u6027\u566a\u58f0\uff0c\u91c7\u7528\u7b97\u672f\u5747\u503c\u6ee4\u6ce2\u3001\u51e0\u4f55\u5747\u503c\u6ee4\u6ce2\u3001\u9006\u8c10\u6ce2\u5747\u503c\u6ee4\u6ce2\u548c\u8c10\u6ce2\u5747\u503c\u6ee4\u6ce2\u53bb\u9664\u3002 1\uff09\u5747\u503c\u6ee4\u6ce2\u5668 2\uff09\u8c10\u6ce2\u5747\u503c\u6ee4\u6ce2\u5668 3\uff09\u4fee\u6b63alpha\u5747\u503c\u6ee4\u6ce2\u5668 4\uff09\u81ea\u9002\u5e94\u6ee4\u6ce2\u5668 \u6ee4\u6ce2\u5668\u7279\u5f81\u53d8\u5316\u662f\u4ee5\ud835\udc8e \u00d7 \ud835\udc8f\u7684\u77e9\u5f62\u7a97\u53e3\ud835\udc7a\ud835\udc99\ud835\udc9a\u5b9a\u4e49\u7684\u6ee4\u6ce2\u5668\u533a\u57df\u5185\u56fe\u50cf\u7684\u7edf\u8ba1\u7279\u5f81\u4e3a\u57fa\u7840 \u81ea\u9002\u5e94\u6ee4\u6ce2\u5668\u6027\u80fd\u4f18\u4e8e\u5168\u5c40\u6ee4\u6ce2\u5668 \u8ba1\u7b97\u590d\u6742\u5ea6\u9ad8 5\uff09\u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u5168\u5c40\u4e2d\u503c\u6ee4\u6ce2\uff0c\u5728\u8109\u51b2\u566a\u58f0\u7a7a\u95f4\u5bc6\u5ea6\u4e0d\u5927\u662f\uff0c\u6027\u80fd\u5f88\u597d\uff08\u7ecf\u9a8c\uff1a\ud835\udc77\ud835\udc82 < \ud835\udfce. \ud835\udfd0\uff0c\ud835\udc77\ud835\udc83 < \ud835\udfce. \ud835\udfd0\uff09 \u2013 \u5bc6\u5ea6\u5927\uff0c\u4e0d\u597d\u7528 \u2013 \u4e0d\u80fd\u5904\u7406\u975e\u8109\u51b2\u566a\u58f0\uff0c\u540c\u65f6\u4fdd\u7559\u7ec6\u8282 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2 \u2013 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u53ef\u4ee5\u5904\u7406\u66f4\u5927\u7684\u5bc6\u5ea6 \u2013 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u80fd\u591f\u5728\u5e73\u6ed1\u975e\u8109\u51b2\u566a\u58f0\u65f6\uff0c\u4fdd\u7559\u7ec6\u8282 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u76f8\u540c\uff1a \u2013 \u6ee4\u6ce2\u5668\u4f5c\u7528\u4e8e\u5c40\u90e8\u533a\u57df\ud835\udc7a\ud835\udc99\ud835\udc9a \u533a\u522b\uff1a \u2013 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u6839\u636e\u67d0\u4e9b\u6761\u4ef6\u6539\u53d8\ud835\udc7a\ud835\udc99\ud835\udc9a\u7684\u5c3a\u5bf8 \u4f7f\u7528\uff1a \u2013 \u6ee4\u6ce2\u5668\u8f93\u51fa\u4e00\u4e2a\u5355\u503c\uff0c\u7528\u4e8e\u4ee3\u66ff\u6ee4\u6ce2\u5668\u7a97\u53e3\ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u5fc3\u5904\u50cf\u7d20 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u7b26\u53f7\uff1a \ud835\udc9b\ud835\udc8e\ud835\udc8a\ud835\udc8f = \ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u7684\u6700\u5c0f\u7070\u5ea6\u503c \ud835\udc9b\ud835\udc8e\ud835\udc82\ud835\udc99 = \ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u7684\u6700\u5927\u7070\u5ea6\u503c \ud835\udc9b\ud835\udc8e\ud835\udc86\ud835\udc85 = \ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u7684\u7070\u5ea6\u503c\u4e2d\u503c \ud835\udc9b\ud835\udc99\ud835\udc9a =\u5750\u6807 \ud835\udc99, \ud835\udc9a \u5904\u7684\u7070\u5ea6\u503c \ud835\udc7a\ud835\udc8e\ud835\udc82\ud835\udc99 = \ud835\udc7a\ud835\udc99\ud835\udc9a\u5141\u8bb8\u7684\u6700\u5927\u5c3a\u5bf8 \u5468\u671f\u566a\u58f0\u6d88\u9664 \u5e26\u963b\u6ee4\u6ce2\u5668 \u5e26\u901a\u6ee4\u6ce2\u5668 \uff08\u63d0\u53d6\u566a\u58f0\u6a21\u5f0f\uff09 \u9677\u6ce2\u6ee4\u6ce2\u5668 \u7ebf\u6027\u3001\u4f4d\u7f6e\u4e0d\u53d8\u7684\u9000\u5316 1\uff09\u9000\u5316\u6a21\u578b \u9000\u5316\u6a21\u578b\u516c\u5f0f\uff1a \ud835\udc88(\ud835\udc99, \ud835\udc9a) = \ud835\udc6f[\ud835\udc87(\ud835\udc99, \ud835\udc9a)] + \ud835\udf3c(\ud835\udc99, \ud835\udc9a) \u7b80\u5316\u6a21\u578b\uff1a \ud835\udf3c(\ud835\udc99, \ud835\udc9a)=0 2\uff09\u9000\u5316\u7cfb\u7edfH\u7684\u6027\u8d28 \u4f30\u8ba1\u9000\u5316\u51fd\u6570 \u56fe\u50cf\u89c2\u5bdf\u4f30\u8ba1 \u2013 \u6761\u4ef6\uff1a\u53ea\u6709\u9000\u5316\u56fe\u50cf\uff0c\u6ca1\u6709\u5173\u4e8e\u9000\u5316\u51fd\u6570H\u7684\u4efb\u4f55\u77e5\u8bc6\u3002 \u4ece\u56fe\u50cf\u672c\u8eab\u6765\u6536\u96c6\u4fe1\u606f\uff0c\u5373\u901a\u8fc7\u89c2\u5bdf\u56fe\u50cf\uff0c\u8fdb\u884c\u5904\u7406 \u6765\u83b7\u5f97\u9000\u5316\u51fd\u6570\u4fe1\u606f\u3002 \u65b9\u6cd5\uff1a \u2013 \u4ece\u56fe\u50cf\u4e2d\u9009\u62e9\u4e00\u5c0f\u5757\u533a\u57df\uff0c\u4f5c\u4e3a\u5b50\u56fe\u50cf \u2013 \u56fe\u50cf\u4e2d\u7269\u4f53\u6216\u56fe\u50cf\u80cc\u666f\u4e00\u90e8\u5206 \u2013 \u4e3a\u964d\u4f4e\u566a\u58f0\u5f71\u54cd\uff0c\u627e\u6709\u5f88\u5f3a\u4fe1\u53f7\u7684\u533a\u57df\uff08\u9ad8\u5bf9\u6bd4\u533a\u57df\uff09 \u2013 \u624b\u5de5\u5904\u7406\u5b50\u56fe\u50cf\uff0c\u53bb\u9664\u6a21\u7cca\u3002 \u2013 \u8ba1\u7b97\u51faH(u,v) \u8bd5\u9a8c\u4f30\u8ba1 \u2013 \u6761\u4ef6\uff1a\u53ef\u4ee5\u83b7\u5f97\u4e0e\u9000\u5316\u56fe\u50cf\u8bbe\u5907\u76f8\u4f3c\u7684\u7cfb\u7edf \u2013 \u7406\u8bba\u4e0a\uff1a\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u51c6\u786e\u7684\u9000\u5316\u4f30\u8ba1 \u65b9\u6cd5\uff1a \u2013 \u901a\u8fc7\u8bbe\u7f6e\u7cfb\u7edf\uff0c\u83b7\u5f97\u4e0e\u9000\u5316\u56fe\u50cf\u63a5\u8fd1\u7684\u56fe\u50cf\uff1b \u2013 \u7528\u8be5\u7cfb\u7edf\u4e00\u5e45\u51b2\u6fc0\u6210\u50cf\uff0c\u5f97\u5230\u9000\u5316\u7684\u51b2\u6fc0\u54cd\u5e94\uff1b \u2013 \u51b2\u6fc0\u7528\u4e00\u4e2a\u5c0f\u4eae\u70b9\u6765\u6a21\u62df\uff0c\u5c3d\u53ef\u80fd\u4eae\uff1b \u2013 \ud835\udc6f(\ud835\udc96, \ud835\udc97)= \ud835\udc6e(\ud835\udc96,\ud835\udc97)/\ud835\udc68 \u200b \ud835\udc6e(\ud835\udc96, \ud835\udc97)\u662f\u51b2\u6fc0\u6210\u50cf\u56fe\u50cf\u7684\u5085\u91cc\u53f6\u53d8\u6362\uff0c\ud835\udc68\u662f\u51b2\u6fc0\u7684\u5085\u91cc\u53f6\u53d8\u6362 \u5efa\u6a21\u4f30\u8ba1 \u4ece\u5f15\u8d77\u9000\u5316\u7684\u73af\u5883\u6761\u4ef6\u8003\u8651\uff0c\u8fdb\u884c\u4f30\u8ba1 \u6e4d\u6d41\u9000\u5316\u6a21\u578b\u662f\u5927\u6c14\u6e4d\u6d41\u7269\u7406\u7279\u6027\u7684 \u901a\u7528\u5f62\u5f0f\uff1a \ud835\udc6f(\ud835\udc96, \ud835\udc97)= \ud835\udc86^{\u2212\ud835\udc8c(\ud835\udc96^\ud835\udfd0+\ud835\udc97^\ud835\udfd0)^{\ud835\udfd3/6}} \ud835\udc6f(\ud835\udc96, \ud835\udc97)= \ud835\udc86^{\u2212\ud835\udc8c(\ud835\udc96^\ud835\udfd0+\ud835\udc97^\ud835\udfd0)^{\ud835\udfd3/6}} \u5176\u4e2d\uff0c \ud835\udc8c\u662f\u4e0e\u6e4d\u6d41\u6027\u8d28\u6709\u5173\u7684\u5e38\u6570 \ud835\udc8c = \ud835\udfce. \ud835\udfce\ud835\udfce\ud835\udfd0\ud835\udfd3\u5267\u70c8\u6e4d\u6d41 \ud835\udc8c = \ud835\udfce. \ud835\udfce\ud835\udfce\ud835\udfcf\u4e2d\u7b49\u6e4d\u6d41 \ud835\udc8c = \ud835\udfce. \ud835\udfce\ud835\udfce\ud835\udfce\ud835\udfd0\ud835\udfd3\u8f7b\u5fae\u6e4d\u6d41 \u9006\u6ee4\u6ce2 --\u65e0\u7ea6\u675f\u6062\u590d \u9006\u6ee4\u6ce2\u4e2d\uff0c\u9006\u6ee4\u6ce2\u4e2d\uff0c\u6309\u7167\u79bb\u9891\u8c31\u4e2d\u5fc3\u7684\u8fdc\u8fd1\u5b9a\u4e49\u4e86\u6062\u590d\u8f6c\u79fb\u51fd\u6570\u662f\u632f\u94c3\u6548\u5e94\u51fa\u73b0\u7684\u539f\u56e0\u3002 \u6700\u5c0f\u5747\u65b9\u8bef\u5dee\u6ee4\u6ce2\uff08\u7ef4\u7eb3\u6ee4\u6ce2\uff09 --\u6709\u7ea6\u675f\u6062\u590d \u4e86\u89e3 \u6709\u7ea6\u675f\u6700\u5c0f\u4e8c\u4e58\u65b9\u6062\u590d --\u6709\u7ea6\u675f\u6062\u590d \u4e86\u89e3 \u7b2c\u4e03\u7ae0 \u5f69\u8272\u56fe\u50cf\u5904\u7406 \u00b6 \u5f69\u8272\u57fa\u7840 1\uff09\u989c\u8272\u7684\u672c\u8d28 \u4e0d\u540c\u989c\u8272\u7684\u5149\u5b9e\u8d28\u662f \u4e0d\u540c\u9891\u7387\u7684\u7535\u78c1\u6ce2 \u2013 \u53ef\u89c1\u5149\u8c31\u7684\u6ce2\u957f\u8303\u56f4\uff1a400\uff5e700nm 2\uff09\u4e09\u57fa\u8272 \u5927\u591a\u6570\u7684\u989c\u8272\u53ef\u4ee5\u901a \u8fc7\u7ea2\u3001\u7eff\u3001\u84dd\u4e09\u8272\u6309\u7167 \u4e0d\u540c\u7684\u6bd4\u4f8b\u5408\u6210\u4ea7\u751f 3\uff09\u8272\u5ea6 \u8272\u5ea6 \u5f69\u8272\u7684\u4e09\u79cd\u57fa\u672c\u7279\u6027\u91cf \u4eae\u5ea6\uff1a \u4e0e\u7269\u4f53\u7684\u53cd\u5c04\u7387\u6210\u6b63\u6bd4 \u8272\u8c03\uff1a \u4e0e\u5149\u8c31\u4e2d\u5149\u7684\u6ce2\u957f\u76f8\u8054\u7cfb \u9971\u548c\u5ea6\uff1a\u4e0e\u4e00\u5b9a\u8272\u8c03\u5149\u7684\u7eaf\u5ea6\u6709\u5173 \u8272\u5ea6\uff1a\u8272\u8c03\u548c\u9971\u548c\u5ea6\u5408\u79f0 \u5f69\u8272\u53ef\u7528\u4eae\u5ea6\u548c\u8272\u5ea6\u5171\u540c\u8868\u793a 4\uff09\u8272\u5ea6\u56fe \u5f69\u8272\u6253\u5370\u673a\u662f\u76f8 \u52a0\u8272\u5f69\u548c\u76f8\u51cf\u8272\u5f69\u7684\u6df7\u5408\u7684 \u7ec4\u5408\uff0c\u6240\u4ee5\u5f69\u8272\u57df\u8fb9\u754c\u4e0d\u89c4\u5219\u3002 \u5f69\u8272\u8f6c\u5316\u4e3a\u7070\u5ea6\uff0c\u9002\u5408\u663e\u793a\u5668\u548c\u6444\u50cf\u673a\uff1a Y_{709} = 0.2125R + 0.7154G + 0.0721B Y_{709} = 0.2125R + 0.7154G + 0.0721B \u5f69\u8272\u6a21\u578b \u4e3a\u4e86\u6b63\u786e\u6709\u6548\u5730\u8868\u8fbe\u5f69\u8272\u4fe1\u606f\uff0c\u9700\u8981\u5efa\u7acb\u5408\u9002\u7684\u5f69\u8272\u8868\u8fbe\u6a21\u578b\u3002 1\uff09\u5f69\u8272\u8868\u8fbe\u6a21\u578b \u5f69\u8272\u8868\u8fbe\u6a21\u578b\u5206\u4e3a\u4e24\u79cd\uff1a \u9762\u5411\u786c\u8bbe\u5907\u7684\u5f69\u8272\u6a21\u578b\uff0c\u8bf8\u5982\u5f69\u8272\u663e\u793a\u5668\u6216\u6253\u5370\u673a\u4e4b\u7c7b\u7684\u786c\u8bbe\u5907\uff0c\u4f8b\u5982RGB\uff0cCMY\u6a21\u578b\u7b49\u3002 \u9762\u5411\u89c6\u89c9\u611f\u77e5\u7684\u5f69\u8272\u6a21\u578b\uff0c\u4ee5\u5f69\u8272\u5904\u7406\u4e3a\u76ee\u7684\u7684\u5e94\u7528\uff0c\u4f8b\u5982HSI\u3001HSV\u6a21\u578b\u7b49\u3002 2\uff09RGB\u6a21\u578b \u5efa\u7acb\u5728\u7b1b\u5361\u513f\u5750\u6807\u7cfb\u7edf\u91cc\uff0c\u5176\u4e2d\u4e09 \u4e2a\u8f74\u5206\u522b\u4e3aR\uff0cG\uff0cB\uff0c \u2013 \u6a21\u578b\u7684\u7a7a\u95f4\u662f\u6b63\u65b9\u4f53\uff0c\u539f\u70b9\u5bf9\u5e94\u9ed1 \u8272\uff0c\u79bb\u539f\u70b9\u6700\u8fdc\u7684\u9876\u70b9\u5bf9\u5e94\u767d\u8272 \u2013 \u4ece\u9ed1\u5230\u767d\u7684\u7070\u5ea6\u503c\u5206\u5e03\u5728\u4ece\u539f\u70b9\u5230 \u79bb\u539f\u70b9\u6700\u8fdc\u9876\u70b9\u95f4\u7684\u8fde\u7ebf\u4e0a\uff0c\u800c\u7acb\u65b9\u4f53\u5185\u5176\u4f59\u5404\u70b9\u5bf9\u5e94\u4e0d\u540c\u7684\u989c\u8272\uff0c \u53ef\u7528\u4ece\u539f\u70b9\u5230\u8be5\u70b9\u7684\u77e2\u91cf\u8868\u793a 3\uff09CMY\u6a21\u578b \u4e09\u8865\u8272\uff1a \u84dd\u7eff(C, cyan)\uff0c\u54c1\u7ea2(M, magenta)\uff0c\u9ec4(Y, yellow) \u2013 \u4e3b\u8981\u7528\u4e8e\u5f69\u8272\u6253\u5370\uff0c\u8fd9\u4e09\u79cd\u8865\u8272\u53ef\u5206\u522b\u7531\u4ece\u767d\u5149\u4e2d\u51cf\u53bb\u4e09\u79cd\u57fa\u8272\u800c\u5f97\u5230 \u2013 \u4eceCMY\u5230RGB\u7684\u8f6c\u6362\u4e3aR =1\u2212C\uff0cG =1\u2212 M\uff0cB =1\u2212Y 4\uff09HSI\u6a21\u578b H\uff1a\u70b9s\u7684H\u4e3a\u4e09\u89d2\u5f62 \u4e2d\u5fc3\u70b9\u5230s\u7684\u77e2\u91cf\u4e0eR\u8f74\u7684\u5939\u89d2 S\uff1a\u70b9s\u7684S\u4e3a\u4e09\u89d2 \u5f62\u4e2d\u5fc3\u70b9\u5230s\u7684\u77e2\u91cf\u957f\u5ea6 I\uff1a\u79bb\u5f00\u4e2d\u95f4\u622a\u9762 \u5411\u4e0a\u53d8\u767d\uff1b\u5411\u4e0b\u53d8\u9ed1 \u8272\u8c03\u548c\u9971\u548c\u5ea6\u4e8c\u8005\u5408\u5e76\u79f0\u4e3a\u8272\u5ea6\uff0c\u4eae\u5ea6\u4e2d\u4e0d\u542b\u6709\u989c\u8272\u4fe1\u606f\u3002 H \u8868\u793a\u8272\u8c03\uff08hue\uff09 S \u8868\u793a\u9971\u548c\u5ea6\uff08saturation\uff09 I \u8868\u793a\u5bc6\u5ea6\uff08intensity\uff0c\u5bf9\u5e94\u6210\u50cf\u4eae\u5ea6\u548c\u56fe\u50cf\u7070\u5ea6\uff09 H\u548cS\u5408\u79f0\u8272\u5ea6 I \u5206\u91cf\u4e0e\u56fe\u50cf\u7684\u5f69\u8272\u4fe1\u606f\u65e0\u5173 H \u548c S \u5206\u91cf\u4e0e\u4eba\u611f\u53d7\u989c\u8272\u7684\u65b9\u5f0f\u7d27\u5bc6\u76f8\u8fde \u4f2a\u5f69\u8272\u5904\u7406 \u4eba\u773c\u5bf9\u5f69\u8272\u8272\u6bd4\u5bf9\u7070\u5ea6\u6709\u8f83\u5927\u7684\u5206\u8fa8\u80fd\u529b\u3002 \u4f2a\u5f69\u8272(pseudocolor)\u5904\u7406\u662f\u6307\u5bf9\u539f\u6765\u7070\u5ea6\u56fe\u50cf\u4e2d\u4e0d\u540c\u7070\u5ea6\u503c\u7684\u533a\u57df\u8d4b\u4e88\u4e0d\u540c\u7684\u989c\u8272\u3002 \u5178\u578b\u65b9\u6cd5 (1) \u4eae\u5ea6\u5207\u5272 (2) \u5229\u7528\u53d8\u6362\u51fd\u6570 (3) \u9891\u57df\u6ee4\u6ce2 1\uff09\u4eae\u5ea6\u5207\u5272 \u75281\u4e2a\u5e73\u884c\u4e8e\u56fe\u50cf\u5750\u6807\u5e73\u9762\u7684\u5e73\u9762\u53bb\u5207\u5272\u56fe\u50cf\u4eae\u5ea6\u51fd\u6570\uff0c\u4ece\u800c\u628a\u4eae \u5ea6\u51fd\u6570\u5206\u62102\u4e2a\u7070\u5ea6\u503c\u533a\u95f4\u3002 2\uff09\u4ece\u7070\u5ea6\u5230\u5f69\u8272\u7684\u53d8\u6362\uff08\u6620\u5c04\uff09 3\uff09\u9891\u57df\u6ee4\u6ce2 \u5bf9\u539f\u6765\u7070\u5ea6\u56fe\u50cf\u4e2d\u7684\u4e0d\u540c\u9891\u7387\u5206\u91cf\uff08\u53ef\u5206\u522b\u501f\u52a9\u4f4e\u901a\uff0c\u5e26\u901a/\u5e26\u963b\uff0c\u9ad8\u901a\u6ee4\u6ce2\u5668\u83b7\u5f97\uff09\u8d4b\u4e88\u4e0d\u540c\u7684\u989c\u8272 \u771f\u5f69\u8272\u5904\u7406 1\uff09\u5904\u7406\u65b9\u6cd5 \u5c06\u4e00\u5e45\u5f69\u8272\u56fe\u50cf\u770b\u4f5c\u4e09\u5e45\u5206\u91cf\u56fe\u50cf\u7684\u7ec4\u5408\u4f53\uff0c\u5148\u5206\u522b\u5355\u72ec\u5904\u7406\u6bcf\u4e00\u5e45\u5206\u91cf\u56fe\u50cf\uff0c\u518d\u5c06\u7ed3\u679c\u5408\u6210\u4e00\u5e45\u5904\u7406\u8fc7\u7684\u5408\u6210\u5f69\u8272\u56fe\u50cf \u5c06\u4e00\u5e45\u5f69\u8272\u56fe\u50cf\u4e2d\u7684\u6bcf\u4e2a\u50cf\u7d20\u770b\u4f5c\u5177\u6709\u4e09\u4e2a\u5c5e\u6027\u503c\uff0c\u5373\u5c5e\u6027\u73b0\u5728\u4e3a\u4e00\u4e2a\u77e2\u91cf\uff0c\u5229\u7528\u5bf9\u77e2\u91cf\u7684\u8868\u8fbe\u65b9\u6cd5\u8fdb\u884c\u5904\u7406 2\uff09\u5f69\u8272\u53d8\u6362 g(x,y)=T(f(x,y)) g(x,y)=T(f(x,y)) \u5176\u4e2d\uff0c\ud835\udc87(\ud835\udc99, \ud835\udc9a) \u662f\u5f69\u8272\u8f93\u5165\u56fe\u50cf\uff0c \ud835\udc88(\ud835\udc99, \ud835\udc9a) \u662f\u53d8\u6362\u540e\u7684\u5f69\u8272\u56fe\u50cf\uff0c \ud835\udc7b\u662f\u5728 (\ud835\udc99, \ud835\udc9a) \u7684\u7a7a\u95f4\u90bb\u57df\u4e0a\u5bf9\ud835\udc87\u7684\u4e00\u4e2a\u7b97\u5b50\u3002 \u5206\u91cf\u5f62\u5f0f\uff1a\ud835\udc94\ud835\udc8a = \ud835\udc7b\ud835\udc8a(\ud835\udc93\ud835\udfcf, \ud835\udc93\ud835\udfd0, \u22ef , \ud835\udc93\ud835\udc8f)\uff0c\ud835\udc8a = \ud835\udfcf, \ud835\udfd0, \u22ef , \ud835\udc8f \ud835\udc93\ud835\udc8a\u548c\ud835\udc94\ud835\udc8a\u662f\ud835\udc87 \ud835\udc99, \ud835\udc9a \u548c\ud835\udc88 \ud835\udc99, \ud835\udc9a \u5728\u4efb\u4f55\u70b9\u5904\u5f69\u8272\u5206\u91cf\u53d8\u91cf\uff0c\ud835\udc8f\u662f\u5f69\u8272\u5206\u91cf\u6570\uff1b \ud835\udc7b\ud835\udc8a\u662f\u5bf9\ud835\udc93\ud835\udc8a\u5904\u7406\u4ea7\u751f\ud835\udc94\ud835\udc8a\u7684\u6620\u5c04\u51fd\u6570\uff1b \ud835\udc8f = \ud835\udfd1\u65f6\u5019\uff0c\u662fRGB\u7a7a\u95f4\uff0c\ud835\udc8f = \ud835\udfd2\u65f6\u5019\uff0c\u662fCMYK\u7a7a\u95f4\uff0c 3\uff09\u5f69\u8272\u5f3a\u5ea6\u589e\u5f3a\u53d8\u6362 \u53d8\u6362\u589e\u5f3a \u5bf9\u4e8e\u5f69\u8272\u56fe\u50cf\u589e\u5f3a\u5176\u5f3a\u5ea6\u503c\uff0c\u5373intensity \u8981\u5224\u65ad\u989c\u8272\u6a21\u578b\uff0c\u7136\u540e\u5904\u7406 HSI\u6a21\u578b\uff0cI\u5355\u5206\u91cf\u8fdb\u884c\u589e\u5f3a\u7684\u6b65\u9aa4 (1) \u5c06R\uff0cG\uff0cB\u5206\u91cf\u56fe\u8f6c\u5316\u4e3aH\uff0cS\uff0cI\u5206\u91cf\u56fe (2) \u5229\u7528\u5bf9\u7070\u5ea6\u56fe\u589e\u5f3a\u7684\u65b9\u6cd5\u589e\u5f3a\u5176\u4e2d\u7684I\u5206\u91cf \ud835\udc94\ud835\udfd1 = \ud835\udc8c\ud835\udc93\ud835\udfd1 (3) \u518d\u5c06\u7ed3\u679c\u8f6c\u6362\u4e3aR\uff0cG\uff0cB\u5206\u91cf\u56fe RGB\u6a21\u578b\uff0c\u5f3a\u5ea6\u589e\u5f3a \u4e09\u4e2a\u5206\u91cf\u90fd\u53d8\u6362 \ud835\udc94\ud835\udc8a = \ud835\udc8c\ud835\udc93\ud835\udc8a\uff0c\ud835\udc8a = \ud835\udfcf, \ud835\udfd0, 3 4\uff09\u8865\u8272 \u5728\u8272\u73af\u4e0a\uff0c\u4e0e\u8272\u8c03\u76f4\u63a5\u76f8\u5bf9 \u7684\u53e6\u4e00\u7aef\u79f0\u4e3a\u8865\u8272 \u5728RGB\u7a7a\u95f4\uff0c \u76f4\u63a5\u6c42\u8865\uff1b \u5728HSI\u7a7a\u95f4\uff0c \u6ca1\u6709\u76f4\u63a5\u65b9\u6cd5\uff0c \u53ea\u80fd\u8fd1\u4f3c\u3002 5\uff09\u76f4\u65b9\u56fe\u5747\u8861\u5316 \u5355\u72ec\u5bf9RGB\u5f69\u8272\u56fe\u50cf\u5206\u91cf\u8fdb\u884c\u76f4\u65b9\u56fe\u5747\u8861 \u2013 \u4ea7\u751f\u4e0d\u6b63\u786e\u989c\u8272 \u5747\u5300\u5730\u5c55\u5f00\u8fd9\u79cd\u5f69\u8272\u7070\u5ea6\uff0c\u4fdd\u6301\u5f69\u8272\u672c\u8272\uff08\u8272\u8c03\uff09 \u4e0d\u53d8 \u2013 \u5728HSI\u4e2d\uff0c\u5747\u8861\u5316\u5f69\u8272\u5206\u91cfI\uff0c\u5f69\u8272\u672c\u8eab\uff08\u8272\u8c03\uff09\u4e0d\u53d8 6\uff09\u5f69\u8272\u5e73\u6ed1 \u5c06\u7070\u5ea6\u56fe\u50cf\u90bb\u57df\u5e73\u5747\u6269\u5c55\u5230\u5f69\u8272\u56fe\u50cf\uff0c\u4f7f\u7528\u5411\u91cf\u5e73\u6ed1\u7b97\u5b50 \u5bf9HSI\u6a21\u578b\u4e2d\u7684I\u901a\u9053\u8fdb\u884c\u5e73\u6ed1\uff0cH\u548cS\u901a\u9053\u4e0d\u5904\u7406\uff0c \u989c\u8272\u6ca1\u6709\u53d8\u5316\u3002 7\uff09\u5f69\u8272\u9510\u5316 8\uff09\u9971\u548c\u5ea6\u589e\u5f3a \u2013 \u65b9\u6cd5\uff1a\u8f6c\u5230HSI\u989c\u8272\u7a7a\u95f4\uff0c\u5bf9S\u901a\u9053\u8fdb\u884c\u589e\u5f3a \u2013 \u6548\u679c\uff1a \u2013 \u589e\u5927\u50cf\u7d20\u9971\u548c\u5ea6\u4f1a\u4f7f\u56fe\u50cf\u8272\u5f69\u66f4\u9c9c\u660e \u2013 \u51cf\u5c0f\u50cf\u7d20\u9971\u548c\u5ea6\u4f1a\u4f7f\u56fe\u50cf\u8272\u5f69\u611f\u51cf\u5c11\uff0c\u663e\u5f97\u5e73\u6de1 9\uff09\u8272\u8c03\u589e\u5f3a \u2013 \u65b9\u6cd5\uff1a\u8f6c\u6362\u5230HSI\u989c\u8272\u7a7a\u95f4\uff0c\u7136\u540e\u5bf9H\u8fdb\u884c\u589e\u5f3a \u6548\u679c\uff1a\u56e0\u4e3a\u8272\u8c03\u5bf9\u5e94\u4e00\u4e2a\u89d2\u5ea6 \u2013 \u5fae\u589e\u4e00\u4e2a\u5e38\u6570\uff0c\u4f1a\u4f7f\u989c\u8272\u5728\u8272\u8c31\u4e0a\u79fb\u52a8\u3002 \u2013 \u5e38\u6570\u8f83\u5c0f\u65f6\uff0c\u4f1a\u4f7f\u8272\u8c03\u53d8\u201c\u6696\u201d\u6216\u53d8\u201c\u51b7\u201d \u2013 \u5e38\u6570\u8f83\u5927\u65f6\uff0c\u4f1a\u4f7f\u5f69\u8272\u56fe\u50cf\u53d1\u751f\u5267\u70c8\u53d8\u6362 \u7b2c\u516b\u7ae0 \u5f62\u6001\u5b66\u56fe\u50cf\u5904\u7406 \u00b6 \u7ed3\u6784\u5143 \u5bf9\u6bcf\u4e2a\u7ed3\u6784\u5143\u7d20\uff0c\u5148\u8981\u6307\u5b9a\u4e00\u4e2a\u539f\u70b9\uff0c\u5b83\u662f\u7ed3\u6784\u5143\u7d20\u53c2\u4e0e \u5f62\u6001\u5b66\u8fd0\u7b97\u7684\u53c2\u8003\u70b9\u3002 \u6ce8\u610f\uff1a\u539f\u70b9\u53ef\u4ee5\u5305\u542b\u5728\u7ed3\u6784\u5143\u7d20\u4e2d\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u5305\u542b\u5728\u7ed3 \u6784\u5143\u7d20\u4e2d\uff08\u5373\u539f\u70b9\u5e76\u4e0d\u4e00\u5b9a\u8981\u5c5e\u4e8e\u7ed3\u6784\u5143\u7d20\uff09 \u5bf9\u56fe\u50cf\u64cd\u4f5c\u65f6\u8981\u6c42\u7ed3\u6784\u5143\u7d20\u662f\u77e9\u5f62\u9635\u5217\uff0c\u901a\u8fc7\u6dfb\u52a0\u6700\u5c11\u53ef\u80fd\u7684\u80cc\u666f\u5143\u7d20\u5b9e\u73b0\u3002 \u57fa\u672c\u5f62\u6001\u5b66\u64cd\u4f5c \u6620\u50cf\u548c\u4f4d\u79fb\u662f\u5f62\u6001\u5b66\u5904\u7406\u4e2d\u6269\u5c55\u7684\u96c6\u5408\u8fd0\u7b97\u3002 1\uff09\u81a8\u80c0 A\u2295B = \\{x|(B\u02c6) x \u2229 A \u2260 \\phi \\},\u02c6\u4e3a\u7ffb\u8f6c\u8fd0\u7b97 A\u2295B = \\{x|(B\u02c6) x \u2229 A \u2260 \\phi \\},\u02c6\u4e3a\u7ffb\u8f6c\u8fd0\u7b97 \u5148\u5bf9B\u505a==\u5173\u4e8e\u539f\u70b9\u7684\u6620\u8c61==\uff0c\u518d\u5c06\u5176\u6620\u8c61\u5e73\u79fbx\uff0c\u7ed3\u679c\u662f\u5e73\u79fb\u540e\u4e0eA\u4ea4\u96c6\u4e0d\u4e3a\u7a7a\u7684x\u96c6\u5408\u3002 \u5373\u4e3a\u7528B\u6765\u81a8\u80c0A\u5f97\u5230\u7684\u96c6\u5408\u662f \u7684\u4f4d\u79fb\u4e0eA\u81f3\u5c11\u6709\u4e00 \u4e2a\u975e\u96f6\u5143\u7d20\u5373\u76f8\u4ea4\u65f6B\u7684\u539f\u70b9\u4f4d\u7f6e\u7684\u96c6\u5408\u3002 2\uff09\u8150\u8680 A\u3280B = \\{x |(B)x \u2286 A \\} A\u3280B = \\{x |(B)x \u2286 A \\} B\u79fb\u52a8\u540e\u5b8c\u5168\u5305\u542b\u5728A\u4e2d\u65f6\uff0cB\u7684\u539f\u70b9\u4f4d\u7f6e\u7684\u96c6\u5408 \u4f5c\u7528\uff1a \u539f\u70b9\u5728\u7ed3\u6784\u5143\u7d20\uff08B\u4e2d\uff0c\u6536\u7f29\u56fe\u50cf\u3002 \u7ed3\u6784\u5143\u7d20\u4e0d\u5305\u542b\u539f\u70b9\u65f6\uff0c\u53ef\u4ee5\u7528\u4f5c\u586b\u5145\u5185\u90e8\u7a7a\u6d1e 3\uff09\u8150\u8680\u548c\u81a8\u80c0\u5bf9\u5076\u6027 (A\u3280B)^c=A^c\u2295B\u02c6 (A\u3280B)^c=A^c\u2295B\u02c6 \uff0c\u5176\u4e2dc\u4e3a\u53d6\u8865\u8fd0\u7b97 3\uff09\u5f00\u64cd\u4f5c \u5b9a\u4e49\uff1aB\u5bf9A\u8fdb\u884c\u7684\u5f00\u64cd\u4f5c\u5c31\u662f\u5148\u7528B\u5bf9A\u8150\u8680\uff0c\u7136\u540e\u7528B \u5bf9\u7ed3\u679c\u8fdb\u884c\u81a8\u80c0 \u4f5c\u7528\uff1a\u5f00\u64cd\u4f5c\u65ad\u5f00\u72ed\u7a84\u7684\u95f4\u65ad\u548c\u6d88\u9664\u7ec6\u7684\u7a81\u51fa\u7269 A\u2299B=(A\u3280B)\u2295B A\u2299B=(A\u3280B)\u2295B 4\uff09\u95ed\u64cd\u4f5c \u5b9a\u4e49\uff1aB\u5bf9A\u8fdb\u884c\u7684\u95ed\u64cd\u4f5c\u5c31\u662f\u5148\u7528B\u5bf9A\u81a8\u80c0\uff0c\u7136\u540e\u7528B \u5bf9\u7ed3\u679c\u8fdb\u884c\u8150\u8680 \u4f5c\u7528\uff1a\u95ed\u64cd\u4f5c\u6d88\u5f25\u72ed\u7a84\u7684\u95f4\u65ad\u548c\u957f\u7ec6\u7684\u9e3f\u6c9f\uff0c\u6d88\u9664\u5c0f\u7684\u5b54\u6d1e\uff0c\u5e76 \u586b\u8865\u8f6e\u5ed3\u7ebf\u4e2d\u5c0f\u7684\u65ad\u88c2 A\u2022B=(A\u2295B)\u3280B A\u2022B=(A\u2295B)\u3280B 5\uff09\u5f00\u548c\u95ed\u64cd\u4f5c\u6027\u8d28 (A\u2022B)^c=(A^c\u2299B\u02c6) (A\u2022B)^c=(A^c\u2299B\u02c6) (A\u2299B)\u2286A (A\u2299B)\u2286A A\u2286A\u2022B A\u2286A\u2022B 6\uff09\u51fb\u4e2d\u6216\u51fb\u4e0d\u4e2d\u53d8\u6362 \u57fa\u672c\u7684\u5f62\u6001\u5b66\u7b97\u6cd5 1\uff09\u8fb9\u754c\u63d0\u53d6 \u8bbe\u96c6\u5408A\u7684\u8fb9\u754c\u8868\u793a\u4e3a \u03b2(A)\uff0c\u9009\u53d6\u7ed3\u6784\u5143\u7d20B\uff0c\u5148\u8fdb\u884cB\u5bf9 A\u8150\u8680\uff0c\u800c\u540e\u7528A\u51cf\u53bb\u8150\u8680\u7684\u7ed3\u679c\u3002 2\uff09\u533a\u57df\u586b\u5145 3\uff09\u7ec6\u5316\u64cd\u4f5c \u63d0\u53d6\u56fe\u50cf\u7684\u4e3b\u8981\u6846\u67b6 4\uff09\u8054\u901a\u533a\u57df\u63d0\u53d6 \u65b9\u6cd5\uff1a X_k = (X_{k\u22121} \u2295 B)\u2229A X_k = (X_{k\u22121} \u2295 B)\u2229A \u76f4\u81f3 X_k X_k \u548c X_{k-1} X_{k-1} \u76f8\u540c 5\uff09\u51f8\u58f3 \u57fa\u672c\u7070\u5ea6\u7ea7\u56fe\u50cf\u6269\u5c55\u64cd\u4f5c 1\uff09\u81a8\u80c0 f\u2295b(s,t)=max\\{f(s-x,t-y)+b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} f\u2295b(s,t)=max\\{f(s-x,t-y)+b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} Df\u548cDb\u5206\u522b\u4e3a f \u548c b \u7684\u5b9a\u4e49\u57df\u3002 \u50cf\u7d20\u90fd\u5fc5\u987b\u5728\u5b9a\u4e49\u57df\u5185\uff0c\u4e0e\u96c6\u5408\u4ea4\u96c6\u4e00\u81f4 \u81a8\u80c0\u64cd\u4f5c\u7684\u7ed3\u679c\uff1a \uff08a\uff09\u5982\u679c\u7ed3\u6784\u5143 \u7d20\u7684\u503c\u90fd\u4e3a\u6b63\uff0c\u90a3\u4e48\u8f93\u51fa\u56fe\u50cf\u4f1a\u66f4\u4eae \uff08b\uff09\u6697\u7684\u7ec6\u8282\u90e8 \u5206\u7684\u53d8\u5316\u53d6\u51b3\u4e8e\u7ed3\u6784\u5143\u7d20\u7684\u503c\u548c\u5f62\u72b6 2\uff09\u8150\u8680 f\u3280b(s,t)=min\\{f(s-x,t-y)-b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} f\u3280b(s,t)=min\\{f(s-x,t-y)-b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} Df\u548cDb\u5206\u522b\u4e3a f \u548c b \u7684\u5b9a\u4e49\u57df\u3002 \u50cf\u7d20\u90fd\u5fc5\u987b\u5728\u5b9a\u4e49\u57df\u5185\uff0c\u4e0e\u7ed3\u6784\u5143\u7d20\u5fc5\u987b\u5b8c\u5168\u5305\u542b\u5728\u88ab\u8150\u8680\u7684 \u96c6\u5408\u5185\u4e00\u81f4 \u8150\u8680\u64cd\u4f5c\u7684\u7ed3\u679c\uff1a \uff08a\uff09\u5982\u679c\u7ed3\u6784\u5143\u7d20\u7684 \u503c\u90fd\u4e3a\u6b63\uff0c\u90a3\u4e48\u8f93\u51fa\u56fe\u50cf\u4f1a\u66f4\u6697 \uff08b\uff09\u4eae\u7684\u7ec6\u8282\u90e8\u5206\u7684\u53d8\u5316\u53d6\u51b3\u4e8e\u7ed3\u6784\u5143\u7d20\u7684\u503c\u548c\u5f62\u72b6 3\uff09\u5f00\u64cd\u4f5c \u5f00\u64cd\u4f5c\uff1a\u5c0f\u7684\u660e\u4eae\u7ec6\u8282\u5c3a\u5bf8\u53d8\u5c0f\uff0c\u6697\u7684\u6548\u679c\u53d7\u5f71\u54cd\u8f83\u5c0f \u95ed\u64cd\u4f5c\uff1a\u5c0f\u7684\u6697\u7ec6\u8282\u7684\u5c3a\u5bf8\u7f29\u5c0f\uff0c\u660e\u4eae\u90e8\u5206\u53d7\u5f71\u54cd\u8f83\u5c0f \u57fa\u672c\u7684\u7070\u5ea6\u7ea7\u5f62\u6001\u5b66\u7b97\u6cd5 1\uff09\u5f62\u6001\u5b66\u5e73\u6ed1 \u5148\u8fdb\u884c\u5f00\u64cd\u4f5c\uff0c\u540e\u8fdb\u884c\u95ed\u64cd\u4f5c \u8ba1\u7b97\u516c\u5f0f\u4e3a\uff1a g=(f\u2299b)\u2022b g=(f\u2299b)\u2022b 2\uff09\u5f62\u6001\u5b66\u68af\u5ea6 \u5f00\u64cd\u4f5c\u51cf\u95ed\u64cd\u4f5c \u8ba1\u7b97\u516c\u5f0f\u4e3a\uff1a g=(f\u2295b)-(f\u3280b) g=(f\u2295b)-(f\u3280b) 3\uff09\u5e3d\u53d8\u6362 \u7528\u4e00\u4e2a\u7ed3\u6784\u5143\u901a\u8fc7\u5f00\u64cd\u4f5c\u6216\u95ed\u64cd\u4f5c\u4ece\u56fe\u50cf\u4e2d\u5220\u9664\u7269\u4f53\u3002 \u7136\u540e\u5dee\u64cd\u4f5c\u5f97\u5230\u4e00\u5e45\u4ec5\u4fdd\u7559\u5df2\u5220\u9664\u5206\u91cf\u7684\u56fe\u50cf\u3002 \u9876\u5e3d\u53d8\u6362 T_{hat}(f)=f-(f\u2299b) T_{hat}(f)=f-(f\u2299b) \u7070\u5ea6\u7ea7\u56fe\u50cff\u7684\u9876\u5e3d\u53d8\u6362\u662ff\u51cf\u53bb\u5176\u5f00\u64cd\u4f5c \u9876\u5e3d\u53d8\u6362\u7528\u4e8e\u5f97\u5230\u6697\u80cc\u666f\u4e0a\u7684\u4eae\u7269\u4f53\uff08\u767d\u9876\u5e3d\uff09 \u4f4e\u5e3d\u53d8\u6362 T_{hat}(f)=(f\u2022b)-f T_{hat}(f)=(f\u2022b)-f \u7070\u5ea6\u7ea7\u56fe\u50cff\u7684\u5e95\u5e3d\u53d8\u6362\u662ff\u7684\u95ed\u64cd\u4f5c\u51cf\u53bbf \u5e95\u5e3d\u53d8\u6362\u7528\u4e8e\u5f97\u5230\u4eae\u80cc\u666f\u4e0a\u7684\u6697\u7269\u4f53\uff08\u9ed1\u5e95\u5e3d\uff09 \u5e3d\u53d8\u6362\u7684\u5e94\u7528\u6709\u6821\u6b63\u4e0d\u5747\u5300\u5149\u7167\u5f71\u54cd\u3001\u7eb9\u7406\u5206\u5272\u548c\u7c92\u5ea6\u6d4b\u5b9a\uff0c\u5177\u4f53\u4f7f\u7528\u7684\u662f\u5f00\u64cd\u4f5c\uff0c\u51cf\u5c11\u4eae\u5ea6\u8f83\u9ad8\u7684\u90e8\u5206\u3002 \u7b2c\u4e5d\u7ae0 \u56fe\u50cf\u7f16\u7801 \u00b6 \u56fe\u7247\u538b\u7f29 1\uff09\u6570\u636e\u548c\u4fe1\u606f \u6570\u636e\u662f\u4fe1\u606f\u7684\u8f7d\u4f53 \u540c\u91cf\u7684\u6570\u636e\u53ef\u8868\u8fbe\u4e0d\u4fe1\u606f\uff0c\u540c\u91cf\u7684\u4fe1\u606f\u53ef\u7528\u4e0d\u6570\u636e\u8868\u8fbe 2\uff09\u56fe\u7247\u538b\u7f29\u79cd\u7c7b \u4fe1\u606f\u4fdd\u5b58\u578b\u548c\u4fe1\u606f\u635f\u5931\u578b \u6570\u636e\u5197\u4f59 1\uff09\u5197\u4f59\u79cd\u7c7b \u5197\u4f59\u6709\u4e24\u79cd\uff0c\u5206\u522b\u4e3a\u6570\u636e\u8868\u8fbe\u4e86\u65e0\u7528\u7684\u4fe1\u606f\u548c\u6570\u636e\u8868\u8fbe\u4e86\u5df2\u8868\u8fbe\u7684\u4fe1\u606f\u3002 2\uff09\u76f8\u5bf9\u538b\u7f29\u5197\u4f59 \u76f8\u5bf9\u5197\u4f59\u516c\u5f0f\u4e3a R_D=1-\\frac{1}{C_R} R_D=1-\\frac{1}{C_R} \uff0c\u538b\u7f29\u7387\u4e3a C_R=\\frac{n_1}{n2} C_R=\\frac{n_1}{n2} \uff0c C_R C_R \u5728\u533a\u95f4 (0,+\\infty) (0,+\\infty) \u4e2d\u53d6\u503c\u3002n1\u548cn2\u4ee3\u8868\u4e24\u4e2a\u6570\u636e\u96c6\u5408\u4e2d\u7684\u4fe1\u606f\u8f7d\u4f53\u5355\u4f4d\u7684\u6570\u91cf\u3002 3\uff09\u5197\u4f59\u7684\u7c7b\u522b \u7f16\u7801\u5197\u4f59\u3001\u50cf\u7d20\u76f8\u5173\u5197\u4f59\u548c\u5fc3\u91cc\u89c6\u89c9\u5197\u4f59\u3002 \u7f16\u7801\u5197\u4f59\u548c\u4e0e\u7070\u5ea6\u5206\u5e03\u7684\u6982\u7387\u7279\u6027\u6709\u5173\u3002 \u50cf\u7d20\u76f8\u5173\u5197\u4f59\u548c\u7a7a\u95f4\u5197\u4f59\uff0c\u65f6\u95f4\u5197\u4f59\u6709\u5173\u3002 \u5fc3\u7406\u89c6\u89c9\u5197\u4f59\u548c\u4e3b\u89c2\u611f\u89c9\u6709\u5173\u3002 4\uff09\u7f16\u7801\u5197\u4f59 \u56fe\u50cf\u4e2d\u7070\u5ea6\u51fa\u73b0\u7684\u6982\u7387\uff1a p_s(s_k)=n_k/n,k=0,1,..,L-1 p_s(s_k)=n_k/n,k=0,1,..,L-1 \u5e73\u5747\u6bd4\u7279\u6570\uff1a L_{avg}=\\sum^{L-1}_{k=0}l(s_k)p_k(s_k) L_{avg}=\\sum^{L-1}_{k=0}l(s_k)p_k(s_k) \u9884\u671f\u7ed3\u679c\u4e3a\u7528\u8f83\u5c11\u7684\u6bd4\u7279\u6570\u8868\u793a\u51fa\u73b0\u6982\u7387\u8f83\u5927\u7684\u7070\u5ea6\u7ea7\uff0c\u7528\u8f83\u591a\u7684\u6bd4\u7279\u6570\u8868\u793a\u51fa\u73b0\u6982\u7387\u8f83\u5c0f\u7684\u7070\u5ea6\u7ea7 5\uff09\u50cf\u7d20\u95f4\u5197\u4f59 \u4e3b\u8981\u4f53\u73b0\u50cf\u7d20\u95f4\u76f8\u5173\u6027\uff0c\u81ea\u76f8\u5173\u7cfb\u6570\u4e3a\uff1a A(\\Delta n)=\\frac{1}{N-\\Delta n} \\sum^{N-\\Delta n-1}_{X=0}f(x,y)f(x+\\Delta n,y) A(\\Delta n)=\\frac{1}{N-\\Delta n} \\sum^{N-\\Delta n-1}_{X=0}f(x,y)f(x+\\Delta n,y) 3\uff09\u5fc3\u91cc\u89c6\u89c9\u5197\u4f59 \u4e3b\u8981\u4e0e\u4eba\u89c2\u5bdf\u56fe\u50cf\u7684\u65b9\u5f0f\u6709\u5173\uff0c\u5fc3\u7406\u89c6\u89c9\u5197\u4f59\u4e0e\u5b9e\u5728\u7684\u89c6\u89c9\u4fe1\u606f\u6709\u8054\u7cfb \u56fe\u50cf\u4fdd\u771f\u5ea6 \u63cf\u8ff0\u89e3\u7801\u56fe\u50cf\u76f8\u5bf9\u4e8e\u539f\u59cb\u56fe\u50cf\u7684\u504f\u79bb\u7a0b\u5ea6\u3002 1\uff09\u4e3b\u7ba1\u4fdd\u771f\u5ea6\u51c6\u5219 \u4e3b\u7ba1\u89c2\u6d4b\u56fe\u50cf\u7684\u8d28\u91cf\uff0c\u5e76\u5bf9\u56fe\u50cf\u505a\u51fa\u8bc4\u4ef7\uff0c\u4f8b\u5982\u4f18\u79c0\u3001\u826f\u597d\u3001\u53ef\u7528\u3001\u521a\u53ef\u770b\u3001\u5dee\u548c\u4e0d\u80fd\u7528\u3002 2\uff09\u5ba2\u89c2\u4fdd\u771f\u5ea6\u51c6\u5219 \u7528\u7f16\u7801\u8f93\u5165\u56fe\u4e0e\u89e3\u7801\u8f93\u51fa\u56fe\u7684\u67d0\u4e2a\u786e\u5b9a\u51fd\u6570\u8868\u793a\u635f\u5931\u7684\u4fe1 \u606f\u91cf\uff0c \u4fbf\u4e8e\u8ba1\u7b97\u6216\u6d4b\u91cf \u56fe\u50cf\u7f16\u7801\u6a21\u578b \u7f16\u7801\u6a21\u578b\u5206\u4e3a\u4e24\u79cd\uff1a\u4fe1\u606f\u4fdd\u5b58\u578b\u548c\u4fe1\u606f\u635f\u5931\u578b \u65e0\u5931\u771f\u4fe1\u6e90\u7f16\u7801\u5668\u4e0d\u9700\u8981\u91cf\u5316\u5668 \u56fe\u50cf\u7f16\u7801 1\uff09\u4fe1\u606f\u91cf \u6982\u7387\u4e3aP(E)\u7684\u968f\u673a\u4e8b\u4ef6E\u7684\u4fe1\u606f\u91cf\u4e3a l(E)=log\\frac{1}{P(E)}=-logP(E) l(E)=log\\frac{1}{P(E)}=-logP(E) \uff0c\u5176\u4e2dlog\u4ee52\u4e3a\u5e95\u3002 2\uff09\u7f16\u7801\u6548\u7387 \u4fe1\u606f\u71b5\u516c\u5f0f\uff1a H(u)=-\\sum^J_{j=1}p(a_i)log(P(a_i)) H(u)=-\\sum^J_{j=1}p(a_i)log(P(a_i)) \u5b9a\u4e49\u4e86\u89c2\u5bdf\u5230\u5355\u4e2a\u4fe1\u6e90\u7b26\u53f7\u8f93\u51fa\u65f6\u6240\u83b7\u5f97\u7684\u5e73\u5747\u4fe1\u606f\u91cf \u5e73\u5747\u7801\u957f\uff1a L^*_{avg}=\\sum^{J^n}_{j=1}p(a_i)*l(a_i) L^*_{avg}=\\sum^{J^n}_{j=1}p(a_i)*l(a_i) \u7f16\u7801\u6548\u7387\uff1a \\eta=\\frac{H(u)}{L^*_{avg}}*100\\% \\eta=\\frac{H(u)}{L^*_{avg}}*100\\% 3\uff09\u65e0\u635f\u7f16\u7801--\u53d8\u957f\u7f16\u7801 \u54c8\u592b\u66fc\u7f16\u7801 \u7565 \u9999\u519c-\u6cd5\u8bfa\u6bd4\u90a3\u5417 \u4e3b\u8981\u6b65\u9aa4\u4e3a\uff1a (1) \u5c06\u4fe1\u6e90\u7b26\u53f7\u4f9d\u5176\u6982\u7387\u4ece\u5927\u5230\u5c0f\u6392\u5217 (2) \u5c06\u4fe1\u6e90\u7b26\u53f7\u5206\u6210\u6982\u7387\u548c\u63a5\u8fd1\u7684\u4e24\u90e8\u5206 (3) \u5206\u522b\u7ed9\u4e24\u90e8\u5206\u7684\u4fe1\u6e90\u7b26\u53f7\u7ec4\u5408\u8d4b\u503c (4) \u5982\u679c\u4e24\u90e8\u5206\u5747\u53ea\u6709\u4e00\u4e2a\u4fe1\u6e90\u7b26\u53f7\uff0c\u7f16\u7801\u7ed3\u675f\uff0c\u5426\u5219\u8fd4\u56de(2) \u7ee7\u7eed\u8fdb\u884c \u7279\u5f81 \u4e8c\u8005\u5747\u5177\u6709\u5373\u65f6\u6027\uff0c\u6307\u5bf9\u4efb\u610f\u4e00\u4e2a\u6709\u9650\u7684\u7801\u7b26\u53f7\u4e32\uff0c\u53ef\u4ee5\u5bf9\u6bcf\u4e2a\u7801\u5b57 \u5206\u522b\u89e3\u7801\uff0c\u89e3\u7801\u65f6\u4e0d\u9700\u63a5\u6536\u540e\u9762\u7684\u6240\u6709\u7801\u5b57\u3002 \u4e8c\u8005\u5747\u5177\u6709\u552f\u4e00\u6027\uff0c\u6307\u5bf9\u4efb\u610f\u4e00\u4e2a\u6709\u9650\u957f\u7684\u7801\u7b26\u53f7\u4e32 \uff0c\u53ea\u6709\u4e00\u79cd\u5206\u89e3\u6210\u5176\u5404\u4e2a\u7801\u7b26\u53f7\u7684\u65b9\u6cd5\u3002 4\uff09\u65e0\u635f\u7f16\u7801--\u4f4d\u5e73\u9762\u7f16\u7801 \u4f4d\u5e73\u9762\u5206\u89e3 \u5c06\u591a\u7070\u5ea6\u503c\u56fe\u50cf\u5206\u89e3\u6210\u4e00\u7cfb\u5217\u4e8c\u503c\u56fe \u5bf9\u6bcf\u4e00\u5e45\u4e8c\u503c\u56fe\u518d\u7528\u4e8c\u503c\u538b\u7f29\u65b9\u6cd5\uff0c\u4e3b\u8981\u5305\u62ec\u4f4d\u5e73\u9762\u7684\u5206\u89e3\u548c\u7f16\u7801\u3002 \u4f4d\u5e73\u9762\u5206\u89e3\u662f\u6307\u5bf9\u6bcf\u4e00\u4e2a\u7070\u5ea6\u8fdb\u884c\u91cf\u5316\uff0c\u7136\u540e\u5bf9\u56fe\u7247\u8fdb\u884c\u5206\u5c42\uff0c\u5f97\u5230\u6bcf\u4e00\u5c42\u7684\u7070\u5ea6\u3002 \u5e38\u6570\u5757\u7f16\u7801 \u5e38\u6570\u5757\u7f16\u7801\u662f\u6307\u7528\u4e13\u95e8\u7684\u7801\u5b57\u8868\u8fbe\u5168\u662f0\u62161\u7684\u8fde\u901a\u533a\u57df \u5c06\u56fe\u50cf\u5206\u6210\u5168\u9ed1\uff0c\u5168\u767d\u6216\u6df7\u5408\u7684m*n\u5c3a\u5bf8\u5757\u3002 \u51fa\u73b0\u9891\u7387\u6700\u9ad8\u7684\u7c7b\u8d4b\u4e88 1 bit \u7801\u5b570\uff1b\u5176\u5b83\u4e24\u7c7b\u5206\u522b\u8d4b\u4e882 bit\u7801\u5b5710\u548c11\uff0b mn\u6bd4\u7279\u8868\u793a\u7684\u6a21\u5f0f\u3002 \u538b\u7f29\uff1a\u539f\u9700\u7528mn\u6bd4\u7279\u8868\u793a\u7684\u5e38\u6570\u5757\u4e2d\u7684\u50cf\u7d20\u73b0\u5728\u53ea \u75281 bit \u6765\u8868\u793a\u3001 1-D\u6e38\u7a0b\u7f16\u7801 5\uff09\u65e0\u635f\u7f16\u7801--\u65e0\u635f\u9884\u6d4b\u7f16\u7801 \u9884\u6d4b\u7f16\u7801\uff1a \u7a7a\u57df\u65b9\u6cd5\uff0c\u6d88\u9664\u50cf\u7d20\u95f4\u7684\u5197\u4f59\uff0c\u57fa\u672c\u601d\u60f3\u4e3a\u63d0\u53d6\u6bcf\u4e2a\u50cf\u7d20\u4e2d\u7684\u65b0\u4fe1\u606f\uff08\u5b9e\u9645\u503c\u4e0e\u9884\u6d4b\u503c\u7684\u5dee\uff09\u5e76\u5bf9\u5b83 \u4eec\u7f16\u7801\u3002 \u4e3b\u8981\u5206\u4e3a\u4e24\u79cd\uff0c\u6709\u635f\u9884\u6d4b\u7f16\u7801\u548c\u65e0\u635f\u9884\u6d4b\u7f16\u7801\u3002 \u9884\u6d4b\u7f16\u7801\u4e3b\u8981\u6d88\u9664\u4e86\u50cf\u7d20\u95f4\u5197\u4f59\u3002 6\uff09\u6709\u635f\u7f16\u7801--\u6709\u635f\u9884\u6d4b\u7f16\u7801 7\uff09\u6709\u635f\u7f16\u7801--\u53d8\u6362\u7f16\u7801 \u200b \u53d8\u6362\u7f16\u7801\u7684\u4f5c\u7528\u662f\u5c06\u7a7a\u95f4\u57df\u63cf\u8ff0\u7684\u56fe\u50cf\u4fe1\u53f7\u53d8\u6362\u5230\u9891\u7387\u57df\uff0c\u7136\u540e\u5bf9\u53d8\u6362\u540e\u7684\u7cfb\u6570\u8fdb\u884c\u7f16\u7801\u5904\u7406\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u56fe\u50cf\u5728\u7a7a\u95f4\u4e0a\u5177\u6709\u8f83\u5f3a\u7684\u76f8\u5173\u6027\uff0c\u53d8\u6362\u5230\u9891\u7387\u57df\u53ef\u4ee5\u5b9e\u73b0\u53bb\u76f8\u5173\u548c\u80fd\u91cf\u96c6\u4e2d\u3002 \u53d8\u6362\u9009\u62e9 \uff1a \u4e00\u4e2a\u80fd\u628a\u6700\u591a\u7684\u4fe1\u606f\u96c6\u4e2d\u5230\u6700\u5c11\u7684\u7cfb\u6570\u4e0a\u53bb\u7684\u53d8\u6362\u6240\u4ea7\u751f\u7684 \u91cd\u5efa\u5747\u65b9\u8bef\u5dee\u6700\u5c0f \u4e0d\u540c\u53d8\u6362\u7684\u4fe1\u606f\u96c6\u4e2d\u80fd\u529b\u4e0d\u540c \u2013 \u6b63\u5f26\u7c7b\u53d8\u6362\uff08\u5982DFT\u548cDCT\uff09\u8f83\u4f18 \u2013 \u975e\u6b63\u5f26\u7c7b\u53d8\u6362\uff08\u5982WHT: Walsh-Hadamard\uff09 \u5b9e\u73b0\u7b80\u5355 \u2013 \u5c0f\u6ce2\u53d8\u6362\u8ba1\u7b97\u5feb\u4e14\u6709\u5c40\u90e8\u6027\u8d28\uff08\u4e0d\u9700\u5206\u89e3\uff09 DCT\u662f\u8f83\u597d\u7684\uff08\u7efc\u5408\uff09\u9009\u62e9\uff0c\u96c6\u4e2d\u80fd\u529b\u5f3a\uff0c\u5e76\u4e14\u6240\u9700\u8ba1\u7b97\u91cf\u5c0f\u3002","title":"\u6570\u5b57\u56fe\u50cf\u5904\u7406"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_1","text":"","title":"\u6570\u5b57\u56fe\u50cf\u5904\u7406\u603b\u590d\u4e60"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_2","text":"\u56fe\u50cf\u548c\u6570\u5b57\u56fe\u50cf \u56fe\u50cf\u4e3a\u53ef\u4ee5\u770b\u4f5c\u662f\u5bf9\u7269\u4f53\u6216\u573a\u666f\u7684\u4e00\u79cd\u8868\u73b0\u5f62\u5f0f\uff0c\u62bd\u8c61\u5b9a\u4e49\uff1a\u4e8c\u7ef4\u51fd\u6570f(x, y) \u6570\u5b57\u56fe\u50cf\u4e3a\u79bb\u6563\u5316\u4e86\u7684\u56fe\u50cf\uff0c\u5373\u5bf9x\uff0cy \u548c f \u8fdb\u884c\u79bb\u6563\u5316 \u6570\u5b57\u56fe\u50cf\u5904\u7406\u6982\u5ff5 1.\u72ed\u4e49\uff08\u8f93\u5165\u548c\u8f93\u51fa\uff09\uff1a\u5bf9\u56fe\u50cf\u8fdb\u884c\u5404\u79cd\u52a0\u5de5\uff0c\u4ee5\u6539\u5584\u56fe\u50cf\u7684\u89c6\u89c9\u6548\u679c\u6216\u7a81\u51fa\u76ee\u6807\uff0c\u5f3a\u8c03\u56fe\u50cf\u4e4b\u95f4\u8fdb\u884c\u7684\u53d8\u6362\uff0c\u662f\u4e00\u4e2a\u4ece\u56fe\u50cf\u5230\u56fe\u50cf\u7684\u8fc7\u7a0b 2.\u5e7f\u4e49\uff1a\u4e0e\u56fe\u50cf\u76f8\u5173\u7684\u5904\u7406\uff08\u56fe\u50cf\u5206\u6790\u3001\u7406\u89e3\u548c\u673a\u5668\u89c6\u89c9\uff09 3.\u5e7f\u4e49\u4e0a\u5206\u4e3a\u4e09\u79cd\u7c7b\u578b\uff1a\u4f4e\u3001\u4e2d\u3001\u9ad8\u7ea7\u5904\u7406 \u200b 1\uff09\u4f4e\u7ea7\u5904\u7406\uff1a\u8f93\u5165\u8f93\u51fa\u90fd\u662f\u56fe\u50cf\uff08\u589e\u5f3a\uff0c\u590d\u539f\uff0c\u7f16\u7801\uff0c\u538b\u7f29\uff09 \u200b 2\uff09\u4e2d\u7ea7\u5904\u7406\uff1a\u56fe\u50cf\u5206\u5272\u53ca\u76ee\u6807\u7684\u63cf\u8ff0\uff0c\u8f93\u51fa\u662f\u76ee\u6807\u7684\u7279\u5f81\u6570\u636e \uff08\u68c0\u6d4b\uff0c\u5206\u5272\uff09 \u200b 3\uff09\u9ad8\u7ea7\u5904\u7406\uff1a\u76ee\u6807\u7269\u4f53\u53ca\u76f8\u4e92\u5173\u7cfb\u7684\u7406\u89e3\uff0c\u8f93\u51fa\u662f\u66f4\u62bd\u8c61\u7684\u6570\u636e\uff08\u5206\u7c7b\uff0c\u8bc6\u522b\uff0c\u89e3\u91ca\uff09 \u56fe\u50cf\u5904\u7406\u4e3b\u8981\u662f\u4f4e\u7ea7\u5904\u7406\u53ca\u90e8\u5206\u4e2d\u7ea7\u5904\u7406\u3002","title":"\u7b2c\u4e00\u7ae0 \u7eea\u8bba"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_3","text":"\u56fe\u50cf\u83b7\u53d6 \u4eba\u7c7b\u89c6\u89c9\u7cfb\u7edf\u3001\u5149\u548c\u7535\u78c1\u6ce2\u7406\u8bba\u662f\u6570\u5b57\u56fe\u50cf\u6765\u6e90\u7684\u57fa\u7840 \u4eae\u5ea6\u6210\u50cf\u6a21\u578b 2-D\u4eae\u5ea6\u51fd\u6570\uff1af (x, y)=r (x, y) (\u6ce8\uff1a\u53cd\u5c04\u6210\u5206) * i (x, y) (\u6ce8\uff1a\u7167\u5ea6\u6210\u5206) \u89c6\u7f51\u819c\u4e2d\u592e\u7684\u201c\u89c6\u9525\u7ec6\u80de\u89c6\u89c9\u201d\u548c\u89c6\u7f51\u819c\u8fb9\u7f18\u7684\u201c\u89c6\u6746\u7ec6\u80de\u89c6\u89c9\u201d\uff0c\u4e5f\u53eb\u505a\u660e\u89c6\u89c9\u548c\u6697\u89c6\u89c9\u3002 \u9525\u72b6\u7ec6\u80de\u8d1f\u8d23\u611f\u53d7\u989c\u8272\u4fe1\u606f\u7684\u3002 \u56fe\u50cf\u6570\u5b57\u5316 \u5c06\u4ee3\u8868\u56fe\u50cf\u7684\u8fde\u7eed(\u6a21\u62df)\u4fe1\u53f7\u8f6c\u6362\u4e3a\u79bb\u6563(\u6570\u5b57)\u4fe1\u53f7\u7684\u8fc7\u7a0b\u79f0\u4e3a\u56fe\u50cf\u6570\u5b57\u5316 \u6b65\u9aa4\uff1a\u91c7\u6837\u548c\u91cf\u5316 \u4e3b\u8981\u6280\u672f\uff1a 1) \u6210\u50cf\uff1a\u5149\u4fe1\u606f\uff0d>\u7535\u4fe1\u53f7 2) \u6a21\u6570\u8f6c\u6362\uff08A/D Converter \uff09 \u56fe\u50cf\u91c7\u6837\u548c\u91cf\u5316 \u91c7\u6837\u662f\u5747\u5300\u7684\uff0c\u91cf\u5316\u53ef\u4ee5\u5747\u5300\uff0c\u53ef\u4ee5\u975e\u5747\u5300\u3002 \u91c7\u6837\u548c\u91cf\u5316\u662f\u56fe\u50cf\u83b7\u53d6\u4e2d\u7684\u4e24\u5927\u6280\u672f\u3002 \u7a7a\u95f4\u548c\u7070\u5ea6\u5206\u8fa8\u7387\u662f\u56fe\u50cf\u7684\u57fa\u672c\u5c5e\u6027 1\uff09\u91c7\u6837 \u7a7a\u95f4\u5750\u6807\u7684\u79bb\u6563\u5316\u79f0\u4e3a\u7a7a\u95f4\u91c7\u6837\uff0c\u7b80\u79f0\u91c7\u6837\uff0c\u786e\u5b9a\u4e86\u56fe\u50cf\u7684\u7a7a\u95f4\u5206\u8fa8\u7387 \u5373\u7528\u7a7a\u95f4\u4e0a\u90e8\u5206\u70b9\u7684\u7070\u5ea6\u503c\u4ee3\u8868\u56fe\u50cf\u3002\u8fd9\u4e9b\u70b9\u79f0\u4e3a\u91c7 \u6837\u70b9 \u65b9\u5f0f\u4e3a\u70b9\u9635\u91c7\u6837\uff1a\u76f4\u63a5\u5bf9\u8868\u793a\u56fe\u50cf\u7684\u4e8c\u7ef4\u51fd\u6570\u503c\u8fdb\u884c\u91c7\u6837\uff0c \u6240\u5f97\u7684\u7ed3\u679c\u5c31\u662f\u4e00\u4e2a\u6837\u70b9\u503c\u5e8f\u5217 2\uff09\u91cf\u5316 \u5bf9\u91c7\u6837\u70b9\u4eae\u5ea6\uff08\u7070\u5ea6\uff09\u503c\u7684\u79bb\u6563\u5316\u8fc7\u7a0b\u3002\u786e\u5b9a\u4e86\u56fe\u50cf \u7684\u7070\uff08\u5e45\uff09\u5ea6\u5206\u8fa8\u7387 \u4e24\u79cd\u91cf\u5316\uff1a\u5747\u5300\u91cf\u5316\u3001\u975e\u5747\u5300\u91cf\u5316 \u5747\u5300\u91cf\u5316: \u5c06\u6837\u70b9\u7070\u5ea6\u7ea7\u503c\u7b49\u95f4\u9694\u5206\u6863\u53d6\u6574\uff0c\u79f0\u4e3a\u5747\u5300\u91cf\u5316 \u975e\u5747\u5300\u91cf\u5316: \u5c06\u6837\u70b9\u7070\u5ea6\u7ea7\u503c\u4e0d\u7b49\u95f4\u9694\u5206\u6863\u53d6\u6574 3\uff09\u91c7\u6837\u548c\u91cf\u5316\u7684\u7ea7\u6570 \u5047\u5b9a\u56fe\u50cf\u53d6M\u00d7N\u4e2a\u91c7\u6837\u70b9\uff0c\u5bf9\u6837\u672c\u70b9\u7070\u5ea6\u503c\u8fdb\u884cG\u7ea7\u5206\u6863\u53d6\u6574 \u2013 M, N, G \u4e00\u822c\u53d62\u7684\u6574\u6570\u6b21\u5e42 \u2013M= 2^m 2^m \uff1bN= 2^n 2^n \uff1bG= 2^k 2^k \u50cf\u7d20\u7a7a\u95f4\u7684\u5173\u7cfb 1\uff09\u50cf\u7d20\u7684\u90bb\u57df\u4e0e\u8fde\u63a5 \u90bb\u63a5---\u50cf\u7d20\u95f4\u7684\u7a7a\u95f4\u5173\u7cfb \u2460 \u56db\u90bb\u57df N_4(p),p(x,y)=(x+1,y),(x-1,y),(x,y+1),(x,y-1) N_4(p),p(x,y)=(x+1,y),(x-1,y),(x,y+1),(x,y-1) \u2461 \u5bf9\u89d2\u90bb\u57df N_D(p):p(x,y)=(x-1,y-1),(x+1,y-1),(x-1,y+1),(x+1,y+1) N_D(p):p(x,y)=(x-1,y-1),(x+1,y-1),(x-1,y+1),(x+1,y+1) \u2462 8-\u90bb\u57df N_8(P):p(x,y)=N_4(p)+N_D(p) N_8(P):p(x,y)=N_4(p)+N_D(p) 2\uff09\u8fde\u63a5 \u8fde\u63a5\uff1a\u7a7a\u95f4\u4e0a\u90bb\u63a5\u4e14\u50cf\u7d20\u7070\u5ea6\u503c\u76f8\u4f3c \u4e24\u4e2a\u50cf\u7d20\u662f\u5426\u8fde\u63a5\uff1a (1) \u662f\u5426\u63a5\u89e6\uff08\u90bb\u63a5\uff09 (2) \u7070\u5ea6\u503c\u662f\u5426\u6ee1\u8db3\u67d0\u4e2a\u7279\u5b9a\u7684\u76f8\u4f3c\u51c6\u5219 \u7070\u5ea6\u503c\u76f8\u7b49 \u6216 \u540c\u5728\u4e00\u4e2a\u7070\u5ea6\u503c\u96c6\u5408\u4e2d \u4e09\u79cd\u8fde\u63a5\u65b9\u5f0f\uff0c\u5047\u8bbeV\u4e3a\u7070\u5ea6\u503c\u96c6\u5408 \u2460 4-\u8fde\u63a5 2\u4e2a\u50cf\u7d20 p \u548c r \u5728V \u4e2d\u53d6\u503c \u4e14 r \u5728N4 (p)\u4e2d \u2461 8-\u8fde\u63a5 2\u4e2a\u50cf\u7d20 p \u548c r \u5728V \u4e2d\u53d6\u503c \u4e14 r \u5728N8 (p)\u4e2d \u2462 m-\u8fde\u63a5\uff08\u6df7\u5408\u8fde\u63a5\uff09 2\u4e2a\u50cf\u7d20 p \u548c r \u5728V \u4e2d\u53d6\u503c\uff0c\u4e14\u6ee1\u8db3\u4e0b\u5217\u6761\u4ef6\u4e4b\u4e00 (a) r \u5728 N_4 (p) N_4 (p) \u4e2d (b) r \u5728 N_D (p) N_D (p) \u4e2d\u4e14\u96c6\u5408 N_4 (p) \u2229 N_4 (r) N_4 (p) \u2229 N_4 (r) \u662f\u7a7a\u96c6 \uff08\u8fd9\u4e2a\u96c6\u5408\u662f\u7531 p \u548c r \u7684\u5728V\u4e2d\u53d6\u503c\u76844-\u8fde\u63a5\u50cf\u7d20\u7ec4\u6210\u7684\uff09 3\uff09\u8fde\u901a\u6027 \u50cf\u7d20\u7684\u8fde\u901a \u2013 \u53cd\u6620\u4e24\u4e2a\u50cf\u7d20\u95f4\u7684\u7a7a\u95f4\u5173\u7cfb \u901a\u8def\u548c\u8fde\u901a\uff0c\u79cd\u7c7b\u5206\u4e3a\u56db\u8fde\u901a\uff0c\u516b\u8fde\u901a\uff0cm\u8fde\u901a 4\uff09\u8ddd\u79bb\u5ea6\u91cf \u8ddd\u79bb\u51fd\u6570\u5b9a\u4e49\uff1a \u5bf9\u4e8e\u50cf\u7d20p, q\u548cz, \u5206\u522b\u5177\u6709\u5750\u6807(x, y), (s, t), (u, v), \u5982\u679c\uff1a (a) D(p, q)\u22650 [D(p, q)= 0, \u5f53\u4e14\u4ec5\u5f53 p=q] (b) D(p, q)= D(q, p) \u00a9 D(p, z) \u2264 D(p, q) + D(q, z) \u5219D\u662f\u8ddd\u79bb\u51fd\u6570\u6216\u5ea6\u91cf \u2460 \u6b27\u6c0f\u8ddd\u79bb D_e(p,q)=[(x-s)^2+(y-t)^2]^{1/2} D_e(p,q)=[(x-s)^2+(y-t)^2]^{1/2} \u2461 D4\u8ddd\u79bb\uff08\u57ce\u5e02\u8ddd\u79bb\uff09 D_4( p,q) = |x \u2212 s| + |y \u2212t| D_4( p,q) = |x \u2212 s| + |y \u2212t| \u2462 D8\u8ddd\u79bb\uff08\u68cb\u76d8\u8ddd\u79bb\uff09 D_8(p,q) = max(|x \u2212 s|,| y \u2212t|) D_8(p,q) = max(|x \u2212 s|,| y \u2212t|) \u6ce8\u610f\uff1a De\u8ddd\u79bb\u4e0e\u50cf\u7d20\u7684\u70b9\u5750\u6807\u76f8\u5173\uff0c\u4e0e\u50cf\u7d20\u95f4\u7684\u8fde\u901a\u6027\u65e0\u5173 D4\u548cD8\u8ddd\u79bb\u53ef\u4ee5\u770b\u4f5c\u662f\u901a\u8def\u4e0a\u8fde\u63a5\u7684\u6570\u76ee\u6700\u5c0f\u503c \u5bf9\u4e8eD4\u3001D8\u548cDm\uff0c\u5982\u679c\u50cf\u7d20p\u548cq\u95f4\u65e0\u8fde\u63a5\uff0c\u5219\u8ddd\u79bb\u662f\u65e0\u7a77\u5927 \u4ee5\u540e\u7684\u8ddd\u79bb\u9690\u542b\u8fde\u901a\u6027 \u56fe\u50cf\u7684\u8fd0\u7b97 \u52a0\u6cd5\uff1aC(x, y) = A(x, y) + B(x, y) \u51cf\u6cd5\uff1aC(x, y) = A(x, y) - B(x, y) \u4e58\u6cd5\uff1aC(x, y) = A(x, y) * B(x, y) \u6c42\u53cd\uff1ag(x, y) = 255 - f(x, y) \u5f02\u6216\uff1ag(x, y) = f(x, y) \u2295 h(x, y) \u6216\u8fd0\u7b97\uff1ag(x, y) = f(x, y) | h(x, y) \u4e0e\u8fd0\u7b97\uff1a g(x, y) = f(x, y) & h(x, y) \u56fe\u50cf\u5185\u63d2 \u56fe\u50cf\u5185\u63d2\uff1a\u653e\u5927\uff0c\u6536\u7f29\uff0c\u65cb\u8f6c\uff0c\u51e0\u4f55\u77eb\u6b63 \u653e\u5927\u8fc7\u7a0b\uff1a \u00bb \u539f\u6765\u56fe\u50cf\u5206\u8fa8\u7387\u4e3am\u00d7n \u00bb \u5c06\u56fe\u50cf\u653e\u59271.5\u500d\u4e4b\u540e\uff0c\u5177\u67091.5m\u00d71.5n= 2.25m\u00d7n\u4e2a\u50cf\u7d20 \u00bb \u4e0e\u539f\u6765\u56fe\u50cf\u5177\u6709\u76f8\u540c\u7684\u50cf\u7d20\uff0c\u50cf\u7d20\u6570\u91cf\u662f\u539f\u67652.25\u500d \u00bb \u5c06\u5176\u6536\u7f29\uff0c\u4e0e\u539f\u6765\u56fe\u50cf\u5339\u914d \u00bb \u50cf\u7d20\u95f4\u9694\u5c0f\u4e8e\u539f\u6765\u56fe\u50cf\u50cf\u7d20\u95f4\u9694 \u00bb \u4ece\u539f\u6765\u56fe\u50cf\u50cf\u7d20\u503c\u63d0\u53d6\u4fe1\u606f\u8d4b\u7ed9\u65b0\u56fe\u50cf\u76f8\u5e94\u50cf\u7d20 \u56fe\u50cf\u5185\u63d2\u7684\u4e3b\u8981\u65b9\u6cd5 \u6700\u8fd1\u90bb\u5185\u63d2\u6cd5 \u53cc\u7ebf\u6027\u5185\u63d2\u6cd5 \u53cc\u4e09\u6b21\u5185\u63d2\u6cd5\u3002 \u56fe\u50cf\u7cfb\u7edf \u56fe\u50cf\u5904\u7406\u7cfb\u7edf\u5177\u6709\u56fe\u50cf\u8f93\u5165\u3001\u8f93\u51fa\u3001\u5b58\u50a8\u548c\u5904\u7406\u529f\u80fd\u3002 \u56fe\u50cf\u4e4b\u95f4\u7684\u56db\u5219\u8fd0\u7b97\uff0c\u53ea\u8981\u76f4\u63a5\u8fd0\u7b97\u5c31\u884c\u3002--\u9700\u5bf9\u8d85\u51fa\u7070\u5ea6\u8303\u56f4\u7684\u50cf\u7d20\u8fdb\u884c\u5904\u7406\u3002","title":"\u7b2c\u4e8c\u7ae0 \u6570\u5b57\u56fe\u50cf\u57fa\u7840"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_4","text":"\u7a7a\u57df\u589e\u5f3a\u57fa\u7840 \ud835\udc88(\ud835\udc99, \ud835\udc9a)= \ud835\udc7b[\ud835\udc87(\ud835\udc99, y)] \ud835\udc88(\ud835\udc99, \ud835\udc9a)= \ud835\udc7b[\ud835\udc87(\ud835\udc99, y)] \u5176\u4e2d\ud835\udc87(\ud835\udc99, \ud835\udc9a) \u662f\u8f93\u5165\u56fe\u50cf\uff0c \ud835\udc88(\ud835\udc99, \ud835\udc9a) \u662f\u5904\u7406\u540e\u56fe\u50cf \ud835\udc7b\u662f\u5728\u70b9 (\ud835\udc99, \ud835\udc9a) \u90bb\u57df\u4e0a\u5b9a\u4e49\u7684\u5173\u4e8e\ud835\udc87\u7684\u589e\u5f3a\u64cd\u4f5c\u3002 \u7a7a\u57df\u589e\u5f3a\u8ba1\u7b97\u8fc7\u7a0b\uff1a-\u904d\u5386\u56fe\u50cf\u6240\u6709\u50cf\u7d20 \u2013 \u6bcf\u4e2a\u50cf\u7d20\u5904\uff0c\u7528T\u8ddf\u4ee5(x,y)\u4e3a\u4e2d\u5fc3\u7684\u90bb\u57df\u8fdb\u884c\u8ba1\u7b97 \u2013 \u8fb9\u7f18\u5904\u7406\uff1a\u586b\u96f6 \u76f4\u63a5\u7070\u5ea6\u6620\u5c04 \u5c06 f (x, y)\u4e2d\u7684\u6bcf\u4e2a\u50cf\u7d20\u7070\u5ea6\u6309\ud835\udc7b\u64cd\u4f5c\u76f4\u63a5\u53d8\u6362\u4ee5\u5f97\u5230 g(x, y) \u5178\u578b\u65b9\u6cd5\uff1a \u5bf9\u6570\u53d8\u6362 s=c*log(r+1) s=c*log(r+1) \u6307\u6570\u53d8\u6362 s=cr^{\\gamma} s=cr^{\\gamma} \u03b3>1\u4f4e\u7070\u5ea6\u538b\u7f29\uff0c\u9ad8\u7070\u5ea6\u62c9\u4f38 \u03b3<1\u4f4e\u7070\u5ea6\u62c9\u4f38\uff0c\u9ad8\u7070\u5ea6\u538b\u7f29 \u03b3=1\u5c31\u662f\u6052\u7b49\u53d8\u6362 \u76f4\u65b9\u56fe\u53d8\u6362 \u76f4\u65b9\u56fe\uff08Histogram \uff09 \u6570\u5b57\u56fe\u50cf\u4e2d\u6bcf\u4e00\u7070\u5ea6\u7ea7\uff0c\u5b83\u51fa\u73b0\u7684\u9891\u6570\u7684\u7edf\u8ba1 \u63d0\u4f9b\u4e86\u56fe\u50cf\u50cf\u7d20\u7684\u7070\u5ea6\u503c\u5206\u5e03\u60c5\u51b5 1\uff09\u76f4\u65b9\u56fe\u5747\u8861\u5316 \u76f4\u65b9\u56fe\u5747\u8861\u5316\uff1a\u6307\u56fe\u50cf\u7ecf\u7070\u5ea6\u53d8\u6362\u540e\uff0c\u4f7f\u5f97\u7070\u5ea6\u7684\u6982\u7387\u5bc6\u5ea6\u5206\u5e03\u53d8\u4e3a\u5e38 \u6570\uff0c\u5373\u5747\u5300\u5206\u5e03 \u6ce8\uff1a\u5728\u8be5\u76f4\u65b9\u56fe\u4e2d\uff0c\u5171\u67098\u949f\u7070\u5ea6\uff0c\u5373L=8\u3002 2\uff09\u76f4\u65b9\u56fe\u89c4\u5b9a\u5316 \u901a\u8fc7\u6307\u5b9a\u7684\u51fd\u6570\u5c06\u539f\u56fe\u50cf\u7684\u7070\u5ea6\u76f4\u65b9\u56fe\u53d8\u6362\u6210\u53e6\u4e00\u79cd\u5206\u5e03\u7684\u7070\u5ea6\u76f4\u65b9\u56fe\uff0c\u5373\u786e\u5b9a\u4e00\u4e2aT\u51fd\u6570\uff0c\u6839\u636e\u8fd9\u4e2a\u76f4\u65b9\u56fe\u786e\u5b9a\u4e00\u7070\u5ea6\u7ea7\u53d8\u6362 T\u00ae, \u4f7f\u7531 T\u4ea7\u751f\u7684 \u65b0\u56fe\u8c61\u7684\u76f4\u65b9\u7b26\u5408\u6307\u5b9a\u7684\u76f4\u65b9\u56fe\u3002 3\uff09\u5c40\u90e8\u76f4\u65b9\u56fe\u5904\u7406 \u6709\u65f6\u9700\u8981\u5bf9\u56fe\u50cf\u5c0f\u533a\u57df\u7ec6\u8282\u7684\u5c40\u90e8\u589e\u5f3a\u3002\u89e3\u51b3\u7684\u529e\u6cd5\u5c31\u662f\u5728\u56fe\u50cf\u4e2d\u6bcf\u4e00\u4e2a\u7d20\u7684\u90bb\u57df\u5c31\u662f\u5728\u56fe\u50cf\u4e2d\uff0c\u6839\u636e\u7070\u5ea6\u7ea7\u5206\u5e03 \u8bbe\u8ba1\u53d8\u6362\u51fd\u6570\u3002\u7136\u540e\u5229\u7528\u524d\u9762\u4ecb\u7ecd\u7684\u6280\u672f\u6765\u8fdb\u884c\u5c40\u90e8\u589e\u5f3a\u3002 \u7ebf\u6027\u6ee4\u6ce2 \u6ee4\u6ce2\u5668\u53ef\u5206\u4e3a\u7ebf\u6027\u6ee4\u6ce2\u5668\u548c\u975e\u7ebf\u6027\u6ee4\u6ce2\u5668\uff0c\u9510\u5316\u548c\u5e73\u6ed1\u3002 \u975e\u7ebf\u6027\u6ee4\u6ce2\u5668\u4f5c\u7528\uff1a\u65e2\u6d88\u9664\u566a\u58f0\u53c8\u4fdd\u6301\u7ec6\u8282\uff08\u4e0d\u6a21\u7cca\uff09 \u5e38\u89c1\u6ee4\u6ce2\u5668\uff1a \u90bb\u57df\u5e73\u5747 --\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u6a21\u7248\u7cfb\u6570\u90fd\u662f\u6b63\u7684\uff0c\u4fdd\u6301\u7070\u5ea6\u503c\u8303\u56f4\uff08\u7cfb\u6570\u4e4b\u548c\u4e3a1\uff09 z=\\frac{1}{M} \\sum ^{M-1}_{i=0} (k_i*s_i) z=\\frac{1}{M} \\sum ^{M-1}_{i=0} (k_i*s_i) M\u7684\u5927\u5c0f\u4e0d\u540c\uff0c\u5e73\u6ed1\u7684\u6548\u679c\u4e5f\u4e0d\u540c\u3002 \u6a21\u677f\u5c3a\u5bf8\u589e\u5927\u65f6\uff0c\u5bf9\u566a\u58f0\u6d88\u9664\u6548\u679c\u589e\u5f3a\uff0c\u4f46\u56fe\u50cf\u53d8\u5f97\u6a21\u7cca\uff0c\u5373\u8fb9\u7f18\u7ec6\u8282\u51cf\u5c11\u3002 \u52a0\u6743\u5e73\u5747 --\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u4e0d\u540c\u4f4d\u7f6e\u7684\u7cfb\u6570\u91c7\u7528\u4e0d\u540c\u7684\u503c\uff0c\u4e00\u822c\u8ba4\u4e3a\uff1a\u79bb\u6a21\u677f\u4e2d\u5fc3\u8fd1\u7684\u50cf\u7d20\u5bf9\u6ee4\u6ce2\u8d21\u732e\u5927\uff0c\u6240\u4ee5\u7cfb\u6570\u5927\uff1b \u800c\u5468\u56f4\u7cfb\u6570\u5c0f\u3002 \u4e2d\u503c\u6ee4\u6ce2\u5668 --\u975e\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u5c06\u6a21\u677f\u4e2d\u5fc3\u4e0e\u50cf\u7d20\u4f4d\u7f6e\u91cd\u5408\uff0c\u8bfb\u53d6\u6a21\u677f\u4e0b\u5404\u5bf9\u5e94\u50cf\u7d20\u7684\u7070\u5ea6\u503c\uff0c\u5c06\u8fd9\u4e9b\u7070\u5ea6\u503c\u4ece\u5c0f\u5230\u5927\u6392\u6210 1\u5217\uff0c\u627e\u51fa\u8fd9\u4e9b\u503c\u91cc\u6392\u5728\u4e2d\u95f4\u7684 1\u4e2a\uff0c\u5c06\u8fd9\u4e2a\u4e2d\u95f4\u503c\u8d4b\u7ed9\u6a21\u677f\u5fc3\u4f4d\u7f6e\u50cf\u7d20\u3002 \u4e2d\u503c\u6ee4\u6ce2\u5668\u7684\u6d88\u566a\u58f0\u6548\u679c\u4e0e\u6a21\u677f\u7684\u5c3a\u5bf8\u548c\u53c2\u4e0e\u8fd0\u7b97\u7684\u50cf\u7d20\u6570\u6709\u5173\u3002 \u56fe\u50cf\u4e2d\u5c3a\u5bf8\u5c0f\u4e8e\u6a21\u677f\u5c3a\u5bf8\u4e00\u534a\u7684\u8fc7\u4eae\u6216\u8fc7\u6697\u533a\u57df\u5c06\u4f1a\u5728\u6ee4\u6ce2\u540e\u4f1a\u88ab\u6d88\u9664\u6389\u3002 \u767e\u5206\u6bd4\u6ee4\u6ce2\u5668 --\u975e\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u6700\u5927\u503c\u6ee4\u6ce2\u5668\uff1a g_{max}(x,y)=max_{(s,t)\u2208N(x,y)}[f(s,t)] g_{max}(x,y)=max_{(s,t)\u2208N(x,y)}[f(s,t)] \u6700\u5c0f\u503c\u6ee4\u6ce2\u5668\uff1a g_{min}(x,y)=min_{(s,t)\u2208N(x,y)}[f(s,t)] g_{min}(x,y)=min_{(s,t)\u2208N(x,y)}[f(s,t)] \u4e2d\u70b9\u6ee4\u6ce2\u5668\uff1a g_{mid}(x,y)=\\frac{1}{2}(g_{max}(x,y)+g_{min}(x,y)) g_{mid}(x,y)=\\frac{1}{2}(g_{max}(x,y)+g_{min}(x,y)) \u68af\u5ea6\u6ee4\u6ce2\u5668 --\u975e\u7ebf\u6027\u9510\u5316\u6ee4\u6ce2\u5668 \u5404\u5411\u5f02\u6027\uff0c\u5728X\u548cY\u4e24\u4e2a\u65b9\u5411\u4e0d\u540c\u3002 \u200b \u68af\u5ea6\u66ff\u4ee3\u8ba1\u7b97\u65b9\u6cd5 \u62c9\u666e\u62c9\u65af\u7b97\u5b50\uff0c\u4e8c\u9636\u5bfc\u6570 --\u975e\u7ebf\u6027\u9510\u5316\u6ee4\u6ce2\u5668 \u5fae\u5206\u7b97\u5b50\uff0c\u4f7f\u7528\u540e\u589e\u5f3a\u4e86\u56fe\u50cf\u4e2d\u7070\u5ea6\u7684\u7a81\u53d8\uff0c\u4e0d\u7ea7\u7f13\u6162\u53d8\u5316\u533a\u57df \u628a\u539f\u56fe\u50cf\u4e0e laplace laplace \u56fe\u50cf\u7ebf\u6027\u7ec4\u5408\uff0c\u53ef\u4ee5\u540c\u65f6\u4fdd\u6301 laplace laplace laplace\u9510\u5316\u548c\u539f\u56fe\u50cf\u80cc\u666f\u3002 \u5982\u679c laplace \u7b97\u5b50\u4e2d\u5fc3\u7cfb\u6570\u4e3a\u6b63\uff0c\u5219\u7528\u539f\u56fe\u50cf\u52a0\u4e0a laplace \u56fe\u50cf\uff1b \u5982\u679c laplace \u7b97\u5b50\u4e2d\u5fc3\u7cfb\u6570\u4e3a\u8d1f\uff0c\u5219\u7528\u539f\u56fe\u50cf\u51cf\u53bb laplace\u56fe\u50cf\u3002 \u5c40\u90e8\u589e\u5f3a \u7a7a\u95f4\u57df\u5c40\u90e8\u589e\u5f3a-\u5c40\u90e8\u9009\u62e9\u6839\u636e\u5b9e\u9645\u95ee\u9898\u8981\u6c42\u7075\u6d3b\u8bbe\u5b9a\u3002 \u5bf9\u56fe\u50cf\u5c40\u90e8\u7ec6\u8282\u7684\u589e\u5f3a\u5904\u7406 \u56fe\u50cf\u7684\u7edf\u8ba1\u91cf\uff1a \u7070\u5ea6\u5e73\u5747\u503c m=\\sum^{L-1}_{i=0}r_i*p(r_i) m=\\sum^{L-1}_{i=0}r_i*p(r_i) \u65b9\u5dee\uff08\u4e8c\u9636\u77e9\uff09 \\mu_2(r)=\\sum^{L-1}_{i=0}(r_i-m)^2p(r_i) \\mu_2(r)=\\sum^{L-1}_{i=0}(r_i-m)^2p(r_i) r\u7684n\u9636\u77e9\uff1a \\mu_n(r)=\\sum^{L-1}_{i=0}(r_i-m)^np(r_i) \\mu_n(r)=\\sum^{L-1}_{i=0}(r_i-m)^np(r_i) \u5c40\u90e8\u589e\u5f3a\u7684\u65b9\u6cd5\uff1a g(x,y)=A(x,y)[f(x,y)-m(x,y)]+m(x,y),\u5176\u4e2dA(x,y)=\\frac{k*M}{\\sigma(x,y)} g(x,y)=A(x,y)[f(x,y)-m(x,y)]+m(x,y),\u5176\u4e2dA(x,y)=\\frac{k*M}{\\sigma(x,y)} M\u4e3af(x,y)\u7684\u5747\u503c,m(x,y)\u548c\\sigma(x,y)\u4e3a\u4ee5(x,y)\u4e3a\u4e2d\u5fc3\u90bb\u57df\u5185\u7684\u5747\u503c\u548c\u5747\u65b9\u5dee\u503c M\u4e3af(x,y)\u7684\u5747\u503c,m(x,y)\u548c\\sigma(x,y)\u4e3a\u4ee5(x,y)\u4e3a\u4e2d\u5fc3\u90bb\u57df\u5185\u7684\u5747\u503c\u548c\u5747\u65b9\u5dee\u503c \u57fa\u4e8e\u5c40\u90e8\u7edf\u8ba1\u7684\u589e\u5f3a\u65b9\u6cd5\uff1a \u4ee4 (x,y) (x,y) \u4e3a\u4e00\u50cf\u7d20\u5750\u6807\uff0c S_{xy} S_{xy} \u8868\u793a\u4e00\u786e\u5b9a\u5927\u5c0f\u7684\u90bb\u57df\uff08\u5b50\u56fe\u50cf\uff09\uff0c\u5219 S_{xy} S_{xy} \u7684\u5e73\u5747\u503c m_{xy} m_{xy} \u4e3a\uff1a m_{xy}=\\sum_{(s,t)\u2208(S_{xy}))}(r_{s,t}\u00d7p(r_{s,t})) m_{xy}=\\sum_{(s,t)\u2208(S_{xy}))}(r_{s,t}\u00d7p(r_{s,t})) S_{xy} S_{xy} \u4e2d\u50cf\u7d20\u7684\u65b9\u5dee\u4e3a\uff1a \\sigma^2_{S_{xy}}=\\sum^{(L-1)}_{(s,t)\u2208S_{xy}}\\{[r_{s,t}-m_{s_{xy}}]^2\u00d7p(s_{s,t})\\} \\sigma^2_{S_{xy}}=\\sum^{(L-1)}_{(s,t)\u2208S_{xy}}\\{[r_{s,t}-m_{s_{xy}}]^2\u00d7p(s_{s,t})\\} \u6839\u636e\u4eae\u6697\u548c\u5bf9\u6bd4\u5ea6\u6765\u5224\u65ad\u662f\u5426\u589e\u5f3a\u67d0\u4e00\u70b9\u7684\u4eae\u5ea6\uff0c\u7136\u540e\u5bf9\u5176\u8fdb\u884c\u589e\u5f3a \u4ee4\u6761\u4ef6T=m_{s_{xy}}<=k_0*M_G,k_0<=1.0\u4e14k_1D_G<=\\sigma_{S_{xy}}<=k_2D_G,k_1<=k_2 \u4ee4\u6761\u4ef6T=m_{s_{xy}}<=k_0*M_G,k_0<=1.0\u4e14k_1D_G<=\\sigma_{S_{xy}}<=k_2D_G,k_1<=k_2 g(x,y)=T?E*f(x,y):f(x,y) g(x,y)=T?E*f(x,y):f(x,y)","title":"\u7b2c\u4e09\u7ae0 \u7a7a\u57df\u589e\u5f3a\u6280\u672f"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_5","text":"\u5085\u91cc\u53f6\u53d8\u6362 \u65f6\u57df\u56fe\u50cf\u662f\u4e00\u4e2a\u5468\u671f\u4e14\u8fde\u7eed\u7684\u51fd\u6570\uff0c\u9891\u57df\u56fe\u50cf\u548c\u76f8\u4f4d\u56fe\u50cf\u662f\u4e00\u4e2a\u975e\u5468\u671f\u79bb\u6563\u7684\u51fd\u6570\u3002 \u6b27\u62c9\u516c\u5f0f\uff1a e^{ix}=cos(x)+i*sin(x) e^{ix}=cos(x)+i*sin(x) \u5085\u91cc\u53f6\u53d8\u6362\u7684\u5b9a\u4e49 1\uff09\u4e00\u7ef4\u5085\u91cc\u53f6\u53d8\u6362 \u8fde\u7eed\u51fd\u6570 \u6b63\u53d8\u6362 F\\{f(x)\\}=F(u)=\\int^{+\\infty}_{-\\infty}f(x)e^{-j2*\\pi ux}dx F\\{f(x)\\}=F(u)=\\int^{+\\infty}_{-\\infty}f(x)e^{-j2*\\pi ux}dx \u9006\uff08\u53cd\uff09\u53d8\u6362 f(x)=\\int^{+\\infty}_{-\\infty}F(u)e^{j*2\\pi ux}du f(x)=\\int^{+\\infty}_{-\\infty}F(u)e^{j*2\\pi ux}du \u79bb\u6563\u51fd\u6570 \u6b63\u53d8\u6362 F\\{f(x)\\}=F(u)=\\sum^{N-1}_{x=0}f(x)e^{-2j\\pi ux/N} F\\{f(x)\\}=F(u)=\\sum^{N-1}_{x=0}f(x)e^{-2j\\pi ux/N} \u9006\uff08\u53cd\uff09\u53d8\u6362 F^{-1}\\{f(x)\\}=f(x)=\\frac{1}{N}\\sum^{N-1}_{x=0}F(u)e^{2j\\pi ux} F^{-1}\\{f(x)\\}=f(x)=\\frac{1}{N}\\sum^{N-1}_{x=0}F(u)e^{2j\\pi ux} u=0,1,2,...,N-1 u=0,1,2,...,N-1 2\uff09\u4e8c\u7ef4\u5085\u91cc\u53f6\u53d8\u6362 \u8fde\u7eed\u51fd\u6570 \u6b63\u53d8\u6362 F\\{f(x,y)\\}=F(u,v)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} f(x,y)e^{-j2\\pi ux}dxdy F\\{f(x,y)\\}=F(u,v)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} f(x,y)e^{-j2\\pi ux}dxdy \u9006\uff08\u53cd\uff09\u53d8\u6362 F^{-1}\\{f(x,y)\\}=f(x,y)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} F(u,v)e^{j2\\pi ux}dudv F^{-1}\\{f(x,y)\\}=f(x,y)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} F(u,v)e^{j2\\pi ux}dudv \u79bb\u6563\u51fd\u6570 \u6b63\u53d8\u6362 F(u,v)=\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} f(x,y) e^{-j2\\pi (ux/M+vy/N)} F(u,v)=\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} f(x,y) e^{-j2\\pi (ux/M+vy/N)} u=0,1,2,...,M-1,v=0,1,2,...,N-1 u=0,1,2,...,M-1,v=0,1,2,...,N-1 \u9006\u53d8\u6362 f(x,y)=\\frac{1}{MN}\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} F(u,v) e^{j2\\pi (ux/M+vy/N)} f(x,y)=\\frac{1}{MN}\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} F(u,v) e^{j2\\pi (ux/M+vy/N)} x=0,1,2,...,M-1,y=0,1,2,...,N-1 x=0,1,2,...,M-1,y=0,1,2,...,N-1 3\uff09\u9891\u8c31\u57df \u5b9a\u4e49\uff1a\u7531\u5085\u7acb\u53f6\u53d8\u6362\u548c\u9891\u7387\u53d8\u91cf( u, v)\u5b9a\u4e49\u7684\u7a7a\u95f4 \u6027\u8d28\uff1a \u53d8\u6362\u6700\u6162\u7684\u9891\u7387\u6210\u5206(u=0,v=0)\u5bf9\u5e94\u4e00\u5e45\u56fe\u50cf\u7684\u5e73\u5747\u7070\u5ea6\uff0c\u8bc1\u660e\u4e3a\uff1a F(0,0)=\\sum_{x=0}^{M-1}\\sum^{N-1}_{y=0}f(x,y) F(0,0)=\\sum_{x=0}^{M-1}\\sum^{N-1}_{y=0}f(x,y) \u5373 F(0,0)=mean(f(x,y))*M*N F(0,0)=mean(f(x,y))*M*N \uff0c\u6240\u4ee5 |F(0,0)| |F(0,0)| \u662f\u9891\u8c31\u7684\u6700\u5927\u5206\u91cf\u3002 \u9891\u57df\u6709\u67d0\u4e00\u65b9\u5411\u7684\u4eae\u7ebf\u6761\uff0c\u8bf4\u660e\u56fe\u50cf\u4e2d\u4e0e\u4e4b\u5782\u76f4\u65b9\u5411\u4e0a\u6709\u8f83\u591a\u7ebf\u6761\u3002 \u5085\u91cc\u53f6\u53d8\u6362\u662f\u5171\u8f6d\u5bf9\u79f0\u7684\uff0c\u5373 F^*(u,v)=F(-u,-v) F^*(u,v)=F(-u,-v) \u6570\u5b57\u56fe\u50cf\u7684\u9891\u8c31\u662f\u5173\u4e8e\u539f\u70b9\u5076\u5bf9\u79f0\u7684\uff0c\u5373 |F(u,v)|=|F(-u,-v)| |F(u,v)|=|F(-u,-v)| \u6570\u5b57\u56fe\u50cf\u7684\u76f8\u4f4d\u89d2\u662f\u5173\u4e8e\u8fdc\u70b9\u5947\u5bf9\u79f0\u7684\uff0c\u5373 \\varphi(u,v)=-\\varphi(-u,-v) \\varphi(u,v)=-\\varphi(-u,-v) \u5e73\u79fb\u6027\u8d28 \u5085\u7acb\u53f6\u53d8\u6362\u5e73\u79fb\u6027\u8d28\uff0c\u662f\u6307\u5f53\u7a7a\u57df\u56fe\u50cf\u76ee\u6807\u4f4d\u7f6e\u53d8\u5316\u4e4b\u540e\uff0c\u5176\u9891\u8c31\u4e0d\u53d1\u751f\u6539\u53d8\u3002 \u65cb\u8f6c\u6027\u8d28 \u5c3a\u5ea6\u5b9a\u7406 \u5468\u671f\u6027 \u5e94\u7528\uff1a f(x)(-1)^x==F(u-\\frac{M}{2}) f(x)(-1)^x==F(u-\\frac{M}{2}) \u8bc1\u660e\u4e3a\uff1a \u4e8c\u7ef4\u540c\u6837\uff1a 4\uff09\u5085\u91cc\u53f6\u53d8\u6362\u76f8\u4f4d\u8c31 \u7531\u5085\u7acb\u53f6\u53d8\u6362\u7684\u76f8\u4f4d\u6784\u6210\u7684\u77e9\u9635\u3002 \u76f8\u4f4d\u5206\u91cf\u662f\u6307\u5404\u4e2a\u6b63\u5f26\u5206\u91cf\u5173\u4e8e\u539f\u70b9\u7684\u4f4d\u79fb\u7684\u5ea6\u91cf\uff0c\u51b3\u5b9a\u4e86\u56fe\u50cf\u4e2d\u53ef\u8fa8\u522b\u7269\u4f53\u5b9a\u4f4d\u4fe1\u606f\u3002 5\uff09\u5377\u79ef\u5b9a\u7406 6\uff09\u5085\u91cc\u53f6\u53d8\u6362\u65f6\u95f4\u590d\u6742\u5ea6 \u8ba1\u7b97\u4e00\u7ef4\u79bb\u6563\u5085\u91cc\u53f6\u53d8\u6362\uff08DFT\uff09\u516c\u5f0f\u5982\u4e0b\uff1a \u200b \u5176\u4e2d\uff0cN\u8868\u793a\u6570\u636e\u957f\u5ea6\u3002\u7531\u4e0a\u5f0f\u53ef\u77e5\uff0cDFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(N*N) \u4e00\u7ef4FFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(N*logN)\uff0c\u5176\u4e2dN\u8868\u793a\u6570\u636e\u957f\u5ea6 \u5bf9\u4e8e\u4e00\u4e2aM*N\u7684\u4e8c\u7ef4\u6570\u636e\uff0cFFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO( M*N*log(M*N) ) \u82e5M=N\uff0c\u5219\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u7b80\u5316\u4e3aO(N^2*logN) \u5bf9\u4e8eM\u7ef4\u7684\u6570\u636e\uff08\u6bcf\u4e00\u7ef4\u957f\u5ea6\u4e3aA\uff0cB\uff0cC\uff0c...\uff09\uff0c\u5219FFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO( A*B*C*...* log(A*B*C*...) ) \u82e5\u6bcf\u4e00\u7ef4\u957f\u5ea6\u76f8\u540c\uff0c\u5373A=B=C=...=N\uff0c\u5219\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u7b80\u5316\u4e3aO(N^M*logN) \u79bb\u6563\u4f59\u5f26\u53d8\u6362 1\uff09\u4e8c\u7ef4\u79bb\u6563\u4f59\u5f26\u53d8\u6362\u5b9a\u4e49 \u6c83\u5c14\u4ec0\u53d8\u6362","title":"\u7b2c\u56db\u7ae0 \u9891\u57df\u5904\u7406"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_6","text":"\u9891\u7387\u57df\u589e\u5f3a\u539f\u7406 1\uff09\u5377\u79ef\u4ee5\u53ca\u5377\u79ef\u5b9a\u7406 \u8bbe\u51fd\u6570f (x, y)\u4e0e\u7b97\u5b50h(x, y)\u7684\u5377\u79ef\u7ed3\u679c\u662fg(x, y)\uff0c\u5373 g(x, y) = h(x, y) * f (x, y)\uff0c\u90a3\u4e48\u6839\u636e\u5377\u79ef\u5b9a\u7406\u5728\u9891\u57df\u6709\uff1a G(u,v) = H(u,v)F(u,v)\uff0c\u5176\u4e2dG(u, v)\uff0cH(u, v)\uff0cF(u, v)\u5206\u522b\u662fg(x, y)\uff0ch(x, y)\uff0cf (x, y)\u7684\u5085\u7acb\u53f6(\u6216\u5176\u5b83)\u53d8\u6362\uff0c\u79f0H(u, v)\u4e3a\u8f6c\u79fb\u51fd\u6570 G(u,v) = H(u,v)F(u,v) 2\uff09\u56fe\u50cf\u589e\u5f3a\u539f\u7406 \u5176\u4e2dT\u4ee3\u8868\u5085\u91cc\u53f6\u53d8\u6362 3\uff09\u56fe\u50cf\u589e\u5f3a\u5177\u4f53\u5b9e\u73b0 \u5377\u79ef\u5b9a\u7406\uff1a G(u,v)=H(u,v)F(u,v) G(u,v)=H(u,v)F(u,v) \u589e\u5f3a\u56fe\u50cf\uff1a g(x,y)=T^{-1}[H(u,v)F(u,v)] g(x,y)=T^{-1}[H(u,v)F(u,v)] \u6b65 \u9aa4\uff1a (1) \u8ba1\u7b97\u56fe\u50cf\u7684\u9891\u57df\u53d8\u6362 (2) \u5728\u9891\u57df\u6ee4\u6ce2 (3) \u53cd\u53d8\u6362\u56de\u56fe\u50cf\u7a7a\u95f4 \u9891\u57df\u6ee4\u6ce2: \u4f4e\u901a\uff0c\u9ad8\u901a\uff0c\u540c\u6001 \u9891\u7387\u57df\u5e73\u6ed1\u6ee4\u6ce2\u5668 1\uff09\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u56fe\u50cf\u4e2d\u7684\u8fb9\u7f18\u548c\u566a\u58f0\u90fd\u5bf9\u5e94\u56fe\u50cf\u5085\u7acb\u53f6\u53d8\u6362\u4e2d\u7684\u9ad8\u9891\u90e8\u5206 \uff0c\u6240\u4ee5\u5982\u8981\u5728\u9891\u57df\u4e2d\u6d88\u5f31\u5176\u5f71\u54cd\u5c31\u8981\u8bbe\u6cd5\u51cf\u5f31\u8fd9\u90e8\u5206\u9891\u7387\u7684\u5206\u91cf\u3002 2\uff09\u7406\u60f3\u4f4e\u901a\u6ee4\u6ce2\u5668 H(u,v)=1:0?D(u,v)<D_0\uff0c\u5176\u4e2dD(u,v)=(u^2+v^2)^{1/2} H(u,v)=1:0?D(u,v)<D_0\uff0c\u5176\u4e2dD(u,v)=(u^2+v^2)^{1/2} \u95ee\u9898\uff1a\u6a21\u7cca\uff0c\u632f\u94c3\u6548\u5e94\u3002 3\uff09\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668 \u51cf\u5c11\u632f\u94c3\u6548\u5e94\uff0c\u9ad8\u4f4e\u9891\u7387\u95f4\u7684\u8fc7\u6e21\u6bd4\u8f83\u5149\u6ed1\u3002 \u9636\u6570\u4e3an\u7684\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668\u516c\u5f0f\u4e3a\uff1a H(u,v)=\\frac{1}{1+D(u,v)^{2n}} H(u,v)=\\frac{1}{1+D(u,v)^{2n}} \u9636\u6570\u5bf9\u632f\u94c3\u73b0\u8c61\u7684\u5f71\u54cd\uff1a\u9636\u6570\u8d8a\u9ad8\uff0c\u8d8a\u660e\u663e\u3002 \u5f53\u9636\u6570\u8d8b\u4e8e\u65e0\u7a77\u65f6\uff0c\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u53d8\u6210\u7406\u60f3\u4f4e\u901a\u6ee4\u6ce2\u3002 4\uff09\u5e94\u7528 \u56fe\u50cf\u7531\u4e8e\u91cf\u5316\u4e0d\u8db3\u4ea7\u751f\u865a\u5047\u8f6e\u5ed3\u65f6\u5e38\u53ef\u7528\u4f4e\u901a\u6ee4\u6ce2\u8fdb\u884c\u5e73\u6ed1\u4ee5\u6539\u8fdb\u56fe\u50cf\u8d28\u91cf\u3002 5\uff09\u9ad8\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668 \u9ad8\u65af\u6ee4\u6ce2\u5668\u662f\u5b8c\u5168\u4e0d\u4f1a\u4ea7\u751f\u632f\u94c3\u6548\u5e94\u7684\u3002 H(u,v)=e^{-D^2(u,v)/2D_0)^2} H(u,v)=e^{-D^2(u,v)/2D_0)^2} 6\uff09\u5176\u4ed6\u4f4e\u901a\u6ee4\u6ce2\u5668 \u9891\u7387\u57df\u9510\u5316\u6ee4\u6ce2\u5668 1\uff09\u7406\u60f3\u9ad8\u901a\u6ee4\u6ce2\u5668 \u5f62\u72b6\u4e0e\u4f4e\u901a\u6ee4\u6ce2\u5668\u7684\u5f62\u72b6\u6b63\u597d\u76f8\u53cd H(u,v)=0:1?D(u,v)>D_0 H(u,v)=0:1?D(u,v)>D_0 2\uff09\u5df4\u7279\u6c83\u65af\u9ad8\u901a\u6ee4\u6ce2\u5668 \u5f62\u72b6\u4e0e\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668\u7684\u5f62\u72b6\u6b63\u597d\u76f8\u53cd H(u,v)=\\frac{1}{1+[D_0/D(u,v)]^{2n}} H(u,v)=\\frac{1}{1+[D_0/D(u,v)]^{2n}} 3\uff09\u9ad8\u65af\u9ad8\u901a\u6ee4\u6ce2\u5668 \u5f62\u72b6\u4e0e\u9ad8\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668\u7684\u5f62\u72b6\u6b63\u597d\u76f8\u53cd H(u,v)=1-e^{-D^2(u,v)/2D_0)^2} H(u,v)=1-e^{-D^2(u,v)/2D_0)^2} \u9ad8\u9891\u5f3a\u8c03\u6ee4\u6ce2\u5668 \u9ad8\u901a\u6ee4\u6ce2\u7684\u7ed3\u679c\uff1a\u8fb9\u7f18\u52a0\u5f3a\uff0c\u5149\u6ed1\u533a\u57df\u53d8\u6697 \u9ad8\u901a\u6ee4\u6ce2\uff1a G(u,v)=H(u,v)F(u,v) G(u,v)=H(u,v)F(u,v) \u9ad8\u901a\u5f3a\u8c03\u8f6c\u79fb\u51fd\u6570\uff1a H_c(u,v)=k\u00d7H(u,v)+c H_c(u,v)=k\u00d7H(u,v)+c \u9ad8\u9891\u5f3a\u8c03\u8f93\u51fa\u56fe\u7684\u5085\u7acb\u53f6\u53d8\u6362\uff1a G_c(u,v)=k\u00d7G(u,v)+c\u00d7F(u,c) G_c(u,v)=k\u00d7G(u,v)+c\u00d7F(u,c) \u53cd\u53d8\u6362\u4e3a\uff1a g(x,y)=k\u00d7g(x,y)+c\u00d7f(x,y) g(x,y)=k\u00d7g(x,y)+c\u00d7f(x,y) \u9ad8\u9891\u63d0\u5347\u6ee4\u6ce2\u5668 \u7528\u539f\u59cb\u56fe\u51cf\u53bb\u4f4e\u901a\u56fe\u5f97\u5230\u9ad8\u901a\u6ee4\u6ce2\u5668\u7684\u6548\u679c\u3002 \u628a\u539f\u59cb\u56fe\u4e58\u4ee5\u4e00\u4e2a\u653e\u5927\u7cfb\u6570A\u518d\u51cf\u53bb\u4f4e\u901a\u56fe\u5c31\u53ef\u6784 \u6210\u9ad8\u9891\u63d0\u5347\uff08high-boost\uff09\u6ee4\u6ce2\u5668 G_{HB}(u,v)=A\u00d7F(u,v)-F_L(u,v)=(A-1)F(u,v)+F_H(u,v) G_{HB}(u,v)=A\u00d7F(u,v)-F_L(u,v)=(A-1)F(u,v)+F_H(u,v) A = 1 \uff1a\u9ad8\u901a\u6ee4\u6ce2\u5668 A > 1 \uff1a\u539f\u59cb\u56fe\u7684\u4e00\u90e8\u5206\u4e0e\u9ad8\u901a\u56fe\u76f8\u52a0\uff0c\u6062\u590d\u4e86\u9ad8\u901a\u6ee4\u6ce2\u65f6\u4e22\u5931\u7684\u4f4e\u9891\u5206\u91cf \u540c\u6001\u6ee4\u6ce2 \u5c06\u660e\u4eae\u5747\u8861\u5316\uff0c\u4f7f\u4eae\u5ea6\u548c\u7070\u5ea6\u5747\u8861\u5316\u3002 \u9009\u62e9\u6027\u6ee4\u6ce2 \u5206\u4e3a\u4e24\u79cd\uff1a \u5e26\u963b\u6ee4\u6ce2\u5668&\u5e26\u901a\u6ee4\u6ce2\u5668 1\uff09\u5e26\u963b\u6ee4\u6ce2\u5668 \u5e26\u963b\u6ee4\u6ce2\u5668\u4e5f\u6709\u4e09\u79cd\u7279\u6027\u3002\u7406\u60f3\u3001\u5df4\u7279\u6c83\u65af\u548c\u9ad8\u65af 2\uff09\u5e26\u901a\u6ee4\u6ce2\u5668 \u5e26\u963b\u6ee4\u6ce2\u5668\u4e5f\u6709\u4e09\u79cd\u7279\u6027\u3002\u7406\u60f3\u3001\u5df4\u7279\u6c83\u65af\u548c\u9ad8\u65af 3\uff09\u9677\u6ce2\u6ee4\u6ce2\u5668(Notch Filter) \u9677\u6ce2\u6ee4\u6ce2\u5668\u672c\u8d28\u4e0a\u662f\u591a\u4e2a\u9ad8\u901a\u6ee4\u6ce2\u5668\u8fdb\u884c\u5e73\u79fb\u540e\u518d\u76f8\u4e58\u3002 \u591a\u4e2a\u5e26\u963b\u6ee4\u6ce2\u5668\u7ecf\u8fc7\u5e73\u79fb\u83b7\u5f97\u3002 \u9891\u57df\u6280\u672f\u4e0e\u7a7a\u57df\u6280\u672f 1\uff09\u7a7a\u95f4\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u6d88\u9664\u6216\u51cf\u5f31\u56fe\u50cf\u4e2d\u7070\u5ea6\u503c\u5177\u6709\u8f83\u5927\u8f83\u5feb\u53d8\u5316\u90e8\u5206\u7684\u5f71\u54cd\uff0c \u8fd9\u4e9b\u90e8\u5206\u5bf9\u5e94\u9891\u57df\u4e2d\u7684\u9ad8\u9891\u5206\u91cf\uff0c\u6240\u4ee5\u53ef\u7528\u9891\u57df\u4f4e\u901a\u6ee4\u6ce2\u6765\u5b9e\u73b0 \u9891\u57df\u8d8a\u5bbd\uff0c\u7a7a\u57df\u8d8a\u7a84\uff0c\u5e73\u6ed1\u4f5c\u7528\u8d8a\u5f31 \u9891\u57df\u8d8a\u7a84\uff0c\u7a7a\u57df\u8d8a\u5bbd\uff0c\u6a21\u7cca\u4f5c\u7528\u8d8a\u5f3a \u5e73\u6ed1\u6a21\u677f\u7cfb\u6570\u4e3a\u6b63\uff0c\u4e14\u4e2d\u90e8\u7cfb\u6570\u503c\u8f83\u5927 2\uff09\u7a7a\u95f4\u9510\u5316\u6ee4\u6ce2\u5668 \u6d88\u9664\u6216\u51cf\u5f31\u56fe\u50cf\u4e2d\u7070\u5ea6\u503c\u7f13\u6162\u53d8\u5316\u7684\u90e8\u5206\uff0c\u8fd9\u4e9b\u90e8\u5206\u5bf9\u5e94 \u9891\u57df\u4e2d\u7684\u4f4e\u9891\u5206\u91cf\uff0c\u6240\u4ee5\u53ef\u7528\u9891\u57df\u9ad8\u901a\u6ee4\u6ce2\u6765\u5b9e\u73b0 \u7a7a\u57df\u6709\u6b63\u8d1f\u503c\uff0c\u6a21\u677f\u4e2d\u5fc3\u7cfb\u6570\u503c\u8f83\u5927","title":"\u7b2c\u4e94\u7ae0 \u9891\u7387\u57df\u56fe\u50cf\u589e\u5f3a"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_7","text":"\u56fe\u50cf\u6062\u590dvs.\u56fe\u50cf\u589e\u5f3a \u76f8\u540c\u4e4b\u5904\uff1a \u6539\u8fdb\u8f93\u5165\u56fe\u50cf\u7684\u89c6\u89c9\u8d28\u91cf \u4e0d\u540c\u4e4b\u5904\uff1a \u4e0d\u8003\u8651\u56fe\u50cf\u964d\u8d28\u7684\u539f\u56e0\uff0c\u53ea\u5c06\u56fe\u50cf\u4e2d\u611f\u5174\u8da3\u7684\u7279\u5f81\u6709\u9009\u62e9\u5730 \u7a81\u51fa\uff08\u589e\u5f3a\uff09\uff0c\u800c\u8870\u51cf\u5176\u4e0d\u9700\u8981\u7684\u7279\u5f81\uff0c\u6539\u5584\u540e\u7684\u56fe\u50cf\u4e0d\u4e00\u5b9a\u8981\u53bb \u903c\u8fd1\u539f\u56fe\u50cf\u3002\u56fe\u50cf\u589e\u5f3a\u501f\u52a9\u4eba\u7684\u89c6\u89c9\u7cfb\u7edf\u7279\u6027\uff0c\u4ee5\u53d6\u5f97\u8f83\u597d\u7684\u89c6 \u89c9\u7ed3\u679c\uff08\u4e0d\u8003\u8651\u9000\u5316\u539f\u56e0\uff09 \u56fe\u50cf\u6062\u590d\u6839\u636e\u76f8\u5e94\u7684\u9000\u5316\u6a21\u578b\u548c\u77e5\u8bc6\u91cd\u5efa\u6216\u6062\u590d\u539f\u59cb\u7684\u56fe\u50cf \uff08\u8003\u8651\u9000\u5316\u539f\u56e0\uff09 \u56fe\u50cf\u9000\u5316\u793a\u4f8b \u56fe\u50cf\u9000\u5316\u6307\u7531\u573a\u666f\u5f97\u5230\u7684\u56fe\u50cf\u6ca1\u80fd\u5b8c\u5168\u5730\u53cd\u6620\u573a\u666f\u7684\u771f \u5b9e\u5185\u5bb9\uff0c\u4ea7\u751f\u4e86\u5931\u771f\u7b49\u95ee\u9898 \u539f\u56e0\uff1a\u900f\u955c\u50cf\u5dee/\u8272\u5dee\u3001\u805a\u7126\u4e0d\u51c6\uff08\u5931\u7126\uff0c\u9650\u5236\u4e86\u56fe\u50cf\u9510\u5ea6\uff09\u3001\u6a21\u7cca\uff08\u9650\u5236\u9891\u8c31\u5bbd\u5ea6\uff09\u3001\u566a\u58f0\uff08\u662f\u4e00\u4e2a\u7edf\u8ba1\u8fc7\u7a0b\uff09\u3001\u6296\u52a8\uff08\u673a\u68b0\u3001\u7535\u5b50\uff09 \u56fe\u50cf\u9000\u5316\u590d\u539f\u8fc7\u7a0b\u6a21\u578b \u9000\u5316\u8fc7\u7a0b\u662f\u4e00\u4e2a\u9000\u5316\u51fd\u6570\ud835\udc6f(\u2219) \u548c\u4e00\u4e2a\u52a0\u6027\u566a\u58f0 \ud835\udf3c (\ud835\udc99, \ud835\udc9a) \uff0c\u4f5c\u7528\u5230\u4e00\u5e45\u56fe\u50cf\ud835\udc87(\ud835\udc99, \ud835\udc9a)\u4e0a\uff0c\u4ea7\u751f\u9000\u5316\u540e\u7684 \u56fe\u50cf\ud835\udc88(\ud835\udc99, \ud835\udc9a)\u3002 \u590d\u539f\u8fc7\u7a0b\u662f\u7ed9\u5b9a\u9000\u5316\u56fe\ud835\udc88(\ud835\udc99, \ud835\udc9a)\u548c\u5173\u4e8e\u9000\u5316\u51fd\u6570\ud835\udc6f(\u2219)\u7684\u4e00\u4e9b\u77e5\u8bc6\u53ca\u5173\u4e8e\u52a0\u6027\u566a\u58f0\u9879\ud835\udf3c(\ud835\udc99, \ud835\udc9a)\u7684\u77e5\u8bc6\uff0c\u83b7\u5f97 \u539f\u59cb\u56fe\u50cf\u7684\u4e00\u4e2a\u4f30\u8ba1\ud835\udc87(x,y)\u3002 \u9000\u5316\u6a21\u578b\uff1a g(x,y)=H[f(x,y)]+\\eta(x,y)=h(x,y)*f(x,y)+\\eta(x,y),*\u4e3a\u5377\u79ef g(x,y)=H[f(x,y)]+\\eta(x,y)=h(x,y)*f(x,y)+\\eta(x,y),*\u4e3a\u5377\u79ef G(x,y)=H(x,y)F(x,y+N(x,y)) G(x,y)=H(x,y)F(x,y+N(x,y)) \u566a\u58f0\u6a21\u578b 1\uff09\u5e38\u89c1\u566a\u58f0 \u70ed\u566a\u58f0\uff1a\u4e0e\u7269\u4f53\u7684\u7edd\u5bf9\u6e29\u5ea6\u6709\u5173\u3002 \u4e5f\u79f0\uff1a \u767d\u566a\u58f0 \uff08\u9891\u7387\u8986\u76d6\u6574\u4e2a\u9891\u8c31\uff09 \u9ad8\u65af\u566a\u58f0\uff08\u5e45\u5ea6\u7b26\u5408\u9ad8\u65af\u5206\u5e03\uff09 \u95ea\u70c1\u566a\u58f0\uff1a\u7535\u6d41\u8fd0\u52a8\u4ea7\u751f\u3002 \u5177\u6709\u53cd\u6bd4\u4e8e\u9891\u7387\uff081/f\uff09\u7684\u9891\u8c31 \u4e5f\u79f0\u7c89\u8272\u566a\u58f0\uff08\u5728\u5bf9\u6570\u9891\u7387\u95f4\u9694\u5185\u6709\u76f8\u540c\u7684\u80fd\u91cf\uff09 \u53d1\u5c04\u566a\u58f0\uff1a\u9ad8\u65af\u5206\u5e03\uff08\u7535\u5b50\u8fd0\u52a8\u7684\u968f\u673a\u6027\uff09 **\u52a0\u6027\u566a\u58f0**\u4e00\u822c\u6307\u70ed\u566a\u58f0\u3001\u6563\u5f39\u566a\u58f0\u7b49\uff0c\u5b83\u4eec\u4e0e\u4fe1\u53f7\u7684\u5173\u7cfb\u662f\u76f8\u52a0\uff0c\u4e0d\u7ba1\u6709\u6ca1\u6709\u4fe1\u53f7\uff0c\u8be5\u7c7b\u566a\u58f0\u662f\u4e00\u76f4\u5b58\u5728\u7684\u3002\u4e00\u822c\u901a\u4fe1\u4e2d\u628a\u52a0\u6027\u968f\u673a\u6027\u770b\u6210\u662f\u7cfb\u7edf\u7684\u80cc\u666f\u566a\u58f0\u3002 **\u4e58\u6027\u566a\u58f0**\u4e00\u822c\u7531\u4fe1\u9053\u4e0d\u7406\u60f3\u5f15\u8d77\uff0c\u5b83\u4eec\u4e0e\u4fe1\u53f7\u7684\u5173\u7cfb\u662f\u76f8\u4e58\uff0c\u4fe1\u53f7\u5728\u5b83\u5728\uff0c\u4fe1\u53f7\u4e0d\u5728\u4ed6\u4e5f\u5c31\u4e0d\u5728\u3002\u4e58\u6027\u968f\u673a\u6027\u770b\u6210\u7cfb\u7edf\u7684\u65f6\u53d8\u6027\uff08\u5982\u8870\u843d\u6216\u8005\u591a\u666e\u52d2\uff09\u6216\u8005\u975e\u7ebf\u6027\u6240\u9020\u6210\u7684\u3002 2\uff09\u566a\u58f0\u6982\u7387\u5bc6\u5ea6\u51fd\u6570 3\uff09\u5468\u671f\u566a\u58f0 \u4e00\u5e45\u56fe\u50cf\u7684\u5468\u671f\u566a\u58f0\u662f\u5728\u56fe\u50cf\u83b7\u53d6\u671f\u95f4\u7531\u7535\u529b\u6216\u673a\u7535\u5e72\u6270\u4ea7\u751f\u7684\u3002 \u662f\u4e00\u79cd\u7a7a\u95f4\u76f8\u5173\u566a\u58f0\u3002 \u5468\u671f\u566a\u58f0\uff08\u6b63\u5f26\uff09\u5728\u5085\u91cc\u53f6\u53d8\u6362\u540e\uff0c\u662f\u4f4d\u4e8e\u6b63\u5f26\u6ce2\u5171\u8f6d\u9891\u7387\u5904\u7684\u4e00\u5bf9\u5171\u8f6d\u8109\u51b2\u3002 \u5468\u671f\u566a\u58f0\u53c2\u6570\u4f30\u8ba1\uff1a \u901a\u8fc7\u68c0\u9a8c\u5085\u91cc\u53f6\u8c31\u6765\u4f30\u8ba1\u5468\u671f\u3002 \u5468\u671f\u566a\u58f0\u901a\u5e38\u4f1a\u4ea7\u751f\u9891\u7387\u5c16\u5cf0\uff0c\u53ef\u4ee5\u8fdb\u884c\u68c0\u6d4b\u3002 \u566a\u58f0\u53c2\u6570\u4f30\u8ba1 \u566a\u58f0\u7684PDF\u53c2\u6570 \u6210\u50cf\u7cfb\u7edf\u53ef\u4f7f\u7528 \u4f7f\u7528\u6210\u50cf\u7cfb\u7edf\u83b7\u53d6\u4e00\u7ec4\u201c\u5e73\u5766\u201d\u73af\u5883\u56fe\u50cf\uff0c\u4f5c\u4e3a\u6837\u672c\uff1b\u5373\uff1a\u62cd\u6444\u5149\u7167\u5747\u5300\u7684\u7eaf\u8272\u7070\u5ea6\u56fe\u50cf \u6210\u50cf\u7cfb\u7edf\u4e0d\u53ef\u4f7f\u7528\uff0c\u53ea\u6709\u5176\u751f\u6210\u56fe\u50cf \u4ece\u56fe\u50cf\u4e2d\uff0c\u627e\u4e00\u5757\u5408\u7406\u7684\u6052\u5b9a\u7070\u5ea6\u503c\u533a\u57df\uff0c\u4f5c\u4e3a\u6837\u672c \u56fe\u50cf\u566a\u58f0\u7684\u6982\u7387\u5bc6\u5ea6\u51fd\u6570\u8868\u793a\uff0c\u5176\u81ea\u53d8\u91cf\u662f\u56fe\u50cf\u7070\u5ea6\u503c\u3002 \u53ea\u6709\u566a\u58f0\u7684\u590d\u539f-\u7a7a\u95f4\u6ee4\u6ce2 \u5bf9\u4e8e\u5468\u671f\u566a\u58f0\uff0c\u5728\u9891\u57df\u4f30\u8ba1\ud835\udc75(\ud835\udc96, \ud835\udc97) \uff0c\u76f4\u63a5\u53bb\u6389\uff0c\u53d8\u6362\u5230\u7a7a\u95f4\u57df\u3002 \u52a0\u6027\u566a\u58f0\uff0c\u7a7a\u95f4\u6ee4\u6ce2\u3002 \u5bf9\u4e8e\u56fe\u50cf\u4e2d\u7684\u52a0\u6027\u566a\u58f0\uff0c\u91c7\u7528\u7b97\u672f\u5747\u503c\u6ee4\u6ce2\u3001\u51e0\u4f55\u5747\u503c\u6ee4\u6ce2\u3001\u9006\u8c10\u6ce2\u5747\u503c\u6ee4\u6ce2\u548c\u8c10\u6ce2\u5747\u503c\u6ee4\u6ce2\u53bb\u9664\u3002 1\uff09\u5747\u503c\u6ee4\u6ce2\u5668 2\uff09\u8c10\u6ce2\u5747\u503c\u6ee4\u6ce2\u5668 3\uff09\u4fee\u6b63alpha\u5747\u503c\u6ee4\u6ce2\u5668 4\uff09\u81ea\u9002\u5e94\u6ee4\u6ce2\u5668 \u6ee4\u6ce2\u5668\u7279\u5f81\u53d8\u5316\u662f\u4ee5\ud835\udc8e \u00d7 \ud835\udc8f\u7684\u77e9\u5f62\u7a97\u53e3\ud835\udc7a\ud835\udc99\ud835\udc9a\u5b9a\u4e49\u7684\u6ee4\u6ce2\u5668\u533a\u57df\u5185\u56fe\u50cf\u7684\u7edf\u8ba1\u7279\u5f81\u4e3a\u57fa\u7840 \u81ea\u9002\u5e94\u6ee4\u6ce2\u5668\u6027\u80fd\u4f18\u4e8e\u5168\u5c40\u6ee4\u6ce2\u5668 \u8ba1\u7b97\u590d\u6742\u5ea6\u9ad8 5\uff09\u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u5168\u5c40\u4e2d\u503c\u6ee4\u6ce2\uff0c\u5728\u8109\u51b2\u566a\u58f0\u7a7a\u95f4\u5bc6\u5ea6\u4e0d\u5927\u662f\uff0c\u6027\u80fd\u5f88\u597d\uff08\u7ecf\u9a8c\uff1a\ud835\udc77\ud835\udc82 < \ud835\udfce. \ud835\udfd0\uff0c\ud835\udc77\ud835\udc83 < \ud835\udfce. \ud835\udfd0\uff09 \u2013 \u5bc6\u5ea6\u5927\uff0c\u4e0d\u597d\u7528 \u2013 \u4e0d\u80fd\u5904\u7406\u975e\u8109\u51b2\u566a\u58f0\uff0c\u540c\u65f6\u4fdd\u7559\u7ec6\u8282 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2 \u2013 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u53ef\u4ee5\u5904\u7406\u66f4\u5927\u7684\u5bc6\u5ea6 \u2013 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u80fd\u591f\u5728\u5e73\u6ed1\u975e\u8109\u51b2\u566a\u58f0\u65f6\uff0c\u4fdd\u7559\u7ec6\u8282 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u76f8\u540c\uff1a \u2013 \u6ee4\u6ce2\u5668\u4f5c\u7528\u4e8e\u5c40\u90e8\u533a\u57df\ud835\udc7a\ud835\udc99\ud835\udc9a \u533a\u522b\uff1a \u2013 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u6839\u636e\u67d0\u4e9b\u6761\u4ef6\u6539\u53d8\ud835\udc7a\ud835\udc99\ud835\udc9a\u7684\u5c3a\u5bf8 \u4f7f\u7528\uff1a \u2013 \u6ee4\u6ce2\u5668\u8f93\u51fa\u4e00\u4e2a\u5355\u503c\uff0c\u7528\u4e8e\u4ee3\u66ff\u6ee4\u6ce2\u5668\u7a97\u53e3\ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u5fc3\u5904\u50cf\u7d20 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u7b26\u53f7\uff1a \ud835\udc9b\ud835\udc8e\ud835\udc8a\ud835\udc8f = \ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u7684\u6700\u5c0f\u7070\u5ea6\u503c \ud835\udc9b\ud835\udc8e\ud835\udc82\ud835\udc99 = \ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u7684\u6700\u5927\u7070\u5ea6\u503c \ud835\udc9b\ud835\udc8e\ud835\udc86\ud835\udc85 = \ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u7684\u7070\u5ea6\u503c\u4e2d\u503c \ud835\udc9b\ud835\udc99\ud835\udc9a =\u5750\u6807 \ud835\udc99, \ud835\udc9a \u5904\u7684\u7070\u5ea6\u503c \ud835\udc7a\ud835\udc8e\ud835\udc82\ud835\udc99 = \ud835\udc7a\ud835\udc99\ud835\udc9a\u5141\u8bb8\u7684\u6700\u5927\u5c3a\u5bf8 \u5468\u671f\u566a\u58f0\u6d88\u9664 \u5e26\u963b\u6ee4\u6ce2\u5668 \u5e26\u901a\u6ee4\u6ce2\u5668 \uff08\u63d0\u53d6\u566a\u58f0\u6a21\u5f0f\uff09 \u9677\u6ce2\u6ee4\u6ce2\u5668 \u7ebf\u6027\u3001\u4f4d\u7f6e\u4e0d\u53d8\u7684\u9000\u5316 1\uff09\u9000\u5316\u6a21\u578b \u9000\u5316\u6a21\u578b\u516c\u5f0f\uff1a \ud835\udc88(\ud835\udc99, \ud835\udc9a) = \ud835\udc6f[\ud835\udc87(\ud835\udc99, \ud835\udc9a)] + \ud835\udf3c(\ud835\udc99, \ud835\udc9a) \u7b80\u5316\u6a21\u578b\uff1a \ud835\udf3c(\ud835\udc99, \ud835\udc9a)=0 2\uff09\u9000\u5316\u7cfb\u7edfH\u7684\u6027\u8d28 \u4f30\u8ba1\u9000\u5316\u51fd\u6570 \u56fe\u50cf\u89c2\u5bdf\u4f30\u8ba1 \u2013 \u6761\u4ef6\uff1a\u53ea\u6709\u9000\u5316\u56fe\u50cf\uff0c\u6ca1\u6709\u5173\u4e8e\u9000\u5316\u51fd\u6570H\u7684\u4efb\u4f55\u77e5\u8bc6\u3002 \u4ece\u56fe\u50cf\u672c\u8eab\u6765\u6536\u96c6\u4fe1\u606f\uff0c\u5373\u901a\u8fc7\u89c2\u5bdf\u56fe\u50cf\uff0c\u8fdb\u884c\u5904\u7406 \u6765\u83b7\u5f97\u9000\u5316\u51fd\u6570\u4fe1\u606f\u3002 \u65b9\u6cd5\uff1a \u2013 \u4ece\u56fe\u50cf\u4e2d\u9009\u62e9\u4e00\u5c0f\u5757\u533a\u57df\uff0c\u4f5c\u4e3a\u5b50\u56fe\u50cf \u2013 \u56fe\u50cf\u4e2d\u7269\u4f53\u6216\u56fe\u50cf\u80cc\u666f\u4e00\u90e8\u5206 \u2013 \u4e3a\u964d\u4f4e\u566a\u58f0\u5f71\u54cd\uff0c\u627e\u6709\u5f88\u5f3a\u4fe1\u53f7\u7684\u533a\u57df\uff08\u9ad8\u5bf9\u6bd4\u533a\u57df\uff09 \u2013 \u624b\u5de5\u5904\u7406\u5b50\u56fe\u50cf\uff0c\u53bb\u9664\u6a21\u7cca\u3002 \u2013 \u8ba1\u7b97\u51faH(u,v) \u8bd5\u9a8c\u4f30\u8ba1 \u2013 \u6761\u4ef6\uff1a\u53ef\u4ee5\u83b7\u5f97\u4e0e\u9000\u5316\u56fe\u50cf\u8bbe\u5907\u76f8\u4f3c\u7684\u7cfb\u7edf \u2013 \u7406\u8bba\u4e0a\uff1a\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u51c6\u786e\u7684\u9000\u5316\u4f30\u8ba1 \u65b9\u6cd5\uff1a \u2013 \u901a\u8fc7\u8bbe\u7f6e\u7cfb\u7edf\uff0c\u83b7\u5f97\u4e0e\u9000\u5316\u56fe\u50cf\u63a5\u8fd1\u7684\u56fe\u50cf\uff1b \u2013 \u7528\u8be5\u7cfb\u7edf\u4e00\u5e45\u51b2\u6fc0\u6210\u50cf\uff0c\u5f97\u5230\u9000\u5316\u7684\u51b2\u6fc0\u54cd\u5e94\uff1b \u2013 \u51b2\u6fc0\u7528\u4e00\u4e2a\u5c0f\u4eae\u70b9\u6765\u6a21\u62df\uff0c\u5c3d\u53ef\u80fd\u4eae\uff1b \u2013 \ud835\udc6f(\ud835\udc96, \ud835\udc97)= \ud835\udc6e(\ud835\udc96,\ud835\udc97)/\ud835\udc68 \u200b \ud835\udc6e(\ud835\udc96, \ud835\udc97)\u662f\u51b2\u6fc0\u6210\u50cf\u56fe\u50cf\u7684\u5085\u91cc\u53f6\u53d8\u6362\uff0c\ud835\udc68\u662f\u51b2\u6fc0\u7684\u5085\u91cc\u53f6\u53d8\u6362 \u5efa\u6a21\u4f30\u8ba1 \u4ece\u5f15\u8d77\u9000\u5316\u7684\u73af\u5883\u6761\u4ef6\u8003\u8651\uff0c\u8fdb\u884c\u4f30\u8ba1 \u6e4d\u6d41\u9000\u5316\u6a21\u578b\u662f\u5927\u6c14\u6e4d\u6d41\u7269\u7406\u7279\u6027\u7684 \u901a\u7528\u5f62\u5f0f\uff1a \ud835\udc6f(\ud835\udc96, \ud835\udc97)= \ud835\udc86^{\u2212\ud835\udc8c(\ud835\udc96^\ud835\udfd0+\ud835\udc97^\ud835\udfd0)^{\ud835\udfd3/6}} \ud835\udc6f(\ud835\udc96, \ud835\udc97)= \ud835\udc86^{\u2212\ud835\udc8c(\ud835\udc96^\ud835\udfd0+\ud835\udc97^\ud835\udfd0)^{\ud835\udfd3/6}} \u5176\u4e2d\uff0c \ud835\udc8c\u662f\u4e0e\u6e4d\u6d41\u6027\u8d28\u6709\u5173\u7684\u5e38\u6570 \ud835\udc8c = \ud835\udfce. \ud835\udfce\ud835\udfce\ud835\udfd0\ud835\udfd3\u5267\u70c8\u6e4d\u6d41 \ud835\udc8c = \ud835\udfce. \ud835\udfce\ud835\udfce\ud835\udfcf\u4e2d\u7b49\u6e4d\u6d41 \ud835\udc8c = \ud835\udfce. \ud835\udfce\ud835\udfce\ud835\udfce\ud835\udfd0\ud835\udfd3\u8f7b\u5fae\u6e4d\u6d41 \u9006\u6ee4\u6ce2 --\u65e0\u7ea6\u675f\u6062\u590d \u9006\u6ee4\u6ce2\u4e2d\uff0c\u9006\u6ee4\u6ce2\u4e2d\uff0c\u6309\u7167\u79bb\u9891\u8c31\u4e2d\u5fc3\u7684\u8fdc\u8fd1\u5b9a\u4e49\u4e86\u6062\u590d\u8f6c\u79fb\u51fd\u6570\u662f\u632f\u94c3\u6548\u5e94\u51fa\u73b0\u7684\u539f\u56e0\u3002 \u6700\u5c0f\u5747\u65b9\u8bef\u5dee\u6ee4\u6ce2\uff08\u7ef4\u7eb3\u6ee4\u6ce2\uff09 --\u6709\u7ea6\u675f\u6062\u590d \u4e86\u89e3 \u6709\u7ea6\u675f\u6700\u5c0f\u4e8c\u4e58\u65b9\u6062\u590d --\u6709\u7ea6\u675f\u6062\u590d \u4e86\u89e3","title":"\u7b2c\u516d\u7ae0 \u56fe\u50cf\u6062\u590d"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_8","text":"\u5f69\u8272\u57fa\u7840 1\uff09\u989c\u8272\u7684\u672c\u8d28 \u4e0d\u540c\u989c\u8272\u7684\u5149\u5b9e\u8d28\u662f \u4e0d\u540c\u9891\u7387\u7684\u7535\u78c1\u6ce2 \u2013 \u53ef\u89c1\u5149\u8c31\u7684\u6ce2\u957f\u8303\u56f4\uff1a400\uff5e700nm 2\uff09\u4e09\u57fa\u8272 \u5927\u591a\u6570\u7684\u989c\u8272\u53ef\u4ee5\u901a \u8fc7\u7ea2\u3001\u7eff\u3001\u84dd\u4e09\u8272\u6309\u7167 \u4e0d\u540c\u7684\u6bd4\u4f8b\u5408\u6210\u4ea7\u751f 3\uff09\u8272\u5ea6 \u8272\u5ea6 \u5f69\u8272\u7684\u4e09\u79cd\u57fa\u672c\u7279\u6027\u91cf \u4eae\u5ea6\uff1a \u4e0e\u7269\u4f53\u7684\u53cd\u5c04\u7387\u6210\u6b63\u6bd4 \u8272\u8c03\uff1a \u4e0e\u5149\u8c31\u4e2d\u5149\u7684\u6ce2\u957f\u76f8\u8054\u7cfb \u9971\u548c\u5ea6\uff1a\u4e0e\u4e00\u5b9a\u8272\u8c03\u5149\u7684\u7eaf\u5ea6\u6709\u5173 \u8272\u5ea6\uff1a\u8272\u8c03\u548c\u9971\u548c\u5ea6\u5408\u79f0 \u5f69\u8272\u53ef\u7528\u4eae\u5ea6\u548c\u8272\u5ea6\u5171\u540c\u8868\u793a 4\uff09\u8272\u5ea6\u56fe \u5f69\u8272\u6253\u5370\u673a\u662f\u76f8 \u52a0\u8272\u5f69\u548c\u76f8\u51cf\u8272\u5f69\u7684\u6df7\u5408\u7684 \u7ec4\u5408\uff0c\u6240\u4ee5\u5f69\u8272\u57df\u8fb9\u754c\u4e0d\u89c4\u5219\u3002 \u5f69\u8272\u8f6c\u5316\u4e3a\u7070\u5ea6\uff0c\u9002\u5408\u663e\u793a\u5668\u548c\u6444\u50cf\u673a\uff1a Y_{709} = 0.2125R + 0.7154G + 0.0721B Y_{709} = 0.2125R + 0.7154G + 0.0721B \u5f69\u8272\u6a21\u578b \u4e3a\u4e86\u6b63\u786e\u6709\u6548\u5730\u8868\u8fbe\u5f69\u8272\u4fe1\u606f\uff0c\u9700\u8981\u5efa\u7acb\u5408\u9002\u7684\u5f69\u8272\u8868\u8fbe\u6a21\u578b\u3002 1\uff09\u5f69\u8272\u8868\u8fbe\u6a21\u578b \u5f69\u8272\u8868\u8fbe\u6a21\u578b\u5206\u4e3a\u4e24\u79cd\uff1a \u9762\u5411\u786c\u8bbe\u5907\u7684\u5f69\u8272\u6a21\u578b\uff0c\u8bf8\u5982\u5f69\u8272\u663e\u793a\u5668\u6216\u6253\u5370\u673a\u4e4b\u7c7b\u7684\u786c\u8bbe\u5907\uff0c\u4f8b\u5982RGB\uff0cCMY\u6a21\u578b\u7b49\u3002 \u9762\u5411\u89c6\u89c9\u611f\u77e5\u7684\u5f69\u8272\u6a21\u578b\uff0c\u4ee5\u5f69\u8272\u5904\u7406\u4e3a\u76ee\u7684\u7684\u5e94\u7528\uff0c\u4f8b\u5982HSI\u3001HSV\u6a21\u578b\u7b49\u3002 2\uff09RGB\u6a21\u578b \u5efa\u7acb\u5728\u7b1b\u5361\u513f\u5750\u6807\u7cfb\u7edf\u91cc\uff0c\u5176\u4e2d\u4e09 \u4e2a\u8f74\u5206\u522b\u4e3aR\uff0cG\uff0cB\uff0c \u2013 \u6a21\u578b\u7684\u7a7a\u95f4\u662f\u6b63\u65b9\u4f53\uff0c\u539f\u70b9\u5bf9\u5e94\u9ed1 \u8272\uff0c\u79bb\u539f\u70b9\u6700\u8fdc\u7684\u9876\u70b9\u5bf9\u5e94\u767d\u8272 \u2013 \u4ece\u9ed1\u5230\u767d\u7684\u7070\u5ea6\u503c\u5206\u5e03\u5728\u4ece\u539f\u70b9\u5230 \u79bb\u539f\u70b9\u6700\u8fdc\u9876\u70b9\u95f4\u7684\u8fde\u7ebf\u4e0a\uff0c\u800c\u7acb\u65b9\u4f53\u5185\u5176\u4f59\u5404\u70b9\u5bf9\u5e94\u4e0d\u540c\u7684\u989c\u8272\uff0c \u53ef\u7528\u4ece\u539f\u70b9\u5230\u8be5\u70b9\u7684\u77e2\u91cf\u8868\u793a 3\uff09CMY\u6a21\u578b \u4e09\u8865\u8272\uff1a \u84dd\u7eff(C, cyan)\uff0c\u54c1\u7ea2(M, magenta)\uff0c\u9ec4(Y, yellow) \u2013 \u4e3b\u8981\u7528\u4e8e\u5f69\u8272\u6253\u5370\uff0c\u8fd9\u4e09\u79cd\u8865\u8272\u53ef\u5206\u522b\u7531\u4ece\u767d\u5149\u4e2d\u51cf\u53bb\u4e09\u79cd\u57fa\u8272\u800c\u5f97\u5230 \u2013 \u4eceCMY\u5230RGB\u7684\u8f6c\u6362\u4e3aR =1\u2212C\uff0cG =1\u2212 M\uff0cB =1\u2212Y 4\uff09HSI\u6a21\u578b H\uff1a\u70b9s\u7684H\u4e3a\u4e09\u89d2\u5f62 \u4e2d\u5fc3\u70b9\u5230s\u7684\u77e2\u91cf\u4e0eR\u8f74\u7684\u5939\u89d2 S\uff1a\u70b9s\u7684S\u4e3a\u4e09\u89d2 \u5f62\u4e2d\u5fc3\u70b9\u5230s\u7684\u77e2\u91cf\u957f\u5ea6 I\uff1a\u79bb\u5f00\u4e2d\u95f4\u622a\u9762 \u5411\u4e0a\u53d8\u767d\uff1b\u5411\u4e0b\u53d8\u9ed1 \u8272\u8c03\u548c\u9971\u548c\u5ea6\u4e8c\u8005\u5408\u5e76\u79f0\u4e3a\u8272\u5ea6\uff0c\u4eae\u5ea6\u4e2d\u4e0d\u542b\u6709\u989c\u8272\u4fe1\u606f\u3002 H \u8868\u793a\u8272\u8c03\uff08hue\uff09 S \u8868\u793a\u9971\u548c\u5ea6\uff08saturation\uff09 I \u8868\u793a\u5bc6\u5ea6\uff08intensity\uff0c\u5bf9\u5e94\u6210\u50cf\u4eae\u5ea6\u548c\u56fe\u50cf\u7070\u5ea6\uff09 H\u548cS\u5408\u79f0\u8272\u5ea6 I \u5206\u91cf\u4e0e\u56fe\u50cf\u7684\u5f69\u8272\u4fe1\u606f\u65e0\u5173 H \u548c S \u5206\u91cf\u4e0e\u4eba\u611f\u53d7\u989c\u8272\u7684\u65b9\u5f0f\u7d27\u5bc6\u76f8\u8fde \u4f2a\u5f69\u8272\u5904\u7406 \u4eba\u773c\u5bf9\u5f69\u8272\u8272\u6bd4\u5bf9\u7070\u5ea6\u6709\u8f83\u5927\u7684\u5206\u8fa8\u80fd\u529b\u3002 \u4f2a\u5f69\u8272(pseudocolor)\u5904\u7406\u662f\u6307\u5bf9\u539f\u6765\u7070\u5ea6\u56fe\u50cf\u4e2d\u4e0d\u540c\u7070\u5ea6\u503c\u7684\u533a\u57df\u8d4b\u4e88\u4e0d\u540c\u7684\u989c\u8272\u3002 \u5178\u578b\u65b9\u6cd5 (1) \u4eae\u5ea6\u5207\u5272 (2) \u5229\u7528\u53d8\u6362\u51fd\u6570 (3) \u9891\u57df\u6ee4\u6ce2 1\uff09\u4eae\u5ea6\u5207\u5272 \u75281\u4e2a\u5e73\u884c\u4e8e\u56fe\u50cf\u5750\u6807\u5e73\u9762\u7684\u5e73\u9762\u53bb\u5207\u5272\u56fe\u50cf\u4eae\u5ea6\u51fd\u6570\uff0c\u4ece\u800c\u628a\u4eae \u5ea6\u51fd\u6570\u5206\u62102\u4e2a\u7070\u5ea6\u503c\u533a\u95f4\u3002 2\uff09\u4ece\u7070\u5ea6\u5230\u5f69\u8272\u7684\u53d8\u6362\uff08\u6620\u5c04\uff09 3\uff09\u9891\u57df\u6ee4\u6ce2 \u5bf9\u539f\u6765\u7070\u5ea6\u56fe\u50cf\u4e2d\u7684\u4e0d\u540c\u9891\u7387\u5206\u91cf\uff08\u53ef\u5206\u522b\u501f\u52a9\u4f4e\u901a\uff0c\u5e26\u901a/\u5e26\u963b\uff0c\u9ad8\u901a\u6ee4\u6ce2\u5668\u83b7\u5f97\uff09\u8d4b\u4e88\u4e0d\u540c\u7684\u989c\u8272 \u771f\u5f69\u8272\u5904\u7406 1\uff09\u5904\u7406\u65b9\u6cd5 \u5c06\u4e00\u5e45\u5f69\u8272\u56fe\u50cf\u770b\u4f5c\u4e09\u5e45\u5206\u91cf\u56fe\u50cf\u7684\u7ec4\u5408\u4f53\uff0c\u5148\u5206\u522b\u5355\u72ec\u5904\u7406\u6bcf\u4e00\u5e45\u5206\u91cf\u56fe\u50cf\uff0c\u518d\u5c06\u7ed3\u679c\u5408\u6210\u4e00\u5e45\u5904\u7406\u8fc7\u7684\u5408\u6210\u5f69\u8272\u56fe\u50cf \u5c06\u4e00\u5e45\u5f69\u8272\u56fe\u50cf\u4e2d\u7684\u6bcf\u4e2a\u50cf\u7d20\u770b\u4f5c\u5177\u6709\u4e09\u4e2a\u5c5e\u6027\u503c\uff0c\u5373\u5c5e\u6027\u73b0\u5728\u4e3a\u4e00\u4e2a\u77e2\u91cf\uff0c\u5229\u7528\u5bf9\u77e2\u91cf\u7684\u8868\u8fbe\u65b9\u6cd5\u8fdb\u884c\u5904\u7406 2\uff09\u5f69\u8272\u53d8\u6362 g(x,y)=T(f(x,y)) g(x,y)=T(f(x,y)) \u5176\u4e2d\uff0c\ud835\udc87(\ud835\udc99, \ud835\udc9a) \u662f\u5f69\u8272\u8f93\u5165\u56fe\u50cf\uff0c \ud835\udc88(\ud835\udc99, \ud835\udc9a) \u662f\u53d8\u6362\u540e\u7684\u5f69\u8272\u56fe\u50cf\uff0c \ud835\udc7b\u662f\u5728 (\ud835\udc99, \ud835\udc9a) \u7684\u7a7a\u95f4\u90bb\u57df\u4e0a\u5bf9\ud835\udc87\u7684\u4e00\u4e2a\u7b97\u5b50\u3002 \u5206\u91cf\u5f62\u5f0f\uff1a\ud835\udc94\ud835\udc8a = \ud835\udc7b\ud835\udc8a(\ud835\udc93\ud835\udfcf, \ud835\udc93\ud835\udfd0, \u22ef , \ud835\udc93\ud835\udc8f)\uff0c\ud835\udc8a = \ud835\udfcf, \ud835\udfd0, \u22ef , \ud835\udc8f \ud835\udc93\ud835\udc8a\u548c\ud835\udc94\ud835\udc8a\u662f\ud835\udc87 \ud835\udc99, \ud835\udc9a \u548c\ud835\udc88 \ud835\udc99, \ud835\udc9a \u5728\u4efb\u4f55\u70b9\u5904\u5f69\u8272\u5206\u91cf\u53d8\u91cf\uff0c\ud835\udc8f\u662f\u5f69\u8272\u5206\u91cf\u6570\uff1b \ud835\udc7b\ud835\udc8a\u662f\u5bf9\ud835\udc93\ud835\udc8a\u5904\u7406\u4ea7\u751f\ud835\udc94\ud835\udc8a\u7684\u6620\u5c04\u51fd\u6570\uff1b \ud835\udc8f = \ud835\udfd1\u65f6\u5019\uff0c\u662fRGB\u7a7a\u95f4\uff0c\ud835\udc8f = \ud835\udfd2\u65f6\u5019\uff0c\u662fCMYK\u7a7a\u95f4\uff0c 3\uff09\u5f69\u8272\u5f3a\u5ea6\u589e\u5f3a\u53d8\u6362 \u53d8\u6362\u589e\u5f3a \u5bf9\u4e8e\u5f69\u8272\u56fe\u50cf\u589e\u5f3a\u5176\u5f3a\u5ea6\u503c\uff0c\u5373intensity \u8981\u5224\u65ad\u989c\u8272\u6a21\u578b\uff0c\u7136\u540e\u5904\u7406 HSI\u6a21\u578b\uff0cI\u5355\u5206\u91cf\u8fdb\u884c\u589e\u5f3a\u7684\u6b65\u9aa4 (1) \u5c06R\uff0cG\uff0cB\u5206\u91cf\u56fe\u8f6c\u5316\u4e3aH\uff0cS\uff0cI\u5206\u91cf\u56fe (2) \u5229\u7528\u5bf9\u7070\u5ea6\u56fe\u589e\u5f3a\u7684\u65b9\u6cd5\u589e\u5f3a\u5176\u4e2d\u7684I\u5206\u91cf \ud835\udc94\ud835\udfd1 = \ud835\udc8c\ud835\udc93\ud835\udfd1 (3) \u518d\u5c06\u7ed3\u679c\u8f6c\u6362\u4e3aR\uff0cG\uff0cB\u5206\u91cf\u56fe RGB\u6a21\u578b\uff0c\u5f3a\u5ea6\u589e\u5f3a \u4e09\u4e2a\u5206\u91cf\u90fd\u53d8\u6362 \ud835\udc94\ud835\udc8a = \ud835\udc8c\ud835\udc93\ud835\udc8a\uff0c\ud835\udc8a = \ud835\udfcf, \ud835\udfd0, 3 4\uff09\u8865\u8272 \u5728\u8272\u73af\u4e0a\uff0c\u4e0e\u8272\u8c03\u76f4\u63a5\u76f8\u5bf9 \u7684\u53e6\u4e00\u7aef\u79f0\u4e3a\u8865\u8272 \u5728RGB\u7a7a\u95f4\uff0c \u76f4\u63a5\u6c42\u8865\uff1b \u5728HSI\u7a7a\u95f4\uff0c \u6ca1\u6709\u76f4\u63a5\u65b9\u6cd5\uff0c \u53ea\u80fd\u8fd1\u4f3c\u3002 5\uff09\u76f4\u65b9\u56fe\u5747\u8861\u5316 \u5355\u72ec\u5bf9RGB\u5f69\u8272\u56fe\u50cf\u5206\u91cf\u8fdb\u884c\u76f4\u65b9\u56fe\u5747\u8861 \u2013 \u4ea7\u751f\u4e0d\u6b63\u786e\u989c\u8272 \u5747\u5300\u5730\u5c55\u5f00\u8fd9\u79cd\u5f69\u8272\u7070\u5ea6\uff0c\u4fdd\u6301\u5f69\u8272\u672c\u8272\uff08\u8272\u8c03\uff09 \u4e0d\u53d8 \u2013 \u5728HSI\u4e2d\uff0c\u5747\u8861\u5316\u5f69\u8272\u5206\u91cfI\uff0c\u5f69\u8272\u672c\u8eab\uff08\u8272\u8c03\uff09\u4e0d\u53d8 6\uff09\u5f69\u8272\u5e73\u6ed1 \u5c06\u7070\u5ea6\u56fe\u50cf\u90bb\u57df\u5e73\u5747\u6269\u5c55\u5230\u5f69\u8272\u56fe\u50cf\uff0c\u4f7f\u7528\u5411\u91cf\u5e73\u6ed1\u7b97\u5b50 \u5bf9HSI\u6a21\u578b\u4e2d\u7684I\u901a\u9053\u8fdb\u884c\u5e73\u6ed1\uff0cH\u548cS\u901a\u9053\u4e0d\u5904\u7406\uff0c \u989c\u8272\u6ca1\u6709\u53d8\u5316\u3002 7\uff09\u5f69\u8272\u9510\u5316 8\uff09\u9971\u548c\u5ea6\u589e\u5f3a \u2013 \u65b9\u6cd5\uff1a\u8f6c\u5230HSI\u989c\u8272\u7a7a\u95f4\uff0c\u5bf9S\u901a\u9053\u8fdb\u884c\u589e\u5f3a \u2013 \u6548\u679c\uff1a \u2013 \u589e\u5927\u50cf\u7d20\u9971\u548c\u5ea6\u4f1a\u4f7f\u56fe\u50cf\u8272\u5f69\u66f4\u9c9c\u660e \u2013 \u51cf\u5c0f\u50cf\u7d20\u9971\u548c\u5ea6\u4f1a\u4f7f\u56fe\u50cf\u8272\u5f69\u611f\u51cf\u5c11\uff0c\u663e\u5f97\u5e73\u6de1 9\uff09\u8272\u8c03\u589e\u5f3a \u2013 \u65b9\u6cd5\uff1a\u8f6c\u6362\u5230HSI\u989c\u8272\u7a7a\u95f4\uff0c\u7136\u540e\u5bf9H\u8fdb\u884c\u589e\u5f3a \u6548\u679c\uff1a\u56e0\u4e3a\u8272\u8c03\u5bf9\u5e94\u4e00\u4e2a\u89d2\u5ea6 \u2013 \u5fae\u589e\u4e00\u4e2a\u5e38\u6570\uff0c\u4f1a\u4f7f\u989c\u8272\u5728\u8272\u8c31\u4e0a\u79fb\u52a8\u3002 \u2013 \u5e38\u6570\u8f83\u5c0f\u65f6\uff0c\u4f1a\u4f7f\u8272\u8c03\u53d8\u201c\u6696\u201d\u6216\u53d8\u201c\u51b7\u201d \u2013 \u5e38\u6570\u8f83\u5927\u65f6\uff0c\u4f1a\u4f7f\u5f69\u8272\u56fe\u50cf\u53d1\u751f\u5267\u70c8\u53d8\u6362","title":"\u7b2c\u4e03\u7ae0 \u5f69\u8272\u56fe\u50cf\u5904\u7406"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_9","text":"\u7ed3\u6784\u5143 \u5bf9\u6bcf\u4e2a\u7ed3\u6784\u5143\u7d20\uff0c\u5148\u8981\u6307\u5b9a\u4e00\u4e2a\u539f\u70b9\uff0c\u5b83\u662f\u7ed3\u6784\u5143\u7d20\u53c2\u4e0e \u5f62\u6001\u5b66\u8fd0\u7b97\u7684\u53c2\u8003\u70b9\u3002 \u6ce8\u610f\uff1a\u539f\u70b9\u53ef\u4ee5\u5305\u542b\u5728\u7ed3\u6784\u5143\u7d20\u4e2d\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u5305\u542b\u5728\u7ed3 \u6784\u5143\u7d20\u4e2d\uff08\u5373\u539f\u70b9\u5e76\u4e0d\u4e00\u5b9a\u8981\u5c5e\u4e8e\u7ed3\u6784\u5143\u7d20\uff09 \u5bf9\u56fe\u50cf\u64cd\u4f5c\u65f6\u8981\u6c42\u7ed3\u6784\u5143\u7d20\u662f\u77e9\u5f62\u9635\u5217\uff0c\u901a\u8fc7\u6dfb\u52a0\u6700\u5c11\u53ef\u80fd\u7684\u80cc\u666f\u5143\u7d20\u5b9e\u73b0\u3002 \u57fa\u672c\u5f62\u6001\u5b66\u64cd\u4f5c \u6620\u50cf\u548c\u4f4d\u79fb\u662f\u5f62\u6001\u5b66\u5904\u7406\u4e2d\u6269\u5c55\u7684\u96c6\u5408\u8fd0\u7b97\u3002 1\uff09\u81a8\u80c0 A\u2295B = \\{x|(B\u02c6) x \u2229 A \u2260 \\phi \\},\u02c6\u4e3a\u7ffb\u8f6c\u8fd0\u7b97 A\u2295B = \\{x|(B\u02c6) x \u2229 A \u2260 \\phi \\},\u02c6\u4e3a\u7ffb\u8f6c\u8fd0\u7b97 \u5148\u5bf9B\u505a==\u5173\u4e8e\u539f\u70b9\u7684\u6620\u8c61==\uff0c\u518d\u5c06\u5176\u6620\u8c61\u5e73\u79fbx\uff0c\u7ed3\u679c\u662f\u5e73\u79fb\u540e\u4e0eA\u4ea4\u96c6\u4e0d\u4e3a\u7a7a\u7684x\u96c6\u5408\u3002 \u5373\u4e3a\u7528B\u6765\u81a8\u80c0A\u5f97\u5230\u7684\u96c6\u5408\u662f \u7684\u4f4d\u79fb\u4e0eA\u81f3\u5c11\u6709\u4e00 \u4e2a\u975e\u96f6\u5143\u7d20\u5373\u76f8\u4ea4\u65f6B\u7684\u539f\u70b9\u4f4d\u7f6e\u7684\u96c6\u5408\u3002 2\uff09\u8150\u8680 A\u3280B = \\{x |(B)x \u2286 A \\} A\u3280B = \\{x |(B)x \u2286 A \\} B\u79fb\u52a8\u540e\u5b8c\u5168\u5305\u542b\u5728A\u4e2d\u65f6\uff0cB\u7684\u539f\u70b9\u4f4d\u7f6e\u7684\u96c6\u5408 \u4f5c\u7528\uff1a \u539f\u70b9\u5728\u7ed3\u6784\u5143\u7d20\uff08B\u4e2d\uff0c\u6536\u7f29\u56fe\u50cf\u3002 \u7ed3\u6784\u5143\u7d20\u4e0d\u5305\u542b\u539f\u70b9\u65f6\uff0c\u53ef\u4ee5\u7528\u4f5c\u586b\u5145\u5185\u90e8\u7a7a\u6d1e 3\uff09\u8150\u8680\u548c\u81a8\u80c0\u5bf9\u5076\u6027 (A\u3280B)^c=A^c\u2295B\u02c6 (A\u3280B)^c=A^c\u2295B\u02c6 \uff0c\u5176\u4e2dc\u4e3a\u53d6\u8865\u8fd0\u7b97 3\uff09\u5f00\u64cd\u4f5c \u5b9a\u4e49\uff1aB\u5bf9A\u8fdb\u884c\u7684\u5f00\u64cd\u4f5c\u5c31\u662f\u5148\u7528B\u5bf9A\u8150\u8680\uff0c\u7136\u540e\u7528B \u5bf9\u7ed3\u679c\u8fdb\u884c\u81a8\u80c0 \u4f5c\u7528\uff1a\u5f00\u64cd\u4f5c\u65ad\u5f00\u72ed\u7a84\u7684\u95f4\u65ad\u548c\u6d88\u9664\u7ec6\u7684\u7a81\u51fa\u7269 A\u2299B=(A\u3280B)\u2295B A\u2299B=(A\u3280B)\u2295B 4\uff09\u95ed\u64cd\u4f5c \u5b9a\u4e49\uff1aB\u5bf9A\u8fdb\u884c\u7684\u95ed\u64cd\u4f5c\u5c31\u662f\u5148\u7528B\u5bf9A\u81a8\u80c0\uff0c\u7136\u540e\u7528B \u5bf9\u7ed3\u679c\u8fdb\u884c\u8150\u8680 \u4f5c\u7528\uff1a\u95ed\u64cd\u4f5c\u6d88\u5f25\u72ed\u7a84\u7684\u95f4\u65ad\u548c\u957f\u7ec6\u7684\u9e3f\u6c9f\uff0c\u6d88\u9664\u5c0f\u7684\u5b54\u6d1e\uff0c\u5e76 \u586b\u8865\u8f6e\u5ed3\u7ebf\u4e2d\u5c0f\u7684\u65ad\u88c2 A\u2022B=(A\u2295B)\u3280B A\u2022B=(A\u2295B)\u3280B 5\uff09\u5f00\u548c\u95ed\u64cd\u4f5c\u6027\u8d28 (A\u2022B)^c=(A^c\u2299B\u02c6) (A\u2022B)^c=(A^c\u2299B\u02c6) (A\u2299B)\u2286A (A\u2299B)\u2286A A\u2286A\u2022B A\u2286A\u2022B 6\uff09\u51fb\u4e2d\u6216\u51fb\u4e0d\u4e2d\u53d8\u6362 \u57fa\u672c\u7684\u5f62\u6001\u5b66\u7b97\u6cd5 1\uff09\u8fb9\u754c\u63d0\u53d6 \u8bbe\u96c6\u5408A\u7684\u8fb9\u754c\u8868\u793a\u4e3a \u03b2(A)\uff0c\u9009\u53d6\u7ed3\u6784\u5143\u7d20B\uff0c\u5148\u8fdb\u884cB\u5bf9 A\u8150\u8680\uff0c\u800c\u540e\u7528A\u51cf\u53bb\u8150\u8680\u7684\u7ed3\u679c\u3002 2\uff09\u533a\u57df\u586b\u5145 3\uff09\u7ec6\u5316\u64cd\u4f5c \u63d0\u53d6\u56fe\u50cf\u7684\u4e3b\u8981\u6846\u67b6 4\uff09\u8054\u901a\u533a\u57df\u63d0\u53d6 \u65b9\u6cd5\uff1a X_k = (X_{k\u22121} \u2295 B)\u2229A X_k = (X_{k\u22121} \u2295 B)\u2229A \u76f4\u81f3 X_k X_k \u548c X_{k-1} X_{k-1} \u76f8\u540c 5\uff09\u51f8\u58f3 \u57fa\u672c\u7070\u5ea6\u7ea7\u56fe\u50cf\u6269\u5c55\u64cd\u4f5c 1\uff09\u81a8\u80c0 f\u2295b(s,t)=max\\{f(s-x,t-y)+b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} f\u2295b(s,t)=max\\{f(s-x,t-y)+b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} Df\u548cDb\u5206\u522b\u4e3a f \u548c b \u7684\u5b9a\u4e49\u57df\u3002 \u50cf\u7d20\u90fd\u5fc5\u987b\u5728\u5b9a\u4e49\u57df\u5185\uff0c\u4e0e\u96c6\u5408\u4ea4\u96c6\u4e00\u81f4 \u81a8\u80c0\u64cd\u4f5c\u7684\u7ed3\u679c\uff1a \uff08a\uff09\u5982\u679c\u7ed3\u6784\u5143 \u7d20\u7684\u503c\u90fd\u4e3a\u6b63\uff0c\u90a3\u4e48\u8f93\u51fa\u56fe\u50cf\u4f1a\u66f4\u4eae \uff08b\uff09\u6697\u7684\u7ec6\u8282\u90e8 \u5206\u7684\u53d8\u5316\u53d6\u51b3\u4e8e\u7ed3\u6784\u5143\u7d20\u7684\u503c\u548c\u5f62\u72b6 2\uff09\u8150\u8680 f\u3280b(s,t)=min\\{f(s-x,t-y)-b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} f\u3280b(s,t)=min\\{f(s-x,t-y)-b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} Df\u548cDb\u5206\u522b\u4e3a f \u548c b \u7684\u5b9a\u4e49\u57df\u3002 \u50cf\u7d20\u90fd\u5fc5\u987b\u5728\u5b9a\u4e49\u57df\u5185\uff0c\u4e0e\u7ed3\u6784\u5143\u7d20\u5fc5\u987b\u5b8c\u5168\u5305\u542b\u5728\u88ab\u8150\u8680\u7684 \u96c6\u5408\u5185\u4e00\u81f4 \u8150\u8680\u64cd\u4f5c\u7684\u7ed3\u679c\uff1a \uff08a\uff09\u5982\u679c\u7ed3\u6784\u5143\u7d20\u7684 \u503c\u90fd\u4e3a\u6b63\uff0c\u90a3\u4e48\u8f93\u51fa\u56fe\u50cf\u4f1a\u66f4\u6697 \uff08b\uff09\u4eae\u7684\u7ec6\u8282\u90e8\u5206\u7684\u53d8\u5316\u53d6\u51b3\u4e8e\u7ed3\u6784\u5143\u7d20\u7684\u503c\u548c\u5f62\u72b6 3\uff09\u5f00\u64cd\u4f5c \u5f00\u64cd\u4f5c\uff1a\u5c0f\u7684\u660e\u4eae\u7ec6\u8282\u5c3a\u5bf8\u53d8\u5c0f\uff0c\u6697\u7684\u6548\u679c\u53d7\u5f71\u54cd\u8f83\u5c0f \u95ed\u64cd\u4f5c\uff1a\u5c0f\u7684\u6697\u7ec6\u8282\u7684\u5c3a\u5bf8\u7f29\u5c0f\uff0c\u660e\u4eae\u90e8\u5206\u53d7\u5f71\u54cd\u8f83\u5c0f \u57fa\u672c\u7684\u7070\u5ea6\u7ea7\u5f62\u6001\u5b66\u7b97\u6cd5 1\uff09\u5f62\u6001\u5b66\u5e73\u6ed1 \u5148\u8fdb\u884c\u5f00\u64cd\u4f5c\uff0c\u540e\u8fdb\u884c\u95ed\u64cd\u4f5c \u8ba1\u7b97\u516c\u5f0f\u4e3a\uff1a g=(f\u2299b)\u2022b g=(f\u2299b)\u2022b 2\uff09\u5f62\u6001\u5b66\u68af\u5ea6 \u5f00\u64cd\u4f5c\u51cf\u95ed\u64cd\u4f5c \u8ba1\u7b97\u516c\u5f0f\u4e3a\uff1a g=(f\u2295b)-(f\u3280b) g=(f\u2295b)-(f\u3280b) 3\uff09\u5e3d\u53d8\u6362 \u7528\u4e00\u4e2a\u7ed3\u6784\u5143\u901a\u8fc7\u5f00\u64cd\u4f5c\u6216\u95ed\u64cd\u4f5c\u4ece\u56fe\u50cf\u4e2d\u5220\u9664\u7269\u4f53\u3002 \u7136\u540e\u5dee\u64cd\u4f5c\u5f97\u5230\u4e00\u5e45\u4ec5\u4fdd\u7559\u5df2\u5220\u9664\u5206\u91cf\u7684\u56fe\u50cf\u3002 \u9876\u5e3d\u53d8\u6362 T_{hat}(f)=f-(f\u2299b) T_{hat}(f)=f-(f\u2299b) \u7070\u5ea6\u7ea7\u56fe\u50cff\u7684\u9876\u5e3d\u53d8\u6362\u662ff\u51cf\u53bb\u5176\u5f00\u64cd\u4f5c \u9876\u5e3d\u53d8\u6362\u7528\u4e8e\u5f97\u5230\u6697\u80cc\u666f\u4e0a\u7684\u4eae\u7269\u4f53\uff08\u767d\u9876\u5e3d\uff09 \u4f4e\u5e3d\u53d8\u6362 T_{hat}(f)=(f\u2022b)-f T_{hat}(f)=(f\u2022b)-f \u7070\u5ea6\u7ea7\u56fe\u50cff\u7684\u5e95\u5e3d\u53d8\u6362\u662ff\u7684\u95ed\u64cd\u4f5c\u51cf\u53bbf \u5e95\u5e3d\u53d8\u6362\u7528\u4e8e\u5f97\u5230\u4eae\u80cc\u666f\u4e0a\u7684\u6697\u7269\u4f53\uff08\u9ed1\u5e95\u5e3d\uff09 \u5e3d\u53d8\u6362\u7684\u5e94\u7528\u6709\u6821\u6b63\u4e0d\u5747\u5300\u5149\u7167\u5f71\u54cd\u3001\u7eb9\u7406\u5206\u5272\u548c\u7c92\u5ea6\u6d4b\u5b9a\uff0c\u5177\u4f53\u4f7f\u7528\u7684\u662f\u5f00\u64cd\u4f5c\uff0c\u51cf\u5c11\u4eae\u5ea6\u8f83\u9ad8\u7684\u90e8\u5206\u3002","title":"\u7b2c\u516b\u7ae0 \u5f62\u6001\u5b66\u56fe\u50cf\u5904\u7406"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_10","text":"\u56fe\u7247\u538b\u7f29 1\uff09\u6570\u636e\u548c\u4fe1\u606f \u6570\u636e\u662f\u4fe1\u606f\u7684\u8f7d\u4f53 \u540c\u91cf\u7684\u6570\u636e\u53ef\u8868\u8fbe\u4e0d\u4fe1\u606f\uff0c\u540c\u91cf\u7684\u4fe1\u606f\u53ef\u7528\u4e0d\u6570\u636e\u8868\u8fbe 2\uff09\u56fe\u7247\u538b\u7f29\u79cd\u7c7b \u4fe1\u606f\u4fdd\u5b58\u578b\u548c\u4fe1\u606f\u635f\u5931\u578b \u6570\u636e\u5197\u4f59 1\uff09\u5197\u4f59\u79cd\u7c7b \u5197\u4f59\u6709\u4e24\u79cd\uff0c\u5206\u522b\u4e3a\u6570\u636e\u8868\u8fbe\u4e86\u65e0\u7528\u7684\u4fe1\u606f\u548c\u6570\u636e\u8868\u8fbe\u4e86\u5df2\u8868\u8fbe\u7684\u4fe1\u606f\u3002 2\uff09\u76f8\u5bf9\u538b\u7f29\u5197\u4f59 \u76f8\u5bf9\u5197\u4f59\u516c\u5f0f\u4e3a R_D=1-\\frac{1}{C_R} R_D=1-\\frac{1}{C_R} \uff0c\u538b\u7f29\u7387\u4e3a C_R=\\frac{n_1}{n2} C_R=\\frac{n_1}{n2} \uff0c C_R C_R \u5728\u533a\u95f4 (0,+\\infty) (0,+\\infty) \u4e2d\u53d6\u503c\u3002n1\u548cn2\u4ee3\u8868\u4e24\u4e2a\u6570\u636e\u96c6\u5408\u4e2d\u7684\u4fe1\u606f\u8f7d\u4f53\u5355\u4f4d\u7684\u6570\u91cf\u3002 3\uff09\u5197\u4f59\u7684\u7c7b\u522b \u7f16\u7801\u5197\u4f59\u3001\u50cf\u7d20\u76f8\u5173\u5197\u4f59\u548c\u5fc3\u91cc\u89c6\u89c9\u5197\u4f59\u3002 \u7f16\u7801\u5197\u4f59\u548c\u4e0e\u7070\u5ea6\u5206\u5e03\u7684\u6982\u7387\u7279\u6027\u6709\u5173\u3002 \u50cf\u7d20\u76f8\u5173\u5197\u4f59\u548c\u7a7a\u95f4\u5197\u4f59\uff0c\u65f6\u95f4\u5197\u4f59\u6709\u5173\u3002 \u5fc3\u7406\u89c6\u89c9\u5197\u4f59\u548c\u4e3b\u89c2\u611f\u89c9\u6709\u5173\u3002 4\uff09\u7f16\u7801\u5197\u4f59 \u56fe\u50cf\u4e2d\u7070\u5ea6\u51fa\u73b0\u7684\u6982\u7387\uff1a p_s(s_k)=n_k/n,k=0,1,..,L-1 p_s(s_k)=n_k/n,k=0,1,..,L-1 \u5e73\u5747\u6bd4\u7279\u6570\uff1a L_{avg}=\\sum^{L-1}_{k=0}l(s_k)p_k(s_k) L_{avg}=\\sum^{L-1}_{k=0}l(s_k)p_k(s_k) \u9884\u671f\u7ed3\u679c\u4e3a\u7528\u8f83\u5c11\u7684\u6bd4\u7279\u6570\u8868\u793a\u51fa\u73b0\u6982\u7387\u8f83\u5927\u7684\u7070\u5ea6\u7ea7\uff0c\u7528\u8f83\u591a\u7684\u6bd4\u7279\u6570\u8868\u793a\u51fa\u73b0\u6982\u7387\u8f83\u5c0f\u7684\u7070\u5ea6\u7ea7 5\uff09\u50cf\u7d20\u95f4\u5197\u4f59 \u4e3b\u8981\u4f53\u73b0\u50cf\u7d20\u95f4\u76f8\u5173\u6027\uff0c\u81ea\u76f8\u5173\u7cfb\u6570\u4e3a\uff1a A(\\Delta n)=\\frac{1}{N-\\Delta n} \\sum^{N-\\Delta n-1}_{X=0}f(x,y)f(x+\\Delta n,y) A(\\Delta n)=\\frac{1}{N-\\Delta n} \\sum^{N-\\Delta n-1}_{X=0}f(x,y)f(x+\\Delta n,y) 3\uff09\u5fc3\u91cc\u89c6\u89c9\u5197\u4f59 \u4e3b\u8981\u4e0e\u4eba\u89c2\u5bdf\u56fe\u50cf\u7684\u65b9\u5f0f\u6709\u5173\uff0c\u5fc3\u7406\u89c6\u89c9\u5197\u4f59\u4e0e\u5b9e\u5728\u7684\u89c6\u89c9\u4fe1\u606f\u6709\u8054\u7cfb \u56fe\u50cf\u4fdd\u771f\u5ea6 \u63cf\u8ff0\u89e3\u7801\u56fe\u50cf\u76f8\u5bf9\u4e8e\u539f\u59cb\u56fe\u50cf\u7684\u504f\u79bb\u7a0b\u5ea6\u3002 1\uff09\u4e3b\u7ba1\u4fdd\u771f\u5ea6\u51c6\u5219 \u4e3b\u7ba1\u89c2\u6d4b\u56fe\u50cf\u7684\u8d28\u91cf\uff0c\u5e76\u5bf9\u56fe\u50cf\u505a\u51fa\u8bc4\u4ef7\uff0c\u4f8b\u5982\u4f18\u79c0\u3001\u826f\u597d\u3001\u53ef\u7528\u3001\u521a\u53ef\u770b\u3001\u5dee\u548c\u4e0d\u80fd\u7528\u3002 2\uff09\u5ba2\u89c2\u4fdd\u771f\u5ea6\u51c6\u5219 \u7528\u7f16\u7801\u8f93\u5165\u56fe\u4e0e\u89e3\u7801\u8f93\u51fa\u56fe\u7684\u67d0\u4e2a\u786e\u5b9a\u51fd\u6570\u8868\u793a\u635f\u5931\u7684\u4fe1 \u606f\u91cf\uff0c \u4fbf\u4e8e\u8ba1\u7b97\u6216\u6d4b\u91cf \u56fe\u50cf\u7f16\u7801\u6a21\u578b \u7f16\u7801\u6a21\u578b\u5206\u4e3a\u4e24\u79cd\uff1a\u4fe1\u606f\u4fdd\u5b58\u578b\u548c\u4fe1\u606f\u635f\u5931\u578b \u65e0\u5931\u771f\u4fe1\u6e90\u7f16\u7801\u5668\u4e0d\u9700\u8981\u91cf\u5316\u5668 \u56fe\u50cf\u7f16\u7801 1\uff09\u4fe1\u606f\u91cf \u6982\u7387\u4e3aP(E)\u7684\u968f\u673a\u4e8b\u4ef6E\u7684\u4fe1\u606f\u91cf\u4e3a l(E)=log\\frac{1}{P(E)}=-logP(E) l(E)=log\\frac{1}{P(E)}=-logP(E) \uff0c\u5176\u4e2dlog\u4ee52\u4e3a\u5e95\u3002 2\uff09\u7f16\u7801\u6548\u7387 \u4fe1\u606f\u71b5\u516c\u5f0f\uff1a H(u)=-\\sum^J_{j=1}p(a_i)log(P(a_i)) H(u)=-\\sum^J_{j=1}p(a_i)log(P(a_i)) \u5b9a\u4e49\u4e86\u89c2\u5bdf\u5230\u5355\u4e2a\u4fe1\u6e90\u7b26\u53f7\u8f93\u51fa\u65f6\u6240\u83b7\u5f97\u7684\u5e73\u5747\u4fe1\u606f\u91cf \u5e73\u5747\u7801\u957f\uff1a L^*_{avg}=\\sum^{J^n}_{j=1}p(a_i)*l(a_i) L^*_{avg}=\\sum^{J^n}_{j=1}p(a_i)*l(a_i) \u7f16\u7801\u6548\u7387\uff1a \\eta=\\frac{H(u)}{L^*_{avg}}*100\\% \\eta=\\frac{H(u)}{L^*_{avg}}*100\\% 3\uff09\u65e0\u635f\u7f16\u7801--\u53d8\u957f\u7f16\u7801 \u54c8\u592b\u66fc\u7f16\u7801 \u7565 \u9999\u519c-\u6cd5\u8bfa\u6bd4\u90a3\u5417 \u4e3b\u8981\u6b65\u9aa4\u4e3a\uff1a (1) \u5c06\u4fe1\u6e90\u7b26\u53f7\u4f9d\u5176\u6982\u7387\u4ece\u5927\u5230\u5c0f\u6392\u5217 (2) \u5c06\u4fe1\u6e90\u7b26\u53f7\u5206\u6210\u6982\u7387\u548c\u63a5\u8fd1\u7684\u4e24\u90e8\u5206 (3) \u5206\u522b\u7ed9\u4e24\u90e8\u5206\u7684\u4fe1\u6e90\u7b26\u53f7\u7ec4\u5408\u8d4b\u503c (4) \u5982\u679c\u4e24\u90e8\u5206\u5747\u53ea\u6709\u4e00\u4e2a\u4fe1\u6e90\u7b26\u53f7\uff0c\u7f16\u7801\u7ed3\u675f\uff0c\u5426\u5219\u8fd4\u56de(2) \u7ee7\u7eed\u8fdb\u884c \u7279\u5f81 \u4e8c\u8005\u5747\u5177\u6709\u5373\u65f6\u6027\uff0c\u6307\u5bf9\u4efb\u610f\u4e00\u4e2a\u6709\u9650\u7684\u7801\u7b26\u53f7\u4e32\uff0c\u53ef\u4ee5\u5bf9\u6bcf\u4e2a\u7801\u5b57 \u5206\u522b\u89e3\u7801\uff0c\u89e3\u7801\u65f6\u4e0d\u9700\u63a5\u6536\u540e\u9762\u7684\u6240\u6709\u7801\u5b57\u3002 \u4e8c\u8005\u5747\u5177\u6709\u552f\u4e00\u6027\uff0c\u6307\u5bf9\u4efb\u610f\u4e00\u4e2a\u6709\u9650\u957f\u7684\u7801\u7b26\u53f7\u4e32 \uff0c\u53ea\u6709\u4e00\u79cd\u5206\u89e3\u6210\u5176\u5404\u4e2a\u7801\u7b26\u53f7\u7684\u65b9\u6cd5\u3002 4\uff09\u65e0\u635f\u7f16\u7801--\u4f4d\u5e73\u9762\u7f16\u7801 \u4f4d\u5e73\u9762\u5206\u89e3 \u5c06\u591a\u7070\u5ea6\u503c\u56fe\u50cf\u5206\u89e3\u6210\u4e00\u7cfb\u5217\u4e8c\u503c\u56fe \u5bf9\u6bcf\u4e00\u5e45\u4e8c\u503c\u56fe\u518d\u7528\u4e8c\u503c\u538b\u7f29\u65b9\u6cd5\uff0c\u4e3b\u8981\u5305\u62ec\u4f4d\u5e73\u9762\u7684\u5206\u89e3\u548c\u7f16\u7801\u3002 \u4f4d\u5e73\u9762\u5206\u89e3\u662f\u6307\u5bf9\u6bcf\u4e00\u4e2a\u7070\u5ea6\u8fdb\u884c\u91cf\u5316\uff0c\u7136\u540e\u5bf9\u56fe\u7247\u8fdb\u884c\u5206\u5c42\uff0c\u5f97\u5230\u6bcf\u4e00\u5c42\u7684\u7070\u5ea6\u3002 \u5e38\u6570\u5757\u7f16\u7801 \u5e38\u6570\u5757\u7f16\u7801\u662f\u6307\u7528\u4e13\u95e8\u7684\u7801\u5b57\u8868\u8fbe\u5168\u662f0\u62161\u7684\u8fde\u901a\u533a\u57df \u5c06\u56fe\u50cf\u5206\u6210\u5168\u9ed1\uff0c\u5168\u767d\u6216\u6df7\u5408\u7684m*n\u5c3a\u5bf8\u5757\u3002 \u51fa\u73b0\u9891\u7387\u6700\u9ad8\u7684\u7c7b\u8d4b\u4e88 1 bit \u7801\u5b570\uff1b\u5176\u5b83\u4e24\u7c7b\u5206\u522b\u8d4b\u4e882 bit\u7801\u5b5710\u548c11\uff0b mn\u6bd4\u7279\u8868\u793a\u7684\u6a21\u5f0f\u3002 \u538b\u7f29\uff1a\u539f\u9700\u7528mn\u6bd4\u7279\u8868\u793a\u7684\u5e38\u6570\u5757\u4e2d\u7684\u50cf\u7d20\u73b0\u5728\u53ea \u75281 bit \u6765\u8868\u793a\u3001 1-D\u6e38\u7a0b\u7f16\u7801 5\uff09\u65e0\u635f\u7f16\u7801--\u65e0\u635f\u9884\u6d4b\u7f16\u7801 \u9884\u6d4b\u7f16\u7801\uff1a \u7a7a\u57df\u65b9\u6cd5\uff0c\u6d88\u9664\u50cf\u7d20\u95f4\u7684\u5197\u4f59\uff0c\u57fa\u672c\u601d\u60f3\u4e3a\u63d0\u53d6\u6bcf\u4e2a\u50cf\u7d20\u4e2d\u7684\u65b0\u4fe1\u606f\uff08\u5b9e\u9645\u503c\u4e0e\u9884\u6d4b\u503c\u7684\u5dee\uff09\u5e76\u5bf9\u5b83 \u4eec\u7f16\u7801\u3002 \u4e3b\u8981\u5206\u4e3a\u4e24\u79cd\uff0c\u6709\u635f\u9884\u6d4b\u7f16\u7801\u548c\u65e0\u635f\u9884\u6d4b\u7f16\u7801\u3002 \u9884\u6d4b\u7f16\u7801\u4e3b\u8981\u6d88\u9664\u4e86\u50cf\u7d20\u95f4\u5197\u4f59\u3002 6\uff09\u6709\u635f\u7f16\u7801--\u6709\u635f\u9884\u6d4b\u7f16\u7801 7\uff09\u6709\u635f\u7f16\u7801--\u53d8\u6362\u7f16\u7801 \u200b \u53d8\u6362\u7f16\u7801\u7684\u4f5c\u7528\u662f\u5c06\u7a7a\u95f4\u57df\u63cf\u8ff0\u7684\u56fe\u50cf\u4fe1\u53f7\u53d8\u6362\u5230\u9891\u7387\u57df\uff0c\u7136\u540e\u5bf9\u53d8\u6362\u540e\u7684\u7cfb\u6570\u8fdb\u884c\u7f16\u7801\u5904\u7406\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u56fe\u50cf\u5728\u7a7a\u95f4\u4e0a\u5177\u6709\u8f83\u5f3a\u7684\u76f8\u5173\u6027\uff0c\u53d8\u6362\u5230\u9891\u7387\u57df\u53ef\u4ee5\u5b9e\u73b0\u53bb\u76f8\u5173\u548c\u80fd\u91cf\u96c6\u4e2d\u3002 \u53d8\u6362\u9009\u62e9 \uff1a \u4e00\u4e2a\u80fd\u628a\u6700\u591a\u7684\u4fe1\u606f\u96c6\u4e2d\u5230\u6700\u5c11\u7684\u7cfb\u6570\u4e0a\u53bb\u7684\u53d8\u6362\u6240\u4ea7\u751f\u7684 \u91cd\u5efa\u5747\u65b9\u8bef\u5dee\u6700\u5c0f \u4e0d\u540c\u53d8\u6362\u7684\u4fe1\u606f\u96c6\u4e2d\u80fd\u529b\u4e0d\u540c \u2013 \u6b63\u5f26\u7c7b\u53d8\u6362\uff08\u5982DFT\u548cDCT\uff09\u8f83\u4f18 \u2013 \u975e\u6b63\u5f26\u7c7b\u53d8\u6362\uff08\u5982WHT: Walsh-Hadamard\uff09 \u5b9e\u73b0\u7b80\u5355 \u2013 \u5c0f\u6ce2\u53d8\u6362\u8ba1\u7b97\u5feb\u4e14\u6709\u5c40\u90e8\u6027\u8d28\uff08\u4e0d\u9700\u5206\u89e3\uff09 DCT\u662f\u8f83\u597d\u7684\uff08\u7efc\u5408\uff09\u9009\u62e9\uff0c\u96c6\u4e2d\u80fd\u529b\u5f3a\uff0c\u5e76\u4e14\u6240\u9700\u8ba1\u7b97\u91cf\u5c0f\u3002","title":"\u7b2c\u4e5d\u7ae0 \u56fe\u50cf\u7f16\u7801"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/","text":"\u53e4\u5178\u5bc6\u7801\u4f53\u5236\u7684\u8ba1\u7b97\uff1a \u00b6 \u5b57\u6bcd\u5bf9\u7167\u8868 \u00b6 \u4eff\u5c04\u53d8\u6362 \u00b6 \u52a0\u5bc6\u53d8\u6362*E* k (*m )= a + b*m mod q \u89e3\u5bc6\u53d8\u6362 *D k ( c )=( c - a )**b* -1 mod q \u5bc6\u94a5\u77ed\u8bed\u5bc6\u7801 \u00b6 \u9009\u62e9\u4e00\u4e2a\u82f1\u6587\u77ed\u8bed\u4f5c\u4e3a\u5bc6\u94a5\u5b57\u6216\u79f0\u5bc6\u94a5\u77ed\u8bed\uff0c\u5982HAPPY NEW YEAR\uff0c\u53bb\u6389\u91cd\u590d\u7684\u5b57\u6bcd\u5f97\u5230HAPYNEWR\u3002\u5c06\u5b83\u4f9d\u6b21\u5199\u5728\u660e\u6587\u5b57\u6bcd\u8868\u7684\u4e0b\u9762\uff0c\u800c\u540e\u518d\u5c06\u5b57\u6bcd\u8868\u4e2d\u672a\u5728\u77ed\u8bed\u4e2d\u51fa\u73b0\u8fc7\u7684\u5b57\u6bcd\u4f9d\u6b21\u5199\u5728\u8fd9\u4e2a\u77ed\u8bed\u540e\u9762\uff0c\u5c31\u53ef\u4ee5\u6784\u9020\u4e00\u4e2a\u4ee3\u6362\u8868\uff0c\u5982\u4e0b\u6240\u793a\uff1a \u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801 \uff08\u591a\u8868\u4ee3\u6362\uff09 \u00b6 \u8bbe\u5bc6\u94a5k=(k[0], k[1],,\u2026,k[d-1])\u5c5e\u4e8eZqd, \u4ee3\u6362\u5e8f\u5217: p=(p[0], p[1],\u2026,p[d-1]), p(x)=x+k[i] mod q. \u660e\u6587\u5e8f\u5217: m=(m[0], m[1],\u2026) \u5bc6\u6587\u5e8f\u5217: c=(m[0]+k[0])(m[1]+k[1])\u2026(m[d-1]+k[d-1]) \u200b (m[d]+k[0])(m[d+1]+k[1])\u2026\u2026 \u8bbe*q*=26, d =6, k =CIPHER=(2,8,15,7,4,17) \u660e\u6587: m =this cryptosystem is not secure \u5bc6\u6587: c =VPXZGI AXIVWP UBTTMJ PWIZIT WZT Hill\u52a0\u5bc6 \uff08\u591a\u5b57\u6bcd\u4ee3\u6362\uff09 \u00b6 \u57fa\u4e8e\u77e9\u9635\u7684\u7ebf\u6027\u53d8\u6362: Z26\u4e3a\u6a2126\u7684\u540c\u4f59\u7c7b\u96c6\u5408, K\u662f\u4e00\u4e2aL*L\u77e9\u9635,\u5728Z26\u4e0a\u53ef\u9006,\u5373\u5b58\u5728K -1 \u4f7f\u5f97: KK -1 = I (\u5728Z26\u4e0a) \u6ce8\uff1a\u660e\u6587\u4e0e\u5bc6\u6587\u90fd\u662fL\u7ef4\u7684\u5411\u91cf m=\uff08m1, m2 \u2026, mL); c=(c1,c2,\u2026,cL); \u52a0\u5bc6\uff1ac=mK mod 26; \u89e3\u5bc6\uff1am=cK -1 mod 26; \u6362\u4f4d\u5bc6\u94a5\uff08\u7efc\u5408\u6848\u4f8b\uff09 \u00b6 \u660e\u6587\uff1a m = the simplest possible transposition ciphers \u5206\u6210\u957f\u5ea6\u4e3a5\u7684\u7ec4\uff1a m = thesi | mples | tposs | iblet | ransp | ositi | oncip | hersx \u52a0\u5bc6\u53d8\u6362\uff1a\u5c06\u5404\u7ec4\u5185\u5b57\u7b26\u6309\u4f4d\u7f6e\u6807\u53f7\uff080~4\uff09\u5b9e\u65bd\u4e0b\u8ff0\u7f6e\u6362\uff08permutation) (Ek\u4e3a\u6b63\u53d8\u6362\uff0cDk\u4e3a\u9006\u53d8\u6362) \u5bc6\u94a5\uff1a c =STIEH EMSLP STSOP EITLB SRPNA TOIIS IOPCN SHXRE \u6d41\u5bc6\u7801 \u00b6 \u6e38\u7a0b\u5206\u5e03\u8ba1\u7b97 \u00b6 \u8bbe*a*= ( a [0], a [1],\u2026, a [i],\u2026)\u662f\u4e00\u4e2a\u5468\u671f\u4e3a*N*\u7684\u4e8c\u5143\u5e8f\u5217\uff0c\u5728\u4e00\u4e2a\u5468\u671f\u5185\u8fde\u7eed\u51fa\u73b0\u7684\u6700\u591a\u7684\u7b26\u53f7\u201c0\u201d\uff08\u62161\uff09\u7684\u4e32\uff0c\u79f0\u4e3a0\uff08\u62161\uff09\u7684\u4e00\u4e2a\u6e38\u7a0b\u3002\u5728\u4e00\u4e2a\u6e38\u7a0b\u4e2d\uff0c0\uff08\u62161\uff09\u7684\u4e2a\u6570\u79f0\u4e3a\u8be5\u6e38\u7a0b\u7684\u957f\u5ea6\u3002 \u5728\u5e8f\u5217 k ={*k*i}=001110100000111100\u2026\u4e2d, \u6709 \u957f\u4e3a1\u76840\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a4\u76840\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a5\u76840\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a1\u76841\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a3\u76841\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a4\u76841\u6e38\u7a0b\u4e00\u4e2a \u6ce8\u610f\u6709\u5468\u671f\uff0c\u5373{*k*i}= 001110100000111100 001110100000111100 \u2026 \u5e8f\u5217\u81ea\u76f8\u5173\u8ba1\u7b97 \u00b6 \u8bbe*a*=( a*0,*a*1,\u2026,*a [N-1])\u548c*b*=( b*0,*b*1,\u2026,*b [N-1])\u662f\u4e24\u4e2a\u5468\u671f\u4e3a*N*\u7684\u4e8c\u5143\u5468\u671f\u5e8f\u5217\uff0c\u5176\u76f8\u5173\u51fd\u6570\u5b9a\u4e49\u4e3a \u5176\u4e2di+t\u662f\u6a21N\u8fd0\u7b97 \u7279\u522b\u5730\uff0c\u5982\u679c*a*= b \uff0c\u5219*R*a*, a ( t)\u88ab\u79f0\u4e3a\u81ea\u76f8\u5173\u51fd\u6570\uff0c\u5176\u4e2d\u5f53t =0\uff0c*R*a , a(0)\u88ab\u79f0\u4e3a\u540c\u76f8\u81ea\u76f8\u5173\u51fd\u6570\uff0c\u800c\u5f53*t*\u4e0d\u7b49\u4e8e0\uff0c R*a , a ( t )\u88ab\u79f0\u4e3a\u5f02\u76f8\u81ea\u76f8\u5173\u51fd\u6570\u3002 \u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\uff08\u8f93\u51fa\u4e3aa1\uff09 \u00b6 \u8bbe\u6709\u9650\u57dfGF(2)\u4e0a\u76843\u7ea7FSR\u7684\u53cd\u9988\u51fd\u6570\u4e3a: f (*x*1, *x*2, *x*3)=*x*1\u5f02\u6216*x*2\u5f02\u6216*x*3 \u521d\u59cb\u72b6\u6001\u4e3a*s*0=(1,0,1). \u6c42FSR\u5e8f\u5217. \u89e3: \u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u5e8f\u5217: a =1011\u2026; \u5468\u671f*q*=4. \u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668 \u00b6 \u5df2\u77e5\u5982\u56fe\u6240\u793a\u76843\u7ea7LFSR. \u7279\u5f81\u591a\u9879\u5f0f\u4e3a\uff1a f ( x )=1+ x 2 + x 3 \u5373\u4e3a a[0]+a[2]+a[3]=0 LFSR\u5e8f\u5217*a*=( a [0], a [1],\u2026, a [n-1],\u2026) \u6ee1\u8db3\u9012\u63a8\u5173\u7cfb\u5f0f: a [n]= a [n-2]+ a [n-3]. \u5982\u679c\u8bbe\u521d\u59cb\u72b6\u6001\u4e3a: (0,0,1) \u5373*a*[0]=0, a [1]=0, a [2]=1,\u8f93\u51fa\u5e8f\u5217\u4e3a: 0010111, \u5468\u671f\u4e3a7. \u5206\u7ec4\u5bc6\u7801 \u00b6 DES\u7b97\u6cd5 \u00b6 DES\u7b97\u6cd5\u6d41\u7a0b \u00b6 \u5206\u7ec4\u5927\u5c0f: 2*w*=64 \u5bc6\u94a5\u5927\u5c0f: | K |=56 \u5b50\u5bc6\u94a5: |K[i]|=48 \u8f6e\u6570: h =16 \u5bf9\u660e\u6587\u4f5c\u7f6e\u6362*IP*\u540e\u5f00\u59cb\u7b2c1\u6b21\u8fed\u4ee3 \u7b2c16\u6b21\u8fed\u4ee3\u540e\uff0c\u4ea4\u6362\u5de6\u3001\u53f332bit\u6570\u636e\uff0c\u518d\u4f5c\u9006\u7f6e\u6362*IP* -1 \uff0c\u5373\u5f97\u5bc6\u6587 IP\u53d8\u6362 \u00b6 \u5c0664\u4f4d\u660e\u6587\u6253\u4e71\u91cd\u65b0\u6392\u5217. \u8bbe*x*= x*1*x*2\u2026*x*64\uff0c\u5219*IP ( x )=*x*58*x*50*x*42\u2026*x*23*x*15*x*7 \u52a0\u5bc6\u7ed3\u679c\uff1a10011000 00000111 00110001 11111101 10010110 01100101 11000010 10001110 \u521d\u59cb\u7f6e\u6362IP\u7684\u9006\u7f6e\u6362 \u5c0664\u4f4d\u5bc6\u6587\u4f4d\u7f6e\u8fd8\u539f. \u8bbe*y*= y*1*y*2\u2026*y*64\uff0c\u5219*IP-1 ( y )=*y*40*y*8*y*48\u2026*y*17*y*57*y*25 \u89e3\u5bc6\u7ed3\u679c\uff1a11011111 00101011 11010000 00100101 10101000 10011100 01000011 01101001 \u8f6e\u51fd\u6570F \u00b6 \u6269\u5c55E\u53d8\u6362\uff08\u5bf9R\u8fdb\u884c\u6269\u5c55\u53d8\u6362\uff09 \u00b6 S\u76d2\u548c\u7f6e\u6362P\u8fd0\u7b97 \uff08S\u76d2\u8f93\u51fa\u7ed3\u679c\u7f6e\u6362\uff09 \u00b6 \u8f93\u5165: b [1] b [2] b [3 ] b [4] b [5] b [6], \u752810\u8fdb\u5236\u8868\u793a: ( i )10= b [1] b [6] (0<=i<=3), ( j )10= b [2] b [3] b [4] b [5] (0<=j<=15) \u5bf9\u4e8e*S*1\uff0c\u8f93\u5165*b*=101011, \u6709*i*=11=3, j =0101=5, \u8f93\u51fa: S*1(*b )= *S*1(3,5)=9=1001. \u5b50\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u00b6 \u7f6e\u6362\u53d8\u6362\uff1aPC-1 \u00b6 64\u4f4d\u5bc6\u94a5*K*\u7684\u7b2c8, 16, 24,\u2026,64\u4f4d\u51718\u4f4d\u662f\u5947\u5076\u6821\u9a8c\u4f4d, \u5176\u4f5956\u4f4d\u4f5c\u4e3a\u5bc6\u94a5\u7528. \u9009\u62e9*K*\u7684\u7b2c57,49,\u2026\u4f4d\u517128\u4f4d\u4f5c\u4e3a\u5bc6\u94a5\u6bb5*C*0;\u9009\u62e9*K*\u7684\u7b2c63,55,\u2026\u4f4d\u517128\u4f4d\u4f5c\u4e3a\u5bc6\u94a5\u6bb5*D*0. \u5faa\u73af\u5de6\u79fbLSi \u00b6 \u5c0628\u4f4d\u7684\u5bc6\u94a5\u6bb5\u4f5c\u4e3a*C*[i], D [i]\u5faa\u73af\u5de6\u79fb1\u62162\u4f4d,\u5de6\u79fb\u4f4d\u6570\u7531\u4e0b\u8868\u786e\u5b9a. \u7f6e\u6362\u9009\u62e9 PC-2 \u00b6 \u4ece56\u4f4d\u5bc6\u94a5\u6bb5*C*[i] ||*D[i]\u4e2d\u9009\u62e948\u4f4d\u4f5c\u4e3a\u5b50\u5bc6\u94a5*K [i]. DES\u89e3\u5bc6\u7b97\u6cd5 \u00b6 \u4e0eDES\u52a0\u5bc6\u7ed3\u6784\u76f8\u540c \u5b50\u5bc6\u94a5\u4f7f\u7528\u6b21\u5e8f\u76f8\u53cd: K [16], K [15], \u2026, K [2], K [1] \u8f93\u5165\uff1a\u5bc6\u6587y; \u8f93\u51fa\uff1a\u660e\u6587*x* IDEA\u4e2d\u4e3b\u8981\u8fd0\u7b97 \u00b6 \u8fd0\u7b97\u2018+\u2019\uff1a\u4e24\u4e2a\u957f\u5ea6\u4e3a16\u7684\u6bd4\u7279\u4e32*x*\u548c*y*\u3002 x \u2018+\u2019*y*\u8868\u793a*x*\u548c*y*\u505a\u9010\u4f4d\u6a212\u52a0\u8fd0\u7b97\uff08\u9010\u6bd4\u7279\u5f02\u6216\uff09\u3002 \u8fd0\u7b97\u201c+\u201d\uff1a\u5c06\u957f\u5ea6\u4e3a16\u7684\u6bd4\u7279\u4e32*x*\u548c*y*\u770b\u4f5c\u662f\u201c\u22650\uff0c\u4e14<2 16 \u201d\u7684\u6574\u6570\u3002 x \u201c+\u201d*y*\u8868\u793a*x*\u548c*y*\u505a\u6a212 16 \u52a0\u8fd0\u7b97\u3002 \u8fd0\u7b97\u00d7\uff1a \u5c06\u957f\u5ea6\u4e3a16\u7684\u6bd4\u7279\u4e32*x*\u548c*y*\u770b\u4f5c\u662f\u201c\u22651\uff0c\u4e14<2 16 +1\u201d\u7684\u6574\u6570\u3002 \u5176\u4e2d\u5c06\u51680\u4e32\u770b\u4f5c\u662f2 16 \u3002 x \u00d7*y*\u8868\u793a*x*\u548c*y*\u505a\u6a212 16 +1\u4e58\u8fd0\u7b97\u3002\uff08\u6ce8\u610f\uff1a 2 16 +1 \u662f\u7d20\u6570\uff09 \u8f6e\u51fd\u6570 \u00b6 \u8f6e\u51fd\u6570\u6570\u636e \u00b6 \u8f6e\u51fd\u6570\u4e3a*M*= F ( m , z ), \u5176\u4e2d*m*\u662f\u660e\u6587\uff0c\u5b83\u662f\u957f\u5ea6\u4e3a64\u7684\u6bd4\u7279\u4e32\uff1b*M*\u662f\u5bc6\u6587\uff0c\u5b83\u662f\u957f\u5ea6\u4e3a64\u7684\u6bd4\u7279\u4e32\uff1b *z*\u662f\u5bc6\u94a5\uff0c\u5b83\u662f\u957f\u5ea6\u4e3a96\u7684\u6bd4\u7279\u4e32\u3002 \u5c06\u660e\u6587*m*\u5206\u4e3a4\u4e2a\u5b50\u5757\uff1a m =( m*1,*m*2,*m*3,*m*4)\uff0c\u5176\u4e2d\u6bcf\u4e2a\u5b50\u5757\u957f\u5ea6\u4e3a16\u3002\u5c06\u5bc6\u6587*M*\u5206\u4e3a4\u4e2a\u5b50\u5757: *M =( M*1,*M*2,*M*3,*M*4), \u5176\u4e2d\u6bcf\u4e2a\u5b50\u5757\u957f\u5ea6\u4e3a16\u3002\u5c06\u5bc6\u94a5*z*\u5206\u4e3a6\u4e2a\u5b50\u5757\uff1a*z =(*z*1,*z*2,*z*3,*z*4,*z*5,*z*6)\uff0c\u5176\u4e2d\u6bcf\u4e2a\u5b50\u5757\u957f\u5ea6\u4e3a16\u3002 \u4e09\u79cd\u8fd0\u7b97\u2018+\u2019\u3001\u201c+\u201d\u3001\u00d7\u5206\u522b\u4e3a\u524d\u9762\u6240\u8ff0\u3002 \u8f6e\u51fd\u6570\u8fd0\u7b97 \u00b6 \u8f6e\u51fd\u6570\u7b97\u6cd5\u63cf\u8ff0\u5982\u4e0b\uff1a \uff081\uff09( m [1], m [2], m [3], m [4])(\u00d7,\u201c+\u201d,\u201c+\u201d,\u00d7) ( z [1], z [2], z [3], z [4])=( a , b , c , d )\u3002 \uff08\u7fa4\u52a0\u5bc6\uff09 \uff082\uff09( a \u2018+\u2019 c , b \u2018+\u2019 d )=( e , f )\u3002\uff08MA\u53d8\u6362\uff09 \uff083\uff09(( e \u00d7 z [5])\u201c+\u201d f )\u00d7 z [6]= u \uff0c u \u201c+\u201d( e \u00d7 z [5])= v \u3002\uff08MA\u53d8\u6362\uff09 \uff084\uff09( a , b , c , d )(\u2018+\u2019,\u2018+\u2019,\u2018+\u2019,\u2018+\u2019) ( u , v , u , v )=( w [1], w [2], w [3], w [4])\u3002\uff08MA\u53d8\u6362\uff09 \uff085\uff09( w [1], w [3], w [2], w*0[4])=(*M [1], M [2], M [3], M [4])\u3002 \uff08\u5757\u7f6e\u6362\uff09 \u52a0\u5bc6\u987a\u5e8f \u00b6 \u5206\u7ec4\u5bc6\u7801IDEA\u7684\u5b8c\u6574\u52a0\u5bc6\u7b97\u6cd5\u662f\u8fde\u7eed8\u6b21\u4f7f\u7528\u8f6e\u51fd\u6570\uff0c\u4e0d\u8fc7\u7b2c8\u8f6e\u4e0e\u524d7\u8f6e\u6709\u6240\u4e0d\u540c\u3002\u524d7\u8f6e\u662f\u666e\u901a\u8f6e\uff0c\u8f6e\u51fd\u6570\u7684\u8fd0\u7b97\u6b65\u9aa4\u5982\u524d\u6240\u8ff0\u4e3a\uff1a \u7fa4\u52a0\u5bc6\u2192MA\u53d8\u6362\u2192\u5757\u7f6e\u6362\u3002 \u7b2c8\u8f6e\u662f\u7279\u6b8a\u8f6e\uff0c\u8f6e\u51fd\u6570\u7684\u8fd0\u7b97\u6b65\u9aa4\u4e3a\uff1a \u7fa4\u52a0\u5bc6\u2192MA\u53d8\u6362\u2192\u7fa4\u52a0\u5bc6\u3002 IDEA\u7b97\u6cd5\u89e3\u5bc6 \u00b6 \u52a0\u89e3\u5bc6\u987a\u5e8f\u4e0d\u540c\uff0c\u53ea\u4e0d\u8fc7\u5bc6\u94a5\u987a\u5e8f\u53d1\u751f\u6539\u53d8\uff1a \u52a0\u5bc6\u5bc6\u94a5(q[1],q[2],q[3],q[4],q[5],q[6])\u5219\u5bf9\u5e94\u7684\u89e3\u5bc6\u5bc6\u94a5\u4e3a( q [1] -1 , - q [3], - q [2], q [4] -1 ,q[5],q[6]) \uff08\u52a0\u4e58\u6cd5\u9006\u8fd0\u7b97\uff09 IDEA \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u00b6 IDEA\u52a0\u5bc6\u7b97\u6cd5\u4e2d\u6240\u4f7f\u7528\u7684\u5bc6\u94a5\u5171\u670952\u4e2a\u5b50\u5757\uff0c\u5373\u52a0\u5bc6\u5bc6\u94a5\u957f\u5ea6\u4e3a16\u00d752=832\uff08\u6bd4\u7279\uff09\u3002\u7528\u6237\u5bc6\u94a5\u5b9e\u9645\u4e0a\u53ea\u6709128 \uff08\u6bd4\u7279\uff09\uff0c\u56e0\u6b64\u9700\u8981\u4e00\u4e2a\u5bc6\u94a5\u6269\u5c55\u7b97\u6cd5\u3002\u5bc6\u94a5\u6269\u5c55\u7b97\u6cd5\u5982\u4e0b\u3002\u5c06128 \u6bd4\u7279\u7684\u7528\u6237\u5bc6\u94a5\u5206\u4e3a8\u4e2a\u5b50\u5757\uff0c\u4f5c\u4e3a\u52a0\u5bc6\u5bc6\u94a5\u7684\u7b2c\u4e00\u4e2a\u201c8\u4e2a\u5b50\u5757\u201d\uff1b\u5c06128 \u6bd4\u7279\u5bc6\u94a5\u5faa\u73af\u5de6\u79fb25\u4f4d\uff0c\u518d\u5206\u4e3a8\u4e2a\u5b50\u5757\uff0c\u4f5c\u4e3a\u52a0\u5bc6\u5bc6\u94a5\u7684\u7b2c\u4e8c\u4e2a\u201c8\u4e2a\u5b50\u5757\u201d\uff1b AES\u7b97\u6cd5 \u00b6 AES\u6d41\u7a0b \u00b6 AES\u7b97\u6cd5\u6a21\u591a\u9879\u5f0f m(x)= x 8 + x 4 + x 3 + x +1. \u5747\u4e3a\u5728GF(2 8 )\u4e0a\u7684\u8fd0\u7b9711 \u521d\u59cb\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0 \u7b2c\u4e00\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e8c\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e09\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u56db\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u7b2cNr-1\u8f6e\uff1a\u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2cNr\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d \u672b\u5c3e\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0 \u5b57\u8282\u4ee3\u6362 \u00b6 \u5bf9\u72b6\u6001\u7684\u6bcf\u4e2a\u5b57\u8282\u72ec\u7acb\u8fdb\u884c\u4ee3\u6362\uff0c\u662f\u5b57\u8282\u7684\u975e\u7ebf\u6027\u53d8\u6362\uff0c\u4e5f\u79f0\u4e3aS\u76d2\u53d8\u6362\u3002\u8bbe ByteSub( a*ij )= b*ij . \u884c\u4f4d\u79fb\u548c\u5217\u6df7\u5408 \u8f6e\u5bc6\u94a5\u52a0 \u89e3\u5bc6\u7b97\u6cd5 \u00b6 \u5b57\u6bcd\u4ee3\u6362 \u00b6 \u5148\u505a\u4eff\u5c04\u7684\u9006\u53d8\u6362\u7136\u540e\u518d\u6c42\u9006 \u884c\u4f4d\u79fb\u548c\u5217\u6df7\u5408 \u00b6 \u884c\u4f4d\u79fb\u9006\u56de\u5373\u53ef \u5217\u6df7\u5408\u5c06\u72b6\u6001\u77e9\u9635\u6bcf\u5217\u76844\u4e2a\u5b57\u8282\u8868\u793a\u6210\u4e00\u4e2a3\u6b21\u591a\u9879\u5f0f\uff0c\u518d\u4e0e\u591a\u9879\u5f0f*d*( x )\u76f8\u4e58. d ( x )=(0B) x 3 +(0D) x 2 +(09) x +(0E). \u89e3\u5bc6\u987a\u5e8f\uff08\u5df2\u5bf9\u5bc6\u94a5\u8fdb\u884c\u53d8\u6362\uff09 \u00b6 \u521d\u59cb\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0 \u7b2c\u4e00\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e8c\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e09\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u56db\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u7b2cNr-1\u8f6e\uff1a\u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2cNr\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d \u672b\u5c3e\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0 \u516c\u94a5\u5bc6\u7801\u4f53\u5236 \u00b6 \u8865\u5145\u6570\u5b66 \u00b6 \u6b27\u62c9\u51fd\u6570 \u00b6 (\u6b27\u62c9\u5b9a\u7406)\u5bf9\u4e8e\u4efb\u4f55\u4e92\u7d20\u7684\u4e24\u4e2a\u6574\u6570a\u548cn\uff0c\u6709 a \u03c6(n) \u2261 1 mod n \u5bf9\u4efb\u610f\u7684\u6b63\u6574\u6570k, \u6709 a k*\u03c6(n) +1\u2261 a mod n \uff0c \u6b27\u62c9\u51fd\u6570*\u03c6(n)*\u7684\u51e0\u6761\u6027\u8d28\uff1a (1) n\u4e3a\u7d20\u6570\uff0c \u03c6(n) = n \uff0d1;(2)\u82e5p\u4e3a\u7d20\u6570\uff0cn\u4e3a\u6b63\u6574\u6570\uff0c\u5219\u03c6(p n )=(p-1)p* n-1 * (3) gcd( m , n ) =1, \u03c6( mn )= \u03c6( m ) \u00d7\u03c6( n ) \u5982\u679c*m*\u662f\u4f7f*a* m \u2261 1 mod *n*\u6210\u7acb\u7684\u6700\u5c0f\u6b63\u6574\u6570\uff0c\u5219\u79f0\u5b83\u662f*a*\u5bf9\u6a21*n*\u7684\u6307\u6570\uff0c\u6216\u8005\u79f0\u4e3a*a*\u5173\u4e8e\u6a21*n*\u7684\u4e58\u6cd5\u9636\uff0c\u8bb0\u4e3aOrd n a\u3002 \u82e5Ord n a= \u03c6 ( n )\uff0c\u5219\u79f0*a*\u662f\u6a21*n*\u7684\u672c\u539f\u6839(primitive root)\uff0c\u4e5f\u79f0\u6a21*n*\u7684\u4e58\u6cd5\u751f\u6210\u5143\u3002 \u6d4b\u8bd5\u65b9\u6cd5:\u4ee4*q*1, q*2,\u2026, *q*n\u662f*p -1\u7684\u7d20\u56e0\u5b50\uff0c\u5bf9\u4e8e\u6240\u6709\u7684*q*1, q*2,\u2026, *q*n, \u8ba1\u7b97*a ( p -1)/q (mod p ) \uff0c\u5982\u679c\u5bf9\u67d0\u4e2a\u7d20\u56e0\u5b50*q*\uff0c\u5176\u7ed3\u679c\u4e3a1\uff0c\u90a3\u4e48*a* \u4e0d\u662f\u4e00\u4e2a\u672c\u539f\u6839\u3002\u5982\u679c\u5bf9\u6240\u6709\u7d20\u56e0\u5b50*q*\uff0c\u5176\u7ed3\u679c\u90fd\u4e0d\u4e3a1 \uff0c\u90a3\u4e48*a* \u662f\u4e00\u4e2a\u672c\u539f\u6839\u3002 \u5bf9\u4e8e\u4e00\u4e2a\u6574\u6570*b*\u548c\u7d20\u6570*n*\u7684\u4e00\u4e2a\u672c\u539f\u6839*a*\uff0c\u53ef\u4ee5\u627e\u5230\u552f\u4e00\u7684\u6307\u6570*x*\uff0c\u4f7f\u5f97*b* \u2261 a x mod n \uff0c\u5176\u4e2d0\u2264 x \u2264 n -1\uff0c\u6307\u6570*x*\u79f0\u4e3a*b*\u7684\u4ee5*a*\u4e3a\u57fa\u6570\u7684\u6a21*n*\u7684\u79bb\u6563\u5bf9\u6570\uff0c\u6c42\u79bb\u6563\u5bf9\u6570\u4e3a\u4e00\u4e2a\u56f0\u96be\u95ee\u9898 \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 \u4e8c\u6b21\u5269\u4f59 RSA\u7b97\u6cd5 \u00b6 \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u00b6 (1) \u9009\u53d6\u4e24\u4e2a\u5927\u7d20\u6570 p , q (2) \u8ba1\u7b97*n*= p*q, \u53d6\u03c6(n)=(p-1)*(q-1) (3) \u968f\u673a\u9009\u53d6*e*: 1< e < \u03c6 ( n )\uff0c\u4e0e*\u03c6*( n )\u4e92\u7d20 (4) \u6839\u636e\u6b27\u51e0\u91cc\u5fb7\u7b97\u6cd5\u8ba1\u7b97*e*\u7684\u9006 d = e -1 : 1< e < \u03c6 ( n )\uff0ce*d = 1 mod \u03c6 ( n ). (5) \u516c\u94a5: PK=( n , e ), \u79c1\u94a5: S*K =( p, *q , d ). \u52a0\u5bc6\u7b97\u6cd5 \u00b6 \u6d88\u606fm: 0<=m<n\uff0c\u5bc6\u6587 c=E PK (m)=m e (mod n) \u89e3\u5bc6\u7b97\u6cd5 \u00b6 \u5bc6\u6587c: 0<=c<n\uff0c\u660e\u6587 m=D SK \u00a9=c d (mod n) Rabin \u516c\u94a5\u5bc6\u7801\u4f53\u5236 \u00b6 \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u00b6 \u9009\u62e9\u4e24\u4e2a\u5927\u7684\u7d20\u6570p\u548cq\uff0c\u8981\u6c42p\u548cq\u90fd\u662f4\u7684\u500d\u6570\u52a03\u3002 \u8ba1\u7b97n=p*q\u3002Bob\u7684\u516c\u94a5\u662fn\uff0c\u5bf9\u5916\u516c\u5e03\u3002 Bob\u7684\u79c1\u94a5\u662f\uff08p\uff0cq\uff09\uff0c\u81ea\u5df1\u79c1\u85cf\u3002 \u52a0\u5bc6\u7b97\u6cd5 \u00b6 \u5c06\u660e\u6587\u901a\u8fc7\u4e00\u4e2a\u53ef\u9006\u6620\u5c04\u4e3a\u4e00\u4e2a\u5c0f\u4e8en\u4e14\u4e0en\u4e92\u7d20\u7684\u6b63\u6574\u6570m,\u5373 0<m<n \u4e14 gcd (m,n)=1\u3002 Alice\u7528Bob\u7684\u516c\u94a5n\uff0c\u8ba1\u7b97\uff1a c=m 2 (mod n)\u3002c\u4e3a\u5bc6\u6587\u3002 \u89e3\u5bc6\u7b97\u6cd5 \u00b6 Bob \u6536\u5230\u5bc6\u6587*c*\u540e\uff0c\u7528\u81ea\u5df1\u7684\u79c1\u94a5\uff08 p \uff0c q \uff09\u8ba1\u7b97 \u80cc\u5305\u516c\u94a5\u5bc6\u7801\u4f53\u5236 \u00b6 \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u00b6 \u53d6n\u4e2a\u5177\u6709\u8d85\u9012\u589e\u6027\u7684\u7269\u54c1\u91cd\u91cf\uff1aa1\uff0ca2\uff0ca3\uff0c\u2026\uff0can\u3002 \u53d6\u6b63\u6574\u6570M\uff0cU\uff0c\u6ee1\u8db3 (1) M>a1+a2+a3+\u2026+an\uff1b(2) M>U\uff1b(3) U*a1>M\uff1b M\u4e0eU\u4e92\u7d20\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u8f97\u8f6c\u76f8\u9664\u6cd5\u8ba1\u7b97\u51faU\u5173\u4e8e(modM)\u7684\u9006\u5143U -1 \u3002 \u8ba1\u7b97\uff1ab1=U*a1(mod M)\uff0cb2=Ua2(mod M) \uff0cb3=Ua3(mod M) \uff0c\u2026\uff0cbn=Uan(mod M) \u3002(\u4e0d\u5177\u6709\u8d85\u9012\u589e\u6027) \u6b64\u65f6 a1=U -1 b1(mod M)\uff0ca2=U -1 b2(mod M)\uff0ca3=U -1 b3(mod M)\uff0c \u2026\uff0can=U -1 bn(mod M) \u3002 {b1\uff0cb2\uff0cb3\uff0c\u2026\uff0cbn}\u662f\u516c\u94a5\u3002 {a1\uff0ca2\uff0ca3\uff0c\u2026\uff0can} \uff0c M\uff0cU\u90fd\u662f\u79c1\u94a5\u3002 \u52a0\u5bc6\u7b97\u6cd5 \u00b6 \u8bbe\u660e\u6587m\u4e3a\u6b63\u6574\u6570\uff0c\u5176\u4e8c\u8fdb\u5236\u5c55\u5f00\u5f0f\u4e3am=(m1,m2,m3\u2026mn) 2 \u3002\u4f7f\u7528\u516c\u94a5{b1\uff0cb2\uff0cb3\uff0c\u2026\uff0cbn}\u8ba1\u7b97\u5bc6\u6587c \uff1ac=m1*b1+m2b2+m3b3+\u2026+mnbn\u3002\u5bc6\u6587c\u662f\u4e00\u4e2a\u6b63\u6574\u6570\u3002 \u89e3\u5bc6\u7b97\u6cd5 \u00b6 \u4f7f\u7528\u79c1\u94a5{a1\uff0ca2\uff0ca3\uff0c\u2026\uff0can} \uff0c M\uff0cU\uff0c\u8ba1\u7b97\u53d8\u6362\u8bfe\u6587C\uff1a C=U -1 c(modM) =U -1 (m1b1+m2b2+m3b3+\u2026+mnbn )(modM) =m1a1+m2a2+m3a3+\u2026+mnan(modM) =m1a1+m2a2+m3a3+\u2026+mnan\u3002 Elgamal \u516c\u94a5\u5bc6\u7801\u4f53\u5236 \u00b6 \u5faa\u73af\u7fa4` \u8bbe(G,*)\u662f\u4e00\u4e2a\u6709\u9650\u7fa4, |G|= n, e\u662fG\u7684\u5355\u4f4d\u5143. \u5982\u679c\u5b58\u5728 a\u5c5e\u4e8eG\uff0c\u4f7f\u5f97a, a2,\u2026, an=e\u4e92\u4e0d\u76f8\u540c,\u5373 G={a, a2,\u2026,an}, \u5219\u79f0a\u662fG\u7684\u4e00\u4e2a\u672c\u539f\u5143\uff08\u751f\u6210\u5143\uff09. (G,*)\u79f0\u4e3a\u5faa\u73af\u7fa4\u3002 \u6709\u9650\u57df \u8bbep\u662f\u4e00\u4e2a\u7d20\u6570, Zp= {0,1,2,\u2026, p-1}. \u5728Zp \u4e2d, \u52a0\u6cd5\u4e0e\u4e58\u6cd5\u6309 mod (p) \u8fdb\u884c, \u5219Zp\u79f0\u4e3a\u4e00\u4e2a\u6709\u9650\u57df\u3002 GF(p)\u7684\u672c\u539f\u5143 \u8bbeZp*= {1,2,\u2026, p-1}, a\u5c5e\u4e8eZp*, \u5982\u679ca, a 2 ,\u2026, a p-1 =1\u4e92\u4e0d\u76f8\u540c,\u5373 Zp*={a, a2,\u2026,ap-1}, \u5219\u79f0a\u662fZp\u7684\u4e00\u4e2a\u672c\u539f\u5143. (Zp*, *)\u662f\u4e00\u4e2a\u5faa\u73af\u7fa4\u3002 \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u00b6 \u5384\u683c\u739b\u5c14(ElGamal)\u5bc6\u7801\u4f53\u5236 \u5bc6\u94a5\u4ea7\u751f: \u9009\u62e9\u7d20\u6570p\uff0c\u6574\u6570g, x\u6ee1\u8db3 0<g, x<p, \u8ba1\u7b97 y=g x mod p. \u516c\u94a5: (p, g, y) \u79c1\u94a5: x \u52a0\u5bc6\u7b97\u6cd5 \u00b6 \u8bbe\u660e\u6587\u4e3am (0<m<p), \u968f\u673a\u9009\u53d6k(0<k<p), \u8ba1\u7b97 c1=g k mod p, c2=y k m mod p. \u5bc6\u6587: c=(c1, c2) \u89e3\u5bc6\u7b97\u6cd5 \u00b6 \u8bbe\u5bc6\u6587\u4e3ac=(c1, c2), \u5219\u660e\u6587\u4e3a m=c2*(c1 x ) -1 mod p. \u692d\u5706\u66f2\u7ebf\u52a0\u89e3\u5bc6\u8fd0\u7b97 \u00b6 \u5bc6\u94a5\u9009\u53d6 \u00b6 \u786e\u5b9a\u516c\u5f00\u53c2\u6570( p , a , b , n , g ) \u9009\u62e9\u4e00\u4e2a\u7d20\u6570*p*, \u786e\u5b9a\u6709\u9650\u57dfGF( p ) \u9009\u62e9*a*, b*\u5c5e\u4e8eGF(*p ), \u786e\u5b9a\u692d\u5706\u66f2\u7ebf*E* \u9009\u62e9*E*\u7684\u4e00\u4e2a\u5faa\u73af\u5b50\u7fa4*H*, \u4f7f\u5f97| H |= n*\u662f\u4e00\u4e2a\u5927\u7d20\u6570 \u9009\u62e9*H*\u7684\u4e00\u4e2a\u672c\u539f\u5143*g . \u786e\u5b9a\u79c1\u94a5: x \u7528\u6237\u968f\u673a\u9009\u53d6*x*\u5c5e\u4e8e{0,1,2,\u2026, n -1} \u786e\u5b9a\u516c\u94a5: y = x*g. \u6709\u9650\u57df\u4e0a\u7684\u692d\u5706\u66f2\u7ebf \u692d\u5706\u66f2\u7ebf\u7fa4\u8ba1\u7b97 \u00b6 \u8bbep>=3\u662f\u7d20\u6570, Fp= {0,1,\u2026, p-1}\u662f\u6709\u9650\u57df, a, b\u5c5e\u4e8ep, \u25b3=4a 3 +27b 2 \u4e0d\u7b49\u4e8e0 mod (p), \u540c\u4f59\u65b9\u7a0b y 2 =x 3 +ax+b \u52a0\u89e3\u5bc6\u7b97\u6cd5 \u00b6 \u52a0\u5bc6\u7b97\u6cd5 \u8bbe\u660e\u6587\u4e3am, \u5c06m\u6620\u5c04\u5230\u5faa\u73af\u7fa4H\u4e0a\u7684\u70b9. \u968f\u673a\u9009\u53d6k\u5c5e\u4e8e{0,1,\u2026,n-1} \u8ba1\u7b97:c1=kg=(x1, y1) \u8ba1\u7b97:c2 =m+ky=(x2, y2) \u5bc6\u6587: c=(c1, c2) \u89e3\u5bc6\u7b97\u6cd5 \u8bbe\u5bc6\u6587\u4e3ac=(c1, c2), \u5219\u660e\u6587\u4e3a m=c2-xc1. \u52a0\u89e3\u5bc6\u4f8b\u5b50 \u00b6 Hash\u51fd\u6570 \u00b6 lHash\u51fd\u6570\u7684\u5206\u7c7b \u5355\u5411Hash\u51fd\u6570\uff08one-way\uff09\u7ed9\u5b9a\u4e00\u4e2aHash\u503c*y*\uff0c\u5982\u679c\u5bfb\u627e\u4e00\u4e2a\u6d88\u606f*x*\uff0c\u4f7f\u5f97*y*= h ( x )\u662f\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u7684\uff0c\u5219\u79f0*h*\u662f\u5355\u5411Hash\u51fd\u6570. \u5f31\u6297\u78b0\u649eHash\u51fd\u6570\uff08weakly collision-free\uff09 \u4efb\u7ed9\u4e00\u4e2a\u6d88\u606f*x*\uff0c\u5982\u679c\u5bfb\u627e\u53e6\u4e00\u4e2a\u4e0d\u540c\u7684\u6d88\u606f*x*\u2019\uff0c\u4f7f\u5f97*h*( x ) = h ( x \u2019)\u662f\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u7684\uff0c\u5219\u79f0*h*\u662f\u5f31\u6297\u78b0\u649eHash\u51fd\u6570. \u5f3a\u6297\u78b0\u649eHash\u51fd\u6570 \uff08strongly collision-free\uff09 \u5982\u679c\u5bfb\u627e\u4e24\u4e2a\u4e0d\u540c\u7684\u6d88\u606f*x*\u548c*x*\u2019\uff0c\u4f7f\u5f97*h*( x )= h ( x \u2019)\u662f\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u7684\uff0c\u5219\u79f0*h*\u662f\u5f3a\u6297\u78b0\u649eHash\u51fd\u6570. \u6570\u5b57\u7b7e\u540d \u00b6 RSA\u7b7e\u540d \u00b6 \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u00b6 \u9009\u53d6\u4e24\u4e2a\u5927\u7d20\u6570p\uff0cq\uff0c\u8ba1\u7b97 n=p*q\uff0c\u53bb\u03c6(n)=( p -1) *( q -1)\u3002 \u4efb\u9009\u6574\u6570e\uff0c\u6ee1\u8db3\uff1a 0< e <\u03c6(n)\uff0c\u4e14gcd(e ,\u03c6(n))=1\u3002 \u7528\u6269\u5c55Euclidean\u7b97\u6cd5\u6c42e\u6a21j(n)\u7684\u9006d\uff0c\u5373 e*d=1 mod \u03c6(n)\u3002 \u7b7e\u540d\u8005\u7684\u516c\u94a5: { n\uff0ce}\uff0c\u79c1\u94a5:{ p\uff0cq\uff0cd}\u3002 \u7b7e\u540d\u7b97\u6cd5 \u8bbe\u6d88\u606f\u4e3ax\uff0c\u5219x\u7684RSA\u7b7e\u540d\u4e3a y=x d mod n \u9a8c\u8bc1\u7b97\u6cd5\u5f53\u63a5\u6536\u65b9\u6536\u5230\u7b7e\u540d(x,y)\u540e\uff0c\u9a8c\u8bc1x=y e mod n Elgamal \u6570\u5b57\u7b7e\u540d \u00b6 \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u9009\u53d6\u4e00\u4e2a\u5927\u7d20\u6570p\uff0cg\u5c5e\u4e8eZp*\u662f\u4e00\u4e2a\u672c\u539f\u5143\uff0cp\u548cg\u662f\u7cfb\u7edf\u516c\u5f00\u53c2\u6570\u3002 \u4efb\u9009\u6574\u6570x\uff0c\u6ee1\u8db3\uff1a1\u2264x\u2264p-2\u3002\u8ba1\u7b97 y=g x mod p. \u7b7e\u540d\u8005\u7684\u516c\u94a5\u4e3ay\uff0c\u79c1\u94a5\u4e3ax\u3002 \u7b7e\u540d\u7b97\u6cd5 \u9a8c\u8bc1\u7b97\u6cd5 \u7f8e\u56fd\u6570\u5b57\u7b7e\u540d\u6807\u51c6 \u00b6 \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5\u7b7e\u540d\u53ca\u9a8c\u8bc1\u7b97\u6cd5 \u4fc4\u7f57\u65af\u6570\u5b57\u7b7e\u540d\u6807\u51c6 \u00b6 \u5bc6\u94a5\u751f\u6210\u51fd\u6570\u7b7e\u540d\u7b97\u6cd5\u53ca\u9a8c\u8bc1\u7b97\u6cd5 FS\u7b7e\u540d \u00b6 \u9009\u53d6\u4e24\u4e2a\u5927\u7d20\u6570*p*\u3001 q \uff0c\u4ee4*n*=p*q\u3002n\u662f\u516c\u5f00\u53c2\u6570\uff0c*p*\u548c*q*\u662f\u7ba1\u7406\u4e2d\u5fc3CA\u638c\u63e1\u7684\u5bc6\u94a5\u3002\u8bbe*h*\u662f\u4e00\u4e2a\u516c\u5f00\u7684Hash\u51fd\u6570\uff0c*k*\u662f\u4e00\u4e2a\u56fa\u5b9a\u7684\u6b63\u6574\u6570\u3002 \u7ba1\u7406\u4e2d\u5fc3CA\u4e3a\u7528\u6237A\u4ea7\u751f*k*\u4e2a\u516c\u5f00\u5bc6\u94a5\uff1a y i (i =1,2,\u2026, k ) \u662f\u6a21*n*\u7684\u5e73\u65b9\u5269\u4f59 \u518d\u4e3a\u7528\u6237A\u4ea7\u751f*k*\u4e2a\u79c1\u94a5\uff08\u4fdd\u5bc6\uff09 \u7b7e\u540d\u7b97\u6cd5 \u9a8c\u8bc1\u7b97\u6cd5","title":"\u73b0\u4ee3\u5bc6\u7801\u5b66"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_1","text":"","title":"\u53e4\u5178\u5bc6\u7801\u4f53\u5236\u7684\u8ba1\u7b97\uff1a"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_2","text":"","title":"\u5b57\u6bcd\u5bf9\u7167\u8868"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_3","text":"\u52a0\u5bc6\u53d8\u6362*E* k (*m )= a + b*m mod q \u89e3\u5bc6\u53d8\u6362 *D k ( c )=( c - a )**b* -1 mod q","title":"\u4eff\u5c04\u53d8\u6362"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_4","text":"\u9009\u62e9\u4e00\u4e2a\u82f1\u6587\u77ed\u8bed\u4f5c\u4e3a\u5bc6\u94a5\u5b57\u6216\u79f0\u5bc6\u94a5\u77ed\u8bed\uff0c\u5982HAPPY NEW YEAR\uff0c\u53bb\u6389\u91cd\u590d\u7684\u5b57\u6bcd\u5f97\u5230HAPYNEWR\u3002\u5c06\u5b83\u4f9d\u6b21\u5199\u5728\u660e\u6587\u5b57\u6bcd\u8868\u7684\u4e0b\u9762\uff0c\u800c\u540e\u518d\u5c06\u5b57\u6bcd\u8868\u4e2d\u672a\u5728\u77ed\u8bed\u4e2d\u51fa\u73b0\u8fc7\u7684\u5b57\u6bcd\u4f9d\u6b21\u5199\u5728\u8fd9\u4e2a\u77ed\u8bed\u540e\u9762\uff0c\u5c31\u53ef\u4ee5\u6784\u9020\u4e00\u4e2a\u4ee3\u6362\u8868\uff0c\u5982\u4e0b\u6240\u793a\uff1a","title":"\u5bc6\u94a5\u77ed\u8bed\u5bc6\u7801"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_5","text":"\u8bbe\u5bc6\u94a5k=(k[0], k[1],,\u2026,k[d-1])\u5c5e\u4e8eZqd, \u4ee3\u6362\u5e8f\u5217: p=(p[0], p[1],\u2026,p[d-1]), p(x)=x+k[i] mod q. \u660e\u6587\u5e8f\u5217: m=(m[0], m[1],\u2026) \u5bc6\u6587\u5e8f\u5217: c=(m[0]+k[0])(m[1]+k[1])\u2026(m[d-1]+k[d-1]) \u200b (m[d]+k[0])(m[d+1]+k[1])\u2026\u2026 \u8bbe*q*=26, d =6, k =CIPHER=(2,8,15,7,4,17) \u660e\u6587: m =this cryptosystem is not secure \u5bc6\u6587: c =VPXZGI AXIVWP UBTTMJ PWIZIT WZT","title":"\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801 \uff08\u591a\u8868\u4ee3\u6362\uff09"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#hill","text":"\u57fa\u4e8e\u77e9\u9635\u7684\u7ebf\u6027\u53d8\u6362: Z26\u4e3a\u6a2126\u7684\u540c\u4f59\u7c7b\u96c6\u5408, K\u662f\u4e00\u4e2aL*L\u77e9\u9635,\u5728Z26\u4e0a\u53ef\u9006,\u5373\u5b58\u5728K -1 \u4f7f\u5f97: KK -1 = I (\u5728Z26\u4e0a) \u6ce8\uff1a\u660e\u6587\u4e0e\u5bc6\u6587\u90fd\u662fL\u7ef4\u7684\u5411\u91cf m=\uff08m1, m2 \u2026, mL); c=(c1,c2,\u2026,cL); \u52a0\u5bc6\uff1ac=mK mod 26; \u89e3\u5bc6\uff1am=cK -1 mod 26;","title":"Hill\u52a0\u5bc6 \uff08\u591a\u5b57\u6bcd\u4ee3\u6362\uff09"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_6","text":"\u660e\u6587\uff1a m = the simplest possible transposition ciphers \u5206\u6210\u957f\u5ea6\u4e3a5\u7684\u7ec4\uff1a m = thesi | mples | tposs | iblet | ransp | ositi | oncip | hersx \u52a0\u5bc6\u53d8\u6362\uff1a\u5c06\u5404\u7ec4\u5185\u5b57\u7b26\u6309\u4f4d\u7f6e\u6807\u53f7\uff080~4\uff09\u5b9e\u65bd\u4e0b\u8ff0\u7f6e\u6362\uff08permutation) (Ek\u4e3a\u6b63\u53d8\u6362\uff0cDk\u4e3a\u9006\u53d8\u6362) \u5bc6\u94a5\uff1a c =STIEH EMSLP STSOP EITLB SRPNA TOIIS IOPCN SHXRE","title":"\u6362\u4f4d\u5bc6\u94a5\uff08\u7efc\u5408\u6848\u4f8b\uff09"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_7","text":"","title":"\u6d41\u5bc6\u7801"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_8","text":"\u8bbe*a*= ( a [0], a [1],\u2026, a [i],\u2026)\u662f\u4e00\u4e2a\u5468\u671f\u4e3a*N*\u7684\u4e8c\u5143\u5e8f\u5217\uff0c\u5728\u4e00\u4e2a\u5468\u671f\u5185\u8fde\u7eed\u51fa\u73b0\u7684\u6700\u591a\u7684\u7b26\u53f7\u201c0\u201d\uff08\u62161\uff09\u7684\u4e32\uff0c\u79f0\u4e3a0\uff08\u62161\uff09\u7684\u4e00\u4e2a\u6e38\u7a0b\u3002\u5728\u4e00\u4e2a\u6e38\u7a0b\u4e2d\uff0c0\uff08\u62161\uff09\u7684\u4e2a\u6570\u79f0\u4e3a\u8be5\u6e38\u7a0b\u7684\u957f\u5ea6\u3002 \u5728\u5e8f\u5217 k ={*k*i}=001110100000111100\u2026\u4e2d, \u6709 \u957f\u4e3a1\u76840\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a4\u76840\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a5\u76840\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a1\u76841\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a3\u76841\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a4\u76841\u6e38\u7a0b\u4e00\u4e2a \u6ce8\u610f\u6709\u5468\u671f\uff0c\u5373{*k*i}= 001110100000111100 001110100000111100 \u2026","title":"\u6e38\u7a0b\u5206\u5e03\u8ba1\u7b97"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_9","text":"\u8bbe*a*=( a*0,*a*1,\u2026,*a [N-1])\u548c*b*=( b*0,*b*1,\u2026,*b [N-1])\u662f\u4e24\u4e2a\u5468\u671f\u4e3a*N*\u7684\u4e8c\u5143\u5468\u671f\u5e8f\u5217\uff0c\u5176\u76f8\u5173\u51fd\u6570\u5b9a\u4e49\u4e3a \u5176\u4e2di+t\u662f\u6a21N\u8fd0\u7b97 \u7279\u522b\u5730\uff0c\u5982\u679c*a*= b \uff0c\u5219*R*a*, a ( t)\u88ab\u79f0\u4e3a\u81ea\u76f8\u5173\u51fd\u6570\uff0c\u5176\u4e2d\u5f53t =0\uff0c*R*a , a(0)\u88ab\u79f0\u4e3a\u540c\u76f8\u81ea\u76f8\u5173\u51fd\u6570\uff0c\u800c\u5f53*t*\u4e0d\u7b49\u4e8e0\uff0c R*a , a ( t )\u88ab\u79f0\u4e3a\u5f02\u76f8\u81ea\u76f8\u5173\u51fd\u6570\u3002","title":"\u5e8f\u5217\u81ea\u76f8\u5173\u8ba1\u7b97"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#a1","text":"\u8bbe\u6709\u9650\u57dfGF(2)\u4e0a\u76843\u7ea7FSR\u7684\u53cd\u9988\u51fd\u6570\u4e3a: f (*x*1, *x*2, *x*3)=*x*1\u5f02\u6216*x*2\u5f02\u6216*x*3 \u521d\u59cb\u72b6\u6001\u4e3a*s*0=(1,0,1). \u6c42FSR\u5e8f\u5217. \u89e3: \u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u5e8f\u5217: a =1011\u2026; \u5468\u671f*q*=4.","title":"\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\uff08\u8f93\u51fa\u4e3aa1\uff09"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_10","text":"\u5df2\u77e5\u5982\u56fe\u6240\u793a\u76843\u7ea7LFSR. \u7279\u5f81\u591a\u9879\u5f0f\u4e3a\uff1a f ( x )=1+ x 2 + x 3 \u5373\u4e3a a[0]+a[2]+a[3]=0 LFSR\u5e8f\u5217*a*=( a [0], a [1],\u2026, a [n-1],\u2026) \u6ee1\u8db3\u9012\u63a8\u5173\u7cfb\u5f0f: a [n]= a [n-2]+ a [n-3]. \u5982\u679c\u8bbe\u521d\u59cb\u72b6\u6001\u4e3a: (0,0,1) \u5373*a*[0]=0, a [1]=0, a [2]=1,\u8f93\u51fa\u5e8f\u5217\u4e3a: 0010111, \u5468\u671f\u4e3a7.","title":"\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_11","text":"","title":"\u5206\u7ec4\u5bc6\u7801"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#des","text":"","title":"DES\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#des_1","text":"\u5206\u7ec4\u5927\u5c0f: 2*w*=64 \u5bc6\u94a5\u5927\u5c0f: | K |=56 \u5b50\u5bc6\u94a5: |K[i]|=48 \u8f6e\u6570: h =16 \u5bf9\u660e\u6587\u4f5c\u7f6e\u6362*IP*\u540e\u5f00\u59cb\u7b2c1\u6b21\u8fed\u4ee3 \u7b2c16\u6b21\u8fed\u4ee3\u540e\uff0c\u4ea4\u6362\u5de6\u3001\u53f332bit\u6570\u636e\uff0c\u518d\u4f5c\u9006\u7f6e\u6362*IP* -1 \uff0c\u5373\u5f97\u5bc6\u6587","title":"DES\u7b97\u6cd5\u6d41\u7a0b"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#ip","text":"\u5c0664\u4f4d\u660e\u6587\u6253\u4e71\u91cd\u65b0\u6392\u5217. \u8bbe*x*= x*1*x*2\u2026*x*64\uff0c\u5219*IP ( x )=*x*58*x*50*x*42\u2026*x*23*x*15*x*7 \u52a0\u5bc6\u7ed3\u679c\uff1a10011000 00000111 00110001 11111101 10010110 01100101 11000010 10001110 \u521d\u59cb\u7f6e\u6362IP\u7684\u9006\u7f6e\u6362 \u5c0664\u4f4d\u5bc6\u6587\u4f4d\u7f6e\u8fd8\u539f. \u8bbe*y*= y*1*y*2\u2026*y*64\uff0c\u5219*IP-1 ( y )=*y*40*y*8*y*48\u2026*y*17*y*57*y*25 \u89e3\u5bc6\u7ed3\u679c\uff1a11011111 00101011 11010000 00100101 10101000 10011100 01000011 01101001","title":"IP\u53d8\u6362"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#f","text":"","title":"\u8f6e\u51fd\u6570F"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#er","text":"","title":"\u6269\u5c55E\u53d8\u6362\uff08\u5bf9R\u8fdb\u884c\u6269\u5c55\u53d8\u6362\uff09"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#sp-s","text":"\u8f93\u5165: b [1] b [2] b [3 ] b [4] b [5] b [6], \u752810\u8fdb\u5236\u8868\u793a: ( i )10= b [1] b [6] (0<=i<=3), ( j )10= b [2] b [3] b [4] b [5] (0<=j<=15) \u5bf9\u4e8e*S*1\uff0c\u8f93\u5165*b*=101011, \u6709*i*=11=3, j =0101=5, \u8f93\u51fa: S*1(*b )= *S*1(3,5)=9=1001.","title":"S\u76d2\u548c\u7f6e\u6362P\u8fd0\u7b97 \uff08S\u76d2\u8f93\u51fa\u7ed3\u679c\u7f6e\u6362\uff09"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_12","text":"","title":"\u5b50\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#pc-1","text":"64\u4f4d\u5bc6\u94a5*K*\u7684\u7b2c8, 16, 24,\u2026,64\u4f4d\u51718\u4f4d\u662f\u5947\u5076\u6821\u9a8c\u4f4d, \u5176\u4f5956\u4f4d\u4f5c\u4e3a\u5bc6\u94a5\u7528. \u9009\u62e9*K*\u7684\u7b2c57,49,\u2026\u4f4d\u517128\u4f4d\u4f5c\u4e3a\u5bc6\u94a5\u6bb5*C*0;\u9009\u62e9*K*\u7684\u7b2c63,55,\u2026\u4f4d\u517128\u4f4d\u4f5c\u4e3a\u5bc6\u94a5\u6bb5*D*0.","title":"\u7f6e\u6362\u53d8\u6362\uff1aPC-1"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#lsi","text":"\u5c0628\u4f4d\u7684\u5bc6\u94a5\u6bb5\u4f5c\u4e3a*C*[i], D [i]\u5faa\u73af\u5de6\u79fb1\u62162\u4f4d,\u5de6\u79fb\u4f4d\u6570\u7531\u4e0b\u8868\u786e\u5b9a.","title":"\u5faa\u73af\u5de6\u79fbLSi"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#pc-2","text":"\u4ece56\u4f4d\u5bc6\u94a5\u6bb5*C*[i] ||*D[i]\u4e2d\u9009\u62e948\u4f4d\u4f5c\u4e3a\u5b50\u5bc6\u94a5*K [i].","title":"\u7f6e\u6362\u9009\u62e9 PC-2"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#des_2","text":"\u4e0eDES\u52a0\u5bc6\u7ed3\u6784\u76f8\u540c \u5b50\u5bc6\u94a5\u4f7f\u7528\u6b21\u5e8f\u76f8\u53cd: K [16], K [15], \u2026, K [2], K [1] \u8f93\u5165\uff1a\u5bc6\u6587y; \u8f93\u51fa\uff1a\u660e\u6587*x*","title":"DES\u89e3\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#idea","text":"\u8fd0\u7b97\u2018+\u2019\uff1a\u4e24\u4e2a\u957f\u5ea6\u4e3a16\u7684\u6bd4\u7279\u4e32*x*\u548c*y*\u3002 x \u2018+\u2019*y*\u8868\u793a*x*\u548c*y*\u505a\u9010\u4f4d\u6a212\u52a0\u8fd0\u7b97\uff08\u9010\u6bd4\u7279\u5f02\u6216\uff09\u3002 \u8fd0\u7b97\u201c+\u201d\uff1a\u5c06\u957f\u5ea6\u4e3a16\u7684\u6bd4\u7279\u4e32*x*\u548c*y*\u770b\u4f5c\u662f\u201c\u22650\uff0c\u4e14<2 16 \u201d\u7684\u6574\u6570\u3002 x \u201c+\u201d*y*\u8868\u793a*x*\u548c*y*\u505a\u6a212 16 \u52a0\u8fd0\u7b97\u3002 \u8fd0\u7b97\u00d7\uff1a \u5c06\u957f\u5ea6\u4e3a16\u7684\u6bd4\u7279\u4e32*x*\u548c*y*\u770b\u4f5c\u662f\u201c\u22651\uff0c\u4e14<2 16 +1\u201d\u7684\u6574\u6570\u3002 \u5176\u4e2d\u5c06\u51680\u4e32\u770b\u4f5c\u662f2 16 \u3002 x \u00d7*y*\u8868\u793a*x*\u548c*y*\u505a\u6a212 16 +1\u4e58\u8fd0\u7b97\u3002\uff08\u6ce8\u610f\uff1a 2 16 +1 \u662f\u7d20\u6570\uff09","title":"IDEA\u4e2d\u4e3b\u8981\u8fd0\u7b97"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_13","text":"","title":"\u8f6e\u51fd\u6570"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_14","text":"\u8f6e\u51fd\u6570\u4e3a*M*= F ( m , z ), \u5176\u4e2d*m*\u662f\u660e\u6587\uff0c\u5b83\u662f\u957f\u5ea6\u4e3a64\u7684\u6bd4\u7279\u4e32\uff1b*M*\u662f\u5bc6\u6587\uff0c\u5b83\u662f\u957f\u5ea6\u4e3a64\u7684\u6bd4\u7279\u4e32\uff1b *z*\u662f\u5bc6\u94a5\uff0c\u5b83\u662f\u957f\u5ea6\u4e3a96\u7684\u6bd4\u7279\u4e32\u3002 \u5c06\u660e\u6587*m*\u5206\u4e3a4\u4e2a\u5b50\u5757\uff1a m =( m*1,*m*2,*m*3,*m*4)\uff0c\u5176\u4e2d\u6bcf\u4e2a\u5b50\u5757\u957f\u5ea6\u4e3a16\u3002\u5c06\u5bc6\u6587*M*\u5206\u4e3a4\u4e2a\u5b50\u5757: *M =( M*1,*M*2,*M*3,*M*4), \u5176\u4e2d\u6bcf\u4e2a\u5b50\u5757\u957f\u5ea6\u4e3a16\u3002\u5c06\u5bc6\u94a5*z*\u5206\u4e3a6\u4e2a\u5b50\u5757\uff1a*z =(*z*1,*z*2,*z*3,*z*4,*z*5,*z*6)\uff0c\u5176\u4e2d\u6bcf\u4e2a\u5b50\u5757\u957f\u5ea6\u4e3a16\u3002 \u4e09\u79cd\u8fd0\u7b97\u2018+\u2019\u3001\u201c+\u201d\u3001\u00d7\u5206\u522b\u4e3a\u524d\u9762\u6240\u8ff0\u3002","title":"\u8f6e\u51fd\u6570\u6570\u636e"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_15","text":"\u8f6e\u51fd\u6570\u7b97\u6cd5\u63cf\u8ff0\u5982\u4e0b\uff1a \uff081\uff09( m [1], m [2], m [3], m [4])(\u00d7,\u201c+\u201d,\u201c+\u201d,\u00d7) ( z [1], z [2], z [3], z [4])=( a , b , c , d )\u3002 \uff08\u7fa4\u52a0\u5bc6\uff09 \uff082\uff09( a \u2018+\u2019 c , b \u2018+\u2019 d )=( e , f )\u3002\uff08MA\u53d8\u6362\uff09 \uff083\uff09(( e \u00d7 z [5])\u201c+\u201d f )\u00d7 z [6]= u \uff0c u \u201c+\u201d( e \u00d7 z [5])= v \u3002\uff08MA\u53d8\u6362\uff09 \uff084\uff09( a , b , c , d )(\u2018+\u2019,\u2018+\u2019,\u2018+\u2019,\u2018+\u2019) ( u , v , u , v )=( w [1], w [2], w [3], w [4])\u3002\uff08MA\u53d8\u6362\uff09 \uff085\uff09( w [1], w [3], w [2], w*0[4])=(*M [1], M [2], M [3], M [4])\u3002 \uff08\u5757\u7f6e\u6362\uff09","title":"\u8f6e\u51fd\u6570\u8fd0\u7b97"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_16","text":"\u5206\u7ec4\u5bc6\u7801IDEA\u7684\u5b8c\u6574\u52a0\u5bc6\u7b97\u6cd5\u662f\u8fde\u7eed8\u6b21\u4f7f\u7528\u8f6e\u51fd\u6570\uff0c\u4e0d\u8fc7\u7b2c8\u8f6e\u4e0e\u524d7\u8f6e\u6709\u6240\u4e0d\u540c\u3002\u524d7\u8f6e\u662f\u666e\u901a\u8f6e\uff0c\u8f6e\u51fd\u6570\u7684\u8fd0\u7b97\u6b65\u9aa4\u5982\u524d\u6240\u8ff0\u4e3a\uff1a \u7fa4\u52a0\u5bc6\u2192MA\u53d8\u6362\u2192\u5757\u7f6e\u6362\u3002 \u7b2c8\u8f6e\u662f\u7279\u6b8a\u8f6e\uff0c\u8f6e\u51fd\u6570\u7684\u8fd0\u7b97\u6b65\u9aa4\u4e3a\uff1a \u7fa4\u52a0\u5bc6\u2192MA\u53d8\u6362\u2192\u7fa4\u52a0\u5bc6\u3002","title":"\u52a0\u5bc6\u987a\u5e8f"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#idea_1","text":"\u52a0\u89e3\u5bc6\u987a\u5e8f\u4e0d\u540c\uff0c\u53ea\u4e0d\u8fc7\u5bc6\u94a5\u987a\u5e8f\u53d1\u751f\u6539\u53d8\uff1a \u52a0\u5bc6\u5bc6\u94a5(q[1],q[2],q[3],q[4],q[5],q[6])\u5219\u5bf9\u5e94\u7684\u89e3\u5bc6\u5bc6\u94a5\u4e3a( q [1] -1 , - q [3], - q [2], q [4] -1 ,q[5],q[6]) \uff08\u52a0\u4e58\u6cd5\u9006\u8fd0\u7b97\uff09","title":"IDEA\u7b97\u6cd5\u89e3\u5bc6"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#idea_2","text":"IDEA\u52a0\u5bc6\u7b97\u6cd5\u4e2d\u6240\u4f7f\u7528\u7684\u5bc6\u94a5\u5171\u670952\u4e2a\u5b50\u5757\uff0c\u5373\u52a0\u5bc6\u5bc6\u94a5\u957f\u5ea6\u4e3a16\u00d752=832\uff08\u6bd4\u7279\uff09\u3002\u7528\u6237\u5bc6\u94a5\u5b9e\u9645\u4e0a\u53ea\u6709128 \uff08\u6bd4\u7279\uff09\uff0c\u56e0\u6b64\u9700\u8981\u4e00\u4e2a\u5bc6\u94a5\u6269\u5c55\u7b97\u6cd5\u3002\u5bc6\u94a5\u6269\u5c55\u7b97\u6cd5\u5982\u4e0b\u3002\u5c06128 \u6bd4\u7279\u7684\u7528\u6237\u5bc6\u94a5\u5206\u4e3a8\u4e2a\u5b50\u5757\uff0c\u4f5c\u4e3a\u52a0\u5bc6\u5bc6\u94a5\u7684\u7b2c\u4e00\u4e2a\u201c8\u4e2a\u5b50\u5757\u201d\uff1b\u5c06128 \u6bd4\u7279\u5bc6\u94a5\u5faa\u73af\u5de6\u79fb25\u4f4d\uff0c\u518d\u5206\u4e3a8\u4e2a\u5b50\u5757\uff0c\u4f5c\u4e3a\u52a0\u5bc6\u5bc6\u94a5\u7684\u7b2c\u4e8c\u4e2a\u201c8\u4e2a\u5b50\u5757\u201d\uff1b","title":"IDEA \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#aes","text":"","title":"AES\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#aes_1","text":"AES\u7b97\u6cd5\u6a21\u591a\u9879\u5f0f m(x)= x 8 + x 4 + x 3 + x +1. \u5747\u4e3a\u5728GF(2 8 )\u4e0a\u7684\u8fd0\u7b9711 \u521d\u59cb\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0 \u7b2c\u4e00\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e8c\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e09\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u56db\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u7b2cNr-1\u8f6e\uff1a\u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2cNr\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d \u672b\u5c3e\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0","title":"AES\u6d41\u7a0b"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_17","text":"\u5bf9\u72b6\u6001\u7684\u6bcf\u4e2a\u5b57\u8282\u72ec\u7acb\u8fdb\u884c\u4ee3\u6362\uff0c\u662f\u5b57\u8282\u7684\u975e\u7ebf\u6027\u53d8\u6362\uff0c\u4e5f\u79f0\u4e3aS\u76d2\u53d8\u6362\u3002\u8bbe ByteSub( a*ij )= b*ij . \u884c\u4f4d\u79fb\u548c\u5217\u6df7\u5408 \u8f6e\u5bc6\u94a5\u52a0","title":"\u5b57\u8282\u4ee3\u6362"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_18","text":"","title":"\u89e3\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_19","text":"\u5148\u505a\u4eff\u5c04\u7684\u9006\u53d8\u6362\u7136\u540e\u518d\u6c42\u9006","title":"\u5b57\u6bcd\u4ee3\u6362"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_20","text":"\u884c\u4f4d\u79fb\u9006\u56de\u5373\u53ef \u5217\u6df7\u5408\u5c06\u72b6\u6001\u77e9\u9635\u6bcf\u5217\u76844\u4e2a\u5b57\u8282\u8868\u793a\u6210\u4e00\u4e2a3\u6b21\u591a\u9879\u5f0f\uff0c\u518d\u4e0e\u591a\u9879\u5f0f*d*( x )\u76f8\u4e58. d ( x )=(0B) x 3 +(0D) x 2 +(09) x +(0E).","title":"\u884c\u4f4d\u79fb\u548c\u5217\u6df7\u5408"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_21","text":"\u521d\u59cb\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0 \u7b2c\u4e00\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e8c\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e09\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u56db\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u7b2cNr-1\u8f6e\uff1a\u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2cNr\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d \u672b\u5c3e\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0","title":"\u89e3\u5bc6\u987a\u5e8f\uff08\u5df2\u5bf9\u5bc6\u94a5\u8fdb\u884c\u53d8\u6362\uff09"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_22","text":"","title":"\u516c\u94a5\u5bc6\u7801\u4f53\u5236"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_23","text":"","title":"\u8865\u5145\u6570\u5b66"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_24","text":"(\u6b27\u62c9\u5b9a\u7406)\u5bf9\u4e8e\u4efb\u4f55\u4e92\u7d20\u7684\u4e24\u4e2a\u6574\u6570a\u548cn\uff0c\u6709 a \u03c6(n) \u2261 1 mod n \u5bf9\u4efb\u610f\u7684\u6b63\u6574\u6570k, \u6709 a k*\u03c6(n) +1\u2261 a mod n \uff0c \u6b27\u62c9\u51fd\u6570*\u03c6(n)*\u7684\u51e0\u6761\u6027\u8d28\uff1a (1) n\u4e3a\u7d20\u6570\uff0c \u03c6(n) = n \uff0d1;(2)\u82e5p\u4e3a\u7d20\u6570\uff0cn\u4e3a\u6b63\u6574\u6570\uff0c\u5219\u03c6(p n )=(p-1)p* n-1 * (3) gcd( m , n ) =1, \u03c6( mn )= \u03c6( m ) \u00d7\u03c6( n ) \u5982\u679c*m*\u662f\u4f7f*a* m \u2261 1 mod *n*\u6210\u7acb\u7684\u6700\u5c0f\u6b63\u6574\u6570\uff0c\u5219\u79f0\u5b83\u662f*a*\u5bf9\u6a21*n*\u7684\u6307\u6570\uff0c\u6216\u8005\u79f0\u4e3a*a*\u5173\u4e8e\u6a21*n*\u7684\u4e58\u6cd5\u9636\uff0c\u8bb0\u4e3aOrd n a\u3002 \u82e5Ord n a= \u03c6 ( n )\uff0c\u5219\u79f0*a*\u662f\u6a21*n*\u7684\u672c\u539f\u6839(primitive root)\uff0c\u4e5f\u79f0\u6a21*n*\u7684\u4e58\u6cd5\u751f\u6210\u5143\u3002 \u6d4b\u8bd5\u65b9\u6cd5:\u4ee4*q*1, q*2,\u2026, *q*n\u662f*p -1\u7684\u7d20\u56e0\u5b50\uff0c\u5bf9\u4e8e\u6240\u6709\u7684*q*1, q*2,\u2026, *q*n, \u8ba1\u7b97*a ( p -1)/q (mod p ) \uff0c\u5982\u679c\u5bf9\u67d0\u4e2a\u7d20\u56e0\u5b50*q*\uff0c\u5176\u7ed3\u679c\u4e3a1\uff0c\u90a3\u4e48*a* \u4e0d\u662f\u4e00\u4e2a\u672c\u539f\u6839\u3002\u5982\u679c\u5bf9\u6240\u6709\u7d20\u56e0\u5b50*q*\uff0c\u5176\u7ed3\u679c\u90fd\u4e0d\u4e3a1 \uff0c\u90a3\u4e48*a* \u662f\u4e00\u4e2a\u672c\u539f\u6839\u3002 \u5bf9\u4e8e\u4e00\u4e2a\u6574\u6570*b*\u548c\u7d20\u6570*n*\u7684\u4e00\u4e2a\u672c\u539f\u6839*a*\uff0c\u53ef\u4ee5\u627e\u5230\u552f\u4e00\u7684\u6307\u6570*x*\uff0c\u4f7f\u5f97*b* \u2261 a x mod n \uff0c\u5176\u4e2d0\u2264 x \u2264 n -1\uff0c\u6307\u6570*x*\u79f0\u4e3a*b*\u7684\u4ee5*a*\u4e3a\u57fa\u6570\u7684\u6a21*n*\u7684\u79bb\u6563\u5bf9\u6570\uff0c\u6c42\u79bb\u6563\u5bf9\u6570\u4e3a\u4e00\u4e2a\u56f0\u96be\u95ee\u9898 \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 \u4e8c\u6b21\u5269\u4f59","title":"\u6b27\u62c9\u51fd\u6570"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#rsa","text":"","title":"RSA\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_25","text":"(1) \u9009\u53d6\u4e24\u4e2a\u5927\u7d20\u6570 p , q (2) \u8ba1\u7b97*n*= p*q, \u53d6\u03c6(n)=(p-1)*(q-1) (3) \u968f\u673a\u9009\u53d6*e*: 1< e < \u03c6 ( n )\uff0c\u4e0e*\u03c6*( n )\u4e92\u7d20 (4) \u6839\u636e\u6b27\u51e0\u91cc\u5fb7\u7b97\u6cd5\u8ba1\u7b97*e*\u7684\u9006 d = e -1 : 1< e < \u03c6 ( n )\uff0ce*d = 1 mod \u03c6 ( n ). (5) \u516c\u94a5: PK=( n , e ), \u79c1\u94a5: S*K =( p, *q , d ).","title":"\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_26","text":"\u6d88\u606fm: 0<=m<n\uff0c\u5bc6\u6587 c=E PK (m)=m e (mod n)","title":"\u52a0\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_27","text":"\u5bc6\u6587c: 0<=c<n\uff0c\u660e\u6587 m=D SK \u00a9=c d (mod n)","title":"\u89e3\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#rabin","text":"","title":"Rabin \u516c\u94a5\u5bc6\u7801\u4f53\u5236"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_28","text":"\u9009\u62e9\u4e24\u4e2a\u5927\u7684\u7d20\u6570p\u548cq\uff0c\u8981\u6c42p\u548cq\u90fd\u662f4\u7684\u500d\u6570\u52a03\u3002 \u8ba1\u7b97n=p*q\u3002Bob\u7684\u516c\u94a5\u662fn\uff0c\u5bf9\u5916\u516c\u5e03\u3002 Bob\u7684\u79c1\u94a5\u662f\uff08p\uff0cq\uff09\uff0c\u81ea\u5df1\u79c1\u85cf\u3002","title":"\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_29","text":"\u5c06\u660e\u6587\u901a\u8fc7\u4e00\u4e2a\u53ef\u9006\u6620\u5c04\u4e3a\u4e00\u4e2a\u5c0f\u4e8en\u4e14\u4e0en\u4e92\u7d20\u7684\u6b63\u6574\u6570m,\u5373 0<m<n \u4e14 gcd (m,n)=1\u3002 Alice\u7528Bob\u7684\u516c\u94a5n\uff0c\u8ba1\u7b97\uff1a c=m 2 (mod n)\u3002c\u4e3a\u5bc6\u6587\u3002","title":"\u52a0\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_30","text":"Bob \u6536\u5230\u5bc6\u6587*c*\u540e\uff0c\u7528\u81ea\u5df1\u7684\u79c1\u94a5\uff08 p \uff0c q \uff09\u8ba1\u7b97","title":"\u89e3\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_31","text":"","title":"\u80cc\u5305\u516c\u94a5\u5bc6\u7801\u4f53\u5236"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_32","text":"\u53d6n\u4e2a\u5177\u6709\u8d85\u9012\u589e\u6027\u7684\u7269\u54c1\u91cd\u91cf\uff1aa1\uff0ca2\uff0ca3\uff0c\u2026\uff0can\u3002 \u53d6\u6b63\u6574\u6570M\uff0cU\uff0c\u6ee1\u8db3 (1) M>a1+a2+a3+\u2026+an\uff1b(2) M>U\uff1b(3) U*a1>M\uff1b M\u4e0eU\u4e92\u7d20\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u8f97\u8f6c\u76f8\u9664\u6cd5\u8ba1\u7b97\u51faU\u5173\u4e8e(modM)\u7684\u9006\u5143U -1 \u3002 \u8ba1\u7b97\uff1ab1=U*a1(mod M)\uff0cb2=Ua2(mod M) \uff0cb3=Ua3(mod M) \uff0c\u2026\uff0cbn=Uan(mod M) \u3002(\u4e0d\u5177\u6709\u8d85\u9012\u589e\u6027) \u6b64\u65f6 a1=U -1 b1(mod M)\uff0ca2=U -1 b2(mod M)\uff0ca3=U -1 b3(mod M)\uff0c \u2026\uff0can=U -1 bn(mod M) \u3002 {b1\uff0cb2\uff0cb3\uff0c\u2026\uff0cbn}\u662f\u516c\u94a5\u3002 {a1\uff0ca2\uff0ca3\uff0c\u2026\uff0can} \uff0c M\uff0cU\u90fd\u662f\u79c1\u94a5\u3002","title":"\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_33","text":"\u8bbe\u660e\u6587m\u4e3a\u6b63\u6574\u6570\uff0c\u5176\u4e8c\u8fdb\u5236\u5c55\u5f00\u5f0f\u4e3am=(m1,m2,m3\u2026mn) 2 \u3002\u4f7f\u7528\u516c\u94a5{b1\uff0cb2\uff0cb3\uff0c\u2026\uff0cbn}\u8ba1\u7b97\u5bc6\u6587c \uff1ac=m1*b1+m2b2+m3b3+\u2026+mnbn\u3002\u5bc6\u6587c\u662f\u4e00\u4e2a\u6b63\u6574\u6570\u3002","title":"\u52a0\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_34","text":"\u4f7f\u7528\u79c1\u94a5{a1\uff0ca2\uff0ca3\uff0c\u2026\uff0can} \uff0c M\uff0cU\uff0c\u8ba1\u7b97\u53d8\u6362\u8bfe\u6587C\uff1a C=U -1 c(modM) =U -1 (m1b1+m2b2+m3b3+\u2026+mnbn )(modM) =m1a1+m2a2+m3a3+\u2026+mnan(modM) =m1a1+m2a2+m3a3+\u2026+mnan\u3002","title":"\u89e3\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#elgamal","text":"\u5faa\u73af\u7fa4` \u8bbe(G,*)\u662f\u4e00\u4e2a\u6709\u9650\u7fa4, |G|= n, e\u662fG\u7684\u5355\u4f4d\u5143. \u5982\u679c\u5b58\u5728 a\u5c5e\u4e8eG\uff0c\u4f7f\u5f97a, a2,\u2026, an=e\u4e92\u4e0d\u76f8\u540c,\u5373 G={a, a2,\u2026,an}, \u5219\u79f0a\u662fG\u7684\u4e00\u4e2a\u672c\u539f\u5143\uff08\u751f\u6210\u5143\uff09. (G,*)\u79f0\u4e3a\u5faa\u73af\u7fa4\u3002 \u6709\u9650\u57df \u8bbep\u662f\u4e00\u4e2a\u7d20\u6570, Zp= {0,1,2,\u2026, p-1}. \u5728Zp \u4e2d, \u52a0\u6cd5\u4e0e\u4e58\u6cd5\u6309 mod (p) \u8fdb\u884c, \u5219Zp\u79f0\u4e3a\u4e00\u4e2a\u6709\u9650\u57df\u3002 GF(p)\u7684\u672c\u539f\u5143 \u8bbeZp*= {1,2,\u2026, p-1}, a\u5c5e\u4e8eZp*, \u5982\u679ca, a 2 ,\u2026, a p-1 =1\u4e92\u4e0d\u76f8\u540c,\u5373 Zp*={a, a2,\u2026,ap-1}, \u5219\u79f0a\u662fZp\u7684\u4e00\u4e2a\u672c\u539f\u5143. (Zp*, *)\u662f\u4e00\u4e2a\u5faa\u73af\u7fa4\u3002","title":"Elgamal \u516c\u94a5\u5bc6\u7801\u4f53\u5236"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_35","text":"\u5384\u683c\u739b\u5c14(ElGamal)\u5bc6\u7801\u4f53\u5236 \u5bc6\u94a5\u4ea7\u751f: \u9009\u62e9\u7d20\u6570p\uff0c\u6574\u6570g, x\u6ee1\u8db3 0<g, x<p, \u8ba1\u7b97 y=g x mod p. \u516c\u94a5: (p, g, y) \u79c1\u94a5: x","title":"\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_36","text":"\u8bbe\u660e\u6587\u4e3am (0<m<p), \u968f\u673a\u9009\u53d6k(0<k<p), \u8ba1\u7b97 c1=g k mod p, c2=y k m mod p. \u5bc6\u6587: c=(c1, c2)","title":"\u52a0\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_37","text":"\u8bbe\u5bc6\u6587\u4e3ac=(c1, c2), \u5219\u660e\u6587\u4e3a m=c2*(c1 x ) -1 mod p.","title":"\u89e3\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_38","text":"","title":"\u692d\u5706\u66f2\u7ebf\u52a0\u89e3\u5bc6\u8fd0\u7b97"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_39","text":"\u786e\u5b9a\u516c\u5f00\u53c2\u6570( p , a , b , n , g ) \u9009\u62e9\u4e00\u4e2a\u7d20\u6570*p*, \u786e\u5b9a\u6709\u9650\u57dfGF( p ) \u9009\u62e9*a*, b*\u5c5e\u4e8eGF(*p ), \u786e\u5b9a\u692d\u5706\u66f2\u7ebf*E* \u9009\u62e9*E*\u7684\u4e00\u4e2a\u5faa\u73af\u5b50\u7fa4*H*, \u4f7f\u5f97| H |= n*\u662f\u4e00\u4e2a\u5927\u7d20\u6570 \u9009\u62e9*H*\u7684\u4e00\u4e2a\u672c\u539f\u5143*g . \u786e\u5b9a\u79c1\u94a5: x \u7528\u6237\u968f\u673a\u9009\u53d6*x*\u5c5e\u4e8e{0,1,2,\u2026, n -1} \u786e\u5b9a\u516c\u94a5: y = x*g. \u6709\u9650\u57df\u4e0a\u7684\u692d\u5706\u66f2\u7ebf","title":"\u5bc6\u94a5\u9009\u53d6"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_40","text":"\u8bbep>=3\u662f\u7d20\u6570, Fp= {0,1,\u2026, p-1}\u662f\u6709\u9650\u57df, a, b\u5c5e\u4e8ep, \u25b3=4a 3 +27b 2 \u4e0d\u7b49\u4e8e0 mod (p), \u540c\u4f59\u65b9\u7a0b y 2 =x 3 +ax+b","title":"\u692d\u5706\u66f2\u7ebf\u7fa4\u8ba1\u7b97"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_41","text":"\u52a0\u5bc6\u7b97\u6cd5 \u8bbe\u660e\u6587\u4e3am, \u5c06m\u6620\u5c04\u5230\u5faa\u73af\u7fa4H\u4e0a\u7684\u70b9. \u968f\u673a\u9009\u53d6k\u5c5e\u4e8e{0,1,\u2026,n-1} \u8ba1\u7b97:c1=kg=(x1, y1) \u8ba1\u7b97:c2 =m+ky=(x2, y2) \u5bc6\u6587: c=(c1, c2) \u89e3\u5bc6\u7b97\u6cd5 \u8bbe\u5bc6\u6587\u4e3ac=(c1, c2), \u5219\u660e\u6587\u4e3a m=c2-xc1.","title":"\u52a0\u89e3\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_42","text":"","title":"\u52a0\u89e3\u5bc6\u4f8b\u5b50"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#hash","text":"lHash\u51fd\u6570\u7684\u5206\u7c7b \u5355\u5411Hash\u51fd\u6570\uff08one-way\uff09\u7ed9\u5b9a\u4e00\u4e2aHash\u503c*y*\uff0c\u5982\u679c\u5bfb\u627e\u4e00\u4e2a\u6d88\u606f*x*\uff0c\u4f7f\u5f97*y*= h ( x )\u662f\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u7684\uff0c\u5219\u79f0*h*\u662f\u5355\u5411Hash\u51fd\u6570. \u5f31\u6297\u78b0\u649eHash\u51fd\u6570\uff08weakly collision-free\uff09 \u4efb\u7ed9\u4e00\u4e2a\u6d88\u606f*x*\uff0c\u5982\u679c\u5bfb\u627e\u53e6\u4e00\u4e2a\u4e0d\u540c\u7684\u6d88\u606f*x*\u2019\uff0c\u4f7f\u5f97*h*( x ) = h ( x \u2019)\u662f\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u7684\uff0c\u5219\u79f0*h*\u662f\u5f31\u6297\u78b0\u649eHash\u51fd\u6570. \u5f3a\u6297\u78b0\u649eHash\u51fd\u6570 \uff08strongly collision-free\uff09 \u5982\u679c\u5bfb\u627e\u4e24\u4e2a\u4e0d\u540c\u7684\u6d88\u606f*x*\u548c*x*\u2019\uff0c\u4f7f\u5f97*h*( x )= h ( x \u2019)\u662f\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u7684\uff0c\u5219\u79f0*h*\u662f\u5f3a\u6297\u78b0\u649eHash\u51fd\u6570.","title":"Hash\u51fd\u6570"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_43","text":"","title":"\u6570\u5b57\u7b7e\u540d"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#rsa_1","text":"","title":"RSA\u7b7e\u540d"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_44","text":"\u9009\u53d6\u4e24\u4e2a\u5927\u7d20\u6570p\uff0cq\uff0c\u8ba1\u7b97 n=p*q\uff0c\u53bb\u03c6(n)=( p -1) *( q -1)\u3002 \u4efb\u9009\u6574\u6570e\uff0c\u6ee1\u8db3\uff1a 0< e <\u03c6(n)\uff0c\u4e14gcd(e ,\u03c6(n))=1\u3002 \u7528\u6269\u5c55Euclidean\u7b97\u6cd5\u6c42e\u6a21j(n)\u7684\u9006d\uff0c\u5373 e*d=1 mod \u03c6(n)\u3002 \u7b7e\u540d\u8005\u7684\u516c\u94a5: { n\uff0ce}\uff0c\u79c1\u94a5:{ p\uff0cq\uff0cd}\u3002 \u7b7e\u540d\u7b97\u6cd5 \u8bbe\u6d88\u606f\u4e3ax\uff0c\u5219x\u7684RSA\u7b7e\u540d\u4e3a y=x d mod n \u9a8c\u8bc1\u7b97\u6cd5\u5f53\u63a5\u6536\u65b9\u6536\u5230\u7b7e\u540d(x,y)\u540e\uff0c\u9a8c\u8bc1x=y e mod n","title":"\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#elgamal_1","text":"\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u9009\u53d6\u4e00\u4e2a\u5927\u7d20\u6570p\uff0cg\u5c5e\u4e8eZp*\u662f\u4e00\u4e2a\u672c\u539f\u5143\uff0cp\u548cg\u662f\u7cfb\u7edf\u516c\u5f00\u53c2\u6570\u3002 \u4efb\u9009\u6574\u6570x\uff0c\u6ee1\u8db3\uff1a1\u2264x\u2264p-2\u3002\u8ba1\u7b97 y=g x mod p. \u7b7e\u540d\u8005\u7684\u516c\u94a5\u4e3ay\uff0c\u79c1\u94a5\u4e3ax\u3002 \u7b7e\u540d\u7b97\u6cd5 \u9a8c\u8bc1\u7b97\u6cd5","title":"Elgamal \u6570\u5b57\u7b7e\u540d"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_45","text":"\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5\u7b7e\u540d\u53ca\u9a8c\u8bc1\u7b97\u6cd5","title":"\u7f8e\u56fd\u6570\u5b57\u7b7e\u540d\u6807\u51c6"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_46","text":"\u5bc6\u94a5\u751f\u6210\u51fd\u6570\u7b7e\u540d\u7b97\u6cd5\u53ca\u9a8c\u8bc1\u7b97\u6cd5","title":"\u4fc4\u7f57\u65af\u6570\u5b57\u7b7e\u540d\u6807\u51c6"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#fs","text":"\u9009\u53d6\u4e24\u4e2a\u5927\u7d20\u6570*p*\u3001 q \uff0c\u4ee4*n*=p*q\u3002n\u662f\u516c\u5f00\u53c2\u6570\uff0c*p*\u548c*q*\u662f\u7ba1\u7406\u4e2d\u5fc3CA\u638c\u63e1\u7684\u5bc6\u94a5\u3002\u8bbe*h*\u662f\u4e00\u4e2a\u516c\u5f00\u7684Hash\u51fd\u6570\uff0c*k*\u662f\u4e00\u4e2a\u56fa\u5b9a\u7684\u6b63\u6574\u6570\u3002 \u7ba1\u7406\u4e2d\u5fc3CA\u4e3a\u7528\u6237A\u4ea7\u751f*k*\u4e2a\u516c\u5f00\u5bc6\u94a5\uff1a y i (i =1,2,\u2026, k ) \u662f\u6a21*n*\u7684\u5e73\u65b9\u5269\u4f59 \u518d\u4e3a\u7528\u6237A\u4ea7\u751f*k*\u4e2a\u79c1\u94a5\uff08\u4fdd\u5bc6\uff09 \u7b7e\u540d\u7b97\u6cd5 \u9a8c\u8bc1\u7b97\u6cd5","title":"FS\u7b7e\u540d"},{"location":"course/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","text":"\u8f6f\u4ef6\u5de5\u7a0b\u590d\u4e60 \u00b6 \u7b2c\u4e00\u7ae0 \u8f6f\u4ef6\u5de5\u7a0b\u5b66\u6982\u8ff0 \u00b6 \u8f6f\u4ef6\u5b9a\u4e49 Software = Program + Data + Document \u8f6f\u4ef6(software)\u662f\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d\u4e0e\u786c\u4ef6(hardware)\u76f8\u4e92\u4f9d\u5b58\u7684\uff0c\u53e6\u4e00\u90e8\u5206\uff0c\u5b83\u5305\u62ec\u7a0b\u5e8f(program)\u3001\u76f8\u5173\u6570\u636e(data)\u53ca\u5176\u8bf4\u660e\u6587\u6863 (document)\u3002 \u7a0b\u5e8f\uff1a\u662f\u6309\u4e8b\u5148\u8bbe\u8ba1\u7684\u529f\u80fd\u548c\u6027\u80fd\u8981\u6c42\u6267\u884c\u7684\u6307\u4ee4\u5e8f\u5217\uff1b \u6570\u636e\uff1a\u662f\u4f7f\u7a0b\u5e8f\u80fd\u6b63\u5e38\u64cd\u7eb5\u4fe1\u606f\u7684\u6570\u636e\u7ed3\u6784\uff1b \u6587\u6863\uff1a\u662f\u4e0e\u7a0b\u5e8f\u5f00\u53d1\u3001\u7ef4\u62a4\u548c\u4f7f\u7528\u6709\u5173\u7684\u56fe\u6587\u6750\u6599\u3002 \u8f6f\u4ef6\u7684\u7279\u70b9 \u8f6f\u4ef6\u662f\u4e00\u79cd\u903b\u8f91\u5b9e\u4f53\uff0c\u5177\u6709\u62bd\u8c61\u6027\uff1b \u8f6f\u4ef6\u662f\u5f00\u53d1\u7684\uff0c\u800c\u4e0d\u662f\u5236\u9020\u7684\uff1b \u5728\u8f6f\u4ef6\u7684\u8fd0\u884c\u548c\u4f7f\u7528\u671f\u95f4\uff0c\u6ca1\u6709\u786c\u4ef6\u90a3\u6837\u7684\u673a\u68b0\u78e8\u635f\uff0c\u8001\u5316\u95ee\u9898; \u8f6f\u4ef6\u7684\u5f00\u53d1\u81f3\u4eca\u5c1a\u672a\u5b8c\u5168\u6446\u8131\u624b\u5de5\u4f5c\u574a\u5f0f\u7684\u5f00\u53d1\u65b9\u5f0f\uff0c\u751f\u4ea7\u6548\u7387\u4f4e\uff1b \u8f6f\u4ef6\u5177\u6709\u590d\u6742\u6027\uff1b \u8f6f\u4ef6\u7684\u6210\u672c\u76f8\u5f53\u6602\u8d35\uff1b \u8f6f\u4ef6\u5bf9\u786c\u4ef6\u548c\u73af\u5883\u6709\u7740\u4e0d\u540c\u7a0b\u5ea6\u7684\u4f9d\u8d56\u6027\uff1b \u8f6f\u4ef6\u5de5\u4f5c\u7275\u6d89\u5230\u5f88\u591a\u793e\u4f1a\u56e0\u7d20\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u4e09\u8981\u7d20 \u8f6f\u4ef6\u5de5\u7a0b\u7684\u65b9\u6cd5\uff1a\u4e3a\u8f6f\u4ef6\u5f00\u53d1\u63d0\u4f9b\u201c\u5982\u4f55\u505a\u201d\u7684\u6280\u672f\uff0c\u5f53\u524d\u6709\u4f20\u7edf\u7684\u8f6f\u4ef6\u5f00\u53d1\u65b9\u6cd5\u548c\u9762\u5411\u5bf9\u8c61\u7684\u8f6f\u4ef6\u5f00 \u53d1\u65b9\u6cd5\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u7684\u8fc7\u7a0b\uff1a\u662f\u7ba1\u7406\u548c\u63a7\u5236\u4ea7\u54c1\u8d28\u91cf\u7684\u5173\u952e\uff0c\u5b9e\u73b0\u5728\u89c4\u5b9a\u7684\u65f6\u95f4\u548c\u9884\u7b97\u5185\u5f00\u53d1\u9ad8\u8d28\u91cf\u8f6f\u4ef6\u7684\u76ee\u6807\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u7684\u5de5\u5177\uff1a\u4e3a\u8f6f\u4ef6\u5de5\u7a0b\u65b9\u6cd5 \u63d0\u4f9b\u4e86\u81ea\u52a8\u7684\u6216\u534a\u81ea\u52a8\u7684\u8f6f\u4ef6\u652f\u6491 \u73af\u5883\uff0c\u8f85\u52a9\u8f6f\u4ef6\u5f00\u53d1\u4efb\u52a1\u7684\u5b8c\u6210\u3002 CASE \u8f6f\u4ef6\u5de5\u7a0b\u5c42\u6b21\uff1a\u8d28\u91cf\u7126\u70b9>\u8fc7\u7a0b>\u65b9\u6cd5>\u5de5\u5177 \u55b7\u6cc9\u6a21\u578b \u55b7\u6cc9\u6a21\u578b\u662f\u4e00\u79cd\u4ee5\u7528\u6237\u9700\u6c42\u4e3a\u52a8\u529b\uff0c \u4ee5\u5bf9\u8c61\u4e3a\u9a71\u52a8\u7684\u6a21\u578b\uff0c\u4e3b\u8981\u7528\u4e8e\u63cf\u8ff0\u9762\u5411\u5bf9\u8c61\u7684\u8f6f\u4ef6\u5f00\u53d1\u8fc7\u7a0b\u3002 \u8f6f\u4ef6\u5f00\u53d1\u8fc7\u7a0b\u81ea\u4e0b\u800c\u4e0a\u5468\u671f\u7684\u5404\u9636\u6bb5\u662f\u76f8\u4e92\u91cd\u53e0\u548c\u591a\u6b21\u53cd\u590d\u7684\uff0c\u5c31\u50cf\u6c34\u55b7\u4e0a\u53bb\u53c8\u53ef\u4ee5\u843d\u4e0b\u6765\uff0c\u7c7b\u4f3c\u4e00\u4e2a\u55b7\u6cc9\u3002 \u5404\u4e2a\u5f00\u53d1\u9636\u6bb5\u6ca1\u6709\u7279\u5b9a\u7684\u6b21\u5e8f\u8981\u6c42\uff0c\u5e76\u4e14\u53ef\u4ee5\u4ea4\u4e92\u8fdb\u884c\uff0c\u53ef\u4ee5\u5728\u67d0\u4e2a\u5f00\u53d1\u9636\u6bb5\u4e2d\u968f\u65f6\u8865\u5145\u5176\u4ed6\u4efb\u4f55\u5f00\u53d1\u9636\u6bb5\u4e2d\u7684\u9057\u6f0f\u3002 \u4f18\u70b9: \u8be5\u6a21\u578b\u7684\u5404\u4e2a\u9636\u6bb5\u6ca1\u6709\u660e\u663e\u7684\u754c\u9650\uff0c\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u540c\u6b65\u8fdb\u884c\u5f00 \u53d1\uff0c\u53ef\u4ee5\u63d0\u9ad8\u8f6f\u4ef6\u9879\u76ee\u5f00\u53d1\u6548\u7387\uff0c\u8282\u7701\u5f00\u53d1\u65f6\u95f4\uff0c\u9002\u5e94\u4e8e\u9762\u5411\u5bf9\u8c61 \u7684\u8f6f\u4ef6\u5f00\u53d1\u8fc7\u7a0b\u3002 \u7f3a\u70b9\uff1a \u7531\u4e8e\u8be5\u6a21\u578b\u5728\u5404\u4e2a\u5f00\u53d1\u9636\u6bb5\u662f\u91cd\u53e0\u7684\uff0c\u5728\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u9700\u8981\u5927\u91cf \u7684\u5f00\u53d1\u4eba\u5458\uff0c\u56e0\u6b64\u4e0d\u5229\u4e8e\u9879\u76ee\u7684\u7ba1\u7406\u3002 \u8be5\u6a21\u578b\u8981\u6c42\u4e25\u683c\u7ba1\u7406\u6587\u6863\uff0c\u4f7f\u5f97\u5ba1\u6838\u7684\u96be\u5ea6\u52a0\u5927\uff0c\u5c24\u5176\u662f\u9762\u5bf9 \u53ef\u80fd\u968f\u65f6\u52a0\u5165\u5404\u79cd\u4fe1\u606f\u3001\u9700\u6c42\u4e0e\u8d44\u6599\u7684\u60c5\u51b5\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u4e0e\u4e00\u822c\u5de5\u7a0b\u7684\u5dee\u5f02 \u8f6f\u4ef6\u662f\u903b\u8f91\u4ea7\u54c1\u800c\u4e0d\u662f\u5b9e\u7269\u4ea7\u54c1 \u3001\u8f6f\u4ef6\u7684\u529f\u80fd\u4f9d\u8d56\u4e8e\u786c\u4ef6\u548c\u8f6f\u4ef6\u7684\u8fd0\u884c\u73af\u5883\u4ee5 \u53ca\u4eba\u4eec\u5bf9\u5b83\u7684\u64cd\u4f5c\u3001\u8f6f\u4ef6\u8bbe\u8ba1\u7684\u590d\u6742\u6027\u3001\u8f6f\u4ef6\u7279\u5f81\uff1a \u529f\u80fd\u7684\u591a\u6837\u6027 \u5b9e\u73b0\u7684\u591a\u6837\u6027 \u80fd\u89c1\u5ea6\u4f4e \u8f6f\u4ef6\u7ed3\u6784\u5408\u7406\u6027\u5dee \u3001\u667a\u529b\u5bc6\u96c6\u53ca\u77e5\u8bc6\u4ea7\u6743\u4fdd\u62a4 \u7b2c\u4e8c\u7ae0 \u53ef\u884c\u6027\u7814\u7a76 \u00b6 \u6570\u636e\u6d41\u56fe\u7684\u5c42\u6b21\u7ed3\u6784 \u4e3a\u4e86\u8868\u8fbe\u6570\u636e\u5904\u7406\u8fc7\u7a0b\u7684\u6570\u636e\u52a0\u5de5\u60c5\u51b5\uff0c\u9700\u8981\u91c7\u7528\u5c42\u6b21\u7ed3\u6784\u7684\u6570\u636e\u6d41\u56fe\u3002\u6309\u7167\u7cfb\u7edf\u7684\u5c42\u6b21\u7ed3\u6784\u8fdb\u884c\u9010\u6b65\u5206\u89e3\uff0c\u5e76\u4ee5\u5206\u5c42\u7684\u6570\u636e \u6d41\u56fe\u53cd\u6620\u8fd9\u79cd\u7ed3\u6784\u5173\u7cfb\uff0c\u80fd\u6e05\u695a\u5730\u8868\u8fbe\u548c\u5bb9\u6613\u7406\u89e3\u6574\u4e2a\u7cfb\u7edf\u3002 \u5728\u591a\u5c42\u6570\u636e\u6d41\u56fe\u4e2d\uff0c\u9876\u5c42\u6d41\u56fe\u4ec5\u5305\u542b\u4e00\u4e2a\u52a0\u5de5\uff0c\u5b83\u4ee3\u8868\u88ab\u5f00\u53d1\u7cfb\u7edf\u3002\u5b83\u7684\u8f93\u5165\u6d41\u662f\u8be5\u7cfb\u7edf\u7684\u8f93\u5165\u6570\u636e\uff0c\u8f93\u51fa\u6d41\u662f\u7cfb\u7edf\u6240\u8f93\u51fa\u6570\u636e\u3002\u9876\u5c42\u6570\u636e\u6d41\u56fe\u7684\u4f5c\u7528\u5728\u4e8e\u8868\u660e\u88ab\u5f00\u53d1\u7cfb\u7edf\u7684\u8303\u56f4\u4ee5\u53ca\u5b83\u548c\u5468\u56f4\u73af\u5883\u7684\u6570\u636e\u4ea4\u6362\u5173\u7cfb\u3002\u5bf9\u4e8e\u9876\u5c42\u6570\u636e\u6d41\u56fe\u901a\u5e38\u53ef\u4ee5\u4e0d\u8003\u8651\u6570\u636e \u5b58\u50a8\u3002 \u5e95\u5c42\u6d41\u56fe\u662f\u6307\u5176\u52a0\u5de5\u4e0d\u9700\u518d\u505a\u5206\u89e3\u7684\u6570\u636e\u6d41\u56fe\uff0c\u5b83\u5904\u5728\u6700\u5e95\u5c42\u3002 \u4e2d\u95f4\u5c42\u6d41\u56fe\u5219\u8868\u793a\u5bf9\u5176\u4e0a\u5c42\u7236\u56fe\u7684\u7ec6\u5316\u3002\u5b83\u7684\u6bcf\u4e00\u52a0\u5de5\u53ef\u80fd\u7ee7\u7eed\u7ec6\u5316\uff0c\u5f62\u6210\u5b50\u56fe\u3002 \u6570\u636e\u5b57\u5178\u5b9e\u4f8b","title":"\u8f6f\u4ef6\u5de5\u7a0b"},{"location":"course/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#_1","text":"","title":"\u8f6f\u4ef6\u5de5\u7a0b\u590d\u4e60"},{"location":"course/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#_2","text":"\u8f6f\u4ef6\u5b9a\u4e49 Software = Program + Data + Document \u8f6f\u4ef6(software)\u662f\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d\u4e0e\u786c\u4ef6(hardware)\u76f8\u4e92\u4f9d\u5b58\u7684\uff0c\u53e6\u4e00\u90e8\u5206\uff0c\u5b83\u5305\u62ec\u7a0b\u5e8f(program)\u3001\u76f8\u5173\u6570\u636e(data)\u53ca\u5176\u8bf4\u660e\u6587\u6863 (document)\u3002 \u7a0b\u5e8f\uff1a\u662f\u6309\u4e8b\u5148\u8bbe\u8ba1\u7684\u529f\u80fd\u548c\u6027\u80fd\u8981\u6c42\u6267\u884c\u7684\u6307\u4ee4\u5e8f\u5217\uff1b \u6570\u636e\uff1a\u662f\u4f7f\u7a0b\u5e8f\u80fd\u6b63\u5e38\u64cd\u7eb5\u4fe1\u606f\u7684\u6570\u636e\u7ed3\u6784\uff1b \u6587\u6863\uff1a\u662f\u4e0e\u7a0b\u5e8f\u5f00\u53d1\u3001\u7ef4\u62a4\u548c\u4f7f\u7528\u6709\u5173\u7684\u56fe\u6587\u6750\u6599\u3002 \u8f6f\u4ef6\u7684\u7279\u70b9 \u8f6f\u4ef6\u662f\u4e00\u79cd\u903b\u8f91\u5b9e\u4f53\uff0c\u5177\u6709\u62bd\u8c61\u6027\uff1b \u8f6f\u4ef6\u662f\u5f00\u53d1\u7684\uff0c\u800c\u4e0d\u662f\u5236\u9020\u7684\uff1b \u5728\u8f6f\u4ef6\u7684\u8fd0\u884c\u548c\u4f7f\u7528\u671f\u95f4\uff0c\u6ca1\u6709\u786c\u4ef6\u90a3\u6837\u7684\u673a\u68b0\u78e8\u635f\uff0c\u8001\u5316\u95ee\u9898; \u8f6f\u4ef6\u7684\u5f00\u53d1\u81f3\u4eca\u5c1a\u672a\u5b8c\u5168\u6446\u8131\u624b\u5de5\u4f5c\u574a\u5f0f\u7684\u5f00\u53d1\u65b9\u5f0f\uff0c\u751f\u4ea7\u6548\u7387\u4f4e\uff1b \u8f6f\u4ef6\u5177\u6709\u590d\u6742\u6027\uff1b \u8f6f\u4ef6\u7684\u6210\u672c\u76f8\u5f53\u6602\u8d35\uff1b \u8f6f\u4ef6\u5bf9\u786c\u4ef6\u548c\u73af\u5883\u6709\u7740\u4e0d\u540c\u7a0b\u5ea6\u7684\u4f9d\u8d56\u6027\uff1b \u8f6f\u4ef6\u5de5\u4f5c\u7275\u6d89\u5230\u5f88\u591a\u793e\u4f1a\u56e0\u7d20\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u4e09\u8981\u7d20 \u8f6f\u4ef6\u5de5\u7a0b\u7684\u65b9\u6cd5\uff1a\u4e3a\u8f6f\u4ef6\u5f00\u53d1\u63d0\u4f9b\u201c\u5982\u4f55\u505a\u201d\u7684\u6280\u672f\uff0c\u5f53\u524d\u6709\u4f20\u7edf\u7684\u8f6f\u4ef6\u5f00\u53d1\u65b9\u6cd5\u548c\u9762\u5411\u5bf9\u8c61\u7684\u8f6f\u4ef6\u5f00 \u53d1\u65b9\u6cd5\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u7684\u8fc7\u7a0b\uff1a\u662f\u7ba1\u7406\u548c\u63a7\u5236\u4ea7\u54c1\u8d28\u91cf\u7684\u5173\u952e\uff0c\u5b9e\u73b0\u5728\u89c4\u5b9a\u7684\u65f6\u95f4\u548c\u9884\u7b97\u5185\u5f00\u53d1\u9ad8\u8d28\u91cf\u8f6f\u4ef6\u7684\u76ee\u6807\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u7684\u5de5\u5177\uff1a\u4e3a\u8f6f\u4ef6\u5de5\u7a0b\u65b9\u6cd5 \u63d0\u4f9b\u4e86\u81ea\u52a8\u7684\u6216\u534a\u81ea\u52a8\u7684\u8f6f\u4ef6\u652f\u6491 \u73af\u5883\uff0c\u8f85\u52a9\u8f6f\u4ef6\u5f00\u53d1\u4efb\u52a1\u7684\u5b8c\u6210\u3002 CASE \u8f6f\u4ef6\u5de5\u7a0b\u5c42\u6b21\uff1a\u8d28\u91cf\u7126\u70b9>\u8fc7\u7a0b>\u65b9\u6cd5>\u5de5\u5177 \u55b7\u6cc9\u6a21\u578b \u55b7\u6cc9\u6a21\u578b\u662f\u4e00\u79cd\u4ee5\u7528\u6237\u9700\u6c42\u4e3a\u52a8\u529b\uff0c \u4ee5\u5bf9\u8c61\u4e3a\u9a71\u52a8\u7684\u6a21\u578b\uff0c\u4e3b\u8981\u7528\u4e8e\u63cf\u8ff0\u9762\u5411\u5bf9\u8c61\u7684\u8f6f\u4ef6\u5f00\u53d1\u8fc7\u7a0b\u3002 \u8f6f\u4ef6\u5f00\u53d1\u8fc7\u7a0b\u81ea\u4e0b\u800c\u4e0a\u5468\u671f\u7684\u5404\u9636\u6bb5\u662f\u76f8\u4e92\u91cd\u53e0\u548c\u591a\u6b21\u53cd\u590d\u7684\uff0c\u5c31\u50cf\u6c34\u55b7\u4e0a\u53bb\u53c8\u53ef\u4ee5\u843d\u4e0b\u6765\uff0c\u7c7b\u4f3c\u4e00\u4e2a\u55b7\u6cc9\u3002 \u5404\u4e2a\u5f00\u53d1\u9636\u6bb5\u6ca1\u6709\u7279\u5b9a\u7684\u6b21\u5e8f\u8981\u6c42\uff0c\u5e76\u4e14\u53ef\u4ee5\u4ea4\u4e92\u8fdb\u884c\uff0c\u53ef\u4ee5\u5728\u67d0\u4e2a\u5f00\u53d1\u9636\u6bb5\u4e2d\u968f\u65f6\u8865\u5145\u5176\u4ed6\u4efb\u4f55\u5f00\u53d1\u9636\u6bb5\u4e2d\u7684\u9057\u6f0f\u3002 \u4f18\u70b9: \u8be5\u6a21\u578b\u7684\u5404\u4e2a\u9636\u6bb5\u6ca1\u6709\u660e\u663e\u7684\u754c\u9650\uff0c\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u540c\u6b65\u8fdb\u884c\u5f00 \u53d1\uff0c\u53ef\u4ee5\u63d0\u9ad8\u8f6f\u4ef6\u9879\u76ee\u5f00\u53d1\u6548\u7387\uff0c\u8282\u7701\u5f00\u53d1\u65f6\u95f4\uff0c\u9002\u5e94\u4e8e\u9762\u5411\u5bf9\u8c61 \u7684\u8f6f\u4ef6\u5f00\u53d1\u8fc7\u7a0b\u3002 \u7f3a\u70b9\uff1a \u7531\u4e8e\u8be5\u6a21\u578b\u5728\u5404\u4e2a\u5f00\u53d1\u9636\u6bb5\u662f\u91cd\u53e0\u7684\uff0c\u5728\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u9700\u8981\u5927\u91cf \u7684\u5f00\u53d1\u4eba\u5458\uff0c\u56e0\u6b64\u4e0d\u5229\u4e8e\u9879\u76ee\u7684\u7ba1\u7406\u3002 \u8be5\u6a21\u578b\u8981\u6c42\u4e25\u683c\u7ba1\u7406\u6587\u6863\uff0c\u4f7f\u5f97\u5ba1\u6838\u7684\u96be\u5ea6\u52a0\u5927\uff0c\u5c24\u5176\u662f\u9762\u5bf9 \u53ef\u80fd\u968f\u65f6\u52a0\u5165\u5404\u79cd\u4fe1\u606f\u3001\u9700\u6c42\u4e0e\u8d44\u6599\u7684\u60c5\u51b5\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u4e0e\u4e00\u822c\u5de5\u7a0b\u7684\u5dee\u5f02 \u8f6f\u4ef6\u662f\u903b\u8f91\u4ea7\u54c1\u800c\u4e0d\u662f\u5b9e\u7269\u4ea7\u54c1 \u3001\u8f6f\u4ef6\u7684\u529f\u80fd\u4f9d\u8d56\u4e8e\u786c\u4ef6\u548c\u8f6f\u4ef6\u7684\u8fd0\u884c\u73af\u5883\u4ee5 \u53ca\u4eba\u4eec\u5bf9\u5b83\u7684\u64cd\u4f5c\u3001\u8f6f\u4ef6\u8bbe\u8ba1\u7684\u590d\u6742\u6027\u3001\u8f6f\u4ef6\u7279\u5f81\uff1a \u529f\u80fd\u7684\u591a\u6837\u6027 \u5b9e\u73b0\u7684\u591a\u6837\u6027 \u80fd\u89c1\u5ea6\u4f4e \u8f6f\u4ef6\u7ed3\u6784\u5408\u7406\u6027\u5dee \u3001\u667a\u529b\u5bc6\u96c6\u53ca\u77e5\u8bc6\u4ea7\u6743\u4fdd\u62a4","title":"\u7b2c\u4e00\u7ae0 \u8f6f\u4ef6\u5de5\u7a0b\u5b66\u6982\u8ff0"},{"location":"course/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#_3","text":"\u6570\u636e\u6d41\u56fe\u7684\u5c42\u6b21\u7ed3\u6784 \u4e3a\u4e86\u8868\u8fbe\u6570\u636e\u5904\u7406\u8fc7\u7a0b\u7684\u6570\u636e\u52a0\u5de5\u60c5\u51b5\uff0c\u9700\u8981\u91c7\u7528\u5c42\u6b21\u7ed3\u6784\u7684\u6570\u636e\u6d41\u56fe\u3002\u6309\u7167\u7cfb\u7edf\u7684\u5c42\u6b21\u7ed3\u6784\u8fdb\u884c\u9010\u6b65\u5206\u89e3\uff0c\u5e76\u4ee5\u5206\u5c42\u7684\u6570\u636e \u6d41\u56fe\u53cd\u6620\u8fd9\u79cd\u7ed3\u6784\u5173\u7cfb\uff0c\u80fd\u6e05\u695a\u5730\u8868\u8fbe\u548c\u5bb9\u6613\u7406\u89e3\u6574\u4e2a\u7cfb\u7edf\u3002 \u5728\u591a\u5c42\u6570\u636e\u6d41\u56fe\u4e2d\uff0c\u9876\u5c42\u6d41\u56fe\u4ec5\u5305\u542b\u4e00\u4e2a\u52a0\u5de5\uff0c\u5b83\u4ee3\u8868\u88ab\u5f00\u53d1\u7cfb\u7edf\u3002\u5b83\u7684\u8f93\u5165\u6d41\u662f\u8be5\u7cfb\u7edf\u7684\u8f93\u5165\u6570\u636e\uff0c\u8f93\u51fa\u6d41\u662f\u7cfb\u7edf\u6240\u8f93\u51fa\u6570\u636e\u3002\u9876\u5c42\u6570\u636e\u6d41\u56fe\u7684\u4f5c\u7528\u5728\u4e8e\u8868\u660e\u88ab\u5f00\u53d1\u7cfb\u7edf\u7684\u8303\u56f4\u4ee5\u53ca\u5b83\u548c\u5468\u56f4\u73af\u5883\u7684\u6570\u636e\u4ea4\u6362\u5173\u7cfb\u3002\u5bf9\u4e8e\u9876\u5c42\u6570\u636e\u6d41\u56fe\u901a\u5e38\u53ef\u4ee5\u4e0d\u8003\u8651\u6570\u636e \u5b58\u50a8\u3002 \u5e95\u5c42\u6d41\u56fe\u662f\u6307\u5176\u52a0\u5de5\u4e0d\u9700\u518d\u505a\u5206\u89e3\u7684\u6570\u636e\u6d41\u56fe\uff0c\u5b83\u5904\u5728\u6700\u5e95\u5c42\u3002 \u4e2d\u95f4\u5c42\u6d41\u56fe\u5219\u8868\u793a\u5bf9\u5176\u4e0a\u5c42\u7236\u56fe\u7684\u7ec6\u5316\u3002\u5b83\u7684\u6bcf\u4e00\u52a0\u5de5\u53ef\u80fd\u7ee7\u7eed\u7ec6\u5316\uff0c\u5f62\u6210\u5b50\u56fe\u3002 \u6570\u636e\u5b57\u5178\u5b9e\u4f8b","title":"\u7b2c\u4e8c\u7ae0 \u53ef\u884c\u6027\u7814\u7a76"},{"location":"icpc/","text":"\u6742\u9879 \u00b6 \u5feb\u8bfb&O2\u4f18\u5316 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #define inf1 0x3f3f3f3f #define inf2 0x3f3f3f3f3f3f3f3f const double Pi = acos ( -1 ); std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( 0 ); cout << fixed << setprecision ( 20 ) << ans << endl ; __int128 \u8f93\u5165\u548c\u8f93\u51fa \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; __int128 int128read () { __int128 x = 0 ; int flag = 1 ; string a ; cin >> a ; for ( char c : a ) { if ( c == '-' ) flag = -1 ; else x = x * 10 + c - '0' ; } return flag * x ; } void int128print ( __int128 x ) { if ( x < 0 ) { putchar ( '-' ); x =- x ; } if ( x > 9 ) int128print ( x / 10 ); putchar ( x % 10 + '0' ); } int main () { __int128 a = int128read (), b = int128read (); int128print ( a + b ); } java ACM \u57fa\u7840 \u00b6 import java.io.* ; import java.math.* ; import java.util.* ; public class Main { public static void main ( String args [] ) { //BigDecimal\u5927\u6570Double\u7c7b //\u8bfb\u5165 Scanner cin = new Scanner ( new BufferedInputStream ( System . in )); int a ; double b ; BigInteger c ; String d ; a = cin . nextInt (); b = cin . nextDouble (); c = cin . nextBigInteger (); d = cin . nextLine (); // \u6bcf\u79cd\u7c7b\u578b\u90fd\u6709\u76f8\u5e94\u7684\u8f93\u5165\u51fd\u6570. System . out . printf ( \"\u8f93\u5165\u7684\u4e3a%d %f %s %s\\n\" , a , b , c . toString (), d ); c = cin . nextBigInteger ( 2 ); //\u5927\u6570\u4ee52\u8fdb\u5236\u8bfb\u5165 String tmp = c . toString ( 2 ); ///\u5c06\u5927\u6570\u4ee5\u4e8c\u8fdb\u5236\u5f62\u5f0f\u8f93\u51fa System . out . print ( 1 ); // cout << \u2026; System . out . println ( 1 ); // cout << \u2026 << endl; System . out . printf ( \"%d\" , 1 ); // \u4e0eC\u4e2d\u7684printf\u7528\u6cd5\u7c7b\u4f3c. ///\u5b57\u7b26\u4e32\u5904\u7406 String st = \"abcdefg\" ; System . out . println ( st . charAt ( 0 )); // st.charAt(i)\u5c31\u76f8\u5f53\u4e8est[i]. char [] ch ; ch = st . toCharArray (); // \u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u5b57\u7b26\u6570\u7ec4. for ( int i = 0 ; i < ch . length ; i ++ ) ch [ i ] += 1 ; System . out . println ( ch ); // \u8f93\u5165\u4e3a\u201cbcdefgh\u201d. if ( st . startsWith ( \"a\" )) // \u5982\u679c\u5b57\u7b26\u4e32\u4ee5'0'\u5f00\u5934. st = st . substring ( 1 ); // \u5219\u4ece\u7b2c1\u4f4d\u5f00\u59cbcopy(\u5f00\u5934\u4e3a\u7b2c0\u4f4d). ///\u8fdb\u5236\u8f6c\u5316 int num = 15 , base = 2 ; System . out . printf ( \"15\u8f6c2\u8fdb\u5236\u4e3a%s\\n\" , Integer . toString ( num , base )); st = \"1111\" ; System . out . printf ( \"2\u8fdb\u5236\u76841111\u8f6c10\u8fdb\u5236\u4e3a%d\\n\" , Integer . parseInt ( st , base )); // \u628ast\u5f53\u505abase\u8fdb\u5236\uff0c\u8f6c\u621010\u8fdb\u5236\u7684int(parseInt\u6709\u4e24\u4e2a\u53c2\u6570,\u7b2c\u4e00\u4e2a\u4e3a\u8981\u8f6c\u7684\u5b57\u7b26\u4e32,\u7b2c\u4e8c\u4e2a\u4e3a\u8fdb\u5236). BigInteger m = new BigInteger ( st , base ); // st\u662f\u5b57\u7b26\u4e32\uff0cbase\u662fst\u7684\u8fdb\u5236. ///\u6392\u5e8f int n = cin . nextInt (); Integer [] arr = new Integer [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ]= cin . nextInt (); Arrays . sort ( arr , new Comparator < Integer > () { @Override public int compare ( Integer o1 , Integer o2 ) { return o2 - o1 ; ///\u4ece\u5927\u5230\u5c0f\u6392\u5e8f } }); for ( int i = 0 ; i < n ; i ++ ) System . out . printf ( \"%d \" , arr [ i ] ); System . out . println (); ///\u6e05\u7a7a Arrays . fill ( arr , 5 ); for ( int i = 0 ; i < n ; i ++ ) System . out . printf ( \"%d \" , arr [ i ] ); System . out . println (); ///\u4e8c\u5206\u67e5\u627e System . out . println ( Arrays . binarySearch ( arr , 5 )); ///\u5982\u679ckey\u5728\u6570\u7ec4\u4e2d\uff0c\u5219\u8fd4\u56de\u641c\u7d22\u503c\u7684\u7d22\u5f15\uff1b\u5426\u5219\u8fd4\u56de-1\u6216\u8005\u201d-\u201c(\u63d2\u5165\u70b9)\u3002 ///\u63d2\u5165\u70b9\u662f\u7d22\u5f15\u952e\u5c06\u8981\u63d2\u5165\u6570\u7ec4\u7684\u90a3\u4e00\u70b9\uff0c\u5373\u7b2c\u4e00\u4e2a\u5927\u4e8e\u8be5\u952e\u7684\u5143\u7d20\u7d22\u5f15\u3002 } } java BigInteger \u8fd0\u7b97 \u00b6 import java.io.* ; import java.math.* ; import java.util.* ; public class Main { public static void main ( String args [] ) { Scanner cin = new Scanner ( System . in ); while ( cin . hasNext ()) ///\u76f8\u5f53\u4e8e scanf()!=EOF { BigInteger a , b , c ; //\u5927\u6570\u521d\u59cb\u5316 //1.\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32 BigInteger interNum1 = new BigInteger ( \"1011100111\" , 2 ); //2.\u5341\u8fdb\u5236\u5b57\u7b26\u4e32 BigInteger interNum2 = new BigInteger ( \"123456\" ); //3.\u5341\u8fdb\u5236\u6570\u5b57 BigInteger interNum3 = BigInteger . valueOf ( 8 ); //\u5927\u6570\u8bfb\u5165 a = cin . nextBigInteger (); b = cin . nextBigInteger (); //\u57fa\u672c\u8fd0\u7b97 //1.\u628aa\u4e0eb\u76f8\u52a0\u5e76\u8d4b\u7ed9c c = a . add ( b ); //2.\u628aa\u4e0eb\u76f8\u51cf\u5e76\u8d4b\u7ed9c c = a . subtract ( b ); //3.\u628aa\u4e0eb\u76f8\u4e58\u5e76\u8d4b\u7ed9c c = a . multiply ( b ); //4.\u628aa\u4e0eb\u76f8\u9664\u5e76\u8d4b\u7ed9c c = a . divide ( b ); //5.\u53d6\u6a21\uff0c(\u9700 b > 0\uff0c\u5426\u5219\u51fa\u73b0\u5f02\u5e38\uff1aArithmeticException(\"BigInteger: modulus not positive\")) c = a . mod ( b ); //6.\u6c42\u4f59 c = a . remainder ( b ); //7.\u76f8\u5f53\u4e8ea^b c = a . pow ( 2 ); //8.\u6839\u636e\u8be5\u6570\u503c\u662f\u5c0f\u4e8e\u3001\u7b49\u4e8e\u3001\u6216\u5927\u4e8ea \u8fd4\u56de -1\u30010 \u6216 1 int ans1 = a . compareTo ( b ); //9.\u5224\u65ad\u4e24\u6570\u662f\u5426\u76f8\u7b49\uff0c\u4e5f\u53ef\u4ee5\u7528compareTo\u6765\u4ee3\u66ff boolean ans2 = a . equals ( b ); //10.\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c c = a . min ( b ); c = a . max ( b ); //\u7c7b\u578b\u8f6c\u6362 //1.\u8f6c\u6362\u4e3abigNum\u7684\u4e8c\u8fdb\u5236\u8865\u7801\u5f62\u5f0f byte [] num1 = a . toByteArray (); //2.\u8f6c\u6362\u4e3abigNum\u7684\u5341\u8fdb\u5236\u5b57\u7b26\u4e32\u5f62\u5f0f String num2 = a . toString (); //3.\u8f6c\u6362\u4e3abigNum\u7684radix\u8fdb\u5236\u5b57\u7b26\u4e32\u5f62\u5f0f String num3 = a . toString ( 2 ); //4.\u5c06bigNum\u8f6c\u6362\u4e3aint int num4 = a . intValue (); //5.\u5c06bigNum\u8f6c\u6362\u4e3along long num5 = a . longValue (); //6.\u5c06bigNum\u8f6c\u6362\u4e3afloat float num6 = a . floatValue (); //7.\u5c06bigNum\u8f6c\u6362\u4e3adouble double num7 = a . doubleValue (); //\u4e8c\u8fdb\u5236\u8fd0\u7b97 //1.\u4e0e\uff1aa&b BigInteger bigNum1 = a . and ( b ); //2.\u6216\uff1aa|b BigInteger bigNum2 = a . or ( b ); //3.\u5f02\u6216\uff1aa^b BigInteger bigNum3 = a . xor ( b ); //4.\u53d6\u53cd\uff1a~a BigInteger bigNum4 = a . not (); //5.\u5de6\u79fbn\u4f4d\uff1a (a << n) BigInteger bigNum5 = a . shiftLeft ( 3 ); //6.\u53f3\u79fbn\u4f4d\uff1a (a >> n) BigInteger bigNum6 = a . shiftRight ( 3 ); } } } java BigDecimal \u8fd0\u7b97 \u00b6 import java.io.* ; import java.math.* ; import java.util.* ; public class Main { public static void main ( String args [] ) { Scanner cin = new Scanner ( System . in ); while ( cin . hasNext ()) ///\u76f8\u5f53\u4e8e scanf()!=EOF { BigDecimal a , b , c ; //\u5927\u6570\u521d\u59cb\u5316 //1.\u5341\u8fdb\u5236\u5b57\u7b26\u4e32 BigDecimal interNum1 = new BigDecimal ( \"0.005\" ); //2.\u5341\u8fdb\u5236\u6570\u5b57 BigDecimal interNum2 = new BigDecimal ( 0.000005 ); BigDecimal interNum3 = BigDecimal . valueOf ( 0.000005 ); //\u5927\u6570\u8bfb\u5165 a = cin . nextBigDecimal (); b = cin . nextBigDecimal (); //\u5927\u6570\u4fdd\u7559\u5c0f\u6570\u4f4d\u8f93\u51fa BigDecimal d = a . setScale ( 10 , RoundingMode . HALF_UP ); //\u4fdd\u7559\u5341\u4f4d\u5c0f\u6570 System . out . println ( d ); //\u57fa\u672c\u8fd0\u7b97 //1.\u628aa\u4e0eb\u76f8\u52a0\u5e76\u8d4b\u7ed9c c = a . add ( b ); //2.\u628aa\u4e0eb\u76f8\u51cf\u5e76\u8d4b\u7ed9c c = a . subtract ( b ); //3.\u628aa\u4e0eb\u76f8\u4e58\u5e76\u8d4b\u7ed9c c = a . multiply ( b ); //4.\u628aa\u4e0eb\u76f8\u9664\u5e76\u8d4b\u7ed9c c = a . divide ( b , 10 , BigDecimal . ROUND_UP ); //\u820d\u5165\u8fdc\u79bb\u96f6\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_DOWN ); //\u63a5\u8fd1\u96f6\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_CEILING ); //\u63a5\u8fd1\u6b63\u65e0\u7a77\u5927\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_FLOOR ); //\u63a5\u8fd1\u8d1f\u65e0\u7a77\u5927\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_HALF_UP ); //\u5411\u201c\u6700\u63a5\u8fd1\u7684\u201d\u6570\u5b57\u820d\u5165\uff0c\u5982\u679c\u4e0e\u4e24\u4e2a\u76f8\u90bb\u6570\u5b57\u7684\u8ddd\u79bb\u76f8\u7b49\uff0c\u5219\u4e3a\u5411\u4e0a\u820d\u5165\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_HALF_DOWN ); //\u5411\u201c\u6700\u63a5\u8fd1\u7684\u201d\u6570\u5b57\u820d\u5165\uff0c\u5982\u679c\u4e0e\u4e24\u4e2a\u76f8\u90bb\u6570\u5b57\u7684\u8ddd\u79bb\u76f8\u7b49\uff0c\u5219\u4e3a\u4e0a\u820d\u5165\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_HALF_EVEN ); //\u5411\u201c\u6700\u63a5\u8fd1\u7684\u201d\u6570\u5b57\u820d\u5165\uff0c\u5982\u679c\u4e0e\u4e24\u4e2a\u76f8\u90bb\u6570\u5b57\u7684\u8ddd\u79bb\u76f8\u7b49\uff0c\u5219\u5411\u76f8\u90bb\u7684\u5076\u6570\u820d\u5165\u3002 //5.\u6c42\u4f59 c = a . remainder ( b ); //6.\u76f8\u5f53\u4e8ea^b c = a . pow ( 2 ); //7.\u6839\u636e\u8be5\u6570\u503c\u662f\u5c0f\u4e8e\u3001\u7b49\u4e8e\u3001\u6216\u5927\u4e8ea \u8fd4\u56de -1\u30010 \u6216 1 int ans1 = a . compareTo ( b ); //8.\u5224\u65ad\u4e24\u6570\u662f\u5426\u76f8\u7b49\uff0c\u4e5f\u53ef\u4ee5\u7528compareTo\u6765\u4ee3\u66ff boolean ans2 = a . equals ( b ); //9.\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c c = a . min ( b ); c = a . max ( b ); //10.\u7edd\u5bf9\u503c c = a . abs (); //\u7c7b\u578b\u8f6c\u6362 //1.\u8f6c\u6362\u4e3abigNum\u7684\u5341\u8fdb\u5236\u5b57\u7b26\u4e32\u5f62\u5f0f String num2 = a . toString (); //2.\u5c06bigNum\u8f6c\u6362\u4e3aint int num4 = a . intValue (); //3.\u5c06bigNum\u8f6c\u6362\u4e3along long num5 = a . longValue (); //4.\u5c06bigNum\u8f6c\u6362\u4e3afloat float num6 = a . floatValue (); //5.\u5c06bigNum\u8f6c\u6362\u4e3adouble double num7 = a . doubleValue (); } } } \u5224\u65ad\u5468\u51e0 \u00b6 int getWeek ( int y , int m , int d ) { if ( m == 1 || m == 2 ) { m += 12 ; y -- ; } int week = ( d + 1 + 2 * m + 3 * ( m + 1 ) / 5 + y + y / 4 - y / 100 + y / 400 ) % 7 ; return week ; } \u7ec4\u5408\u6570\u5947\u5076\u5224\u65ad \u00b6 \u56fe\u8bba \u00b6 \u5806\u4f18\u5316prim\u7b97\u6cd5 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; struct node { int to , val ; }; vector < node > v [ 100500 ]; struct node1 { int now , val ; bool operator < ( const node1 & a ) const { return a . val < val ; } }; priority_queue < node1 > que ; int dis [ 100500 ] = { 0 }; void prim () { memset ( dis , -1 , sizeof ( dis )); que . push ({ 1 , 0 }); while ( ! que . empty ()) { node1 now = que . top (); que . pop (); if ( dis [ now . now ] != -1 ) continue ; dis [ now . now ] = now . val ; for ( int i = 0 ; i < v [ now . now ]. size (); i ++ ) { int to = v [ now . now ][ i ]. to ; int val = v [ now . now ][ i ]. val ; if ( dis [ to ] != -1 ) continue ; que . push ({ to , val }); } } } int main () { int n , m , from , to , val ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d%d\" , & from , & to , & val ); v [ from ]. push_back ({ to , val }); v [ to ]. push_back ({ from , val }); } prim (); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { if ( dis [ i ] == -1 ) return 0 * puts ( \"orz\" ); ///\u4e0d\u8fde\u901a ans += dis [ i ]; } cout << ans << endl ; } ```` #### SPFA\u5224\u65ad\u8d1f\u73af ``` c ++ #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <queue> #include <algorithm> #define INF 0x3f3f3f3f using namespace std ; const int MAXN = 5500 ; int n , m , w ; struct Edge { int v , w , next ; } edge [ MAXN ]; int head [ MAXN ], dis [ MAXN ], vis [ MAXN ], t ; void Init () { memset ( head , -1 , sizeof ( head )); t = 0 ; } void Add_edge ( int u , int v , int w ) { edge [ t ]. v = v ; edge [ t ]. w = w ; edge [ t ]. next = head [ u ]; head [ u ] = t ++ ; } bool SPFA () { int mark [ MAXN ]; //\u8bb0\u5f55\u6bcf\u4e2a\u70b9\u5982\u961f\u5217\u7684\u6b21\u6570 for ( int i = 1 ; i <= n ; i ++ ) { mark [ i ] = 0 ; dis [ i ] = INF ; vis [ i ] = 0 ; } queue < int > q ; q . push ( 1 ); //\u6211\u4eec\u53ea\u9700\u8981\u5224\u65ad\u8d1f\u73af\uff0c\u968f\u4fbf\u627e\u4e00\u4e2a\u8d77\u70b9\u5c31\u597d dis [ 1 ] = 0 ; vis [ 1 ] = 1 ; //\u5165\u961f\u5217 mark [ 1 ] ++ ; while ( ! q . empty ()) { int u = q . front (); q . pop (); vis [ u ] = 0 ; //\u51fa\u961f\u5217 for ( int i = head [ u ]; i != -1 ; i = edge [ i ]. next ) { int v = edge [ i ]. v ; if ( dis [ v ] > dis [ u ] + edge [ i ]. w ) { dis [ v ] = dis [ u ] + edge [ i ]. w ; if ( ! vis [ v ]) //\u4e0d\u5728\u961f\u5217\u4e2d\u7684\u65f6\u5019\u51fa\u961f { q . push ( v ); mark [ v ] ++ ; vis [ v ] = 1 ; } if ( mark [ v ] >= n ) //\u5982\u679c\u4e0d\u5b58\u5728\u8d1f\u73af\uff0c\u90a3\u4e48\u6700\u591a\u66f4\u65b0n-1\u6b21\u5c31\u53ef\u4ee5\u5f97\u5230\u6700\u7ec8\u7684\u7b54\u6848\uff0c\u56e0\u4e3a\u4e00\u6b21\u6700\u5c11\u66f4\u65b0\u4e00\u4e2a\u8282\u70b9\uff0c\u90a3\u4e48\u5982\u679c\u51fa\u73b0\u4e86\u66f4\u65b0n\u6b21\uff0c\u90a3\u4e48\u5c31\u4e00\u5b9a\u51fa\u73b0\u4e86\u8d1f\u73af return false ; } } } return true ; } int main () { int T ; scanf ( \"%d\" , & T ); while ( T -- ) { Init (); int u , v , z ; scanf ( \"%d%d%d\" , & n , & m , & w ); for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d%d\" , & u , & v , & z ); Add_edge ( u , v , z ); Add_edge ( v , u , z ); } for ( int i = 0 ; i < w ; i ++ ) { scanf ( \"%d%d%d\" , & u , & v , & z ); Add_edge ( u , v , - z ); } if ( ! SPFA ()) printf ( \"YES \\n \" ); else printf ( \"NO \\n \" ); } return 0 ; } dijikastra\u7b2ck\u77ed\u8def \u00b6 #include <iostream> #include <cstdio> #include <cstring> #include <queue> using namespace std ; const int INF = 0x3f3f3f3f ; const int MAX = 1005 ; int n , m ; int start , end , k ; struct Edge { int w ; int to ; int next ; }; Edge e [ 100005 ]; int head [ MAX ], edgeNum ; int dis [ MAX ]; //dis[i]\u8868\u793a\u4ecei\u70b9\u5230end\u7684\u6700\u77ed\u8ddd\u79bb bool vis [ MAX ]; int cnt [ MAX ]; vector < Edge > opp_Graph [ MAX ]; struct Node { int f , g ; //f = g+dis[v] int v ; //\u5f53\u524d\u5230\u8fbe\u7684\u8282\u70b9 Node ( int a , int b , int c ) : f ( a ), g ( b ), v ( c ){} bool operator < ( const Node & a ) const { return a . f < f ; } }; void addEdge ( int from , int to , int w ) { e [ edgeNum ]. to = to ; e [ edgeNum ]. w = w ; e [ edgeNum ]. next = head [ from ]; head [ from ] = edgeNum ++ ; } void dijikastra ( int start ) { int i ; memset ( vis , 0 , sizeof ( vis )); for ( i = 1 ; i <= n ; i ++ ) dis [ i ] = INF ; dis [ start ] = 0 ; priority_queue < Node > que ; que . push ( Node ( 0 , 0 , start )); Node next ( 0 , 0 , 0 ); while ( ! que . empty ()) { Node now = que . top (); que . pop (); if ( vis [ now . v ]) //\u4ece\u96c6\u5408T\u4e2d\u9009\u53d6\u5177\u6709\u6700\u77ed\u8ddd\u79bb\u7684\u8282\u70b9 continue ; vis [ now . v ] = true ; //\u6807\u8bb0\u8282\u70b9\u5df2\u4ece\u96c6\u5408T\u52a0\u5165\u5230\u96c6\u5408S\u4e2d for ( i = 0 ; i < opp_Graph [ now . v ]. size (); i ++ ) //\u66f4\u65b0\u4ece\u6e90\u70b9\u5230\u5176\u5b83\u8282\u70b9(\u96c6\u5408T\u4e2d)\u7684\u6700\u77ed\u8ddd\u79bb { Edge edge = opp_Graph [ now . v ][ i ]; if ( ! vis [ edge . to ] && dis [ now . v ] + edge . w < dis [ edge . to ]) //\u52a0\u4e0d\u52a0\u524d\u9762\u7684\u5224\u65ad\u65e0\u6240\u8c13 { dis [ edge . to ] = dis [ now . v ] + edge . w ; next . f = dis [ edge . to ]; next . v = edge . to ; que . push ( next ); } } } } int A_Star () { int i ; priority_queue < Node > que ; if ( dis [ start ] == INF ) return -1 ; que . push ( Node ( dis [ start ], 0 , start )); Node next ( 0 , 0 , 0 ); while ( ! que . empty ()) { Node now = que . top (); que . pop (); cnt [ now . v ] ++ ; if ( cnt [ end ] == k ) return now . f ; if ( cnt [ now . v ] > k ) continue ; for ( i = head [ now . v ]; i != -1 ; i = e [ i ]. next ) { next . v = e [ i ]. to ; next . g = now . g + e [ i ]. w ; next . f = next . g + dis [ e [ i ]. to ]; que . push ( next ); } } return -1 ; } int main () { int i ; int from , to , w ; edgeNum = 0 ; memset ( head , -1 , sizeof ( head )); memset ( opp_Graph , 0 , sizeof ( opp_Graph )); memset ( cnt , 0 , sizeof ( cnt )); scanf ( \"%d %d\" , & n , & m ); Edge edge ; for ( i = 1 ; i <= m ; i ++ ) { scanf ( \"%d %d %d\" , & from , & to , & w ); addEdge ( from , to , w ); edge . to = from ; edge . w = w ; opp_Graph [ to ]. push_back ( edge ); } scanf ( \"%d %d %d\" , & start , & end , & k ); if ( start == end ) k ++ ; dijikastra ( end ); int result = A_Star (); printf ( \"%d \\n \" , result ); return 0 ; } LCA+ST\u500d\u589e\u7b97\u6cd5 \u00b6 #include <bits/stdc++.h> using namespace std ; //lca\u677f\u5b50\u9898,\u6c42\u4fe9\u4e2a\u70b9\u6700\u77ed\u8ddd\u79bb //\u6811\u4e0a\u4e24\u70b9\u6700\u77ed\u8def\u5f84:\u4ece\u6839\u8282\u70b9\u51fa\u53d1dis[u]+dis[v]-dis[lca]*2 struct node { int to , next ; }; int tot = 0 ; node edge [ 1000500 ] = { 0 }; int head [ 500500 ] = { 0 }; int fa [ 500500 ][ 18 ] = { 0 }; int dep [ 500500 ] = { 0 }; void add ( int from , int to ) { edge [ ++ tot ]. next = head [ from ]; edge [ tot ]. to = to ; head [ from ] = tot ; } void dfs ( int now , int fa1 ) { dep [ now ] = dep [ fa1 ] + 1 ; fa [ now ][ 0 ] = fa1 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to != fa1 ) dfs ( to , now ); } } int lca ( int x , int y ) { if ( dep [ x ] < dep [ y ]) swap ( x , y ); for ( int j = 17 ; j >= 0 ; j -- ) { if ( dep [ fa [ x ][ j ]] >= dep [ y ]) x = fa [ x ][ j ]; } if ( x == y ) return x ; for ( int j = 17 ; j >= 0 ; j -- ) { if ( fa [ x ][ j ] != fa [ y ][ j ]) x = fa [ x ][ j ], y = fa [ y ][ j ]; } return fa [ x ][ 0 ]; } int main () { int n , m , s , f , t ; scanf ( \"%d%d%d\" , & n , & m , & s ); ///s\u4e3a\u6839\u8282\u70b9 for ( int i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%d%d\" , & f , & t ); add ( f , t ); add ( t , f ); } dfs ( s , 0 ); for ( int j = 1 ; j <= 17 ; j ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { fa [ i ][ j ] = fa [ fa [ i ][ j - 1 ]][ j - 1 ]; } } for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & f , & t ); printf ( \"%d \\n \" , lca ( f , t )); } } \u6811\u7684\u76f4\u5f84 \u00b6 #include <bits/stdc++.h> using namespace std ; struct node { int to , val , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }; int cnt = 0 ; int add_edge ( int from , int to , int val ) { edge [ ++ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. val = val ; head [ from ] = cnt ; } int dp [ 200500 ][ 4 ] = { 0 }; int down [ 200500 ] = { 0 }; int up [ 200500 ] = { 0 }; int len [ 200500 ][ 3 ] = { 0 }; int dfs1 ( int now , int fa ) { for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to , val = edge [ i ]. val ; if ( to == fa ) continue ; dfs1 ( to , now ); int tmp = dp [ to ][ 0 ] + val ; if ( tmp > dp [ now ][ 0 ]) swap ( dp [ now ][ 0 ], tmp ); if ( tmp > dp [ now ][ 1 ]) swap ( dp [ now ][ 1 ], tmp ); if ( tmp > dp [ now ][ 2 ]) swap ( dp [ now ][ 2 ], tmp ); down [ now ] = max ( down [ now ], down [ to ]); } down [ now ] = max ( down [ now ], dp [ now ][ 0 ] + dp [ now ][ 1 ]); } int dfs2 ( int now , int fa ) { for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { if ( edge [ i ]. to == fa ) continue ; int tem = down [ edge [ i ]. to ]; if ( tem > len [ now ][ 0 ]) swap ( tem , len [ now ][ 0 ]); if ( tem > len [ now ][ 1 ]) swap ( tem , len [ now ][ 1 ]); } for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to , val = edge [ i ]. val ; if ( to == fa ) continue ; if ( dp [ now ][ 0 ] == dp [ to ][ 0 ] + val ) { dp [ to ][ 3 ] = max ( dp [ now ][ 1 ], dp [ now ][ 3 ]) + val ; up [ to ] = max ( dp [ now ][ 2 ], dp [ now ][ 3 ]) + dp [ now ][ 1 ]; } else if ( dp [ now ][ 1 ] == dp [ to ][ 0 ] + val ) { dp [ to ][ 3 ] = max ( dp [ now ][ 0 ], dp [ now ][ 3 ]) + val ; up [ to ] = max ( dp [ now ][ 2 ], dp [ now ][ 3 ]) + dp [ now ][ 0 ]; } else { dp [ to ][ 3 ] = max ( dp [ now ][ 0 ], dp [ now ][ 3 ]) + val ; up [ to ] = max ( dp [ now ][ 1 ], dp [ now ][ 3 ]) + dp [ now ][ 0 ]; } if ( len [ now ][ 0 ] == down [ to ]) up [ to ] = max ( up [ to ], len [ now ][ 1 ]); else up [ to ] = max ( up [ to ], len [ now ][ 0 ]); dfs2 ( to , now ); } } int main () { int n , from , to , val ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n -1 ; i ++ ) { scanf ( \"%d%d%d\" , & from , & to , & val ); add_edge ( from , to , val ); add_edge ( to , from , val ); } dfs1 ( 1 , -1 ); dfs2 ( 1 , -1 ); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans = max ( ans , up [ i ] + down [ i ]); cout << ans << endl ; } \u6700\u5927\u6d41\u7b97\u6cd5 \u00b6 EK\u7b97\u6cd5\uff1a #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll to , val , next ; }; node edge [ 805 ] = { 0 }; ll head [ 205 ] = { 0 }; ll cnt = 0 ; ll s = 1 , e = 1 ; void add_edge ( ll from , ll to , ll val ) { edge [ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. val = val ; head [ from ] = cnt ++ ; } ll pre [ 205 ] = { 0 }, tag [ 205 ] = { 0 }, vis [ 205 ] = { 0 }; ll bfs () { queue < ll > que ; memset ( tag , 0 , sizeof ( tag )); memset ( pre , 0 , sizeof ( pre )); memset ( vis , 0 , sizeof ( vis )); que . push ( s ); vis [ s ] = 1 ; while ( ! que . empty ()) { ll now = que . front (); que . pop (); for ( ll i = head [ now ]; i != -1 ; i = edge [ i ]. next ) { ll to = edge [ i ]. to , val = edge [ i ]. val ; if ( ! vis [ to ] && val > 0 ) { vis [ to ] = 1 ; pre [ to ] = now ; tag [ to ] = i ; if ( to == e ) return 1 ; que . push ( to ); } } } return 0 ; } ll EK () { ll ans = 0 ; while ( bfs ()) { ll min1 = inf ; for ( ll i = e ; i != s ; i = pre [ i ]) { min1 = min ( min1 , edge [ tag [ i ]]. val ); } for ( ll i = e ; i != s ; i = pre [ i ]) { edge [ tag [ i ]]. val -= min1 ; edge [ tag [ i ] ^ 1 ]. val += min1 ; } ans += min1 ; } return ans ; } int main () { ll n , m , from , to , val ; while ( scanf ( \"%lld%lld\" , & m , & n ) == 2 && n ){ e = n ; cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) head [ i ] = -1 ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld%lld\" , & from , & to , & val ); add_edge ( from , to , val ); add_edge ( to , from , 0 ); } printf ( \"%lld \\n \" , EK ()); } } \u4f18\u5316\u7248Dinic\u7b97\u6cd5\uff1a #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define INF 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct Edge { ll from , to , cap , flow , index ; Edge ( ll from , ll to , ll cap , ll flow , ll index ) : from ( from ), to ( to ), cap ( cap ), flow ( flow ), index ( index ) {} }; struct Dinic { ll N ; vector < vector < Edge >> G ; vector < Edge *> dad ; vector < ll > Q ; Dinic ( ll N ) : N ( N ), G ( N ), dad ( N ), Q ( N ) {} void AddEdge ( ll from , ll to , ll cap ) { G [ from ]. push_back ( Edge ( from , to , cap , 0 , G [ to ]. size ())); if ( from == to ) G [ from ]. back (). index ++ ; G [ to ]. push_back ( Edge ( to , from , 0 , 0 , G [ from ]. size () - 1 )); } ll BlockingFlow ( ll s , ll t ) { fill ( dad . begin (), dad . end (), ( Edge * ) NULL ); dad [ s ] = & G [ 0 ][ 0 ] - 1 ; ll head = 0 , tail = 0 ; Q [ tail ++ ] = s ; while ( head < tail ) { ll x = Q [ head ++ ]; for ( ll i = 0 ; i < G [ x ]. size (); i ++ ) { Edge & e = G [ x ][ i ]; if ( ! dad [ e . to ] && e . cap - e . flow > 0 ) { dad [ e . to ] = & G [ x ][ i ]; Q [ tail ++ ] = e . to ; } } } if ( ! dad [ t ]) return 0 ; ll totflow = 0 ; for ( ll i = 0 ; i < G [ t ]. size (); i ++ ) { Edge * start = & G [ G [ t ][ i ]. to ][ G [ t ][ i ]. index ]; ll amt = INF ; for ( Edge * e = start ; amt && e != dad [ s ]; e = dad [ e -> from ]) { if ( ! e ) { amt = 0 ; break ; } amt = min ( amt , e -> cap - e -> flow ); } if ( amt == 0 ) continue ; for ( Edge * e = start ; amt && e != dad [ s ]; e = dad [ e -> from ]) { e -> flow += amt ; G [ e -> to ][ e -> index ]. flow -= amt ; } totflow += amt ; } return totflow ; } ll GetMaxFlow ( ll s , ll t ) { ll totflow = 0 ; while ( ll flow = BlockingFlow ( s , t )) totflow += flow ; return totflow ; } }; int main () { ll n , m , f , t , v , s , e ; scanf ( \"%lld%lld\" , & n , & m ); scanf ( \"%lld%lld\" , & s , & e ); Dinic dinic ( n + 10 ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld%lld\" , & f , & t , & v ); dinic . AddEdge ( f , t , v ); } printf ( \"%lld \\n \" , dinic . GetMaxFlow ( s , e )); } \u666e\u901a\u7248\u672cdinic\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll INF = 1e18 ; const int N = 5e2 + 7 ; const int M = 2e5 + 7 ; int head [ N ], nex [ M ], ver [ M ], tot = 1 ; ll edge [ M ]; int n , m , s , t ; ll maxflow ; ll deep [ N ]; //\u5c42\u7ea7\u6570\uff0c\u5176\u5b9e\u5e94\u8be5\u662flevel int now [ M ]; //\u5f53\u524d\u5f27\u4f18\u5316 queue < int > q ; inline void add ( int x , int y , int z ) { //\u5efa\u6b63\u8fb9\u548c\u53cd\u5411\u8fb9 ver [ ++ tot ] = y ; edge [ tot ] = z ; nex [ tot ] = head [ x ]; head [ x ] = tot ; ver [ ++ tot ] = x ; edge [ tot ] = 0 ; nex [ tot ] = head [ y ]; head [ y ] = tot ; } inline bool bfs () { //\u5728\u6b8b\u91cf\u7f51\u7edc\u4e2d\u6784\u9020\u5206\u5c42\u56fe for ( int i = 1 ; i <= n ; i ++ ) deep [ i ] = INF ; while ( ! q . empty ()) q . pop (); q . push ( s ); deep [ s ] = 0 ; now [ s ] = head [ s ]; //\u4e00\u4e9b\u521d\u59cb\u5316 while ( ! q . empty ()) { int x = q . front (); q . pop (); for ( int i = head [ x ]; i ; i = nex [ i ]) { int y = ver [ i ]; if ( edge [ i ] > 0 && deep [ y ] == INF ) { //\u6ca1\u8d70\u8fc7\u4e14\u5269\u4f59\u5bb9\u91cf\u5927\u4e8e0 q . push ( y ); now [ y ] = head [ y ]; //\u5148\u521d\u59cb\u5316\uff0c\u6682\u65f6\u90fd\u4e00\u6837 deep [ y ] = deep [ x ] + 1 ; if ( y == t ) return 1 ; //\u627e\u5230\u4e86 } } } return 0 ; } //flow\u662f\u6574\u6761\u589e\u5e7f\u8def\u5bf9\u6700\u5927\u6d41\u7684\u8d21\u732e\uff0crest\u662f\u5f53\u524d\u6700\u5c0f\u5269\u4f59\u5bb9\u91cf\uff0c\u7528rest\u53bb\u66f4\u65b0flow ll dfs ( int x , ll flow ) { //\u5728\u5f53\u524d\u5206\u5c42\u56fe\u4e0a\u589e\u5e7f if ( x == t ) return flow ; ll ans = 0 , k , i ; for ( i = now [ x ]; i && flow ; i = nex [ i ]) { now [ x ] = i ; //\u5f53\u524d\u5f27\u4f18\u5316\uff08\u907f\u514d\u91cd\u590d\u904d\u5386\u4ecex\u51fa\u53d1\u7684\u4e0d\u53ef\u62d3\u5c55\u7684\u8fb9\uff09 int y = ver [ i ]; if ( edge [ i ] > 0 && ( deep [ y ] == deep [ x ] + 1 )) { //\u5fc5\u987b\u662f\u4e0b\u4e00\u5c42\u5e76\u4e14\u5269\u4f59\u5bb9\u91cf\u5927\u4e8e0 k = dfs ( y , min ( flow , edge [ i ])); //\u53d6\u6700\u5c0f if ( ! k ) deep [ y ] = INF ; //\u526a\u679d\uff0c\u53bb\u6389\u589e\u5e7f\u5b8c\u6bd5\u7684\u70b9 edge [ i ] -= k ; //\u56de\u6eaf\u65f6\u66f4\u65b0 edge [ i ^ 1 ] += k ; //\u6210\u5bf9\u53d8\u6362 ans += k ; flow -= k ; } } return ans ; } void dinic () { while ( bfs ()) maxflow += dfs ( s , INF ); } int main () { scanf ( \"%d%d%d%d\" , & n , & m , & s , & t ); tot = 1 ; for ( ll i = 1 ; i <= m ; i ++ ) { int x , y , z ; scanf ( \"%d%d%d\" , & x , & y , & z ); add ( x , y , z ); } dinic (); printf ( \"%lld \\n \" , maxflow ); return 0 ; } \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u7b97\u6cd5 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int next ; int flow ; int dis ; int to ; }; int head [ 100500 ] = { 0 }; node edge [ 100500 ] = { 0 }; int dis [ 100500 ] = { 0 }; int pre [ 100500 ] = { 0 }; int vis [ 100500 ] = { 0 }; int last [ 100500 ] = { 0 }; int flow [ 100500 ] = { 0 }; char g [ 1000 ][ 1000 ] = { 0 }; int n , m , s , t , cnt = -1 , maxflow = 0 , mincost = 0 ; int num ( int i , int j ) { return i * m + j ; } int add ( int from , int to , int flow , int dis ) { edge [ ++ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. flow = flow ; edge [ cnt ]. dis = dis ; head [ from ] = cnt ; } queue < int > w ; bool spfa ( int start , int end1 ) { w . push ( start ); memset ( dis , 0x3f3f3f , sizeof ( dis )); memset ( vis , 0 , sizeof ( vis )); memset ( flow , 0x3f3f3f , sizeof ( flow )); pre [ end1 ] = -1 ; vis [ start ] = 1 ; dis [ start ] = 0 ; while ( ! w . empty ()) { int now = w . front (); w . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i != -1 ; i = edge [ i ]. next ) { //cout<<i<<endl; if ( edge [ i ]. flow > 0 && dis [ edge [ i ]. to ] > dis [ now ] + edge [ i ]. dis ) { dis [ edge [ i ]. to ] = dis [ now ] + edge [ i ]. dis ; pre [ edge [ i ]. to ] = now ; last [ edge [ i ]. to ] = i ; flow [ edge [ i ]. to ] = min ( flow [ now ], edge [ i ]. flow ); if ( ! vis [ edge [ i ]. to ]) { vis [ edge [ i ]. to ] = 1 ; w . push ( edge [ i ]. to ); } } } } return pre [ end1 ] != -1 ; } int MCMF () { while ( spfa ( s , t )) { maxflow += flow [ t ]; mincost += dis [ t ] * flow [ t ]; int now = t ; while ( now != s ) { edge [ last [ now ]]. flow -= flow [ t ]; edge [ last [ now ] ^ 1 ]. flow += flow [ t ]; now = pre [ now ]; } } } int main () { memset ( head , -1 , sizeof ( head )); scanf ( \"%d%d\" , & n , & m ); s = n * m + 200 , t = n * m + 100 ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , g [ i ] + 1 ); } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( g [ i ][ j ] == 'x' ) continue ; if ( j > 1 && g [ i ][ j -1 ] != 'x' ) { add ( num ( i , j ), num ( i , j -1 ), 1 , 1 ); add ( num ( i , j -1 ), num ( i , j ), 0 , -1 ); } if ( i > 1 && g [ i -1 ][ j ] != 'x' ) { add ( num ( i , j ), num ( i -1 , j ), 1 , 1 ); add ( num ( i -1 , j ), num ( i , j ), 0 , -1 ); } if ( j < m && g [ i ][ j + 1 ] != 'x' ) { add ( num ( i , j ), num ( i , j + 1 ), 1 , 1 ); add ( num ( i , j + 1 ), num ( i , j ), 0 , -1 ); } if ( i < n && g [ i + 1 ][ j ] != 'x' ) { add ( num ( i , j ), num ( i + 1 , j ), 1 , 1 ); add ( num ( i + 1 , j ), num ( i , j ), 0 , -1 ); } if ( g [ i ][ j ] == 'F' ) { add ( s , num ( i , j ), 2 , 0 ); add ( num ( i , j ), s , 0 , 0 ); } if ( g [ i ][ j ] == 'C' || g [ i ][ j ] == 'B' ) { add ( num ( i , j ), t , 1 , 0 ); add ( t , num ( i , j ), 0 , 0 ); } } } MCMF (); // cout<<maxflow<<\" \"<<mincost<<endl; if ( maxflow != 2 ) printf ( \"-1 \\n \" ); else printf ( \"%d \\n \" , mincost ); } \u4e8c\u5206\u56fe\u6a21\u677f \u00b6 \u9898\u610f\uff1a\u7ed9\u4f60n\u4e2a\u957f\u5ea6\u76f8\u540c\uff0c\u5305\u542b\u5b57\u6bcd\u79cd\u7c7b\u76f8\u540c\uff0c\u6bcf\u79cd\u5b57\u6bcd\u6570\u91cf\u76f8\u540c\uff0c\u8ba9\u4f60\u786e\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\u96c6\u5408\uff0c\u96c6\u5408\u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u4e32\u4e0d\u80fd\u901a\u8fc7\u4ea4\u6362\u4efb\u610f\u4e24\u4e2a\u4e0d\u540c\u7684\u4f4d\u7f6e\u53d8\u6210\u96c6\u5408\u4e2d\u7684\u53e6\u4e00\u4e2a\u4e32\uff0c\u95ee\u4f60\u96c6\u5408\u6700\u5927\u6709\u591a\u4e2a\u5b57\u7b26\u4e32\u3002 \u601d\u8def\uff1a \u6211\u4eec\u5bf9\u4e8e\u4e24\u4e2a\u4e00\u6b21\u64cd\u4f5c\uff08\u4ea4\u6362\u4e24\u4e2a\u4e0d\u540c\u4f4d\u7f6e\uff09\u4e0d\u80fd\u4e92\u76f8\u53d8\u6362\u7684\u4e32\u5efa\u8fb9\uff0c\u90a3\u4e48\u7b54\u6848\u5c31\u662f\u8fd9\u4e2a\u56fe\u7684\u6700\u5927\u56e2\u3002 \u4e00\u4e2a\u56fe\u7684\u6700\u5927\u56e2\u7b49\u4e8e\u8fd9\u4e2a\u56fe\u8865\u56fe\u7684\u6700\u5927\u72ec\u7acb\u96c6\uff0c\u90a3\u4e48\u6211\u4eec\u8981\u5efa\u8fd9\u4e2a\u56fe\u7684\u8865\u56fe\u3002 \u8fd9\u4e2a\u56fe\u7684\u8865\u56fe\u5c31\u662f\u5bf9\u80fd\u591f\u4e00\u6b21\u64cd\u4f5c\u4e92\u76f8\u53d8\u6362\u7684\u4e24\u4e2a\u4e32\u5efa\u8fb9\u3002 \u90a3\u4e48\u73b0\u5728\u7b54\u6848\u5c31\u662f\u8fd9\u4e2a\u8865\u56fe\u7684\u6700\u5927\u72ec\u7acb\u96c6\u3002 \u8fd9\u4e2a\u8865\u56fe\u4e00\u5b9a\u662f\u4e00\u4e2a\u4e8c\u5206\u56fe\u3002 \u4e8c\u5206\u56fe\u7684\u6700\u5927\u72ec\u7acb\u96c6\u7b49\u4e8e\u56fe\u4e2d\u70b9\u7684\u4e2a\u6570 - \u6700\u5927\u5339\u914d\u6570\u3002 \u6240\u4ee5\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u5bf9\u8fd9\u4e2a\u4e8c\u5206\u56fe\u6c42\u4e00\u4e2a\u6700\u5927\u5339\u914d\u3002 #include <bits/stdc++.h> using namespace std ; char a [ 1000 ][ 300 ] = { 0 }; int mp [ 1000 ][ 1000 ] = { 0 }; map < int , int > mp1 , vis ; int n ; int dfs ( int k ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( mp [ i ][ k ] &&! vis [ i ]) { vis [ i ] = 1 ; if ( mp1 [ i ] == 0 || dfs ( mp1 [ i ])) { mp1 [ i ] = k ; return 1 ; } } } return 0 ; } int main () { scanf ( \"%d\" , & n ); ///\u4e24\u4e2a\u5b57\u7b26\u4e32\u4e2d\u4e0d\u80fd\u6709\u4e24\u4e2a\u5b57\u7b26\u76f8\u540c\uff0c\u95ee\u81f3\u5c11\u9700\u8981\u5206\u4e3a\u591a\u5c11\u7ec4 for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int sum = 0 ; for ( int k = 1 ; a [ i ][ k ]; k ++ ) { if ( a [ i ][ k ] != a [ j ][ k ]) sum ++ ; } if ( sum == 2 ) mp [ i ][ j ] = 1 ; } } //cout<<mp[1][2]<<endl; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { vis . clear (); ans += dfs ( i ); } cout << n - ans / 2 << endl ; } \u4e8c\u5206\u56fe\u5224\u65ad #include <bits/stdc++.h> using namespace std ; vector < int > v [ 100500 ]; int color [ 100500 ] = { 0 }; int bfs ( int i ) { queue < int > que ; que . push ( i ); while ( ! que . empty ()) { int now = que . front (); que . pop (); for ( int i : v [ now ]) { if ( color [ i ] == 0 ) { color [ i ] = 3 - color [ now ]; que . push ( i ); } else { if ( color [ i ] == color [ now ]) return 0 ; } } } return 1 ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int from , to ; scanf ( \"%d %d\" , & from , & to ); v [ from ]. push_back ( to ); v [ to ]. push_back ( from ); } for ( int i = 1 ; i <= m ; i ++ ) { if ( color [ i ] == 0 ) { int tmp = bfs ( i ); if ( tmp == 0 ) { puts ( \"No\" ); return 0 ; } } } puts ( \"Yes\" ); } /* \u8f93\u5165\uff1a 7 6 1 2 1 3 2 4 2 5 3 6 3 7 \u8f93\u51fa\uff1a Yes \u8f93\u5165\uff1a 3 3 1 2 2 3 1 3 \u8f93\u51fa\uff1a No */ \u4e8c\u5206\u56fe\u6700\u5927\u5339\u914d #include <bits/stdc++.h> using namespace std ; vector < int > v [ 100500 ]; map < int , int > mp , vis , mp1 ; int dfs ( int now ) { for ( int i = 0 ; i < v [ now ]. size (); i ++ ) { int to = v [ now ][ i ]; if ( ! vis [ to ]) { vis [ to ] = 1 ; if ( mp [ to ] == 0 || dfs ( mp [ to ])) { mp [ to ] = now ; mp1 [ now ] = to ; return 1 ; } } } return 0 ; } int main () { int n1 , n2 , m ; scanf ( \"%d%d%d\" , & n1 , & n2 , & m ); int from , to ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); to += n1 ; v [ from ]. push_back ( to ); v [ to ]. push_back ( from ); } int ans = 0 ; for ( int i = 1 ; i <= n1 ; i ++ ) { vis . clear (); ans += dfs ( i ); } cout << ans << endl ; for ( int i = 1 ; i <= n1 ; i ++ ) cout << max ( 0 , mp1 [ i ] - n1 ) << ' ' ; } \u4e8c\u5206\u56fe\u6700\u5927\u72ec\u7acb\u96c6\uff1a \u9009\u6700\u591a\u7684\u70b9\uff0c\u6ee1\u8db3\u4e24\u4e24\u4e4b\u95f4\u6ca1\u6709\u8fb9\u76f8\u8fde\u3002 \u4e8c\u5206\u56fe\u4e2d\uff0c\u6700\u5927\u72ec\u7acb\u96c6 =n- \u6700\u5927\u5339\u914d\u3002 \u4e8c\u5206\u56fe\u6700\u5c0f\u70b9\u8986\u76d6\uff1a \u9009\u6700\u5c11\u7684\u70b9\uff0c\u6ee1\u8db3\u6bcf\u6761\u8fb9\u81f3\u5c11\u6709\u4e00\u4e2a\u7aef\u70b9\u88ab\u9009\uff0c\u4e0d\u96be\u53d1\u73b0\u8865\u96c6\u662f\u72ec\u7acb\u96c6\u3002 \u4e8c\u5206\u56fe\u4e2d\uff0c\u6700\u5c0f\u70b9\u8986\u76d6 =n- \u6700\u5927\u72ec\u7acb\u96c6\u3002 \u4e8c\u5206\u56fe\u6709\u5411\u65e0\u5411\u5efa\u56fe\u89c4\u5219\uff1a \u6709\u5de6\u53f3\u4e4b\u5206\u5efa\u5355\u5411\u8fb9\uff0c\u65e0\u5de6\u53f3\u4e4b\u5206\u5efa\u65e0\u5411\u8fb9 \u7b54\u6848\u96642 \u4e00\u5207\u6811\u5747\u4e3a\u4e8c\u5206\u56fe \u4e8c\u5206\u56fe\u6700\u5927\u6743\u5339\u914d\uff1a \u9898\u76ee\uff1a https://uoj.ac/problem/80 \u9898\u89e3\uff1a https://blog.csdn.net/weixin_30528371/article/details/99263983 \u8bb2\u89e3\uff1a https://www.cnblogs.com/wenruo/p/5264235.html #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; int n , m , q ; int w [ 405 ] = { 0 }, v [ 405 ] = { 0 }; int vl [ 405 ] = { 0 }, vr [ 405 ] = { 0 }, c [ 405 ] = { 0 }; int a [ 405 ][ 405 ] = { 0 }, ans [ 405 ] = { 0 }, b [ 405 ] = { 0 }; int tim = 0 ; int dfs ( int x ) { vl [ x ] = tim ; for ( int i = 1 ; i <= m ; i ++ ) { if ( vr [ i ] == tim ) continue ; int d = w [ x ] + v [ i ] - a [ x ][ i ]; if ( d == 0 ) { vr [ i ] = tim ; if ( ! b [ i ] || dfs ( b [ i ])) { b [ i ] = x ; return 1 ; } } else { c [ i ] = min ( c [ i ], d ); } } return 0 ; } void km () { for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) w [ i ] = max ( w [ i ], a [ i ][ j ]); for ( int i = 1 ; i <= n ; i ++ ) { memset ( c , inf , sizeof ( c )); tim += 1 ; if ( dfs ( i )) continue ; while ( 1 ) { int d = inf , y = 0 ; for ( int j = 1 ; j <= m ; j ++ ) if ( vr [ j ] != tim ) d = min ( d , c [ j ]); for ( int j = 1 ; j <= n ; j ++ ) if ( vl [ j ] == tim ) w [ j ] -= d ; for ( int j = 1 ; j <= m ; j ++ ) { if ( vr [ j ] == tim ) v [ j ] += d ; else if ( ! ( c [ j ] -= d )) y = j ; } if ( ! b [ y ]) break ; int x = b [ y ]; vl [ x ] = vr [ y ] = tim ; for ( int j = 1 ; j <= m ; j ++ ) c [ j ] = min ( c [ j ], w [ x ] + v [ j ] - a [ x ][ j ]); } tim += 1 ; dfs ( i ); } ll ans1 = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans1 += a [ b [ i ]][ i ]; printf ( \"%lld \\n \" , ans1 ); for ( int i = 1 ; i <= m ; i ++ ) { if ( a [ b [ i ]][ i ]) ans [ b [ i ]] = i ; } for ( int i = 1 ; i <= n ; i ++ ) printf ( \"%d \" , ans [ i ]); } int main () { scanf ( \"%d%d%d\" , & n , & m , & q ); m = max ( m , n ); for ( int i = 1 ; i <= q ; i ++ ) { int x , y , v ; scanf ( \"%d%d%d\" , & x , & y , & v ); a [ x ][ y ] = v ; } km (); } Tarjan\u7b97\u6cd5 \u00b6 Tarjan \u7b97\u6cd5\u53ca\u5176\u5e94\u7528 \u6c42\u5272\u8fb9 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int to , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }, dfn [ 200500 ] = { 0 }, low [ 200500 ] = { 0 }, bridge [ 200500 ] = { 0 }; int cnt = 1 , tot = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } void tarjan ( int x , int in_edge ) { dfn [ x ] = low [ x ] = ++ tot ; for ( int i = head [ x ]; i ; i = edge [ i ]. next ) { int y = edge [ i ]. to ; if ( ! dfn [ y ]) { tarjan ( y , i ); low [ x ] = min ( low [ x ], low [ y ]); if ( low [ y ] > dfn [ x ]) bridge [ i ] = bridge [ i ^ 1 ] = 1 ; ///\u6865 } else if ( i != ( in_edge ^ 1 )) low [ x ] = min ( low [ x ], dfn [ y ]); } } int main () { int n , m , from , to ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! dfn [ i ]) tarjan ( i , 0 ); } for ( int i = 2 ; i <= cnt ; i += 2 ) { if ( bridge [ i ]) { printf ( \"%d %d \\n \" , edge [ i ^ 1 ]. to , edge [ i ]. to ); } } } \u7f29\u70b9\u6c42\u5c06\u56fe\u8f6c\u53d8\u4e3a\u5f3a\u8fde\u901a\u56fe\u9700\u8981\u52a0\u8fb9\u7684\u6570\u76ee \u9898\u76ee\u6765\u6e90\uff1aPOJ 2767 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int to , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }, dfn [ 200500 ] = { 0 }, low [ 200500 ] = { 0 }; int stack1 [ 200500 ] = { 0 }, vis [ 200500 ] = { 0 }, color [ 200500 ] = { 0 }; bool in [ 200500 ] = { 0 }, out [ 200500 ] = { 0 }; int cnt = 0 , tot = 0 , top = 0 , color_num = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } void tarjan ( int now ) { stack1 [ ++ top ] = now ; vis [ now ] = 1 ; dfn [ now ] = low [ now ] = ++ tot ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int y = edge [ i ]. to ; if ( ! dfn [ y ]) { tarjan ( y ); low [ now ] = min ( low [ now ], low [ y ]); } else if ( vis [ y ]) low [ now ] = min ( low [ now ], dfn [ y ]); } if ( dfn [ now ] == low [ now ]) ///\u5f3a\u8fde\u901a\u5757 { color [ now ] = ++ color_num ; vis [ now ] = 0 ; while ( stack1 [ top ] != now ) { color [ stack1 [ top ]] = color_num ; vis [ stack1 [ top -- ]] = 0 ; } vis [ stack1 [ top ]] = 0 ; top -- ; } } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m , from , to ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n + 1 ; i ++ ) in [ i ] = out [ i ] = head [ i ] = dfn [ i ] = low [ i ] = stack1 [ i ] = vis [ i ] = color [ i ] = 0 ; cnt = 0 , tot = 0 , top = 0 , color_num = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); add_edge ( from , to ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! dfn [ i ]) tarjan ( i ); } if ( color_num == 1 ) { printf ( \"0 \\n \" ); continue ; } int in_num = color_num , out_num = color_num ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = head [ i ]; j ; j = edge [ j ]. next ) { int to = edge [ j ]. to ; if ( color [ to ] != color [ i ]) { if ( ! in [ color [ to ]]) { in_num -- ; in [ color [ to ]] = 1 ; } if ( ! out [ color [ i ]]) { out_num -- ; out [ color [ i ]] = 1 ; } } } } printf ( \"%d \\n \" , max ( out_num , in_num )); } } \u6c42\u5272\u70b9 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int to , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }, dfn [ 200500 ] = { 0 }, low [ 200500 ] = { 0 }, cut [ 200500 ] = { 0 }; int cnt = 0 , tot = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } void tarjan ( int now , int root ) { dfn [ now ] = low [ now ] = ++ tot ; int ct = 0 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int y = edge [ i ]. to ; ct ++ ; if ( ! dfn [ y ]) { tarjan ( y , root ); low [ now ] = min ( low [ now ], low [ y ]); if ( now != root && low [ y ] >= dfn [ now ]) cut [ now ] = 1 ; if ( now == root && ct > 1 ) cut [ now ] = 1 ; } else low [ now ] = min ( low [ now ], dfn [ y ]); } } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m , from , to ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n + 1 ; i ++ ) head [ i ] = dfn [ i ] = low [ i ] = cut [ i ] = 0 ; cnt = 0 , tot = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! dfn [ i ]) tarjan ( i , i ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( cut [ i ]) printf ( \"%d \" , i ); } printf ( \" \\n \" ); } } /* \u8f93\u5165\uff1a 1 7 7 1 2 1 5 5 6 5 7 2 3 2 4 3 4 \u5272\u70b9\u4e3a\uff1a 1 2 5 */ \u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811 \u00b6 https://oi-wiki.org/graph/hld/#_4 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll sum [ 400500 ] = { 0 }, lazy [ 400500 ] = { 0 }; ll dep [ 200500 ] = { 0 }, size1 [ 200500 ] = { 0 }, son [ 200500 ] = { 0 }, f [ 200500 ] = { 0 }, id [ 200500 ] = { 0 }, top [ 200500 ] = { 0 }; struct node { ll to , next ; }; node edge [ 400500 ] = { 0 }; ll head [ 400500 ] = { 0 }; ll num = 0 , cnt = 0 ; void add_edge ( ll from , ll to ) { edge [ ++ num ] = { to , head [ from ]}; head [ from ] = num ; } void dfs1 ( ll now , ll fa ) { size1 [ now ] = 1 ; for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == fa ) continue ; f [ to ] = now ; dep [ to ] = dep [ now ] + 1 ; dfs1 ( to , now ); size1 [ now ] += size1 [ to ]; if ( size1 [ to ] > size1 [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( ll now , ll fa ) { id [ now ] = ++ cnt ; top [ now ] = fa ; if ( son [ now ]) dfs2 ( son [ now ], fa ); for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == f [ now ] || to == son [ now ]) continue ; dfs2 ( to , to ); } } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t + 1 ] += lazy [ t ]; lazy [ 2 * t ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += ( mid - l + 1 ) * lazy [ t ]; sum [ 2 * t + 1 ] += ( r - mid ) * lazy [ t ]; lazy [ t ] = 0 ; } void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { lazy [ t ] += add ; sum [ t ] += add * ( R - L + 1 ); return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query ( ll t , ll l , ll r , ll L , ll R ) { if ( l <= L && R <= r ) return sum [ t ]; push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; ll ans = 0 ; if ( l <= mid ) ans += query ( 2 * t , l , r , L , mid ); if ( mid < r ) ans += query ( 2 * t + 1 , l , r , mid + 1 , R ); return ans ; } void update_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ]; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); update ( 1 , id [ fx ], id [ x ], 1 , cnt , 1 ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); update ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt , 1 ); } ll query_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ], ans = 0 ; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); ans += query ( 1 , id [ fx ], id [ x ], 1 , cnt ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); ans += query ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt ); return ans ; } int main () { ll n , m , from , to ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } f [ 1 ] = 0 , dep [ 1 ] = 1 ; dfs1 ( 1 , 0 ), dfs2 ( 1 , 1 ); char c [ 10 ]; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , c + 1 , & from , & to ); if ( c [ 1 ] == 'P' ) update_chain ( from , to ); else printf ( \"%lld \\n \" , query_chain ( from , to )); } } \u5206\u5c42\u6700\u77ed\u8def \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef pair < int , int > pii ; const int N = 100000 + 5 ; const int K = 10 + 5 ; const ll inf = 0x3f3f3f3f3f3f3f3f ; vector < pii > e [ N ]; struct Info { int pos , num ; ll val ; inline Info (){} inline Info ( int _pos , int _num , ll _val ) { pos = _pos , num = _num , val = _val ; } inline bool operator < ( const Info & b ) const { return val > b . val ; } }; ll f [ N ][ K ]; bool vis [ N ][ K ]; priority_queue < Info > q ; class TaskL { public : void solve ( std :: istream & in , std :: ostream & out ) { int T ; in >> T ; while ( T -- ) { int n , m , k ; in >> n >> m >> k ; while ( q . size ()) q . pop (); for ( int i = 1 ; i <= n ; ++ i ) { e [ i ]. clear (); for ( int j = 0 ; j <= k ; ++ j ) { f [ i ][ j ] = inf ; vis [ i ][ j ] = false ; } } for ( int i = 1 , x , y , z ; i <= m ; ++ i ) { in >> x >> y >> z ; e [ x ]. push_back ({ y , z }); } f [ 1 ][ 0 ] = 0 ; q . push ( Info ( 1 , 0 , 0 )); while ( q . size ()) { Info now = q . top (); q . pop (); if ( vis [ now . pos ][ now . num ] == true ) continue ; vis [ now . pos ][ now . num ] = true ; for ( int i = 0 ; i < e [ now . pos ]. size (); ++ i ) { int to = e [ now . pos ][ i ]. first , val = e [ now . pos ][ i ]. second ; if ( f [ to ][ now . num ] > f [ now . pos ][ now . num ] + val ) { f [ to ][ now . num ] = f [ now . pos ][ now . num ] + val ; q . push ( Info ( to , now . num , f [ to ][ now . num ])); } if ( now . num < k && f [ to ][ now . num + 1 ] > f [ now . pos ][ now . num ]) { f [ to ][ now . num + 1 ] = f [ now . pos ][ now . num ]; q . push ( Info ( to , now . num + 1 , f [ to ][ now . num + 1 ])); } } } ll ans = inf ; for ( int i = 0 ; i <= k ; ++ i ) { ans = min ( ans , f [ n ][ i ]); } out << ans << endl ; } } }; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); TaskL solver ; std :: istream & in ( std :: cin ); std :: ostream & out ( std :: cout ); solver . solve ( in , out ); return 0 ; } LCT \u52a8\u6001\u6811 \u00b6 \u53c2\u8003\u94fe\u63a5\uff1a https://www.luogu.com.cn/problem/P3690 https://www.cnblogs.com/zwfymqz/p/7896036.html#!comments https://www.cnblogs.com/zzy2005/p/10312977.html https://www.cnblogs.com/JeremyGJY/p/5921594.html https://blog.csdn.net/qq_36551189/article/details/79152612 #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll f [ 100500 ] = { 0 }, c [ 100500 ][ 2 ] = { 0 }, v [ 100500 ] = { 0 }, s [ 100500 ] = { 0 }, st [ 100500 ] = { 0 }; bool r [ 100500 ] = { 0 }; //\u5224\u65ad\u8282\u70b9\u662f\u5426\u4e3a\u4e00\u4e2aSplay\u7684\u6839 inline bool nroot ( register ll x ) { return c [ f [ x ]][ 0 ] == x || c [ f [ x ]][ 1 ] == x ; //\u539f\u7406\u4e3a\u5982\u679c\u8fde\u7684\u662f\u8f7b\u8fb9\uff0c\u4ed6\u7684\u7236\u4eb2\u7684\u513f\u5b50\u91cc\u6ca1\u6709\u5b83 } //\u4e0a\u4f20\u4fe1\u606f inline void pushup ( ll x ) { s [ x ] = s [ c [ x ][ 0 ]] ^ s [ c [ x ][ 1 ]] ^ v [ x ]; } //\u7ffb\u8f6c\u64cd\u4f5c inline void pushr ( register ll x ) { register ll t = c [ x ][ 0 ]; c [ x ][ 0 ] = c [ x ][ 1 ]; c [ x ][ 1 ] = t ; r [ x ] ^= 1 ; } //\u5224\u65ad\u5e76\u91ca\u653e\u61d2\u6807\u8bb0 inline void pushdown ( register ll x ) { if ( r [ x ]) { if ( c [ x ][ 0 ]) pushr ( c [ x ][ 0 ]); if ( c [ x ][ 1 ]) pushr ( c [ x ][ 1 ]); r [ x ] = 0 ; } } //\u4e00\u6b21\u65cb\u8f6c inline void rotate ( register ll x ) { register ll y = f [ x ], z = f [ y ], k = c [ y ][ 1 ] == x , w = c [ x ][ ! k ]; if ( nroot ( y )) c [ z ][ c [ z ][ 1 ] == y ] = x ; c [ x ][ ! k ] = y ; c [ y ][ k ] = w ; if ( w ) f [ w ] = y ; f [ y ] = x ; f [ x ] = z ; pushup ( y ); } //\u53ea\u4f20\u4e86\u4e00\u4e2a\u53c2\u6570\uff0c\u56e0\u4e3a\u6240\u6709\u64cd\u4f5c\u7684\u76ee\u6807\u90fd\u662f\u8be5Splay\u7684\u6839 inline void splay ( register ll x ) { register ll y = x , z = 0 ; st [ ++ z ] = y ; //st\u4e3a\u6808\uff0c\u6682\u5b58\u5f53\u524d\u70b9\u5230\u6839\u7684\u6574\u6761\u8def\u5f84\uff0cpushdown\u65f6\u4e00\u5b9a\u8981\u4ece\u4e0a\u5f80\u4e0b\u653e\u6807\u8bb0 while ( nroot ( y )) st [ ++ z ] = y = f [ y ]; while ( z ) pushdown ( st [ z -- ]); while ( nroot ( x )) { y = f [ x ]; z = f [ y ]; if ( nroot ( y )) rotate (( c [ y ][ 0 ] == x ) ^ ( c [ z ][ 0 ] == y ) ? x : y ); rotate ( x ); } pushup ( x ); } //\u8bbf\u95ee inline void access ( register ll x ) { for ( register ll y = 0 ; x ; x = f [ y = x ]) splay ( x ), c [ x ][ 1 ] = y , pushup ( x ); } //\u6362\u6839 inline void makeroot ( register ll x ) { access ( x ); splay ( x ); pushr ( x ); } //\u627e\u6839\uff08\u5728\u771f\u5b9e\u7684\u6811\u4e2d\u7684\uff09 inline ll findroot ( register ll x ) { access ( x ); splay ( x ); while ( c [ x ][ 0 ]) pushdown ( x ), x = c [ x ][ 0 ]; splay ( x ); return x ; } //\u63d0\u53d6\u8def\u5f84 inline void split ( register ll x , register ll y ) { makeroot ( x ); access ( y ); splay ( y ); } //\u8fde\u8fb9 inline void link ( register ll x , register ll y ) { makeroot ( x ); if ( findroot ( y ) != x ) f [ x ] = y ; } //\u65ad\u8fb9 void cut ( register ll x , register ll y ) { makeroot ( x ); if ( findroot ( y ) == x && f [ y ] == x && ! c [ y ][ 0 ]) { f [ y ] = c [ x ][ 1 ] = 0 ; pushup ( x ); } } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) //\u7ed9\u5b9a n \u4e2a\u70b9\u4ee5\u53ca\u6bcf\u4e2a\u70b9\u7684\u6743\u503c scanf ( \"%d\" , & v [ i ]); for ( int i = 1 ; i <= m ; i ++ ) { int opt , x , y ; scanf ( \"%d%d%d\" , & opt , & x , & y ); if ( opt == 0 ) //\u4ee3\u8868\u8be2\u95ee\u4ece x \u5230 y \u7684\u8def\u5f84\u4e0a\u7684\u70b9\u7684\u6743\u503c\u7684 xor \u548c\u3002\u4fdd\u8bc1 x \u5230 y \u662f\u8054\u901a\u7684\u3002 { split ( x , y ); printf ( \"%d \\n \" , s [ y ]); } else if ( opt == 1 ) //\u4ee3\u8868\u8fde\u63a5 x \u5230 y\uff0c\u82e5 x \u5230 y \u5df2\u7ecf\u8054\u901a\u5219\u65e0\u9700\u8fde\u63a5\u3002 { link ( x , y ); } else if ( opt == 2 ) //\u4ee3\u8868\u5220\u9664\u8fb9 (x,y)\uff0c\u4e0d\u4fdd\u8bc1\u8fb9 (x,y) \u5b58\u5728\u3002 { cut ( x , y ); } else if ( opt == 3 ) //\u4ee3\u8868\u5c06\u70b9 x \u4e0a\u7684\u6743\u503c\u53d8\u6210 y\u3002 { splay ( x ); v [ x ] = y ; } } } \u6570\u636e\u7ed3\u6784 \u00b6 \u6811\u72b6\u6570\u7ec4\u524d\u7f00\u548c \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n , m ; ll a [ 100500 ] = { 0 }; ll c [ 100500 ] = { 0 }; ll lowbit ( ll x ) { return x & ( - x ); } ll update ( ll k , ll x ) { for ( ll i = k ; i <= n ; i += lowbit ( i )) c [ i ] += x ; } ll sum1 ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c [ i ]; return ans ; } int main () { ll a1 , b1 , c1 ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld%lld\" , & a1 , & b1 , & c1 ); if ( a1 == 0 ) update ( b1 , c1 ); else printf ( \"%lld \\n \" , sum1 ( c1 ) - sum1 ( b1 -1 )); } } \u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u548c \u00b6 #include <stdio.h> using namespace std ; typedef long long ll ; ll num [ 100500 ] = { 0 }; ll lazy [ 800500 ] = { 0 }; ll sum [ 800500 ] = { 0 }; void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t ] += lazy [ t ]; lazy [ 2 * t + 1 ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += lazy [ t ] * ( mid - l + 1 ); sum [ 2 * t + 1 ] += lazy [ t ] * ( r - mid ); lazy [ t ] = 0 ; } void build ( ll t , ll l , ll r ) { if ( l == r ) { sum [ t ] = num [ l ]; return ; } ll mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); push_up ( t ); } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( l <= L && r >= R ) { sum [ t ] += add * ( R - L + 1 ); lazy [ t ] += add ; return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query_sum ( ll t , ll l , ll r , ll L , ll R ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( l <= L && r >= R ) { return sum [ t ]; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 , sum = 0 ; if ( l <= mid ) sum += query_sum ( 2 * t , l , r , L , mid ); if ( mid < r ) sum += query_sum ( 2 * t + 1 , l , r , mid + 1 , R ); return sum ; } int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & num [ i ]); build ( 1 , 1 , n ); char s [ 10 ]; ll l , r , x ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , s , & l , & r ); if ( s [ 0 ] == 'Q' ) { printf ( \"%lld \\n \" , query_sum ( 1 , l , r , 1 , n )); } else { scanf ( \"%lld\" , & x ); update ( 1 , l , r , 1 , n , x ); } } } \u5212\u5206\u6811\u6c42\u4e2d\u4f4d\u6570 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int tree [ 20 ][ 100500 ] = { 0 }; int to [ 20 ][ 100500 ] = { 0 }; int num [ 100500 ] = { 0 }; int sorted [ 100500 ] = { 0 }; int build ( int l , int r , int deep ) { if ( l == r ) return 0 ; int mid = ( l + r ) / 2 ; int midd = sorted [ mid ]; int suppose = mid - l + 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( tree [ deep ][ i ] < midd ) suppose -- ; } int sleft = l , sright = mid + 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( i == l ) to [ deep ][ l ] = 0 ; else to [ deep ][ i ] = to [ deep ][ i -1 ]; if ( tree [ deep ][ i ] < midd ) { to [ deep ][ i ] ++ ; tree [ deep + 1 ][ sleft ++ ] = tree [ deep ][ i ]; } else if ( tree [ deep ][ i ] == midd && suppose > 0 ) { suppose -- ; to [ deep ][ i ] ++ ; tree [ deep + 1 ][ sleft ++ ] = tree [ deep ][ i ]; } else { tree [ deep + 1 ][ sright ++ ] = tree [ deep ][ i ]; } } build ( l , mid , deep + 1 ); build ( mid + 1 , r , deep + 1 ); } int query ( int l , int r , int L , int R , int k , int deep ) { if ( L == R ) return tree [ deep ][ L ]; int mid = ( l + r ) / 2 ; int lef ; int toleft ; if ( l == L ) lef = 0 , toleft = to [ deep ][ R ]; else lef = to [ deep ][ L -1 ], toleft = to [ deep ][ R ] - lef ; if ( k <= toleft ) { return query ( l , mid , l + lef , l + toleft + lef -1 , k , deep + 1 ); } else { return query ( mid + 1 , r , mid + L - l - lef + 1 , mid + R - l - toleft - lef + 1 , k - toleft , deep + 1 ); } } int main () { int n , m , summ = 0 ; while ( scanf ( \"%d\" , & n ) != EOF ) { summ ++ ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & num [ i ]); sorted [ i ] = num [ i ]; tree [ 0 ][ i ] = num [ i ]; } sort ( sorted + 1 , sorted + n + 1 ); build ( 1 , n , 0 ); printf ( \"Case %d: \\n \" , summ ); scanf ( \"%d\" , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int a , b , c ; /// a,b,c\u4ee3\u8868\u67e5\u8be2a\u5230b\u533a\u95f4\u5185\u7b2cc\u5927\u7684\u6570 scanf ( \"%d%d\" , & a , & b ); c = ( b - a ) / 2 + 1 ; printf ( \"%d \\n \" , query ( 1 , n , a , b , c , 0 )); } } } \u5355\u8c03\u6808 \u00b6 \u5355\u8c03\u6808 \u662f\u5728\u6808\u7684**\u5148\u8fdb\u540e\u51fa**\u57fa\u7840\u4e4b\u4e0a\u989d\u5916\u6dfb\u52a0\u4e00\u4e2a\u7279\u6027\uff1a**\u4ece\u6808\u9876\u5230\u6808\u5e95**\u7684\u5143\u7d20\u662f\u4e25\u683c\u9012\u589e\u6216\u9012\u51cf\u3002 \u4e3a\u4e86\u7ef4\u62a4\u6808\u7684\u5355\u8c03\u6027\uff0c\u5728\u8fdb\u6808\u8fc7\u7a0b\u4e2d\u9700\u8981\u8fdb\u884c\u5224\u65ad\uff0c\u5177\u4f53\u8fdb\u6808\u8fc7\u7a0b\u5982\u4e0b\uff1a\u5047\u8bbe\u5f53\u524d\u8fdb\u6808\u5143\u7d20\u4e3a e\uff0c \u5bf9\u4e8e\u5355\u8c03\u9012\u589e\u6808\uff0c\u4ece\u6808\u9876\u5f00\u59cb\u904d\u5386\u5143\u7d20\uff0c\u628a\u5c0f\u4e8e e \u6216\u8005\u7b49\u4e8e e \u7684\u5143\u7d20\u5f39\u51fa\u6808\uff0c\u76f4\u81f3\u9047\u89c1\u4e00\u4e2a\u5927\u4e8e e \u7684\u5143\u7d20\u6216\u8005\u6808\u4e3a\u7a7a\u4e3a\u6b62\uff0c\u7136\u540e\u518d\u628a e \u538b\u5165\u6808\u4e2d\uff0c\u8fd9\u6837\u5c31\u80fd\u6ee1\u8db3\u4ece\u6808\u9876\u5230\u6808\u5e95\u7684\u5143\u7d20\u662f\u9012\u589e\u7684 \u5bf9\u4e8e\u5355\u8c03\u9012\u51cf\u6808\uff0c\u5219\u6bcf\u6b21\u5f39\u51fa\u7684\u662f\u5927\u4e8e e \u6216\u8005\u7b49\u4e8e e \u7684\u5143\u7d20\uff0c\u76f4\u81f3\u9047\u89c1\u4e00\u4e2a\u5c0f\u4e8ee\u7684\u5143\u7d20\u6216\u8005\u6808\u4e3a\u7a7a\u4e3a\u6b62 \u5355\u8c03\u6808\u7684\u4f5c\u7528\u5728\u4e8e \u5355\u8c03\u9012\u589e\u6808\u4ece\u6808\u9876\u5230\u6808\u5e95\u662f\u9012\u589e\u7684\uff0c\u6808\u4e2d\u4fdd\u7559\u7684\u90fd\u662f\u6bd4\u5f53\u524d\u5165\u6808\u5143\u7d20\u5927\u7684\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5feb\u901f\u627e\u5230\u5165\u6808\u5143\u7d20\u5de6\u8fb9\u6bd4\u4ed6\u5927\u7684\u5143\u7d20 \u5355\u8c03\u9012\u51cf\u6808\u4ece\u6808\u9876\u5230\u6808\u5e95\u662f\u9012\u51cf\u7684\uff0c\u6808\u4e2d\u4fdd\u7559\u7684\u90fd\u662f\u6bd4\u5f53\u524d\u5165\u6808\u5143\u7d20\u5c0f\u7684\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5feb\u901f\u627e\u5230\u5165\u6808\u5143\u7d20\u5de6\u8fb9\u6bd4\u4ed6\u5c0f\u7684\u5143\u7d20 \u5355\u8c03\u6808\u6c42\u533a\u95f4\u957f\u5ea6\u548c\u533a\u95f4\u6700\u5c0f\u503c\u4e58\u79ef\u6700\u5927\u503c\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll pos , val ; }; node s [ 2005000 ] = { 0 }; ll a [ 2005000 ] = { 0 }; int main () { ll n , top = 0 , ans = 0 ; scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); for ( int j = 1 ; j <= n + 1 ; j ++ ) { if ( top == 0 ) { s [ ++ top ] = { j , a [ j ]}; } else { while ( s [ top ]. val > a [ j ]) ///\u9012\u589e\u6808 { ll tmp = ( j - s [ top - 1 ]. pos - 1 ) * s [ top ]. val ; ans = max ( ans , tmp ); top -- ; } s [ ++ top ] = { j , a [ j ]}; } } printf ( \"%lld \\n \" , ans ); return 0 ; } \u7ebf\u6027\u57fa \u00b6 \u7ebf\u6027\u57fa\u6c42\u4ea4\uff0c\u53c2\u8003\u4e0e\uff1a https://blog.csdn.net/qcwlmqy/article/details/97584411 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; const int maxn = 50500 ; typedef long long ll ; class Bit_Set { public : ll d [ 32 ]; Bit_Set () { memset ( d , 0 , sizeof ( d )); } Bit_Set ( const Bit_Set & t ) { for ( int i = 0 ; i <= 31 ; i ++ ) d [ i ] = t . d [ i ]; } void clear () { memset ( d , 0 , sizeof ( d )); } void insert ( ll x ) { for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( ll ( 1 ) << i )) { if ( ! d [ i ]) { d [ i ] = x ; return ; } x ^= d [ i ]; } } } bool check ( ll x ) { for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( ll ( 1 ) << i )) { if ( ! d [ i ]) return false ; x ^= d [ i ]; } } return true ; } void show () { for ( int i = 0 ; i <= 31 ; i ++ ) cout << i << ' ' << d [ i ] << endl ; } friend Bit_Set operator + ( const Bit_Set & a , const Bit_Set & b ) { Bit_Set a_b ( a ), c , res ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( b . d [ i ]) { ll x = b . d [ i ], k = ll ( 1 ) << i ; bool flag = true ; for ( int j = 31 ; j >= 0 ; j -- ) { if ( x & ( ll ( 1 ) << j )) { if ( a_b . d [ j ]) { x ^= a_b . d [ j ]; k ^= c . d [ j ]; //\u5c06\u7528\u4e0a\u7684b\u5143\u7d20\u8ba1\u5165k } else { flag = false ; //\u82e5\u4e0d\u80fd\u88aba_b\u8868\u793a\uff0c\u5c06b[i]\u52a0\u5165\u6570\u7ec4 a_b . d [ j ] = x ; c . d [ j ] ^= k ; //\u5c06a_b\u4e2db\u5143\u7d20\u6807\u8bb0 break ; } } } if ( flag ) { ll x = 0 ; for ( int j = 31 ; j >= 0 ; j -- ) { if ( k & ( ll ( 1 ) << j )) x ^= b . d [ j ]; //\u5c06\u7528\u4e0a\u7684b\u5143\u7d20\u548c\u672c\u8eab\u7684b[i]\u5f02\u6216\u5728\u4e00\u8d77\uff0c //\u7531(a[argv---]^b[argv---]^b[i]==0),\u6240\u5f97\u5373\u4e3aV1\u7684\u8d21\u732e } res . insert ( x ); } } } return res ; } }; Bit_Set tree [ maxn << 2 ]; void build ( ll t , ll l , ll r ) { if ( l == r ) { int k ; ll x ; scanf ( \"%d\" , & k ); while ( k -- ) { scanf ( \"%lld\" , & x ); tree [ t ]. insert ( x ); } return ; } int mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); tree [ t ] = tree [ 2 * t ] + tree [ 2 * t + 1 ]; } int query ( ll t , ll l , ll r , ll L , ll R , ll x ) { if ( l <= L && R <= r ) { return tree [ t ]. check ( x ); } int flag = 1 ; int mid = ( L + R ) / 2 ; if ( l <= mid ) flag &= query ( 2 * t , l , r , L , mid , x ); if ( r > mid ) flag &= query ( 2 * t + 1 , l , r , mid + 1 , R , x ); return flag ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); build ( 1 , 1 , n ); while ( m -- ) { int l , r , x ; scanf ( \"%d%d%d\" , & l , & r , & x ); if ( query ( 1 , l , r , 1 , n , x )) puts ( \"YES\" ); else puts ( \"NO\" ); } } \u7ebf\u6027\u57fa\u57fa\u7840 \u6027\u8d28 \u5bf9\u4e8e\u4e00\u4e2a\u6570\u7ec4\uff0c\u5b58\u5728\u4e00\u4e9b\u6570\u6784\u6210\u8be5\u6570\u7ec4\u7684\u7ebf\u6027\u57fa \u7ebf\u6027\u57fa\u6709\u4e09\u5927\u5f88\u4f18\u7f8e\u7684\u6027\u8d28 \u6570\u7ec4\u4e2d\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531\u7ebf\u6027\u57fa\u4e2d\u90e8\u5206\u6570\u5f02\u6216\u5f97\u5230 \u6570\u7ec4\u4e2d\u6240\u6709\u6570\u5f02\u6216\u51fa\u6765\u5747\u4e0d\u4e3a0 \u5bf9\u4e8e\u540c\u4e00\u6570\u7ec4\u7ebf\u6027\u57fa\u4e2a\u6570\u552f\u4e00 \u4f8b\u5982 2 \uff0c4 \uff0c 5 \uff0c 6 ,\u7531\u7ebf\u6027\u57fa ,\u7531\u7ebf\u6027\u57fa 1 , 2 , 4 1 , 2 , 4 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 1,2,41,2,4 2 \uff0c4 \uff0c 5 \uff0c 6 <span class=\"arithmatex\"><span class=\"MathJax_Preview\">,\u7531\u7ebf\u6027\u57fa</span><script type=\"math/tex\">,\u7531\u7ebf\u6027\u57fa 1 , 2 , 4 1 , 2 , 4 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 1,2,41,2,4 \u5f02\u6216\u5f97\u5230 \u7ebf\u6027\u57fa\u6784\u9020 \u6570\u7ec4\u6bcf\u52a0\u5165\u4e00\u4e2a\u6570\uff0c\u5bf9\u7ebf\u6027\u57fa\u8fdb\u884c\u4fee\u6539 \u4ee4\u7ebf\u6027\u57fa\u4e3ad[32] ,\u6570\u7ec4\u957f\u5ea6\u4e3amax(a[i])\u7684\u6700\u5927\u4e8c\u8fdb\u5236\uff08\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531$ 1 , 2 , 4 \u22ef ,2^n$ \u8868\u793a\uff09 void add ( int x ) { for ( int i = 31 ; i >= 0 ; i -- ) { //i\u4e3a\u7ebf\u6027\u57fa\u4e0b\u6807 if ( x & ( 1 << i )) { if ( d [ i ]) x ^= d [ i ]; //\u82e5\u8be5\u4e8c\u8fdb\u5236\u4f4d\u5df2\u6709\u503c\uff0c\u5f02\u6216\u5bfb\u627e\u7ebf\u6027\u57fa\u80fd\u5426\u8868\u8fbex^d[i] else { d [ i ] = x ; //\u82e5\u4e8c\u8fdb\u5236\u4f4d\u6ca1\u6709\u503c\uff0c\u8bf4\u660ex\u4e0d\u80fd\u88ab\u7ebf\u6027\u57fa\u8868\u8fbe\uff0c\u4ee4d[i]=x break ; //\u8bb0\u5f97\u5982\u679c\u63d2\u5165\u6210\u529f\u4e00\u5b9a\u8981\u9000\u51fa } } } } \u6784\u9020\u5408\u7406\u6027\uff1a \u82e5\u80fd\u63d2\u5165x \uff0c\u5219\u5c06d[i] =x\uff0cx\u53ef\u4ee5\u7531\u7ebf\u6027\u57fa\u8868\u8fbe \u82e5\u4e0d\u80fd\u63d2\u5165x\uff0c\u5219x\u6700\u7ec8\u5f02\u6216\u4e3a0\uff0c\u5373\u53ef\u4ee5\u7531\u7ebf\u6027\u57fa\u8868\u8fbe \u533a\u95f4\u5f02\u6216\u6700\u5927\u503c \u6570\u7ec4 ( L , R ) ( L , R ) \u5185\u53d6\u82e5\u5e72\u4e2a\u6570\uff0c\u4f7f\u8fd9\u4e9b\u6570\u5f02\u6216\u540e\u5f97\u5230\u7684\u503c\u6700\u5927 \u4ee4 d [ 32 ] \u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c \u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c p [ 32 ]p [ 32 ] d [ 32 ] <span class=\"arithmatex\"><span class=\"MathJax_Preview\">\u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c</span><script type=\"math/tex\">\u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c p [ 32 ]p [ 32 ] \u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u4f4d\u7f6e\uff08\u4e3a\u4e86\u4fbf\u4e8e\u8be2\u95ee\uff0c\u4f4d\u7f6e\u5c3d\u91cf\u5b58\u504f\u53f3\u7684\uff09 int ask ( int l , int r ){ int res = 0 ; for \uff08 int i = 31 ; i >= 0 ; i -- \uff09 if ( p [ i ] >= l && ( res ^ d [ i ]) > res ) res ^= d [ i ]; return res ; } \u8d2a\u5fc3\uff1a\u9ad8\u4f4d\u80fd\u53d8\u62101\uff0c\u5c31\u53d8\u62101\uff08\u9ad8\u4f4d1\u6bd4\u4f4e\u4f4d\u90fd\u53d8\u62101\u90fd\u6709\u4ef7\u503c\uff09 \u533a\u95f4\u5f02\u6216\u7b2ck\u5927 \u5148\u5c06\u7ebf\u6027\u57fa\u5904\u7406\u6210$ 1 , 2 , 4 , \u22ef ,2^n$ \u7684\u4e8c\u8fdb\u5236\u8868\u8fbe\u5f62\u5f0f \u53bb\u9664\u4e3a0\u7684\u5f02\u6216\u503c\uff0c\u6bcf\u4e00\u4f4dd[i] =1 \u76f8\u5f53\u4e8e\u53ef\u4ee5\u8868\u8fbe\u7684\u4e8c\u8fdb\u5236\u4f4d\u6570\u589e\u52a0\u4e00\u4f4d void work () { //\u5c06\u7ebf\u6027\u57fa\u8f6c\u5316\u4e3a2\u8fdb\u5236 for ( int i = 1 ; i <= 31 ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) if ( d [ i ] & ( 1 << ( j -1 ))) d [ i ] ^= d [ j -1 ]; } int k_th ( int k ) { if ( k == 1 && tot < n ) return 0 ; //\u7279\u5224\u4e00\u4e0b\uff0c\u5047\u5982k=1\uff0c\u5e76\u4e14\u539f\u6765\u7684\u5e8f\u5217\u53ef\u4ee5\u5f02\u6216\u51fa0\uff0c\u5c31\u8981\u8fd4\u56de0\uff0c //tot\u8868\u793a\u7ebf\u6027\u57fa\u4e2d\u7684\u5143\u7d20\u4e2a\u6570\uff0cn\u8868\u793a\u5e8f\u5217\u957f\u5ea6 if ( tot < n ) k -- ; //\u7c7b\u4f3c\u4e0a\u9762\uff0c\u53bb\u63890\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a\u7ebf\u6027\u57fa\u4e2d\u53ea\u80fd\u5f02\u6216\u51fa\u4e0d\u4e3a0\u7684\u89e3 work (); int ans = 0 ; for ( int i = 0 ; i <= 31 ; i ++ ) if ( d [ i ] != 0 ) { if ( k & 1 ) ans ^= d [ i ]; k >>= 1 ; } } \u4e3b\u5e2d\u6811 \u00b6 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/zuzhiang/article/details/78173412 https://www.cnblogs.com/s1124yy/p/6258026.html https://blog.csdn.net/tianwei0822/article/details/79439054 \u4e3b\u5e2d\u6811\u7ef4\u62a4\u533a\u95f4\u7b2ck\u5927\u6570 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; int L [ 3200500 ] = { 0 }, R [ 3200500 ] = { 0 }, sum [ 3200500 ] = { 0 }; int tot = 0 ; int a [ 3200500 ] = { 0 }, hash1 [ 3200500 ] = { 0 }, T [ 3200500 ] = { 0 }; int build ( int l , int r ) { int root = ++ tot ; sum [ root ] = 0 ; if ( l < r ) { int mid = ( l + r ) / 2 ; L [ root ] = build ( l , mid ); R [ root ] = build ( mid + 1 , r ); } return root ; } int update ( int pre , int l , int r , int pos ) { int root = ++ tot ; L [ root ] = L [ pre ]; R [ root ] = R [ pre ]; sum [ root ] = sum [ pre ] + 1 ; if ( l < r ) { int mid = ( l + r ) / 2 ; if ( pos <= mid ) L [ root ] = update ( L [ pre ], l , mid , pos ); else R [ root ] = update ( R [ pre ], mid + 1 , r , pos ); } return root ; } int query ( int l1 , int r1 , int l , int r , int k ) //\u53c2\u6570\u5206\u522b\u4e3a\uff1a\u4e24\u9897\u7ebf\u6bb5\u6811\u6839\u8282\u70b9\u7684\u7f16\u53f7\uff0c\u5de6\u53f3\u7aef\u70b9\uff0c\u7b2ck\u5927 { if ( l >= r ) return l ; int mid = ( l + r ) / 2 ; int num = sum [ L [ r1 ]] - sum [ L [ l1 ]]; if ( num >= k ) return query ( L [ l1 ], L [ r1 ], l , mid , k ); else return query ( R [ l1 ], R [ r1 ], mid + 1 , r , k - num ); } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { tot = 0 ; int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]), hash1 [ i ] = a [ i ]; sort ( hash1 + 1 , hash1 + n + 1 ); int d = unique ( hash1 + 1 , hash1 + n + 1 ) - hash1 - 1 ; T [ 0 ] = build ( 1 , d ); for ( int i = 1 ; i <= n ; i ++ ) { int pos = lower_bound ( hash1 + 1 , hash1 + d + 1 , a [ i ]) - hash1 ; T [ i ] = update ( T [ i - 1 ], 1 , d , pos ); } for ( int i = 1 ; i <= m ; i ++ ) { int l , r , k ; scanf ( \"%d%d%d\" , & l , & r , & k ); int pos = query ( T [ l - 1 ], T [ r ], 1 , d , k ); printf ( \"%d \\n \" , hash1 [ pos ]); } } } \u67e5\u8be2\u533a\u95f4\u5185\u5c0f\u4e8e\u7b49\u4e8e\u7ed9\u5b9a\u7684K\u7684\u6570\u7684\u4e2a\u6570 \u9898\u76ee\u94fe\u63a5\uff1a https://acm.hdu.edu.cn/showproblem.php?pid=4417 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; int L [ 3200500 ] = { 0 }, R [ 3200500 ] = { 0 }, sum [ 3200500 ] = { 0 }; int tot = 0 ; int a [ 3200500 ] = { 0 }, hash1 [ 3200500 ] = { 0 }, T [ 3200500 ] = { 0 }; int build ( int l , int r ) { int root = ++ tot ; sum [ root ] = 0 ; if ( l < r ) { int mid = ( l + r ) / 2 ; L [ root ] = build ( l , mid ); R [ root ] = build ( mid + 1 , r ); } return root ; } int update ( int pre , int l , int r , int pos ) { int root = ++ tot ; L [ root ] = L [ pre ]; R [ root ] = R [ pre ]; sum [ root ] = sum [ pre ] + 1 ; if ( l < r ) { int mid = ( l + r ) / 2 ; if ( pos <= mid ) L [ root ] = update ( L [ pre ], l , mid , pos ); else R [ root ] = update ( R [ pre ], mid + 1 , r , pos ); } return root ; } int query ( int l1 , int r1 , int l , int r , int k ) { if ( k < hash1 [ l ]) return 0 ; if ( hash1 [ r ] <= k ) return sum [ r1 ] - sum [ l1 ]; int mid = ( l + r ) / 2 ; if ( k <= hash1 [ mid ]) { return query ( L [ l1 ], L [ r1 ], l , mid , k ); } else { int num = 0 ; num += sum [ L [ r1 ]] - sum [ L [ l1 ]]; num += query ( R [ l1 ], R [ r1 ], mid + 1 , r , k ); return num ; } } int main () { int t ; scanf ( \"%d\" , & t ); for ( int t1 = 1 ; t1 <= t ; t1 ++ ) { tot = 0 ; int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]), hash1 [ i ] = a [ i ]; sort ( hash1 + 1 , hash1 + n + 1 ); int d = unique ( hash1 + 1 , hash1 + n + 1 ) - hash1 - 1 ; T [ 0 ] = build ( 1 , d ); for ( int i = 1 ; i <= n ; i ++ ) { int pos = lower_bound ( hash1 + 1 , hash1 + d + 1 , a [ i ]) - hash1 ; T [ i ] = update ( T [ i - 1 ], 1 , d , pos ); } printf ( \"Case %d: \\n \" , t1 ); for ( int i = 1 ; i <= m ; i ++ ) { int l , r , k ; scanf ( \"%d%d%d\" , & l , & r , & k ); int ans = query ( T [ l ], T [ r + 1 ], 1 , d , k ); printf ( \"%d \\n \" , ans ); } } } \u5b57\u7b26\u4e32 \u00b6 KMP\u7b97\u6cd5 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; const ll N = 1005000 ; ll Next [ N ]; char s [ N ]; char t [ N ]; ll tlen , len ; void getNext ( char s [ N ]) { ll j = 0 , k = -1 ; Next [ 0 ] = -1 ; while ( j < tlen ) { if ( k == -1 || s [ j ] == s [ k ]) { Next [ ++ j ] =++ k ; } else k = Next [ k ]; } } int main () { while ( 1 ) { scanf ( \"%s\" , s ); if ( s [ 0 ] == '.' ) break ; tlen = strlen ( s ); len = tlen ; getNext ( s ); ll kk = tlen - Next [ tlen ]; if ( strlen ( s ) % kk == 0 ) { printf ( \"%d \\n \" , strlen ( s ) / kk ); } else { printf ( \"1 \\n \" ); //\u5982\u679c\u4e0d\u80fd\u9664\u5c3d\uff0c\u8bf4\u660e\u6709\u540e\u7f00\uff0c\u4f8b\u5982abababa\uff0c\u8fd9\u79cd\u60c5\u51b5\u53ea\u80fd\u4e3a1 } } return 0 ; } \u5b57\u7b26\u4e32\u54c8\u5e0c \u00b6 \u7ed9\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u5b57\u7b26\u4e32(1<=n<=200000),\u4ed6\u53ea\u5305\u542b**\u5c0f\u5199**\u5b57\u6bcd \u627e\u5230\u8fd9\u4e2a\u5b57\u7b26\u4e32\u591a\u5c11\u4e2a\u524d\u7f00\u662fM\u5f62\u5b57\u7b26\u4e32. M\u5f62\u5b57\u7b26\u4e32\u5b9a\u4e49\u5982\u4e0b: \u4ed6\u7531\u4e24\u4e2a\u76f8\u540c\u7684\u56de\u6587\u4e32\u62fc\u63a5\u800c\u6765,\u7b2c\u4e00\u4e2a\u56de\u6587\u4e32\u7684\u7ed3\u5c3e\u5b57\u7b26\u548c\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u4e32\u7684\u5f00\u59cb\u5b57\u7b26\u53ef\u4ee5\u91cd\u53e0,\u4e5f\u5c31\u662f\u4ee5\u4e0b\u90fd\u662fM \u5f62\u5b57\u7b26\u4e32. abccbaabccba(\u7531abccba+abccba\u7ec4\u6210) abcbaabcba(\u6709abcba+abcba\u7ec4\u6210) abccbabccba(\u7531abccba+abccba\u7ec4\u6210\u7ec4\u6210,\u4f46\u662f\u4e2d\u95f4\u76841\u662f\u5171\u7528\u7684) a(\u4e00\u4e2a\u5355\u72ec\u5b57\u7b26\u4e5f\u7b97) #include <bits/stdc++.h> using namespace std ; typedef unsigned long long int ULL ; const int N = 200010 ; int P = 131 ; ULL p [ N ], h [ N ], ed [ N ]; int ask1 ( int l , int r ) { return h [ r ] - h [ l - 1 ] * p [ r - l + 1 ]; } int ask2 ( int l , int r ) { return ed [ l ] - ed [ r + 1 ] * p [ r - l + 1 ]; } int main () { int ans = 0 ; char str [ N ]; cin >> str + 1 ; int n = strlen ( str + 1 ); p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { h [ i ] = h [ i - 1 ] * P + str [ i ]; p [ i ] = p [ i - 1 ] * P ; } for ( int i = n ; i >= 0 ; i -- ) { ed [ i ] = ed [ i + 1 ] * P + str [ i ]; } for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) { int x = ( i + 1 ) / 2 ; if ( ask1 ( 1 , x ) == ask1 ( x , i ) && ask1 ( 1 , x ) == ask2 ( 1 , x )) ans ++ ; } else { int x = i / 2 ; if ( ask1 ( 1 , x ) == ask1 ( x + 1 , i ) && ask1 ( 1 , x ) == ask2 ( 1 , x )) ans ++ ; } } cout << ans ; } \u56de\u6587\u4e32\u5339\u914d\u7b97\u6cd5\uff08\u9a6c\u62c9\u8f66\u7b97\u6cd5\uff09 \u00b6 #include <bits/stdc++.h> ///\u6c42\u89e3\u6700\u957f\u56de\u6587\u4e32\uff0c\u5bf9p[i]/2\u6c42\u548c\u5373\u53ef\u5f97\u56de\u6587\u4e32\u4e2a\u6570 using namespace std ; typedef long long ll ; char a [ 500500 ] = { 0 }; int l [ 500500 ] = { 0 }; int r [ 500500 ] = { 0 }; string str = \"$#\" ; vector < int > p ; void manacher ( char * c ) { int max_id = 0 , id = 0 ; for ( int i = 1 ; c [ i ]; i ++ ) str += c [ i ], str += \"#\" ; p . push_back ( 1 ); for ( int i = 1 ; i < ( int ) str . size (); i ++ ) { if ( max_id > i ) p . push_back ( min ( max_id - i , p [ 2 * id - i ])); else p . push_back ( 1 ); while ( i + p [ i ] < ( int ) str . size () && str [ i + p [ i ]] == str [ i - p [ i ]]) p [ i ] ++ ; if ( i + p [ i ] > max_id ){ max_id = i + p [ i ], id = i ; } } } int main () { scanf ( \"%s\" , a + 1 ); manacher ( a ); int now = 0 , n = str . size (), ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , p [ i ] -1 ); printf ( \"%d\" , ans ); } \u5b57\u5178\u6811 \u00b6 \u4ece\u4e00\u7ec4\u6570\u636e\u4e2d\u9009\u53d6\u4e24\u4e2a\u6570\u6c42\u6700\u5927\u5f02\u6216\u503c\u3002 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 1005000 ] = { 0 }; int tree [ 5000500 ][ 3 ] = { 0 }; int tot = 1 ; ///\u5fc5\u987b\u4ece1\u5f00\u59cb int in ( int x ) { int p = 1 ; for ( int i = 30 ; i >= 0 ; i -- ) { int k = x >> i & 1 ; if ( tree [ p ][ k ] == 0 ) tree [ p ][ k ] =++ tot ; p = tree [ p ][ k ]; } } int out ( int x ) { int p = 1 , ans = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { int k = x >> i & 1 ; if ( tree [ p ][ ! k ]) { ans = ans * 2 +! k ; p = tree [ p ][ ! k ]; } else { ans = ans * 2 + k ; p = tree [ p ][ k ]; } } return ans ; } int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { in ( a [ i ]); int num = out ( a [ i ]); max1 = max ( max1 , num ^ a [ i ]); } cout << max1 << endl ; return 0 ; } \u6587\u6cd5\u5206\u6790 \u00b6 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/qq_40736036/article/details/89110584 #include <bits/stdc++.h> using namespace std ; typedef unsigned long long ull ; typedef long long ll ; const ll mod = 10000 ; char c [ 5000500 ] = { 0 }; struct grammer { pair < char * , ll > Q ( char * p ) { pair < char * , ll > ans1 = E ( p ); if ( ans1 . first == NULL ) return { NULL , 0 }; ans1 . second %= mod ; return ans1 ; } pair < char * , ll > E ( char * p ) { pair < char * , ll > ans1 = T ( p ); if ( ans1 . first == NULL ) return { NULL , 0 }; while ( * ans1 . first == '+' || * ans1 . first == '-' ) { pair < char * , ll > ans2 = T ( ans1 . first + 1 ); if ( ans2 . first == NULL ) return { NULL , 0 }; if ( * ans1 . first == '+' ) ans1 . second += ans2 . second ; else if ( * ans1 . first == '-' ) ans1 . second -= ans2 . second ; ans1 . second = ( ans1 . second % mod + mod ) % mod ; ans1 . first = ans2 . first ; } return ans1 ; } pair < char * , ll > T ( char * p ) { pair < char * , ll > ans1 = F ( p ); if ( ans1 . first == NULL ) return { NULL , 0 }; while ( * ans1 . first == '*' ) { pair < char * , ll > ans2 = F ( ans1 . first + 1 ); if ( ans2 . first == NULL ) return { NULL , 0 }; ans1 . second *= ans2 . second ; ans1 . second %= mod ; ans1 . first = ans2 . first ; } return ans1 ; } pair < char * , ll > F ( char * p ) { if ( * p >= '0' || * p <= '9' ) { return N ( p ); } else if ( * p == '-' ) { pair < char * , ll > ans1 = F ( p + 1 ); if ( ans1 . first == NULL ) return { NULL , 0 }; return { ans1 . first , ( - ans1 . second % mod + mod ) % mod }; } else if ( * p == '(' ) { pair < char * , ll > ans1 = E ( p + 1 ); if ( ans1 . first == NULL ) return { NULL , 0 }; if ( * ans1 . first == ')' ) return { ans1 . first + 1 , ans1 . second % mod }; else return { NULL , 0 }; } else { return { NULL , 0 }; } } pair < char * , ll > N ( char * p ) { if ( * p == '0' ) { // if (*(p + 1) >= '0' || *(p + 1) <= '9') // return {NULL, 0}; // else return { p + 1 , 0 }; } else if ( * p >= '1' && * p <= '9' ) { pair < char * , ll > ans1 = B ( p ); if ( ans1 . first == NULL ) { return { NULL , 0 }; } return { ans1 . first , ans1 . second % mod }; } else { return { NULL , 0 }; } } pair < char * , ll > B ( char * p ) { ll sum = 0 ; while ( * p >= '0' && * p <= '9' ) { sum = sum * 10 + * p - '0' ; p ++ ; sum %= mod ; } return { p , sum % mod }; } } Grammer ; int main () { scanf ( \"%s\" , c + 1 ); ll ans = ( Grammer . Q ( c + 1 ). second % mod + mod ) % mod ; printf ( \"%lld \\n \" , ans ); } AC\u81ea\u52a8\u673a \u00b6 \u53c2\u8003\u94fe\u63a5\uff1a https://www.cnblogs.com/nullzx/p/7499397.html https://zhuanlan.zhihu.com/p/80325757 https://oi-wiki.org/string/ac-automaton/ AC\u81ea\u52a8\u673a\u6a21\u677f\uff1a \u7ed9\u5b9a n n \u4e2a\u6a21\u5f0f\u4e32 s_i s_i \u548c\u4e00\u4e2a\u6587\u672c\u4e32 t t \uff0c\u6c42\u6709\u591a\u5c11\u4e2a\u4e0d\u540c\u7684\u6a21\u5f0f\u4e32\u5728\u6587\u672c\u4e32\u91cc\u51fa\u73b0\u8fc7\u3002 \u4e24\u4e2a\u6a21\u5f0f\u4e32\u4e0d\u540c\u5f53\u4e14\u4ec5\u5f53\u4ed6\u4eec**\u7f16\u53f7**\u4e0d\u540c\u3002 #include <bits/stdc++.h> using namespace std ; const int N = 1e6 + 6 ; int n ; namespace AC { int tr [ N ][ 26 ], tot ; int e [ N ], fail [ N ]; void insert ( char * s ) { int u = 0 ; for ( int i = 1 ; s [ i ]; i ++ ) { if ( ! tr [ u ][ s [ i ] - 'a' ]) tr [ u ][ s [ i ] - 'a' ] = ++ tot ; //\u5982\u679c\u6ca1\u6709\u5219\u63d2\u5165\u65b0\u8282\u70b9 u = tr [ u ][ s [ i ] - 'a' ]; //\u641c\u7d22\u4e0b\u4e00\u4e2a\u8282\u70b9 } e [ u ] ++ ; //\u5c3e\u4e3a\u8282\u70b9 u \u7684\u4e32\u7684\u4e2a\u6570 } queue < int > q ; void build () { for ( int i = 0 ; i < 26 ; i ++ ) if ( tr [ 0 ][ i ]) q . push ( tr [ 0 ][ i ]); while ( q . size ()) { int u = q . front (); q . pop (); for ( int i = 0 ; i < 26 ; i ++ ) { if ( tr [ u ][ i ]) { fail [ tr [ u ][ i ]] = tr [ fail [ u ]][ i ]; // fail\u6570\u7ec4\uff1a\u540c\u4e00\u5b57\u7b26\u53ef\u4ee5\u5339\u914d\u7684\u5176\u4ed6\u4f4d\u7f6e q . push ( tr [ u ][ i ]); } else tr [ u ][ i ] = tr [ fail [ u ]][ i ]; } } } int query ( char * t ) { int u = 0 , res = 0 ; for ( int i = 1 ; t [ i ]; i ++ ) { u = tr [ u ][ t [ i ] - 'a' ]; // \u8f6c\u79fb for ( int j = u ; j && e [ j ] != -1 ; j = fail [ j ]) { res += e [ j ], e [ j ] = -1 ; } } return res ; } } // namespace AC char s [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , s + 1 ), AC :: insert ( s ); scanf ( \"%s\" , s + 1 ); AC :: build (); printf ( \"%d\" , AC :: query ( s )); return 0 ; } \u6570\u8bba \u00b6 \u6574\u6570\u5206\u5757 \u00b6 \u4ee3\u7801\u5b9e\u73b0\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n , ans = 0 ; scanf ( \"%lld\" , & n ); for ( ll l = 1 , r ; l <= n ; l = r + 1 ) { r = n / ( n / l ); ans += ( r - l + 1 ) * ( n / l ); } printf ( \"%lld \\n \" , ans ); } \u7ebf\u6027\u7b5b\u6c42\u8d28\u56e0\u6570\u7684\u4e2a\u6570 \u00b6 ///\u53c2\u7167\u4e8e\uff1a //https://www.luogu.com.cn/blog/SuuTTT/solution%2Dp1029 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; const ll maxn = 1e7 + 5 ; ll low_prime [ 10050000 ] = { 0 }; ll prime [ 700500 ] = { 0 }; ll cnt = 0 ; int main () { for ( ll i = 2 ; i <= maxn ; i ++ ) { if ( low_prime [ i ] == 0 ) { low_prime [ i ] = i ; prime [ ++ cnt ] = i ; } for ( ll j = 1 ; j <= cnt && prime [ j ] * i <= maxn ; j ++ ) { low_prime [ prime [ j ] * i ] = prime [ j ]; if ( i % prime [ j ] == 0 ) break ; } } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , flag = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { ll m , sum = 0 ; scanf ( \"%lld\" , & m ); while ( m > 1 ) { m /= low_prime [ m ]; sum ++ ; } flag ^= sum ; ///sum\u5373\u4e3a\u8d28\u56e0\u6570\u7684\u4e2a\u6570 } if ( ! flag ) puts ( \"Bob\" ); else puts ( \"Alice\" ); } } \u6b27\u62c9\u51fd\u6570\u6a21\u677f \u00b6 #include <bits/stdc++.h> using namespace std ; int is_prime [ 100500 ] = { 0 }; vector < int > prime ; int oula_table [ 100500 ] = { 0 }; void init ( int n ) ///\u6253\u7d20\u6570\u8868 { for ( int i = 2 ; i <= n ; i ++ ) { if ( ! is_prime [ i ]) prime . push_back ( i ); for ( int j = 0 ; j <= prime . size () && i * prime [ j ] <= n ; j ++ ) { is_prime [ i * prime [ j ]] = 1 ; if ( i % prime [ j ] == 0 ) break ; } } } int oula1 ( int n ) ///\u6839\u636e\u7d20\u6570\u8868\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int ans = n ; for ( int i = 0 ; prime [ i ] * prime [ i ] <= n ; i ++ ) { if ( n % prime [ i ] == 0 ) ans = ans - ans / prime [ i ]; while ( n % prime [ i ] == 0 ) n /= prime [ i ]; } return ans ; } int oula2 ( int n ) ///\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int m = n ; int ans = n ; for ( int i = 2 ; i <= sqrt ( n ); i ++ ) { if ( m % i == 0 ) ans = ans - ans / i ; while ( m % i == 0 ) m /= i ; } if ( m != 1 ) ans = ans - ans / m ; return ans ; } void get_oula_table ( int n ) ///\u6b27\u62c9\u6253\u8868 { for ( int i = 1 ; i <= n ; i ++ ) oula_table [ i ] = 0 ; oula_table [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! oula_table [ i ]) ///\u8bf4\u660ei\u662f\u8d28\u6570 { for ( int j = i ; j <= n ; j += i ) //\u53bb\u627ei\u7684\u500d\u6570 { if ( ! oula_table [ j ]) oula_table [ j ] = j ; oula_table [ j ] = oula_table [ j ] / i * ( i -1 ); } } } } int main () { int n ; cin >> n ; init ( n ); cout << \"\u627e\u7d20\u6570\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula1 ( n ) << endl ; cout << \"\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula2 ( n ) << endl ; get_oula_table ( n ); cout << \"\u6253\u8868\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" ; for ( int i = 1 ; i <= n ; i ++ ) cout << oula_table [ i ] << ' ' ; } \u9006\u5e8f\u5bf9 \u00b6 #include <iostream> #include <bits/stdc++.h> using namespace std ; int a [ 2005000 ] = { 0 }; int b [ 2005000 ] = { 0 }; long long int merge_sort ( long long int l , long long int r ) { if ( l >= r ) return 0 ; long long int mid = ( l + r ) >> 1 , res = 0 ; res += merge_sort ( l , mid ); res += merge_sort ( mid + 1 , r ); long long int i = l , j = mid + 1 , cnt = 0 ; while ( i <= mid && j <= r ) if ( a [ i ] <= a [ j ]) b [ cnt ++ ] = a [ i ++ ]; else { res += mid - i + 1 ; b [ cnt ++ ] = a [ j ++ ]; } while ( i <= mid ) b [ cnt ++ ] = a [ i ++ ]; while ( j <= r ) b [ cnt ++ ] = a [ j ++ ]; for ( long long int i = l , j = 0 ; j < cnt ; ++ i , ++ j ) a [ i ] = b [ j ]; return res ; } int main () { int n ; cin >> n ; for ( long long int i = 0 ; i < n ; i ++ ) { cin >> a [ i ]; } long long int sum = merge_sort ( 0 , n -1 ); cout << sum << endl ; return 0 ; } #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n , m ; ll a [ 100500 ] = { 0 }; ll c [ 100500 ] = { 0 }; ll maxn = 10050 , k , ans = 0 ; ll lowbit ( ll x ) { return x & ( - x ); } ll add ( ll k , ll x ) { for ( ll i = k ; i <= maxn ; i += lowbit ( i )) c [ i ] += x ; } ll getsum ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c [ i ]; return ans ; } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & k ); add ( k , 1 ); ans += i - getsum ( k ); } printf ( \"%d \\n \" , ans ); } \u4e8c\u7ef4\u524d\u7f00\u548c \u00b6 #include <bits/stdc++.h> using namespace std ; const int maxn = 5010 ; int g [ maxn ][ maxn ]; int main ( void ) { int N , R ; cin >> N >> R ; int n = R , m = R ; for ( int i = 0 , x , y , w ; i < N ; ++ i ) { cin >> x >> y >> w ; x ++ , y ++ ; n = max ( n , x ); m = max ( m , y ); g [ x ][ y ] += w ; } for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) g [ i ][ j ] += g [ i -1 ][ j ] + g [ i ][ j -1 ] - g [ i -1 ][ j -1 ]; int ans = 0 ; for ( int i = R ; i <= n ; i ++ ) for ( int j = R ; j <= m ; j ++ ) ans = max ( ans , g [ i ][ j ] - g [ i - R ][ j ] - g [ i ][ j - R ] + g [ i - R ][ j - R ]); cout << ans ; return 0 ; } \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u7406 \u00b6 \u6c42\u89e3$a * x + b * y = gcd(a,b) $\u65b9\u7a0b\u7684\u901a\u89e3x\u548cy #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll N = 1e9 + 7 ; ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll d = exgcd ( b , a % b , x , y ); ll t = x ; x = y ; y = t - ( a / b ) * y ; return d ; } int main () { ll a = 3 , b = 5 , x = 0 , y = 0 ; ll g = exgcd ( a , b , x , y ); cout << \"\u7279\u89e3\u4e3a\" << \"x=\" << x << \",y=\" << y << endl ; for ( int i = 1 ; i <= 5 ; i ++ ) { x += b / g ; y -= a / g ; cout << \"\u901a\u89e3\u4e3a\" << \"x=\" << x << \",y=\" << y << endl ; } return 0 ; } \u6c42\u89e3\u4e00\u822c\u65b9\u7a0b a * x+b * y=c a * x+b * y=c \u7684\u901a\u89e3x\u548cy \u5c06\u65b9\u7a0b\u8f6c\u53d8\u4e3a\uff1a a * x+b * y=gcd(a, b) * c/gcd(a, b); a * x+b * y=gcd(a, b) * c/gcd(a, b); \u6700\u7ec8\u5373\u4e3a\uff1a a * x/(c/gcd(a, b))+b * y/(c/gcd(a, b))=gcd(a, b); a * x/(c/gcd(a, b))+b * y/(c/gcd(a, b))=gcd(a, b); \u5373\u628a\u7ed3\u679c\u8c03\u6574\u4e3a\uff1a x1=x0 * c/gcd(a, b); y1=y0 * c/gcd(a, b); x1=x0 * c/gcd(a, b); y1=y0 * c/gcd(a, b); #include <stdio.h> long long exgcd ( long long a , long long b , long long & x , long long & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } long long r = exgcd ( b , a % b , x , y ), t ; t = x ; x = y ; y = t - ( a / b ) * y ; return r ; } int main () { long long a , b , c , ans , x , y ; while ( scanf ( \"%lld%lld%lld\" , & a , & b , & c ) != EOF ) { ans = exgcd ( a , b , x , y ); if ( c % ans == 0 ) { x =- x * c / ans ; y =- y * c / ans ; printf ( \"%lld %lld \\n \" , x , y ); } else printf ( \"-1 \\n \" ); } return 0 ; } \u9006\u5143 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a , q ; ll ksm ( ll n , ll k ) { ll sum1 = 1 , sum2 = n ; while ( k != 0 ) { if ( k % 2 == 1 ) sum1 = sum1 * sum2 % q ; sum2 = sum2 * sum2 % q ; k /= 2 ; } return sum1 ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; cin >> a >> q ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << ksm ( a , q -2 ) << endl ; } #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll exgcd ( ll a , ll b , ll & x , ll & y ) ///\u540e\u4e24\u4e2a\u53c2\u6570\u4e3a\u5f15\u7528 { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll gcd_ans = exgcd ( b , a % b , x , y ); ll tem = x ; x = y ; y = tem - a / b * y ; return gcd_ans ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; ll a , q , x = 0 , y = 0 ; cin >> a >> q ; ll gcd_ans = exgcd ( q , a , x , y ); ll mul = q / gcd_ans ; y = ( y % mul + mul ) % mul ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << y << endl ; } \u8868\u8fbe\u5f0f\u6c42\u503c\uff08\u4e2d\u7f00\u8868\u8fbe\u5f0f\u8f6c\u540e\u7f00\u8868\u8fbe\u5f0f\uff09 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; stack < char > sc ; stack < ll > sll ; char a [ 100500 ] = { 0 }; inline ll qpow ( ll a , ll b ) { ll ans = 1 ; while ( b ) { if ( b & 1 ) ans *= a ; a *= a , b >>= 1 ; } return ans ; } int cmp1 ( char a1 , char a2 ) { if ( a2 == '(' ) return -1 ; if ( a2 == ')' ) { if ( a1 == '(' ) return 0 ; else if ( a1 == '#' ) return 0 ; else return 1 ; } if ( a2 == '+' || a2 == '-' ) { if ( a1 == '+' || a1 == '-' || a1 == '*' || a1 == '/' || a1 == '^' ) return 1 ; else return -1 ; } if ( a2 == '*' || a2 == '/' ) { if ( a1 == '*' || a1 == '/' || a1 == '^' ) return 1 ; else return -1 ; } if ( a2 == '^' ) { if ( a1 == '^' ) return 1 ; else return -1 ; } if ( a2 == '#' ) { if ( a1 == '#' ) return 0 ; else if ( a1 == '(' || a1 == ')' ) return 0 ; else return 1 ; } return 0 ; } int main () { scanf ( \"%s\" , a + 1 ); a [ strlen ( a + 1 ) + 1 ] = '#' ; ll tem = 0 , tem2 , tem1 ; sll . push ( 0 ); sc . push ( '#' ); for ( int i = 1 ; a [ i ]; i ++ ) { if ( a [ i ] <= '9' && a [ i ] >= '0' ) { tem = tem * 10 + a [ i ] - '0' ; if ( a [ i + 1 ] < '0' || a [ i + 1 ] > '9' ) sll . push ( tem ), tem = 0 ; } else { while ( ! sc . empty ()) { ll tem_cmp = cmp1 ( sc . top (), a [ i ]); if ( tem_cmp == 1 ) { tem2 = sll . top (); sll . pop (); tem1 = sll . top (); sll . pop (); if ( sc . top () == '+' ) sll . push ( tem1 + tem2 ); else if ( sc . top () == '-' ) sll . push ( tem1 - tem2 ); else if ( sc . top () == '*' ) sll . push ( tem1 * tem2 ); else if ( sc . top () == '/' ) sll . push ( tem1 / tem2 ); else if ( sc . top () == '^' ) sll . push (( ll ) qpow ( tem1 , tem2 )); sc . pop (); } else if ( tem_cmp == 0 ) { if ( a [ i ] != ')' || ( a [ i ] == ')' && sc . size () > 1 )) sc . pop (); break ; } else if ( tem_cmp == -1 ) { sc . push ( a [ i ]); break ; } } } } cout << sll . top () << endl ; } \u7ec4\u5408\u6570\u5b66 \u00b6 \u53c2\u8003\u535a\u5ba2\uff1a https://blog.csdn.net/Luoxiaobaia/article/details/107593528 1.\u7403\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u4e0d\u80fd\u7a7a\uff08\u9694\u677f\u6cd5\uff09 \u4e00\u5171\u6709n-1\u4e2a\u7a7a\u9699(\u603b\u5171n+1\u4e2a\u7a7a\u9699\uff0c\u4e0d\u80fd\u7a7a\u8981\u53bb\u6389\u5934\u5c3e=n-1) \uff0c\u8981\u63d2m-1\u4e2a\u677f\uff0c\u7b54\u6848\u4e3a C_{n-1}^{m-1} C_{n-1}^{m-1} \u200b 2.\u7403\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u80fd\u7a7a \u5982\u679c\u7ed9\u6bcf\u4e2a\u76d2\u5b50\u4e00\u4e2a\u7403\uff0c\u5c31\u53ef\u4ee5\u628a\u95ee\u9898\u8f6c\u5316\u4e3a\u4e0d\u80fd\u7a7a\u7684\u60c5\u51b5\u4e86,\u5c31\u76f8\u5f53\u4e8en+m\u4e2a\u5c0f\u7403\u653e\u5165m\u4e2a\u76d2\u5b50\u4e14\u4e0d\u80fd\u7a7a\uff0c\u7b54\u6848\u5c31\u662f C_{n+m-1}^{m-1} C_{n+m-1}^{m-1} 3.\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u80fd\u7a7a\uff08dp\u95ee\u9898\uff09 dp[n][m]\u4ee3\u8868n\u4e2a\u5c0f\u7403\u653e\u5165m\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u4e14\u4e0d\u80fd\u7a7a\u7684\u65b9\u6cd5 \u5f53 i >= 0 \u65f6\uff0cdp[i][i]=1 (i\u4e2a\u5c0f\u7403\u653e\u5165i\u4e2a\u76d2\u5b50\uff0c\u5c31\u53ea\u80fd1\u4e2a\u76d2\u5b50\u653e1\u4e2a) \u5f53 i > 0 \u65f6,dp[i][0]=0(\u90fd\u6ca1\u6709\u76d2\u5b50\u4e86\uff0c\u80af\u5b9a\u65e0\u89e3) dp[i][j] = j * dp[i-1][j] + dp[i-1][j-1] (\u7b2ci\u4e2a\u7403\u53ef\u4ee5\u653e\u5728\u5df2\u7ecf\u6709\u7684j\u4e2a\u76d2\u5b50\u7684\u4e00\u4e2a\uff0c\u6709j\u79cd\u65b9\u6cd5,\u4e5f\u5c31\u662fj*dp[i-1][j], \u4e5f\u53ef\u4ee5\u662f\u653e\u5165\u4e00\u4e2a\u65b0\u7684\u76d2\u5b50,\u5c31\u662fdp[i-1][j-1]) \u6240\u4ee5\u7b54\u6848\u5982\u4e0b\uff1a 4.\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a\uff08\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\uff09 \u90a3\u5c31\u662f3\u7684\u60c5\u51b5(\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u5141\u8bb8\u4e3a\u7a7a)\u75281\u4e2a\u76d2\u5b50+\u75282\u4e2a\u76d2\u5b50+\u2026+m\u4e2a\u76d2\u5b50 5.\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u4e0d\u80fd\u7a7a \u90a3\u5c31\u662f3\u7684\u60c5\u51b5(\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u5141\u8bb8\u4e3a\u7a7a)\u5bf9\u76d2\u5b50\u8fdb\u884c\u5168\u6392\u5217 \u7b54\u6848\u5c31\u662f m!*dp[n][m] (dp[n][m]\u662f\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570) 6.\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u53ef\u4ee5\u7a7a \u6bcf\u4e00\u4e2a\u5c0f\u7403\u90fd\u6709m\u79cd\u65b9\u6cd5\uff0c\u4e14\u76f8\u4e92\u72ec\u7acb\uff0c\u7b54\u6848\u5c31\u662f m^n m^n 7.\u7403\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a\uff08dp\u95ee\u9898\uff09 dp[i][j]\u4ee3\u8868\u7403\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a\u7684\u653e\u6cd5 \u5f53 i>=j \u65f6\uff0cdp[i][j] = dp[i][j-1]+dp[i-j][j] ( \u6211\u4eec\u53ef\u4ee5\u5728\u6240\u6709\u7684\u76d2\u5b50\u4e0a\u653e\u4e00\u4e2a\u7403dp[i-j][j]\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u9009\u62e9\u8fd9\u79cd\u64cd\u4f5c\uff0c\u4f46\u662f\u4ee5\u540e\u90fd\u4e0d\u5bf9\u5176\u4e2d\u4e00\u4e2a\u76d2\u5b50\u8fdb\u884c\u64cd\u4f5c\u4e86\uff0c\u90a3\u5c31\u662fdp[i][j-1] ) \u5f53 i<j \u65f6\uff0cdp[i][i] (\u591a\u4f59\u7684\u76d2\u5b50\u90fd\u6ca1\u6709\u4ec0\u4e48\u5375\u7528\u4e86) \u5f53 j=1 \u65f6\uff0c1(\u53ea\u6709\u4e00\u4e2a\u76d2\u5b50\u4e86\u5c31\u53ea\u80fd\u653e\u5728\u90a3\u4e2a\u76d2\u5b50\u4e86\uff0c\u53ea\u6709\u4e00\u79cd\u653e\u6cd5) \u5f53 i=1 \u65f6\uff0c1(\u53ea\u6709\u4e00\u4e2a\u7403\u4e86\uff0c\u653e\u54ea\u4e2a\u76d2\u5b50\u90fd\u4e00\u6837\uff0c\u53ea\u6709\u4e00\u79cd\u653e\u6cd5) \u5f53 i=0 \u65f6 1(\u6ca1\u6709\u7403\u4e86\uff0c\u4e5f\u662f1\u79cd\u65b9\u6cd5) \u7b54\u6848\u662f 8.\u7403\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u80fd\u7a7a \u90a3\u5c31\u662f7\u7684\u60c5\u51b5(\u7403\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a)\u6bcf\u4e2a\u76d2\u5b50\u5148\u653e\u4e00\u4e2a\u4fdd\u8bc1\u4e0d\u7a7a \u6240\u4ee5\u7b54\u6848\u662f dp[n-m][m] (n>=m) 0 (n<m) \u5176\u4e2ddp\u662f\u60c5\u51b57\u7684dp \u9644\u60c5\u51b57\u7684\u4ee3\u7801\uff1a #include <iostream> int main () { const int N = 11 ; int dp [ N ][ N ] = {}, t , n , m ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 1 ; j < N ; ++ j ) { if ( i <= 1 || j == 1 ) dp [ i ][ j ] = 1 ; else if ( i < j ) dp [ i ][ j ] = dp [ i ][ i ]; else dp [ i ][ j ] = dp [ i ][ j -1 ] + dp [ i - j ][ j ]; } scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & m ); printf ( \"%d \\n \" , dp [ n ][ m ]); } return 0 ; } \u5361\u7279\u5170\u6570 \u00b6 \u53c2\u7167\u535a\u5ba2\uff1a https://zhuanlan.zhihu.com/p/97619085 \u5361\u7279\u5170\u6570\uff08Catalan number\uff09\u662f \u7ec4\u5408\u6570\u5b66 \u4e2d\u4e00\u4e2a\u5e38\u51fa\u73b0\u5728\u5404\u79cd \u8ba1\u6570\u95ee\u9898 \u4e2d\u7684 \u6570\u5217 \u3002 \u6570\u5217\u7684\u524d\u51e0\u9879\u4e3a\uff1a1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862\uff0c... \u5361\u7279\u5170\u6570\u516c\u5f0f\uff1a \u7535\u5f71\u8d2d\u7968\u95ee\u9898 \u7535\u5f71\u7968\u4e00\u5f20 50 coin\uff0c\u4e14\u552e\u7968\u5385\u6ca1\u6709 coin\u3002m \u4e2a\u4eba\u5404\u81ea\u6301\u6709 50 coin\uff0cn \u4e2a\u4eba\u5404\u81ea\u6301\u6709 100 coin\u3002 \u5219\u6709\u591a\u5c11\u79cd\u6392\u961f\u65b9\u5f0f\uff0c\u53ef\u4ee5\u8ba9\u6bcf\u4e2a\u4eba\u90fd\u4e70\u5230\u7535\u5f71\u7968\u3002 \u601d\u8def \u6301\u6709 50 coin \u7684\u4eba\u6bcf\u6b21\u8d2d\u7968\u65f6\u4e0d\u9700\u8981\u627e\u96f6\uff0c\u5e76\u4e14\u53ef\u4ee5\u5e2e\u52a9\u540e\u9762\u6301\u6709 100 coin \u7684\u4eba\u627e\u96f6\uff1b\u800c\u5bf9\u4e8e\u6301\u6709 100 coin \u7684\u4eba\u6bcf\u6b21\u8d2d\u7968\u65f6\u9700\u8981\u627e\u96f6\uff0c\u4f46 100 coin \u5bf9\u540e\u9762\u7684\u627e\u96f6\u6ca1\u6709\u4efb\u4f55\u4f5c\u7528\u3002 \u56e0\u6b64\uff0c\u76f8\u5f53\u4e8e\u6bcf\u4e2a\u6301\u6709 100 coin \u7684\u4eba\u90fd\u9700\u8981\u548c\u4e00\u4e2a\u6301\u6709 50 coin \u7684\u4eba\u8fdb\u884c\u5339\u914d\u3002\u6211\u4eec\u5c06\u6301\u6709 50 coin \u7684\u6807\u8bb0\u4e3a +1\uff0c\u6301\u6709 100 coin \u7684\u6807\u8bb0\u4e3a -1\uff0c\u6b64\u65f6\u53c8\u56de\u5230\u4e86\u8fdb\u51fa\u6808\u95ee\u9898\u3002 \u4e0d\u540c\u7684\u662f\uff0cm \u5e76\u4e00\u5b9a\u7b49\u4e8e n\uff0c\u4e14\u6392\u961f\u5e8f\u5217\u662f\u4e00\u79cd\u6392\u5217\uff0c\u9700\u8981\u8003\u8651\u5148\u540e\u987a\u5e8f\uff0c\u4f8b\u5982\u5404\u81ea\u6301\u6709 50 coin \u7684\u7532\u548c\u4e59\u7684\u524d\u540e\u5173\u7cfb\u4f1a\u9020\u6210\u4e24\u79cd\u4e0d\u540c\u7684\u6392\u961f\u5e8f\u5217\u3002\u6240\u4ee5\uff0c\u5c06\u4f1a\u6709 \u7b2c\u4e8c\u9879\u4e3a\u4ec0\u4e48\u662f \uff0c\u5176\u5b9e\u5f88\u7b80\u5355\uff0c\u6211\u4eec\u6bcf\u6b21\u628a\u7b2c\u4e00\u4e2a\u524d\u7f00\u5c0f\u4e8e0 \u7684\u524d\u7f00\u53d6\u53cd\u540e\uff0c\u4f1a\u9020\u6210 +1 \u591a\u4e86\u4e00\u4e2a\u800c -1 \u5c11\u4e86\u4e00\u4e2a\u3002\u8fd9\u91cc +1 \u6709 m \u4e2a\uff0c-1 \u6709 n \u4e2a\uff0c\u53d6\u53cd\u540e +1 \u53d8\u6210 m + 1 \u4e2a\uff0c-1 \u53d8\u6210 n - 1 \u4e2a\uff0c\u603b\u548c\u4e0d\u53d8\u3002 const int C_maxn = 1e4 + 10 ; ll CatalanNum [ C_maxn ]; ll inv [ C_maxn ]; inline void Catalan_Mod ( int N , LL mod ) { inv [ 1 ] = 1 ; for ( int i = 2 ; i <= N + 1 ; i ++ ) ///\u7ebf\u6027\u9884\u5904\u7406 1 ~ N \u5173\u4e8e mod \u7684\u9006\u5143 inv [ i ] = ( mod - mod / i ) * inv [ mod % i ] % mod ; CatalanNum [ 0 ] = CatalanNum [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) CatalanNum [ i ] = CatalanNum [ i - 1 ] * ( 4 * i - 2 ) % mod * inv [ i + 1 ] % mod ; } \u79ef\u6027\u51fd\u6570 \u00b6 \u79ef\u6027\u51fd\u6570\u662f\u6307\u5bf9\u4e8e\u4efb\u610f\u4e92\u8d28\u7684\u6574\u6570a\u548cb\u6709\u6027\u8d28f(ab)=f(a)f(b)\u7684\u6570\u8bba\u51fd\u6570 \u5e38\u7528\u79ef\u6027\u51fd\u6570\u6709\uff1a \u03c6(n) \uff0d\u6b27\u62c9\u51fd\u6570 \u03bc(n) \uff0d\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\uff0c\u5173\u4e8e\u975e\u5e73\u65b9\u6570\u7684\u8d28\u56e0\u5b50\u6570\u76ee gcd(n,k) \uff0d\u6700\u5927\u516c\u56e0\u5b50\uff0c\u5f53k\u56fa\u5b9a\u7684\u60c5\u51b5 d(n) \uff0dn\u7684\u6b63\u56e0\u5b50\u6570\u76ee \u03c3(n) \uff0dn\u7684\u6240\u6709\u6b63\u56e0\u5b50\u4e4b\u548c \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14 \u00b6 \u53c2\u8003\u4e8e https://zhuanlan.zhihu.com/p/45744228 \u51fd\u6570\u5b9a\u4e49 \u8f85\u52a9\u5b9a\u7406 \u5bf9\u4e8e\u4efb\u610f\u6b63\u6574\u6570 \uff0c\u6052\u6709 \u5176\u6b21\uff0c\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u548c\u6b27\u62c9\u51fd\u6570\u7684\u5173\u7cfb\uff1a \\sum_{d|n}\\frac{\\mu[d]}{d}=\\frac{\\varphi(n)}{n} \\sum_{d|n}\\frac{\\mu[d]}{d}=\\frac{\\varphi(n)}{n} \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u5b9a\u7406 \u548c \u662f\u5b9a\u4e49\u5728\u6b63\u6574\u6570\u96c6\u5408\u4e0a\u7684\u4e24\u4e2a\u51fd\u6570\uff0c\u82e5 \u5219 \u53cd\u4e4b\u4ea6\u7136. \u8bc1\u660e\uff1a \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u5b9e\u9645\u4e0a\u662f\u5bb9\u65a5\u3002 \u5e38\u89c1\u53cd\u6f14 1\u3001 \u6240\u4ee5\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\u672c\u8eab\u4e5f\u53ef\u4ee5\u53cd\u6f14\u3002 2\u3001 \u7ebf\u6027\u9884\u5904\u7406 \u6c42\u89e3\u533a\u95f4 \u548c\u533a\u95f4 \u4e0a\u4e92\u8d28\u7684\u6570\u7684\u4e2a\u6570\u3002 \u4ee3\u7801 void get_mu ( int n ) { mu [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! vis [ i ]){ prim [ ++ cnt ] = i ; mu [ i ] = -1 ;} for ( int j = 1 ; j <= cnt && prim [ j ] * i <= n ; j ++ ) { vis [ prim [ j ] * i ] = 1 ; if ( i % prim [ j ] == 0 ) break ; else mu [ i * prim [ j ]] =- mu [ i ]; } } } FFT\u548cNNT\u6a21\u677f \u00b6 \u53c2\u8003\u94fe\u63a5\uff1a https://www.acwing.com/file_system/file/content/whole/index/content/1563813/ https://blog.csdn.net/hzf0701/article/details/119428159 https://blog.csdn.net/zz_1215/article/details/40430041 https://www.luogu.com.cn/problem/P3803 NTT \u5feb\u901f\u6570\u8bba\u53d8\u6362\u53d6\u6a21\u591a\u9879\u5f0f\u6a21\u677f #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; const ll G = 3 ; ll n , m , L , R [ 6005000 ] = { 0 }; ll a [ 6005000 ] = { 0 }, b [ 6005000 ] = { 0 }, inv [ 6005000 ] = { 0 }; ll qpow ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ans1 * ans2 % mod ; ans2 = ans2 * ans2 % mod ; b /= 2 ; } return ans1 % mod ; } void NTT ( ll * a , ll f ) { for ( ll i = 0 ; i < n ; i ++ ) { if ( i < R [ i ]) swap ( a [ i ], a [ R [ i ]]); } for ( ll i = 1 ; i < n ; i <<= 1 ) { ll gn = qpow ( G , ( mod - 1 ) / ( i << 1 )); for ( ll j = 0 ; j < n ; j += ( i << 1 )) { ll g = 1 ; for ( ll k = 0 ; k < i ; k ++ , g = g * gn % mod ) { ll x = a [ j + k ], y = g * a [ j + k + i ] % mod ; a [ j + k ] = ( x + y ) % mod ; a [ j + k + i ] = ( x - y + mod ) % mod ; } } } if ( f == 1 ) return ; ll inv = qpow ( n , mod - 2 ); reverse ( a + 1 , a + n ); for ( ll i = 0 ; i < n ; i ++ ) a [ i ] = 1l l * a [ i ] * inv % mod ; } void solve ( ll * A , ll * B ) { m = n + m ; for ( n = 1 ; n <= m ; n <<= 1 ) L ++ ; for ( int i = 0 ; i < n ; i ++ ) R [ i ] = ( R [ i >> 1 ] >> 1 ) | (( i & 1 ) << ( L - 1 )); NTT ( A , 1 ); NTT ( B , 1 ); for ( int i = 0 ; i < n ; i ++ ) A [ i ] = ( A [ i ] % mod * B [ i ] % mod + mod ) % mod ; NTT ( A , -1 ); } int main () { scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 0 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); for ( ll i = 0 ; i <= m ; i ++ ) scanf ( \"%lld\" , & b [ i ]); solve ( a , b ); for ( ll i = 0 ; i <= m ; i ++ ) printf ( \"%lld \" , a [ i ]); return 0 ; } FFT\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362\u6a21\u677f #include <bits/stdc++.h> using namespace std ; typedef pair < int , int > pii ; typedef long long ll ; const int N = 6e6 + 10 ; const int P = 1e9 + 7 ; const int INF = 0x3f3f3f3f ; const double PI = acos ( -1.0 ); //\u5706\u5468\u7387PI\u3002 struct Complex { double x , y ; //\u590d\u6570\uff0cx\u4ee3\u8868\u5b9e\u90e8\uff0cy\u4ee3\u8868\u865a\u90e8\u3002 Complex ( double _x = 0 , double _y = 0 ) { x = _x , y = _y ; } } a [ N ], b [ N ]; //\u591a\u9879\u5f0fa\u548cb\uff0c\u76f8\u4e58\u3002 int n , m , l , r [ N ], limit = 1 ; //n\u4e3aa\u7684\u6b21\u6570,m\u4e3ab\u7684\u6b21\u6570\u3002limit\u5373\u4e3a\u6700\u5927\u9650\u5236\u30022^n\u6b21\u65b9\uff0c\u800cl\u4e3a\u4e8c\u8fdb\u5236\u7684\u4f4d\u6570 //\u8fd0\u7b97\u7b26\u91cd\u8f7d\u3002 Complex operator + ( Complex a , Complex b ) { return Complex ( a . x + b . x , a . y + b . y ); } Complex operator - ( Complex a , Complex b ) { return Complex ( a . x - b . x , a . y - b . y ); } //\u590d\u6570\u76f8\u4e58\uff0c\u5219\u6a21\u957f\u76f8\u4e58\uff0c\u5e45\u5ea6\u76f8\u52a0\u3002 Complex operator * ( Complex a , Complex b ) { return Complex ( a . x * b . x - a . y * b . y , a . x * b . y + a . y * b . x ); } void fft ( Complex * A , int type ) { for ( int i = 0 ; i < limit ; ++ i ) { if ( i < r [ i ]) swap ( A [ i ], A [ r [ i ]]); //\u6c42\u51fa\u8981\u8fed\u4ee3\u7684\u533a\u95f4\u3002\u5c0f\u4e8er[i]\u65f6\u624d\u4ea4\u6362\uff0c\u9632\u6b62\u540c\u4e00\u4e2a\u5143\u7d20\u4ea4\u6362\u4e24\u6b21\uff0c\u56de\u5230\u539f\u6765\u7684\u4f4d\u7f6e\u3002 } //\u4ece\u5e95\u5c42\u5f80\u4e0a\u5408\u5e76\u3002 for ( int mid = 1 ; mid < limit ; mid <<= 1 ) { //\u5f85\u5408\u5e76\u533a\u95f4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u6700\u5f00\u59cb\u662f\u4e24\u4e2a\u957f\u5ea6\u4e3a1\u7684\u5e8f\u5217\u5408\u5e76,mid = 1; Complex Wn ( cos ( PI / mid ), type * sin ( PI / mid )); //\u5355\u4f4d\u6839\u3002 for ( int len = mid << 1 , j = 0 ; j < limit ; j += len ) { //len\u662f\u533a\u95f4\u7684\u957f\u5ea6\uff0cj\u662f\u5f53\u524d\u7684\u4f4d\u7f6e\uff0c\u4e5f\u5c31\u662f\u5408\u5e76\u5230\u4e86\u54ea\u4e00\u4f4d\u3002 Complex w ( 1 , 0 ); //\u5e42\uff0c\u4e00\u76f4\u4e58\uff0c\u5f97\u5230\u5e73\u65b9\uff0c\u4e09\u6b21\u65b9\u3002 for ( int k = 0 ; k < mid ; ++ k , w = w * Wn ) { //\u679a\u4e3e\u5de6\u534a\u90e8\u5206\u3002\u8774\u8776\u53d8\u6362\u5f97\u5230\u53f3\u534a\u90e8\u5206\u7684\u7b54\u6848\u3002w\u4e3awn * k Complex x = A [ j + k ], y = w * A [ j + mid + k ]; //\u5de6\u534a\u90e8\u5206\u548c\u53f3\u534a\u90e8\u5206\u3002 A [ j + k ] = x + y ; //\u5de6\u8fb9\u52a0\u3002 A [ j + mid + k ] = x - y ; //\u53f3\u8fb9\u51cf\u3002 } } } if ( type == 1 ) return ; for ( int i = 0 ; i <= limit ; ++ i ) { a [ i ]. x /= limit ; //\u6700\u540e\u9700\u8981\u9664\u4ee5limit\u4e5f\u5c31\u662f\u8865\u6210\u4e862\u7684\u6574\u6570\u5e42\u3002\u5c06\u70b9\u503c\u8f6c\u6362\u4e3a\u7cfb\u6570\u3002 } } void solve () { while ( limit <= n + m ) { limit <<= 1 , l ++ ; } //\u521d\u59cb\u5316r\u6570\u7ec4\u3002 for ( int i = 0 ; i < limit ; ++ i ) { r [ i ] = ( r [ i >> 1 ] >> 1 ) | (( i & 1 ) << ( l - 1 )); } fft ( a , 1 ); //\u5c06a\u7684\u7cfb\u6570\u8f6c\u5316\u4e3a\u70b9\u503c\u8868\u793a\uff0c fft ( b , 1 ); //\u5c06b\u7684\u7cfb\u6570\u8f6c\u5316\u4e3a\u70b9\u503c\u8868\u793a\u3002 for ( int i = 0 ; i <= limit ; ++ i ) { //\u5bf9\u5e94\u9879\u76f8\u4e58\uff0c\u5f97\u5230\u70b9\u503c\u8868\u793a\u7684\u89e3\u3002 a [ i ] = a [ i ] * b [ i ]; } fft ( a , -1 ); for ( int i = 0 ; i <= n + m ; ++ i ) { //\u53d6\u51fa\u6765\u96642\uff0c\u52a0\u4e0a0.5\u56db\u820d\u4e94\u5165\u3002 printf ( \"%d \" , ( int )( a [ i ]. x + 0.5 )); } printf ( \" \\n \" ); } int main () { scanf ( \"%d%d\" , & n , & m ); //\u8bfb\u5165\u591a\u9879\u5f0f\u7684\u6bcf\u4e00\u9879\u3002 for ( int i = 0 ; i <= n ; ++ i ) { scanf ( \"%lf\" , & a [ i ]. x ); } \u00b7 for ( int i = 0 ; i <= m ; ++ i ) { scanf ( \"%lf\" , & b [ i ]. x ); } solve (); return 0 ; } Meissel-Lehmer \u7b97\u6cd5 \u00b6 \u662f\u4e00\u79cd\u80fd\u5728\u4e9a\u7ebf\u6027\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u6c42\u51fa 1\u223cn\u5185\u8d28\u6570\u4e2a\u6570\u7684\u4e00\u79cd\u7b97\u6cd5\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{\\frac{2}{3}}) O(n^{\\frac{2}{3}}) #include <bits/stdc++.h> using namespace std ; using ll = long long ; //\u901a\u8fc7\u77e5\u9053\u524d\u9762\u7684 n^1/3 \u7684\u8d28\u6570\u53ef\u4ee5\u63a8\u65ad\u540e\u9762n^2/3\u7684\u8d28\u6570\u6240\u4ee5\u53ef\u4ee5\u9002\u5f53\u51cf\u5c0f const int N = 9e3 ; const int M = 2 ; //\u4e3a\u4e86\u51cf\u5c0f\u5185\u5b58\u53ef\u4ee5\u4e0d\u8fc7\u662f\u8d28\u6570 const int PM = 2 * 3 * 5 ; //\u4e3a\u4e86\u51cf\u5c0f\u5185\u5b58\u53ef\u4ee5\u4e0d\u8fc7\u8981\u6309\u8d28\u6570\u51cf\u5c0f\u5982\u53bb\u638917 ll n ; bool np [ N ]; int prime [ N ], pi [ N ]; int phi [ PM + 1 ][ M + 1 ], sz [ M + 1 ]; int getprime () { int cnt = 0 ; np [ 0 ] = np [ 1 ] = true ; pi [ 0 ] = pi [ 1 ] = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( ! np [ i ]) prime [ ++ cnt ] = i ; pi [ i ] = cnt ; for ( int j = 1 ; j <= cnt && i * prime [ j ] < N ; ++ j ) { np [ i * prime [ j ]] = true ; if ( i % prime [ j ] == 0 ) break ; } } return cnt ; } void init () { getprime (); sz [ 0 ] = 1 ; for ( int i = 0 ; i <= PM ; ++ i ) phi [ i ][ 0 ] = i ; for ( int i = 1 ; i <= M ; ++ i ) { sz [ i ] = prime [ i ] * sz [ i - 1 ]; for ( int j = 1 ; j <= PM ; ++ j ) phi [ j ][ i ] = phi [ j ][ i - 1 ] - phi [ j / prime [ i ]][ i - 1 ]; } } int sqrt2 ( ll x ) { ll r = ( ll ) sqrt ( x - 0.1 ); while ( r * r <= x ) ++ r ; return int ( r - 1 ); } int sqrt3 ( ll x ) { ll r = ( ll ) cbrt ( x - 0.1 ); while ( r * r * r <= x ) ++ r ; return int ( r - 1 ); } ll getphi ( ll x , int s ) { if ( s == 0 ) return x ; if ( s <= M ) return phi [ x % sz [ s ]][ s ] + ( x / sz [ s ]) * phi [ sz [ s ]][ s ]; if ( x <= prime [ s ] * prime [ s ]) return pi [ x ] - s + 1 ; if ( x <= prime [ s ] * prime [ s ] * prime [ s ] && x < N ) { int s2x = pi [ sqrt2 ( x )]; ll ans = pi [ x ] - ( s2x + s - 2 ) * ( s2x - s + 1 ) / 2 ; for ( int i = s + 1 ; i <= s2x ; ++ i ) ans += pi [ x / prime [ i ]]; return ans ; } return getphi ( x , s - 1 ) - getphi ( x / prime [ s ], s - 1 ); } ll getpi ( ll x ) { if ( x < N ) return pi [ x ]; ll ans = getphi ( x , pi [ sqrt3 ( x )]) + pi [ sqrt3 ( x )] - 1 ; for ( int i = pi [ sqrt3 ( x )] + 1 , ed = pi [ sqrt2 ( x )]; i <= ed ; ++ i ) ans -= getpi ( x / prime [ i ]) - i + 1 ; return ans ; } ll lehmer_pi ( ll x ) { //\u5c0f\u4e8e\u7b49\u4e8en\u7684\u7d20\u6570\u6709\u591a\u5c11\u4e2a if ( x < N ) return pi [ x ]; int a = ( int ) lehmer_pi ( sqrt2 ( sqrt2 ( x ))); int b = ( int ) lehmer_pi ( sqrt2 ( x )); int c = ( int ) lehmer_pi ( sqrt3 ( x )); ll sum = getphi ( x , a ) + ( ll )( b + a - 2 ) * ( b - a + 1 ) / 2 ; for ( int i = a + 1 ; i <= b ; i ++ ) { ll w = x / prime [ i ]; sum -= lehmer_pi ( w ); if ( i > c ) continue ; ll lim = lehmer_pi ( sqrt2 ( w )); for ( int j = i ; j <= lim ; j ++ ) sum -= lehmer_pi ( w / prime [ j ]) - ( j - 1 ); } return sum ; } int main () { ios_base :: sync_with_stdio ( false ), cin . tie ( 0 ); init (); while ( cin >> n && n ) cout << lehmer_pi ( n ) << \" \\n \" ; return 0 ; } Miller Rabin\u7d20\u6570\u5224\u5b9a\u7b97\u6cd5 \u00b6 // C++ Version bool millerRabin ( int n ) { if ( n < 3 || n % 2 == 0 ) return n == 2 ; int a = n - 1 , b = 0 ; while ( a % 2 == 0 ) a /= 2 , ++ b ; // test_time \u4e3a\u6d4b\u8bd5\u6b21\u6570,\u5efa\u8bae\u8bbe\u4e3a\u4e0d\u5c0f\u4e8e 8 // \u7684\u6574\u6570\u4ee5\u4fdd\u8bc1\u6b63\u786e\u7387,\u4f46\u4e5f\u4e0d\u5b9c\u8fc7\u5927,\u5426\u5219\u4f1a\u5f71\u54cd\u6548\u7387 for ( int i = 1 , j ; i <= test_time ; ++ i ) { int x = rand () % ( n - 2 ) + 2 , v = quickPow ( x , a , n ); if ( v == 1 ) continue ; for ( j = 0 ; j < b ; ++ j ) { if ( v == n - 1 ) break ; v = ( long long ) v * v % n ; } if ( j >= b ) return 0 ; } return 1 ; } \u52a8\u6001\u89c4\u5212 \u00b6 \u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217 \u00b6 \u5982\u679c\u4f60\u9700\u8981\u79fb\u52a8\u4e00\u6837\u4e1c\u897f\uff0c\u663e\u7136\u63a5\u89e6\u6216\u8005\u4f7f\u7528\u78c1\u573a\u7535\u573a\u4e4b\u7c7b\u7684\u53ef\u4ee5\u89e3\u51b3\u3002\u4f46\u662f\u6709\u6ca1\u6709\u529e\u6cd5\u8fdb\u884c\u8d85\u8d8a\u8ddd\u79bb\u7684\u968f\u5fc3\u6240\u6b32\u7684\u79fb\u52a8\uff1f \u5bf9\u4e8e\u7269\u4f53\u6216\u8005\u6587\u5b57\u8fdb\u884c\u8d85\u8ddd\u79bb\u79fb\u52a8\u4e00\u76f4\u662f\u4eba\u7c7b\u7684\u68a6\u60f3\uff0c\u6709\u4e00\u5929\u8fd9\u4e2a\u96be\u9898\u7ec8\u4e8e\u88ab\u6211\u4eec\u7684\u5927\u725b\u89e3\u51b3\u4e86\uff01\u4ed6\u73b0\u5728\u9700\u8981\u7684\u5c31\u662f\u6574\u7406\u6570\u5217\u3002\u6570\u5217\u5c31\u662f\u6240\u8c13\u7684\u5199\u5728\u7eb8\u4e0a\u6216\u8005\u5728\u7535\u8111\u54c1\u76ee\u4e0a\u7684\u6570\u5217... \u6574\u7406\u6570\u5217\u9700\u8981\u4e00\u4e2a\u53eb\u505aswap\u7684\u64cd\u4f5c\uff0cswap\u64cd\u4f5c\u5c31\u662f\u6307\u5927\u725b\u901a\u8fc7\u8d85\u8ddd\u79bb\u7684\u63a7\u5236\u628a\u6570\u5217\u4e2d\u7684\u67d0\u4e00\u4f4d\u76f4\u63a5\u63d2\u5165\u67d0\u4e24\u4f4d\u7684\u4e2d\u95f4\u6216\u8005\u6570\u5217\u7684\u5f00\u59cb\u6216\u8005\u7ec8\u6b62\u7684\u64cd\u4f5c\u3002\u8fd9\u4e2a\u64cd\u4f5c\u7684\u5173\u952e\u5728\u4e8e\u8d85\u8ddd\u79bb\u63a7\u5236\uff0c\u663e\u7136\u8fd9\u79cd\u4e8b\u60c5\u4e0d\u80fd\u5e72\u592a\u591a\u6b21\uff0c\u4e0d\u4f46\u964dRP\uff0c\u800c\u4e14\u5f88\u8017\u4f53\u529b\u3002\u4f60\u7684\u4efb\u52a1\u5c31\u662f\u4ece\u521d\u59cb\u72b6\u6001\u5230\u76ee\u6807\u72b6\u6001\u6240\u9700\u8981\u505aswap\u7684\u6700\u5c11\u6b21\u6570\u3002 \u8f93\u5165 \u4e09\u884c\uff0c\u7b2c\u4e00\u884c\u4e00\u4e2a\u6574\u6570 n\uff08n<600000\uff09 \u7b2c\u4e8c\u884c\uff0cn \u4e2a\u6574\u6570\uff081-n\uff09\uff0c\u8868\u793a\u521d\u59cb\u6570\u5217\u3002 \u7b2c\u4e09\u884c\uff0cn \u4e2a\u6574\u6570\uff081-n\uff09\uff0c\u8868\u793a\u76ee\u6807\u6570\u5217\u3002 \u4fdd\u8bc1\u6574\u6570\u4e0d\u91cd\u590d\u3002 \u8f93\u51fa \u4e00\u884c \u8868\u793a\u6700\u5c11swap\u6b21\u6570\u3002 \u6837\u4f8b\u8f93\u5165 10 1 2 3 4 5 6 7 8 9 10 10 9 8 7 6 5 4 3 2 1 \u6837\u4f8b\u8f93\u51fa 9 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <iostream> #include <cstdio> #include <bits/stdc++.h> using namespace std ; const int inf = 0x7fffffff ; int b [ 1005001 ], mp [ 1005001 ], c [ 1005001 ]; int main () { int n , x ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & x ), mp [ x ] = i ; for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & b [ i ]), c [ i ] = inf ; int len = 0 ; c [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int l = 0 , r = len , mid ; if ( mp [ b [ i ]] > c [ len ]) c [ ++ len ] = mp [ b [ i ]]; else { while ( l < r ) { mid = ( l + r ) / 2 ; if ( c [ mid ] > mp [ b [ i ]]) r = mid ; else l = mid + 1 ; } c [ l ] = min ( mp [ b [ i ]], c [ l ]); } } cout << n - len << endl ; return 0 ; } \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217 \u00b6 for ( int i = 1 ; i <= strlen ( a ); i ++ ) for ( int j = 1 ; j <= strlen ( b ); j ++ ) if ( a [ i ] == b [ j ]) dp [ i ][ j ] = dp [ i -1 ][ j -1 ] + 1 ; else dp [ i ][ j ] = max ( dp [ i -1 ][ j ], dp [ i ][ j -1 ]); \u72b6\u538bDP \u00b6 #include <bits/stdc++.h> using namespace std ; typedef unsigned long long ull ; typedef long long ll ; const int inf = 0x3f3f3f3f ; int n , m ; struct node { int cost , num ; } nd [ 100005 ]; int f [ 1005 ][( 1 << 12 ) + 5 ]; //1\u5de6\u79fb12\u4f4d\u518d\u52a05 int main () { cin >> n >> m ; for ( int i = 1 ; i <= m ; i ++ ) { int b ; scanf ( \"%d%d\" , & nd [ i ]. cost , & b ); int t = 0 ; for ( int j = 1 ; j <= b ; j ++ ) { int temp ; scanf ( \"%d\" , & temp ); t |= ( 1 << ( temp -1 )); ///1\u672c\u6765\u5c31\u5728\u7b2c\u4e00\u4e2a\u4f4d\uff0c\u6240\u4ee5\u8981\u5230\u7b2ctemp\u4f4d\uff0c\u53ea\u9700\u8981\u5411\u5de6\u79fb\u52a8temp-1\u4f4d } nd [ i ]. num = t ; } memset ( f , inf , sizeof ( f )); f [ 0 ][ 0 ] = 0 ; ///\u5f88\u91cd\u8981 for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 0 ; j < ( 1 << n ); j ++ ) ///n\u4e2a\u9501 { int kk = j | nd [ i ]. num ; ///\u5bf9\u5e94\u6bcf\u4e2a\u9501\u9009\u4e0d\u9009 f [ i ][ kk ] = min ( f [ i ][ kk ], f [ i -1 ][ j ] + nd [ i ]. cost ); f [ i ][ j ] = min ( f [ i ][ j ], f [ i -1 ][ j ]); /// } } if ( f [ m ][( 1 << n ) -1 ] != inf ) ///1\u5411\u5de6\u79fb\u52a812\uff0c\u76f8\u5f53\u4e8e1000000000000\uff0c\u7136\u800c12\u4e2a\u4f4d\u7f6e\u90fd\u4e3a1\uff0c\u5373(111111111111)=(1000000000000)-1 printf ( \"%d \\n \" , f [ m ][( 1 << n ) -1 ]); else printf ( \"-1\" ); return 0 ; } \u659c\u7387DP \u00b6 \u4f18\u5316$ Dp[i]=min(Dp[i]\uff0cDp[j]+(h[j]-h[i])^2 +m)(m\u4e3a\u5e38\u6570)$ \u9898\u76ee\u94fe\u63a5\uff1a Frog 3-ICPC Frog 3-Atcoder \u53c2\u8003\u94fe\u63a5\uff1a https://www.cnblogs.com/orzzz/p/7885971.html https://blog.csdn.net/mengxiang000000/article/details/78113980 https://blog.csdn.net/bllsll/article/details/78267029 \u516c\u5f0f\u63a8\u5bfc\uff1a \u6211\u4eec\u5047\u8bbe\u5728\u6c42\u89e3 dp[i] dp[i] \u65f6\uff0c\u5b58\u5728 j,k(j>k) j,k(j>k) \u4f7f\u5f97\u4ece j j \u8f6c\u79fb\u6bd4\u4ece k k \u8f6c\u79fb\u66f4\u4f18\uff0c\u90a3\u4e48\u9700\u8981\u6ee1\u8db3\u6761\u4ef6\uff1a dp[j]+(S[i+1]\u2212S[j])^2+M<dp[k]+(S[i+1]\u2212S[k])^2+M dp[j]+(S[i+1]\u2212S[j])^2+M<dp[k]+(S[i+1]\u2212S[k])^2+M \u5c55\u5f00\u4e0a\u5f0f dp[j]+S[i+1]^2\u22122S[i+1]S[j]+S[j]^2+M<dp[k]+S[i+1]^2\u22122S[i+1]S[k]+S[k]^2+M dp[j]+S[i+1]^2\u22122S[i+1]S[j]+S[j]^2+M<dp[k]+S[i+1]^2\u22122S[i+1]S[k]+S[k]^2+M \u79fb\u9879\u5e76\u6d88\u53bb\u518d\u5408\u5e76\u540c\u7c7b\u9879\u5f97 $dp[j]\u2212dp[k]+S[j] 2\u2212S[k] 2<2S[i+1] (S[j]\u2212S[k]) $ \u628aS[j]\u2212S[k]S[j]\u2212S[k]\u9664\u8fc7\u53bb\uff0c\u5f97\u5230 \\frac{dp[j]\u2212dp[k]+S[j]^2\u2212S[k]^2}{S[j]\u2212S[k]}<2S[i+1] \\frac{dp[j]\u2212dp[k]+S[j]^2\u2212S[k]^2}{S[j]\u2212S[k]}<2S[i+1] \u6211\u4eec\u8bbe f[x]=dp[x]+S[x]^2 f[x]=dp[x]+S[x]^2 \uff0c\u5c31\u5316\u6210\u4e86 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \u5373\u5f53 (j>k) (j>k) \u65f6\uff0c\u82e5 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \uff0c\u5219 j j \u5bf9\u66f4\u65b0 dp[i] dp[i] \u6bd4 k k \u66f4\u65b0 dp[i] dp[i] \u4f18\u3002---\u659c\u7387\u3002 \u5f53\u4e00\u4e2a\u6570\u7684dp\u503c\u6c42\u5b8c\u4e86\uff0c\u5b83\u7684f\u503c\u4e5f\u8ddf\u7740\u786e\u5b9a\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5728\u7a7a\u95f4\u4e2d\u7ed8\u5236\u51fa\u70b9(S[i],f[i])\u3002\u8fd9\u4e2a\u70b9\u4ee3\u8868\u5df2\u7ecf\u6c42\u51fadp\u503c\u7684\u4e00\u4e2a\u70b9\u3002 \u5f53\u6211\u4eec\u8981\u6c42\u89e3dp[t]\u65f6\uff0c\u5982\u679c\u53ef\u7528\u7684\u96c6\u5408\u91cc\u5b58\u5728\u8fd9\u6837\u4e09\u4e2a\u70b9\uff0c\u4f4d\u7f6e\u5173\u7cfb\u5982\u56fe\u6240\u793a\uff1a \u90a3\u4e48\u663e\u7136 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \u8fd9\u65f6\u5019\u4ed6\u4eec\u548c2S[t+1]2S[t+1]\u7684\u5173\u7cfb\u67093\u79cd\uff1a \u00b7 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]}>2S[t+1] \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]}>2S[t+1] \u90a3\u4e48j\u6bd4i\u4f18\uff0ck\u6bd4j\u4f18\u3002 \u00b7 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>2S[t+1]>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>2S[t+1]>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \u90a3\u4e48i\u6bd4j\u4f18\uff0ck\u6bd4j\u4f18\u3002 \u00b7 2S[t+1]>\\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} 2S[t+1]>\\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \u90a3\u4e48i\u6bd4j\u4f18\uff0cj\u6bd4k\u4f18\u3002 \u7efc\u4e0a\uff0c\u4e0d\u7ba1\u4ec0\u4e48\u6837\u7684 S[t+1] S[t+1] \uff0c\u4ecej\u8f6c\u79fb\u90fd\u4e0d\u4f1a\u662f\u6700\u4f73\u65b9\u6848\u3002\u90a3\u4e48\u7528\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u4e00\u4e2a\u51f8\u5305\uff08\u4e0b\u51f8\uff09\uff0c\u6bcf\u52a0\u5165\u4e00\u4e2a\u70b9\u5c31\u5220\u53bb\u4e00\u4e9b\u70b9\uff0c\u4f7f\u5176\u7ef4\u6301\u51f8\u5305\u7684\u5f62\u6001\u3002\u6700\u4f18\u8f6c\u79fb\u4e00\u5b9a\u5728\u8fd9\u4e2a\u51f8\u5305\u4e2d\u3002 \u90a3\u4e48\u6839\u636e\u4e0a\u8ff0\uff0c\u6211\u4eec\u53ef\u4ee5\u6709\u4e24\u4e2a\u63a8\u8bba\uff1a 1. G[j\uff0ck]<=S[i] G[j\uff0ck]<=S[i] \uff0c\u90a3\u4e48\u4f4d\u5b50k\u5c31\u53ef\u4ee5\u88ab\u6dd8\u6c70\u3002 2. G[j\uff0ck]<=G[i\uff0cj] G[j\uff0ck]<=G[i\uff0cj] \uff0c\u90a3\u4e48\u8868\u793aj\u6bd4k\u66f4\u4f18\uff0c\u5e76\u4e14i\u6bd4j\u66f4\u4f18\uff0c\u90a3\u4e48\u4f4d\u5b50j\u662f\u53ef\u4ee5\u88ab\u6dd8\u6c70\u7684\u3002 \u4ee3\u7801\uff1a #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll h [ 200500 ] = { 0 }; ll dp [ 200500 ] = { 0 }; deque < ll > que ; double xielv ( ll i , ll j ) { double ans = ( dp [ i ] + h [ i ] * h [ i ] - dp [ j ] - h [ j ] * h [ j ]) * 1.0 / ( 2 * ( h [ i ] - h [ j ])); return ans ; } int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & h [ i ]); que . push_back ( 1 ); dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { while ( que . size () >= 2 && xielv ( que [ 0 ], que [ 1 ]) <= h [ i ]) que . pop_front (); if ( que . size ()) dp [ i ] = dp [ que [ 0 ]] + ( h [ i ] - h [ que [ 0 ]]) * ( h [ i ] - h [ que [ 0 ]]) + m ; while ( que . size () >= 2 && xielv ( que [ que . size () - 2 ], que [ que . size () - 1 ]) > xielv ( que [ que . size () - 1 ], i )) que . pop_back (); que . push_back ( i ); } cout << dp [ n ] << endl ; } \u8ba1\u7b97\u673a\u56fe\u5f62\u5b66 \u00b6 \u51f8\u5305\u7b97\u6cd5 \u00b6 #include <iostream> #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #define PI 3.1415926535 using namespace std ; struct node { int x , y ; }; node vex [ 1000 ]; //\u5b58\u5165\u7684\u6240\u6709\u7684\u70b9 node stackk [ 1000 ]; //\u51f8\u5305\u4e2d\u6240\u6709\u7684\u70b9 int xx , yy ; bool cmp1 ( node a , node b ) //\u6392\u5e8f\u627e\u7b2c\u4e00\u4e2a\u70b9 { if ( a . y == b . y ) return a . x < b . x ; else return a . y < b . y ; } int cross ( node a , node b , node c ) //\u8ba1\u7b97\u53c9\u79ef { return ( b . x - a . x ) * ( c . y - a . y ) - ( c . x - a . x ) * ( b . y - a . y ); } double dis ( node a , node b ) //\u8ba1\u7b97\u8ddd\u79bb { return sqrt (( a . x - b . x ) * ( a . x - b . x ) * 1.0 + ( a . y - b . y ) * ( a . y - b . y )); } bool cmp2 ( node a , node b ) //\u6781\u89d2\u6392\u5e8f\u53e6\u4e00\u79cd\u65b9\u6cd5\uff0c\u901f\u5ea6\u5feb { if ( atan2 ( a . y - yy , a . x - xx ) != atan2 ( b . y - yy , b . x - xx )) return ( atan2 ( a . y - yy , a . x - xx )) < ( atan2 ( b . y - yy , b . x - xx )); return a . x < b . x ; } bool cmp ( node a , node b ) //\u6781\u89d2\u6392\u5e8f { int m = cross ( vex [ 0 ], a , b ); if ( m > 0 ) return 1 ; else if ( m == 0 && dis ( vex [ 0 ], a ) - dis ( vex [ 0 ], b ) <= 0 ) return 1 ; else return 0 ; /*if(m==0) return dis(vex[0],a)-dis(vex[0],b)<=0?true:false; else return m>0?true:false;*/ } int main () { int t , L ; while ( ~ scanf ( \"%d\" , & t ), t ) { int i ; for ( i = 0 ; i < t ; i ++ ) { scanf ( \"%d%d\" , & vex [ i ]. x , & vex [ i ]. y ); } if ( t == 1 ) printf ( \"%.2f \\n \" , 0.00 ); else if ( t == 2 ) printf ( \"%.2f \\n \" , dis ( vex [ 0 ], vex [ 1 ])); else { memset ( stackk , 0 , sizeof ( stackk )); sort ( vex , vex + t , cmp1 ); stackk [ 0 ] = vex [ 0 ]; xx = stackk [ 0 ]. x ; yy = stackk [ 0 ]. y ; sort ( vex + 1 , vex + t , cmp2 ); //cmp2\u662f\u66f4\u5feb\u7684\uff0ccmp\u66f4\u5bb9\u6613\u7406\u89e3 stackk [ 1 ] = vex [ 1 ]; //\u5c06\u51f8\u5305\u4e2d\u7684\u7b2c\u4e24\u4e2a\u70b9\u5b58\u5165\u51f8\u5305\u7684\u7ed3\u6784\u4f53\u4e2d int top = 1 ; //\u6700\u540e\u51f8\u5305\u4e2d\u62e5\u6709\u70b9\u7684\u4e2a\u6570 for ( i = 2 ; i < t ; i ++ ) { while ( i >= 1 && cross ( stackk [ top -1 ], stackk [ top ], vex [ i ]) < 0 ) //\u5bf9\u4f7f\u7528\u6781\u89d2\u6392\u5e8f\u7684i>=1\u6709\u65f6\u53ef\u4ee5\u4e0d\u7528\uff0c\u4f46\u52a0\u4e0a\u603b\u662f\u597d\u7684 top -- ; stackk [ ++ top ] = vex [ i ]; //\u63a7\u5236<0\u6216<=0\u53ef\u4ee5\u63a7\u5236\u91cd\u70b9\uff0c\u5171\u7ebf\u7684\uff0c\u5177\u4f53\u89c6\u9898\u76ee\u800c\u5b9a\u3002 } double s = 0 ; //for(i=1; i<=top; i++)//\u8f93\u51fa\u51f8\u5305\u4e0a\u7684\u70b9 //cout<<stackk[i].x<<\" \"<<stackk[i].y<<endl; for ( i = 1 ; i <= top ; i ++ ) //\u8ba1\u7b97\u51f8\u5305\u7684\u5468\u957f s += dis ( stackk [ i -1 ], stackk [ i ]); s += dis ( stackk [ top ], vex [ 0 ]); //\u6700\u540e\u4e00\u4e2a\u70b9\u548c\u7b2c\u4e00\u4e2a\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb /*s+=2*PI*L; int ans=s+0.5;//\u56db\u820d\u4e94\u5165 printf(\"%d\\n\",ans);*/ printf ( \"%.2lf \\n \" , s ); } } } \u6c42\u4efb\u610f\u591a\u8fb9\u5f62\u9762\u79ef \u00b6 #include <bits/stdc++.h> using namespace std ; struct Point { double x , y ; } p [ 100500 ]; int n ; double polygonarea () { int i , j ; double area = 0 ; for ( i = 1 ; i <= n ; ++ i ){ if ( i < n ) j = i + 1 ; else j = 1 ; area += p [ i ]. x * p [ j ]. y ; area -= p [ i ]. y * p [ j ]. x ; } area /= 2.0 ; return ( area < 0 ?- area : area ); } int main () { while ( scanf ( \"%d\" , & n ) != EOF && n != 0 ) { for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%lf%lf\" , & p [ i ]. x , & p [ i ]. y ); printf ( \"%.1f \\n \" , polygonarea ()); } } \u7ebf\u6bb5\u6811+\u626b\u63cf\u7ebf\u6c42\u6b63\u65b9\u5f62\u989c\u8272\u53cd\u8f6c \u00b6 \u8f93\u5165\uff1a 1 5 2 2 4 1 3 1 5 3 5 \u4ee3\u88681\u7ec4\u6d4b\u8bd5\u6837\u4f8b\uff0c\u7ed9\u5b9a5*2\u7684\u6b63\u65b9\u5f62\uff0c\u5c062<=x<=4&&1<=y<=3\u7684\u8303\u56f4\u5185\u7684\u5c0f\u6b63\u65b9\u5f62\u8fdb\u884c\u9ed1\u767d\u53cd\u8f6c\uff0c\u6c42\u6700\u7ec8\u9ed1\u8272\u6b63\u65b9\u5f62\u7684\u4e2a\u6570\uff0c\u7b54\u6848\u4e3a18. #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int h , a , b , num ; }; int mark [ 100500 ] = { 0 }; int sum [ 100500 ] = { 0 }; node edge [ 100500 ] = { 0 }; bool cmp ( node a , node b ) { if ( a . h == b . h ) return a . num > b . num ; else return a . h < b . h ; } int nodeupdate ( int root , int l , int r , ll num ) { mark [ root ] ^= 1 ; sum [ root ] = r - l + 1 - sum [ root ]; } int pushdown ( int root , int l , int r ) { if ( mark [ root ] == 0 ) return 0 ; int mid = ( l + r ) / 2 ; nodeupdate ( 2 * root , l , mid , mark [ root ]); nodeupdate ( 2 * root + 1 , mid + 1 , r , mark [ root ]); mark [ root ] = 0 ; } int update ( int root , int l , int r , int L , int R , ll num ) { if ( l >= L && r <= R ) { nodeupdate ( root , l , r , num ); return 0 ; } pushdown ( root , l , r ); int mid = ( l + r ) / 2 ; if ( mid >= L ) update ( root * 2 , l , mid , L , R , num ); if ( mid < R ) update ( root * 2 + 1 , mid + 1 , r , L , R , num ); sum [ root ] = sum [ 2 * root ] + sum [ 2 * root + 1 ]; } int main () { int t , cnt ; scanf ( \"%d\" , & t ); while ( t -- ) { memset ( sum , 0 , sizeof ( sum )); memset ( mark , 0 , sizeof ( mark )); int n , m , ans = 0 ; cnt = 0 ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int x1 , y1 , x2 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & x2 , & y1 , & y2 ); edge [ cnt ++ ] = node { y1 , x1 , x2 , 1 }; edge [ cnt ++ ] = node { y2 , x1 , x2 , -1 }; } sort ( edge , edge + cnt , cmp ); for ( int i = 1 , j = 0 ; i <= n ; i ++ ) { while ( j < cnt && edge [ j ]. h <= i && edge [ j ]. num == 1 ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } ans += sum [ 1 ]; while ( j < cnt && edge [ j ]. h <= i ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } } cout << ans << endl ; } return 0 ; } \u7ebf\u6bb5\u6811\u79bb\u6563\u5316\u6c42\u9762\u79ef\u7684\u5e76\uff1a #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll n ; ll s [ 400500 ] = { 0 }; ll len [ 400500 ] = { 0 }; ll x [ 400500 ] = { 0 }; unordered_map < ll , ll > mpx ; void push_up ( ll t , ll l , ll r ) { if ( s [ t ]) len [ t ] = x [ r + 1 ] - x [ l ]; else if ( l == r ) len [ t ] = 0 ; else len [ t ] = len [ 2 * t + 1 ] + len [ 2 * t ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { s [ t ] += add ; push_up ( t , L , R ); return ; } ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t , L , R ); } struct node1 { ll l , r , h , d ; }; node1 edge [ 200500 ] = { 0 }; bool cmp ( node1 a , node1 b ) { return a . h < b . h ; } int main () { scanf ( \"%lld\" , & n ); ll cnt = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll x1 , x2 , y1 , y2 ; scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); x [ ++ cnt ] = x1 , edge [ cnt ] = { x1 , x2 , y1 , 1 }; x [ ++ cnt ] = x2 , edge [ cnt ] = { x1 , x2 , y2 , -1 }; } sort ( x + 1 , x + cnt + 1 ); sort ( edge + 1 , edge + cnt + 1 , cmp ); ll m = unique ( x + 1 , x + cnt + 1 ) - x -1 ; for ( int i = 1 ; i <= m ; i ++ ) mpx [ x [ i ]] = i ; ll ans = 0 ; for ( ll i = 1 ; i < cnt ; i ++ ) { ll l = mpx [ edge [ i ]. l ], r = mpx [ edge [ i ]. r ]; update ( 1 , l , r -1 , 1 , m , edge [ i ]. d ); ans += len [ 1 ] * ( edge [ i + 1 ]. h - edge [ i ]. h ); } cout << ans << endl ; } \u535a\u5f08\u8bba \u00b6 \u5df4\u4ec0\u535a\u5f08 \u00b6 \u53ea\u6709\u4e00\u5806n\u4e2a\u7269\u54c1\uff0c\u4e24\u4e2a\u4eba\u4ece\u8f6e\u6d41\u4e2d\u53d6\u51fa\uff081~m\uff09\u4e2a\uff1b\u6700\u540e\u53d6\u5149\u8005\u80dc\u3002 \u82e5n=k*(m+1) \u90a3\u4e48\u5148\u53d6\u8005\u5fc5\u8f93\u3002 int Bash_Game ( int n , int m ) //\u662f\u5426\u5148\u624b\u6709\u5fc5\u8d62\u7b56\u7565 { if ( n % ( m + 1 ) != 0 ) return 1 ; return 0 ; } \u5c3c\u59c6\u535a\u5f08 \u00b6 \u6709\u82e5\u5e72\u5806\u5404\u82e5\u5e72\u4e2a\u7269\u54c1\uff0c\u4e24\u4e2a\u4eba\u8f6e\u6d41\u4ece\u67d0\u4e00\u5806\u53d6\u4efb\u610f\u591a\u7684\u7269\u54c1\uff0c\u89c4\u5b9a\u6bcf\u6b21\u81f3\u5c11\u53d6\u4e00\u4e2a\uff0c\u591a\u8005\u4e0d\u9650\uff0c\u6700\u540e\u53d6\u5149\u8005\u5f97\u80dc\u3002 XOR \u5224\u65ad: int Nimm_Game ( int n ) //\u5047\u8bben\u4e2a\u6570\u5b58\u5728\u6570\u7ec4f[]\u4e2d,\u6709\u5fc5\u80dc\u7b56\u7565\u8fd4\u56de1 { int flag = 0 ; for ( int i = 1 ; i <= n ; i ++ ) flag ^= f [ i ]; if ( flag ) return 1 ; return 0 ; } \u5a01\u4f50\u592b\u535a\u5955 \u00b6 \u6709\u4e24\u5806\u5404\u82e5\u5e72\u4e2a\u7269\u54c1\uff0c\u4e24\u4e2a\u4eba\u8f6e\u6d41\u4ece\u67d0\u4e00\u5806\u6216\u540c\u65f6\u4ece\u4e24\u5806\u4e2d\u53d6\u540c\u6837\u591a\u7684\u7269\u54c1\uff0c\u89c4\u5b9a\u6bcf\u6b21\u81f3\u5c11\u53d6\u4e00\u4e2a\uff0c\u591a\u8005\u4e0d\u9650\uff0c\u6700\u540e\u53d6\u5149\u8005\u5f97\u80dc\u3002 \u5224\u65ad\u662f\u5426\u4e3a\u5947\u5f02\u5c40\u52bf \u8bbex= k=[a*x]\uff0c\u5411\u4e0a\u53d6\u6574 \u5982\u679ca+k=b\uff0c\u5219\uff08a\uff0cb\uff09\u4e3a\u5947\u5f02\u5c40\u52bf\uff0c\u540e\u624b\u80dc\uff0c\u53cd\u4e4b\u4e3a\u5148\u624b\u80dc \u5bf9\u5e94\u7684\u4ee3\u7801\u5728\u8fd9\u91cc\uff1a int Wythoff_Game ( int a , int b ) { if ( a > b ) swap ( a , b ); double x = ( sqrt ( 5.0 ) -1.0 ) / 2.0 ; int k = ceil ( 1.0 * a * x ); if ( a + k == b ) return 0 ; //\u5947\u5f02\u5c40\u52bf\uff0c\u540e\u624b\u80dc\uff01 else return 1 ; //\u975e\u5947\u5f02\u5c40\u52bf\uff0c\u5148\u624b\u80dc\uff01 } SG\u51fd\u6570\u548cNIM\u535a\u5f08 \u00b6 \u9898\u76ee\u9898\u89e3 \u9898\u76ee\u94fe\u63a5 SG\u51fd\u6570\u8be6\u89e3 #include <bits/stdc++.h> using namespace std ; bool vis [ 300 ] = { 0 }; int sg [ 110 ][ 110 ] = { 0 }; void init () { for ( int i = 0 ; i <= 100 ; i ++ ) sg [ i ][ i ] = sg [ i ][ 0 ] = sg [ 0 ][ i ] = 199 ; for ( int i = 0 ; i <= 100 ; i ++ ) { for ( int j = 0 ; j <= 100 ; j ++ ) { if ( i == j || i == 0 || j == 0 ) continue ; memset ( vis , 0 , sizeof ( vis )); for ( int a = 0 ; a < i ; a ++ ) vis [ sg [ a ][ j ]] = 1 ; for ( int b = 0 ; b < j ; b ++ ) vis [ sg [ i ][ b ]] = 1 ; for ( int c = min ( i , j ); c >= 1 ; c -- ) vis [ sg [ i - c ][ j - c ]] = 1 ; for ( int k = 0 ;; k ++ ) { if ( ! vis [ k ]) { sg [ i ][ j ] = k ; break ; } } } } } int main () { int n ; scanf ( \"%d\" , & n ); int a , b ; int nim = 0 ; init (); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d%d\" , & a , & b ); if ( a == b ) { printf ( \"Y \\n \" ); return 0 ; } nim ^= sg [ a ][ b ]; } if ( nim != 0 ) printf ( \"Y \\n \" ); else printf ( \"N \\n \" ); }","title":"ICPC\u6a21\u677f"},{"location":"icpc/#_1","text":"","title":"\u6742\u9879"},{"location":"icpc/#o2","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #define inf1 0x3f3f3f3f #define inf2 0x3f3f3f3f3f3f3f3f const double Pi = acos ( -1 ); std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( 0 ); cout << fixed << setprecision ( 20 ) << ans << endl ;","title":"\u5feb\u8bfb&amp;O2\u4f18\u5316"},{"location":"icpc/#__int128","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; __int128 int128read () { __int128 x = 0 ; int flag = 1 ; string a ; cin >> a ; for ( char c : a ) { if ( c == '-' ) flag = -1 ; else x = x * 10 + c - '0' ; } return flag * x ; } void int128print ( __int128 x ) { if ( x < 0 ) { putchar ( '-' ); x =- x ; } if ( x > 9 ) int128print ( x / 10 ); putchar ( x % 10 + '0' ); } int main () { __int128 a = int128read (), b = int128read (); int128print ( a + b ); }","title":"__int128 \u8f93\u5165\u548c\u8f93\u51fa"},{"location":"icpc/#java-acm","text":"import java.io.* ; import java.math.* ; import java.util.* ; public class Main { public static void main ( String args [] ) { //BigDecimal\u5927\u6570Double\u7c7b //\u8bfb\u5165 Scanner cin = new Scanner ( new BufferedInputStream ( System . in )); int a ; double b ; BigInteger c ; String d ; a = cin . nextInt (); b = cin . nextDouble (); c = cin . nextBigInteger (); d = cin . nextLine (); // \u6bcf\u79cd\u7c7b\u578b\u90fd\u6709\u76f8\u5e94\u7684\u8f93\u5165\u51fd\u6570. System . out . printf ( \"\u8f93\u5165\u7684\u4e3a%d %f %s %s\\n\" , a , b , c . toString (), d ); c = cin . nextBigInteger ( 2 ); //\u5927\u6570\u4ee52\u8fdb\u5236\u8bfb\u5165 String tmp = c . toString ( 2 ); ///\u5c06\u5927\u6570\u4ee5\u4e8c\u8fdb\u5236\u5f62\u5f0f\u8f93\u51fa System . out . print ( 1 ); // cout << \u2026; System . out . println ( 1 ); // cout << \u2026 << endl; System . out . printf ( \"%d\" , 1 ); // \u4e0eC\u4e2d\u7684printf\u7528\u6cd5\u7c7b\u4f3c. ///\u5b57\u7b26\u4e32\u5904\u7406 String st = \"abcdefg\" ; System . out . println ( st . charAt ( 0 )); // st.charAt(i)\u5c31\u76f8\u5f53\u4e8est[i]. char [] ch ; ch = st . toCharArray (); // \u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u5b57\u7b26\u6570\u7ec4. for ( int i = 0 ; i < ch . length ; i ++ ) ch [ i ] += 1 ; System . out . println ( ch ); // \u8f93\u5165\u4e3a\u201cbcdefgh\u201d. if ( st . startsWith ( \"a\" )) // \u5982\u679c\u5b57\u7b26\u4e32\u4ee5'0'\u5f00\u5934. st = st . substring ( 1 ); // \u5219\u4ece\u7b2c1\u4f4d\u5f00\u59cbcopy(\u5f00\u5934\u4e3a\u7b2c0\u4f4d). ///\u8fdb\u5236\u8f6c\u5316 int num = 15 , base = 2 ; System . out . printf ( \"15\u8f6c2\u8fdb\u5236\u4e3a%s\\n\" , Integer . toString ( num , base )); st = \"1111\" ; System . out . printf ( \"2\u8fdb\u5236\u76841111\u8f6c10\u8fdb\u5236\u4e3a%d\\n\" , Integer . parseInt ( st , base )); // \u628ast\u5f53\u505abase\u8fdb\u5236\uff0c\u8f6c\u621010\u8fdb\u5236\u7684int(parseInt\u6709\u4e24\u4e2a\u53c2\u6570,\u7b2c\u4e00\u4e2a\u4e3a\u8981\u8f6c\u7684\u5b57\u7b26\u4e32,\u7b2c\u4e8c\u4e2a\u4e3a\u8fdb\u5236). BigInteger m = new BigInteger ( st , base ); // st\u662f\u5b57\u7b26\u4e32\uff0cbase\u662fst\u7684\u8fdb\u5236. ///\u6392\u5e8f int n = cin . nextInt (); Integer [] arr = new Integer [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ]= cin . nextInt (); Arrays . sort ( arr , new Comparator < Integer > () { @Override public int compare ( Integer o1 , Integer o2 ) { return o2 - o1 ; ///\u4ece\u5927\u5230\u5c0f\u6392\u5e8f } }); for ( int i = 0 ; i < n ; i ++ ) System . out . printf ( \"%d \" , arr [ i ] ); System . out . println (); ///\u6e05\u7a7a Arrays . fill ( arr , 5 ); for ( int i = 0 ; i < n ; i ++ ) System . out . printf ( \"%d \" , arr [ i ] ); System . out . println (); ///\u4e8c\u5206\u67e5\u627e System . out . println ( Arrays . binarySearch ( arr , 5 )); ///\u5982\u679ckey\u5728\u6570\u7ec4\u4e2d\uff0c\u5219\u8fd4\u56de\u641c\u7d22\u503c\u7684\u7d22\u5f15\uff1b\u5426\u5219\u8fd4\u56de-1\u6216\u8005\u201d-\u201c(\u63d2\u5165\u70b9)\u3002 ///\u63d2\u5165\u70b9\u662f\u7d22\u5f15\u952e\u5c06\u8981\u63d2\u5165\u6570\u7ec4\u7684\u90a3\u4e00\u70b9\uff0c\u5373\u7b2c\u4e00\u4e2a\u5927\u4e8e\u8be5\u952e\u7684\u5143\u7d20\u7d22\u5f15\u3002 } }","title":"java ACM \u57fa\u7840"},{"location":"icpc/#java-biginteger","text":"import java.io.* ; import java.math.* ; import java.util.* ; public class Main { public static void main ( String args [] ) { Scanner cin = new Scanner ( System . in ); while ( cin . hasNext ()) ///\u76f8\u5f53\u4e8e scanf()!=EOF { BigInteger a , b , c ; //\u5927\u6570\u521d\u59cb\u5316 //1.\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32 BigInteger interNum1 = new BigInteger ( \"1011100111\" , 2 ); //2.\u5341\u8fdb\u5236\u5b57\u7b26\u4e32 BigInteger interNum2 = new BigInteger ( \"123456\" ); //3.\u5341\u8fdb\u5236\u6570\u5b57 BigInteger interNum3 = BigInteger . valueOf ( 8 ); //\u5927\u6570\u8bfb\u5165 a = cin . nextBigInteger (); b = cin . nextBigInteger (); //\u57fa\u672c\u8fd0\u7b97 //1.\u628aa\u4e0eb\u76f8\u52a0\u5e76\u8d4b\u7ed9c c = a . add ( b ); //2.\u628aa\u4e0eb\u76f8\u51cf\u5e76\u8d4b\u7ed9c c = a . subtract ( b ); //3.\u628aa\u4e0eb\u76f8\u4e58\u5e76\u8d4b\u7ed9c c = a . multiply ( b ); //4.\u628aa\u4e0eb\u76f8\u9664\u5e76\u8d4b\u7ed9c c = a . divide ( b ); //5.\u53d6\u6a21\uff0c(\u9700 b > 0\uff0c\u5426\u5219\u51fa\u73b0\u5f02\u5e38\uff1aArithmeticException(\"BigInteger: modulus not positive\")) c = a . mod ( b ); //6.\u6c42\u4f59 c = a . remainder ( b ); //7.\u76f8\u5f53\u4e8ea^b c = a . pow ( 2 ); //8.\u6839\u636e\u8be5\u6570\u503c\u662f\u5c0f\u4e8e\u3001\u7b49\u4e8e\u3001\u6216\u5927\u4e8ea \u8fd4\u56de -1\u30010 \u6216 1 int ans1 = a . compareTo ( b ); //9.\u5224\u65ad\u4e24\u6570\u662f\u5426\u76f8\u7b49\uff0c\u4e5f\u53ef\u4ee5\u7528compareTo\u6765\u4ee3\u66ff boolean ans2 = a . equals ( b ); //10.\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c c = a . min ( b ); c = a . max ( b ); //\u7c7b\u578b\u8f6c\u6362 //1.\u8f6c\u6362\u4e3abigNum\u7684\u4e8c\u8fdb\u5236\u8865\u7801\u5f62\u5f0f byte [] num1 = a . toByteArray (); //2.\u8f6c\u6362\u4e3abigNum\u7684\u5341\u8fdb\u5236\u5b57\u7b26\u4e32\u5f62\u5f0f String num2 = a . toString (); //3.\u8f6c\u6362\u4e3abigNum\u7684radix\u8fdb\u5236\u5b57\u7b26\u4e32\u5f62\u5f0f String num3 = a . toString ( 2 ); //4.\u5c06bigNum\u8f6c\u6362\u4e3aint int num4 = a . intValue (); //5.\u5c06bigNum\u8f6c\u6362\u4e3along long num5 = a . longValue (); //6.\u5c06bigNum\u8f6c\u6362\u4e3afloat float num6 = a . floatValue (); //7.\u5c06bigNum\u8f6c\u6362\u4e3adouble double num7 = a . doubleValue (); //\u4e8c\u8fdb\u5236\u8fd0\u7b97 //1.\u4e0e\uff1aa&b BigInteger bigNum1 = a . and ( b ); //2.\u6216\uff1aa|b BigInteger bigNum2 = a . or ( b ); //3.\u5f02\u6216\uff1aa^b BigInteger bigNum3 = a . xor ( b ); //4.\u53d6\u53cd\uff1a~a BigInteger bigNum4 = a . not (); //5.\u5de6\u79fbn\u4f4d\uff1a (a << n) BigInteger bigNum5 = a . shiftLeft ( 3 ); //6.\u53f3\u79fbn\u4f4d\uff1a (a >> n) BigInteger bigNum6 = a . shiftRight ( 3 ); } } }","title":"java BigInteger \u8fd0\u7b97"},{"location":"icpc/#java-bigdecimal","text":"import java.io.* ; import java.math.* ; import java.util.* ; public class Main { public static void main ( String args [] ) { Scanner cin = new Scanner ( System . in ); while ( cin . hasNext ()) ///\u76f8\u5f53\u4e8e scanf()!=EOF { BigDecimal a , b , c ; //\u5927\u6570\u521d\u59cb\u5316 //1.\u5341\u8fdb\u5236\u5b57\u7b26\u4e32 BigDecimal interNum1 = new BigDecimal ( \"0.005\" ); //2.\u5341\u8fdb\u5236\u6570\u5b57 BigDecimal interNum2 = new BigDecimal ( 0.000005 ); BigDecimal interNum3 = BigDecimal . valueOf ( 0.000005 ); //\u5927\u6570\u8bfb\u5165 a = cin . nextBigDecimal (); b = cin . nextBigDecimal (); //\u5927\u6570\u4fdd\u7559\u5c0f\u6570\u4f4d\u8f93\u51fa BigDecimal d = a . setScale ( 10 , RoundingMode . HALF_UP ); //\u4fdd\u7559\u5341\u4f4d\u5c0f\u6570 System . out . println ( d ); //\u57fa\u672c\u8fd0\u7b97 //1.\u628aa\u4e0eb\u76f8\u52a0\u5e76\u8d4b\u7ed9c c = a . add ( b ); //2.\u628aa\u4e0eb\u76f8\u51cf\u5e76\u8d4b\u7ed9c c = a . subtract ( b ); //3.\u628aa\u4e0eb\u76f8\u4e58\u5e76\u8d4b\u7ed9c c = a . multiply ( b ); //4.\u628aa\u4e0eb\u76f8\u9664\u5e76\u8d4b\u7ed9c c = a . divide ( b , 10 , BigDecimal . ROUND_UP ); //\u820d\u5165\u8fdc\u79bb\u96f6\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_DOWN ); //\u63a5\u8fd1\u96f6\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_CEILING ); //\u63a5\u8fd1\u6b63\u65e0\u7a77\u5927\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_FLOOR ); //\u63a5\u8fd1\u8d1f\u65e0\u7a77\u5927\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_HALF_UP ); //\u5411\u201c\u6700\u63a5\u8fd1\u7684\u201d\u6570\u5b57\u820d\u5165\uff0c\u5982\u679c\u4e0e\u4e24\u4e2a\u76f8\u90bb\u6570\u5b57\u7684\u8ddd\u79bb\u76f8\u7b49\uff0c\u5219\u4e3a\u5411\u4e0a\u820d\u5165\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_HALF_DOWN ); //\u5411\u201c\u6700\u63a5\u8fd1\u7684\u201d\u6570\u5b57\u820d\u5165\uff0c\u5982\u679c\u4e0e\u4e24\u4e2a\u76f8\u90bb\u6570\u5b57\u7684\u8ddd\u79bb\u76f8\u7b49\uff0c\u5219\u4e3a\u4e0a\u820d\u5165\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_HALF_EVEN ); //\u5411\u201c\u6700\u63a5\u8fd1\u7684\u201d\u6570\u5b57\u820d\u5165\uff0c\u5982\u679c\u4e0e\u4e24\u4e2a\u76f8\u90bb\u6570\u5b57\u7684\u8ddd\u79bb\u76f8\u7b49\uff0c\u5219\u5411\u76f8\u90bb\u7684\u5076\u6570\u820d\u5165\u3002 //5.\u6c42\u4f59 c = a . remainder ( b ); //6.\u76f8\u5f53\u4e8ea^b c = a . pow ( 2 ); //7.\u6839\u636e\u8be5\u6570\u503c\u662f\u5c0f\u4e8e\u3001\u7b49\u4e8e\u3001\u6216\u5927\u4e8ea \u8fd4\u56de -1\u30010 \u6216 1 int ans1 = a . compareTo ( b ); //8.\u5224\u65ad\u4e24\u6570\u662f\u5426\u76f8\u7b49\uff0c\u4e5f\u53ef\u4ee5\u7528compareTo\u6765\u4ee3\u66ff boolean ans2 = a . equals ( b ); //9.\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c c = a . min ( b ); c = a . max ( b ); //10.\u7edd\u5bf9\u503c c = a . abs (); //\u7c7b\u578b\u8f6c\u6362 //1.\u8f6c\u6362\u4e3abigNum\u7684\u5341\u8fdb\u5236\u5b57\u7b26\u4e32\u5f62\u5f0f String num2 = a . toString (); //2.\u5c06bigNum\u8f6c\u6362\u4e3aint int num4 = a . intValue (); //3.\u5c06bigNum\u8f6c\u6362\u4e3along long num5 = a . longValue (); //4.\u5c06bigNum\u8f6c\u6362\u4e3afloat float num6 = a . floatValue (); //5.\u5c06bigNum\u8f6c\u6362\u4e3adouble double num7 = a . doubleValue (); } } }","title":"java BigDecimal \u8fd0\u7b97"},{"location":"icpc/#_2","text":"int getWeek ( int y , int m , int d ) { if ( m == 1 || m == 2 ) { m += 12 ; y -- ; } int week = ( d + 1 + 2 * m + 3 * ( m + 1 ) / 5 + y + y / 4 - y / 100 + y / 400 ) % 7 ; return week ; }","title":"\u5224\u65ad\u5468\u51e0"},{"location":"icpc/#_3","text":"","title":"\u7ec4\u5408\u6570\u5947\u5076\u5224\u65ad"},{"location":"icpc/#_4","text":"","title":"\u56fe\u8bba"},{"location":"icpc/#prim","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; struct node { int to , val ; }; vector < node > v [ 100500 ]; struct node1 { int now , val ; bool operator < ( const node1 & a ) const { return a . val < val ; } }; priority_queue < node1 > que ; int dis [ 100500 ] = { 0 }; void prim () { memset ( dis , -1 , sizeof ( dis )); que . push ({ 1 , 0 }); while ( ! que . empty ()) { node1 now = que . top (); que . pop (); if ( dis [ now . now ] != -1 ) continue ; dis [ now . now ] = now . val ; for ( int i = 0 ; i < v [ now . now ]. size (); i ++ ) { int to = v [ now . now ][ i ]. to ; int val = v [ now . now ][ i ]. val ; if ( dis [ to ] != -1 ) continue ; que . push ({ to , val }); } } } int main () { int n , m , from , to , val ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d%d\" , & from , & to , & val ); v [ from ]. push_back ({ to , val }); v [ to ]. push_back ({ from , val }); } prim (); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { if ( dis [ i ] == -1 ) return 0 * puts ( \"orz\" ); ///\u4e0d\u8fde\u901a ans += dis [ i ]; } cout << ans << endl ; } ```` #### SPFA\u5224\u65ad\u8d1f\u73af ``` c ++ #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <queue> #include <algorithm> #define INF 0x3f3f3f3f using namespace std ; const int MAXN = 5500 ; int n , m , w ; struct Edge { int v , w , next ; } edge [ MAXN ]; int head [ MAXN ], dis [ MAXN ], vis [ MAXN ], t ; void Init () { memset ( head , -1 , sizeof ( head )); t = 0 ; } void Add_edge ( int u , int v , int w ) { edge [ t ]. v = v ; edge [ t ]. w = w ; edge [ t ]. next = head [ u ]; head [ u ] = t ++ ; } bool SPFA () { int mark [ MAXN ]; //\u8bb0\u5f55\u6bcf\u4e2a\u70b9\u5982\u961f\u5217\u7684\u6b21\u6570 for ( int i = 1 ; i <= n ; i ++ ) { mark [ i ] = 0 ; dis [ i ] = INF ; vis [ i ] = 0 ; } queue < int > q ; q . push ( 1 ); //\u6211\u4eec\u53ea\u9700\u8981\u5224\u65ad\u8d1f\u73af\uff0c\u968f\u4fbf\u627e\u4e00\u4e2a\u8d77\u70b9\u5c31\u597d dis [ 1 ] = 0 ; vis [ 1 ] = 1 ; //\u5165\u961f\u5217 mark [ 1 ] ++ ; while ( ! q . empty ()) { int u = q . front (); q . pop (); vis [ u ] = 0 ; //\u51fa\u961f\u5217 for ( int i = head [ u ]; i != -1 ; i = edge [ i ]. next ) { int v = edge [ i ]. v ; if ( dis [ v ] > dis [ u ] + edge [ i ]. w ) { dis [ v ] = dis [ u ] + edge [ i ]. w ; if ( ! vis [ v ]) //\u4e0d\u5728\u961f\u5217\u4e2d\u7684\u65f6\u5019\u51fa\u961f { q . push ( v ); mark [ v ] ++ ; vis [ v ] = 1 ; } if ( mark [ v ] >= n ) //\u5982\u679c\u4e0d\u5b58\u5728\u8d1f\u73af\uff0c\u90a3\u4e48\u6700\u591a\u66f4\u65b0n-1\u6b21\u5c31\u53ef\u4ee5\u5f97\u5230\u6700\u7ec8\u7684\u7b54\u6848\uff0c\u56e0\u4e3a\u4e00\u6b21\u6700\u5c11\u66f4\u65b0\u4e00\u4e2a\u8282\u70b9\uff0c\u90a3\u4e48\u5982\u679c\u51fa\u73b0\u4e86\u66f4\u65b0n\u6b21\uff0c\u90a3\u4e48\u5c31\u4e00\u5b9a\u51fa\u73b0\u4e86\u8d1f\u73af return false ; } } } return true ; } int main () { int T ; scanf ( \"%d\" , & T ); while ( T -- ) { Init (); int u , v , z ; scanf ( \"%d%d%d\" , & n , & m , & w ); for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d%d\" , & u , & v , & z ); Add_edge ( u , v , z ); Add_edge ( v , u , z ); } for ( int i = 0 ; i < w ; i ++ ) { scanf ( \"%d%d%d\" , & u , & v , & z ); Add_edge ( u , v , - z ); } if ( ! SPFA ()) printf ( \"YES \\n \" ); else printf ( \"NO \\n \" ); } return 0 ; }","title":"\u5806\u4f18\u5316prim\u7b97\u6cd5"},{"location":"icpc/#dijikastrak","text":"#include <iostream> #include <cstdio> #include <cstring> #include <queue> using namespace std ; const int INF = 0x3f3f3f3f ; const int MAX = 1005 ; int n , m ; int start , end , k ; struct Edge { int w ; int to ; int next ; }; Edge e [ 100005 ]; int head [ MAX ], edgeNum ; int dis [ MAX ]; //dis[i]\u8868\u793a\u4ecei\u70b9\u5230end\u7684\u6700\u77ed\u8ddd\u79bb bool vis [ MAX ]; int cnt [ MAX ]; vector < Edge > opp_Graph [ MAX ]; struct Node { int f , g ; //f = g+dis[v] int v ; //\u5f53\u524d\u5230\u8fbe\u7684\u8282\u70b9 Node ( int a , int b , int c ) : f ( a ), g ( b ), v ( c ){} bool operator < ( const Node & a ) const { return a . f < f ; } }; void addEdge ( int from , int to , int w ) { e [ edgeNum ]. to = to ; e [ edgeNum ]. w = w ; e [ edgeNum ]. next = head [ from ]; head [ from ] = edgeNum ++ ; } void dijikastra ( int start ) { int i ; memset ( vis , 0 , sizeof ( vis )); for ( i = 1 ; i <= n ; i ++ ) dis [ i ] = INF ; dis [ start ] = 0 ; priority_queue < Node > que ; que . push ( Node ( 0 , 0 , start )); Node next ( 0 , 0 , 0 ); while ( ! que . empty ()) { Node now = que . top (); que . pop (); if ( vis [ now . v ]) //\u4ece\u96c6\u5408T\u4e2d\u9009\u53d6\u5177\u6709\u6700\u77ed\u8ddd\u79bb\u7684\u8282\u70b9 continue ; vis [ now . v ] = true ; //\u6807\u8bb0\u8282\u70b9\u5df2\u4ece\u96c6\u5408T\u52a0\u5165\u5230\u96c6\u5408S\u4e2d for ( i = 0 ; i < opp_Graph [ now . v ]. size (); i ++ ) //\u66f4\u65b0\u4ece\u6e90\u70b9\u5230\u5176\u5b83\u8282\u70b9(\u96c6\u5408T\u4e2d)\u7684\u6700\u77ed\u8ddd\u79bb { Edge edge = opp_Graph [ now . v ][ i ]; if ( ! vis [ edge . to ] && dis [ now . v ] + edge . w < dis [ edge . to ]) //\u52a0\u4e0d\u52a0\u524d\u9762\u7684\u5224\u65ad\u65e0\u6240\u8c13 { dis [ edge . to ] = dis [ now . v ] + edge . w ; next . f = dis [ edge . to ]; next . v = edge . to ; que . push ( next ); } } } } int A_Star () { int i ; priority_queue < Node > que ; if ( dis [ start ] == INF ) return -1 ; que . push ( Node ( dis [ start ], 0 , start )); Node next ( 0 , 0 , 0 ); while ( ! que . empty ()) { Node now = que . top (); que . pop (); cnt [ now . v ] ++ ; if ( cnt [ end ] == k ) return now . f ; if ( cnt [ now . v ] > k ) continue ; for ( i = head [ now . v ]; i != -1 ; i = e [ i ]. next ) { next . v = e [ i ]. to ; next . g = now . g + e [ i ]. w ; next . f = next . g + dis [ e [ i ]. to ]; que . push ( next ); } } return -1 ; } int main () { int i ; int from , to , w ; edgeNum = 0 ; memset ( head , -1 , sizeof ( head )); memset ( opp_Graph , 0 , sizeof ( opp_Graph )); memset ( cnt , 0 , sizeof ( cnt )); scanf ( \"%d %d\" , & n , & m ); Edge edge ; for ( i = 1 ; i <= m ; i ++ ) { scanf ( \"%d %d %d\" , & from , & to , & w ); addEdge ( from , to , w ); edge . to = from ; edge . w = w ; opp_Graph [ to ]. push_back ( edge ); } scanf ( \"%d %d %d\" , & start , & end , & k ); if ( start == end ) k ++ ; dijikastra ( end ); int result = A_Star (); printf ( \"%d \\n \" , result ); return 0 ; }","title":"dijikastra\u7b2ck\u77ed\u8def"},{"location":"icpc/#lcast","text":"#include <bits/stdc++.h> using namespace std ; //lca\u677f\u5b50\u9898,\u6c42\u4fe9\u4e2a\u70b9\u6700\u77ed\u8ddd\u79bb //\u6811\u4e0a\u4e24\u70b9\u6700\u77ed\u8def\u5f84:\u4ece\u6839\u8282\u70b9\u51fa\u53d1dis[u]+dis[v]-dis[lca]*2 struct node { int to , next ; }; int tot = 0 ; node edge [ 1000500 ] = { 0 }; int head [ 500500 ] = { 0 }; int fa [ 500500 ][ 18 ] = { 0 }; int dep [ 500500 ] = { 0 }; void add ( int from , int to ) { edge [ ++ tot ]. next = head [ from ]; edge [ tot ]. to = to ; head [ from ] = tot ; } void dfs ( int now , int fa1 ) { dep [ now ] = dep [ fa1 ] + 1 ; fa [ now ][ 0 ] = fa1 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to != fa1 ) dfs ( to , now ); } } int lca ( int x , int y ) { if ( dep [ x ] < dep [ y ]) swap ( x , y ); for ( int j = 17 ; j >= 0 ; j -- ) { if ( dep [ fa [ x ][ j ]] >= dep [ y ]) x = fa [ x ][ j ]; } if ( x == y ) return x ; for ( int j = 17 ; j >= 0 ; j -- ) { if ( fa [ x ][ j ] != fa [ y ][ j ]) x = fa [ x ][ j ], y = fa [ y ][ j ]; } return fa [ x ][ 0 ]; } int main () { int n , m , s , f , t ; scanf ( \"%d%d%d\" , & n , & m , & s ); ///s\u4e3a\u6839\u8282\u70b9 for ( int i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%d%d\" , & f , & t ); add ( f , t ); add ( t , f ); } dfs ( s , 0 ); for ( int j = 1 ; j <= 17 ; j ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { fa [ i ][ j ] = fa [ fa [ i ][ j - 1 ]][ j - 1 ]; } } for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & f , & t ); printf ( \"%d \\n \" , lca ( f , t )); } }","title":"LCA+ST\u500d\u589e\u7b97\u6cd5"},{"location":"icpc/#_5","text":"#include <bits/stdc++.h> using namespace std ; struct node { int to , val , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }; int cnt = 0 ; int add_edge ( int from , int to , int val ) { edge [ ++ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. val = val ; head [ from ] = cnt ; } int dp [ 200500 ][ 4 ] = { 0 }; int down [ 200500 ] = { 0 }; int up [ 200500 ] = { 0 }; int len [ 200500 ][ 3 ] = { 0 }; int dfs1 ( int now , int fa ) { for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to , val = edge [ i ]. val ; if ( to == fa ) continue ; dfs1 ( to , now ); int tmp = dp [ to ][ 0 ] + val ; if ( tmp > dp [ now ][ 0 ]) swap ( dp [ now ][ 0 ], tmp ); if ( tmp > dp [ now ][ 1 ]) swap ( dp [ now ][ 1 ], tmp ); if ( tmp > dp [ now ][ 2 ]) swap ( dp [ now ][ 2 ], tmp ); down [ now ] = max ( down [ now ], down [ to ]); } down [ now ] = max ( down [ now ], dp [ now ][ 0 ] + dp [ now ][ 1 ]); } int dfs2 ( int now , int fa ) { for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { if ( edge [ i ]. to == fa ) continue ; int tem = down [ edge [ i ]. to ]; if ( tem > len [ now ][ 0 ]) swap ( tem , len [ now ][ 0 ]); if ( tem > len [ now ][ 1 ]) swap ( tem , len [ now ][ 1 ]); } for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to , val = edge [ i ]. val ; if ( to == fa ) continue ; if ( dp [ now ][ 0 ] == dp [ to ][ 0 ] + val ) { dp [ to ][ 3 ] = max ( dp [ now ][ 1 ], dp [ now ][ 3 ]) + val ; up [ to ] = max ( dp [ now ][ 2 ], dp [ now ][ 3 ]) + dp [ now ][ 1 ]; } else if ( dp [ now ][ 1 ] == dp [ to ][ 0 ] + val ) { dp [ to ][ 3 ] = max ( dp [ now ][ 0 ], dp [ now ][ 3 ]) + val ; up [ to ] = max ( dp [ now ][ 2 ], dp [ now ][ 3 ]) + dp [ now ][ 0 ]; } else { dp [ to ][ 3 ] = max ( dp [ now ][ 0 ], dp [ now ][ 3 ]) + val ; up [ to ] = max ( dp [ now ][ 1 ], dp [ now ][ 3 ]) + dp [ now ][ 0 ]; } if ( len [ now ][ 0 ] == down [ to ]) up [ to ] = max ( up [ to ], len [ now ][ 1 ]); else up [ to ] = max ( up [ to ], len [ now ][ 0 ]); dfs2 ( to , now ); } } int main () { int n , from , to , val ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n -1 ; i ++ ) { scanf ( \"%d%d%d\" , & from , & to , & val ); add_edge ( from , to , val ); add_edge ( to , from , val ); } dfs1 ( 1 , -1 ); dfs2 ( 1 , -1 ); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans = max ( ans , up [ i ] + down [ i ]); cout << ans << endl ; }","title":"\u6811\u7684\u76f4\u5f84"},{"location":"icpc/#_6","text":"EK\u7b97\u6cd5\uff1a #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll to , val , next ; }; node edge [ 805 ] = { 0 }; ll head [ 205 ] = { 0 }; ll cnt = 0 ; ll s = 1 , e = 1 ; void add_edge ( ll from , ll to , ll val ) { edge [ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. val = val ; head [ from ] = cnt ++ ; } ll pre [ 205 ] = { 0 }, tag [ 205 ] = { 0 }, vis [ 205 ] = { 0 }; ll bfs () { queue < ll > que ; memset ( tag , 0 , sizeof ( tag )); memset ( pre , 0 , sizeof ( pre )); memset ( vis , 0 , sizeof ( vis )); que . push ( s ); vis [ s ] = 1 ; while ( ! que . empty ()) { ll now = que . front (); que . pop (); for ( ll i = head [ now ]; i != -1 ; i = edge [ i ]. next ) { ll to = edge [ i ]. to , val = edge [ i ]. val ; if ( ! vis [ to ] && val > 0 ) { vis [ to ] = 1 ; pre [ to ] = now ; tag [ to ] = i ; if ( to == e ) return 1 ; que . push ( to ); } } } return 0 ; } ll EK () { ll ans = 0 ; while ( bfs ()) { ll min1 = inf ; for ( ll i = e ; i != s ; i = pre [ i ]) { min1 = min ( min1 , edge [ tag [ i ]]. val ); } for ( ll i = e ; i != s ; i = pre [ i ]) { edge [ tag [ i ]]. val -= min1 ; edge [ tag [ i ] ^ 1 ]. val += min1 ; } ans += min1 ; } return ans ; } int main () { ll n , m , from , to , val ; while ( scanf ( \"%lld%lld\" , & m , & n ) == 2 && n ){ e = n ; cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) head [ i ] = -1 ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld%lld\" , & from , & to , & val ); add_edge ( from , to , val ); add_edge ( to , from , 0 ); } printf ( \"%lld \\n \" , EK ()); } } \u4f18\u5316\u7248Dinic\u7b97\u6cd5\uff1a #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define INF 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct Edge { ll from , to , cap , flow , index ; Edge ( ll from , ll to , ll cap , ll flow , ll index ) : from ( from ), to ( to ), cap ( cap ), flow ( flow ), index ( index ) {} }; struct Dinic { ll N ; vector < vector < Edge >> G ; vector < Edge *> dad ; vector < ll > Q ; Dinic ( ll N ) : N ( N ), G ( N ), dad ( N ), Q ( N ) {} void AddEdge ( ll from , ll to , ll cap ) { G [ from ]. push_back ( Edge ( from , to , cap , 0 , G [ to ]. size ())); if ( from == to ) G [ from ]. back (). index ++ ; G [ to ]. push_back ( Edge ( to , from , 0 , 0 , G [ from ]. size () - 1 )); } ll BlockingFlow ( ll s , ll t ) { fill ( dad . begin (), dad . end (), ( Edge * ) NULL ); dad [ s ] = & G [ 0 ][ 0 ] - 1 ; ll head = 0 , tail = 0 ; Q [ tail ++ ] = s ; while ( head < tail ) { ll x = Q [ head ++ ]; for ( ll i = 0 ; i < G [ x ]. size (); i ++ ) { Edge & e = G [ x ][ i ]; if ( ! dad [ e . to ] && e . cap - e . flow > 0 ) { dad [ e . to ] = & G [ x ][ i ]; Q [ tail ++ ] = e . to ; } } } if ( ! dad [ t ]) return 0 ; ll totflow = 0 ; for ( ll i = 0 ; i < G [ t ]. size (); i ++ ) { Edge * start = & G [ G [ t ][ i ]. to ][ G [ t ][ i ]. index ]; ll amt = INF ; for ( Edge * e = start ; amt && e != dad [ s ]; e = dad [ e -> from ]) { if ( ! e ) { amt = 0 ; break ; } amt = min ( amt , e -> cap - e -> flow ); } if ( amt == 0 ) continue ; for ( Edge * e = start ; amt && e != dad [ s ]; e = dad [ e -> from ]) { e -> flow += amt ; G [ e -> to ][ e -> index ]. flow -= amt ; } totflow += amt ; } return totflow ; } ll GetMaxFlow ( ll s , ll t ) { ll totflow = 0 ; while ( ll flow = BlockingFlow ( s , t )) totflow += flow ; return totflow ; } }; int main () { ll n , m , f , t , v , s , e ; scanf ( \"%lld%lld\" , & n , & m ); scanf ( \"%lld%lld\" , & s , & e ); Dinic dinic ( n + 10 ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld%lld\" , & f , & t , & v ); dinic . AddEdge ( f , t , v ); } printf ( \"%lld \\n \" , dinic . GetMaxFlow ( s , e )); } \u666e\u901a\u7248\u672cdinic\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll INF = 1e18 ; const int N = 5e2 + 7 ; const int M = 2e5 + 7 ; int head [ N ], nex [ M ], ver [ M ], tot = 1 ; ll edge [ M ]; int n , m , s , t ; ll maxflow ; ll deep [ N ]; //\u5c42\u7ea7\u6570\uff0c\u5176\u5b9e\u5e94\u8be5\u662flevel int now [ M ]; //\u5f53\u524d\u5f27\u4f18\u5316 queue < int > q ; inline void add ( int x , int y , int z ) { //\u5efa\u6b63\u8fb9\u548c\u53cd\u5411\u8fb9 ver [ ++ tot ] = y ; edge [ tot ] = z ; nex [ tot ] = head [ x ]; head [ x ] = tot ; ver [ ++ tot ] = x ; edge [ tot ] = 0 ; nex [ tot ] = head [ y ]; head [ y ] = tot ; } inline bool bfs () { //\u5728\u6b8b\u91cf\u7f51\u7edc\u4e2d\u6784\u9020\u5206\u5c42\u56fe for ( int i = 1 ; i <= n ; i ++ ) deep [ i ] = INF ; while ( ! q . empty ()) q . pop (); q . push ( s ); deep [ s ] = 0 ; now [ s ] = head [ s ]; //\u4e00\u4e9b\u521d\u59cb\u5316 while ( ! q . empty ()) { int x = q . front (); q . pop (); for ( int i = head [ x ]; i ; i = nex [ i ]) { int y = ver [ i ]; if ( edge [ i ] > 0 && deep [ y ] == INF ) { //\u6ca1\u8d70\u8fc7\u4e14\u5269\u4f59\u5bb9\u91cf\u5927\u4e8e0 q . push ( y ); now [ y ] = head [ y ]; //\u5148\u521d\u59cb\u5316\uff0c\u6682\u65f6\u90fd\u4e00\u6837 deep [ y ] = deep [ x ] + 1 ; if ( y == t ) return 1 ; //\u627e\u5230\u4e86 } } } return 0 ; } //flow\u662f\u6574\u6761\u589e\u5e7f\u8def\u5bf9\u6700\u5927\u6d41\u7684\u8d21\u732e\uff0crest\u662f\u5f53\u524d\u6700\u5c0f\u5269\u4f59\u5bb9\u91cf\uff0c\u7528rest\u53bb\u66f4\u65b0flow ll dfs ( int x , ll flow ) { //\u5728\u5f53\u524d\u5206\u5c42\u56fe\u4e0a\u589e\u5e7f if ( x == t ) return flow ; ll ans = 0 , k , i ; for ( i = now [ x ]; i && flow ; i = nex [ i ]) { now [ x ] = i ; //\u5f53\u524d\u5f27\u4f18\u5316\uff08\u907f\u514d\u91cd\u590d\u904d\u5386\u4ecex\u51fa\u53d1\u7684\u4e0d\u53ef\u62d3\u5c55\u7684\u8fb9\uff09 int y = ver [ i ]; if ( edge [ i ] > 0 && ( deep [ y ] == deep [ x ] + 1 )) { //\u5fc5\u987b\u662f\u4e0b\u4e00\u5c42\u5e76\u4e14\u5269\u4f59\u5bb9\u91cf\u5927\u4e8e0 k = dfs ( y , min ( flow , edge [ i ])); //\u53d6\u6700\u5c0f if ( ! k ) deep [ y ] = INF ; //\u526a\u679d\uff0c\u53bb\u6389\u589e\u5e7f\u5b8c\u6bd5\u7684\u70b9 edge [ i ] -= k ; //\u56de\u6eaf\u65f6\u66f4\u65b0 edge [ i ^ 1 ] += k ; //\u6210\u5bf9\u53d8\u6362 ans += k ; flow -= k ; } } return ans ; } void dinic () { while ( bfs ()) maxflow += dfs ( s , INF ); } int main () { scanf ( \"%d%d%d%d\" , & n , & m , & s , & t ); tot = 1 ; for ( ll i = 1 ; i <= m ; i ++ ) { int x , y , z ; scanf ( \"%d%d%d\" , & x , & y , & z ); add ( x , y , z ); } dinic (); printf ( \"%lld \\n \" , maxflow ); return 0 ; }","title":"\u6700\u5927\u6d41\u7b97\u6cd5"},{"location":"icpc/#_7","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int next ; int flow ; int dis ; int to ; }; int head [ 100500 ] = { 0 }; node edge [ 100500 ] = { 0 }; int dis [ 100500 ] = { 0 }; int pre [ 100500 ] = { 0 }; int vis [ 100500 ] = { 0 }; int last [ 100500 ] = { 0 }; int flow [ 100500 ] = { 0 }; char g [ 1000 ][ 1000 ] = { 0 }; int n , m , s , t , cnt = -1 , maxflow = 0 , mincost = 0 ; int num ( int i , int j ) { return i * m + j ; } int add ( int from , int to , int flow , int dis ) { edge [ ++ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. flow = flow ; edge [ cnt ]. dis = dis ; head [ from ] = cnt ; } queue < int > w ; bool spfa ( int start , int end1 ) { w . push ( start ); memset ( dis , 0x3f3f3f , sizeof ( dis )); memset ( vis , 0 , sizeof ( vis )); memset ( flow , 0x3f3f3f , sizeof ( flow )); pre [ end1 ] = -1 ; vis [ start ] = 1 ; dis [ start ] = 0 ; while ( ! w . empty ()) { int now = w . front (); w . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i != -1 ; i = edge [ i ]. next ) { //cout<<i<<endl; if ( edge [ i ]. flow > 0 && dis [ edge [ i ]. to ] > dis [ now ] + edge [ i ]. dis ) { dis [ edge [ i ]. to ] = dis [ now ] + edge [ i ]. dis ; pre [ edge [ i ]. to ] = now ; last [ edge [ i ]. to ] = i ; flow [ edge [ i ]. to ] = min ( flow [ now ], edge [ i ]. flow ); if ( ! vis [ edge [ i ]. to ]) { vis [ edge [ i ]. to ] = 1 ; w . push ( edge [ i ]. to ); } } } } return pre [ end1 ] != -1 ; } int MCMF () { while ( spfa ( s , t )) { maxflow += flow [ t ]; mincost += dis [ t ] * flow [ t ]; int now = t ; while ( now != s ) { edge [ last [ now ]]. flow -= flow [ t ]; edge [ last [ now ] ^ 1 ]. flow += flow [ t ]; now = pre [ now ]; } } } int main () { memset ( head , -1 , sizeof ( head )); scanf ( \"%d%d\" , & n , & m ); s = n * m + 200 , t = n * m + 100 ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , g [ i ] + 1 ); } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( g [ i ][ j ] == 'x' ) continue ; if ( j > 1 && g [ i ][ j -1 ] != 'x' ) { add ( num ( i , j ), num ( i , j -1 ), 1 , 1 ); add ( num ( i , j -1 ), num ( i , j ), 0 , -1 ); } if ( i > 1 && g [ i -1 ][ j ] != 'x' ) { add ( num ( i , j ), num ( i -1 , j ), 1 , 1 ); add ( num ( i -1 , j ), num ( i , j ), 0 , -1 ); } if ( j < m && g [ i ][ j + 1 ] != 'x' ) { add ( num ( i , j ), num ( i , j + 1 ), 1 , 1 ); add ( num ( i , j + 1 ), num ( i , j ), 0 , -1 ); } if ( i < n && g [ i + 1 ][ j ] != 'x' ) { add ( num ( i , j ), num ( i + 1 , j ), 1 , 1 ); add ( num ( i + 1 , j ), num ( i , j ), 0 , -1 ); } if ( g [ i ][ j ] == 'F' ) { add ( s , num ( i , j ), 2 , 0 ); add ( num ( i , j ), s , 0 , 0 ); } if ( g [ i ][ j ] == 'C' || g [ i ][ j ] == 'B' ) { add ( num ( i , j ), t , 1 , 0 ); add ( t , num ( i , j ), 0 , 0 ); } } } MCMF (); // cout<<maxflow<<\" \"<<mincost<<endl; if ( maxflow != 2 ) printf ( \"-1 \\n \" ); else printf ( \"%d \\n \" , mincost ); }","title":"\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u7b97\u6cd5"},{"location":"icpc/#_8","text":"\u9898\u610f\uff1a\u7ed9\u4f60n\u4e2a\u957f\u5ea6\u76f8\u540c\uff0c\u5305\u542b\u5b57\u6bcd\u79cd\u7c7b\u76f8\u540c\uff0c\u6bcf\u79cd\u5b57\u6bcd\u6570\u91cf\u76f8\u540c\uff0c\u8ba9\u4f60\u786e\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\u96c6\u5408\uff0c\u96c6\u5408\u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u4e32\u4e0d\u80fd\u901a\u8fc7\u4ea4\u6362\u4efb\u610f\u4e24\u4e2a\u4e0d\u540c\u7684\u4f4d\u7f6e\u53d8\u6210\u96c6\u5408\u4e2d\u7684\u53e6\u4e00\u4e2a\u4e32\uff0c\u95ee\u4f60\u96c6\u5408\u6700\u5927\u6709\u591a\u4e2a\u5b57\u7b26\u4e32\u3002 \u601d\u8def\uff1a \u6211\u4eec\u5bf9\u4e8e\u4e24\u4e2a\u4e00\u6b21\u64cd\u4f5c\uff08\u4ea4\u6362\u4e24\u4e2a\u4e0d\u540c\u4f4d\u7f6e\uff09\u4e0d\u80fd\u4e92\u76f8\u53d8\u6362\u7684\u4e32\u5efa\u8fb9\uff0c\u90a3\u4e48\u7b54\u6848\u5c31\u662f\u8fd9\u4e2a\u56fe\u7684\u6700\u5927\u56e2\u3002 \u4e00\u4e2a\u56fe\u7684\u6700\u5927\u56e2\u7b49\u4e8e\u8fd9\u4e2a\u56fe\u8865\u56fe\u7684\u6700\u5927\u72ec\u7acb\u96c6\uff0c\u90a3\u4e48\u6211\u4eec\u8981\u5efa\u8fd9\u4e2a\u56fe\u7684\u8865\u56fe\u3002 \u8fd9\u4e2a\u56fe\u7684\u8865\u56fe\u5c31\u662f\u5bf9\u80fd\u591f\u4e00\u6b21\u64cd\u4f5c\u4e92\u76f8\u53d8\u6362\u7684\u4e24\u4e2a\u4e32\u5efa\u8fb9\u3002 \u90a3\u4e48\u73b0\u5728\u7b54\u6848\u5c31\u662f\u8fd9\u4e2a\u8865\u56fe\u7684\u6700\u5927\u72ec\u7acb\u96c6\u3002 \u8fd9\u4e2a\u8865\u56fe\u4e00\u5b9a\u662f\u4e00\u4e2a\u4e8c\u5206\u56fe\u3002 \u4e8c\u5206\u56fe\u7684\u6700\u5927\u72ec\u7acb\u96c6\u7b49\u4e8e\u56fe\u4e2d\u70b9\u7684\u4e2a\u6570 - \u6700\u5927\u5339\u914d\u6570\u3002 \u6240\u4ee5\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u5bf9\u8fd9\u4e2a\u4e8c\u5206\u56fe\u6c42\u4e00\u4e2a\u6700\u5927\u5339\u914d\u3002 #include <bits/stdc++.h> using namespace std ; char a [ 1000 ][ 300 ] = { 0 }; int mp [ 1000 ][ 1000 ] = { 0 }; map < int , int > mp1 , vis ; int n ; int dfs ( int k ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( mp [ i ][ k ] &&! vis [ i ]) { vis [ i ] = 1 ; if ( mp1 [ i ] == 0 || dfs ( mp1 [ i ])) { mp1 [ i ] = k ; return 1 ; } } } return 0 ; } int main () { scanf ( \"%d\" , & n ); ///\u4e24\u4e2a\u5b57\u7b26\u4e32\u4e2d\u4e0d\u80fd\u6709\u4e24\u4e2a\u5b57\u7b26\u76f8\u540c\uff0c\u95ee\u81f3\u5c11\u9700\u8981\u5206\u4e3a\u591a\u5c11\u7ec4 for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int sum = 0 ; for ( int k = 1 ; a [ i ][ k ]; k ++ ) { if ( a [ i ][ k ] != a [ j ][ k ]) sum ++ ; } if ( sum == 2 ) mp [ i ][ j ] = 1 ; } } //cout<<mp[1][2]<<endl; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { vis . clear (); ans += dfs ( i ); } cout << n - ans / 2 << endl ; } \u4e8c\u5206\u56fe\u5224\u65ad #include <bits/stdc++.h> using namespace std ; vector < int > v [ 100500 ]; int color [ 100500 ] = { 0 }; int bfs ( int i ) { queue < int > que ; que . push ( i ); while ( ! que . empty ()) { int now = que . front (); que . pop (); for ( int i : v [ now ]) { if ( color [ i ] == 0 ) { color [ i ] = 3 - color [ now ]; que . push ( i ); } else { if ( color [ i ] == color [ now ]) return 0 ; } } } return 1 ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int from , to ; scanf ( \"%d %d\" , & from , & to ); v [ from ]. push_back ( to ); v [ to ]. push_back ( from ); } for ( int i = 1 ; i <= m ; i ++ ) { if ( color [ i ] == 0 ) { int tmp = bfs ( i ); if ( tmp == 0 ) { puts ( \"No\" ); return 0 ; } } } puts ( \"Yes\" ); } /* \u8f93\u5165\uff1a 7 6 1 2 1 3 2 4 2 5 3 6 3 7 \u8f93\u51fa\uff1a Yes \u8f93\u5165\uff1a 3 3 1 2 2 3 1 3 \u8f93\u51fa\uff1a No */ \u4e8c\u5206\u56fe\u6700\u5927\u5339\u914d #include <bits/stdc++.h> using namespace std ; vector < int > v [ 100500 ]; map < int , int > mp , vis , mp1 ; int dfs ( int now ) { for ( int i = 0 ; i < v [ now ]. size (); i ++ ) { int to = v [ now ][ i ]; if ( ! vis [ to ]) { vis [ to ] = 1 ; if ( mp [ to ] == 0 || dfs ( mp [ to ])) { mp [ to ] = now ; mp1 [ now ] = to ; return 1 ; } } } return 0 ; } int main () { int n1 , n2 , m ; scanf ( \"%d%d%d\" , & n1 , & n2 , & m ); int from , to ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); to += n1 ; v [ from ]. push_back ( to ); v [ to ]. push_back ( from ); } int ans = 0 ; for ( int i = 1 ; i <= n1 ; i ++ ) { vis . clear (); ans += dfs ( i ); } cout << ans << endl ; for ( int i = 1 ; i <= n1 ; i ++ ) cout << max ( 0 , mp1 [ i ] - n1 ) << ' ' ; } \u4e8c\u5206\u56fe\u6700\u5927\u72ec\u7acb\u96c6\uff1a \u9009\u6700\u591a\u7684\u70b9\uff0c\u6ee1\u8db3\u4e24\u4e24\u4e4b\u95f4\u6ca1\u6709\u8fb9\u76f8\u8fde\u3002 \u4e8c\u5206\u56fe\u4e2d\uff0c\u6700\u5927\u72ec\u7acb\u96c6 =n- \u6700\u5927\u5339\u914d\u3002 \u4e8c\u5206\u56fe\u6700\u5c0f\u70b9\u8986\u76d6\uff1a \u9009\u6700\u5c11\u7684\u70b9\uff0c\u6ee1\u8db3\u6bcf\u6761\u8fb9\u81f3\u5c11\u6709\u4e00\u4e2a\u7aef\u70b9\u88ab\u9009\uff0c\u4e0d\u96be\u53d1\u73b0\u8865\u96c6\u662f\u72ec\u7acb\u96c6\u3002 \u4e8c\u5206\u56fe\u4e2d\uff0c\u6700\u5c0f\u70b9\u8986\u76d6 =n- \u6700\u5927\u72ec\u7acb\u96c6\u3002 \u4e8c\u5206\u56fe\u6709\u5411\u65e0\u5411\u5efa\u56fe\u89c4\u5219\uff1a \u6709\u5de6\u53f3\u4e4b\u5206\u5efa\u5355\u5411\u8fb9\uff0c\u65e0\u5de6\u53f3\u4e4b\u5206\u5efa\u65e0\u5411\u8fb9 \u7b54\u6848\u96642 \u4e00\u5207\u6811\u5747\u4e3a\u4e8c\u5206\u56fe \u4e8c\u5206\u56fe\u6700\u5927\u6743\u5339\u914d\uff1a \u9898\u76ee\uff1a https://uoj.ac/problem/80 \u9898\u89e3\uff1a https://blog.csdn.net/weixin_30528371/article/details/99263983 \u8bb2\u89e3\uff1a https://www.cnblogs.com/wenruo/p/5264235.html #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; int n , m , q ; int w [ 405 ] = { 0 }, v [ 405 ] = { 0 }; int vl [ 405 ] = { 0 }, vr [ 405 ] = { 0 }, c [ 405 ] = { 0 }; int a [ 405 ][ 405 ] = { 0 }, ans [ 405 ] = { 0 }, b [ 405 ] = { 0 }; int tim = 0 ; int dfs ( int x ) { vl [ x ] = tim ; for ( int i = 1 ; i <= m ; i ++ ) { if ( vr [ i ] == tim ) continue ; int d = w [ x ] + v [ i ] - a [ x ][ i ]; if ( d == 0 ) { vr [ i ] = tim ; if ( ! b [ i ] || dfs ( b [ i ])) { b [ i ] = x ; return 1 ; } } else { c [ i ] = min ( c [ i ], d ); } } return 0 ; } void km () { for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) w [ i ] = max ( w [ i ], a [ i ][ j ]); for ( int i = 1 ; i <= n ; i ++ ) { memset ( c , inf , sizeof ( c )); tim += 1 ; if ( dfs ( i )) continue ; while ( 1 ) { int d = inf , y = 0 ; for ( int j = 1 ; j <= m ; j ++ ) if ( vr [ j ] != tim ) d = min ( d , c [ j ]); for ( int j = 1 ; j <= n ; j ++ ) if ( vl [ j ] == tim ) w [ j ] -= d ; for ( int j = 1 ; j <= m ; j ++ ) { if ( vr [ j ] == tim ) v [ j ] += d ; else if ( ! ( c [ j ] -= d )) y = j ; } if ( ! b [ y ]) break ; int x = b [ y ]; vl [ x ] = vr [ y ] = tim ; for ( int j = 1 ; j <= m ; j ++ ) c [ j ] = min ( c [ j ], w [ x ] + v [ j ] - a [ x ][ j ]); } tim += 1 ; dfs ( i ); } ll ans1 = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans1 += a [ b [ i ]][ i ]; printf ( \"%lld \\n \" , ans1 ); for ( int i = 1 ; i <= m ; i ++ ) { if ( a [ b [ i ]][ i ]) ans [ b [ i ]] = i ; } for ( int i = 1 ; i <= n ; i ++ ) printf ( \"%d \" , ans [ i ]); } int main () { scanf ( \"%d%d%d\" , & n , & m , & q ); m = max ( m , n ); for ( int i = 1 ; i <= q ; i ++ ) { int x , y , v ; scanf ( \"%d%d%d\" , & x , & y , & v ); a [ x ][ y ] = v ; } km (); }","title":"\u4e8c\u5206\u56fe\u6a21\u677f"},{"location":"icpc/#tarjan","text":"Tarjan \u7b97\u6cd5\u53ca\u5176\u5e94\u7528 \u6c42\u5272\u8fb9 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int to , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }, dfn [ 200500 ] = { 0 }, low [ 200500 ] = { 0 }, bridge [ 200500 ] = { 0 }; int cnt = 1 , tot = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } void tarjan ( int x , int in_edge ) { dfn [ x ] = low [ x ] = ++ tot ; for ( int i = head [ x ]; i ; i = edge [ i ]. next ) { int y = edge [ i ]. to ; if ( ! dfn [ y ]) { tarjan ( y , i ); low [ x ] = min ( low [ x ], low [ y ]); if ( low [ y ] > dfn [ x ]) bridge [ i ] = bridge [ i ^ 1 ] = 1 ; ///\u6865 } else if ( i != ( in_edge ^ 1 )) low [ x ] = min ( low [ x ], dfn [ y ]); } } int main () { int n , m , from , to ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! dfn [ i ]) tarjan ( i , 0 ); } for ( int i = 2 ; i <= cnt ; i += 2 ) { if ( bridge [ i ]) { printf ( \"%d %d \\n \" , edge [ i ^ 1 ]. to , edge [ i ]. to ); } } } \u7f29\u70b9\u6c42\u5c06\u56fe\u8f6c\u53d8\u4e3a\u5f3a\u8fde\u901a\u56fe\u9700\u8981\u52a0\u8fb9\u7684\u6570\u76ee \u9898\u76ee\u6765\u6e90\uff1aPOJ 2767 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int to , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }, dfn [ 200500 ] = { 0 }, low [ 200500 ] = { 0 }; int stack1 [ 200500 ] = { 0 }, vis [ 200500 ] = { 0 }, color [ 200500 ] = { 0 }; bool in [ 200500 ] = { 0 }, out [ 200500 ] = { 0 }; int cnt = 0 , tot = 0 , top = 0 , color_num = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } void tarjan ( int now ) { stack1 [ ++ top ] = now ; vis [ now ] = 1 ; dfn [ now ] = low [ now ] = ++ tot ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int y = edge [ i ]. to ; if ( ! dfn [ y ]) { tarjan ( y ); low [ now ] = min ( low [ now ], low [ y ]); } else if ( vis [ y ]) low [ now ] = min ( low [ now ], dfn [ y ]); } if ( dfn [ now ] == low [ now ]) ///\u5f3a\u8fde\u901a\u5757 { color [ now ] = ++ color_num ; vis [ now ] = 0 ; while ( stack1 [ top ] != now ) { color [ stack1 [ top ]] = color_num ; vis [ stack1 [ top -- ]] = 0 ; } vis [ stack1 [ top ]] = 0 ; top -- ; } } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m , from , to ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n + 1 ; i ++ ) in [ i ] = out [ i ] = head [ i ] = dfn [ i ] = low [ i ] = stack1 [ i ] = vis [ i ] = color [ i ] = 0 ; cnt = 0 , tot = 0 , top = 0 , color_num = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); add_edge ( from , to ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! dfn [ i ]) tarjan ( i ); } if ( color_num == 1 ) { printf ( \"0 \\n \" ); continue ; } int in_num = color_num , out_num = color_num ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = head [ i ]; j ; j = edge [ j ]. next ) { int to = edge [ j ]. to ; if ( color [ to ] != color [ i ]) { if ( ! in [ color [ to ]]) { in_num -- ; in [ color [ to ]] = 1 ; } if ( ! out [ color [ i ]]) { out_num -- ; out [ color [ i ]] = 1 ; } } } } printf ( \"%d \\n \" , max ( out_num , in_num )); } } \u6c42\u5272\u70b9 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int to , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }, dfn [ 200500 ] = { 0 }, low [ 200500 ] = { 0 }, cut [ 200500 ] = { 0 }; int cnt = 0 , tot = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } void tarjan ( int now , int root ) { dfn [ now ] = low [ now ] = ++ tot ; int ct = 0 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int y = edge [ i ]. to ; ct ++ ; if ( ! dfn [ y ]) { tarjan ( y , root ); low [ now ] = min ( low [ now ], low [ y ]); if ( now != root && low [ y ] >= dfn [ now ]) cut [ now ] = 1 ; if ( now == root && ct > 1 ) cut [ now ] = 1 ; } else low [ now ] = min ( low [ now ], dfn [ y ]); } } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m , from , to ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n + 1 ; i ++ ) head [ i ] = dfn [ i ] = low [ i ] = cut [ i ] = 0 ; cnt = 0 , tot = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! dfn [ i ]) tarjan ( i , i ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( cut [ i ]) printf ( \"%d \" , i ); } printf ( \" \\n \" ); } } /* \u8f93\u5165\uff1a 1 7 7 1 2 1 5 5 6 5 7 2 3 2 4 3 4 \u5272\u70b9\u4e3a\uff1a 1 2 5 */","title":"Tarjan\u7b97\u6cd5"},{"location":"icpc/#_9","text":"https://oi-wiki.org/graph/hld/#_4 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll sum [ 400500 ] = { 0 }, lazy [ 400500 ] = { 0 }; ll dep [ 200500 ] = { 0 }, size1 [ 200500 ] = { 0 }, son [ 200500 ] = { 0 }, f [ 200500 ] = { 0 }, id [ 200500 ] = { 0 }, top [ 200500 ] = { 0 }; struct node { ll to , next ; }; node edge [ 400500 ] = { 0 }; ll head [ 400500 ] = { 0 }; ll num = 0 , cnt = 0 ; void add_edge ( ll from , ll to ) { edge [ ++ num ] = { to , head [ from ]}; head [ from ] = num ; } void dfs1 ( ll now , ll fa ) { size1 [ now ] = 1 ; for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == fa ) continue ; f [ to ] = now ; dep [ to ] = dep [ now ] + 1 ; dfs1 ( to , now ); size1 [ now ] += size1 [ to ]; if ( size1 [ to ] > size1 [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( ll now , ll fa ) { id [ now ] = ++ cnt ; top [ now ] = fa ; if ( son [ now ]) dfs2 ( son [ now ], fa ); for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == f [ now ] || to == son [ now ]) continue ; dfs2 ( to , to ); } } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t + 1 ] += lazy [ t ]; lazy [ 2 * t ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += ( mid - l + 1 ) * lazy [ t ]; sum [ 2 * t + 1 ] += ( r - mid ) * lazy [ t ]; lazy [ t ] = 0 ; } void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { lazy [ t ] += add ; sum [ t ] += add * ( R - L + 1 ); return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query ( ll t , ll l , ll r , ll L , ll R ) { if ( l <= L && R <= r ) return sum [ t ]; push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; ll ans = 0 ; if ( l <= mid ) ans += query ( 2 * t , l , r , L , mid ); if ( mid < r ) ans += query ( 2 * t + 1 , l , r , mid + 1 , R ); return ans ; } void update_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ]; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); update ( 1 , id [ fx ], id [ x ], 1 , cnt , 1 ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); update ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt , 1 ); } ll query_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ], ans = 0 ; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); ans += query ( 1 , id [ fx ], id [ x ], 1 , cnt ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); ans += query ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt ); return ans ; } int main () { ll n , m , from , to ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } f [ 1 ] = 0 , dep [ 1 ] = 1 ; dfs1 ( 1 , 0 ), dfs2 ( 1 , 1 ); char c [ 10 ]; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , c + 1 , & from , & to ); if ( c [ 1 ] == 'P' ) update_chain ( from , to ); else printf ( \"%lld \\n \" , query_chain ( from , to )); } }","title":"\u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811"},{"location":"icpc/#_10","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef pair < int , int > pii ; const int N = 100000 + 5 ; const int K = 10 + 5 ; const ll inf = 0x3f3f3f3f3f3f3f3f ; vector < pii > e [ N ]; struct Info { int pos , num ; ll val ; inline Info (){} inline Info ( int _pos , int _num , ll _val ) { pos = _pos , num = _num , val = _val ; } inline bool operator < ( const Info & b ) const { return val > b . val ; } }; ll f [ N ][ K ]; bool vis [ N ][ K ]; priority_queue < Info > q ; class TaskL { public : void solve ( std :: istream & in , std :: ostream & out ) { int T ; in >> T ; while ( T -- ) { int n , m , k ; in >> n >> m >> k ; while ( q . size ()) q . pop (); for ( int i = 1 ; i <= n ; ++ i ) { e [ i ]. clear (); for ( int j = 0 ; j <= k ; ++ j ) { f [ i ][ j ] = inf ; vis [ i ][ j ] = false ; } } for ( int i = 1 , x , y , z ; i <= m ; ++ i ) { in >> x >> y >> z ; e [ x ]. push_back ({ y , z }); } f [ 1 ][ 0 ] = 0 ; q . push ( Info ( 1 , 0 , 0 )); while ( q . size ()) { Info now = q . top (); q . pop (); if ( vis [ now . pos ][ now . num ] == true ) continue ; vis [ now . pos ][ now . num ] = true ; for ( int i = 0 ; i < e [ now . pos ]. size (); ++ i ) { int to = e [ now . pos ][ i ]. first , val = e [ now . pos ][ i ]. second ; if ( f [ to ][ now . num ] > f [ now . pos ][ now . num ] + val ) { f [ to ][ now . num ] = f [ now . pos ][ now . num ] + val ; q . push ( Info ( to , now . num , f [ to ][ now . num ])); } if ( now . num < k && f [ to ][ now . num + 1 ] > f [ now . pos ][ now . num ]) { f [ to ][ now . num + 1 ] = f [ now . pos ][ now . num ]; q . push ( Info ( to , now . num + 1 , f [ to ][ now . num + 1 ])); } } } ll ans = inf ; for ( int i = 0 ; i <= k ; ++ i ) { ans = min ( ans , f [ n ][ i ]); } out << ans << endl ; } } }; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); TaskL solver ; std :: istream & in ( std :: cin ); std :: ostream & out ( std :: cout ); solver . solve ( in , out ); return 0 ; }","title":"\u5206\u5c42\u6700\u77ed\u8def"},{"location":"icpc/#lct","text":"\u53c2\u8003\u94fe\u63a5\uff1a https://www.luogu.com.cn/problem/P3690 https://www.cnblogs.com/zwfymqz/p/7896036.html#!comments https://www.cnblogs.com/zzy2005/p/10312977.html https://www.cnblogs.com/JeremyGJY/p/5921594.html https://blog.csdn.net/qq_36551189/article/details/79152612 #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll f [ 100500 ] = { 0 }, c [ 100500 ][ 2 ] = { 0 }, v [ 100500 ] = { 0 }, s [ 100500 ] = { 0 }, st [ 100500 ] = { 0 }; bool r [ 100500 ] = { 0 }; //\u5224\u65ad\u8282\u70b9\u662f\u5426\u4e3a\u4e00\u4e2aSplay\u7684\u6839 inline bool nroot ( register ll x ) { return c [ f [ x ]][ 0 ] == x || c [ f [ x ]][ 1 ] == x ; //\u539f\u7406\u4e3a\u5982\u679c\u8fde\u7684\u662f\u8f7b\u8fb9\uff0c\u4ed6\u7684\u7236\u4eb2\u7684\u513f\u5b50\u91cc\u6ca1\u6709\u5b83 } //\u4e0a\u4f20\u4fe1\u606f inline void pushup ( ll x ) { s [ x ] = s [ c [ x ][ 0 ]] ^ s [ c [ x ][ 1 ]] ^ v [ x ]; } //\u7ffb\u8f6c\u64cd\u4f5c inline void pushr ( register ll x ) { register ll t = c [ x ][ 0 ]; c [ x ][ 0 ] = c [ x ][ 1 ]; c [ x ][ 1 ] = t ; r [ x ] ^= 1 ; } //\u5224\u65ad\u5e76\u91ca\u653e\u61d2\u6807\u8bb0 inline void pushdown ( register ll x ) { if ( r [ x ]) { if ( c [ x ][ 0 ]) pushr ( c [ x ][ 0 ]); if ( c [ x ][ 1 ]) pushr ( c [ x ][ 1 ]); r [ x ] = 0 ; } } //\u4e00\u6b21\u65cb\u8f6c inline void rotate ( register ll x ) { register ll y = f [ x ], z = f [ y ], k = c [ y ][ 1 ] == x , w = c [ x ][ ! k ]; if ( nroot ( y )) c [ z ][ c [ z ][ 1 ] == y ] = x ; c [ x ][ ! k ] = y ; c [ y ][ k ] = w ; if ( w ) f [ w ] = y ; f [ y ] = x ; f [ x ] = z ; pushup ( y ); } //\u53ea\u4f20\u4e86\u4e00\u4e2a\u53c2\u6570\uff0c\u56e0\u4e3a\u6240\u6709\u64cd\u4f5c\u7684\u76ee\u6807\u90fd\u662f\u8be5Splay\u7684\u6839 inline void splay ( register ll x ) { register ll y = x , z = 0 ; st [ ++ z ] = y ; //st\u4e3a\u6808\uff0c\u6682\u5b58\u5f53\u524d\u70b9\u5230\u6839\u7684\u6574\u6761\u8def\u5f84\uff0cpushdown\u65f6\u4e00\u5b9a\u8981\u4ece\u4e0a\u5f80\u4e0b\u653e\u6807\u8bb0 while ( nroot ( y )) st [ ++ z ] = y = f [ y ]; while ( z ) pushdown ( st [ z -- ]); while ( nroot ( x )) { y = f [ x ]; z = f [ y ]; if ( nroot ( y )) rotate (( c [ y ][ 0 ] == x ) ^ ( c [ z ][ 0 ] == y ) ? x : y ); rotate ( x ); } pushup ( x ); } //\u8bbf\u95ee inline void access ( register ll x ) { for ( register ll y = 0 ; x ; x = f [ y = x ]) splay ( x ), c [ x ][ 1 ] = y , pushup ( x ); } //\u6362\u6839 inline void makeroot ( register ll x ) { access ( x ); splay ( x ); pushr ( x ); } //\u627e\u6839\uff08\u5728\u771f\u5b9e\u7684\u6811\u4e2d\u7684\uff09 inline ll findroot ( register ll x ) { access ( x ); splay ( x ); while ( c [ x ][ 0 ]) pushdown ( x ), x = c [ x ][ 0 ]; splay ( x ); return x ; } //\u63d0\u53d6\u8def\u5f84 inline void split ( register ll x , register ll y ) { makeroot ( x ); access ( y ); splay ( y ); } //\u8fde\u8fb9 inline void link ( register ll x , register ll y ) { makeroot ( x ); if ( findroot ( y ) != x ) f [ x ] = y ; } //\u65ad\u8fb9 void cut ( register ll x , register ll y ) { makeroot ( x ); if ( findroot ( y ) == x && f [ y ] == x && ! c [ y ][ 0 ]) { f [ y ] = c [ x ][ 1 ] = 0 ; pushup ( x ); } } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) //\u7ed9\u5b9a n \u4e2a\u70b9\u4ee5\u53ca\u6bcf\u4e2a\u70b9\u7684\u6743\u503c scanf ( \"%d\" , & v [ i ]); for ( int i = 1 ; i <= m ; i ++ ) { int opt , x , y ; scanf ( \"%d%d%d\" , & opt , & x , & y ); if ( opt == 0 ) //\u4ee3\u8868\u8be2\u95ee\u4ece x \u5230 y \u7684\u8def\u5f84\u4e0a\u7684\u70b9\u7684\u6743\u503c\u7684 xor \u548c\u3002\u4fdd\u8bc1 x \u5230 y \u662f\u8054\u901a\u7684\u3002 { split ( x , y ); printf ( \"%d \\n \" , s [ y ]); } else if ( opt == 1 ) //\u4ee3\u8868\u8fde\u63a5 x \u5230 y\uff0c\u82e5 x \u5230 y \u5df2\u7ecf\u8054\u901a\u5219\u65e0\u9700\u8fde\u63a5\u3002 { link ( x , y ); } else if ( opt == 2 ) //\u4ee3\u8868\u5220\u9664\u8fb9 (x,y)\uff0c\u4e0d\u4fdd\u8bc1\u8fb9 (x,y) \u5b58\u5728\u3002 { cut ( x , y ); } else if ( opt == 3 ) //\u4ee3\u8868\u5c06\u70b9 x \u4e0a\u7684\u6743\u503c\u53d8\u6210 y\u3002 { splay ( x ); v [ x ] = y ; } } }","title":"LCT \u52a8\u6001\u6811"},{"location":"icpc/#_11","text":"","title":"\u6570\u636e\u7ed3\u6784"},{"location":"icpc/#_12","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n , m ; ll a [ 100500 ] = { 0 }; ll c [ 100500 ] = { 0 }; ll lowbit ( ll x ) { return x & ( - x ); } ll update ( ll k , ll x ) { for ( ll i = k ; i <= n ; i += lowbit ( i )) c [ i ] += x ; } ll sum1 ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c [ i ]; return ans ; } int main () { ll a1 , b1 , c1 ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld%lld\" , & a1 , & b1 , & c1 ); if ( a1 == 0 ) update ( b1 , c1 ); else printf ( \"%lld \\n \" , sum1 ( c1 ) - sum1 ( b1 -1 )); } }","title":"\u6811\u72b6\u6570\u7ec4\u524d\u7f00\u548c"},{"location":"icpc/#_13","text":"#include <stdio.h> using namespace std ; typedef long long ll ; ll num [ 100500 ] = { 0 }; ll lazy [ 800500 ] = { 0 }; ll sum [ 800500 ] = { 0 }; void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t ] += lazy [ t ]; lazy [ 2 * t + 1 ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += lazy [ t ] * ( mid - l + 1 ); sum [ 2 * t + 1 ] += lazy [ t ] * ( r - mid ); lazy [ t ] = 0 ; } void build ( ll t , ll l , ll r ) { if ( l == r ) { sum [ t ] = num [ l ]; return ; } ll mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); push_up ( t ); } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( l <= L && r >= R ) { sum [ t ] += add * ( R - L + 1 ); lazy [ t ] += add ; return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query_sum ( ll t , ll l , ll r , ll L , ll R ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( l <= L && r >= R ) { return sum [ t ]; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 , sum = 0 ; if ( l <= mid ) sum += query_sum ( 2 * t , l , r , L , mid ); if ( mid < r ) sum += query_sum ( 2 * t + 1 , l , r , mid + 1 , R ); return sum ; } int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & num [ i ]); build ( 1 , 1 , n ); char s [ 10 ]; ll l , r , x ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , s , & l , & r ); if ( s [ 0 ] == 'Q' ) { printf ( \"%lld \\n \" , query_sum ( 1 , l , r , 1 , n )); } else { scanf ( \"%lld\" , & x ); update ( 1 , l , r , 1 , n , x ); } } }","title":"\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u548c"},{"location":"icpc/#_14","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int tree [ 20 ][ 100500 ] = { 0 }; int to [ 20 ][ 100500 ] = { 0 }; int num [ 100500 ] = { 0 }; int sorted [ 100500 ] = { 0 }; int build ( int l , int r , int deep ) { if ( l == r ) return 0 ; int mid = ( l + r ) / 2 ; int midd = sorted [ mid ]; int suppose = mid - l + 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( tree [ deep ][ i ] < midd ) suppose -- ; } int sleft = l , sright = mid + 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( i == l ) to [ deep ][ l ] = 0 ; else to [ deep ][ i ] = to [ deep ][ i -1 ]; if ( tree [ deep ][ i ] < midd ) { to [ deep ][ i ] ++ ; tree [ deep + 1 ][ sleft ++ ] = tree [ deep ][ i ]; } else if ( tree [ deep ][ i ] == midd && suppose > 0 ) { suppose -- ; to [ deep ][ i ] ++ ; tree [ deep + 1 ][ sleft ++ ] = tree [ deep ][ i ]; } else { tree [ deep + 1 ][ sright ++ ] = tree [ deep ][ i ]; } } build ( l , mid , deep + 1 ); build ( mid + 1 , r , deep + 1 ); } int query ( int l , int r , int L , int R , int k , int deep ) { if ( L == R ) return tree [ deep ][ L ]; int mid = ( l + r ) / 2 ; int lef ; int toleft ; if ( l == L ) lef = 0 , toleft = to [ deep ][ R ]; else lef = to [ deep ][ L -1 ], toleft = to [ deep ][ R ] - lef ; if ( k <= toleft ) { return query ( l , mid , l + lef , l + toleft + lef -1 , k , deep + 1 ); } else { return query ( mid + 1 , r , mid + L - l - lef + 1 , mid + R - l - toleft - lef + 1 , k - toleft , deep + 1 ); } } int main () { int n , m , summ = 0 ; while ( scanf ( \"%d\" , & n ) != EOF ) { summ ++ ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & num [ i ]); sorted [ i ] = num [ i ]; tree [ 0 ][ i ] = num [ i ]; } sort ( sorted + 1 , sorted + n + 1 ); build ( 1 , n , 0 ); printf ( \"Case %d: \\n \" , summ ); scanf ( \"%d\" , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int a , b , c ; /// a,b,c\u4ee3\u8868\u67e5\u8be2a\u5230b\u533a\u95f4\u5185\u7b2cc\u5927\u7684\u6570 scanf ( \"%d%d\" , & a , & b ); c = ( b - a ) / 2 + 1 ; printf ( \"%d \\n \" , query ( 1 , n , a , b , c , 0 )); } } }","title":"\u5212\u5206\u6811\u6c42\u4e2d\u4f4d\u6570"},{"location":"icpc/#_15","text":"\u5355\u8c03\u6808 \u662f\u5728\u6808\u7684**\u5148\u8fdb\u540e\u51fa**\u57fa\u7840\u4e4b\u4e0a\u989d\u5916\u6dfb\u52a0\u4e00\u4e2a\u7279\u6027\uff1a**\u4ece\u6808\u9876\u5230\u6808\u5e95**\u7684\u5143\u7d20\u662f\u4e25\u683c\u9012\u589e\u6216\u9012\u51cf\u3002 \u4e3a\u4e86\u7ef4\u62a4\u6808\u7684\u5355\u8c03\u6027\uff0c\u5728\u8fdb\u6808\u8fc7\u7a0b\u4e2d\u9700\u8981\u8fdb\u884c\u5224\u65ad\uff0c\u5177\u4f53\u8fdb\u6808\u8fc7\u7a0b\u5982\u4e0b\uff1a\u5047\u8bbe\u5f53\u524d\u8fdb\u6808\u5143\u7d20\u4e3a e\uff0c \u5bf9\u4e8e\u5355\u8c03\u9012\u589e\u6808\uff0c\u4ece\u6808\u9876\u5f00\u59cb\u904d\u5386\u5143\u7d20\uff0c\u628a\u5c0f\u4e8e e \u6216\u8005\u7b49\u4e8e e \u7684\u5143\u7d20\u5f39\u51fa\u6808\uff0c\u76f4\u81f3\u9047\u89c1\u4e00\u4e2a\u5927\u4e8e e \u7684\u5143\u7d20\u6216\u8005\u6808\u4e3a\u7a7a\u4e3a\u6b62\uff0c\u7136\u540e\u518d\u628a e \u538b\u5165\u6808\u4e2d\uff0c\u8fd9\u6837\u5c31\u80fd\u6ee1\u8db3\u4ece\u6808\u9876\u5230\u6808\u5e95\u7684\u5143\u7d20\u662f\u9012\u589e\u7684 \u5bf9\u4e8e\u5355\u8c03\u9012\u51cf\u6808\uff0c\u5219\u6bcf\u6b21\u5f39\u51fa\u7684\u662f\u5927\u4e8e e \u6216\u8005\u7b49\u4e8e e \u7684\u5143\u7d20\uff0c\u76f4\u81f3\u9047\u89c1\u4e00\u4e2a\u5c0f\u4e8ee\u7684\u5143\u7d20\u6216\u8005\u6808\u4e3a\u7a7a\u4e3a\u6b62 \u5355\u8c03\u6808\u7684\u4f5c\u7528\u5728\u4e8e \u5355\u8c03\u9012\u589e\u6808\u4ece\u6808\u9876\u5230\u6808\u5e95\u662f\u9012\u589e\u7684\uff0c\u6808\u4e2d\u4fdd\u7559\u7684\u90fd\u662f\u6bd4\u5f53\u524d\u5165\u6808\u5143\u7d20\u5927\u7684\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5feb\u901f\u627e\u5230\u5165\u6808\u5143\u7d20\u5de6\u8fb9\u6bd4\u4ed6\u5927\u7684\u5143\u7d20 \u5355\u8c03\u9012\u51cf\u6808\u4ece\u6808\u9876\u5230\u6808\u5e95\u662f\u9012\u51cf\u7684\uff0c\u6808\u4e2d\u4fdd\u7559\u7684\u90fd\u662f\u6bd4\u5f53\u524d\u5165\u6808\u5143\u7d20\u5c0f\u7684\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5feb\u901f\u627e\u5230\u5165\u6808\u5143\u7d20\u5de6\u8fb9\u6bd4\u4ed6\u5c0f\u7684\u5143\u7d20 \u5355\u8c03\u6808\u6c42\u533a\u95f4\u957f\u5ea6\u548c\u533a\u95f4\u6700\u5c0f\u503c\u4e58\u79ef\u6700\u5927\u503c\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll pos , val ; }; node s [ 2005000 ] = { 0 }; ll a [ 2005000 ] = { 0 }; int main () { ll n , top = 0 , ans = 0 ; scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); for ( int j = 1 ; j <= n + 1 ; j ++ ) { if ( top == 0 ) { s [ ++ top ] = { j , a [ j ]}; } else { while ( s [ top ]. val > a [ j ]) ///\u9012\u589e\u6808 { ll tmp = ( j - s [ top - 1 ]. pos - 1 ) * s [ top ]. val ; ans = max ( ans , tmp ); top -- ; } s [ ++ top ] = { j , a [ j ]}; } } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"\u5355\u8c03\u6808"},{"location":"icpc/#_16","text":"\u7ebf\u6027\u57fa\u6c42\u4ea4\uff0c\u53c2\u8003\u4e0e\uff1a https://blog.csdn.net/qcwlmqy/article/details/97584411 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; const int maxn = 50500 ; typedef long long ll ; class Bit_Set { public : ll d [ 32 ]; Bit_Set () { memset ( d , 0 , sizeof ( d )); } Bit_Set ( const Bit_Set & t ) { for ( int i = 0 ; i <= 31 ; i ++ ) d [ i ] = t . d [ i ]; } void clear () { memset ( d , 0 , sizeof ( d )); } void insert ( ll x ) { for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( ll ( 1 ) << i )) { if ( ! d [ i ]) { d [ i ] = x ; return ; } x ^= d [ i ]; } } } bool check ( ll x ) { for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( ll ( 1 ) << i )) { if ( ! d [ i ]) return false ; x ^= d [ i ]; } } return true ; } void show () { for ( int i = 0 ; i <= 31 ; i ++ ) cout << i << ' ' << d [ i ] << endl ; } friend Bit_Set operator + ( const Bit_Set & a , const Bit_Set & b ) { Bit_Set a_b ( a ), c , res ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( b . d [ i ]) { ll x = b . d [ i ], k = ll ( 1 ) << i ; bool flag = true ; for ( int j = 31 ; j >= 0 ; j -- ) { if ( x & ( ll ( 1 ) << j )) { if ( a_b . d [ j ]) { x ^= a_b . d [ j ]; k ^= c . d [ j ]; //\u5c06\u7528\u4e0a\u7684b\u5143\u7d20\u8ba1\u5165k } else { flag = false ; //\u82e5\u4e0d\u80fd\u88aba_b\u8868\u793a\uff0c\u5c06b[i]\u52a0\u5165\u6570\u7ec4 a_b . d [ j ] = x ; c . d [ j ] ^= k ; //\u5c06a_b\u4e2db\u5143\u7d20\u6807\u8bb0 break ; } } } if ( flag ) { ll x = 0 ; for ( int j = 31 ; j >= 0 ; j -- ) { if ( k & ( ll ( 1 ) << j )) x ^= b . d [ j ]; //\u5c06\u7528\u4e0a\u7684b\u5143\u7d20\u548c\u672c\u8eab\u7684b[i]\u5f02\u6216\u5728\u4e00\u8d77\uff0c //\u7531(a[argv---]^b[argv---]^b[i]==0),\u6240\u5f97\u5373\u4e3aV1\u7684\u8d21\u732e } res . insert ( x ); } } } return res ; } }; Bit_Set tree [ maxn << 2 ]; void build ( ll t , ll l , ll r ) { if ( l == r ) { int k ; ll x ; scanf ( \"%d\" , & k ); while ( k -- ) { scanf ( \"%lld\" , & x ); tree [ t ]. insert ( x ); } return ; } int mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); tree [ t ] = tree [ 2 * t ] + tree [ 2 * t + 1 ]; } int query ( ll t , ll l , ll r , ll L , ll R , ll x ) { if ( l <= L && R <= r ) { return tree [ t ]. check ( x ); } int flag = 1 ; int mid = ( L + R ) / 2 ; if ( l <= mid ) flag &= query ( 2 * t , l , r , L , mid , x ); if ( r > mid ) flag &= query ( 2 * t + 1 , l , r , mid + 1 , R , x ); return flag ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); build ( 1 , 1 , n ); while ( m -- ) { int l , r , x ; scanf ( \"%d%d%d\" , & l , & r , & x ); if ( query ( 1 , l , r , 1 , n , x )) puts ( \"YES\" ); else puts ( \"NO\" ); } } \u7ebf\u6027\u57fa\u57fa\u7840 \u6027\u8d28 \u5bf9\u4e8e\u4e00\u4e2a\u6570\u7ec4\uff0c\u5b58\u5728\u4e00\u4e9b\u6570\u6784\u6210\u8be5\u6570\u7ec4\u7684\u7ebf\u6027\u57fa \u7ebf\u6027\u57fa\u6709\u4e09\u5927\u5f88\u4f18\u7f8e\u7684\u6027\u8d28 \u6570\u7ec4\u4e2d\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531\u7ebf\u6027\u57fa\u4e2d\u90e8\u5206\u6570\u5f02\u6216\u5f97\u5230 \u6570\u7ec4\u4e2d\u6240\u6709\u6570\u5f02\u6216\u51fa\u6765\u5747\u4e0d\u4e3a0 \u5bf9\u4e8e\u540c\u4e00\u6570\u7ec4\u7ebf\u6027\u57fa\u4e2a\u6570\u552f\u4e00 \u4f8b\u5982 2 \uff0c4 \uff0c 5 \uff0c 6 ,\u7531\u7ebf\u6027\u57fa ,\u7531\u7ebf\u6027\u57fa 1 , 2 , 4 1 , 2 , 4 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 1,2,41,2,4 2 \uff0c4 \uff0c 5 \uff0c 6 <span class=\"arithmatex\"><span class=\"MathJax_Preview\">,\u7531\u7ebf\u6027\u57fa</span><script type=\"math/tex\">,\u7531\u7ebf\u6027\u57fa 1 , 2 , 4 1 , 2 , 4 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 1,2,41,2,4 \u5f02\u6216\u5f97\u5230 \u7ebf\u6027\u57fa\u6784\u9020 \u6570\u7ec4\u6bcf\u52a0\u5165\u4e00\u4e2a\u6570\uff0c\u5bf9\u7ebf\u6027\u57fa\u8fdb\u884c\u4fee\u6539 \u4ee4\u7ebf\u6027\u57fa\u4e3ad[32] ,\u6570\u7ec4\u957f\u5ea6\u4e3amax(a[i])\u7684\u6700\u5927\u4e8c\u8fdb\u5236\uff08\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531$ 1 , 2 , 4 \u22ef ,2^n$ \u8868\u793a\uff09 void add ( int x ) { for ( int i = 31 ; i >= 0 ; i -- ) { //i\u4e3a\u7ebf\u6027\u57fa\u4e0b\u6807 if ( x & ( 1 << i )) { if ( d [ i ]) x ^= d [ i ]; //\u82e5\u8be5\u4e8c\u8fdb\u5236\u4f4d\u5df2\u6709\u503c\uff0c\u5f02\u6216\u5bfb\u627e\u7ebf\u6027\u57fa\u80fd\u5426\u8868\u8fbex^d[i] else { d [ i ] = x ; //\u82e5\u4e8c\u8fdb\u5236\u4f4d\u6ca1\u6709\u503c\uff0c\u8bf4\u660ex\u4e0d\u80fd\u88ab\u7ebf\u6027\u57fa\u8868\u8fbe\uff0c\u4ee4d[i]=x break ; //\u8bb0\u5f97\u5982\u679c\u63d2\u5165\u6210\u529f\u4e00\u5b9a\u8981\u9000\u51fa } } } } \u6784\u9020\u5408\u7406\u6027\uff1a \u82e5\u80fd\u63d2\u5165x \uff0c\u5219\u5c06d[i] =x\uff0cx\u53ef\u4ee5\u7531\u7ebf\u6027\u57fa\u8868\u8fbe \u82e5\u4e0d\u80fd\u63d2\u5165x\uff0c\u5219x\u6700\u7ec8\u5f02\u6216\u4e3a0\uff0c\u5373\u53ef\u4ee5\u7531\u7ebf\u6027\u57fa\u8868\u8fbe \u533a\u95f4\u5f02\u6216\u6700\u5927\u503c \u6570\u7ec4 ( L , R ) ( L , R ) \u5185\u53d6\u82e5\u5e72\u4e2a\u6570\uff0c\u4f7f\u8fd9\u4e9b\u6570\u5f02\u6216\u540e\u5f97\u5230\u7684\u503c\u6700\u5927 \u4ee4 d [ 32 ] \u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c \u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c p [ 32 ]p [ 32 ] d [ 32 ] <span class=\"arithmatex\"><span class=\"MathJax_Preview\">\u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c</span><script type=\"math/tex\">\u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c p [ 32 ]p [ 32 ] \u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u4f4d\u7f6e\uff08\u4e3a\u4e86\u4fbf\u4e8e\u8be2\u95ee\uff0c\u4f4d\u7f6e\u5c3d\u91cf\u5b58\u504f\u53f3\u7684\uff09 int ask ( int l , int r ){ int res = 0 ; for \uff08 int i = 31 ; i >= 0 ; i -- \uff09 if ( p [ i ] >= l && ( res ^ d [ i ]) > res ) res ^= d [ i ]; return res ; } \u8d2a\u5fc3\uff1a\u9ad8\u4f4d\u80fd\u53d8\u62101\uff0c\u5c31\u53d8\u62101\uff08\u9ad8\u4f4d1\u6bd4\u4f4e\u4f4d\u90fd\u53d8\u62101\u90fd\u6709\u4ef7\u503c\uff09 \u533a\u95f4\u5f02\u6216\u7b2ck\u5927 \u5148\u5c06\u7ebf\u6027\u57fa\u5904\u7406\u6210$ 1 , 2 , 4 , \u22ef ,2^n$ \u7684\u4e8c\u8fdb\u5236\u8868\u8fbe\u5f62\u5f0f \u53bb\u9664\u4e3a0\u7684\u5f02\u6216\u503c\uff0c\u6bcf\u4e00\u4f4dd[i] =1 \u76f8\u5f53\u4e8e\u53ef\u4ee5\u8868\u8fbe\u7684\u4e8c\u8fdb\u5236\u4f4d\u6570\u589e\u52a0\u4e00\u4f4d void work () { //\u5c06\u7ebf\u6027\u57fa\u8f6c\u5316\u4e3a2\u8fdb\u5236 for ( int i = 1 ; i <= 31 ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) if ( d [ i ] & ( 1 << ( j -1 ))) d [ i ] ^= d [ j -1 ]; } int k_th ( int k ) { if ( k == 1 && tot < n ) return 0 ; //\u7279\u5224\u4e00\u4e0b\uff0c\u5047\u5982k=1\uff0c\u5e76\u4e14\u539f\u6765\u7684\u5e8f\u5217\u53ef\u4ee5\u5f02\u6216\u51fa0\uff0c\u5c31\u8981\u8fd4\u56de0\uff0c //tot\u8868\u793a\u7ebf\u6027\u57fa\u4e2d\u7684\u5143\u7d20\u4e2a\u6570\uff0cn\u8868\u793a\u5e8f\u5217\u957f\u5ea6 if ( tot < n ) k -- ; //\u7c7b\u4f3c\u4e0a\u9762\uff0c\u53bb\u63890\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a\u7ebf\u6027\u57fa\u4e2d\u53ea\u80fd\u5f02\u6216\u51fa\u4e0d\u4e3a0\u7684\u89e3 work (); int ans = 0 ; for ( int i = 0 ; i <= 31 ; i ++ ) if ( d [ i ] != 0 ) { if ( k & 1 ) ans ^= d [ i ]; k >>= 1 ; } }","title":"\u7ebf\u6027\u57fa"},{"location":"icpc/#_17","text":"\u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/zuzhiang/article/details/78173412 https://www.cnblogs.com/s1124yy/p/6258026.html https://blog.csdn.net/tianwei0822/article/details/79439054 \u4e3b\u5e2d\u6811\u7ef4\u62a4\u533a\u95f4\u7b2ck\u5927\u6570 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; int L [ 3200500 ] = { 0 }, R [ 3200500 ] = { 0 }, sum [ 3200500 ] = { 0 }; int tot = 0 ; int a [ 3200500 ] = { 0 }, hash1 [ 3200500 ] = { 0 }, T [ 3200500 ] = { 0 }; int build ( int l , int r ) { int root = ++ tot ; sum [ root ] = 0 ; if ( l < r ) { int mid = ( l + r ) / 2 ; L [ root ] = build ( l , mid ); R [ root ] = build ( mid + 1 , r ); } return root ; } int update ( int pre , int l , int r , int pos ) { int root = ++ tot ; L [ root ] = L [ pre ]; R [ root ] = R [ pre ]; sum [ root ] = sum [ pre ] + 1 ; if ( l < r ) { int mid = ( l + r ) / 2 ; if ( pos <= mid ) L [ root ] = update ( L [ pre ], l , mid , pos ); else R [ root ] = update ( R [ pre ], mid + 1 , r , pos ); } return root ; } int query ( int l1 , int r1 , int l , int r , int k ) //\u53c2\u6570\u5206\u522b\u4e3a\uff1a\u4e24\u9897\u7ebf\u6bb5\u6811\u6839\u8282\u70b9\u7684\u7f16\u53f7\uff0c\u5de6\u53f3\u7aef\u70b9\uff0c\u7b2ck\u5927 { if ( l >= r ) return l ; int mid = ( l + r ) / 2 ; int num = sum [ L [ r1 ]] - sum [ L [ l1 ]]; if ( num >= k ) return query ( L [ l1 ], L [ r1 ], l , mid , k ); else return query ( R [ l1 ], R [ r1 ], mid + 1 , r , k - num ); } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { tot = 0 ; int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]), hash1 [ i ] = a [ i ]; sort ( hash1 + 1 , hash1 + n + 1 ); int d = unique ( hash1 + 1 , hash1 + n + 1 ) - hash1 - 1 ; T [ 0 ] = build ( 1 , d ); for ( int i = 1 ; i <= n ; i ++ ) { int pos = lower_bound ( hash1 + 1 , hash1 + d + 1 , a [ i ]) - hash1 ; T [ i ] = update ( T [ i - 1 ], 1 , d , pos ); } for ( int i = 1 ; i <= m ; i ++ ) { int l , r , k ; scanf ( \"%d%d%d\" , & l , & r , & k ); int pos = query ( T [ l - 1 ], T [ r ], 1 , d , k ); printf ( \"%d \\n \" , hash1 [ pos ]); } } } \u67e5\u8be2\u533a\u95f4\u5185\u5c0f\u4e8e\u7b49\u4e8e\u7ed9\u5b9a\u7684K\u7684\u6570\u7684\u4e2a\u6570 \u9898\u76ee\u94fe\u63a5\uff1a https://acm.hdu.edu.cn/showproblem.php?pid=4417 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; int L [ 3200500 ] = { 0 }, R [ 3200500 ] = { 0 }, sum [ 3200500 ] = { 0 }; int tot = 0 ; int a [ 3200500 ] = { 0 }, hash1 [ 3200500 ] = { 0 }, T [ 3200500 ] = { 0 }; int build ( int l , int r ) { int root = ++ tot ; sum [ root ] = 0 ; if ( l < r ) { int mid = ( l + r ) / 2 ; L [ root ] = build ( l , mid ); R [ root ] = build ( mid + 1 , r ); } return root ; } int update ( int pre , int l , int r , int pos ) { int root = ++ tot ; L [ root ] = L [ pre ]; R [ root ] = R [ pre ]; sum [ root ] = sum [ pre ] + 1 ; if ( l < r ) { int mid = ( l + r ) / 2 ; if ( pos <= mid ) L [ root ] = update ( L [ pre ], l , mid , pos ); else R [ root ] = update ( R [ pre ], mid + 1 , r , pos ); } return root ; } int query ( int l1 , int r1 , int l , int r , int k ) { if ( k < hash1 [ l ]) return 0 ; if ( hash1 [ r ] <= k ) return sum [ r1 ] - sum [ l1 ]; int mid = ( l + r ) / 2 ; if ( k <= hash1 [ mid ]) { return query ( L [ l1 ], L [ r1 ], l , mid , k ); } else { int num = 0 ; num += sum [ L [ r1 ]] - sum [ L [ l1 ]]; num += query ( R [ l1 ], R [ r1 ], mid + 1 , r , k ); return num ; } } int main () { int t ; scanf ( \"%d\" , & t ); for ( int t1 = 1 ; t1 <= t ; t1 ++ ) { tot = 0 ; int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]), hash1 [ i ] = a [ i ]; sort ( hash1 + 1 , hash1 + n + 1 ); int d = unique ( hash1 + 1 , hash1 + n + 1 ) - hash1 - 1 ; T [ 0 ] = build ( 1 , d ); for ( int i = 1 ; i <= n ; i ++ ) { int pos = lower_bound ( hash1 + 1 , hash1 + d + 1 , a [ i ]) - hash1 ; T [ i ] = update ( T [ i - 1 ], 1 , d , pos ); } printf ( \"Case %d: \\n \" , t1 ); for ( int i = 1 ; i <= m ; i ++ ) { int l , r , k ; scanf ( \"%d%d%d\" , & l , & r , & k ); int ans = query ( T [ l ], T [ r + 1 ], 1 , d , k ); printf ( \"%d \\n \" , ans ); } } }","title":"\u4e3b\u5e2d\u6811"},{"location":"icpc/#_18","text":"","title":"\u5b57\u7b26\u4e32"},{"location":"icpc/#kmp","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; const ll N = 1005000 ; ll Next [ N ]; char s [ N ]; char t [ N ]; ll tlen , len ; void getNext ( char s [ N ]) { ll j = 0 , k = -1 ; Next [ 0 ] = -1 ; while ( j < tlen ) { if ( k == -1 || s [ j ] == s [ k ]) { Next [ ++ j ] =++ k ; } else k = Next [ k ]; } } int main () { while ( 1 ) { scanf ( \"%s\" , s ); if ( s [ 0 ] == '.' ) break ; tlen = strlen ( s ); len = tlen ; getNext ( s ); ll kk = tlen - Next [ tlen ]; if ( strlen ( s ) % kk == 0 ) { printf ( \"%d \\n \" , strlen ( s ) / kk ); } else { printf ( \"1 \\n \" ); //\u5982\u679c\u4e0d\u80fd\u9664\u5c3d\uff0c\u8bf4\u660e\u6709\u540e\u7f00\uff0c\u4f8b\u5982abababa\uff0c\u8fd9\u79cd\u60c5\u51b5\u53ea\u80fd\u4e3a1 } } return 0 ; }","title":"KMP\u7b97\u6cd5"},{"location":"icpc/#_19","text":"\u7ed9\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u5b57\u7b26\u4e32(1<=n<=200000),\u4ed6\u53ea\u5305\u542b**\u5c0f\u5199**\u5b57\u6bcd \u627e\u5230\u8fd9\u4e2a\u5b57\u7b26\u4e32\u591a\u5c11\u4e2a\u524d\u7f00\u662fM\u5f62\u5b57\u7b26\u4e32. M\u5f62\u5b57\u7b26\u4e32\u5b9a\u4e49\u5982\u4e0b: \u4ed6\u7531\u4e24\u4e2a\u76f8\u540c\u7684\u56de\u6587\u4e32\u62fc\u63a5\u800c\u6765,\u7b2c\u4e00\u4e2a\u56de\u6587\u4e32\u7684\u7ed3\u5c3e\u5b57\u7b26\u548c\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u4e32\u7684\u5f00\u59cb\u5b57\u7b26\u53ef\u4ee5\u91cd\u53e0,\u4e5f\u5c31\u662f\u4ee5\u4e0b\u90fd\u662fM \u5f62\u5b57\u7b26\u4e32. abccbaabccba(\u7531abccba+abccba\u7ec4\u6210) abcbaabcba(\u6709abcba+abcba\u7ec4\u6210) abccbabccba(\u7531abccba+abccba\u7ec4\u6210\u7ec4\u6210,\u4f46\u662f\u4e2d\u95f4\u76841\u662f\u5171\u7528\u7684) a(\u4e00\u4e2a\u5355\u72ec\u5b57\u7b26\u4e5f\u7b97) #include <bits/stdc++.h> using namespace std ; typedef unsigned long long int ULL ; const int N = 200010 ; int P = 131 ; ULL p [ N ], h [ N ], ed [ N ]; int ask1 ( int l , int r ) { return h [ r ] - h [ l - 1 ] * p [ r - l + 1 ]; } int ask2 ( int l , int r ) { return ed [ l ] - ed [ r + 1 ] * p [ r - l + 1 ]; } int main () { int ans = 0 ; char str [ N ]; cin >> str + 1 ; int n = strlen ( str + 1 ); p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { h [ i ] = h [ i - 1 ] * P + str [ i ]; p [ i ] = p [ i - 1 ] * P ; } for ( int i = n ; i >= 0 ; i -- ) { ed [ i ] = ed [ i + 1 ] * P + str [ i ]; } for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) { int x = ( i + 1 ) / 2 ; if ( ask1 ( 1 , x ) == ask1 ( x , i ) && ask1 ( 1 , x ) == ask2 ( 1 , x )) ans ++ ; } else { int x = i / 2 ; if ( ask1 ( 1 , x ) == ask1 ( x + 1 , i ) && ask1 ( 1 , x ) == ask2 ( 1 , x )) ans ++ ; } } cout << ans ; }","title":"\u5b57\u7b26\u4e32\u54c8\u5e0c"},{"location":"icpc/#_20","text":"#include <bits/stdc++.h> ///\u6c42\u89e3\u6700\u957f\u56de\u6587\u4e32\uff0c\u5bf9p[i]/2\u6c42\u548c\u5373\u53ef\u5f97\u56de\u6587\u4e32\u4e2a\u6570 using namespace std ; typedef long long ll ; char a [ 500500 ] = { 0 }; int l [ 500500 ] = { 0 }; int r [ 500500 ] = { 0 }; string str = \"$#\" ; vector < int > p ; void manacher ( char * c ) { int max_id = 0 , id = 0 ; for ( int i = 1 ; c [ i ]; i ++ ) str += c [ i ], str += \"#\" ; p . push_back ( 1 ); for ( int i = 1 ; i < ( int ) str . size (); i ++ ) { if ( max_id > i ) p . push_back ( min ( max_id - i , p [ 2 * id - i ])); else p . push_back ( 1 ); while ( i + p [ i ] < ( int ) str . size () && str [ i + p [ i ]] == str [ i - p [ i ]]) p [ i ] ++ ; if ( i + p [ i ] > max_id ){ max_id = i + p [ i ], id = i ; } } } int main () { scanf ( \"%s\" , a + 1 ); manacher ( a ); int now = 0 , n = str . size (), ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , p [ i ] -1 ); printf ( \"%d\" , ans ); }","title":"\u56de\u6587\u4e32\u5339\u914d\u7b97\u6cd5\uff08\u9a6c\u62c9\u8f66\u7b97\u6cd5\uff09"},{"location":"icpc/#_21","text":"\u4ece\u4e00\u7ec4\u6570\u636e\u4e2d\u9009\u53d6\u4e24\u4e2a\u6570\u6c42\u6700\u5927\u5f02\u6216\u503c\u3002 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 1005000 ] = { 0 }; int tree [ 5000500 ][ 3 ] = { 0 }; int tot = 1 ; ///\u5fc5\u987b\u4ece1\u5f00\u59cb int in ( int x ) { int p = 1 ; for ( int i = 30 ; i >= 0 ; i -- ) { int k = x >> i & 1 ; if ( tree [ p ][ k ] == 0 ) tree [ p ][ k ] =++ tot ; p = tree [ p ][ k ]; } } int out ( int x ) { int p = 1 , ans = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { int k = x >> i & 1 ; if ( tree [ p ][ ! k ]) { ans = ans * 2 +! k ; p = tree [ p ][ ! k ]; } else { ans = ans * 2 + k ; p = tree [ p ][ k ]; } } return ans ; } int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { in ( a [ i ]); int num = out ( a [ i ]); max1 = max ( max1 , num ^ a [ i ]); } cout << max1 << endl ; return 0 ; }","title":"\u5b57\u5178\u6811"},{"location":"icpc/#_22","text":"\u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/qq_40736036/article/details/89110584 #include <bits/stdc++.h> using namespace std ; typedef unsigned long long ull ; typedef long long ll ; const ll mod = 10000 ; char c [ 5000500 ] = { 0 }; struct grammer { pair < char * , ll > Q ( char * p ) { pair < char * , ll > ans1 = E ( p ); if ( ans1 . first == NULL ) return { NULL , 0 }; ans1 . second %= mod ; return ans1 ; } pair < char * , ll > E ( char * p ) { pair < char * , ll > ans1 = T ( p ); if ( ans1 . first == NULL ) return { NULL , 0 }; while ( * ans1 . first == '+' || * ans1 . first == '-' ) { pair < char * , ll > ans2 = T ( ans1 . first + 1 ); if ( ans2 . first == NULL ) return { NULL , 0 }; if ( * ans1 . first == '+' ) ans1 . second += ans2 . second ; else if ( * ans1 . first == '-' ) ans1 . second -= ans2 . second ; ans1 . second = ( ans1 . second % mod + mod ) % mod ; ans1 . first = ans2 . first ; } return ans1 ; } pair < char * , ll > T ( char * p ) { pair < char * , ll > ans1 = F ( p ); if ( ans1 . first == NULL ) return { NULL , 0 }; while ( * ans1 . first == '*' ) { pair < char * , ll > ans2 = F ( ans1 . first + 1 ); if ( ans2 . first == NULL ) return { NULL , 0 }; ans1 . second *= ans2 . second ; ans1 . second %= mod ; ans1 . first = ans2 . first ; } return ans1 ; } pair < char * , ll > F ( char * p ) { if ( * p >= '0' || * p <= '9' ) { return N ( p ); } else if ( * p == '-' ) { pair < char * , ll > ans1 = F ( p + 1 ); if ( ans1 . first == NULL ) return { NULL , 0 }; return { ans1 . first , ( - ans1 . second % mod + mod ) % mod }; } else if ( * p == '(' ) { pair < char * , ll > ans1 = E ( p + 1 ); if ( ans1 . first == NULL ) return { NULL , 0 }; if ( * ans1 . first == ')' ) return { ans1 . first + 1 , ans1 . second % mod }; else return { NULL , 0 }; } else { return { NULL , 0 }; } } pair < char * , ll > N ( char * p ) { if ( * p == '0' ) { // if (*(p + 1) >= '0' || *(p + 1) <= '9') // return {NULL, 0}; // else return { p + 1 , 0 }; } else if ( * p >= '1' && * p <= '9' ) { pair < char * , ll > ans1 = B ( p ); if ( ans1 . first == NULL ) { return { NULL , 0 }; } return { ans1 . first , ans1 . second % mod }; } else { return { NULL , 0 }; } } pair < char * , ll > B ( char * p ) { ll sum = 0 ; while ( * p >= '0' && * p <= '9' ) { sum = sum * 10 + * p - '0' ; p ++ ; sum %= mod ; } return { p , sum % mod }; } } Grammer ; int main () { scanf ( \"%s\" , c + 1 ); ll ans = ( Grammer . Q ( c + 1 ). second % mod + mod ) % mod ; printf ( \"%lld \\n \" , ans ); }","title":"\u6587\u6cd5\u5206\u6790"},{"location":"icpc/#ac","text":"\u53c2\u8003\u94fe\u63a5\uff1a https://www.cnblogs.com/nullzx/p/7499397.html https://zhuanlan.zhihu.com/p/80325757 https://oi-wiki.org/string/ac-automaton/ AC\u81ea\u52a8\u673a\u6a21\u677f\uff1a \u7ed9\u5b9a n n \u4e2a\u6a21\u5f0f\u4e32 s_i s_i \u548c\u4e00\u4e2a\u6587\u672c\u4e32 t t \uff0c\u6c42\u6709\u591a\u5c11\u4e2a\u4e0d\u540c\u7684\u6a21\u5f0f\u4e32\u5728\u6587\u672c\u4e32\u91cc\u51fa\u73b0\u8fc7\u3002 \u4e24\u4e2a\u6a21\u5f0f\u4e32\u4e0d\u540c\u5f53\u4e14\u4ec5\u5f53\u4ed6\u4eec**\u7f16\u53f7**\u4e0d\u540c\u3002 #include <bits/stdc++.h> using namespace std ; const int N = 1e6 + 6 ; int n ; namespace AC { int tr [ N ][ 26 ], tot ; int e [ N ], fail [ N ]; void insert ( char * s ) { int u = 0 ; for ( int i = 1 ; s [ i ]; i ++ ) { if ( ! tr [ u ][ s [ i ] - 'a' ]) tr [ u ][ s [ i ] - 'a' ] = ++ tot ; //\u5982\u679c\u6ca1\u6709\u5219\u63d2\u5165\u65b0\u8282\u70b9 u = tr [ u ][ s [ i ] - 'a' ]; //\u641c\u7d22\u4e0b\u4e00\u4e2a\u8282\u70b9 } e [ u ] ++ ; //\u5c3e\u4e3a\u8282\u70b9 u \u7684\u4e32\u7684\u4e2a\u6570 } queue < int > q ; void build () { for ( int i = 0 ; i < 26 ; i ++ ) if ( tr [ 0 ][ i ]) q . push ( tr [ 0 ][ i ]); while ( q . size ()) { int u = q . front (); q . pop (); for ( int i = 0 ; i < 26 ; i ++ ) { if ( tr [ u ][ i ]) { fail [ tr [ u ][ i ]] = tr [ fail [ u ]][ i ]; // fail\u6570\u7ec4\uff1a\u540c\u4e00\u5b57\u7b26\u53ef\u4ee5\u5339\u914d\u7684\u5176\u4ed6\u4f4d\u7f6e q . push ( tr [ u ][ i ]); } else tr [ u ][ i ] = tr [ fail [ u ]][ i ]; } } } int query ( char * t ) { int u = 0 , res = 0 ; for ( int i = 1 ; t [ i ]; i ++ ) { u = tr [ u ][ t [ i ] - 'a' ]; // \u8f6c\u79fb for ( int j = u ; j && e [ j ] != -1 ; j = fail [ j ]) { res += e [ j ], e [ j ] = -1 ; } } return res ; } } // namespace AC char s [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , s + 1 ), AC :: insert ( s ); scanf ( \"%s\" , s + 1 ); AC :: build (); printf ( \"%d\" , AC :: query ( s )); return 0 ; }","title":"AC\u81ea\u52a8\u673a"},{"location":"icpc/#_23","text":"","title":"\u6570\u8bba"},{"location":"icpc/#_24","text":"\u4ee3\u7801\u5b9e\u73b0\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n , ans = 0 ; scanf ( \"%lld\" , & n ); for ( ll l = 1 , r ; l <= n ; l = r + 1 ) { r = n / ( n / l ); ans += ( r - l + 1 ) * ( n / l ); } printf ( \"%lld \\n \" , ans ); }","title":"\u6574\u6570\u5206\u5757"},{"location":"icpc/#_25","text":"///\u53c2\u7167\u4e8e\uff1a //https://www.luogu.com.cn/blog/SuuTTT/solution%2Dp1029 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; const ll maxn = 1e7 + 5 ; ll low_prime [ 10050000 ] = { 0 }; ll prime [ 700500 ] = { 0 }; ll cnt = 0 ; int main () { for ( ll i = 2 ; i <= maxn ; i ++ ) { if ( low_prime [ i ] == 0 ) { low_prime [ i ] = i ; prime [ ++ cnt ] = i ; } for ( ll j = 1 ; j <= cnt && prime [ j ] * i <= maxn ; j ++ ) { low_prime [ prime [ j ] * i ] = prime [ j ]; if ( i % prime [ j ] == 0 ) break ; } } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , flag = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { ll m , sum = 0 ; scanf ( \"%lld\" , & m ); while ( m > 1 ) { m /= low_prime [ m ]; sum ++ ; } flag ^= sum ; ///sum\u5373\u4e3a\u8d28\u56e0\u6570\u7684\u4e2a\u6570 } if ( ! flag ) puts ( \"Bob\" ); else puts ( \"Alice\" ); } }","title":"\u7ebf\u6027\u7b5b\u6c42\u8d28\u56e0\u6570\u7684\u4e2a\u6570"},{"location":"icpc/#_26","text":"#include <bits/stdc++.h> using namespace std ; int is_prime [ 100500 ] = { 0 }; vector < int > prime ; int oula_table [ 100500 ] = { 0 }; void init ( int n ) ///\u6253\u7d20\u6570\u8868 { for ( int i = 2 ; i <= n ; i ++ ) { if ( ! is_prime [ i ]) prime . push_back ( i ); for ( int j = 0 ; j <= prime . size () && i * prime [ j ] <= n ; j ++ ) { is_prime [ i * prime [ j ]] = 1 ; if ( i % prime [ j ] == 0 ) break ; } } } int oula1 ( int n ) ///\u6839\u636e\u7d20\u6570\u8868\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int ans = n ; for ( int i = 0 ; prime [ i ] * prime [ i ] <= n ; i ++ ) { if ( n % prime [ i ] == 0 ) ans = ans - ans / prime [ i ]; while ( n % prime [ i ] == 0 ) n /= prime [ i ]; } return ans ; } int oula2 ( int n ) ///\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int m = n ; int ans = n ; for ( int i = 2 ; i <= sqrt ( n ); i ++ ) { if ( m % i == 0 ) ans = ans - ans / i ; while ( m % i == 0 ) m /= i ; } if ( m != 1 ) ans = ans - ans / m ; return ans ; } void get_oula_table ( int n ) ///\u6b27\u62c9\u6253\u8868 { for ( int i = 1 ; i <= n ; i ++ ) oula_table [ i ] = 0 ; oula_table [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! oula_table [ i ]) ///\u8bf4\u660ei\u662f\u8d28\u6570 { for ( int j = i ; j <= n ; j += i ) //\u53bb\u627ei\u7684\u500d\u6570 { if ( ! oula_table [ j ]) oula_table [ j ] = j ; oula_table [ j ] = oula_table [ j ] / i * ( i -1 ); } } } } int main () { int n ; cin >> n ; init ( n ); cout << \"\u627e\u7d20\u6570\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula1 ( n ) << endl ; cout << \"\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula2 ( n ) << endl ; get_oula_table ( n ); cout << \"\u6253\u8868\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" ; for ( int i = 1 ; i <= n ; i ++ ) cout << oula_table [ i ] << ' ' ; }","title":"\u6b27\u62c9\u51fd\u6570\u6a21\u677f"},{"location":"icpc/#_27","text":"#include <iostream> #include <bits/stdc++.h> using namespace std ; int a [ 2005000 ] = { 0 }; int b [ 2005000 ] = { 0 }; long long int merge_sort ( long long int l , long long int r ) { if ( l >= r ) return 0 ; long long int mid = ( l + r ) >> 1 , res = 0 ; res += merge_sort ( l , mid ); res += merge_sort ( mid + 1 , r ); long long int i = l , j = mid + 1 , cnt = 0 ; while ( i <= mid && j <= r ) if ( a [ i ] <= a [ j ]) b [ cnt ++ ] = a [ i ++ ]; else { res += mid - i + 1 ; b [ cnt ++ ] = a [ j ++ ]; } while ( i <= mid ) b [ cnt ++ ] = a [ i ++ ]; while ( j <= r ) b [ cnt ++ ] = a [ j ++ ]; for ( long long int i = l , j = 0 ; j < cnt ; ++ i , ++ j ) a [ i ] = b [ j ]; return res ; } int main () { int n ; cin >> n ; for ( long long int i = 0 ; i < n ; i ++ ) { cin >> a [ i ]; } long long int sum = merge_sort ( 0 , n -1 ); cout << sum << endl ; return 0 ; } #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n , m ; ll a [ 100500 ] = { 0 }; ll c [ 100500 ] = { 0 }; ll maxn = 10050 , k , ans = 0 ; ll lowbit ( ll x ) { return x & ( - x ); } ll add ( ll k , ll x ) { for ( ll i = k ; i <= maxn ; i += lowbit ( i )) c [ i ] += x ; } ll getsum ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c [ i ]; return ans ; } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & k ); add ( k , 1 ); ans += i - getsum ( k ); } printf ( \"%d \\n \" , ans ); }","title":"\u9006\u5e8f\u5bf9"},{"location":"icpc/#_28","text":"#include <bits/stdc++.h> using namespace std ; const int maxn = 5010 ; int g [ maxn ][ maxn ]; int main ( void ) { int N , R ; cin >> N >> R ; int n = R , m = R ; for ( int i = 0 , x , y , w ; i < N ; ++ i ) { cin >> x >> y >> w ; x ++ , y ++ ; n = max ( n , x ); m = max ( m , y ); g [ x ][ y ] += w ; } for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) g [ i ][ j ] += g [ i -1 ][ j ] + g [ i ][ j -1 ] - g [ i -1 ][ j -1 ]; int ans = 0 ; for ( int i = R ; i <= n ; i ++ ) for ( int j = R ; j <= m ; j ++ ) ans = max ( ans , g [ i ][ j ] - g [ i - R ][ j ] - g [ i ][ j - R ] + g [ i - R ][ j - R ]); cout << ans ; return 0 ; }","title":"\u4e8c\u7ef4\u524d\u7f00\u548c"},{"location":"icpc/#_29","text":"\u6c42\u89e3$a * x + b * y = gcd(a,b) $\u65b9\u7a0b\u7684\u901a\u89e3x\u548cy #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll N = 1e9 + 7 ; ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll d = exgcd ( b , a % b , x , y ); ll t = x ; x = y ; y = t - ( a / b ) * y ; return d ; } int main () { ll a = 3 , b = 5 , x = 0 , y = 0 ; ll g = exgcd ( a , b , x , y ); cout << \"\u7279\u89e3\u4e3a\" << \"x=\" << x << \",y=\" << y << endl ; for ( int i = 1 ; i <= 5 ; i ++ ) { x += b / g ; y -= a / g ; cout << \"\u901a\u89e3\u4e3a\" << \"x=\" << x << \",y=\" << y << endl ; } return 0 ; } \u6c42\u89e3\u4e00\u822c\u65b9\u7a0b a * x+b * y=c a * x+b * y=c \u7684\u901a\u89e3x\u548cy \u5c06\u65b9\u7a0b\u8f6c\u53d8\u4e3a\uff1a a * x+b * y=gcd(a, b) * c/gcd(a, b); a * x+b * y=gcd(a, b) * c/gcd(a, b); \u6700\u7ec8\u5373\u4e3a\uff1a a * x/(c/gcd(a, b))+b * y/(c/gcd(a, b))=gcd(a, b); a * x/(c/gcd(a, b))+b * y/(c/gcd(a, b))=gcd(a, b); \u5373\u628a\u7ed3\u679c\u8c03\u6574\u4e3a\uff1a x1=x0 * c/gcd(a, b); y1=y0 * c/gcd(a, b); x1=x0 * c/gcd(a, b); y1=y0 * c/gcd(a, b); #include <stdio.h> long long exgcd ( long long a , long long b , long long & x , long long & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } long long r = exgcd ( b , a % b , x , y ), t ; t = x ; x = y ; y = t - ( a / b ) * y ; return r ; } int main () { long long a , b , c , ans , x , y ; while ( scanf ( \"%lld%lld%lld\" , & a , & b , & c ) != EOF ) { ans = exgcd ( a , b , x , y ); if ( c % ans == 0 ) { x =- x * c / ans ; y =- y * c / ans ; printf ( \"%lld %lld \\n \" , x , y ); } else printf ( \"-1 \\n \" ); } return 0 ; }","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u7406"},{"location":"icpc/#_30","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a , q ; ll ksm ( ll n , ll k ) { ll sum1 = 1 , sum2 = n ; while ( k != 0 ) { if ( k % 2 == 1 ) sum1 = sum1 * sum2 % q ; sum2 = sum2 * sum2 % q ; k /= 2 ; } return sum1 ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; cin >> a >> q ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << ksm ( a , q -2 ) << endl ; } #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll exgcd ( ll a , ll b , ll & x , ll & y ) ///\u540e\u4e24\u4e2a\u53c2\u6570\u4e3a\u5f15\u7528 { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll gcd_ans = exgcd ( b , a % b , x , y ); ll tem = x ; x = y ; y = tem - a / b * y ; return gcd_ans ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; ll a , q , x = 0 , y = 0 ; cin >> a >> q ; ll gcd_ans = exgcd ( q , a , x , y ); ll mul = q / gcd_ans ; y = ( y % mul + mul ) % mul ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << y << endl ; }","title":"\u9006\u5143"},{"location":"icpc/#_31","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; stack < char > sc ; stack < ll > sll ; char a [ 100500 ] = { 0 }; inline ll qpow ( ll a , ll b ) { ll ans = 1 ; while ( b ) { if ( b & 1 ) ans *= a ; a *= a , b >>= 1 ; } return ans ; } int cmp1 ( char a1 , char a2 ) { if ( a2 == '(' ) return -1 ; if ( a2 == ')' ) { if ( a1 == '(' ) return 0 ; else if ( a1 == '#' ) return 0 ; else return 1 ; } if ( a2 == '+' || a2 == '-' ) { if ( a1 == '+' || a1 == '-' || a1 == '*' || a1 == '/' || a1 == '^' ) return 1 ; else return -1 ; } if ( a2 == '*' || a2 == '/' ) { if ( a1 == '*' || a1 == '/' || a1 == '^' ) return 1 ; else return -1 ; } if ( a2 == '^' ) { if ( a1 == '^' ) return 1 ; else return -1 ; } if ( a2 == '#' ) { if ( a1 == '#' ) return 0 ; else if ( a1 == '(' || a1 == ')' ) return 0 ; else return 1 ; } return 0 ; } int main () { scanf ( \"%s\" , a + 1 ); a [ strlen ( a + 1 ) + 1 ] = '#' ; ll tem = 0 , tem2 , tem1 ; sll . push ( 0 ); sc . push ( '#' ); for ( int i = 1 ; a [ i ]; i ++ ) { if ( a [ i ] <= '9' && a [ i ] >= '0' ) { tem = tem * 10 + a [ i ] - '0' ; if ( a [ i + 1 ] < '0' || a [ i + 1 ] > '9' ) sll . push ( tem ), tem = 0 ; } else { while ( ! sc . empty ()) { ll tem_cmp = cmp1 ( sc . top (), a [ i ]); if ( tem_cmp == 1 ) { tem2 = sll . top (); sll . pop (); tem1 = sll . top (); sll . pop (); if ( sc . top () == '+' ) sll . push ( tem1 + tem2 ); else if ( sc . top () == '-' ) sll . push ( tem1 - tem2 ); else if ( sc . top () == '*' ) sll . push ( tem1 * tem2 ); else if ( sc . top () == '/' ) sll . push ( tem1 / tem2 ); else if ( sc . top () == '^' ) sll . push (( ll ) qpow ( tem1 , tem2 )); sc . pop (); } else if ( tem_cmp == 0 ) { if ( a [ i ] != ')' || ( a [ i ] == ')' && sc . size () > 1 )) sc . pop (); break ; } else if ( tem_cmp == -1 ) { sc . push ( a [ i ]); break ; } } } } cout << sll . top () << endl ; }","title":"\u8868\u8fbe\u5f0f\u6c42\u503c\uff08\u4e2d\u7f00\u8868\u8fbe\u5f0f\u8f6c\u540e\u7f00\u8868\u8fbe\u5f0f\uff09"},{"location":"icpc/#_32","text":"\u53c2\u8003\u535a\u5ba2\uff1a https://blog.csdn.net/Luoxiaobaia/article/details/107593528 1.\u7403\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u4e0d\u80fd\u7a7a\uff08\u9694\u677f\u6cd5\uff09 \u4e00\u5171\u6709n-1\u4e2a\u7a7a\u9699(\u603b\u5171n+1\u4e2a\u7a7a\u9699\uff0c\u4e0d\u80fd\u7a7a\u8981\u53bb\u6389\u5934\u5c3e=n-1) \uff0c\u8981\u63d2m-1\u4e2a\u677f\uff0c\u7b54\u6848\u4e3a C_{n-1}^{m-1} C_{n-1}^{m-1} \u200b 2.\u7403\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u80fd\u7a7a \u5982\u679c\u7ed9\u6bcf\u4e2a\u76d2\u5b50\u4e00\u4e2a\u7403\uff0c\u5c31\u53ef\u4ee5\u628a\u95ee\u9898\u8f6c\u5316\u4e3a\u4e0d\u80fd\u7a7a\u7684\u60c5\u51b5\u4e86,\u5c31\u76f8\u5f53\u4e8en+m\u4e2a\u5c0f\u7403\u653e\u5165m\u4e2a\u76d2\u5b50\u4e14\u4e0d\u80fd\u7a7a\uff0c\u7b54\u6848\u5c31\u662f C_{n+m-1}^{m-1} C_{n+m-1}^{m-1} 3.\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u80fd\u7a7a\uff08dp\u95ee\u9898\uff09 dp[n][m]\u4ee3\u8868n\u4e2a\u5c0f\u7403\u653e\u5165m\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u4e14\u4e0d\u80fd\u7a7a\u7684\u65b9\u6cd5 \u5f53 i >= 0 \u65f6\uff0cdp[i][i]=1 (i\u4e2a\u5c0f\u7403\u653e\u5165i\u4e2a\u76d2\u5b50\uff0c\u5c31\u53ea\u80fd1\u4e2a\u76d2\u5b50\u653e1\u4e2a) \u5f53 i > 0 \u65f6,dp[i][0]=0(\u90fd\u6ca1\u6709\u76d2\u5b50\u4e86\uff0c\u80af\u5b9a\u65e0\u89e3) dp[i][j] = j * dp[i-1][j] + dp[i-1][j-1] (\u7b2ci\u4e2a\u7403\u53ef\u4ee5\u653e\u5728\u5df2\u7ecf\u6709\u7684j\u4e2a\u76d2\u5b50\u7684\u4e00\u4e2a\uff0c\u6709j\u79cd\u65b9\u6cd5,\u4e5f\u5c31\u662fj*dp[i-1][j], \u4e5f\u53ef\u4ee5\u662f\u653e\u5165\u4e00\u4e2a\u65b0\u7684\u76d2\u5b50,\u5c31\u662fdp[i-1][j-1]) \u6240\u4ee5\u7b54\u6848\u5982\u4e0b\uff1a 4.\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a\uff08\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\uff09 \u90a3\u5c31\u662f3\u7684\u60c5\u51b5(\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u5141\u8bb8\u4e3a\u7a7a)\u75281\u4e2a\u76d2\u5b50+\u75282\u4e2a\u76d2\u5b50+\u2026+m\u4e2a\u76d2\u5b50 5.\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u4e0d\u80fd\u7a7a \u90a3\u5c31\u662f3\u7684\u60c5\u51b5(\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u5141\u8bb8\u4e3a\u7a7a)\u5bf9\u76d2\u5b50\u8fdb\u884c\u5168\u6392\u5217 \u7b54\u6848\u5c31\u662f m!*dp[n][m] (dp[n][m]\u662f\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570) 6.\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u53ef\u4ee5\u7a7a \u6bcf\u4e00\u4e2a\u5c0f\u7403\u90fd\u6709m\u79cd\u65b9\u6cd5\uff0c\u4e14\u76f8\u4e92\u72ec\u7acb\uff0c\u7b54\u6848\u5c31\u662f m^n m^n 7.\u7403\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a\uff08dp\u95ee\u9898\uff09 dp[i][j]\u4ee3\u8868\u7403\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a\u7684\u653e\u6cd5 \u5f53 i>=j \u65f6\uff0cdp[i][j] = dp[i][j-1]+dp[i-j][j] ( \u6211\u4eec\u53ef\u4ee5\u5728\u6240\u6709\u7684\u76d2\u5b50\u4e0a\u653e\u4e00\u4e2a\u7403dp[i-j][j]\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u9009\u62e9\u8fd9\u79cd\u64cd\u4f5c\uff0c\u4f46\u662f\u4ee5\u540e\u90fd\u4e0d\u5bf9\u5176\u4e2d\u4e00\u4e2a\u76d2\u5b50\u8fdb\u884c\u64cd\u4f5c\u4e86\uff0c\u90a3\u5c31\u662fdp[i][j-1] ) \u5f53 i<j \u65f6\uff0cdp[i][i] (\u591a\u4f59\u7684\u76d2\u5b50\u90fd\u6ca1\u6709\u4ec0\u4e48\u5375\u7528\u4e86) \u5f53 j=1 \u65f6\uff0c1(\u53ea\u6709\u4e00\u4e2a\u76d2\u5b50\u4e86\u5c31\u53ea\u80fd\u653e\u5728\u90a3\u4e2a\u76d2\u5b50\u4e86\uff0c\u53ea\u6709\u4e00\u79cd\u653e\u6cd5) \u5f53 i=1 \u65f6\uff0c1(\u53ea\u6709\u4e00\u4e2a\u7403\u4e86\uff0c\u653e\u54ea\u4e2a\u76d2\u5b50\u90fd\u4e00\u6837\uff0c\u53ea\u6709\u4e00\u79cd\u653e\u6cd5) \u5f53 i=0 \u65f6 1(\u6ca1\u6709\u7403\u4e86\uff0c\u4e5f\u662f1\u79cd\u65b9\u6cd5) \u7b54\u6848\u662f 8.\u7403\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u80fd\u7a7a \u90a3\u5c31\u662f7\u7684\u60c5\u51b5(\u7403\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a)\u6bcf\u4e2a\u76d2\u5b50\u5148\u653e\u4e00\u4e2a\u4fdd\u8bc1\u4e0d\u7a7a \u6240\u4ee5\u7b54\u6848\u662f dp[n-m][m] (n>=m) 0 (n<m) \u5176\u4e2ddp\u662f\u60c5\u51b57\u7684dp \u9644\u60c5\u51b57\u7684\u4ee3\u7801\uff1a #include <iostream> int main () { const int N = 11 ; int dp [ N ][ N ] = {}, t , n , m ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 1 ; j < N ; ++ j ) { if ( i <= 1 || j == 1 ) dp [ i ][ j ] = 1 ; else if ( i < j ) dp [ i ][ j ] = dp [ i ][ i ]; else dp [ i ][ j ] = dp [ i ][ j -1 ] + dp [ i - j ][ j ]; } scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & m ); printf ( \"%d \\n \" , dp [ n ][ m ]); } return 0 ; }","title":"\u7ec4\u5408\u6570\u5b66"},{"location":"icpc/#_33","text":"\u53c2\u7167\u535a\u5ba2\uff1a https://zhuanlan.zhihu.com/p/97619085 \u5361\u7279\u5170\u6570\uff08Catalan number\uff09\u662f \u7ec4\u5408\u6570\u5b66 \u4e2d\u4e00\u4e2a\u5e38\u51fa\u73b0\u5728\u5404\u79cd \u8ba1\u6570\u95ee\u9898 \u4e2d\u7684 \u6570\u5217 \u3002 \u6570\u5217\u7684\u524d\u51e0\u9879\u4e3a\uff1a1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862\uff0c... \u5361\u7279\u5170\u6570\u516c\u5f0f\uff1a \u7535\u5f71\u8d2d\u7968\u95ee\u9898 \u7535\u5f71\u7968\u4e00\u5f20 50 coin\uff0c\u4e14\u552e\u7968\u5385\u6ca1\u6709 coin\u3002m \u4e2a\u4eba\u5404\u81ea\u6301\u6709 50 coin\uff0cn \u4e2a\u4eba\u5404\u81ea\u6301\u6709 100 coin\u3002 \u5219\u6709\u591a\u5c11\u79cd\u6392\u961f\u65b9\u5f0f\uff0c\u53ef\u4ee5\u8ba9\u6bcf\u4e2a\u4eba\u90fd\u4e70\u5230\u7535\u5f71\u7968\u3002 \u601d\u8def \u6301\u6709 50 coin \u7684\u4eba\u6bcf\u6b21\u8d2d\u7968\u65f6\u4e0d\u9700\u8981\u627e\u96f6\uff0c\u5e76\u4e14\u53ef\u4ee5\u5e2e\u52a9\u540e\u9762\u6301\u6709 100 coin \u7684\u4eba\u627e\u96f6\uff1b\u800c\u5bf9\u4e8e\u6301\u6709 100 coin \u7684\u4eba\u6bcf\u6b21\u8d2d\u7968\u65f6\u9700\u8981\u627e\u96f6\uff0c\u4f46 100 coin \u5bf9\u540e\u9762\u7684\u627e\u96f6\u6ca1\u6709\u4efb\u4f55\u4f5c\u7528\u3002 \u56e0\u6b64\uff0c\u76f8\u5f53\u4e8e\u6bcf\u4e2a\u6301\u6709 100 coin \u7684\u4eba\u90fd\u9700\u8981\u548c\u4e00\u4e2a\u6301\u6709 50 coin \u7684\u4eba\u8fdb\u884c\u5339\u914d\u3002\u6211\u4eec\u5c06\u6301\u6709 50 coin \u7684\u6807\u8bb0\u4e3a +1\uff0c\u6301\u6709 100 coin \u7684\u6807\u8bb0\u4e3a -1\uff0c\u6b64\u65f6\u53c8\u56de\u5230\u4e86\u8fdb\u51fa\u6808\u95ee\u9898\u3002 \u4e0d\u540c\u7684\u662f\uff0cm \u5e76\u4e00\u5b9a\u7b49\u4e8e n\uff0c\u4e14\u6392\u961f\u5e8f\u5217\u662f\u4e00\u79cd\u6392\u5217\uff0c\u9700\u8981\u8003\u8651\u5148\u540e\u987a\u5e8f\uff0c\u4f8b\u5982\u5404\u81ea\u6301\u6709 50 coin \u7684\u7532\u548c\u4e59\u7684\u524d\u540e\u5173\u7cfb\u4f1a\u9020\u6210\u4e24\u79cd\u4e0d\u540c\u7684\u6392\u961f\u5e8f\u5217\u3002\u6240\u4ee5\uff0c\u5c06\u4f1a\u6709 \u7b2c\u4e8c\u9879\u4e3a\u4ec0\u4e48\u662f \uff0c\u5176\u5b9e\u5f88\u7b80\u5355\uff0c\u6211\u4eec\u6bcf\u6b21\u628a\u7b2c\u4e00\u4e2a\u524d\u7f00\u5c0f\u4e8e0 \u7684\u524d\u7f00\u53d6\u53cd\u540e\uff0c\u4f1a\u9020\u6210 +1 \u591a\u4e86\u4e00\u4e2a\u800c -1 \u5c11\u4e86\u4e00\u4e2a\u3002\u8fd9\u91cc +1 \u6709 m \u4e2a\uff0c-1 \u6709 n \u4e2a\uff0c\u53d6\u53cd\u540e +1 \u53d8\u6210 m + 1 \u4e2a\uff0c-1 \u53d8\u6210 n - 1 \u4e2a\uff0c\u603b\u548c\u4e0d\u53d8\u3002 const int C_maxn = 1e4 + 10 ; ll CatalanNum [ C_maxn ]; ll inv [ C_maxn ]; inline void Catalan_Mod ( int N , LL mod ) { inv [ 1 ] = 1 ; for ( int i = 2 ; i <= N + 1 ; i ++ ) ///\u7ebf\u6027\u9884\u5904\u7406 1 ~ N \u5173\u4e8e mod \u7684\u9006\u5143 inv [ i ] = ( mod - mod / i ) * inv [ mod % i ] % mod ; CatalanNum [ 0 ] = CatalanNum [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) CatalanNum [ i ] = CatalanNum [ i - 1 ] * ( 4 * i - 2 ) % mod * inv [ i + 1 ] % mod ; }","title":"\u5361\u7279\u5170\u6570"},{"location":"icpc/#_34","text":"\u79ef\u6027\u51fd\u6570\u662f\u6307\u5bf9\u4e8e\u4efb\u610f\u4e92\u8d28\u7684\u6574\u6570a\u548cb\u6709\u6027\u8d28f(ab)=f(a)f(b)\u7684\u6570\u8bba\u51fd\u6570 \u5e38\u7528\u79ef\u6027\u51fd\u6570\u6709\uff1a \u03c6(n) \uff0d\u6b27\u62c9\u51fd\u6570 \u03bc(n) \uff0d\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\uff0c\u5173\u4e8e\u975e\u5e73\u65b9\u6570\u7684\u8d28\u56e0\u5b50\u6570\u76ee gcd(n,k) \uff0d\u6700\u5927\u516c\u56e0\u5b50\uff0c\u5f53k\u56fa\u5b9a\u7684\u60c5\u51b5 d(n) \uff0dn\u7684\u6b63\u56e0\u5b50\u6570\u76ee \u03c3(n) \uff0dn\u7684\u6240\u6709\u6b63\u56e0\u5b50\u4e4b\u548c","title":"\u79ef\u6027\u51fd\u6570"},{"location":"icpc/#_35","text":"\u53c2\u8003\u4e8e https://zhuanlan.zhihu.com/p/45744228 \u51fd\u6570\u5b9a\u4e49 \u8f85\u52a9\u5b9a\u7406 \u5bf9\u4e8e\u4efb\u610f\u6b63\u6574\u6570 \uff0c\u6052\u6709 \u5176\u6b21\uff0c\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u548c\u6b27\u62c9\u51fd\u6570\u7684\u5173\u7cfb\uff1a \\sum_{d|n}\\frac{\\mu[d]}{d}=\\frac{\\varphi(n)}{n} \\sum_{d|n}\\frac{\\mu[d]}{d}=\\frac{\\varphi(n)}{n} \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u5b9a\u7406 \u548c \u662f\u5b9a\u4e49\u5728\u6b63\u6574\u6570\u96c6\u5408\u4e0a\u7684\u4e24\u4e2a\u51fd\u6570\uff0c\u82e5 \u5219 \u53cd\u4e4b\u4ea6\u7136. \u8bc1\u660e\uff1a \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u5b9e\u9645\u4e0a\u662f\u5bb9\u65a5\u3002 \u5e38\u89c1\u53cd\u6f14 1\u3001 \u6240\u4ee5\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\u672c\u8eab\u4e5f\u53ef\u4ee5\u53cd\u6f14\u3002 2\u3001 \u7ebf\u6027\u9884\u5904\u7406 \u6c42\u89e3\u533a\u95f4 \u548c\u533a\u95f4 \u4e0a\u4e92\u8d28\u7684\u6570\u7684\u4e2a\u6570\u3002 \u4ee3\u7801 void get_mu ( int n ) { mu [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! vis [ i ]){ prim [ ++ cnt ] = i ; mu [ i ] = -1 ;} for ( int j = 1 ; j <= cnt && prim [ j ] * i <= n ; j ++ ) { vis [ prim [ j ] * i ] = 1 ; if ( i % prim [ j ] == 0 ) break ; else mu [ i * prim [ j ]] =- mu [ i ]; } } }","title":"\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14"},{"location":"icpc/#fftnnt","text":"\u53c2\u8003\u94fe\u63a5\uff1a https://www.acwing.com/file_system/file/content/whole/index/content/1563813/ https://blog.csdn.net/hzf0701/article/details/119428159 https://blog.csdn.net/zz_1215/article/details/40430041 https://www.luogu.com.cn/problem/P3803 NTT \u5feb\u901f\u6570\u8bba\u53d8\u6362\u53d6\u6a21\u591a\u9879\u5f0f\u6a21\u677f #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; const ll G = 3 ; ll n , m , L , R [ 6005000 ] = { 0 }; ll a [ 6005000 ] = { 0 }, b [ 6005000 ] = { 0 }, inv [ 6005000 ] = { 0 }; ll qpow ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ans1 * ans2 % mod ; ans2 = ans2 * ans2 % mod ; b /= 2 ; } return ans1 % mod ; } void NTT ( ll * a , ll f ) { for ( ll i = 0 ; i < n ; i ++ ) { if ( i < R [ i ]) swap ( a [ i ], a [ R [ i ]]); } for ( ll i = 1 ; i < n ; i <<= 1 ) { ll gn = qpow ( G , ( mod - 1 ) / ( i << 1 )); for ( ll j = 0 ; j < n ; j += ( i << 1 )) { ll g = 1 ; for ( ll k = 0 ; k < i ; k ++ , g = g * gn % mod ) { ll x = a [ j + k ], y = g * a [ j + k + i ] % mod ; a [ j + k ] = ( x + y ) % mod ; a [ j + k + i ] = ( x - y + mod ) % mod ; } } } if ( f == 1 ) return ; ll inv = qpow ( n , mod - 2 ); reverse ( a + 1 , a + n ); for ( ll i = 0 ; i < n ; i ++ ) a [ i ] = 1l l * a [ i ] * inv % mod ; } void solve ( ll * A , ll * B ) { m = n + m ; for ( n = 1 ; n <= m ; n <<= 1 ) L ++ ; for ( int i = 0 ; i < n ; i ++ ) R [ i ] = ( R [ i >> 1 ] >> 1 ) | (( i & 1 ) << ( L - 1 )); NTT ( A , 1 ); NTT ( B , 1 ); for ( int i = 0 ; i < n ; i ++ ) A [ i ] = ( A [ i ] % mod * B [ i ] % mod + mod ) % mod ; NTT ( A , -1 ); } int main () { scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 0 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); for ( ll i = 0 ; i <= m ; i ++ ) scanf ( \"%lld\" , & b [ i ]); solve ( a , b ); for ( ll i = 0 ; i <= m ; i ++ ) printf ( \"%lld \" , a [ i ]); return 0 ; } FFT\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362\u6a21\u677f #include <bits/stdc++.h> using namespace std ; typedef pair < int , int > pii ; typedef long long ll ; const int N = 6e6 + 10 ; const int P = 1e9 + 7 ; const int INF = 0x3f3f3f3f ; const double PI = acos ( -1.0 ); //\u5706\u5468\u7387PI\u3002 struct Complex { double x , y ; //\u590d\u6570\uff0cx\u4ee3\u8868\u5b9e\u90e8\uff0cy\u4ee3\u8868\u865a\u90e8\u3002 Complex ( double _x = 0 , double _y = 0 ) { x = _x , y = _y ; } } a [ N ], b [ N ]; //\u591a\u9879\u5f0fa\u548cb\uff0c\u76f8\u4e58\u3002 int n , m , l , r [ N ], limit = 1 ; //n\u4e3aa\u7684\u6b21\u6570,m\u4e3ab\u7684\u6b21\u6570\u3002limit\u5373\u4e3a\u6700\u5927\u9650\u5236\u30022^n\u6b21\u65b9\uff0c\u800cl\u4e3a\u4e8c\u8fdb\u5236\u7684\u4f4d\u6570 //\u8fd0\u7b97\u7b26\u91cd\u8f7d\u3002 Complex operator + ( Complex a , Complex b ) { return Complex ( a . x + b . x , a . y + b . y ); } Complex operator - ( Complex a , Complex b ) { return Complex ( a . x - b . x , a . y - b . y ); } //\u590d\u6570\u76f8\u4e58\uff0c\u5219\u6a21\u957f\u76f8\u4e58\uff0c\u5e45\u5ea6\u76f8\u52a0\u3002 Complex operator * ( Complex a , Complex b ) { return Complex ( a . x * b . x - a . y * b . y , a . x * b . y + a . y * b . x ); } void fft ( Complex * A , int type ) { for ( int i = 0 ; i < limit ; ++ i ) { if ( i < r [ i ]) swap ( A [ i ], A [ r [ i ]]); //\u6c42\u51fa\u8981\u8fed\u4ee3\u7684\u533a\u95f4\u3002\u5c0f\u4e8er[i]\u65f6\u624d\u4ea4\u6362\uff0c\u9632\u6b62\u540c\u4e00\u4e2a\u5143\u7d20\u4ea4\u6362\u4e24\u6b21\uff0c\u56de\u5230\u539f\u6765\u7684\u4f4d\u7f6e\u3002 } //\u4ece\u5e95\u5c42\u5f80\u4e0a\u5408\u5e76\u3002 for ( int mid = 1 ; mid < limit ; mid <<= 1 ) { //\u5f85\u5408\u5e76\u533a\u95f4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u6700\u5f00\u59cb\u662f\u4e24\u4e2a\u957f\u5ea6\u4e3a1\u7684\u5e8f\u5217\u5408\u5e76,mid = 1; Complex Wn ( cos ( PI / mid ), type * sin ( PI / mid )); //\u5355\u4f4d\u6839\u3002 for ( int len = mid << 1 , j = 0 ; j < limit ; j += len ) { //len\u662f\u533a\u95f4\u7684\u957f\u5ea6\uff0cj\u662f\u5f53\u524d\u7684\u4f4d\u7f6e\uff0c\u4e5f\u5c31\u662f\u5408\u5e76\u5230\u4e86\u54ea\u4e00\u4f4d\u3002 Complex w ( 1 , 0 ); //\u5e42\uff0c\u4e00\u76f4\u4e58\uff0c\u5f97\u5230\u5e73\u65b9\uff0c\u4e09\u6b21\u65b9\u3002 for ( int k = 0 ; k < mid ; ++ k , w = w * Wn ) { //\u679a\u4e3e\u5de6\u534a\u90e8\u5206\u3002\u8774\u8776\u53d8\u6362\u5f97\u5230\u53f3\u534a\u90e8\u5206\u7684\u7b54\u6848\u3002w\u4e3awn * k Complex x = A [ j + k ], y = w * A [ j + mid + k ]; //\u5de6\u534a\u90e8\u5206\u548c\u53f3\u534a\u90e8\u5206\u3002 A [ j + k ] = x + y ; //\u5de6\u8fb9\u52a0\u3002 A [ j + mid + k ] = x - y ; //\u53f3\u8fb9\u51cf\u3002 } } } if ( type == 1 ) return ; for ( int i = 0 ; i <= limit ; ++ i ) { a [ i ]. x /= limit ; //\u6700\u540e\u9700\u8981\u9664\u4ee5limit\u4e5f\u5c31\u662f\u8865\u6210\u4e862\u7684\u6574\u6570\u5e42\u3002\u5c06\u70b9\u503c\u8f6c\u6362\u4e3a\u7cfb\u6570\u3002 } } void solve () { while ( limit <= n + m ) { limit <<= 1 , l ++ ; } //\u521d\u59cb\u5316r\u6570\u7ec4\u3002 for ( int i = 0 ; i < limit ; ++ i ) { r [ i ] = ( r [ i >> 1 ] >> 1 ) | (( i & 1 ) << ( l - 1 )); } fft ( a , 1 ); //\u5c06a\u7684\u7cfb\u6570\u8f6c\u5316\u4e3a\u70b9\u503c\u8868\u793a\uff0c fft ( b , 1 ); //\u5c06b\u7684\u7cfb\u6570\u8f6c\u5316\u4e3a\u70b9\u503c\u8868\u793a\u3002 for ( int i = 0 ; i <= limit ; ++ i ) { //\u5bf9\u5e94\u9879\u76f8\u4e58\uff0c\u5f97\u5230\u70b9\u503c\u8868\u793a\u7684\u89e3\u3002 a [ i ] = a [ i ] * b [ i ]; } fft ( a , -1 ); for ( int i = 0 ; i <= n + m ; ++ i ) { //\u53d6\u51fa\u6765\u96642\uff0c\u52a0\u4e0a0.5\u56db\u820d\u4e94\u5165\u3002 printf ( \"%d \" , ( int )( a [ i ]. x + 0.5 )); } printf ( \" \\n \" ); } int main () { scanf ( \"%d%d\" , & n , & m ); //\u8bfb\u5165\u591a\u9879\u5f0f\u7684\u6bcf\u4e00\u9879\u3002 for ( int i = 0 ; i <= n ; ++ i ) { scanf ( \"%lf\" , & a [ i ]. x ); } \u00b7 for ( int i = 0 ; i <= m ; ++ i ) { scanf ( \"%lf\" , & b [ i ]. x ); } solve (); return 0 ; }","title":"FFT\u548cNNT\u6a21\u677f"},{"location":"icpc/#meissel-lehmer","text":"\u662f\u4e00\u79cd\u80fd\u5728\u4e9a\u7ebf\u6027\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u6c42\u51fa 1\u223cn\u5185\u8d28\u6570\u4e2a\u6570\u7684\u4e00\u79cd\u7b97\u6cd5\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{\\frac{2}{3}}) O(n^{\\frac{2}{3}}) #include <bits/stdc++.h> using namespace std ; using ll = long long ; //\u901a\u8fc7\u77e5\u9053\u524d\u9762\u7684 n^1/3 \u7684\u8d28\u6570\u53ef\u4ee5\u63a8\u65ad\u540e\u9762n^2/3\u7684\u8d28\u6570\u6240\u4ee5\u53ef\u4ee5\u9002\u5f53\u51cf\u5c0f const int N = 9e3 ; const int M = 2 ; //\u4e3a\u4e86\u51cf\u5c0f\u5185\u5b58\u53ef\u4ee5\u4e0d\u8fc7\u662f\u8d28\u6570 const int PM = 2 * 3 * 5 ; //\u4e3a\u4e86\u51cf\u5c0f\u5185\u5b58\u53ef\u4ee5\u4e0d\u8fc7\u8981\u6309\u8d28\u6570\u51cf\u5c0f\u5982\u53bb\u638917 ll n ; bool np [ N ]; int prime [ N ], pi [ N ]; int phi [ PM + 1 ][ M + 1 ], sz [ M + 1 ]; int getprime () { int cnt = 0 ; np [ 0 ] = np [ 1 ] = true ; pi [ 0 ] = pi [ 1 ] = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( ! np [ i ]) prime [ ++ cnt ] = i ; pi [ i ] = cnt ; for ( int j = 1 ; j <= cnt && i * prime [ j ] < N ; ++ j ) { np [ i * prime [ j ]] = true ; if ( i % prime [ j ] == 0 ) break ; } } return cnt ; } void init () { getprime (); sz [ 0 ] = 1 ; for ( int i = 0 ; i <= PM ; ++ i ) phi [ i ][ 0 ] = i ; for ( int i = 1 ; i <= M ; ++ i ) { sz [ i ] = prime [ i ] * sz [ i - 1 ]; for ( int j = 1 ; j <= PM ; ++ j ) phi [ j ][ i ] = phi [ j ][ i - 1 ] - phi [ j / prime [ i ]][ i - 1 ]; } } int sqrt2 ( ll x ) { ll r = ( ll ) sqrt ( x - 0.1 ); while ( r * r <= x ) ++ r ; return int ( r - 1 ); } int sqrt3 ( ll x ) { ll r = ( ll ) cbrt ( x - 0.1 ); while ( r * r * r <= x ) ++ r ; return int ( r - 1 ); } ll getphi ( ll x , int s ) { if ( s == 0 ) return x ; if ( s <= M ) return phi [ x % sz [ s ]][ s ] + ( x / sz [ s ]) * phi [ sz [ s ]][ s ]; if ( x <= prime [ s ] * prime [ s ]) return pi [ x ] - s + 1 ; if ( x <= prime [ s ] * prime [ s ] * prime [ s ] && x < N ) { int s2x = pi [ sqrt2 ( x )]; ll ans = pi [ x ] - ( s2x + s - 2 ) * ( s2x - s + 1 ) / 2 ; for ( int i = s + 1 ; i <= s2x ; ++ i ) ans += pi [ x / prime [ i ]]; return ans ; } return getphi ( x , s - 1 ) - getphi ( x / prime [ s ], s - 1 ); } ll getpi ( ll x ) { if ( x < N ) return pi [ x ]; ll ans = getphi ( x , pi [ sqrt3 ( x )]) + pi [ sqrt3 ( x )] - 1 ; for ( int i = pi [ sqrt3 ( x )] + 1 , ed = pi [ sqrt2 ( x )]; i <= ed ; ++ i ) ans -= getpi ( x / prime [ i ]) - i + 1 ; return ans ; } ll lehmer_pi ( ll x ) { //\u5c0f\u4e8e\u7b49\u4e8en\u7684\u7d20\u6570\u6709\u591a\u5c11\u4e2a if ( x < N ) return pi [ x ]; int a = ( int ) lehmer_pi ( sqrt2 ( sqrt2 ( x ))); int b = ( int ) lehmer_pi ( sqrt2 ( x )); int c = ( int ) lehmer_pi ( sqrt3 ( x )); ll sum = getphi ( x , a ) + ( ll )( b + a - 2 ) * ( b - a + 1 ) / 2 ; for ( int i = a + 1 ; i <= b ; i ++ ) { ll w = x / prime [ i ]; sum -= lehmer_pi ( w ); if ( i > c ) continue ; ll lim = lehmer_pi ( sqrt2 ( w )); for ( int j = i ; j <= lim ; j ++ ) sum -= lehmer_pi ( w / prime [ j ]) - ( j - 1 ); } return sum ; } int main () { ios_base :: sync_with_stdio ( false ), cin . tie ( 0 ); init (); while ( cin >> n && n ) cout << lehmer_pi ( n ) << \" \\n \" ; return 0 ; }","title":"Meissel-Lehmer \u7b97\u6cd5"},{"location":"icpc/#miller-rabin","text":"// C++ Version bool millerRabin ( int n ) { if ( n < 3 || n % 2 == 0 ) return n == 2 ; int a = n - 1 , b = 0 ; while ( a % 2 == 0 ) a /= 2 , ++ b ; // test_time \u4e3a\u6d4b\u8bd5\u6b21\u6570,\u5efa\u8bae\u8bbe\u4e3a\u4e0d\u5c0f\u4e8e 8 // \u7684\u6574\u6570\u4ee5\u4fdd\u8bc1\u6b63\u786e\u7387,\u4f46\u4e5f\u4e0d\u5b9c\u8fc7\u5927,\u5426\u5219\u4f1a\u5f71\u54cd\u6548\u7387 for ( int i = 1 , j ; i <= test_time ; ++ i ) { int x = rand () % ( n - 2 ) + 2 , v = quickPow ( x , a , n ); if ( v == 1 ) continue ; for ( j = 0 ; j < b ; ++ j ) { if ( v == n - 1 ) break ; v = ( long long ) v * v % n ; } if ( j >= b ) return 0 ; } return 1 ; }","title":"Miller Rabin\u7d20\u6570\u5224\u5b9a\u7b97\u6cd5"},{"location":"icpc/#_36","text":"","title":"\u52a8\u6001\u89c4\u5212"},{"location":"icpc/#_37","text":"\u5982\u679c\u4f60\u9700\u8981\u79fb\u52a8\u4e00\u6837\u4e1c\u897f\uff0c\u663e\u7136\u63a5\u89e6\u6216\u8005\u4f7f\u7528\u78c1\u573a\u7535\u573a\u4e4b\u7c7b\u7684\u53ef\u4ee5\u89e3\u51b3\u3002\u4f46\u662f\u6709\u6ca1\u6709\u529e\u6cd5\u8fdb\u884c\u8d85\u8d8a\u8ddd\u79bb\u7684\u968f\u5fc3\u6240\u6b32\u7684\u79fb\u52a8\uff1f \u5bf9\u4e8e\u7269\u4f53\u6216\u8005\u6587\u5b57\u8fdb\u884c\u8d85\u8ddd\u79bb\u79fb\u52a8\u4e00\u76f4\u662f\u4eba\u7c7b\u7684\u68a6\u60f3\uff0c\u6709\u4e00\u5929\u8fd9\u4e2a\u96be\u9898\u7ec8\u4e8e\u88ab\u6211\u4eec\u7684\u5927\u725b\u89e3\u51b3\u4e86\uff01\u4ed6\u73b0\u5728\u9700\u8981\u7684\u5c31\u662f\u6574\u7406\u6570\u5217\u3002\u6570\u5217\u5c31\u662f\u6240\u8c13\u7684\u5199\u5728\u7eb8\u4e0a\u6216\u8005\u5728\u7535\u8111\u54c1\u76ee\u4e0a\u7684\u6570\u5217... \u6574\u7406\u6570\u5217\u9700\u8981\u4e00\u4e2a\u53eb\u505aswap\u7684\u64cd\u4f5c\uff0cswap\u64cd\u4f5c\u5c31\u662f\u6307\u5927\u725b\u901a\u8fc7\u8d85\u8ddd\u79bb\u7684\u63a7\u5236\u628a\u6570\u5217\u4e2d\u7684\u67d0\u4e00\u4f4d\u76f4\u63a5\u63d2\u5165\u67d0\u4e24\u4f4d\u7684\u4e2d\u95f4\u6216\u8005\u6570\u5217\u7684\u5f00\u59cb\u6216\u8005\u7ec8\u6b62\u7684\u64cd\u4f5c\u3002\u8fd9\u4e2a\u64cd\u4f5c\u7684\u5173\u952e\u5728\u4e8e\u8d85\u8ddd\u79bb\u63a7\u5236\uff0c\u663e\u7136\u8fd9\u79cd\u4e8b\u60c5\u4e0d\u80fd\u5e72\u592a\u591a\u6b21\uff0c\u4e0d\u4f46\u964dRP\uff0c\u800c\u4e14\u5f88\u8017\u4f53\u529b\u3002\u4f60\u7684\u4efb\u52a1\u5c31\u662f\u4ece\u521d\u59cb\u72b6\u6001\u5230\u76ee\u6807\u72b6\u6001\u6240\u9700\u8981\u505aswap\u7684\u6700\u5c11\u6b21\u6570\u3002 \u8f93\u5165 \u4e09\u884c\uff0c\u7b2c\u4e00\u884c\u4e00\u4e2a\u6574\u6570 n\uff08n<600000\uff09 \u7b2c\u4e8c\u884c\uff0cn \u4e2a\u6574\u6570\uff081-n\uff09\uff0c\u8868\u793a\u521d\u59cb\u6570\u5217\u3002 \u7b2c\u4e09\u884c\uff0cn \u4e2a\u6574\u6570\uff081-n\uff09\uff0c\u8868\u793a\u76ee\u6807\u6570\u5217\u3002 \u4fdd\u8bc1\u6574\u6570\u4e0d\u91cd\u590d\u3002 \u8f93\u51fa \u4e00\u884c \u8868\u793a\u6700\u5c11swap\u6b21\u6570\u3002 \u6837\u4f8b\u8f93\u5165 10 1 2 3 4 5 6 7 8 9 10 10 9 8 7 6 5 4 3 2 1 \u6837\u4f8b\u8f93\u51fa 9 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <iostream> #include <cstdio> #include <bits/stdc++.h> using namespace std ; const int inf = 0x7fffffff ; int b [ 1005001 ], mp [ 1005001 ], c [ 1005001 ]; int main () { int n , x ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & x ), mp [ x ] = i ; for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & b [ i ]), c [ i ] = inf ; int len = 0 ; c [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int l = 0 , r = len , mid ; if ( mp [ b [ i ]] > c [ len ]) c [ ++ len ] = mp [ b [ i ]]; else { while ( l < r ) { mid = ( l + r ) / 2 ; if ( c [ mid ] > mp [ b [ i ]]) r = mid ; else l = mid + 1 ; } c [ l ] = min ( mp [ b [ i ]], c [ l ]); } } cout << n - len << endl ; return 0 ; }","title":"\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217"},{"location":"icpc/#_38","text":"for ( int i = 1 ; i <= strlen ( a ); i ++ ) for ( int j = 1 ; j <= strlen ( b ); j ++ ) if ( a [ i ] == b [ j ]) dp [ i ][ j ] = dp [ i -1 ][ j -1 ] + 1 ; else dp [ i ][ j ] = max ( dp [ i -1 ][ j ], dp [ i ][ j -1 ]);","title":"\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217"},{"location":"icpc/#dp","text":"#include <bits/stdc++.h> using namespace std ; typedef unsigned long long ull ; typedef long long ll ; const int inf = 0x3f3f3f3f ; int n , m ; struct node { int cost , num ; } nd [ 100005 ]; int f [ 1005 ][( 1 << 12 ) + 5 ]; //1\u5de6\u79fb12\u4f4d\u518d\u52a05 int main () { cin >> n >> m ; for ( int i = 1 ; i <= m ; i ++ ) { int b ; scanf ( \"%d%d\" , & nd [ i ]. cost , & b ); int t = 0 ; for ( int j = 1 ; j <= b ; j ++ ) { int temp ; scanf ( \"%d\" , & temp ); t |= ( 1 << ( temp -1 )); ///1\u672c\u6765\u5c31\u5728\u7b2c\u4e00\u4e2a\u4f4d\uff0c\u6240\u4ee5\u8981\u5230\u7b2ctemp\u4f4d\uff0c\u53ea\u9700\u8981\u5411\u5de6\u79fb\u52a8temp-1\u4f4d } nd [ i ]. num = t ; } memset ( f , inf , sizeof ( f )); f [ 0 ][ 0 ] = 0 ; ///\u5f88\u91cd\u8981 for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 0 ; j < ( 1 << n ); j ++ ) ///n\u4e2a\u9501 { int kk = j | nd [ i ]. num ; ///\u5bf9\u5e94\u6bcf\u4e2a\u9501\u9009\u4e0d\u9009 f [ i ][ kk ] = min ( f [ i ][ kk ], f [ i -1 ][ j ] + nd [ i ]. cost ); f [ i ][ j ] = min ( f [ i ][ j ], f [ i -1 ][ j ]); /// } } if ( f [ m ][( 1 << n ) -1 ] != inf ) ///1\u5411\u5de6\u79fb\u52a812\uff0c\u76f8\u5f53\u4e8e1000000000000\uff0c\u7136\u800c12\u4e2a\u4f4d\u7f6e\u90fd\u4e3a1\uff0c\u5373(111111111111)=(1000000000000)-1 printf ( \"%d \\n \" , f [ m ][( 1 << n ) -1 ]); else printf ( \"-1\" ); return 0 ; }","title":"\u72b6\u538bDP"},{"location":"icpc/#dp_1","text":"\u4f18\u5316$ Dp[i]=min(Dp[i]\uff0cDp[j]+(h[j]-h[i])^2 +m)(m\u4e3a\u5e38\u6570)$ \u9898\u76ee\u94fe\u63a5\uff1a Frog 3-ICPC Frog 3-Atcoder \u53c2\u8003\u94fe\u63a5\uff1a https://www.cnblogs.com/orzzz/p/7885971.html https://blog.csdn.net/mengxiang000000/article/details/78113980 https://blog.csdn.net/bllsll/article/details/78267029 \u516c\u5f0f\u63a8\u5bfc\uff1a \u6211\u4eec\u5047\u8bbe\u5728\u6c42\u89e3 dp[i] dp[i] \u65f6\uff0c\u5b58\u5728 j,k(j>k) j,k(j>k) \u4f7f\u5f97\u4ece j j \u8f6c\u79fb\u6bd4\u4ece k k \u8f6c\u79fb\u66f4\u4f18\uff0c\u90a3\u4e48\u9700\u8981\u6ee1\u8db3\u6761\u4ef6\uff1a dp[j]+(S[i+1]\u2212S[j])^2+M<dp[k]+(S[i+1]\u2212S[k])^2+M dp[j]+(S[i+1]\u2212S[j])^2+M<dp[k]+(S[i+1]\u2212S[k])^2+M \u5c55\u5f00\u4e0a\u5f0f dp[j]+S[i+1]^2\u22122S[i+1]S[j]+S[j]^2+M<dp[k]+S[i+1]^2\u22122S[i+1]S[k]+S[k]^2+M dp[j]+S[i+1]^2\u22122S[i+1]S[j]+S[j]^2+M<dp[k]+S[i+1]^2\u22122S[i+1]S[k]+S[k]^2+M \u79fb\u9879\u5e76\u6d88\u53bb\u518d\u5408\u5e76\u540c\u7c7b\u9879\u5f97 $dp[j]\u2212dp[k]+S[j] 2\u2212S[k] 2<2S[i+1] (S[j]\u2212S[k]) $ \u628aS[j]\u2212S[k]S[j]\u2212S[k]\u9664\u8fc7\u53bb\uff0c\u5f97\u5230 \\frac{dp[j]\u2212dp[k]+S[j]^2\u2212S[k]^2}{S[j]\u2212S[k]}<2S[i+1] \\frac{dp[j]\u2212dp[k]+S[j]^2\u2212S[k]^2}{S[j]\u2212S[k]}<2S[i+1] \u6211\u4eec\u8bbe f[x]=dp[x]+S[x]^2 f[x]=dp[x]+S[x]^2 \uff0c\u5c31\u5316\u6210\u4e86 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \u5373\u5f53 (j>k) (j>k) \u65f6\uff0c\u82e5 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \uff0c\u5219 j j \u5bf9\u66f4\u65b0 dp[i] dp[i] \u6bd4 k k \u66f4\u65b0 dp[i] dp[i] \u4f18\u3002---\u659c\u7387\u3002 \u5f53\u4e00\u4e2a\u6570\u7684dp\u503c\u6c42\u5b8c\u4e86\uff0c\u5b83\u7684f\u503c\u4e5f\u8ddf\u7740\u786e\u5b9a\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5728\u7a7a\u95f4\u4e2d\u7ed8\u5236\u51fa\u70b9(S[i],f[i])\u3002\u8fd9\u4e2a\u70b9\u4ee3\u8868\u5df2\u7ecf\u6c42\u51fadp\u503c\u7684\u4e00\u4e2a\u70b9\u3002 \u5f53\u6211\u4eec\u8981\u6c42\u89e3dp[t]\u65f6\uff0c\u5982\u679c\u53ef\u7528\u7684\u96c6\u5408\u91cc\u5b58\u5728\u8fd9\u6837\u4e09\u4e2a\u70b9\uff0c\u4f4d\u7f6e\u5173\u7cfb\u5982\u56fe\u6240\u793a\uff1a \u90a3\u4e48\u663e\u7136 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \u8fd9\u65f6\u5019\u4ed6\u4eec\u548c2S[t+1]2S[t+1]\u7684\u5173\u7cfb\u67093\u79cd\uff1a \u00b7 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]}>2S[t+1] \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]}>2S[t+1] \u90a3\u4e48j\u6bd4i\u4f18\uff0ck\u6bd4j\u4f18\u3002 \u00b7 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>2S[t+1]>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>2S[t+1]>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \u90a3\u4e48i\u6bd4j\u4f18\uff0ck\u6bd4j\u4f18\u3002 \u00b7 2S[t+1]>\\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} 2S[t+1]>\\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \u90a3\u4e48i\u6bd4j\u4f18\uff0cj\u6bd4k\u4f18\u3002 \u7efc\u4e0a\uff0c\u4e0d\u7ba1\u4ec0\u4e48\u6837\u7684 S[t+1] S[t+1] \uff0c\u4ecej\u8f6c\u79fb\u90fd\u4e0d\u4f1a\u662f\u6700\u4f73\u65b9\u6848\u3002\u90a3\u4e48\u7528\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u4e00\u4e2a\u51f8\u5305\uff08\u4e0b\u51f8\uff09\uff0c\u6bcf\u52a0\u5165\u4e00\u4e2a\u70b9\u5c31\u5220\u53bb\u4e00\u4e9b\u70b9\uff0c\u4f7f\u5176\u7ef4\u6301\u51f8\u5305\u7684\u5f62\u6001\u3002\u6700\u4f18\u8f6c\u79fb\u4e00\u5b9a\u5728\u8fd9\u4e2a\u51f8\u5305\u4e2d\u3002 \u90a3\u4e48\u6839\u636e\u4e0a\u8ff0\uff0c\u6211\u4eec\u53ef\u4ee5\u6709\u4e24\u4e2a\u63a8\u8bba\uff1a 1. G[j\uff0ck]<=S[i] G[j\uff0ck]<=S[i] \uff0c\u90a3\u4e48\u4f4d\u5b50k\u5c31\u53ef\u4ee5\u88ab\u6dd8\u6c70\u3002 2. G[j\uff0ck]<=G[i\uff0cj] G[j\uff0ck]<=G[i\uff0cj] \uff0c\u90a3\u4e48\u8868\u793aj\u6bd4k\u66f4\u4f18\uff0c\u5e76\u4e14i\u6bd4j\u66f4\u4f18\uff0c\u90a3\u4e48\u4f4d\u5b50j\u662f\u53ef\u4ee5\u88ab\u6dd8\u6c70\u7684\u3002 \u4ee3\u7801\uff1a #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll h [ 200500 ] = { 0 }; ll dp [ 200500 ] = { 0 }; deque < ll > que ; double xielv ( ll i , ll j ) { double ans = ( dp [ i ] + h [ i ] * h [ i ] - dp [ j ] - h [ j ] * h [ j ]) * 1.0 / ( 2 * ( h [ i ] - h [ j ])); return ans ; } int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & h [ i ]); que . push_back ( 1 ); dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { while ( que . size () >= 2 && xielv ( que [ 0 ], que [ 1 ]) <= h [ i ]) que . pop_front (); if ( que . size ()) dp [ i ] = dp [ que [ 0 ]] + ( h [ i ] - h [ que [ 0 ]]) * ( h [ i ] - h [ que [ 0 ]]) + m ; while ( que . size () >= 2 && xielv ( que [ que . size () - 2 ], que [ que . size () - 1 ]) > xielv ( que [ que . size () - 1 ], i )) que . pop_back (); que . push_back ( i ); } cout << dp [ n ] << endl ; }","title":"\u659c\u7387DP"},{"location":"icpc/#_39","text":"","title":"\u8ba1\u7b97\u673a\u56fe\u5f62\u5b66"},{"location":"icpc/#_40","text":"#include <iostream> #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #define PI 3.1415926535 using namespace std ; struct node { int x , y ; }; node vex [ 1000 ]; //\u5b58\u5165\u7684\u6240\u6709\u7684\u70b9 node stackk [ 1000 ]; //\u51f8\u5305\u4e2d\u6240\u6709\u7684\u70b9 int xx , yy ; bool cmp1 ( node a , node b ) //\u6392\u5e8f\u627e\u7b2c\u4e00\u4e2a\u70b9 { if ( a . y == b . y ) return a . x < b . x ; else return a . y < b . y ; } int cross ( node a , node b , node c ) //\u8ba1\u7b97\u53c9\u79ef { return ( b . x - a . x ) * ( c . y - a . y ) - ( c . x - a . x ) * ( b . y - a . y ); } double dis ( node a , node b ) //\u8ba1\u7b97\u8ddd\u79bb { return sqrt (( a . x - b . x ) * ( a . x - b . x ) * 1.0 + ( a . y - b . y ) * ( a . y - b . y )); } bool cmp2 ( node a , node b ) //\u6781\u89d2\u6392\u5e8f\u53e6\u4e00\u79cd\u65b9\u6cd5\uff0c\u901f\u5ea6\u5feb { if ( atan2 ( a . y - yy , a . x - xx ) != atan2 ( b . y - yy , b . x - xx )) return ( atan2 ( a . y - yy , a . x - xx )) < ( atan2 ( b . y - yy , b . x - xx )); return a . x < b . x ; } bool cmp ( node a , node b ) //\u6781\u89d2\u6392\u5e8f { int m = cross ( vex [ 0 ], a , b ); if ( m > 0 ) return 1 ; else if ( m == 0 && dis ( vex [ 0 ], a ) - dis ( vex [ 0 ], b ) <= 0 ) return 1 ; else return 0 ; /*if(m==0) return dis(vex[0],a)-dis(vex[0],b)<=0?true:false; else return m>0?true:false;*/ } int main () { int t , L ; while ( ~ scanf ( \"%d\" , & t ), t ) { int i ; for ( i = 0 ; i < t ; i ++ ) { scanf ( \"%d%d\" , & vex [ i ]. x , & vex [ i ]. y ); } if ( t == 1 ) printf ( \"%.2f \\n \" , 0.00 ); else if ( t == 2 ) printf ( \"%.2f \\n \" , dis ( vex [ 0 ], vex [ 1 ])); else { memset ( stackk , 0 , sizeof ( stackk )); sort ( vex , vex + t , cmp1 ); stackk [ 0 ] = vex [ 0 ]; xx = stackk [ 0 ]. x ; yy = stackk [ 0 ]. y ; sort ( vex + 1 , vex + t , cmp2 ); //cmp2\u662f\u66f4\u5feb\u7684\uff0ccmp\u66f4\u5bb9\u6613\u7406\u89e3 stackk [ 1 ] = vex [ 1 ]; //\u5c06\u51f8\u5305\u4e2d\u7684\u7b2c\u4e24\u4e2a\u70b9\u5b58\u5165\u51f8\u5305\u7684\u7ed3\u6784\u4f53\u4e2d int top = 1 ; //\u6700\u540e\u51f8\u5305\u4e2d\u62e5\u6709\u70b9\u7684\u4e2a\u6570 for ( i = 2 ; i < t ; i ++ ) { while ( i >= 1 && cross ( stackk [ top -1 ], stackk [ top ], vex [ i ]) < 0 ) //\u5bf9\u4f7f\u7528\u6781\u89d2\u6392\u5e8f\u7684i>=1\u6709\u65f6\u53ef\u4ee5\u4e0d\u7528\uff0c\u4f46\u52a0\u4e0a\u603b\u662f\u597d\u7684 top -- ; stackk [ ++ top ] = vex [ i ]; //\u63a7\u5236<0\u6216<=0\u53ef\u4ee5\u63a7\u5236\u91cd\u70b9\uff0c\u5171\u7ebf\u7684\uff0c\u5177\u4f53\u89c6\u9898\u76ee\u800c\u5b9a\u3002 } double s = 0 ; //for(i=1; i<=top; i++)//\u8f93\u51fa\u51f8\u5305\u4e0a\u7684\u70b9 //cout<<stackk[i].x<<\" \"<<stackk[i].y<<endl; for ( i = 1 ; i <= top ; i ++ ) //\u8ba1\u7b97\u51f8\u5305\u7684\u5468\u957f s += dis ( stackk [ i -1 ], stackk [ i ]); s += dis ( stackk [ top ], vex [ 0 ]); //\u6700\u540e\u4e00\u4e2a\u70b9\u548c\u7b2c\u4e00\u4e2a\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb /*s+=2*PI*L; int ans=s+0.5;//\u56db\u820d\u4e94\u5165 printf(\"%d\\n\",ans);*/ printf ( \"%.2lf \\n \" , s ); } } }","title":"\u51f8\u5305\u7b97\u6cd5"},{"location":"icpc/#_41","text":"#include <bits/stdc++.h> using namespace std ; struct Point { double x , y ; } p [ 100500 ]; int n ; double polygonarea () { int i , j ; double area = 0 ; for ( i = 1 ; i <= n ; ++ i ){ if ( i < n ) j = i + 1 ; else j = 1 ; area += p [ i ]. x * p [ j ]. y ; area -= p [ i ]. y * p [ j ]. x ; } area /= 2.0 ; return ( area < 0 ?- area : area ); } int main () { while ( scanf ( \"%d\" , & n ) != EOF && n != 0 ) { for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%lf%lf\" , & p [ i ]. x , & p [ i ]. y ); printf ( \"%.1f \\n \" , polygonarea ()); } }","title":"\u6c42\u4efb\u610f\u591a\u8fb9\u5f62\u9762\u79ef"},{"location":"icpc/#_42","text":"\u8f93\u5165\uff1a 1 5 2 2 4 1 3 1 5 3 5 \u4ee3\u88681\u7ec4\u6d4b\u8bd5\u6837\u4f8b\uff0c\u7ed9\u5b9a5*2\u7684\u6b63\u65b9\u5f62\uff0c\u5c062<=x<=4&&1<=y<=3\u7684\u8303\u56f4\u5185\u7684\u5c0f\u6b63\u65b9\u5f62\u8fdb\u884c\u9ed1\u767d\u53cd\u8f6c\uff0c\u6c42\u6700\u7ec8\u9ed1\u8272\u6b63\u65b9\u5f62\u7684\u4e2a\u6570\uff0c\u7b54\u6848\u4e3a18. #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int h , a , b , num ; }; int mark [ 100500 ] = { 0 }; int sum [ 100500 ] = { 0 }; node edge [ 100500 ] = { 0 }; bool cmp ( node a , node b ) { if ( a . h == b . h ) return a . num > b . num ; else return a . h < b . h ; } int nodeupdate ( int root , int l , int r , ll num ) { mark [ root ] ^= 1 ; sum [ root ] = r - l + 1 - sum [ root ]; } int pushdown ( int root , int l , int r ) { if ( mark [ root ] == 0 ) return 0 ; int mid = ( l + r ) / 2 ; nodeupdate ( 2 * root , l , mid , mark [ root ]); nodeupdate ( 2 * root + 1 , mid + 1 , r , mark [ root ]); mark [ root ] = 0 ; } int update ( int root , int l , int r , int L , int R , ll num ) { if ( l >= L && r <= R ) { nodeupdate ( root , l , r , num ); return 0 ; } pushdown ( root , l , r ); int mid = ( l + r ) / 2 ; if ( mid >= L ) update ( root * 2 , l , mid , L , R , num ); if ( mid < R ) update ( root * 2 + 1 , mid + 1 , r , L , R , num ); sum [ root ] = sum [ 2 * root ] + sum [ 2 * root + 1 ]; } int main () { int t , cnt ; scanf ( \"%d\" , & t ); while ( t -- ) { memset ( sum , 0 , sizeof ( sum )); memset ( mark , 0 , sizeof ( mark )); int n , m , ans = 0 ; cnt = 0 ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int x1 , y1 , x2 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & x2 , & y1 , & y2 ); edge [ cnt ++ ] = node { y1 , x1 , x2 , 1 }; edge [ cnt ++ ] = node { y2 , x1 , x2 , -1 }; } sort ( edge , edge + cnt , cmp ); for ( int i = 1 , j = 0 ; i <= n ; i ++ ) { while ( j < cnt && edge [ j ]. h <= i && edge [ j ]. num == 1 ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } ans += sum [ 1 ]; while ( j < cnt && edge [ j ]. h <= i ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } } cout << ans << endl ; } return 0 ; } \u7ebf\u6bb5\u6811\u79bb\u6563\u5316\u6c42\u9762\u79ef\u7684\u5e76\uff1a #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll n ; ll s [ 400500 ] = { 0 }; ll len [ 400500 ] = { 0 }; ll x [ 400500 ] = { 0 }; unordered_map < ll , ll > mpx ; void push_up ( ll t , ll l , ll r ) { if ( s [ t ]) len [ t ] = x [ r + 1 ] - x [ l ]; else if ( l == r ) len [ t ] = 0 ; else len [ t ] = len [ 2 * t + 1 ] + len [ 2 * t ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { s [ t ] += add ; push_up ( t , L , R ); return ; } ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t , L , R ); } struct node1 { ll l , r , h , d ; }; node1 edge [ 200500 ] = { 0 }; bool cmp ( node1 a , node1 b ) { return a . h < b . h ; } int main () { scanf ( \"%lld\" , & n ); ll cnt = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll x1 , x2 , y1 , y2 ; scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); x [ ++ cnt ] = x1 , edge [ cnt ] = { x1 , x2 , y1 , 1 }; x [ ++ cnt ] = x2 , edge [ cnt ] = { x1 , x2 , y2 , -1 }; } sort ( x + 1 , x + cnt + 1 ); sort ( edge + 1 , edge + cnt + 1 , cmp ); ll m = unique ( x + 1 , x + cnt + 1 ) - x -1 ; for ( int i = 1 ; i <= m ; i ++ ) mpx [ x [ i ]] = i ; ll ans = 0 ; for ( ll i = 1 ; i < cnt ; i ++ ) { ll l = mpx [ edge [ i ]. l ], r = mpx [ edge [ i ]. r ]; update ( 1 , l , r -1 , 1 , m , edge [ i ]. d ); ans += len [ 1 ] * ( edge [ i + 1 ]. h - edge [ i ]. h ); } cout << ans << endl ; }","title":"\u7ebf\u6bb5\u6811+\u626b\u63cf\u7ebf\u6c42\u6b63\u65b9\u5f62\u989c\u8272\u53cd\u8f6c"},{"location":"icpc/#_43","text":"","title":"\u535a\u5f08\u8bba"},{"location":"icpc/#_44","text":"\u53ea\u6709\u4e00\u5806n\u4e2a\u7269\u54c1\uff0c\u4e24\u4e2a\u4eba\u4ece\u8f6e\u6d41\u4e2d\u53d6\u51fa\uff081~m\uff09\u4e2a\uff1b\u6700\u540e\u53d6\u5149\u8005\u80dc\u3002 \u82e5n=k*(m+1) \u90a3\u4e48\u5148\u53d6\u8005\u5fc5\u8f93\u3002 int Bash_Game ( int n , int m ) //\u662f\u5426\u5148\u624b\u6709\u5fc5\u8d62\u7b56\u7565 { if ( n % ( m + 1 ) != 0 ) return 1 ; return 0 ; }","title":"\u5df4\u4ec0\u535a\u5f08"},{"location":"icpc/#_45","text":"\u6709\u82e5\u5e72\u5806\u5404\u82e5\u5e72\u4e2a\u7269\u54c1\uff0c\u4e24\u4e2a\u4eba\u8f6e\u6d41\u4ece\u67d0\u4e00\u5806\u53d6\u4efb\u610f\u591a\u7684\u7269\u54c1\uff0c\u89c4\u5b9a\u6bcf\u6b21\u81f3\u5c11\u53d6\u4e00\u4e2a\uff0c\u591a\u8005\u4e0d\u9650\uff0c\u6700\u540e\u53d6\u5149\u8005\u5f97\u80dc\u3002 XOR \u5224\u65ad: int Nimm_Game ( int n ) //\u5047\u8bben\u4e2a\u6570\u5b58\u5728\u6570\u7ec4f[]\u4e2d,\u6709\u5fc5\u80dc\u7b56\u7565\u8fd4\u56de1 { int flag = 0 ; for ( int i = 1 ; i <= n ; i ++ ) flag ^= f [ i ]; if ( flag ) return 1 ; return 0 ; }","title":"\u5c3c\u59c6\u535a\u5f08"},{"location":"icpc/#_46","text":"\u6709\u4e24\u5806\u5404\u82e5\u5e72\u4e2a\u7269\u54c1\uff0c\u4e24\u4e2a\u4eba\u8f6e\u6d41\u4ece\u67d0\u4e00\u5806\u6216\u540c\u65f6\u4ece\u4e24\u5806\u4e2d\u53d6\u540c\u6837\u591a\u7684\u7269\u54c1\uff0c\u89c4\u5b9a\u6bcf\u6b21\u81f3\u5c11\u53d6\u4e00\u4e2a\uff0c\u591a\u8005\u4e0d\u9650\uff0c\u6700\u540e\u53d6\u5149\u8005\u5f97\u80dc\u3002 \u5224\u65ad\u662f\u5426\u4e3a\u5947\u5f02\u5c40\u52bf \u8bbex= k=[a*x]\uff0c\u5411\u4e0a\u53d6\u6574 \u5982\u679ca+k=b\uff0c\u5219\uff08a\uff0cb\uff09\u4e3a\u5947\u5f02\u5c40\u52bf\uff0c\u540e\u624b\u80dc\uff0c\u53cd\u4e4b\u4e3a\u5148\u624b\u80dc \u5bf9\u5e94\u7684\u4ee3\u7801\u5728\u8fd9\u91cc\uff1a int Wythoff_Game ( int a , int b ) { if ( a > b ) swap ( a , b ); double x = ( sqrt ( 5.0 ) -1.0 ) / 2.0 ; int k = ceil ( 1.0 * a * x ); if ( a + k == b ) return 0 ; //\u5947\u5f02\u5c40\u52bf\uff0c\u540e\u624b\u80dc\uff01 else return 1 ; //\u975e\u5947\u5f02\u5c40\u52bf\uff0c\u5148\u624b\u80dc\uff01 }","title":"\u5a01\u4f50\u592b\u535a\u5955"},{"location":"icpc/#sgnim","text":"\u9898\u76ee\u9898\u89e3 \u9898\u76ee\u94fe\u63a5 SG\u51fd\u6570\u8be6\u89e3 #include <bits/stdc++.h> using namespace std ; bool vis [ 300 ] = { 0 }; int sg [ 110 ][ 110 ] = { 0 }; void init () { for ( int i = 0 ; i <= 100 ; i ++ ) sg [ i ][ i ] = sg [ i ][ 0 ] = sg [ 0 ][ i ] = 199 ; for ( int i = 0 ; i <= 100 ; i ++ ) { for ( int j = 0 ; j <= 100 ; j ++ ) { if ( i == j || i == 0 || j == 0 ) continue ; memset ( vis , 0 , sizeof ( vis )); for ( int a = 0 ; a < i ; a ++ ) vis [ sg [ a ][ j ]] = 1 ; for ( int b = 0 ; b < j ; b ++ ) vis [ sg [ i ][ b ]] = 1 ; for ( int c = min ( i , j ); c >= 1 ; c -- ) vis [ sg [ i - c ][ j - c ]] = 1 ; for ( int k = 0 ;; k ++ ) { if ( ! vis [ k ]) { sg [ i ][ j ] = k ; break ; } } } } } int main () { int n ; scanf ( \"%d\" , & n ); int a , b ; int nim = 0 ; init (); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d%d\" , & a , & b ); if ( a == b ) { printf ( \"Y \\n \" ); return 0 ; } nim ^= sg [ a ][ b ]; } if ( nim != 0 ) printf ( \"Y \\n \" ); else printf ( \"N \\n \" ); }","title":"SG\u51fd\u6570\u548cNIM\u535a\u5f08"},{"location":"icpc/_coverpage/","text":"Tim-wcx \u00b6 \u4e2a\u4eba\u6587\u6863\u7f51\u7ad9 \u00b6 GitHub Get Started","title":"Tim-wcx"},{"location":"icpc/_coverpage/#tim-wcx","text":"","title":"Tim-wcx"},{"location":"icpc/_coverpage/#_1","text":"GitHub Get Started","title":"\u4e2a\u4eba\u6587\u6863\u7f51\u7ad9"},{"location":"icpc/_sidebar/","text":"\u4e0a\u4e00\u7ea7 ICPC\u6a21\u677f","title":" sidebar"},{"location":"problem/","text":"\u9898\u89e3\u7cfb\u5217","title":"Index"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"A\u9898 \u00b6 \u9898\u89e3 \u00b6 \u7b7e\u5230\u9898\u76ee\uff0c\u7ed9\u5b9a\u4e09\u4e2a\u6570a,b\u548cc\uff0c\u9009\u62e9\u4e00\u4e2a\u6570x\uff0c\u4f7f\u5f97x-2<=a\uff0cx-1<=b\u4e14x<=c\uff0c\u6c423*x-3\u7684\u6700\u5927\u503c\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; int main () { int a , b , c ; cin >> a >> b >> c ; int min1 = min ( a + 2 , min ( b + 1 , c )); cout << min1 + min1 -1 + min1 -2 << endl ; } B\u9898 \u00b6 \u9898\u89e3 \u00b6 \u7ed9\u5b9a2 * n\u4e2a\u70b9\uff0c\u5728\u524dn\u4e2a\u70b9\u4e2d\u9009\u4e00\u4e2a\u70b9i\uff0c\u5728\u540en\u4e2a\u70b9\u4e2d\u9009\u4e00\u4e2a\u70b9j\uff0c\u6784\u9020\u4e00\u79cd\u5339\u914d\u65b9\u5f0f\u4f7f\u5f97\u4efb\u610f\u4e24\u70b9\u6a2a\u7eb5\u5750\u6807\u548c(xi+xj,yi+yj)\u5747\u76f8\u540c\u3002\u7531\u4e8exi+xj\u5747\u76f8\u540c\uff0c\u53ef\u4ee5\u628a\u8fd92 * n\u4e2a\u70b9\u7684x\u5750\u6807\u8fdb\u884c\u6c42\u548c\u7136\u540e\u5e73\u5747\u5206\u914d\u6210n\u4efd\uff0c\u8fd9\u6837\u5c31\u5f97\u5230\u4e86xi+xj\u7684\u5b9a\u503c\uff0cy\u5750\u6807\u540c\u7406\u3002\uff08\u6ce8\u610f\u5f00long long\uff09 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n ; scanf ( \"%lld\" , & n ); ll sum1 = 0 , sum2 = 0 , x , y ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { scanf ( \"%lld%lld\" , & x , & y ); sum1 += x , sum2 += y ; } sum1 /= n , sum2 /= n ; cout << sum1 << ' ' << sum2 << endl ; } C\u9898 \u00b6 \u9898\u89e3 \u00b6 \u8be5\u9898\u4e3a\u6253\u8868\u627e\u89c4\u5f8b\u6240\u505a\u51fa\u6765\u7684\uff0c\u5bb9\u6613\u53d1\u73b0\u8fd9\u4e9b\u6700\u5c0f\u503c\u6240\u5bf9\u5e94\u7684k\u53ef\u4ee5\u548cn\u7684\u56e0\u6570\u4e00\u4e00\u5bf9\u5e94\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u679a\u4e3en\u7684\u56e0\u6570\u7136\u540e\u6c42\u51fa\u7ed3\u679c\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; set < ll > s ; ll n ; ll cal ( ll x ) { ll size1 = n / x ; ll ans = size1 + size1 * ( size1 -1 ) / 2 * x ; return ans ; } int main () { scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { s . insert ( cal ( i )); s . insert ( cal ( n / i )); } } set < ll > :: iterator it = s . begin (); while ( it != s . end ()) { cout <<* it << ' ' ; it ++ ; } cout << endl ; } D\u9898 \u00b6 \u9898\u89e3 \u00b6 \u8fd9\u91cc\u4ee5n=4\u4e3a\u4f8b 1 2 3 4 2 1 3 4 3 1 2 4 4 1 2 3 1 2 4 3 2 1 4 3 3 1 4 2 4 1 3 2 1 3 2 4 2 3 1 4 3 2 1 4 4 2 1 3 1 3 4 2 2 3 4 1 3 2 4 1 4 2 3 1 1 4 2 3 2 4 1 3 3 4 1 2 4 3 1 2 1 4 3 2 2 4 3 1 3 4 2 1 4 3 2 1 \u56db\u4e2a\u6570\u4e00\u7ec4\uff0c\u53ef\u4ee5\u7ec4\u62104! \u4e2a\u7b54\u6848 \u7b2c\u4e00\u6392\u5f53\u4e2d \u6bcf\u4e00\u5bf9\u6570\u540e\u4e09\u4e2a \u548c \u4e0b\u4e00\u5bf9\u6570\u7684\u7b2c\u4e00\u4e2a \u7ec4\u6210\u4e00\u4e2a\u7b54\u6848\uff0c\u800c\u7b2c\u4e00\u6392\u4e2d\u6070\u67093! \u5bf9\u6570\uff0c\u6240\u4ee5\u7b54\u6848\u4e3a(3! - 1)*4 \u7b2c\u4e00\u6392\u6709\u516d\u5bf9\u6570\uff0c\u53ef\u4ee5\u5212\u5206\u4e3a3\u7ec4\uff0c\u6bcf\u7ec4\u4e24\u4e2a\uff0c\u4e14\u6bcf\u7ec4\u4e2d \u4e0a\u4e00\u5bf9\u6570\u7684\u540e\u4e24\u4e2a \u548c \u4e0b\u4e00\u5bf9\u6570\u7684\u524d\u4e24\u4e2a \u7ec4\u6210\u7b54\u6848\uff0c\u6240\u4ee5\u7b54\u6848\u53c8\u5e94\u5f53\u52a0\u4e0a(2! - 1) * 4 * 3 \u7efc\u4e0a\u7b54\u6848\u4e3a4! + (3! - 1) * 4 + (2! - 1) * 4 * 3 =56 \u540c\u7406\uff0c5\u7684\u7b54\u6848\u4e3a\uff1a5! + (4! - 1) * 5 + (3! - 1) * 5 * 4 + (2! - 1) * 5 * 4 * 3 = 4 *5! - 5 - 5 *4 - 5 *4 *3 = 395 \u6ce8\u610f\u7279\u52241 \uff01\uff01\uff01 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n ; const ll mod = 998244353 ; int main () { scanf ( \"%lld\" , & n ); if ( n == 1 ) { cout << 1 << endl ; return 0 ; } ll ans = 1 ; for ( ll i = 1 ; i <= n ; i ++ ) { ans = ans * i ; ans %= mod ; } ans = ans * ( n -1 ); ans %= mod ; ll sum1 = 1 ; for ( ll i = n ; i >= 3 ; i -- ) { sum1 *= i ; sum1 %= mod ; ans = ans - sum1 ; ans = ( ans % mod + mod ) % mod ; } ans = ( ans % mod + mod ) % mod ; cout << ans << endl ; } I\u9898 \u00b6 \u9898\u89e3 \u00b6 \u56fe\u8bba\u9898\u76ee\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u8be5\u70b9\u5230\u6839\u8282\u70b9\u7684\u6743\u503c\u6700\u5c0f\u503c\u5373\u4e3a\u5b50\u8282\u70b9\u6743\u503c\u7684\u6700\u5c0f\u503c\uff0c\u6240\u4ee5\u5148dfs\u786e\u5b9a-1\u70b9\u7684\u6743\u503cs[i]\uff0c\u7136\u540e\u6839\u636e\u5f97\u51fa\u7684\u6743\u503c\u8be5\u70b9\u6743\u503cs[i]\u548c\u7236\u8282\u70b9\u6743\u503cs[i]\u5224\u65ad\u662f\u5426\u7b26\u5408\u6761\u4ef6\u5e76\u6c42\u548c\u5f97\u51fa\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; vector < ll > v [ 100500 ]; ll s [ 100500 ] = { 0 }; ll fa [ 100500 ] = { 0 }; ll dfs ( ll k , ll fa ) { ll min1 = inf ; for ( int i : v [ k ]) { if ( i != fa ) { if ( dfs ( i , k ) == -1 ) return -1 ; if ( s [ i ] != -1 ) min1 = min ( min1 , s [ i ]); } } if ( s [ k ] == -1 ) { if ( min1 != inf ) s [ k ] = min1 ; } else { if ( s [ k ] > min1 ) return -1 ; } return 0 ; } ll ans = 0 ; ll dfs1 ( ll k , ll fa , ll sum ) { if ( s [ k ] == -1 ) return 0 ; if ( s [ k ] < sum ) return -1 ; sum = max ( sum , s [ k ]); ans = ans + s [ k ] - s [ fa ]; for ( int i : v [ k ]) { if ( i != fa ) { if ( dfs1 ( i , k , sum ) == -1 ) return -1 ; } } return 0 ; } int main () { ll n , m ; scanf ( \"%lld\" , & n ); fa [ 1 ] = 0 ; for ( ll i = 2 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & m ); fa [ i ] = m ; v [ i ]. push_back ( m ); v [ m ]. push_back ( i ); } for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & s [ i ]); s [ 0 ] = 0 ; if ( dfs ( 1 , -1 ) == -1 ) { printf ( \"-1 \\n \" ); return 0 ; } if ( dfs1 ( 1 , 0 , 0 ) == -1 ) { printf ( \"-1 \\n \" ); return 0 ; } cout << ans << endl ; }","title":"2021-02-02-2\u67082\u65e5\u9898\u89e3"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#a","text":"","title":"A\u9898"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u7b7e\u5230\u9898\u76ee\uff0c\u7ed9\u5b9a\u4e09\u4e2a\u6570a,b\u548cc\uff0c\u9009\u62e9\u4e00\u4e2a\u6570x\uff0c\u4f7f\u5f97x-2<=a\uff0cx-1<=b\u4e14x<=c\uff0c\u6c423*x-3\u7684\u6700\u5927\u503c\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#include <bits/stdc++.h> using namespace std ; int main () { int a , b , c ; cin >> a >> b >> c ; int min1 = min ( a + 2 , min ( b + 1 , c )); cout << min1 + min1 -1 + min1 -2 << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#b","text":"","title":"B\u9898"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u7ed9\u5b9a2 * n\u4e2a\u70b9\uff0c\u5728\u524dn\u4e2a\u70b9\u4e2d\u9009\u4e00\u4e2a\u70b9i\uff0c\u5728\u540en\u4e2a\u70b9\u4e2d\u9009\u4e00\u4e2a\u70b9j\uff0c\u6784\u9020\u4e00\u79cd\u5339\u914d\u65b9\u5f0f\u4f7f\u5f97\u4efb\u610f\u4e24\u70b9\u6a2a\u7eb5\u5750\u6807\u548c(xi+xj,yi+yj)\u5747\u76f8\u540c\u3002\u7531\u4e8exi+xj\u5747\u76f8\u540c\uff0c\u53ef\u4ee5\u628a\u8fd92 * n\u4e2a\u70b9\u7684x\u5750\u6807\u8fdb\u884c\u6c42\u548c\u7136\u540e\u5e73\u5747\u5206\u914d\u6210n\u4efd\uff0c\u8fd9\u6837\u5c31\u5f97\u5230\u4e86xi+xj\u7684\u5b9a\u503c\uff0cy\u5750\u6807\u540c\u7406\u3002\uff08\u6ce8\u610f\u5f00long long\uff09","title":"\u9898\u89e3"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n ; scanf ( \"%lld\" , & n ); ll sum1 = 0 , sum2 = 0 , x , y ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { scanf ( \"%lld%lld\" , & x , & y ); sum1 += x , sum2 += y ; } sum1 /= n , sum2 /= n ; cout << sum1 << ' ' << sum2 << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#c","text":"","title":"C\u9898"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u8be5\u9898\u4e3a\u6253\u8868\u627e\u89c4\u5f8b\u6240\u505a\u51fa\u6765\u7684\uff0c\u5bb9\u6613\u53d1\u73b0\u8fd9\u4e9b\u6700\u5c0f\u503c\u6240\u5bf9\u5e94\u7684k\u53ef\u4ee5\u548cn\u7684\u56e0\u6570\u4e00\u4e00\u5bf9\u5e94\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u679a\u4e3en\u7684\u56e0\u6570\u7136\u540e\u6c42\u51fa\u7ed3\u679c\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; set < ll > s ; ll n ; ll cal ( ll x ) { ll size1 = n / x ; ll ans = size1 + size1 * ( size1 -1 ) / 2 * x ; return ans ; } int main () { scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { s . insert ( cal ( i )); s . insert ( cal ( n / i )); } } set < ll > :: iterator it = s . begin (); while ( it != s . end ()) { cout <<* it << ' ' ; it ++ ; } cout << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#d","text":"","title":"D\u9898"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"\u8fd9\u91cc\u4ee5n=4\u4e3a\u4f8b 1 2 3 4 2 1 3 4 3 1 2 4 4 1 2 3 1 2 4 3 2 1 4 3 3 1 4 2 4 1 3 2 1 3 2 4 2 3 1 4 3 2 1 4 4 2 1 3 1 3 4 2 2 3 4 1 3 2 4 1 4 2 3 1 1 4 2 3 2 4 1 3 3 4 1 2 4 3 1 2 1 4 3 2 2 4 3 1 3 4 2 1 4 3 2 1 \u56db\u4e2a\u6570\u4e00\u7ec4\uff0c\u53ef\u4ee5\u7ec4\u62104! \u4e2a\u7b54\u6848 \u7b2c\u4e00\u6392\u5f53\u4e2d \u6bcf\u4e00\u5bf9\u6570\u540e\u4e09\u4e2a \u548c \u4e0b\u4e00\u5bf9\u6570\u7684\u7b2c\u4e00\u4e2a \u7ec4\u6210\u4e00\u4e2a\u7b54\u6848\uff0c\u800c\u7b2c\u4e00\u6392\u4e2d\u6070\u67093! \u5bf9\u6570\uff0c\u6240\u4ee5\u7b54\u6848\u4e3a(3! - 1)*4 \u7b2c\u4e00\u6392\u6709\u516d\u5bf9\u6570\uff0c\u53ef\u4ee5\u5212\u5206\u4e3a3\u7ec4\uff0c\u6bcf\u7ec4\u4e24\u4e2a\uff0c\u4e14\u6bcf\u7ec4\u4e2d \u4e0a\u4e00\u5bf9\u6570\u7684\u540e\u4e24\u4e2a \u548c \u4e0b\u4e00\u5bf9\u6570\u7684\u524d\u4e24\u4e2a \u7ec4\u6210\u7b54\u6848\uff0c\u6240\u4ee5\u7b54\u6848\u53c8\u5e94\u5f53\u52a0\u4e0a(2! - 1) * 4 * 3 \u7efc\u4e0a\u7b54\u6848\u4e3a4! + (3! - 1) * 4 + (2! - 1) * 4 * 3 =56 \u540c\u7406\uff0c5\u7684\u7b54\u6848\u4e3a\uff1a5! + (4! - 1) * 5 + (3! - 1) * 5 * 4 + (2! - 1) * 5 * 4 * 3 = 4 *5! - 5 - 5 *4 - 5 *4 *3 = 395 \u6ce8\u610f\u7279\u52241 \uff01\uff01\uff01","title":"\u9898\u89e3"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n ; const ll mod = 998244353 ; int main () { scanf ( \"%lld\" , & n ); if ( n == 1 ) { cout << 1 << endl ; return 0 ; } ll ans = 1 ; for ( ll i = 1 ; i <= n ; i ++ ) { ans = ans * i ; ans %= mod ; } ans = ans * ( n -1 ); ans %= mod ; ll sum1 = 1 ; for ( ll i = n ; i >= 3 ; i -- ) { sum1 *= i ; sum1 %= mod ; ans = ans - sum1 ; ans = ( ans % mod + mod ) % mod ; } ans = ( ans % mod + mod ) % mod ; cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#i","text":"","title":"I\u9898"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"\u56fe\u8bba\u9898\u76ee\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u8be5\u70b9\u5230\u6839\u8282\u70b9\u7684\u6743\u503c\u6700\u5c0f\u503c\u5373\u4e3a\u5b50\u8282\u70b9\u6743\u503c\u7684\u6700\u5c0f\u503c\uff0c\u6240\u4ee5\u5148dfs\u786e\u5b9a-1\u70b9\u7684\u6743\u503cs[i]\uff0c\u7136\u540e\u6839\u636e\u5f97\u51fa\u7684\u6743\u503c\u8be5\u70b9\u6743\u503cs[i]\u548c\u7236\u8282\u70b9\u6743\u503cs[i]\u5224\u65ad\u662f\u5426\u7b26\u5408\u6761\u4ef6\u5e76\u6c42\u548c\u5f97\u51fa\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_10","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; vector < ll > v [ 100500 ]; ll s [ 100500 ] = { 0 }; ll fa [ 100500 ] = { 0 }; ll dfs ( ll k , ll fa ) { ll min1 = inf ; for ( int i : v [ k ]) { if ( i != fa ) { if ( dfs ( i , k ) == -1 ) return -1 ; if ( s [ i ] != -1 ) min1 = min ( min1 , s [ i ]); } } if ( s [ k ] == -1 ) { if ( min1 != inf ) s [ k ] = min1 ; } else { if ( s [ k ] > min1 ) return -1 ; } return 0 ; } ll ans = 0 ; ll dfs1 ( ll k , ll fa , ll sum ) { if ( s [ k ] == -1 ) return 0 ; if ( s [ k ] < sum ) return -1 ; sum = max ( sum , s [ k ]); ans = ans + s [ k ] - s [ fa ]; for ( int i : v [ k ]) { if ( i != fa ) { if ( dfs1 ( i , k , sum ) == -1 ) return -1 ; } } return 0 ; } int main () { ll n , m ; scanf ( \"%lld\" , & n ); fa [ 1 ] = 0 ; for ( ll i = 2 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & m ); fa [ i ] = m ; v [ i ]. push_back ( m ); v [ m ]. push_back ( i ); } for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & s [ i ]); s [ 0 ] = 0 ; if ( dfs ( 1 , -1 ) == -1 ) { printf ( \"-1 \\n \" ); return 0 ; } if ( dfs1 ( 1 , 0 , 0 ) == -1 ) { printf ( \"-1 \\n \" ); return 0 ; } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-07-2%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"\u9898\u89e3 \u00b6 \u8be5\u9898\u4e3a\u62ec\u53f7\u5339\u914d\u95ee\u9898\uff0c\u6c42\u6700\u591a\u80fd\u591f\u5339\u914d\u7684\u5bf9\u6570\uff0c\u53ef\u4ee5\u53d1\u73b0 )(\uff0c\u8fd9\u79cd\u60c5\u51b5\u7684\u62ec\u53f7\u4e00\u5b9a\u4e0d\u80fd\u591f\u53c2\u4e0e\u5339\u914d\uff0c\u53ea\u6709\u53bb\u9664\u5339\u914d\u62ec\u53f7\u540e\u5269\u4f59\u5168\u90e8\u4e3a\u5de6\u62ec\u53f7\u6216\u53f3\u62ec\u53f7\u624d\u80fd\u591f\u53c2\u4e0e\u5339\u914d\uff0c\u4e0e\u5176\u4ed6\u7684\u7ec4\u6210\u5b8c\u6574\u7684\u62ec\u53f7\u5e8f\u5217\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char a [ 500500 ] = { 0 }; int num [ 500500 ] = { 0 }; int b [ 100500 ] = { 0 }; stack < char > s ; int main () { int n ; scanf ( \"%d\" , & n ); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , a + 1 ); for ( int j = 1 ; a [ j ]; j ++ ) { if ( s . empty ()) { s . push ( a [ j ]); } else { if ( a [ j ] == ')' && s . top () == '(' ) s . pop (); else s . push ( a [ j ]); } } int sum1 = 0 , flag = 1 ; while ( ! s . empty ()) { if ( s . top () == ')' ) { s . pop (); if ( sum1 > 0 ) flag = 0 ; else sum1 -- ; } else { s . pop (); if ( sum1 < 0 ) flag = 0 ; else sum1 ++ ; } } if ( flag ) { if ( sum1 < 0 ) num [ - sum1 ] ++ ; b [ i ] = sum1 ; if ( sum1 == 0 ) ans ++ ; } } ans /= 2 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( b [ i ] <= 0 ) continue ; else { if ( num [ b [ i ]] != 0 ) num [ b [ i ]] -- , ans ++ ; } } cout << ans << endl ; }","title":"2021-02-07-2\u67087\u65e5\u9898\u89e3"},{"location":"problem/2021-02-07-2%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u8be5\u9898\u4e3a\u62ec\u53f7\u5339\u914d\u95ee\u9898\uff0c\u6c42\u6700\u591a\u80fd\u591f\u5339\u914d\u7684\u5bf9\u6570\uff0c\u53ef\u4ee5\u53d1\u73b0 )(\uff0c\u8fd9\u79cd\u60c5\u51b5\u7684\u62ec\u53f7\u4e00\u5b9a\u4e0d\u80fd\u591f\u53c2\u4e0e\u5339\u914d\uff0c\u53ea\u6709\u53bb\u9664\u5339\u914d\u62ec\u53f7\u540e\u5269\u4f59\u5168\u90e8\u4e3a\u5de6\u62ec\u53f7\u6216\u53f3\u62ec\u53f7\u624d\u80fd\u591f\u53c2\u4e0e\u5339\u914d\uff0c\u4e0e\u5176\u4ed6\u7684\u7ec4\u6210\u5b8c\u6574\u7684\u62ec\u53f7\u5e8f\u5217\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-07-2%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char a [ 500500 ] = { 0 }; int num [ 500500 ] = { 0 }; int b [ 100500 ] = { 0 }; stack < char > s ; int main () { int n ; scanf ( \"%d\" , & n ); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , a + 1 ); for ( int j = 1 ; a [ j ]; j ++ ) { if ( s . empty ()) { s . push ( a [ j ]); } else { if ( a [ j ] == ')' && s . top () == '(' ) s . pop (); else s . push ( a [ j ]); } } int sum1 = 0 , flag = 1 ; while ( ! s . empty ()) { if ( s . top () == ')' ) { s . pop (); if ( sum1 > 0 ) flag = 0 ; else sum1 -- ; } else { s . pop (); if ( sum1 < 0 ) flag = 0 ; else sum1 ++ ; } } if ( flag ) { if ( sum1 < 0 ) num [ - sum1 ] ++ ; b [ i ] = sum1 ; if ( sum1 == 0 ) ans ++ ; } } ans /= 2 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( b [ i ] <= 0 ) continue ; else { if ( num [ b [ i ]] != 0 ) num [ b [ i ]] -- , ans ++ ; } } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-08-2%E6%9C%888%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"\u9898\u89e3 \u00b6 \u5148\u8fdb\u884cLCA\u7b97\u6cd5\uff0c\u8ba1\u7b97\u51fa\u6bcf\u4e2a\u70b9\u7684\u6df1\u5ea6\u3001\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\u7b49\uff0c\u7136\u540e\u5bf9\u4e94\u4e2a\u70b9\uff08\u5206\u522b\u4e3as1,s2,s3,s4,s5\uff09\u8fdb\u884c\u5904\u7406\uff1a \u5c06\u7b2cs1\u52a0\u5165\u56fe\u4e2d\uff0c\u5982\u56fe\uff0c\u589e\u52a0\u7684\u6743\u503c\u4e3adis[s1] \u5c06s2\u52a0\u5165\u56fe\u4e2d\uff0c\u5047\u5982s1\u548cs2\u7684\u6700\u5c0f\u516c\u5171\u7956\u5148\u4e3afa1\u5373\u4e3alca(s1,s2)\uff0c\u5219\u589e\u52a0\u7684\u6743\u503c\u4e3adis[s2]-dis[fa1] \u5c06s3\u52a0\u5165\u56fe\u4e2d\uff0c\u5047\u8bbes1\u548cs3\u7684\u6700\u5c0f\u516c\u5171\u7956\u5148\u4e3afa2\uff0cs2\u548cs3\u7684\u6700\u5c0f\u516c\u5171\u6700\u5148\u4e3afa1\uff0c\u5047\u8bbefa1\u7684\u6df1\u5ea6\u5c0f\u4e8efa2\u7684\u6df1\u5ea6\uff0c\u5219\u589e\u52a0\u7684\u6743\u503c\u4e3adis[s3]-dis[fa2] \u91cd\u590d\u7b2c3\u8fc7\u7a0b\uff0c\u5c06s4,s5\u4e24\u4e2a\u70b9\u52a0\u5165\u5230\u56fe\u5f53\u4e2d\uff0c\u6700\u540e\u6743\u503c\u548c\u51cf\u53bb\u6240\u6709\u70b9\u7684\u6700\u5c0f\u516c\u5171\u7956\u5148\u5230\u6839\u8282\u70b91\u7684\u8ddd\u79bb\u5373\u4e3a\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #include <cstdio> #include <cstring> #include <algorithm> #include <bits/stdc++.h> using namespace std ; const int maxn = 1e5 + 500 ; struct node { int to , nex , w ; } road [ maxn * 2 ]; int n , q , cnt ; int pre [ maxn ][ 32 ], head [ maxn ], depth [ maxn ]; int dis [ maxn ]; void add ( int u , int v , int w ) { road [ cnt ]. to = v ; road [ cnt ]. w = w ; road [ cnt ]. nex = head [ u ]; head [ u ] = cnt ++ ; } void dfs ( int u , int fa ) { pre [ u ][ 0 ] = fa ; depth [ u ] = depth [ fa ] + 1 ; for ( int i = 1 ; ( 1 << i ) <= depth [ u ]; i ++ ) //\u500d\u589e pre [ u ][ i ] = pre [ pre [ u ][ i -1 ]][ i -1 ]; for ( int i = head [ u ]; ~ i ; i = road [ i ]. nex ) { int v = road [ i ]. to ; if ( v != fa ) { dis [ v ] = dis [ u ] + road [ i ]. w ; dfs ( v , u ); } } } int lca ( int u , int v ) { if ( depth [ u ] < depth [ v ]) { swap ( u , v ); } int i = -1 , j ; while (( 1 << ( i + 1 )) <= depth [ u ]) i ++ ; for ( j = i ; j >= 0 ; j -- ) { if ( depth [ u ] - ( 1 << j ) >= depth [ v ]) { u = pre [ u ][ j ]; } } if ( u == v ) return u ; for ( int j = i ; j >= 0 ; j -- ) { if ( pre [ u ][ j ] != pre [ v ][ j ]) { u = pre [ u ][ j ]; v = pre [ v ][ j ]; } } return pre [ u ][ 0 ]; } int main () { scanf ( \"%d\" , & n ); memset ( head , -1 , sizeof ( head )); memset ( depth , 0 , sizeof ( depth )); cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int u , v , w ; scanf ( \"%d %d %d\" , & u , & v , & w ); add ( u + 1 , v + 1 , w ); add ( v + 1 , u + 1 , w ); } dis [ 1 ] = 0 ; dfs ( 1 , 0 ); scanf ( \"%d\" , & q ); while ( q -- ) { int point [ 10 ] = { 0 }; for ( int i = 1 ; i <= 5 ; i ++ ) scanf ( \"%d\" , & point [ i ]), point [ i ] ++ ; int ans = 0 ; for ( int i = 1 ; i <= 5 ; i ++ ) { int dep = 1 ; for ( int j = 1 ; j < i ; j ++ ) { int fa = lca ( point [ i ], point [ j ]); if ( depth [ fa ] > depth [ dep ]) dep = fa ; } ans += dis [ point [ i ]]; ans -= dis [ dep ]; } int dep = point [ 1 ]; for ( int i = 1 ; i <= 5 ; i ++ ) dep = lca ( point [ i ], dep ); ans -= dis [ dep ]; cout << ans << endl ; } } \u9898\u89e3 \u00b6 \u8be5\u9898\u70b9\u6570\u8f83\u5c11\uff0c\u53ef\u4ee5\u76f4\u63a5\u66b4\u529b\u505a\uff0c\u4f46\u662fdfs\u4f1a\u8d85\u65f6\uff0c\u6539\u7528bfs\u5373\u53ef\uff0c\u8be6\u7ec6\u89c1\u4ee3\u7801\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; vector < ll > v [ 100500 ]; //\u5b58\u56fe\u7528 ll vis [ 5050 ] = { 0 }; ///\u8bb0\u5f55\u8ddd\u79bb\u7528 ll to [ 5050 ] = { 0 }; ///\u5230\u8be5\u70b9\u7684\u9053\u8def\u4e2a\u6570 ll sum_vis [ 5050 ] = { 0 }; ///bfs\u7edf\u8ba1\u7528 long double val_all [ 5050 ] = { 0 }; ///\u7edf\u8ba1\u6743\u503c\u7528 ll s , e ; ///\u5f00\u59cb\u7ed3\u5c3e ll sum_size = 0 ; struct node { ll pos , val ; }; void bfs () { queue < node > que ; que . push ({ s , 0 }); vis [ s ] = 0 ; to [ s ] = 1 ; while ( ! que . empty ()) { node now = que . front (); que . pop (); vis [ now . pos ] = min ( vis [ now . pos ], now . val ); for ( ll i : v [ now . pos ]) { if ( vis [ i ] > now . val + 1 ) { vis [ i ] = now . val + 1 ; to [ i ] = to [ now . pos ]; que . push ({ i , now . val + 1 }); } else if ( vis [ i ] == now . val + 1 ) { to [ i ] += to [ now . pos ]; } } } sum_size = to [ e ]; } void bfs1 () { queue < int > que ; que . push ( e ); while ( ! que . empty ()) { int now = que . front (); que . pop (); sum_vis [ vis [ now ]] += to [ now ]; for ( int i : v [ now ]) { if ( vis [ i ] == vis [ now ] -1 ) que . push ( i ); } } que . push ( e ); while ( ! que . empty ()) { int now = que . front (); que . pop (); val_all [ now ] += to [ now ] * 1.0 / sum_vis [ vis [ now ]]; ///\u5230\u8be5\u70b9\u8def\u7684\u6761\u6570\u5360\u76f8\u540c\u957f\u5ea6\u6761\u6570\u7684\u6bd4\u4f8b for ( int i : v [ now ]) { if ( vis [ i ] == vis [ now ] -1 ) { que . push ( i ); } } } } ll dfs ( ll k , ll sum ) { if ( k == e ) { if ( sum == vis [ k ]) sum_size ++ ; else if ( sum < vis [ k ]) vis [ k ] = sum , sum_size = 1 ; } vis [ k ] = min ( vis [ k ], sum ); for ( ll i : v [ k ]) { if ( vis [ i ] >= sum + 1 ) dfs ( i , sum + 1 ); } return 0 ; } long double dfs1 ( ll k , ll sum ) { if ( sum > vis [ e ]) return 0 ; if ( k == e ) { val_all [ k ] += 1.0 / sum_size ; return 1.0 / sum_size ; } long double val = 0 ; for ( ll i : v [ k ]) { if ( vis [ i ] == vis [ k ] + 1 ) val += dfs1 ( i , sum + 1 ); } val_all [ k ] += val ; return val ; } int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld\" , & s , & e ); v [ s ]. push_back ( e ); v [ e ]. push_back ( s ); } ll k ; scanf ( \"%lld\" , & k ); for ( ll i = 1 ; i <= k ; i ++ ) { scanf ( \"%lld%lld\" , & s , & e ); memset ( vis , inf , sizeof ( vis )); memset ( to , 0 , sizeof ( to )); memset ( sum_vis , 0 , sizeof ( sum_vis )); bfs (); //dfs(s,0) ///\u8fd9\u91ccdfs\u4e5f\u53ef\u4ee5\u5f97\u51fa\u6b63\u786e\u7b54\u6848\uff0c\u4f46\u662f\u65f6\u95f4\u4f1a\u8d85,qwq bfs1 (); //dfs1(s,0); ///bfs\u548cdfs\u5747\u53ef\uff0cbfs\u66f4\u5feb\u4e00\u70b9\uff0cdfs\u66f4\u597d\u7406\u89e3\u4e00\u70b9\uff0c\u8fd9\u91cc\u7528dfs\u65f6\u95f4\u4e0d\u4f1a\u8d85 } ll max1 = 0 ; for ( ll i = 0 ; i < n ; i ++ ) { if ( val_all [ i ] > val_all [ max1 ]) max1 = i ; } cout << max1 << endl ; } \u9898\u89e3 \u00b6 \u8be5\u9898\u76ee\u53c2\u7167\u535a\u5ba2https://m-sea-blog.com/archives/2139\uff0c\u9644\u4e00\u5f20\u56fe\uff1a \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u53d6\u4f59\u540e\u7684\u7ed3\u679c\u4e3a\u5468\u671f\u4e3aa\u7684\u5468\u671f\u51fd\u6570\uff0c\u4efb\u53d6\u4e00\u70b9k\uff0c\u5982\u679c(2 * k)%a <= k%a\uff0c\u5219\u4e00\u5b9a\u6709k < a <= 2 * k\uff0c\u9884\u5148\u7f29\u5c0f\u8303\u56f4\u7136\u540e\u4e8c\u5206\u5373\u53ef\u5f97\u5230\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char query ( int x , int y ) { cout << \"? \" << x << \" \" << y << endl ; cout . flush (); char ans ; cin >> ans ; return ans ; } int main () { while ( 1 ) { string s ; cin >> s ; if ( s == \"end\" ) break ; ll l , r ; for ( ll i = 1 ;; i = i * 2 ) { l = i , r = min ( i * 2 ,( ll ) 2e9 ); char ans = query ( l , r ); if ( ans == 'x' ) { l = i , r = min ( i * 2 ,( ll ) 1e9 ); break ; } } while ( l < r ) { int mid = ( l + r ) / 2 ; char ans = query ( mid * 2 , mid ); if ( ans == 'x' ) r = mid ; else l = mid + 1 ; } if ( l == 2 ) { char ans = query ( 2 , 1 ); if ( ans == 'x' ) { cout << \"! 1\" << endl ; cout . flush (); continue ; } else { cout << \"! 2\" << endl ; cout . flush (); continue ; } } cout << \"! \" << l << endl ; cout . flush (); } }","title":"2021-02-08-2\u67088\u65e5\u9898\u89e3"},{"location":"problem/2021-02-08-2%E6%9C%888%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u5148\u8fdb\u884cLCA\u7b97\u6cd5\uff0c\u8ba1\u7b97\u51fa\u6bcf\u4e2a\u70b9\u7684\u6df1\u5ea6\u3001\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\u7b49\uff0c\u7136\u540e\u5bf9\u4e94\u4e2a\u70b9\uff08\u5206\u522b\u4e3as1,s2,s3,s4,s5\uff09\u8fdb\u884c\u5904\u7406\uff1a \u5c06\u7b2cs1\u52a0\u5165\u56fe\u4e2d\uff0c\u5982\u56fe\uff0c\u589e\u52a0\u7684\u6743\u503c\u4e3adis[s1] \u5c06s2\u52a0\u5165\u56fe\u4e2d\uff0c\u5047\u5982s1\u548cs2\u7684\u6700\u5c0f\u516c\u5171\u7956\u5148\u4e3afa1\u5373\u4e3alca(s1,s2)\uff0c\u5219\u589e\u52a0\u7684\u6743\u503c\u4e3adis[s2]-dis[fa1] \u5c06s3\u52a0\u5165\u56fe\u4e2d\uff0c\u5047\u8bbes1\u548cs3\u7684\u6700\u5c0f\u516c\u5171\u7956\u5148\u4e3afa2\uff0cs2\u548cs3\u7684\u6700\u5c0f\u516c\u5171\u6700\u5148\u4e3afa1\uff0c\u5047\u8bbefa1\u7684\u6df1\u5ea6\u5c0f\u4e8efa2\u7684\u6df1\u5ea6\uff0c\u5219\u589e\u52a0\u7684\u6743\u503c\u4e3adis[s3]-dis[fa2] \u91cd\u590d\u7b2c3\u8fc7\u7a0b\uff0c\u5c06s4,s5\u4e24\u4e2a\u70b9\u52a0\u5165\u5230\u56fe\u5f53\u4e2d\uff0c\u6700\u540e\u6743\u503c\u548c\u51cf\u53bb\u6240\u6709\u70b9\u7684\u6700\u5c0f\u516c\u5171\u7956\u5148\u5230\u6839\u8282\u70b91\u7684\u8ddd\u79bb\u5373\u4e3a\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-08-2%E6%9C%888%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#include <cstdio> #include <cstring> #include <algorithm> #include <bits/stdc++.h> using namespace std ; const int maxn = 1e5 + 500 ; struct node { int to , nex , w ; } road [ maxn * 2 ]; int n , q , cnt ; int pre [ maxn ][ 32 ], head [ maxn ], depth [ maxn ]; int dis [ maxn ]; void add ( int u , int v , int w ) { road [ cnt ]. to = v ; road [ cnt ]. w = w ; road [ cnt ]. nex = head [ u ]; head [ u ] = cnt ++ ; } void dfs ( int u , int fa ) { pre [ u ][ 0 ] = fa ; depth [ u ] = depth [ fa ] + 1 ; for ( int i = 1 ; ( 1 << i ) <= depth [ u ]; i ++ ) //\u500d\u589e pre [ u ][ i ] = pre [ pre [ u ][ i -1 ]][ i -1 ]; for ( int i = head [ u ]; ~ i ; i = road [ i ]. nex ) { int v = road [ i ]. to ; if ( v != fa ) { dis [ v ] = dis [ u ] + road [ i ]. w ; dfs ( v , u ); } } } int lca ( int u , int v ) { if ( depth [ u ] < depth [ v ]) { swap ( u , v ); } int i = -1 , j ; while (( 1 << ( i + 1 )) <= depth [ u ]) i ++ ; for ( j = i ; j >= 0 ; j -- ) { if ( depth [ u ] - ( 1 << j ) >= depth [ v ]) { u = pre [ u ][ j ]; } } if ( u == v ) return u ; for ( int j = i ; j >= 0 ; j -- ) { if ( pre [ u ][ j ] != pre [ v ][ j ]) { u = pre [ u ][ j ]; v = pre [ v ][ j ]; } } return pre [ u ][ 0 ]; } int main () { scanf ( \"%d\" , & n ); memset ( head , -1 , sizeof ( head )); memset ( depth , 0 , sizeof ( depth )); cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int u , v , w ; scanf ( \"%d %d %d\" , & u , & v , & w ); add ( u + 1 , v + 1 , w ); add ( v + 1 , u + 1 , w ); } dis [ 1 ] = 0 ; dfs ( 1 , 0 ); scanf ( \"%d\" , & q ); while ( q -- ) { int point [ 10 ] = { 0 }; for ( int i = 1 ; i <= 5 ; i ++ ) scanf ( \"%d\" , & point [ i ]), point [ i ] ++ ; int ans = 0 ; for ( int i = 1 ; i <= 5 ; i ++ ) { int dep = 1 ; for ( int j = 1 ; j < i ; j ++ ) { int fa = lca ( point [ i ], point [ j ]); if ( depth [ fa ] > depth [ dep ]) dep = fa ; } ans += dis [ point [ i ]]; ans -= dis [ dep ]; } int dep = point [ 1 ]; for ( int i = 1 ; i <= 5 ; i ++ ) dep = lca ( point [ i ], dep ); ans -= dis [ dep ]; cout << ans << endl ; } }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-08-2%E6%9C%888%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u8be5\u9898\u70b9\u6570\u8f83\u5c11\uff0c\u53ef\u4ee5\u76f4\u63a5\u66b4\u529b\u505a\uff0c\u4f46\u662fdfs\u4f1a\u8d85\u65f6\uff0c\u6539\u7528bfs\u5373\u53ef\uff0c\u8be6\u7ec6\u89c1\u4ee3\u7801\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-08-2%E6%9C%888%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; vector < ll > v [ 100500 ]; //\u5b58\u56fe\u7528 ll vis [ 5050 ] = { 0 }; ///\u8bb0\u5f55\u8ddd\u79bb\u7528 ll to [ 5050 ] = { 0 }; ///\u5230\u8be5\u70b9\u7684\u9053\u8def\u4e2a\u6570 ll sum_vis [ 5050 ] = { 0 }; ///bfs\u7edf\u8ba1\u7528 long double val_all [ 5050 ] = { 0 }; ///\u7edf\u8ba1\u6743\u503c\u7528 ll s , e ; ///\u5f00\u59cb\u7ed3\u5c3e ll sum_size = 0 ; struct node { ll pos , val ; }; void bfs () { queue < node > que ; que . push ({ s , 0 }); vis [ s ] = 0 ; to [ s ] = 1 ; while ( ! que . empty ()) { node now = que . front (); que . pop (); vis [ now . pos ] = min ( vis [ now . pos ], now . val ); for ( ll i : v [ now . pos ]) { if ( vis [ i ] > now . val + 1 ) { vis [ i ] = now . val + 1 ; to [ i ] = to [ now . pos ]; que . push ({ i , now . val + 1 }); } else if ( vis [ i ] == now . val + 1 ) { to [ i ] += to [ now . pos ]; } } } sum_size = to [ e ]; } void bfs1 () { queue < int > que ; que . push ( e ); while ( ! que . empty ()) { int now = que . front (); que . pop (); sum_vis [ vis [ now ]] += to [ now ]; for ( int i : v [ now ]) { if ( vis [ i ] == vis [ now ] -1 ) que . push ( i ); } } que . push ( e ); while ( ! que . empty ()) { int now = que . front (); que . pop (); val_all [ now ] += to [ now ] * 1.0 / sum_vis [ vis [ now ]]; ///\u5230\u8be5\u70b9\u8def\u7684\u6761\u6570\u5360\u76f8\u540c\u957f\u5ea6\u6761\u6570\u7684\u6bd4\u4f8b for ( int i : v [ now ]) { if ( vis [ i ] == vis [ now ] -1 ) { que . push ( i ); } } } } ll dfs ( ll k , ll sum ) { if ( k == e ) { if ( sum == vis [ k ]) sum_size ++ ; else if ( sum < vis [ k ]) vis [ k ] = sum , sum_size = 1 ; } vis [ k ] = min ( vis [ k ], sum ); for ( ll i : v [ k ]) { if ( vis [ i ] >= sum + 1 ) dfs ( i , sum + 1 ); } return 0 ; } long double dfs1 ( ll k , ll sum ) { if ( sum > vis [ e ]) return 0 ; if ( k == e ) { val_all [ k ] += 1.0 / sum_size ; return 1.0 / sum_size ; } long double val = 0 ; for ( ll i : v [ k ]) { if ( vis [ i ] == vis [ k ] + 1 ) val += dfs1 ( i , sum + 1 ); } val_all [ k ] += val ; return val ; } int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld\" , & s , & e ); v [ s ]. push_back ( e ); v [ e ]. push_back ( s ); } ll k ; scanf ( \"%lld\" , & k ); for ( ll i = 1 ; i <= k ; i ++ ) { scanf ( \"%lld%lld\" , & s , & e ); memset ( vis , inf , sizeof ( vis )); memset ( to , 0 , sizeof ( to )); memset ( sum_vis , 0 , sizeof ( sum_vis )); bfs (); //dfs(s,0) ///\u8fd9\u91ccdfs\u4e5f\u53ef\u4ee5\u5f97\u51fa\u6b63\u786e\u7b54\u6848\uff0c\u4f46\u662f\u65f6\u95f4\u4f1a\u8d85,qwq bfs1 (); //dfs1(s,0); ///bfs\u548cdfs\u5747\u53ef\uff0cbfs\u66f4\u5feb\u4e00\u70b9\uff0cdfs\u66f4\u597d\u7406\u89e3\u4e00\u70b9\uff0c\u8fd9\u91cc\u7528dfs\u65f6\u95f4\u4e0d\u4f1a\u8d85 } ll max1 = 0 ; for ( ll i = 0 ; i < n ; i ++ ) { if ( val_all [ i ] > val_all [ max1 ]) max1 = i ; } cout << max1 << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-08-2%E6%9C%888%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u8be5\u9898\u76ee\u53c2\u7167\u535a\u5ba2https://m-sea-blog.com/archives/2139\uff0c\u9644\u4e00\u5f20\u56fe\uff1a \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u53d6\u4f59\u540e\u7684\u7ed3\u679c\u4e3a\u5468\u671f\u4e3aa\u7684\u5468\u671f\u51fd\u6570\uff0c\u4efb\u53d6\u4e00\u70b9k\uff0c\u5982\u679c(2 * k)%a <= k%a\uff0c\u5219\u4e00\u5b9a\u6709k < a <= 2 * k\uff0c\u9884\u5148\u7f29\u5c0f\u8303\u56f4\u7136\u540e\u4e8c\u5206\u5373\u53ef\u5f97\u5230\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-08-2%E6%9C%888%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char query ( int x , int y ) { cout << \"? \" << x << \" \" << y << endl ; cout . flush (); char ans ; cin >> ans ; return ans ; } int main () { while ( 1 ) { string s ; cin >> s ; if ( s == \"end\" ) break ; ll l , r ; for ( ll i = 1 ;; i = i * 2 ) { l = i , r = min ( i * 2 ,( ll ) 2e9 ); char ans = query ( l , r ); if ( ans == 'x' ) { l = i , r = min ( i * 2 ,( ll ) 1e9 ); break ; } } while ( l < r ) { int mid = ( l + r ) / 2 ; char ans = query ( mid * 2 , mid ); if ( ans == 'x' ) r = mid ; else l = mid + 1 ; } if ( l == 2 ) { char ans = query ( 2 , 1 ); if ( ans == 'x' ) { cout << \"! 1\" << endl ; cout . flush (); continue ; } else { cout << \"! 2\" << endl ; cout . flush (); continue ; } } cout << \"! \" << l << endl ; cout . flush (); } }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"\u9898\u89e3 \u00b6 \u7528\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\u67d0\u4e00\u533a\u95f4\u7684\u6700\u5c0f\u503c\uff0c\u7136\u540e\u5bf9 (0,n-1) \u6bcf\u4e00\u4e2a\u6570\u8fdb\u884c\u67e5\u8be2\uff0c\u5b9a\u4f4d\u5230\u8be5\u6570\u6240\u5728\u7684\u6700\u5c0f\u533a\u95f4\uff08\u6ce8\u610f\u7279\u5224\u4e00\u4e2a\u6700\u5c0f\u503c\u5bf9\u5e94\u591a\u4e2a\u533a\u95f4\u8fd9\u79cd\u60c5\u51b5\uff09\uff0c\u7136\u540e\u5bf9\u8be5\u533a\u95f4\u7684\u6700\u5c0f\u503c\u7684 \u6700\u5c0f\u503c \u8fdb\u884c\u67e5\u8be2\uff0c\u5982\u679c\u8fd9\u4e2a\u533a\u95f4\u7684\u6700\u5c0f\u503c\u90fd\u6bd4\u8be5\u503c\u5927\uff0c\u5219\u8f93\u51fa-1\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll l , r , pos , min1 , add ; }; ll n , q ; node tree [ 400500 ] = { 0 }; struct node1 { ll l , r ; }; vector < node1 > v [ 100500 ]; ll num [ 100500 ] = { 0 }; void build ( ll t , ll l , ll r ) { tree [ t ]. pos = l ; tree [ t ]. l = l ; tree [ t ]. r = r ; tree [ t ]. min1 = -1 ; tree [ t ]. add = -1 ; if ( l == r ) return ; ll mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); return ; } void push_up ( ll p ) { if ( tree [ p * 2 ]. min1 < tree [ p * 2 + 1 ]. min1 ){ tree [ p ]. min1 = tree [ p * 2 ]. min1 ; tree [ p ]. pos = tree [ p * 2 ]. pos ; } else { tree [ p ]. min1 = tree [ p * 2 + 1 ]. min1 ; tree [ p ]. pos = tree [ p * 2 + 1 ]. pos ; } return ; } void push_down ( ll t ) { if ( tree [ t ]. add == -1 ) return ; tree [ 2 * t ]. add = max ( tree [ t ]. add , tree [ 2 * t ]. add ); ///\u6700\u5c0f\u503c\u4e2d\u53d6\u6700\u5927 tree [ 2 * t + 1 ]. add = max ( tree [ t ]. add , tree [ 2 * t + 1 ]. add ); tree [ 2 * t ]. min1 = max ( tree [ t ]. min1 , tree [ 2 * t ]. min1 ); tree [ 2 * t + 1 ]. min1 = max ( tree [ t ]. min1 , tree [ 2 * t + 1 ]. min1 ); tree [ t ]. add = -1 ; return ; } void update ( ll t , ll l , ll r , ll x ) { if ( l == tree [ t ]. l && r == tree [ t ]. r ) { tree [ t ]. add = max ( tree [ t ]. add , x ); tree [ t ]. min1 = max ( tree [ t ]. min1 , x ); return ; } push_down ( t ); ll mid = ( tree [ t ]. l + tree [ t ]. r ) / 2 ; if ( r <= mid ) update ( 2 * t , l , r , x ); else if ( l > mid ) update ( 2 * t + 1 , l , r , x ); else { update ( 2 * t , l , mid , x ); update ( 2 * t + 1 , mid + 1 , r , x ); } push_up ( t ); return ; } void update ( ll t , ll pos ) { if ( tree [ t ]. l == tree [ t ]. r ) { tree [ t ]. min1 = 1e9 ; return ; } push_down ( t ); ll mid = ( tree [ t ]. l + tree [ t ]. r ) / 2 ; if ( pos <= mid ) update ( 2 * t , pos ); if ( pos > mid ) update ( 2 * t + 1 , pos ); push_up ( t ); return ; } node query ( ll t , ll l , ll r ) { if ( tree [ t ]. l == l && tree [ t ]. r == r ) { return tree [ t ]; } push_down ( t ); ll mid = ( tree [ t ]. l + tree [ t ]. r ) / 2 ; if ( r <= mid ) return query ( 2 * t , l , r ); else if ( mid < l ) return query ( 2 * t + 1 , l , r ); else { node tree1 = query ( 2 * t , l , mid ); node tree2 = query ( 2 * t + 1 , mid + 1 , r ); if ( tree1 . min1 < tree2 . min1 ) return tree1 ; else return tree2 ; } } int main () { scanf ( \"%lld%lld\" , & n , & q ); build ( 1 , 1 , n ); for ( ll i = 1 ; i <= q ; i ++ ) { ll l , r , x ; scanf ( \"%lld%lld%lld\" , & l , & r , & x ); l ++ , r ++ , x ++ ; update ( 1 , l , r , x ); v [ x ]. push_back ({ l , r }); } ll flag = 1 ; for ( ll x = 1 ; x <= n && flag ; x ++ ) { ll l = 1 , r = n ; for ( int i = 0 ; i < v [ x ]. size (); i ++ ) { l = max ( l , v [ x ][ i ]. l ); r = min ( r , v [ x ][ i ]. r ); } if ( l > r ) ///\u4e00\u4e2a\u6700\u5c0f\u503c\u5bf9\u5e94\u591a\u4e2a\u533a\u95f4\u7684\u60c5\u51b5 { flag = 0 ; break ; } node ans = query ( 1 , l , r ); if ( ans . min1 > x ) { flag = 0 ; break ; } ll pos = ans . pos ; num [ pos ] = x -1 ; update ( 1 , pos ); } if ( ! flag ) { for ( ll i = 1 ; i <= n ; i ++ ) { printf ( \"-1 \" ); } printf ( \" \\n \" ); } else { for ( ll i = 1 ; i <= n ; i ++ ) { printf ( \"%d \" , num [ i ]); } printf ( \" \\n \" ); } return 0 ; } \u9898\u89e3 \u00b6 \u8def\u5f84\u53ef\u4ee5\u62fc\u51d1\u6210\u4e00\u4e2a\u957f\u65b9\u5f62\uff0c\u53ea\u9700\u8981\u66b4\u529b\u627e\u5230\u8fd9\u4e2a\u957f\u65b9\u5f62\u5373\u53ef\uff0c\u6ce8\u610f\u5982\u679c\u4e24\u4e2a\u70b9\u5728\u540c\u4e00\u6761\u76f4\u7ebf\u4e0a\u5219\u9700\u8981\u5c06\u4e24\u4e2a\u70b9\u9519\u5f00\u3002 \u4ee3\u7801 \u00b6 #include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; int x1 , x2 , y1 , y2 ; int px , py , dis = 0 ; int judge1 ( int x , int y ) { int dis1 = abs ( x1 - x ) + abs ( y1 - y ); if ( dis1 > dis ) px = x , py = y , dis = dis1 ; } int main () { scanf ( \"%d%d%d%d\" , & x1 , & y1 , & x2 , & y2 ); if ( x1 == x2 ) x1 ++ ; if ( y1 == y2 ) y1 ++ ; judge1 ( x2 + 1 , y2 + 1 ); judge1 ( x2 + 1 , y2 ); judge1 ( x2 + 1 , y2 -1 ); judge1 ( x2 , y2 + 1 ); judge1 ( x2 , y2 -1 ); judge1 ( x2 -1 , y2 + 1 ); judge1 ( x2 -1 , y2 ); judge1 ( x2 -1 , y2 -1 ); printf ( \"%d \\n \" , dis * 2 ); } \u9898\u89e3 \u00b6 \u6839\u636e\u9898\u610f\u76f4\u63a5\u6807\u8bb0\u6a21\u62df\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; char a [ 2000 ] = { 0 }; map < char , int > s ; map < int , int > k ; char b [ 2000 ][ 2000 ] = { 0 }; map < char , int > mp1 ; map < char , int > mp ; int main () { int n ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , a + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] == '*' ) k [ i ] = 1 ; else s [ a [ i ]] = 1 ; } int m ; scanf ( \"%d\" , & m ); int sum = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%s\" , b [ ++ sum ] + 1 ); int flag = 1 ; for ( int j = 1 ; j <= n && flag ; j ++ ) { if ( k [ j ] && s [ b [ sum ][ j ]]) flag = 0 ; else if ( ! k [ j ] && b [ sum ][ j ] != a [ j ]) flag = 0 ; } if ( ! flag ) sum -- ; } for ( int i = 1 ; i <= sum ; i ++ ) { mp . clear (); for ( int j = 1 ; j <= n ; j ++ ) { if ( k [ j ]) { if ( ! mp [ b [ i ][ j ]]) { mp [ b [ i ][ j ]] = 1 ; mp1 [ b [ i ][ j ]] ++ ; } } } } int ans = 0 ; for ( char i = 'a' ; i <= 'z' ; i ++ ) { if ( mp1 [ i ] == sum ) ans ++ ; } cout << ans << endl ; } \u9898\u89e3 \u00b6 \u5c06u\u66ff\u6362\u4e3aoo\uff0ckh\u66ff\u6362\u4e3ah\uff0c\u7136\u540e\u627e\u76f8\u540c\u7684\u5b57\u7b26\u4e32\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; char a [ 500 ][ 500 ] = { 0 }; int ans [ 500 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , a [ i ] + 1 ); } for ( int i = 1 ; i <= n ; i ++ ) { stack < char > s ; for ( int j = 1 ; a [ i ][ j ]; j ++ ) { if ( a [ i ][ j ] == 'u' ) { s . push ( 'o' ); s . push ( 'o' ); } else if ( a [ i ][ j ] == 'h' ) { while ( ! s . empty () && s . top () == 'k' ) s . pop (); s . push ( 'h' ); } else { s . push ( a [ i ][ j ]); } } int sum = 0 ; while ( ! s . empty ()) { a [ i ][ ++ sum ] = s . top (); s . pop (); } a [ i ][ ++ sum ] = '\\0' ; } int ans1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ans [ i ]) continue ; for ( int j = i + 1 ; j <= n ; j ++ ) { if ( strcmp ( a [ i ] + 1 , a [ j ] + 1 ) == 0 ) { ans [ j ] = 1 ; ans1 ++ ; } } } cout << n - ans1 << endl ; } \u9898\u89e3 \u00b6 \u627e\u6700\u5927\u76f8\u540c\u957f\u5ea6\u7684\u56de\u6587\u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u53d1\u73b0\u6784\u9020 abcba \u8fd9\u79cd\u5b57\u7b26\u4e32\uff08\u4e24\u8fb9\u4e3a\u80fd\u591f\u5339\u914d\u7684\u5b57\u6bcd\uff0c\u4e2d\u95f4\u4e3a\u4e0d\u80fd\u5339\u914d\u7684\uff09\u80fd\u591f\u6700\u5c0f\u7a0b\u5ea6\u7684\u51cf\u5c11\u5757\u6570\uff0c\u63d0\u9ad8\u957f\u5ea6\uff0c\u7528\u5806\u6808\u6765\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; char a [ 400500 ] = { 0 }; map < char , int > mp ; stack < char > s1 , s2 ; queue < char > que2 ; int main () { int n ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , a + 1 ); for ( int i = 1 ; i <= n ; i ++ ) mp [ a [ i ]] ++ ; for ( char i = 'a' ; i <= 'z' ; i ++ ) { if ( mp [ i ] % 2 == 1 ) que2 . push ( i ); for ( int j = 1 ; j <= mp [ i ] / 2 ; j ++ ) { s1 . push ( i ); s2 . push ( i ); } } for ( char i = '0' ; i <= '9' ; i ++ ) { if ( mp [ i ] % 2 == 1 ) que2 . push ( i ); for ( int j = 1 ; j <= mp [ i ] / 2 ; j ++ ) { s1 . push ( i ); s2 . push ( i ); } } for ( char i = 'A' ; i <= 'Z' ; i ++ ) { if ( mp [ i ] % 2 == 1 ) que2 . push ( i ); for ( int j = 1 ; j <= mp [ i ] / 2 ; j ++ ) { s1 . push ( i ); s2 . push ( i ); } } if ( que2 . size () == 0 ) { printf ( \"%d \\n \" , 1 ); stack < char > s ; while ( ! s1 . empty ()) s . push ( s1 . top ()), s1 . pop (); while ( ! s . empty ()) printf ( \"%c\" , s . top ()), s . pop (); while ( ! s2 . empty ()) printf ( \"%c\" , s2 . top ()), s2 . pop (); } else { while ( s1 . size () % que2 . size () != 0 ) { que2 . push ( s1 . top ()); s1 . pop (); que2 . push ( s2 . top ()); s2 . pop (); } printf ( \"%d \\n \" , que2 . size ()); int size1 = s1 . size () / que2 . size (); while ( ! que2 . empty ()) { stack < char > s ; for ( int i = 0 ; i < size1 ; i ++ ) s . push ( s1 . top ()), s1 . pop (); while ( ! s . empty ()) printf ( \"%c\" , s . top ()), s . pop (); printf ( \"%c\" , que2 . front ()), que2 . pop (); for ( int i = 0 ; i < size1 ; i ++ ) printf ( \"%c\" , s2 . top ()), s2 . pop (); printf ( \" \" ); } } } \u9898\u89e3 \u00b6 \u4e8c\u5206\u6700\u5927\u5dee\u503c\uff0c\u7136\u540e\u7528dp\u6765\u8fdb\u884ccheck() \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 300500 ] = { 0 }; int dp [ 300500 ] = { 0 }; int n , m ; int check ( ll k ) { for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 1 ; int last = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { while ( a [ i ] - a [ last ] > k ) last ++ ; for ( int j = last ; j + m <= i + 1 ; j ++ ) { if ( dp [ j -1 ]) { dp [ i ] = 1 ; break ; } else { last ++ ; } } } return dp [ n ]; } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); sort ( a + 1 , a + n + 1 ); ll l = 0 , r = 2e9 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( check ( mid )) r = mid ; else l = mid + 1 ; } cout << l << endl ; }","title":"2021-02-09-2\u67089\u65e5\u9898\u89e3"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u7528\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\u67d0\u4e00\u533a\u95f4\u7684\u6700\u5c0f\u503c\uff0c\u7136\u540e\u5bf9 (0,n-1) \u6bcf\u4e00\u4e2a\u6570\u8fdb\u884c\u67e5\u8be2\uff0c\u5b9a\u4f4d\u5230\u8be5\u6570\u6240\u5728\u7684\u6700\u5c0f\u533a\u95f4\uff08\u6ce8\u610f\u7279\u5224\u4e00\u4e2a\u6700\u5c0f\u503c\u5bf9\u5e94\u591a\u4e2a\u533a\u95f4\u8fd9\u79cd\u60c5\u51b5\uff09\uff0c\u7136\u540e\u5bf9\u8be5\u533a\u95f4\u7684\u6700\u5c0f\u503c\u7684 \u6700\u5c0f\u503c \u8fdb\u884c\u67e5\u8be2\uff0c\u5982\u679c\u8fd9\u4e2a\u533a\u95f4\u7684\u6700\u5c0f\u503c\u90fd\u6bd4\u8be5\u503c\u5927\uff0c\u5219\u8f93\u51fa-1\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll l , r , pos , min1 , add ; }; ll n , q ; node tree [ 400500 ] = { 0 }; struct node1 { ll l , r ; }; vector < node1 > v [ 100500 ]; ll num [ 100500 ] = { 0 }; void build ( ll t , ll l , ll r ) { tree [ t ]. pos = l ; tree [ t ]. l = l ; tree [ t ]. r = r ; tree [ t ]. min1 = -1 ; tree [ t ]. add = -1 ; if ( l == r ) return ; ll mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); return ; } void push_up ( ll p ) { if ( tree [ p * 2 ]. min1 < tree [ p * 2 + 1 ]. min1 ){ tree [ p ]. min1 = tree [ p * 2 ]. min1 ; tree [ p ]. pos = tree [ p * 2 ]. pos ; } else { tree [ p ]. min1 = tree [ p * 2 + 1 ]. min1 ; tree [ p ]. pos = tree [ p * 2 + 1 ]. pos ; } return ; } void push_down ( ll t ) { if ( tree [ t ]. add == -1 ) return ; tree [ 2 * t ]. add = max ( tree [ t ]. add , tree [ 2 * t ]. add ); ///\u6700\u5c0f\u503c\u4e2d\u53d6\u6700\u5927 tree [ 2 * t + 1 ]. add = max ( tree [ t ]. add , tree [ 2 * t + 1 ]. add ); tree [ 2 * t ]. min1 = max ( tree [ t ]. min1 , tree [ 2 * t ]. min1 ); tree [ 2 * t + 1 ]. min1 = max ( tree [ t ]. min1 , tree [ 2 * t + 1 ]. min1 ); tree [ t ]. add = -1 ; return ; } void update ( ll t , ll l , ll r , ll x ) { if ( l == tree [ t ]. l && r == tree [ t ]. r ) { tree [ t ]. add = max ( tree [ t ]. add , x ); tree [ t ]. min1 = max ( tree [ t ]. min1 , x ); return ; } push_down ( t ); ll mid = ( tree [ t ]. l + tree [ t ]. r ) / 2 ; if ( r <= mid ) update ( 2 * t , l , r , x ); else if ( l > mid ) update ( 2 * t + 1 , l , r , x ); else { update ( 2 * t , l , mid , x ); update ( 2 * t + 1 , mid + 1 , r , x ); } push_up ( t ); return ; } void update ( ll t , ll pos ) { if ( tree [ t ]. l == tree [ t ]. r ) { tree [ t ]. min1 = 1e9 ; return ; } push_down ( t ); ll mid = ( tree [ t ]. l + tree [ t ]. r ) / 2 ; if ( pos <= mid ) update ( 2 * t , pos ); if ( pos > mid ) update ( 2 * t + 1 , pos ); push_up ( t ); return ; } node query ( ll t , ll l , ll r ) { if ( tree [ t ]. l == l && tree [ t ]. r == r ) { return tree [ t ]; } push_down ( t ); ll mid = ( tree [ t ]. l + tree [ t ]. r ) / 2 ; if ( r <= mid ) return query ( 2 * t , l , r ); else if ( mid < l ) return query ( 2 * t + 1 , l , r ); else { node tree1 = query ( 2 * t , l , mid ); node tree2 = query ( 2 * t + 1 , mid + 1 , r ); if ( tree1 . min1 < tree2 . min1 ) return tree1 ; else return tree2 ; } } int main () { scanf ( \"%lld%lld\" , & n , & q ); build ( 1 , 1 , n ); for ( ll i = 1 ; i <= q ; i ++ ) { ll l , r , x ; scanf ( \"%lld%lld%lld\" , & l , & r , & x ); l ++ , r ++ , x ++ ; update ( 1 , l , r , x ); v [ x ]. push_back ({ l , r }); } ll flag = 1 ; for ( ll x = 1 ; x <= n && flag ; x ++ ) { ll l = 1 , r = n ; for ( int i = 0 ; i < v [ x ]. size (); i ++ ) { l = max ( l , v [ x ][ i ]. l ); r = min ( r , v [ x ][ i ]. r ); } if ( l > r ) ///\u4e00\u4e2a\u6700\u5c0f\u503c\u5bf9\u5e94\u591a\u4e2a\u533a\u95f4\u7684\u60c5\u51b5 { flag = 0 ; break ; } node ans = query ( 1 , l , r ); if ( ans . min1 > x ) { flag = 0 ; break ; } ll pos = ans . pos ; num [ pos ] = x -1 ; update ( 1 , pos ); } if ( ! flag ) { for ( ll i = 1 ; i <= n ; i ++ ) { printf ( \"-1 \" ); } printf ( \" \\n \" ); } else { for ( ll i = 1 ; i <= n ; i ++ ) { printf ( \"%d \" , num [ i ]); } printf ( \" \\n \" ); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u8def\u5f84\u53ef\u4ee5\u62fc\u51d1\u6210\u4e00\u4e2a\u957f\u65b9\u5f62\uff0c\u53ea\u9700\u8981\u66b4\u529b\u627e\u5230\u8fd9\u4e2a\u957f\u65b9\u5f62\u5373\u53ef\uff0c\u6ce8\u610f\u5982\u679c\u4e24\u4e2a\u70b9\u5728\u540c\u4e00\u6761\u76f4\u7ebf\u4e0a\u5219\u9700\u8981\u5c06\u4e24\u4e2a\u70b9\u9519\u5f00\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"#include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; int x1 , x2 , y1 , y2 ; int px , py , dis = 0 ; int judge1 ( int x , int y ) { int dis1 = abs ( x1 - x ) + abs ( y1 - y ); if ( dis1 > dis ) px = x , py = y , dis = dis1 ; } int main () { scanf ( \"%d%d%d%d\" , & x1 , & y1 , & x2 , & y2 ); if ( x1 == x2 ) x1 ++ ; if ( y1 == y2 ) y1 ++ ; judge1 ( x2 + 1 , y2 + 1 ); judge1 ( x2 + 1 , y2 ); judge1 ( x2 + 1 , y2 -1 ); judge1 ( x2 , y2 + 1 ); judge1 ( x2 , y2 -1 ); judge1 ( x2 -1 , y2 + 1 ); judge1 ( x2 -1 , y2 ); judge1 ( x2 -1 , y2 -1 ); printf ( \"%d \\n \" , dis * 2 ); }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u6839\u636e\u9898\u610f\u76f4\u63a5\u6807\u8bb0\u6a21\u62df\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"#include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; char a [ 2000 ] = { 0 }; map < char , int > s ; map < int , int > k ; char b [ 2000 ][ 2000 ] = { 0 }; map < char , int > mp1 ; map < char , int > mp ; int main () { int n ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , a + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] == '*' ) k [ i ] = 1 ; else s [ a [ i ]] = 1 ; } int m ; scanf ( \"%d\" , & m ); int sum = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%s\" , b [ ++ sum ] + 1 ); int flag = 1 ; for ( int j = 1 ; j <= n && flag ; j ++ ) { if ( k [ j ] && s [ b [ sum ][ j ]]) flag = 0 ; else if ( ! k [ j ] && b [ sum ][ j ] != a [ j ]) flag = 0 ; } if ( ! flag ) sum -- ; } for ( int i = 1 ; i <= sum ; i ++ ) { mp . clear (); for ( int j = 1 ; j <= n ; j ++ ) { if ( k [ j ]) { if ( ! mp [ b [ i ][ j ]]) { mp [ b [ i ][ j ]] = 1 ; mp1 [ b [ i ][ j ]] ++ ; } } } } int ans = 0 ; for ( char i = 'a' ; i <= 'z' ; i ++ ) { if ( mp1 [ i ] == sum ) ans ++ ; } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"\u5c06u\u66ff\u6362\u4e3aoo\uff0ckh\u66ff\u6362\u4e3ah\uff0c\u7136\u540e\u627e\u76f8\u540c\u7684\u5b57\u7b26\u4e32\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"#include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; char a [ 500 ][ 500 ] = { 0 }; int ans [ 500 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , a [ i ] + 1 ); } for ( int i = 1 ; i <= n ; i ++ ) { stack < char > s ; for ( int j = 1 ; a [ i ][ j ]; j ++ ) { if ( a [ i ][ j ] == 'u' ) { s . push ( 'o' ); s . push ( 'o' ); } else if ( a [ i ][ j ] == 'h' ) { while ( ! s . empty () && s . top () == 'k' ) s . pop (); s . push ( 'h' ); } else { s . push ( a [ i ][ j ]); } } int sum = 0 ; while ( ! s . empty ()) { a [ i ][ ++ sum ] = s . top (); s . pop (); } a [ i ][ ++ sum ] = '\\0' ; } int ans1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ans [ i ]) continue ; for ( int j = i + 1 ; j <= n ; j ++ ) { if ( strcmp ( a [ i ] + 1 , a [ j ] + 1 ) == 0 ) { ans [ j ] = 1 ; ans1 ++ ; } } } cout << n - ans1 << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"\u627e\u6700\u5927\u76f8\u540c\u957f\u5ea6\u7684\u56de\u6587\u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u53d1\u73b0\u6784\u9020 abcba \u8fd9\u79cd\u5b57\u7b26\u4e32\uff08\u4e24\u8fb9\u4e3a\u80fd\u591f\u5339\u914d\u7684\u5b57\u6bcd\uff0c\u4e2d\u95f4\u4e3a\u4e0d\u80fd\u5339\u914d\u7684\uff09\u80fd\u591f\u6700\u5c0f\u7a0b\u5ea6\u7684\u51cf\u5c11\u5757\u6570\uff0c\u63d0\u9ad8\u957f\u5ea6\uff0c\u7528\u5806\u6808\u6765\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_10","text":"#include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; char a [ 400500 ] = { 0 }; map < char , int > mp ; stack < char > s1 , s2 ; queue < char > que2 ; int main () { int n ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , a + 1 ); for ( int i = 1 ; i <= n ; i ++ ) mp [ a [ i ]] ++ ; for ( char i = 'a' ; i <= 'z' ; i ++ ) { if ( mp [ i ] % 2 == 1 ) que2 . push ( i ); for ( int j = 1 ; j <= mp [ i ] / 2 ; j ++ ) { s1 . push ( i ); s2 . push ( i ); } } for ( char i = '0' ; i <= '9' ; i ++ ) { if ( mp [ i ] % 2 == 1 ) que2 . push ( i ); for ( int j = 1 ; j <= mp [ i ] / 2 ; j ++ ) { s1 . push ( i ); s2 . push ( i ); } } for ( char i = 'A' ; i <= 'Z' ; i ++ ) { if ( mp [ i ] % 2 == 1 ) que2 . push ( i ); for ( int j = 1 ; j <= mp [ i ] / 2 ; j ++ ) { s1 . push ( i ); s2 . push ( i ); } } if ( que2 . size () == 0 ) { printf ( \"%d \\n \" , 1 ); stack < char > s ; while ( ! s1 . empty ()) s . push ( s1 . top ()), s1 . pop (); while ( ! s . empty ()) printf ( \"%c\" , s . top ()), s . pop (); while ( ! s2 . empty ()) printf ( \"%c\" , s2 . top ()), s2 . pop (); } else { while ( s1 . size () % que2 . size () != 0 ) { que2 . push ( s1 . top ()); s1 . pop (); que2 . push ( s2 . top ()); s2 . pop (); } printf ( \"%d \\n \" , que2 . size ()); int size1 = s1 . size () / que2 . size (); while ( ! que2 . empty ()) { stack < char > s ; for ( int i = 0 ; i < size1 ; i ++ ) s . push ( s1 . top ()), s1 . pop (); while ( ! s . empty ()) printf ( \"%c\" , s . top ()), s . pop (); printf ( \"%c\" , que2 . front ()), que2 . pop (); for ( int i = 0 ; i < size1 ; i ++ ) printf ( \"%c\" , s2 . top ()), s2 . pop (); printf ( \" \" ); } } }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_11","text":"\u4e8c\u5206\u6700\u5927\u5dee\u503c\uff0c\u7136\u540e\u7528dp\u6765\u8fdb\u884ccheck()","title":"\u9898\u89e3"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_12","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 300500 ] = { 0 }; int dp [ 300500 ] = { 0 }; int n , m ; int check ( ll k ) { for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 1 ; int last = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { while ( a [ i ] - a [ last ] > k ) last ++ ; for ( int j = last ; j + m <= i + 1 ; j ++ ) { if ( dp [ j -1 ]) { dp [ i ] = 1 ; break ; } else { last ++ ; } } } return dp [ n ]; } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); sort ( a + 1 , a + n + 1 ); ll l = 0 , r = 2e9 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( check ( mid )) r = mid ; else l = mid + 1 ; } cout << l << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/","text":"\u4e2d\u56fd\u77f3\u6cb9\u5927\u5b66\u4e13\u7528\u8bfe\u8868 \u00b6 \u7efc\u8ff0 \u00b6 \u4ee3\u7801\u5206\u4e3a\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u7aef\u4e24\u90e8\u5206\uff0c\u5ba2\u6237\u7aef\u4e3aJava\u5f00\u53d1\u7684\u5b89\u5353app\uff0c\u9879\u76ee\u5730\u5740\u4e3ahttps://github.com/WCX1024979076/upc_course_schedule\uff1b\u670d\u52a1\u7aef\u4e3apython\u5f00\u53d1\u7684qq\u673a\u5668\u4eba\uff0c\u9879\u76ee\u5730\u5740\u4e3ahttps://github.com/WCX1024979076/upc_course_schedule_service \u5ba2\u6237\u7aef\u4ee3\u7801\u6ce8\u89e3 \u00b6 \u4ee3\u7801\u7ed3\u6784\u56fe \u00b6 \u53c2\u8003\u4e8e\uff1a \u00b6 \u8bfe\u8868\u63d0\u9192app \u754c\u9762\u8df3\u8f6c \u8bfe\u8868ui U\u8bfe\u8868 \u670d\u52a1\u7aef\u4ee3\u7801\u6ce8\u89e3 \u00b6 \u670d\u52a1\u7aef\u4ee3\u7801\u7ed3\u6784\u56fe \u00b6 \u6ce8\uff1a\u8fd9\u91cc\u8fdb\u5c55\u793a\u8bfe\u8868\u63d0\u9192\u6a21\u5757\uff0c\u5176\u4f59\u8bf7\u53c2\u7167https://github.com/beiyuouo/plugins-for-nonebot2 \u53c2\u8003\u4e8e\uff1a \u00b6 https://github.com/beiyuouo/plugins-for-nonebot2","title":"2021-02-12-\u5b89\u5353\u8bfe\u8868\u5ba2\u6237\u7aef+\u670d\u52a1\u7aef\u6ce8\u89e3"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_1","text":"","title":"\u4e2d\u56fd\u77f3\u6cb9\u5927\u5b66\u4e13\u7528\u8bfe\u8868"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_2","text":"\u4ee3\u7801\u5206\u4e3a\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u7aef\u4e24\u90e8\u5206\uff0c\u5ba2\u6237\u7aef\u4e3aJava\u5f00\u53d1\u7684\u5b89\u5353app\uff0c\u9879\u76ee\u5730\u5740\u4e3ahttps://github.com/WCX1024979076/upc_course_schedule\uff1b\u670d\u52a1\u7aef\u4e3apython\u5f00\u53d1\u7684qq\u673a\u5668\u4eba\uff0c\u9879\u76ee\u5730\u5740\u4e3ahttps://github.com/WCX1024979076/upc_course_schedule_service","title":"\u7efc\u8ff0"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_3","text":"","title":"\u5ba2\u6237\u7aef\u4ee3\u7801\u6ce8\u89e3"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_4","text":"","title":"\u4ee3\u7801\u7ed3\u6784\u56fe"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_5","text":"\u8bfe\u8868\u63d0\u9192app \u754c\u9762\u8df3\u8f6c \u8bfe\u8868ui U\u8bfe\u8868","title":"\u53c2\u8003\u4e8e\uff1a"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_6","text":"","title":"\u670d\u52a1\u7aef\u4ee3\u7801\u6ce8\u89e3"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_7","text":"\u6ce8\uff1a\u8fd9\u91cc\u8fdb\u5c55\u793a\u8bfe\u8868\u63d0\u9192\u6a21\u5757\uff0c\u5176\u4f59\u8bf7\u53c2\u7167https://github.com/beiyuouo/plugins-for-nonebot2","title":"\u670d\u52a1\u7aef\u4ee3\u7801\u7ed3\u6784\u56fe"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_8","text":"https://github.com/beiyuouo/plugins-for-nonebot2","title":"\u53c2\u8003\u4e8e\uff1a"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"A\u9898 \u00b6 \u9898\u89e3 \u00b6 \u7ed9\u9664\u6307\u5b9a\u4e0b\u6807\u4ee5\u5916\u7684\u6570\u505a\u52a0\u6cd5\uff0c\u76f8\u5f53\u4e8e\u7ed9\u8fd9\u4e2a\u6570\u505a\u51cf\u6cd5\uff0c\u6240\u4ee5\u5c06\u8fd9\u4e9b\u6570\u5168\u53d8\u4e3a0\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); printf ( \"%d \\n \" , n ); for ( int i = 1 ; i <= n ; i ++ ) printf ( \"%d \" , i ); printf ( \" \\n \" ); } return 0 ; } B\u9898 \u00b6 \u9898\u89e3 \u00b6 \u6539\u53d8\u76f8\u90bb\u4e24\u4e2a\u6570\u7684\u6b63\u8d1f\u53f7\uff0c\u6c42\u6c42\u548c\u540e\u7684\u6700\u5927\u503c\uff0c\u53ef\u4ee5\u53d1\u73b0\uff0c\u5982\u679c\u6709\u5076\u6570\u4e2a\u8d1f\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u5168\u90e8\u8f6c\u4e3a\u6b63\u6570\uff0c\u5982\u679c\u6709\u5947\u6570\u4e2a\u8d1f\u6570\uff0c\u5219\u4e00\u5b9a\u4f1a\u6709\u4e00\u4e2a\u8d1f\u6570\uff0c\u5c06\u8fd9\u4e2a\u8d1f\u6570\u63a7\u5236\u4e3a\u6700\u5c0f\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 30 ][ 30 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); int sum = 0 , min1 = 99999999 , ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]), ans += ( int ) abs ( a [ i ][ j ]); if ( a [ i ][ j ] < 0 ) sum ++ ; min1 = min ( min1 ,( int ) fabs ( a [ i ][ j ])); } } if ( sum % 2 == 0 ) printf ( \"%d \\n \" , ans ); else { ans -= 2 * min1 ; printf ( \"%d \\n \" , ans ); } } return 0 ; } C\u9898 \u00b6 \u9898\u89e3 \u00b6 \u53ef\u4ee5\u53d1\u73b0\u5982\u679c\u539f\u6570\u7ec4\u4e2d\u6709\u5927\u4e8eW/2\u4e14\u5c0f\u4e8eW\u7684\u6570\u65f6\u53ef\u4ee5\u76f4\u63a5\u5c06\u5176\u8f93\u51fa\uff0c\u53cd\u4e4b\u5219\u6392\u5e8f\u540e\u4ece\u5c0f\u5230\u5927\u76f8\u52a0\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll n , val ; }; node a [ 200500 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); ll mid = m / 2 ; if ( m % 2 != 0 ) mid ++ ; ll flag = -1 ; for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]. val ); a [ i ]. n = i ; if ( a [ i ]. val >= mid && a [ i ]. val <= m ) flag = i ; } if ( flag != -1 ) { printf ( \"1 \\n %lld \\n \" , flag ); continue ; } sort ( a + 1 , a + n + 1 ,[]( node a , node b ){ return a . val < b . val ;}); ll sum = 0 ; flag = -1 ; for ( ll i = 1 ; i <= n ; i ++ ) { sum += a [ i ]. val ; if ( sum >= mid && sum <= m ) { flag = i ; break ; } if ( sum > m ) break ; } if ( flag != -1 ) { printf ( \"%lld \\n \" , flag ); for ( ll i = 1 ; i <= flag ; i ++ ) { printf ( \"%lld \" , a [ i ]. n ); } printf ( \" \\n \" ); } else { printf ( \"-1 \\n \" ); } } return 0 ; } D\u9898 \u00b6 \u9898\u89e3 \u00b6 \u52a8\u6001\u89c4\u5212\uff0cdp[i][j]\u4ee3\u8868\u6700\u540e\u4e00\u4e2a\u5b57\u6bcd\u4e3aa[i]\u548cb[j]\u65f6\u7684\u6700\u5927\u503c\uff0c\u5219\u53ef\u4ee5\u5f97\u5230\u4ee5\u4e0b\u9012\u63a8\u516c\u5f0f if a[i]==b[j] : \u200b dp[i][j]=max(dp[i-1][j-1]+2,dp[i][j]) \\\\\u76f8\u540c\u65f6LSA\u52a01\uff0c\u540c\u65f6\u4e24\u4e2a\u4e32\u7684\u957f\u5ea6\u589e\u52a01 else : \u200b dp[i][j]=max(dp[i][j-1]-1,dp[i-1][j]-1) \\\\\u4e0d\u540c\u65f6\u53ea\u80fd\u7531\u4e24\u8fb9\u8f6c\u79fb\u8fc7\u6765\uff0c\u5e76\u4e14\u957f\u5ea6\u52a01 \u5176\u4e2ddp[i][j]\u6700\u5c0f\u4e3a0\uff0c\u6700\u540e\u53d6\u6700\u5927\u503c\u5373\u4e3a\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int dp [ 5050 ][ 5050 ] = { 0 }; char a [ 5050 ] = { 0 }; char b [ 5050 ] = { 0 }; int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); scanf ( \"%s%s\" , a + 1 , b + 1 ); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ] == b [ j ]) dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i -1 ][ j -1 ] + 2 ); else dp [ i ][ j ] = max ( dp [ i ][ j -1 ], dp [ i -1 ][ j ]) -1 ; dp [ i ][ j ] = max ( dp [ i ][ j ], 0 ); } } int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { max1 = max ( max1 , dp [ i ][ j ]); } } printf ( \"%d \\n \" , max1 ); return 0 ; } H\u9898 \u00b6 \u9898\u89e3 \u00b6 \u5947\u5076\u77e9\u9635\uff08\u6bd4\u8d5b\u65f6\u5dee\u4e00\u70b9\u60f3\u51fa\uff0c\u4f46\u662f\u8fd8\u5dee\u4e00\u70b9\u70b9\uff0c\u989d\uff09 \u53ef\u4ee5\u53d1\u73b0\u5982\u679c\u63a7\u5236\u6807\u8bb0\u7684\u70b9\u4e0e\u5468\u56f4\u7684\u70b9\u6570\u503c\u4e0d\u540c\u65f6\u5373\u53ef\u6ee1\u8db3\u9898\u76ee\u7684\u8981\u6c42\uff08\u6bcf\u5bf9\u76f8\u90bb\u7684\u70b9\u6570\u503c\u5404\u4e0d\u76f8\u540c\uff09\u3002 \u5bb9\u6613\u53d1\u73b0\u8fd9\u4e9b\u6807\u6ce8\u7684\u70b9\u6a2a\u7eb5\u5750\u6807\u4e4b\u548c\u5747\u4e3a\u5076\u6570\uff0c\u5176\u4f59\u672a\u6807\u6ce8\u7684\u70b9\u548c\u5747\u4e3a\u5947\u6570\u3002 \u8fd9\u662f\u6211\u4eec\u53ea\u9700\u8981\u63a7\u5236\u6807\u6ce8\u7684\u70b9\u6240\u5bf9\u5e94\u7684\u6570\u503c\u5747\u4e3a\u5076\u6570\uff0c\u672a\u6807\u8bb0\u70b9\u7684\u6570\u503c\u5747\u4e3a\u5947\u6570\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5b9e\u73b0\u5404\u4e0d\u76f8\u540c\u4e86\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 200 ][ 200 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]); } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if (( i + j ) % 2 != a [ i ][ j ] % 2 ) a [ i ][ j ] ++ ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { printf ( \"%d \" , a [ i ][ j ]); } printf ( \" \\n \" ); } } return 0 ; }","title":"2021-02-16-2\u670816\u65e5\u9898\u89e3"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#a","text":"","title":"A\u9898"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u7ed9\u9664\u6307\u5b9a\u4e0b\u6807\u4ee5\u5916\u7684\u6570\u505a\u52a0\u6cd5\uff0c\u76f8\u5f53\u4e8e\u7ed9\u8fd9\u4e2a\u6570\u505a\u51cf\u6cd5\uff0c\u6240\u4ee5\u5c06\u8fd9\u4e9b\u6570\u5168\u53d8\u4e3a0\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); printf ( \"%d \\n \" , n ); for ( int i = 1 ; i <= n ; i ++ ) printf ( \"%d \" , i ); printf ( \" \\n \" ); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#b","text":"","title":"B\u9898"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u6539\u53d8\u76f8\u90bb\u4e24\u4e2a\u6570\u7684\u6b63\u8d1f\u53f7\uff0c\u6c42\u6c42\u548c\u540e\u7684\u6700\u5927\u503c\uff0c\u53ef\u4ee5\u53d1\u73b0\uff0c\u5982\u679c\u6709\u5076\u6570\u4e2a\u8d1f\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u5168\u90e8\u8f6c\u4e3a\u6b63\u6570\uff0c\u5982\u679c\u6709\u5947\u6570\u4e2a\u8d1f\u6570\uff0c\u5219\u4e00\u5b9a\u4f1a\u6709\u4e00\u4e2a\u8d1f\u6570\uff0c\u5c06\u8fd9\u4e2a\u8d1f\u6570\u63a7\u5236\u4e3a\u6700\u5c0f\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 30 ][ 30 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); int sum = 0 , min1 = 99999999 , ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]), ans += ( int ) abs ( a [ i ][ j ]); if ( a [ i ][ j ] < 0 ) sum ++ ; min1 = min ( min1 ,( int ) fabs ( a [ i ][ j ])); } } if ( sum % 2 == 0 ) printf ( \"%d \\n \" , ans ); else { ans -= 2 * min1 ; printf ( \"%d \\n \" , ans ); } } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#c","text":"","title":"C\u9898"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u53ef\u4ee5\u53d1\u73b0\u5982\u679c\u539f\u6570\u7ec4\u4e2d\u6709\u5927\u4e8eW/2\u4e14\u5c0f\u4e8eW\u7684\u6570\u65f6\u53ef\u4ee5\u76f4\u63a5\u5c06\u5176\u8f93\u51fa\uff0c\u53cd\u4e4b\u5219\u6392\u5e8f\u540e\u4ece\u5c0f\u5230\u5927\u76f8\u52a0\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll n , val ; }; node a [ 200500 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); ll mid = m / 2 ; if ( m % 2 != 0 ) mid ++ ; ll flag = -1 ; for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]. val ); a [ i ]. n = i ; if ( a [ i ]. val >= mid && a [ i ]. val <= m ) flag = i ; } if ( flag != -1 ) { printf ( \"1 \\n %lld \\n \" , flag ); continue ; } sort ( a + 1 , a + n + 1 ,[]( node a , node b ){ return a . val < b . val ;}); ll sum = 0 ; flag = -1 ; for ( ll i = 1 ; i <= n ; i ++ ) { sum += a [ i ]. val ; if ( sum >= mid && sum <= m ) { flag = i ; break ; } if ( sum > m ) break ; } if ( flag != -1 ) { printf ( \"%lld \\n \" , flag ); for ( ll i = 1 ; i <= flag ; i ++ ) { printf ( \"%lld \" , a [ i ]. n ); } printf ( \" \\n \" ); } else { printf ( \"-1 \\n \" ); } } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#d","text":"","title":"D\u9898"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"\u52a8\u6001\u89c4\u5212\uff0cdp[i][j]\u4ee3\u8868\u6700\u540e\u4e00\u4e2a\u5b57\u6bcd\u4e3aa[i]\u548cb[j]\u65f6\u7684\u6700\u5927\u503c\uff0c\u5219\u53ef\u4ee5\u5f97\u5230\u4ee5\u4e0b\u9012\u63a8\u516c\u5f0f if a[i]==b[j] : \u200b dp[i][j]=max(dp[i-1][j-1]+2,dp[i][j]) \\\\\u76f8\u540c\u65f6LSA\u52a01\uff0c\u540c\u65f6\u4e24\u4e2a\u4e32\u7684\u957f\u5ea6\u589e\u52a01 else : \u200b dp[i][j]=max(dp[i][j-1]-1,dp[i-1][j]-1) \\\\\u4e0d\u540c\u65f6\u53ea\u80fd\u7531\u4e24\u8fb9\u8f6c\u79fb\u8fc7\u6765\uff0c\u5e76\u4e14\u957f\u5ea6\u52a01 \u5176\u4e2ddp[i][j]\u6700\u5c0f\u4e3a0\uff0c\u6700\u540e\u53d6\u6700\u5927\u503c\u5373\u4e3a\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int dp [ 5050 ][ 5050 ] = { 0 }; char a [ 5050 ] = { 0 }; char b [ 5050 ] = { 0 }; int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); scanf ( \"%s%s\" , a + 1 , b + 1 ); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ] == b [ j ]) dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i -1 ][ j -1 ] + 2 ); else dp [ i ][ j ] = max ( dp [ i ][ j -1 ], dp [ i -1 ][ j ]) -1 ; dp [ i ][ j ] = max ( dp [ i ][ j ], 0 ); } } int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { max1 = max ( max1 , dp [ i ][ j ]); } } printf ( \"%d \\n \" , max1 ); return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#h","text":"","title":"H\u9898"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"\u5947\u5076\u77e9\u9635\uff08\u6bd4\u8d5b\u65f6\u5dee\u4e00\u70b9\u60f3\u51fa\uff0c\u4f46\u662f\u8fd8\u5dee\u4e00\u70b9\u70b9\uff0c\u989d\uff09 \u53ef\u4ee5\u53d1\u73b0\u5982\u679c\u63a7\u5236\u6807\u8bb0\u7684\u70b9\u4e0e\u5468\u56f4\u7684\u70b9\u6570\u503c\u4e0d\u540c\u65f6\u5373\u53ef\u6ee1\u8db3\u9898\u76ee\u7684\u8981\u6c42\uff08\u6bcf\u5bf9\u76f8\u90bb\u7684\u70b9\u6570\u503c\u5404\u4e0d\u76f8\u540c\uff09\u3002 \u5bb9\u6613\u53d1\u73b0\u8fd9\u4e9b\u6807\u6ce8\u7684\u70b9\u6a2a\u7eb5\u5750\u6807\u4e4b\u548c\u5747\u4e3a\u5076\u6570\uff0c\u5176\u4f59\u672a\u6807\u6ce8\u7684\u70b9\u548c\u5747\u4e3a\u5947\u6570\u3002 \u8fd9\u662f\u6211\u4eec\u53ea\u9700\u8981\u63a7\u5236\u6807\u6ce8\u7684\u70b9\u6240\u5bf9\u5e94\u7684\u6570\u503c\u5747\u4e3a\u5076\u6570\uff0c\u672a\u6807\u8bb0\u70b9\u7684\u6570\u503c\u5747\u4e3a\u5947\u6570\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5b9e\u73b0\u5404\u4e0d\u76f8\u540c\u4e86\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_10","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 200 ][ 200 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]); } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if (( i + j ) % 2 != a [ i ][ j ] % 2 ) a [ i ][ j ] ++ ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { printf ( \"%d \" , a [ i ][ j ]); } printf ( \" \\n \" ); } } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"A\u9898 \u00b6 \u9898\u89e3 \u00b6 \u6570\u636e\u91cf\u6bd4\u8f83\u5c11\uff0c\u66b4\u529b\u505a\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int a [ 4 ][ 1000 ] = { 0 }; int p [ 2000 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ 1 ][ i ]); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ 2 ][ i ]); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ 3 ][ i ]); for ( int i = 1 ; i <= n ; i ++ ) { if ( i != n ) { for ( int j = 1 ; j <= 3 ; j ++ ) { if ( a [ j ][ i ] != p [ i -1 ]) { p [ i ] = a [ j ][ i ]; break ; } } } else { for ( int j = 1 ; j <= 3 ; j ++ ) { if ( a [ j ][ i ] != p [ i -1 ] && a [ j ][ i ] != p [ 1 ]) { p [ i ] = a [ j ][ i ]; break ; } } } } for ( int i = 1 ; i <= n ; i ++ ) printf ( \"%d \" , p [ i ]); printf ( \" \\n \" ); } return 0 ; } B\u9898 \u00b6 \u9898\u89e3 \u00b6 \u627e\u89c4\u5f8b\uff0c\u5bb9\u6613\u53d1\u73b0b\u6570\u7ec4\u7684\u6700\u5c11\u4e2a\u6570\u548ca\u6570\u7ec4\u4e2d\u6570\u5b57\u8df3\u8dc3\u7684\u6b21\u6570\u6709\u5173\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int a [ 1005 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , k , sum = 0 ; scanf ( \"%d%d\" , & n , & k ); a [ 0 ] = -1 ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); if ( a [ i ] != a [ i -1 ]) sum ++ ; } if ( sum <= k ) { printf ( \"1 \\n \" ); continue ; } else { sum -= k ; k -- ; if ( k == 0 ) { printf ( \"-1 \\n \" ); continue ; } else { int ans = sum / k ; ans ++ ; if ( sum % k != 0 ) ans ++ ; printf ( \"%d \\n \" , ans ); } } } return 0 ; } C\u9898 \u00b6 \u9898\u89e3 \u00b6 \u4e8c\u5206\u7b54\u6848\uff0c\u4e8c\u5206\u4e24\u8f86\u8f66\u6700\u7ec8\u76f8\u9047\u7684\u4f4d\u7f6e\uff0c\u8ba1\u7b97\u4e24\u8f66\u6240\u7528\u7684\u65f6\u95f4\u3002\u6ce8\u610f\u4e8c\u5206\u7684\u7cbe\u5ea6\uff01\uff01\uff01 \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; int n , k ; int a [ 100500 ] = { 0 }; int check ( double mid ) { double t1 = 0 , t2 = 0 ; int s1 = 1 , s2 = 1 , last1 = 1 , last2 = k + 1 ; for ( int i = 1 ; a [ i ] <= mid && i <= n ; i ++ ) { if ( a [ i ] <= mid ) { t1 += ( a [ i ] - last1 ) * 1.0 / s1 ; s1 ++ ; last1 = a [ i ]; } } if ( last1 <= mid ) { t1 += ( mid - last1 ) * 1.0 / s1 ; } for ( int i = n ; a [ i ] >= mid && i >= 1 ; i -- ) { if ( a [ i ] >= mid ) { t2 += ( last2 - a [ i ]) * 1.0 / s2 ; s2 ++ ; last2 = a [ i ]; } } if ( last2 >= mid ) { t2 += ( last2 - mid ) * 1.0 / s2 ; } if ( t1 > t2 ) return 1 ; else return 0 ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & k ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); a [ i ] ++ ; } double l = 1 , r = k + 1 ; while ( abs ( r - l ) > 0.00001 ) { double mid = ( l + r ) / 2 ; if ( check ( mid )) r = mid ; else l = mid + 0.000001 ; } double t = 0 ; int s1 = 1 , last1 = 1 ; for ( int i = 1 ; a [ i ] < l && i <= n ; i ++ ) { t += ( a [ i ] - last1 ) * 1.0 / s1 ; s1 ++ ; last1 = a [ i ]; } if ( last1 < l ) { t += ( l - last1 ) * 1.0 / s1 ; } printf ( \"%.15f \\n \" , t ); } return 0 ; } D\u9898 \u00b6 \u9898\u89e3 \u00b6 \u7531\u4e8ex\u7684\u8303\u56f4\u4e3a1e6\uff0c\u53ef\u4ee5 \u901a\u8fc7 \u679a\u4e3e\u5de6\u79fb\u7684\u6570\u91cf \u5e76 \u8ba1\u7b97\u4e0a\u79fb\u7684\u6570\u91cf \u6c42\u548c\u53d6\u6700\u5c0f \u6765\u786e\u5b9a\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll x , y ; }; node a [ 2050 ] = { 0 }; node b [ 2050 ] = { 0 }; ll ans [ 1005000 ] = { 0 }; int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld%lld\" , & a [ i ]. x , & a [ i ]. y ); for ( ll j = 1 ; j <= m ; j ++ ) scanf ( \"%lld%lld\" , & b [ j ]. x , & b [ j ]. y ); for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 1 ; j <= m ; j ++ ) { ll x = b [ j ]. x - a [ i ]. x ; ll y = b [ j ]. y - a [ i ]. y ; if ( x >= 0 && y >= 0 ) { ans [ x ] = max ( ans [ x ], y + 1 ); } } } ll min1 = 999999999 , max1 = -10000000 ; for ( ll i = 1000500 ; i >= 0 ; i -- ) { max1 = max ( max1 , ans [ i ]); ///ans\u6570\u7ec4\u80af\u5b9a\u662f\u4e0d\u51cf\u7684\uff0c\u679a\u4e3e\u8ddd\u79bb\u5373\u53ef\u3002 min1 = min ( min1 , max1 + i ); } cout << min1 << endl ; } I\u9898 \u00b6 \u9898\u89e3 \u00b6 \u7531\u4e8e\u64cd\u4f5c\u6b21\u6570\u4e0a\u9650\u4e3a3 * n * m\u6b21\uff0c\u6240\u4ee5\u53ef\u4ee5\u901a\u8fc7\u679a\u4e3e\u6bcf\u4e2a\u5c0f\u77e9\u9635\uff0c\u8ba9\u6bcf\u4e2a\u5c0f\u77e9\u9635\u53d8\u4e3a0\uff0c\u6700\u540e\u4fbf\u53ef\u4ee5\u8ba9\u6574\u4e2a\u77e9\u9635\u53d8\u4e3a0\u3002\u4f46\u662fJ\u9898\u8981\u6c42\u4e0a\u9650\u4e3an*m\u6b21\uff0c\u65e0\u6cd5\u901a\u8fc7\uff0c\u989d\u3002 \u53e6\uff1a\u4ee3\u7801\u5199\u5f97\u6bd4\u8f83\u6076\u5fc3\uff0c\u989d\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; int a [ 200 ][ 200 ] = { 0 }; int dx [ 5 ] = { 0 , 0 , 1 , 0 , 1 }; int dy [ 5 ] = { 0 , 0 , 0 , 1 , 1 }; struct node { int p [ 10 ]; }; vector < node > ans ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%1d\" , & a [ i ][ j ]); } } for ( int i = 1 ; i <= n -1 ; i ++ ) { for ( int j = 1 ; j <= m -1 ; j ++ ) { int sum = 0 ; for ( int k = 1 ; k <= 4 ; k ++ ) { int x = i + dx [ k ], y = j + dy [ k ]; if ( a [ x ][ y ] == 1 ) sum ++ ; } if ( sum == 3 ) { node z ; int id = 0 ; for ( int k = 1 ; k <= 4 ; k ++ ) { int x = i + dx [ k ], y = j + dy [ k ]; if ( a [ x ][ y ] == 1 ) z . p [ ++ id ] = x , z . p [ ++ id ] = y ; } ans . push_back ( z ); } else if ( sum == 4 ) { node z ; z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( sum == 2 ) { node z ; if ( a [ i + 1 ][ j ] == 1 && a [ i ][ j ] == 1 ) { z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i ][ j + 1 ] == 1 && a [ i ][ j ] == 1 ) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ] == 1 && a [ i ][ j + 1 ] == 1 ) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ] == 1 && a [ i + 1 ][ j ] == 1 ) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ] && a [ i ][ j ]) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i ][ j + 1 ] && a [ i + 1 ][ j ]) { z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } } else if ( sum == 1 ) { if ( a [ i ][ j ]) { node z ; z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j ]) { node z ; z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ]) { node z ; z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i ][ j + 1 ]) { node z ; z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } } for ( int k = 1 ; k <= 4 ; k ++ ) { int x = i + dx [ k ], y = j + dy [ k ]; a [ x ][ y ] = 0 ; } } } printf ( \"%d \\n \" , ans . size ()); for ( node i : ans ) { for ( int j = 1 ; j <= 6 ; j ++ ) { printf ( \"%d \" , i . p [ j ]); } printf ( \" \\n \" ); } ans . clear (); } return 0 ; }","title":"2021-02-19-2\u670819\u65e5\u9898\u89e3"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#a","text":"","title":"A\u9898"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u6570\u636e\u91cf\u6bd4\u8f83\u5c11\uff0c\u66b4\u529b\u505a\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int a [ 4 ][ 1000 ] = { 0 }; int p [ 2000 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ 1 ][ i ]); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ 2 ][ i ]); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ 3 ][ i ]); for ( int i = 1 ; i <= n ; i ++ ) { if ( i != n ) { for ( int j = 1 ; j <= 3 ; j ++ ) { if ( a [ j ][ i ] != p [ i -1 ]) { p [ i ] = a [ j ][ i ]; break ; } } } else { for ( int j = 1 ; j <= 3 ; j ++ ) { if ( a [ j ][ i ] != p [ i -1 ] && a [ j ][ i ] != p [ 1 ]) { p [ i ] = a [ j ][ i ]; break ; } } } } for ( int i = 1 ; i <= n ; i ++ ) printf ( \"%d \" , p [ i ]); printf ( \" \\n \" ); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#b","text":"","title":"B\u9898"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u627e\u89c4\u5f8b\uff0c\u5bb9\u6613\u53d1\u73b0b\u6570\u7ec4\u7684\u6700\u5c11\u4e2a\u6570\u548ca\u6570\u7ec4\u4e2d\u6570\u5b57\u8df3\u8dc3\u7684\u6b21\u6570\u6709\u5173\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int a [ 1005 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , k , sum = 0 ; scanf ( \"%d%d\" , & n , & k ); a [ 0 ] = -1 ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); if ( a [ i ] != a [ i -1 ]) sum ++ ; } if ( sum <= k ) { printf ( \"1 \\n \" ); continue ; } else { sum -= k ; k -- ; if ( k == 0 ) { printf ( \"-1 \\n \" ); continue ; } else { int ans = sum / k ; ans ++ ; if ( sum % k != 0 ) ans ++ ; printf ( \"%d \\n \" , ans ); } } } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#c","text":"","title":"C\u9898"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u4e8c\u5206\u7b54\u6848\uff0c\u4e8c\u5206\u4e24\u8f86\u8f66\u6700\u7ec8\u76f8\u9047\u7684\u4f4d\u7f6e\uff0c\u8ba1\u7b97\u4e24\u8f66\u6240\u7528\u7684\u65f6\u95f4\u3002\u6ce8\u610f\u4e8c\u5206\u7684\u7cbe\u5ea6\uff01\uff01\uff01","title":"\u9898\u89e3"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; int n , k ; int a [ 100500 ] = { 0 }; int check ( double mid ) { double t1 = 0 , t2 = 0 ; int s1 = 1 , s2 = 1 , last1 = 1 , last2 = k + 1 ; for ( int i = 1 ; a [ i ] <= mid && i <= n ; i ++ ) { if ( a [ i ] <= mid ) { t1 += ( a [ i ] - last1 ) * 1.0 / s1 ; s1 ++ ; last1 = a [ i ]; } } if ( last1 <= mid ) { t1 += ( mid - last1 ) * 1.0 / s1 ; } for ( int i = n ; a [ i ] >= mid && i >= 1 ; i -- ) { if ( a [ i ] >= mid ) { t2 += ( last2 - a [ i ]) * 1.0 / s2 ; s2 ++ ; last2 = a [ i ]; } } if ( last2 >= mid ) { t2 += ( last2 - mid ) * 1.0 / s2 ; } if ( t1 > t2 ) return 1 ; else return 0 ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & k ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); a [ i ] ++ ; } double l = 1 , r = k + 1 ; while ( abs ( r - l ) > 0.00001 ) { double mid = ( l + r ) / 2 ; if ( check ( mid )) r = mid ; else l = mid + 0.000001 ; } double t = 0 ; int s1 = 1 , last1 = 1 ; for ( int i = 1 ; a [ i ] < l && i <= n ; i ++ ) { t += ( a [ i ] - last1 ) * 1.0 / s1 ; s1 ++ ; last1 = a [ i ]; } if ( last1 < l ) { t += ( l - last1 ) * 1.0 / s1 ; } printf ( \"%.15f \\n \" , t ); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#d","text":"","title":"D\u9898"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"\u7531\u4e8ex\u7684\u8303\u56f4\u4e3a1e6\uff0c\u53ef\u4ee5 \u901a\u8fc7 \u679a\u4e3e\u5de6\u79fb\u7684\u6570\u91cf \u5e76 \u8ba1\u7b97\u4e0a\u79fb\u7684\u6570\u91cf \u6c42\u548c\u53d6\u6700\u5c0f \u6765\u786e\u5b9a\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll x , y ; }; node a [ 2050 ] = { 0 }; node b [ 2050 ] = { 0 }; ll ans [ 1005000 ] = { 0 }; int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld%lld\" , & a [ i ]. x , & a [ i ]. y ); for ( ll j = 1 ; j <= m ; j ++ ) scanf ( \"%lld%lld\" , & b [ j ]. x , & b [ j ]. y ); for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 1 ; j <= m ; j ++ ) { ll x = b [ j ]. x - a [ i ]. x ; ll y = b [ j ]. y - a [ i ]. y ; if ( x >= 0 && y >= 0 ) { ans [ x ] = max ( ans [ x ], y + 1 ); } } } ll min1 = 999999999 , max1 = -10000000 ; for ( ll i = 1000500 ; i >= 0 ; i -- ) { max1 = max ( max1 , ans [ i ]); ///ans\u6570\u7ec4\u80af\u5b9a\u662f\u4e0d\u51cf\u7684\uff0c\u679a\u4e3e\u8ddd\u79bb\u5373\u53ef\u3002 min1 = min ( min1 , max1 + i ); } cout << min1 << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#i","text":"","title":"I\u9898"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"\u7531\u4e8e\u64cd\u4f5c\u6b21\u6570\u4e0a\u9650\u4e3a3 * n * m\u6b21\uff0c\u6240\u4ee5\u53ef\u4ee5\u901a\u8fc7\u679a\u4e3e\u6bcf\u4e2a\u5c0f\u77e9\u9635\uff0c\u8ba9\u6bcf\u4e2a\u5c0f\u77e9\u9635\u53d8\u4e3a0\uff0c\u6700\u540e\u4fbf\u53ef\u4ee5\u8ba9\u6574\u4e2a\u77e9\u9635\u53d8\u4e3a0\u3002\u4f46\u662fJ\u9898\u8981\u6c42\u4e0a\u9650\u4e3an*m\u6b21\uff0c\u65e0\u6cd5\u901a\u8fc7\uff0c\u989d\u3002 \u53e6\uff1a\u4ee3\u7801\u5199\u5f97\u6bd4\u8f83\u6076\u5fc3\uff0c\u989d\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_10","text":"#include <bits/stdc++.h> using namespace std ; int a [ 200 ][ 200 ] = { 0 }; int dx [ 5 ] = { 0 , 0 , 1 , 0 , 1 }; int dy [ 5 ] = { 0 , 0 , 0 , 1 , 1 }; struct node { int p [ 10 ]; }; vector < node > ans ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%1d\" , & a [ i ][ j ]); } } for ( int i = 1 ; i <= n -1 ; i ++ ) { for ( int j = 1 ; j <= m -1 ; j ++ ) { int sum = 0 ; for ( int k = 1 ; k <= 4 ; k ++ ) { int x = i + dx [ k ], y = j + dy [ k ]; if ( a [ x ][ y ] == 1 ) sum ++ ; } if ( sum == 3 ) { node z ; int id = 0 ; for ( int k = 1 ; k <= 4 ; k ++ ) { int x = i + dx [ k ], y = j + dy [ k ]; if ( a [ x ][ y ] == 1 ) z . p [ ++ id ] = x , z . p [ ++ id ] = y ; } ans . push_back ( z ); } else if ( sum == 4 ) { node z ; z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( sum == 2 ) { node z ; if ( a [ i + 1 ][ j ] == 1 && a [ i ][ j ] == 1 ) { z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i ][ j + 1 ] == 1 && a [ i ][ j ] == 1 ) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ] == 1 && a [ i ][ j + 1 ] == 1 ) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ] == 1 && a [ i + 1 ][ j ] == 1 ) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ] && a [ i ][ j ]) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i ][ j + 1 ] && a [ i + 1 ][ j ]) { z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } } else if ( sum == 1 ) { if ( a [ i ][ j ]) { node z ; z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j ]) { node z ; z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ]) { node z ; z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i ][ j + 1 ]) { node z ; z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } } for ( int k = 1 ; k <= 4 ; k ++ ) { int x = i + dx [ k ], y = j + dy [ k ]; a [ x ][ y ] = 0 ; } } } printf ( \"%d \\n \" , ans . size ()); for ( node i : ans ) { for ( int j = 1 ; j <= 6 ; j ++ ) { printf ( \"%d \" , i . p [ j ]); } printf ( \" \\n \" ); } ans . clear (); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"\u95ee\u9898E \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2723&pid=4 \u7c7b\u4f3c\u95ee\u9898\uff1a https://www.luogu.com.cn/problem/P2145 \u9898\u76ee\u63cf\u8ff0 \u00b6 Playing games is fun. For programmers, however, playing games with programs is even more fun. Consider a simple single-user tabletop game as follows. Given a row of sticks, each of which is in one of the seven colors, red (R), green (G), blue (B), cyan (C), magenta (M), yellow (Y), and key (K), the goal of the game is to eliminate all the sticks by repeating the following rules. \u2022 Consecutive sticks with the same color can be eliminated if the size of them is not less than m . \u2022 The remaining sticks will move closer together. For the case where the row is BBBRRRRRRGGGB and m is 3, all the sticks can be successfully eliminated as the following steps: BBBRRRRRRGGGB BBBGGGB (By eliminating all red sticks) BBBB (By eliminating all green sticks) (By eliminating all blue sticks) For the same row of sticks with m = 4, however, it is no way to eliminate all the sticks. Given a row of n sticks and the value of m , your task is to determine if it is possible to eliminate all the sticks. \u8f93\u5165 \u00b6 Each test case is given as a string that is the row of sticks and an integer m . \u8f93\u51fa \u00b6 Output Yes if it is possible to eliminate all the sticks. Otherwise, output No. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 BBBRRRRRRGGGB 3 \u3010\u6837\u4f8b2\u3011 BBBRRRRRRGGGB 4 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 Yes \u3010\u6837\u4f8b2\u3011 No \u63d0\u793a \u00b6 \u2022 0 <n,m \u2264 500 \u9898\u89e3 \u00b6 \u9898\u610f\uff1a\u7ed9\u5b9a7\u79cd\u5b57\u7b26 \u6bcf\u6709\u4e00\u6bb5\u8fde\u7eed\u7684\u957f\u5ea6\u5927\u4e8em\u7684\u76f8\u540c\u5b57\u7b26\u5c31\u80fd\u6d88\u53bb \u95ee\u6700\u7ec8\u6574\u6bb5\u5b57\u7b26\u4e32\u80fd\u5426\u6d88\u53bb dp[i][j][k] \u4ee3\u8868 i\u5230j\u533a\u95f4 \u79cd\u7c7b\u4e3ak\u7684\u6570\u6700\u5927\u8fde\u7eed\u5b50\u4e32\u7684\u957f\u5ea6 dp[i][j][k]\u5168\u90e8\u521d\u59cb\u5316\u4e3a-1e9\uff0c\u4ee3\u8868\u6ca1\u6709\u4efb\u4f55\u8fde\u7eed\u5b50\u4e32\u3002 \u90a3\u4e48\u6bcf\u6b21\u533a\u95f4\u5408\u5e76\u7684\u65f6\u5019 dp[i][j][k]=max(dp[i][l][k]+dp[l+1][j][k],dp[i][j][k]) \u5982\u679c\u5f53\u524d\u7684\u533a\u95f4\u6bb5\u6709\u80fd\u591f\u5220\u9664\u7684\u6bb5\uff0c\u90a3\u4e48\u5176\u4ed6\u7684\u5b57\u7b26\u4e32\u7684\u5f53\u524d\u533a\u95f4\u6bb5\u7684\u6570\u7684\u975e\u6cd5\u72b6\u6001\u5c31\u53ef\u4ee5\u7f6e\u4e3a0\uff0c\u4fdd\u8bc1\u80fd\u628a\u65ad\u5f00\u7684\u5b57\u7b26\u4e32\u63a5\u8d77\u6765\u3002\uff08\u4ee3\u8868\u6d88\u9664\u76f8\u540c\u7684\u5143\u7d20\uff0c\u8be5\u4e32\u957f\u5ea6\u4e3a0\uff09 \u7ecf\u8fc7\u5220\u9664\u5408\u5e76\u6700\u540e\u5982\u679c\u5269\u4f59\u4e00\u4e2a\u957f\u5ea6\u5927\u4e8em\u7684\u5b50\u4e32\u5219\u8f93\u51fayes\uff0c\u53cd\u4e4b\u8f93\u51fano \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int dp [ 600 ][ 600 ][ 8 ] = { 0 }; ///dp[i][j][k] \u4ee3\u8868\u4ecei\u5230j\u503c\u4e3ak\u7684\u8fde\u7eed\u4e2a\u6570 map < char , int > mp ; char c [ 600 ] = { 0 }; int main () { int n , m ; scanf ( \"%s%d\" , c + 1 , & m ); n = strlen ( c + 1 ); if ( m == 1 ) { printf ( \"Yes \\n \" ); return 0 ; } mp [ 'R' ] = 1 ; mp [ 'G' ] = 2 ; mp [ 'B' ] = 3 ; mp [ 'C' ] = 4 ; mp [ 'M' ] = 5 ; mp [ 'Y' ] = 6 ; mp [ 'K' ] = 7 ; for ( int i = 0 ; i < n + 10 ; i ++ ) for ( int j = 0 ; j < n + 10 ; j ++ ) for ( int k = 0 ; k < 8 ; k ++ ) dp [ i ][ j ][ k ] = -1e9 ; for ( int i = 1 ; c [ i ]; i ++ ) dp [ i ][ i ][ mp [ c [ i ]]] = 1 ; for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 1 ; i + len -1 <= n ; i ++ ) { int j = i + len -1 ; int flag = 0 ; for ( int l = i ; l < j ; l ++ ) { for ( int k = 1 ; k <= 7 ; k ++ ) { dp [ i ][ j ][ k ] = max ( dp [ i ][ j ][ k ], dp [ i ][ l ][ k ] + dp [ l + 1 ][ j ][ k ]); if ( dp [ i ][ j ][ k ] >= m ) flag = 1 ; } } if ( flag ) { for ( int k = 1 ; k <= 7 ; k ++ ) { if ( dp [ i ][ j ][ k ] < 0 ) dp [ i ][ j ][ k ] = 0 ; } } } } for ( int k = 1 ; k <= 7 ; k ++ ) { if ( dp [ 1 ][ n ][ k ] >= m ) { printf ( \"Yes \\n \" ); return 0 ; } } printf ( \"No \\n \" ); return 0 ; } \u95ee\u9898 F \u00b6 \u95ee\u9898\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2723&pid=5 \u9898\u76ee\u63cf\u8ff0 \u00b6 A company ICPC (International Cable Protection Company) produces a cable protection tool that can be installed in a network switch to monitor whether all cable links connected to it are working properly. Because the protection tool would cause transmission delay, it is not suitable for installation on every switch. Usually network topology consists of two parts: a backbone and several subnets. The switches on the backbone are linked as a ring structure and each backbone switch is treated as a root of a subnet in which the switches are linked as a tree structure. We call such topology as unicyclic topology. Figure 2 shows an example of a unicyclic topology. Suppose there are n backbone switches and m subnet switches. The switches are numbered by integers from 0 to m + n \u2212 1. Backbone switches are numbered from 0 to n \u2212 1 in clockwise order and the subnet switches are numbered from n to n + m \u2212 1 where the index of each subnet switch is larger than the index of its parent in the rooted tree structure of the subnet it belongs. Figure 3 shows an example of switch numbering. Please write a program for ICPC to decide the minimum number of switches selected for installing cable protection tools that can monitor all the cable links. Figure 4 shows an optimum solution (circled by ellipses) for the given network. \u8f93\u5165 \u00b6 The first line of the input file contains two integers n and m , separated by a space, indicating the numbers of backbone switches and subnet switches respectively. Each of the next n+m lines consists of two integers, separated by a space, indicating the indices of the two end switches of a link. \u8f93\u51fa \u00b6 Output the minimum number of switches selected for installing cable protection tools that can monitor all the cable links. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 3 2 0 1 1 2 0 2 1 3 2 4 \u3010\u6837\u4f8b2\u3011 4 11 0 1 0 3 0 4 0 5 1 2 1 6 2 3 2 9 3 12 6 7 6 8 9 10 10 11 12 13 12 14 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 2 \u3010\u6837\u4f8b2\u3011 5 \u63d0\u793a \u00b6 \u2022 3 \u2264 n \u2264 100000 \u2022 1 \u2264 m \u2264 100000 \u9898\u89e3 \u00b6 \u6811\u4e0aDP\uff0c\u7531\u4e8e\u4e2d\u5fc3\u5904\u4e3a\u4e00\u4e2a\u73af\uff0c\u53ef\u4ee5\u53bb\u9664\u4e00\u6761\u8fb9\u4f7f\u5176\u53d8\u4e3a\u4e00\u68f5\u6811\uff0c\u7136\u540e\u901a\u8fc7DP\u6765\u8fdb\u884c\u6c42\u89e3\u7b54\u6848\u3002 \u7531\u4e8e\u53bb\u6389\u4e86\u4e00\u6761\u8fb9\uff0c\u5982\u679c\u662f\u8fd9\u6761\u8fb9\uff08\u5047\u8bbe\u8be5\u8fb9\u4e24\u7aef\u70b9\u4e3ax\u548cy\uff09\u80fd\u591f\u88ab\u8986\u76d6\uff0c\u5219\u5206\u4e3a\u4e24\u79cd\u60c5\u51b5\uff0cx\u70b9\u88ab\u9009\u62e9\u548cy\u70b9\u88ab\u9009\u62e9\uff0c\u4e24\u79cd\u60c5\u51b5\u53d6\u6700\u5c0f\u5373\u4e3a\u7b54\u6848\u3002 dp[i][0]\u4ee3\u8868\u8be5\u70b9\u88ab\u9009\u62e9\uff0cdp[i][i]\u4ee3\u8868\u8be5\u70b9\u4e0d\u88ab\u9009\u62e9\uff0c\u5219\u6709\u5982\u4e0b\u7684\u9012\u63a8\u516c\u5f0f dp[i][0]=min(dp[i][0],dp[i][1])+1,dp[i][1]=dp[i][0]+1 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int to , next ; }; node edge [ 400500 ] = { 0 }; int head [ 400500 ] = { 0 }; int flag = 0 , x , y , sum = 0 ; int dp [ 400500 ][ 2 ] = { 0 }; ///\u6811\u4e0aDP\uff0cdp[i][0]\u4ee3\u8868\u8be5\u70b9\u88ab\u9009\u62e9\uff0cdp[i][1]\u4ee3\u8868\u8be5\u70b9\u6ca1\u6709\u88ab\u9009\u62e9 void add ( int from , int to ) { edge [ ++ sum ]. next = head [ from ]; edge [ sum ]. to = to ; head [ from ] = sum ; } void dfs ( int now , int fa ) { dp [ now ][ 0 ] = dp [ now ][ 1 ] = 0 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { if ( edge [ i ]. to != fa ) { dfs ( edge [ i ]. to , now ); dp [ now ][ 0 ] += min ( dp [ edge [ i ]. to ][ 0 ], dp [ edge [ i ]. to ][ 1 ]); dp [ now ][ 1 ] += dp [ edge [ i ]. to ][ 0 ]; } } dp [ now ][ 0 ] ++ ; if ( now == y && flag == 2 ) dp [ now ][ 1 ] ++ ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n + m ; i ++ ) { int s , e ; scanf ( \"%d%d\" , & s , & e ); if ( ! flag && s < n && e < n ) ///\u5728\u4e2d\u5fc3\u73af\u4e0a\uff0c\u9009\u53d6\u4e00\u6761\u8fb9\u5c06\u5176\u65ad\u6389\uff0c\u4f7f\u5176\u53d8\u4e3a\u4e00\u68f5\u6811 { x = s , y = e , flag = 1 ; continue ; } add ( s , e ); add ( e , s ); } int ans = 999999999 ; dfs ( x , -1 ); ///\u4ee3\u8868x\u70b9\u88ab\u6807\u8bb0\uff0c\u90a3\u4e48x\u5230y\u8fd9\u6761\u8fb9\u4e00\u5b9a\u6ee1\u8db3\u6761\u4ef6 ans = min ( ans , dp [ x ][ 0 ]); flag = 2 ; dfs ( x , -1 ); ///\u4ee3\u8868y\u70b9\u88ab\u6807\u8bb0\uff0c\u90a3\u4e48x\u5230y\u8fd9\u6761\u8fb9\u4e00\u5b9a\u6ee1\u8db3\u6761\u4ef6 ans = min ( ans , min ( dp [ x ][ 0 ], dp [ x ][ 1 ])); printf ( \"%d \\n \" , ans ); }","title":"2021-02-20-2\u670820\u65e5\u9898\u89e3"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#e","text":"","title":"\u95ee\u9898E"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"http://icpc.upc.edu.cn/problem.php?cid=2723&pid=4 \u7c7b\u4f3c\u95ee\u9898\uff1a https://www.luogu.com.cn/problem/P2145","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"Playing games is fun. For programmers, however, playing games with programs is even more fun. Consider a simple single-user tabletop game as follows. Given a row of sticks, each of which is in one of the seven colors, red (R), green (G), blue (B), cyan (C), magenta (M), yellow (Y), and key (K), the goal of the game is to eliminate all the sticks by repeating the following rules. \u2022 Consecutive sticks with the same color can be eliminated if the size of them is not less than m . \u2022 The remaining sticks will move closer together. For the case where the row is BBBRRRRRRGGGB and m is 3, all the sticks can be successfully eliminated as the following steps: BBBRRRRRRGGGB BBBGGGB (By eliminating all red sticks) BBBB (By eliminating all green sticks) (By eliminating all blue sticks) For the same row of sticks with m = 4, however, it is no way to eliminate all the sticks. Given a row of n sticks and the value of m , your task is to determine if it is possible to eliminate all the sticks.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"Each test case is given as a string that is the row of sticks and an integer m .","title":"\u8f93\u5165"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"Output Yes if it is possible to eliminate all the sticks. Otherwise, output No.","title":"\u8f93\u51fa"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u3010\u6837\u4f8b1\u3011 BBBRRRRRRGGGB 3 \u3010\u6837\u4f8b2\u3011 BBBRRRRRRGGGB 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"\u3010\u6837\u4f8b1\u3011 Yes \u3010\u6837\u4f8b2\u3011 No","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"\u2022 0 <n,m \u2264 500","title":"\u63d0\u793a"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"\u9898\u610f\uff1a\u7ed9\u5b9a7\u79cd\u5b57\u7b26 \u6bcf\u6709\u4e00\u6bb5\u8fde\u7eed\u7684\u957f\u5ea6\u5927\u4e8em\u7684\u76f8\u540c\u5b57\u7b26\u5c31\u80fd\u6d88\u53bb \u95ee\u6700\u7ec8\u6574\u6bb5\u5b57\u7b26\u4e32\u80fd\u5426\u6d88\u53bb dp[i][j][k] \u4ee3\u8868 i\u5230j\u533a\u95f4 \u79cd\u7c7b\u4e3ak\u7684\u6570\u6700\u5927\u8fde\u7eed\u5b50\u4e32\u7684\u957f\u5ea6 dp[i][j][k]\u5168\u90e8\u521d\u59cb\u5316\u4e3a-1e9\uff0c\u4ee3\u8868\u6ca1\u6709\u4efb\u4f55\u8fde\u7eed\u5b50\u4e32\u3002 \u90a3\u4e48\u6bcf\u6b21\u533a\u95f4\u5408\u5e76\u7684\u65f6\u5019 dp[i][j][k]=max(dp[i][l][k]+dp[l+1][j][k],dp[i][j][k]) \u5982\u679c\u5f53\u524d\u7684\u533a\u95f4\u6bb5\u6709\u80fd\u591f\u5220\u9664\u7684\u6bb5\uff0c\u90a3\u4e48\u5176\u4ed6\u7684\u5b57\u7b26\u4e32\u7684\u5f53\u524d\u533a\u95f4\u6bb5\u7684\u6570\u7684\u975e\u6cd5\u72b6\u6001\u5c31\u53ef\u4ee5\u7f6e\u4e3a0\uff0c\u4fdd\u8bc1\u80fd\u628a\u65ad\u5f00\u7684\u5b57\u7b26\u4e32\u63a5\u8d77\u6765\u3002\uff08\u4ee3\u8868\u6d88\u9664\u76f8\u540c\u7684\u5143\u7d20\uff0c\u8be5\u4e32\u957f\u5ea6\u4e3a0\uff09 \u7ecf\u8fc7\u5220\u9664\u5408\u5e76\u6700\u540e\u5982\u679c\u5269\u4f59\u4e00\u4e2a\u957f\u5ea6\u5927\u4e8em\u7684\u5b50\u4e32\u5219\u8f93\u51fayes\uff0c\u53cd\u4e4b\u8f93\u51fano","title":"\u9898\u89e3"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int dp [ 600 ][ 600 ][ 8 ] = { 0 }; ///dp[i][j][k] \u4ee3\u8868\u4ecei\u5230j\u503c\u4e3ak\u7684\u8fde\u7eed\u4e2a\u6570 map < char , int > mp ; char c [ 600 ] = { 0 }; int main () { int n , m ; scanf ( \"%s%d\" , c + 1 , & m ); n = strlen ( c + 1 ); if ( m == 1 ) { printf ( \"Yes \\n \" ); return 0 ; } mp [ 'R' ] = 1 ; mp [ 'G' ] = 2 ; mp [ 'B' ] = 3 ; mp [ 'C' ] = 4 ; mp [ 'M' ] = 5 ; mp [ 'Y' ] = 6 ; mp [ 'K' ] = 7 ; for ( int i = 0 ; i < n + 10 ; i ++ ) for ( int j = 0 ; j < n + 10 ; j ++ ) for ( int k = 0 ; k < 8 ; k ++ ) dp [ i ][ j ][ k ] = -1e9 ; for ( int i = 1 ; c [ i ]; i ++ ) dp [ i ][ i ][ mp [ c [ i ]]] = 1 ; for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 1 ; i + len -1 <= n ; i ++ ) { int j = i + len -1 ; int flag = 0 ; for ( int l = i ; l < j ; l ++ ) { for ( int k = 1 ; k <= 7 ; k ++ ) { dp [ i ][ j ][ k ] = max ( dp [ i ][ j ][ k ], dp [ i ][ l ][ k ] + dp [ l + 1 ][ j ][ k ]); if ( dp [ i ][ j ][ k ] >= m ) flag = 1 ; } } if ( flag ) { for ( int k = 1 ; k <= 7 ; k ++ ) { if ( dp [ i ][ j ][ k ] < 0 ) dp [ i ][ j ][ k ] = 0 ; } } } } for ( int k = 1 ; k <= 7 ; k ++ ) { if ( dp [ 1 ][ n ][ k ] >= m ) { printf ( \"Yes \\n \" ); return 0 ; } } printf ( \"No \\n \" ); return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#f","text":"","title":"\u95ee\u9898 F"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_10","text":"http://icpc.upc.edu.cn/problem.php?cid=2723&pid=5","title":"\u95ee\u9898\u94fe\u63a5"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_11","text":"A company ICPC (International Cable Protection Company) produces a cable protection tool that can be installed in a network switch to monitor whether all cable links connected to it are working properly. Because the protection tool would cause transmission delay, it is not suitable for installation on every switch. Usually network topology consists of two parts: a backbone and several subnets. The switches on the backbone are linked as a ring structure and each backbone switch is treated as a root of a subnet in which the switches are linked as a tree structure. We call such topology as unicyclic topology. Figure 2 shows an example of a unicyclic topology. Suppose there are n backbone switches and m subnet switches. The switches are numbered by integers from 0 to m + n \u2212 1. Backbone switches are numbered from 0 to n \u2212 1 in clockwise order and the subnet switches are numbered from n to n + m \u2212 1 where the index of each subnet switch is larger than the index of its parent in the rooted tree structure of the subnet it belongs. Figure 3 shows an example of switch numbering. Please write a program for ICPC to decide the minimum number of switches selected for installing cable protection tools that can monitor all the cable links. Figure 4 shows an optimum solution (circled by ellipses) for the given network.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_12","text":"The first line of the input file contains two integers n and m , separated by a space, indicating the numbers of backbone switches and subnet switches respectively. Each of the next n+m lines consists of two integers, separated by a space, indicating the indices of the two end switches of a link.","title":"\u8f93\u5165"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_13","text":"Output the minimum number of switches selected for installing cable protection tools that can monitor all the cable links.","title":"\u8f93\u51fa"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_14","text":"\u3010\u6837\u4f8b1\u3011 3 2 0 1 1 2 0 2 1 3 2 4 \u3010\u6837\u4f8b2\u3011 4 11 0 1 0 3 0 4 0 5 1 2 1 6 2 3 2 9 3 12 6 7 6 8 9 10 10 11 12 13 12 14","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_15","text":"\u3010\u6837\u4f8b1\u3011 2 \u3010\u6837\u4f8b2\u3011 5","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_16","text":"\u2022 3 \u2264 n \u2264 100000 \u2022 1 \u2264 m \u2264 100000","title":"\u63d0\u793a"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_17","text":"\u6811\u4e0aDP\uff0c\u7531\u4e8e\u4e2d\u5fc3\u5904\u4e3a\u4e00\u4e2a\u73af\uff0c\u53ef\u4ee5\u53bb\u9664\u4e00\u6761\u8fb9\u4f7f\u5176\u53d8\u4e3a\u4e00\u68f5\u6811\uff0c\u7136\u540e\u901a\u8fc7DP\u6765\u8fdb\u884c\u6c42\u89e3\u7b54\u6848\u3002 \u7531\u4e8e\u53bb\u6389\u4e86\u4e00\u6761\u8fb9\uff0c\u5982\u679c\u662f\u8fd9\u6761\u8fb9\uff08\u5047\u8bbe\u8be5\u8fb9\u4e24\u7aef\u70b9\u4e3ax\u548cy\uff09\u80fd\u591f\u88ab\u8986\u76d6\uff0c\u5219\u5206\u4e3a\u4e24\u79cd\u60c5\u51b5\uff0cx\u70b9\u88ab\u9009\u62e9\u548cy\u70b9\u88ab\u9009\u62e9\uff0c\u4e24\u79cd\u60c5\u51b5\u53d6\u6700\u5c0f\u5373\u4e3a\u7b54\u6848\u3002 dp[i][0]\u4ee3\u8868\u8be5\u70b9\u88ab\u9009\u62e9\uff0cdp[i][i]\u4ee3\u8868\u8be5\u70b9\u4e0d\u88ab\u9009\u62e9\uff0c\u5219\u6709\u5982\u4e0b\u7684\u9012\u63a8\u516c\u5f0f dp[i][0]=min(dp[i][0],dp[i][1])+1,dp[i][1]=dp[i][0]+1","title":"\u9898\u89e3"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_18","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int to , next ; }; node edge [ 400500 ] = { 0 }; int head [ 400500 ] = { 0 }; int flag = 0 , x , y , sum = 0 ; int dp [ 400500 ][ 2 ] = { 0 }; ///\u6811\u4e0aDP\uff0cdp[i][0]\u4ee3\u8868\u8be5\u70b9\u88ab\u9009\u62e9\uff0cdp[i][1]\u4ee3\u8868\u8be5\u70b9\u6ca1\u6709\u88ab\u9009\u62e9 void add ( int from , int to ) { edge [ ++ sum ]. next = head [ from ]; edge [ sum ]. to = to ; head [ from ] = sum ; } void dfs ( int now , int fa ) { dp [ now ][ 0 ] = dp [ now ][ 1 ] = 0 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { if ( edge [ i ]. to != fa ) { dfs ( edge [ i ]. to , now ); dp [ now ][ 0 ] += min ( dp [ edge [ i ]. to ][ 0 ], dp [ edge [ i ]. to ][ 1 ]); dp [ now ][ 1 ] += dp [ edge [ i ]. to ][ 0 ]; } } dp [ now ][ 0 ] ++ ; if ( now == y && flag == 2 ) dp [ now ][ 1 ] ++ ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n + m ; i ++ ) { int s , e ; scanf ( \"%d%d\" , & s , & e ); if ( ! flag && s < n && e < n ) ///\u5728\u4e2d\u5fc3\u73af\u4e0a\uff0c\u9009\u53d6\u4e00\u6761\u8fb9\u5c06\u5176\u65ad\u6389\uff0c\u4f7f\u5176\u53d8\u4e3a\u4e00\u68f5\u6811 { x = s , y = e , flag = 1 ; continue ; } add ( s , e ); add ( e , s ); } int ans = 999999999 ; dfs ( x , -1 ); ///\u4ee3\u8868x\u70b9\u88ab\u6807\u8bb0\uff0c\u90a3\u4e48x\u5230y\u8fd9\u6761\u8fb9\u4e00\u5b9a\u6ee1\u8db3\u6761\u4ef6 ans = min ( ans , dp [ x ][ 0 ]); flag = 2 ; dfs ( x , -1 ); ///\u4ee3\u8868y\u70b9\u88ab\u6807\u8bb0\uff0c\u90a3\u4e48x\u5230y\u8fd9\u6761\u8fb9\u4e00\u5b9a\u6ee1\u8db3\u6761\u4ef6 ans = min ( ans , min ( dp [ x ][ 0 ], dp [ x ][ 1 ])); printf ( \"%d \\n \" , ans ); }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"A\u9898 \u00b6 \u9898\u89e3 \u00b6 \u6784\u9020\u7531n-1\u4e2a2\u548c\u4e00\u4e2a3\u6216\u8005n-2\u4e2a2\u548c\u4e24\u4e2a3\u7684\u6570\uff0c\u4f7f\u5176\u65e0\u6cd5\u88ab2\u548c3\u6574\u9664\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); if ( n == 1 ) printf ( \"-1 \\n \" ); else { int sum = 0 ; for ( int i = 1 ; i <= n -1 ; i ++ ) { if ( i != n -1 ) { sum += 2 ; sum %= 3 ; printf ( \"2\" ); } else { if ( sum == 0 ) printf ( \"23 \\n \" ); else if ( sum == 1 ) printf ( \"33 \\n \" ); else if ( sum == 2 ) printf ( \"23 \\n \" ); } } } } return 0 ; } B\u9898 \u00b6 \u9898\u89e3 \u00b6 \u6a21\u62df\uff0ca[1]\u4e00\u5b9a\u548cb[1]\u76f8\u540c\uff0cx[1]\u4e00\u5b9a\u4e3a0\uff0c\u7136\u540e\u6a21\u62df\u6c422~n\u4e2a\u6570\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int b [ 200500 ] = { 0 }; int a [ 200500 ] = { 0 }; int main () { ll sum = 0 ; int n , m ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & b [ i ]); } int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = b [ i ] + max1 ; max1 = max ( max1 , a [ i ]); } for ( int i = 1 ; i <= n ; i ++ ) { printf ( \"%d \" , a [ i ]); } return 0 ; } C\u9898 \u00b6 \u9898\u89e3 \u00b6 \u5bb9\u6613\u53d1\u73b0\u5982\u679c\u4f7f\u6c42\u548c\u6700\u5927\uff0c\u5219\u6bcf\u4e00\u5757\u5e94\u8be5\u5305\u542b\u4e00\u4e2a\u6700\u5927\u503c\uff0c\u627e\u51fa\u524dk\u4e2a\u6700\u5927\u503c\u6c42\u548c\u5373\u4e3a\u7b54\u6848\uff0c\u7136\u540e\u5bf9\u6bcf\u4e2a\u6700\u5927\u503c\u7684\u4e0b\u6807\u8fdb\u884c\u505a\u5dee\u6c42\u79ef\u5373\u4e3a\u7b2c\u4e8c\u4e2a\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const long long mod = 998244353 ; struct node { int x , p ; }; node a [ 200500 ] = { 0 }; int main () { int n , k ; scanf ( \"%d%d\" , & n , & k ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]. x ), a [ i ]. p = i ; sort ( a + 1 , a + n + 1 ,[]( node a , node b ){ if ( a . x != b . x ) return a . x > b . x ; else return a . p < b . p ;}); long long ans1 = 0 , ans2 = 1 ; vector < int > v ; for ( int i = 1 ; i <= k ; i ++ ) { ans1 += a [ i ]. x ; v . push_back ( a [ i ]. p ); } sort ( v . begin (), v . end (),[]( int a , int b ){ return a < b ;}); for ( int i = 1 ; i < v . size (); i ++ ) { ans2 = ans2 * ( v [ i ] - v [ i -1 ]); ans2 %= mod ; } printf ( \"%lld %lld \\n \" , ans1 , ans2 ); return 0 ; } D\u9898/E\u9898 \u00b6 \u9898\u89e3 \u00b6 \u53ef\u4ee5\u9884\u5904\u7406\u524d\u7f00\u548c\u540e\u7f00\u76f8\u540c\u7684\u90e8\u5206\uff0c\u7136\u540e\u5bf9\u5269\u4f59\u90e8\u5206\u8fdb\u884cmanacher\u7b97\u6cd5\uff0c\u6c42\u6700\u957f\u7684\u56de\u6587\u4e32\uff0c\u6ce8\uff1a\u8be5\u56de\u6587\u4e32\u5fc5\u987b\u4f4d\u4e8e\u5f00\u5934\u6216\u7ed3\u5c3e\u3002 \u53c2\u7167\u94fe\u63a5\uff1a https://www.luogu.com.cn/blog/xht37/solution-cf1326d2 https://zhuanlan.zhihu.com/p/137172524 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; char a [ 1005000 ] = { 0 }; char t [ 1005000 ] = { 0 }; int manacher ( char * c ) { int max_id = 0 , ans = 1 , id = 0 ; string str = \"$#\" ; for ( int i = 1 ; c [ i ]; i ++ ) str += c [ i ], str += \"#\" ; vector < int > p ; p . push_back ( 1 ); for ( int i = 1 ; i < ( int ) str . size (); i ++ ) { if ( max_id > i ) p . push_back ( min ( max_id - i , p [ 2 * id - i ])); else p . push_back ( 1 ); while ( i + p [ i ] < ( int ) str . size () && str [ i + p [ i ]] == str [ i - p [ i ]]) p [ i ] ++ ; if ( i == p [ i ]) ///i==p[i]\uff0c\u4ee3\u8868\u8be5\u56de\u6587\u4e32\u4f4d\u4e8e\u5f00\u5934 ans = max ( ans , p [ i ]); if ( i + p [ i ] > max_id ){ max_id = i + p [ i ], id = i ; } } return ans -1 ; } int main () { int time ; scanf ( \"%d\" , & time ); while ( time -- ) { scanf ( \"%s\" , a + 1 ); int n = strlen ( a + 1 ), sum = 1 ; while ( sum <= n && a [ sum ] == a [ n - sum + 1 ]) sum ++ ; if ( sum == n + 1 ) { printf ( \"%s \\n \" , a + 1 ); continue ; } int m = 0 ; for ( int i = sum ; i <= n - sum + 1 ; i ++ ) t [ ++ m ] = a [ i ]; t [ m + 1 ] = '\\0' ; int l_ans = manacher ( t ); reverse ( t + 1 , t + m + 1 ); int r_ans = manacher ( t ); reverse ( t + 1 , t + m + 1 ); if ( l_ans < r_ans ) reverse ( t + 1 , t + m + 1 ), swap ( l_ans , r_ans ); for ( int i = 1 ; i < sum ; i ++ ) printf ( \"%c\" , a [ i ]); for ( int i = 1 ; i <= l_ans ; i ++ ) printf ( \"%c\" , t [ i ]); for ( int i = sum -1 ; i >= 1 ; i -- ) printf ( \"%c\" , a [ i ]); printf ( \" \\n \" ); } return 0 ; } \u7ec4\u961f\u8bad\u7ec3\u8d5bA\u9898 Comic Binge \u00b6 \u9898\u89e3 \u00b6 \u7531\u4e8eA\u5fc5\u987b\u7b49B\u8bfb\u5b8c\u540e\u624d\u8bfb\uff0c\u90a3\u4e48\u4e00\u79cd\u53ef\u884c\u7684\u6761\u4ef6\u4fbf\u662fB\u628a\u6240\u6709\u7684\u4e66\u8bfb\u5b8c\u540eA\u518d\u53bb\u8bfb\u6240\u6709\u7684\u4e66\uff0c\u8fd9\u6837\u603b\u65f6\u957f\u662f\u6700\u5927\u7684\uff0c\u4e14A\u548cB\u7684\u91cd\u5408\u8bfb\u4e66\u65f6\u95f4\u4e3a0\u3002\u5982\u679c\u8981\u4f7f\u603b\u65f6\u95f4\u6700\u77ed\uff0c\u90a3\u4e48\u5e94\u5f53\u5c3d\u53ef\u80fd\u589e\u5927\u4e8c\u8005\u7684\u91cd\u5408\u8bfb\u4e66\u65f6\u95f4\uff0c\u52a8\u6001\u89c4\u5212\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const long long mod = 998244353 ; int dp [ 1050 ][ 10050 ] = { 0 }; ///dp[i][j]\u4ee3\u8868B\u5728\u65f6\u95f4j\u8bfb\u5b8c\u524di-1\u672c\u4e66\u4e8c\u8005\u6700\u5927\u91cd\u5408\u8bfb\u4e66\u65f6\u95f4 int sum_a [ 1050 ] = { 0 }; int a [ 1050 ] = { 0 }, b [ 1050 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]), sum_a [ i ] = sum_a [ i -1 ] + a [ i ]; for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & b [ i ]); int max_b = n * 10 ; ///B\u6700\u5927\u7684\u65f6\u95f4 for ( int i = 1 ; i <= n + 1 ; i ++ ) for ( int j = 0 ; j <= max_b ; j ++ ) dp [ i ][ j ] = -1 ; dp [ 1 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) { for ( int j = 0 ; j <= max_b ; j ++ ) { if ( dp [ i ][ j ] == -1 ) continue ; if ( i <= n && j + b [ i ] <= max_b ) { dp [ i + 1 ][ j + b [ i ]] = max ( dp [ i + 1 ][ j + b [ i ]], min ( dp [ i ][ j ] + b [ i ], sum_a [ i -1 ])); ///B\u8bfbi\u4e66\uff0cB\u8bfb\u5b8c\u524di\u672c\u4e66\u91cd\u5408\u65f6\u95f4\u6700\u5927\u503c //\u6ce8\u610f\u5e94\u5f53\u548csum_a[i-1]\u53d6\u6700\u5c0f\u503c\uff0c\u7531\u4e8eA\u843d\u540e\u4e8eB\u4e00\u672c\u4e66 } if ( i > 1 && i + 1 <= n && j + b [ i + 1 ] <= max_b ) ///B\u8bfbi+1\u4e66\uff0c\u4e0d\u8981\u5fd8\u8bb0i>1\u7684\u6761\u4ef6\uff0cB\u5fc5\u987b\u8bfb\u7b2c\u4e00\u672c\u4e66 dp [ i + 2 ][ j + b [ i + 1 ]] = max ( dp [ i + 2 ][ j + b [ i + 1 ]], min ( dp [ i ][ j ] + b [ i + 1 ], sum_a [ i ])); } } int min1 = 999999999 ; for ( int j = 0 ; j <= max_b ; j ++ ) { if ( dp [ n + 1 ][ j ] != -1 ) min1 = min ( min1 , j - dp [ n + 1 ][ j ] + sum_a [ n ]); } printf ( \"%d \\n \" , min1 ); return 0 ; } \u7ec4\u961f\u8bad\u7ec3\u8d5bC\u9898 Cul-De-Sac Parades \u00b6 \u9898\u89e3 \u00b6 \u6811\u4e0aDP\uff0c\u5bf9\u6bcf\u4e2a\u7236\u8282\u70b9\u7684\u7684\u8fb9\u8fdb\u884c\u679a\u4e3e\u9009\u62e9\uff0c\u662f\u5426\u4f7f\u7528\u8fd9\u4e2a\u8fb9\uff08\u5047\u8bbe\u4e3a\u8fb9A\uff09\uff0c\u5982\u679c\u4f7f\u7528\u8fd9\u6761\u8fb9A\uff0c\u5219\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9\uff0c\u627e\u51fa\u8fde\u63a5\u5b50\u8282\u70b9\u6240\u6709\u8fb9\u4e2d\u6743\u503c\u6700\u5927\u7684\u8fb9\uff0c\u5c06\u5176\u4e0e\u8fb9A\u8fdb\u884c\u8fde\u63a5\uff0c\u7ec4\u6210\u4e00\u6761\u901a\u8def\uff0c\u5176\u4f59\u5b50\u8282\u70b9\u4e0a\u7684\u8fb9\u8fdb\u884c\u4e24\u4e24\u5339\u914d\u7ec4\u6210\u901a\u8def\uff1b\u53cd\u4e4b\u5982\u679c\u4e0d\u4f7f\u7528\u8fd9\u6761\u8fb9A\uff0c\u5219\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9\uff0c\u8ba9\u5b50\u8282\u70b9\u7684\u8fb9\u8fdb\u884c\u4e24\u4e24\u5339\u914d\uff0c\u7ec4\u6210\u901a\u8def\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll to , val ; }; struct node1 { ll yes , no ; }; vector < node > v [ 100500 ]; vector < node > chr [ 100500 ]; ll dp [ 100500 ][ 2 ] = { 0 }; void dfs ( ll now , ll fa ) ///\u7528\u4e8e\u627e\u8fd9\u4e2a\u70b9\u7684\u5b50\u8282\u70b9 { for ( node i : v [ now ]) { if ( i . to == fa ) continue ; chr [ now ]. push_back ( i ); dfs ( i . to , now ); } } ll work ( ll now , ll has_path ) ///has_path\u4ee3\u8868\u662f\u5426\u4f7f\u7528\u8fd9\u6761\u8fb9 { if ( chr [ now ]. empty ()) return 0 ; if ( dp [ now ][ has_path ] != -1 ) return dp [ now ][ has_path ]; vector < node1 > data ; ll & ans = dp [ now ][ has_path ] = 0 ; for ( node i : chr [ now ]) { node1 data1 ; data1 . yes = work ( i . to , true ) + i . val ; //\u4f7f\u7528\u8fd9\u6761\u8fb9\uff0c\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9 data1 . no = work ( i . to , false ); ///\u4e0d\u4f7f\u7528\u8fd9\u6761\u8fb9\uff0c\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9 data . push_back ( data1 ); } sort ( data . begin (), data . end (),[]( node1 a , node1 b ){ return a . yes - a . no > b . yes - b . no ;}); for ( node1 i : data ) ans += i . no ; ///\u5148\u5bf9\u4e0d\u4f7f\u7528\u8fd9\u4e9b\u8fb9\u7684\u6743\u503c\u6c42\u548c if ( has_path ) ans += data [ 0 ]. yes - data [ 0 ]. no ; ///\u5982\u679c\u7236\u8282\u70b9\u4f7f\u7528\u8fd9\u6761\u8fb9\uff0c\u5219\u5e94\u5f53\u627e\u4e00\u6761\u6743\u503c\u6700\u5927\u7684\u8fb9\u4e0e\u4e4b\u8fde\u63a5 for ( ll i = has_path ; i + 1 < ( ll ) data . size (); i += 2 ) { ll yes = data [ i ]. yes + data [ i + 1 ]. yes ; ll no = data [ i ]. no + data [ i + 1 ]. no ; if ( yes < no ) break ; else { ans += yes - no ; ///\u4ee3\u8868\u4f7f\u7528\u8fd9\u4e24\u6761\u8fb9\u5e76\u7ec4\u6210\u4e00\u4e2a\u901a\u8def } } return ans ; } int main () { ll n , s , e , val ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n -1 ; i ++ ) { scanf ( \"%lld%lld%lld\" , & s , & e , & val ); v [ s ]. push_back ({ e , val }); v [ e ]. push_back ({ s , val }); } memset ( dp , -1 , sizeof ( dp )); dfs ( 1 , -1 ); ll ans = work ( 1 , false ); if ( chr [ 1 ]. size () == 1 ) ///1\u4e3a\u6839\u8282\u70b9\uff0c\u8fd9\u6761\u8fb9\u5fc5\u987b\u4f7f\u7528 ans = max ( ans , work ( 1 , true )); cout << ans << endl ; }","title":"2021-02-22-2\u670822\u65e5\u9898\u89e3"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#a","text":"","title":"A\u9898"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u6784\u9020\u7531n-1\u4e2a2\u548c\u4e00\u4e2a3\u6216\u8005n-2\u4e2a2\u548c\u4e24\u4e2a3\u7684\u6570\uff0c\u4f7f\u5176\u65e0\u6cd5\u88ab2\u548c3\u6574\u9664\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); if ( n == 1 ) printf ( \"-1 \\n \" ); else { int sum = 0 ; for ( int i = 1 ; i <= n -1 ; i ++ ) { if ( i != n -1 ) { sum += 2 ; sum %= 3 ; printf ( \"2\" ); } else { if ( sum == 0 ) printf ( \"23 \\n \" ); else if ( sum == 1 ) printf ( \"33 \\n \" ); else if ( sum == 2 ) printf ( \"23 \\n \" ); } } } } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#b","text":"","title":"B\u9898"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u6a21\u62df\uff0ca[1]\u4e00\u5b9a\u548cb[1]\u76f8\u540c\uff0cx[1]\u4e00\u5b9a\u4e3a0\uff0c\u7136\u540e\u6a21\u62df\u6c422~n\u4e2a\u6570\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int b [ 200500 ] = { 0 }; int a [ 200500 ] = { 0 }; int main () { ll sum = 0 ; int n , m ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & b [ i ]); } int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = b [ i ] + max1 ; max1 = max ( max1 , a [ i ]); } for ( int i = 1 ; i <= n ; i ++ ) { printf ( \"%d \" , a [ i ]); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#c","text":"","title":"C\u9898"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u5bb9\u6613\u53d1\u73b0\u5982\u679c\u4f7f\u6c42\u548c\u6700\u5927\uff0c\u5219\u6bcf\u4e00\u5757\u5e94\u8be5\u5305\u542b\u4e00\u4e2a\u6700\u5927\u503c\uff0c\u627e\u51fa\u524dk\u4e2a\u6700\u5927\u503c\u6c42\u548c\u5373\u4e3a\u7b54\u6848\uff0c\u7136\u540e\u5bf9\u6bcf\u4e2a\u6700\u5927\u503c\u7684\u4e0b\u6807\u8fdb\u884c\u505a\u5dee\u6c42\u79ef\u5373\u4e3a\u7b2c\u4e8c\u4e2a\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const long long mod = 998244353 ; struct node { int x , p ; }; node a [ 200500 ] = { 0 }; int main () { int n , k ; scanf ( \"%d%d\" , & n , & k ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]. x ), a [ i ]. p = i ; sort ( a + 1 , a + n + 1 ,[]( node a , node b ){ if ( a . x != b . x ) return a . x > b . x ; else return a . p < b . p ;}); long long ans1 = 0 , ans2 = 1 ; vector < int > v ; for ( int i = 1 ; i <= k ; i ++ ) { ans1 += a [ i ]. x ; v . push_back ( a [ i ]. p ); } sort ( v . begin (), v . end (),[]( int a , int b ){ return a < b ;}); for ( int i = 1 ; i < v . size (); i ++ ) { ans2 = ans2 * ( v [ i ] - v [ i -1 ]); ans2 %= mod ; } printf ( \"%lld %lld \\n \" , ans1 , ans2 ); return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#de","text":"","title":"D\u9898/E\u9898"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"\u53ef\u4ee5\u9884\u5904\u7406\u524d\u7f00\u548c\u540e\u7f00\u76f8\u540c\u7684\u90e8\u5206\uff0c\u7136\u540e\u5bf9\u5269\u4f59\u90e8\u5206\u8fdb\u884cmanacher\u7b97\u6cd5\uff0c\u6c42\u6700\u957f\u7684\u56de\u6587\u4e32\uff0c\u6ce8\uff1a\u8be5\u56de\u6587\u4e32\u5fc5\u987b\u4f4d\u4e8e\u5f00\u5934\u6216\u7ed3\u5c3e\u3002 \u53c2\u7167\u94fe\u63a5\uff1a https://www.luogu.com.cn/blog/xht37/solution-cf1326d2 https://zhuanlan.zhihu.com/p/137172524","title":"\u9898\u89e3"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; char a [ 1005000 ] = { 0 }; char t [ 1005000 ] = { 0 }; int manacher ( char * c ) { int max_id = 0 , ans = 1 , id = 0 ; string str = \"$#\" ; for ( int i = 1 ; c [ i ]; i ++ ) str += c [ i ], str += \"#\" ; vector < int > p ; p . push_back ( 1 ); for ( int i = 1 ; i < ( int ) str . size (); i ++ ) { if ( max_id > i ) p . push_back ( min ( max_id - i , p [ 2 * id - i ])); else p . push_back ( 1 ); while ( i + p [ i ] < ( int ) str . size () && str [ i + p [ i ]] == str [ i - p [ i ]]) p [ i ] ++ ; if ( i == p [ i ]) ///i==p[i]\uff0c\u4ee3\u8868\u8be5\u56de\u6587\u4e32\u4f4d\u4e8e\u5f00\u5934 ans = max ( ans , p [ i ]); if ( i + p [ i ] > max_id ){ max_id = i + p [ i ], id = i ; } } return ans -1 ; } int main () { int time ; scanf ( \"%d\" , & time ); while ( time -- ) { scanf ( \"%s\" , a + 1 ); int n = strlen ( a + 1 ), sum = 1 ; while ( sum <= n && a [ sum ] == a [ n - sum + 1 ]) sum ++ ; if ( sum == n + 1 ) { printf ( \"%s \\n \" , a + 1 ); continue ; } int m = 0 ; for ( int i = sum ; i <= n - sum + 1 ; i ++ ) t [ ++ m ] = a [ i ]; t [ m + 1 ] = '\\0' ; int l_ans = manacher ( t ); reverse ( t + 1 , t + m + 1 ); int r_ans = manacher ( t ); reverse ( t + 1 , t + m + 1 ); if ( l_ans < r_ans ) reverse ( t + 1 , t + m + 1 ), swap ( l_ans , r_ans ); for ( int i = 1 ; i < sum ; i ++ ) printf ( \"%c\" , a [ i ]); for ( int i = 1 ; i <= l_ans ; i ++ ) printf ( \"%c\" , t [ i ]); for ( int i = sum -1 ; i >= 1 ; i -- ) printf ( \"%c\" , a [ i ]); printf ( \" \\n \" ); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#a-comic-binge","text":"","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5bA\u9898 Comic Binge"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"\u7531\u4e8eA\u5fc5\u987b\u7b49B\u8bfb\u5b8c\u540e\u624d\u8bfb\uff0c\u90a3\u4e48\u4e00\u79cd\u53ef\u884c\u7684\u6761\u4ef6\u4fbf\u662fB\u628a\u6240\u6709\u7684\u4e66\u8bfb\u5b8c\u540eA\u518d\u53bb\u8bfb\u6240\u6709\u7684\u4e66\uff0c\u8fd9\u6837\u603b\u65f6\u957f\u662f\u6700\u5927\u7684\uff0c\u4e14A\u548cB\u7684\u91cd\u5408\u8bfb\u4e66\u65f6\u95f4\u4e3a0\u3002\u5982\u679c\u8981\u4f7f\u603b\u65f6\u95f4\u6700\u77ed\uff0c\u90a3\u4e48\u5e94\u5f53\u5c3d\u53ef\u80fd\u589e\u5927\u4e8c\u8005\u7684\u91cd\u5408\u8bfb\u4e66\u65f6\u95f4\uff0c\u52a8\u6001\u89c4\u5212\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_10","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const long long mod = 998244353 ; int dp [ 1050 ][ 10050 ] = { 0 }; ///dp[i][j]\u4ee3\u8868B\u5728\u65f6\u95f4j\u8bfb\u5b8c\u524di-1\u672c\u4e66\u4e8c\u8005\u6700\u5927\u91cd\u5408\u8bfb\u4e66\u65f6\u95f4 int sum_a [ 1050 ] = { 0 }; int a [ 1050 ] = { 0 }, b [ 1050 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]), sum_a [ i ] = sum_a [ i -1 ] + a [ i ]; for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & b [ i ]); int max_b = n * 10 ; ///B\u6700\u5927\u7684\u65f6\u95f4 for ( int i = 1 ; i <= n + 1 ; i ++ ) for ( int j = 0 ; j <= max_b ; j ++ ) dp [ i ][ j ] = -1 ; dp [ 1 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) { for ( int j = 0 ; j <= max_b ; j ++ ) { if ( dp [ i ][ j ] == -1 ) continue ; if ( i <= n && j + b [ i ] <= max_b ) { dp [ i + 1 ][ j + b [ i ]] = max ( dp [ i + 1 ][ j + b [ i ]], min ( dp [ i ][ j ] + b [ i ], sum_a [ i -1 ])); ///B\u8bfbi\u4e66\uff0cB\u8bfb\u5b8c\u524di\u672c\u4e66\u91cd\u5408\u65f6\u95f4\u6700\u5927\u503c //\u6ce8\u610f\u5e94\u5f53\u548csum_a[i-1]\u53d6\u6700\u5c0f\u503c\uff0c\u7531\u4e8eA\u843d\u540e\u4e8eB\u4e00\u672c\u4e66 } if ( i > 1 && i + 1 <= n && j + b [ i + 1 ] <= max_b ) ///B\u8bfbi+1\u4e66\uff0c\u4e0d\u8981\u5fd8\u8bb0i>1\u7684\u6761\u4ef6\uff0cB\u5fc5\u987b\u8bfb\u7b2c\u4e00\u672c\u4e66 dp [ i + 2 ][ j + b [ i + 1 ]] = max ( dp [ i + 2 ][ j + b [ i + 1 ]], min ( dp [ i ][ j ] + b [ i + 1 ], sum_a [ i ])); } } int min1 = 999999999 ; for ( int j = 0 ; j <= max_b ; j ++ ) { if ( dp [ n + 1 ][ j ] != -1 ) min1 = min ( min1 , j - dp [ n + 1 ][ j ] + sum_a [ n ]); } printf ( \"%d \\n \" , min1 ); return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#c-cul-de-sac-parades","text":"","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5bC\u9898 Cul-De-Sac Parades"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_11","text":"\u6811\u4e0aDP\uff0c\u5bf9\u6bcf\u4e2a\u7236\u8282\u70b9\u7684\u7684\u8fb9\u8fdb\u884c\u679a\u4e3e\u9009\u62e9\uff0c\u662f\u5426\u4f7f\u7528\u8fd9\u4e2a\u8fb9\uff08\u5047\u8bbe\u4e3a\u8fb9A\uff09\uff0c\u5982\u679c\u4f7f\u7528\u8fd9\u6761\u8fb9A\uff0c\u5219\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9\uff0c\u627e\u51fa\u8fde\u63a5\u5b50\u8282\u70b9\u6240\u6709\u8fb9\u4e2d\u6743\u503c\u6700\u5927\u7684\u8fb9\uff0c\u5c06\u5176\u4e0e\u8fb9A\u8fdb\u884c\u8fde\u63a5\uff0c\u7ec4\u6210\u4e00\u6761\u901a\u8def\uff0c\u5176\u4f59\u5b50\u8282\u70b9\u4e0a\u7684\u8fb9\u8fdb\u884c\u4e24\u4e24\u5339\u914d\u7ec4\u6210\u901a\u8def\uff1b\u53cd\u4e4b\u5982\u679c\u4e0d\u4f7f\u7528\u8fd9\u6761\u8fb9A\uff0c\u5219\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9\uff0c\u8ba9\u5b50\u8282\u70b9\u7684\u8fb9\u8fdb\u884c\u4e24\u4e24\u5339\u914d\uff0c\u7ec4\u6210\u901a\u8def\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_12","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll to , val ; }; struct node1 { ll yes , no ; }; vector < node > v [ 100500 ]; vector < node > chr [ 100500 ]; ll dp [ 100500 ][ 2 ] = { 0 }; void dfs ( ll now , ll fa ) ///\u7528\u4e8e\u627e\u8fd9\u4e2a\u70b9\u7684\u5b50\u8282\u70b9 { for ( node i : v [ now ]) { if ( i . to == fa ) continue ; chr [ now ]. push_back ( i ); dfs ( i . to , now ); } } ll work ( ll now , ll has_path ) ///has_path\u4ee3\u8868\u662f\u5426\u4f7f\u7528\u8fd9\u6761\u8fb9 { if ( chr [ now ]. empty ()) return 0 ; if ( dp [ now ][ has_path ] != -1 ) return dp [ now ][ has_path ]; vector < node1 > data ; ll & ans = dp [ now ][ has_path ] = 0 ; for ( node i : chr [ now ]) { node1 data1 ; data1 . yes = work ( i . to , true ) + i . val ; //\u4f7f\u7528\u8fd9\u6761\u8fb9\uff0c\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9 data1 . no = work ( i . to , false ); ///\u4e0d\u4f7f\u7528\u8fd9\u6761\u8fb9\uff0c\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9 data . push_back ( data1 ); } sort ( data . begin (), data . end (),[]( node1 a , node1 b ){ return a . yes - a . no > b . yes - b . no ;}); for ( node1 i : data ) ans += i . no ; ///\u5148\u5bf9\u4e0d\u4f7f\u7528\u8fd9\u4e9b\u8fb9\u7684\u6743\u503c\u6c42\u548c if ( has_path ) ans += data [ 0 ]. yes - data [ 0 ]. no ; ///\u5982\u679c\u7236\u8282\u70b9\u4f7f\u7528\u8fd9\u6761\u8fb9\uff0c\u5219\u5e94\u5f53\u627e\u4e00\u6761\u6743\u503c\u6700\u5927\u7684\u8fb9\u4e0e\u4e4b\u8fde\u63a5 for ( ll i = has_path ; i + 1 < ( ll ) data . size (); i += 2 ) { ll yes = data [ i ]. yes + data [ i + 1 ]. yes ; ll no = data [ i ]. no + data [ i + 1 ]. no ; if ( yes < no ) break ; else { ans += yes - no ; ///\u4ee3\u8868\u4f7f\u7528\u8fd9\u4e24\u6761\u8fb9\u5e76\u7ec4\u6210\u4e00\u4e2a\u901a\u8def } } return ans ; } int main () { ll n , s , e , val ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n -1 ; i ++ ) { scanf ( \"%lld%lld%lld\" , & s , & e , & val ); v [ s ]. push_back ({ e , val }); v [ e ]. push_back ({ s , val }); } memset ( dp , -1 , sizeof ( dp )); dfs ( 1 , -1 ); ll ans = work ( 1 , false ); if ( chr [ 1 ]. size () == 1 ) ///1\u4e3a\u6839\u8282\u70b9\uff0c\u8fd9\u6761\u8fb9\u5fc5\u987b\u4f7f\u7528 ans = max ( ans , work ( 1 , true )); cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-24-2%E6%9C%8824%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"E\u9898 Social Distancing \u00b6 \u9898\u89e3 \u00b6 \u5207\u6bd4\u96ea\u592b\u8ddd\u79bb\u548c\u66fc\u54c8\u987f\u8ddd\u79bb\u76f8\u4e92\u8f6c\u53d8 \u6839\u636e\u4e0a\u8ff0\u6027\u8d28\uff0c\u53ef\u4ee5\u5c06\u6c42\u5207\u6bd4\u96ea\u592b\u4e0d\u7b49\u5f0f\u6700\u5c0f\u503c\u8f6c\u5316\u4e3a\u6c42\u66fc\u54c8\u987f\u8ddd\u79bb\u7684\u6700\u5c0f\u503c\u3002 \u4e8c\u7ef4\u77e9\u9635\u6c42\u66fc\u54c8\u987f\u8ddd\u79bb\u53ef\u4ee5\u6839\u636e\u524d\u7f00\u548c\u6765\u51cf\u5c11\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u5982\u679c\u8be5\u70b9\u975e\u75c5\u4eba\uff0c\u6807\u8bb0\u4e3a1\uff0c\u4ee3\u8868\u8be5\u70b9\u6743\u503c\u4e3a1\uff1b\u53cd\u4e4b\u5219\u6807\u8bb0\u4e3a-1\uff0c\u540e\u671f\u6c42\u524d\u7f00\u548c\u65f6\u8be5\u70b9\u6743\u503c\u5b9a\u4e3a0\uff1b\u7136\u540e\u5206\u522b\u6cbf\u56db\u4e2a\u65b9\u5411\u6c42\u524d\u7f00\u548c\uff0c\u53d6\u6700\u5c0f\u503c\u5373\u4e3a\u6bcf\u4e2a\u70b9\u7684\u6700\u5c0f\u66fc\u54c8\u987f\u8ddd\u79bb\u3002 \u6700\u540e\u6839\u636e\u6700\u5c0f\u66fc\u54c8\u987f\u8ddd\u79bbdfs\u8fdb\u884c\u641c\u7d22\u5373\u53ef\u5f97\u51fa\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char a [ 505 ][ 505 ] = { 0 }; int ans1 [ 505 ][ 505 ] = { 0 }; int dis [ 505 ][ 505 ] = { 0 }; int sx , sy , ex , ey ; struct node { int x , y , val ; }; int dx [] = { 0 , 1 , -1 , 0 , 0 }; int dy [] = { 0 , 0 , 0 , 1 , -1 }; int n , m ; int ans = -1 ; int dfs ( int x , int y , int val ) { if ( ans >= val ) return 0 ; if ( x == ex && y == ey ) { ans = max ( ans , val ); return 0 ; } for ( int i = 1 ; i <= 4 ; i ++ ) { int xx = x + dx [ i ], yy = y + dy [ i ]; if ( xx < 1 || xx > n || yy < 1 || yy > m ) continue ; if ( a [ xx ][ yy ] == '#' ) continue ; int val1 = min ( val , dis [ xx ][ yy ]); if ( ans1 [ xx ][ yy ] >= val1 ) continue ; ans1 [ xx ][ yy ] = val1 ; dfs ( xx , yy , val1 ); } return 0 ; } int mp [ 1050 ][ 1050 ] = { 0 }; int mp_sum1 [ 1050 ][ 1050 ] = { 0 }; int mp_sum2 [ 1050 ][ 1050 ] = { 0 }; int mp_sum3 [ 1050 ][ 1050 ] = { 0 }; int mp_sum4 [ 1050 ][ 1050 ] = { 0 }; int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dis [ i ][ j ] = inf ; } } for ( int i = 0 ; i < 1050 ; i ++ ) for ( int j = 0 ; j < 1050 ; j ++ ) mp_sum1 [ i ][ j ] = mp_sum2 [ i ][ j ] = mp_sum3 [ i ][ j ] = mp_sum4 [ i ][ j ] = inf ; int sum = 0 ; for ( int i = 0 ; i <= n + 1 ; i ++ ) { int j = 0 ; mp [ i + j ][ i - j + 500 ] = inf ; j = m + 1 ; mp [ i + j ][ i - j + 500 ] = inf ; } for ( int j = 0 ; j <= m + 1 ; j ++ ) { int i = 0 ; mp [ i + j ][ i - j + 500 ] = inf ; i = n + 1 ; mp [ i + j ][ i - j + 500 ] = inf ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ][ j ] == '*' ) { sum ++ ; mp [ i + j ][ i - j + 500 ] = -1 ; } else { mp [ i + j ][ i - j + 500 ] = 1 ; } if ( a [ i ][ j ] == 'S' ) sx = i , sy = j ; if ( a [ i ][ j ] == 'E' ) ex = i , ey = j ; } } for ( int i = 1 ; i < 1050 ; i ++ ) { for ( int j = 1 ; j < 1050 ; j ++ ) { if ( mp [ i ][ j ] == -1 ) mp_sum1 [ i ][ j ] = 0 ; else mp_sum1 [ i ][ j ] = min ( mp_sum1 [ i ][ j ], min ( mp_sum1 [ i -1 ][ j ], mp_sum1 [ i ][ j -1 ]) + mp [ i ][ j ]); } } for ( int i = 1 ; i < 1050 ; i ++ ) { for ( int j = 1049 ; j >= 1 ; j -- ) { if ( mp [ i ][ j ] == -1 ) mp_sum2 [ i ][ j ] = 0 ; else mp_sum2 [ i ][ j ] = min ( mp_sum2 [ i ][ j ], min ( mp_sum2 [ i -1 ][ j ], mp_sum2 [ i ][ j + 1 ]) + mp [ i ][ j ]); } } for ( int i = 1049 ; i >= 1 ; i -- ) { for ( int j = 1 ; j < 1050 ; j ++ ) { if ( mp [ i ][ j ] == -1 ) mp_sum3 [ i ][ j ] = 0 ; else mp_sum3 [ i ][ j ] = min ( mp_sum3 [ i ][ j ], min ( mp_sum3 [ i + 1 ][ j ], mp_sum3 [ i ][ j -1 ]) + mp [ i ][ j ]); } } for ( int i = 1049 ; i >= 1 ; i -- ) { for ( int j = 1049 ; j >= 1 ; j -- ) { if ( mp [ i ][ j ] == -1 ) mp_sum4 [ i ][ j ] = 0 ; else mp_sum4 [ i ][ j ] = min ( mp_sum4 [ i ][ j ], min ( mp_sum4 [ i + 1 ][ j ], mp_sum4 [ i ][ j + 1 ]) + mp [ i ][ j ]); } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int xx = i + j , yy = i - j + 500 ; dis [ i ][ j ] = min ( min ( mp_sum1 [ xx ][ yy ], mp_sum2 [ xx ][ yy ]), min ( mp_sum3 [ xx ][ yy ], mp_sum4 [ xx ][ yy ])); } } dfs ( sx , sy , dis [ sx ][ sy ]); if ( ans != -1 && sum == 0 ) { printf ( \"safe \\n \" ); return 0 ; } printf ( \"%d \\n \" , ans ); }","title":"2021-02-24-2\u670824\u65e5\u9898\u89e3"},{"location":"problem/2021-02-24-2%E6%9C%8824%E6%97%A5%E9%A2%98%E8%A7%A3/#e-social-distancing","text":"","title":"E\u9898 Social Distancing"},{"location":"problem/2021-02-24-2%E6%9C%8824%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u5207\u6bd4\u96ea\u592b\u8ddd\u79bb\u548c\u66fc\u54c8\u987f\u8ddd\u79bb\u76f8\u4e92\u8f6c\u53d8 \u6839\u636e\u4e0a\u8ff0\u6027\u8d28\uff0c\u53ef\u4ee5\u5c06\u6c42\u5207\u6bd4\u96ea\u592b\u4e0d\u7b49\u5f0f\u6700\u5c0f\u503c\u8f6c\u5316\u4e3a\u6c42\u66fc\u54c8\u987f\u8ddd\u79bb\u7684\u6700\u5c0f\u503c\u3002 \u4e8c\u7ef4\u77e9\u9635\u6c42\u66fc\u54c8\u987f\u8ddd\u79bb\u53ef\u4ee5\u6839\u636e\u524d\u7f00\u548c\u6765\u51cf\u5c11\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u5982\u679c\u8be5\u70b9\u975e\u75c5\u4eba\uff0c\u6807\u8bb0\u4e3a1\uff0c\u4ee3\u8868\u8be5\u70b9\u6743\u503c\u4e3a1\uff1b\u53cd\u4e4b\u5219\u6807\u8bb0\u4e3a-1\uff0c\u540e\u671f\u6c42\u524d\u7f00\u548c\u65f6\u8be5\u70b9\u6743\u503c\u5b9a\u4e3a0\uff1b\u7136\u540e\u5206\u522b\u6cbf\u56db\u4e2a\u65b9\u5411\u6c42\u524d\u7f00\u548c\uff0c\u53d6\u6700\u5c0f\u503c\u5373\u4e3a\u6bcf\u4e2a\u70b9\u7684\u6700\u5c0f\u66fc\u54c8\u987f\u8ddd\u79bb\u3002 \u6700\u540e\u6839\u636e\u6700\u5c0f\u66fc\u54c8\u987f\u8ddd\u79bbdfs\u8fdb\u884c\u641c\u7d22\u5373\u53ef\u5f97\u51fa\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-24-2%E6%9C%8824%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char a [ 505 ][ 505 ] = { 0 }; int ans1 [ 505 ][ 505 ] = { 0 }; int dis [ 505 ][ 505 ] = { 0 }; int sx , sy , ex , ey ; struct node { int x , y , val ; }; int dx [] = { 0 , 1 , -1 , 0 , 0 }; int dy [] = { 0 , 0 , 0 , 1 , -1 }; int n , m ; int ans = -1 ; int dfs ( int x , int y , int val ) { if ( ans >= val ) return 0 ; if ( x == ex && y == ey ) { ans = max ( ans , val ); return 0 ; } for ( int i = 1 ; i <= 4 ; i ++ ) { int xx = x + dx [ i ], yy = y + dy [ i ]; if ( xx < 1 || xx > n || yy < 1 || yy > m ) continue ; if ( a [ xx ][ yy ] == '#' ) continue ; int val1 = min ( val , dis [ xx ][ yy ]); if ( ans1 [ xx ][ yy ] >= val1 ) continue ; ans1 [ xx ][ yy ] = val1 ; dfs ( xx , yy , val1 ); } return 0 ; } int mp [ 1050 ][ 1050 ] = { 0 }; int mp_sum1 [ 1050 ][ 1050 ] = { 0 }; int mp_sum2 [ 1050 ][ 1050 ] = { 0 }; int mp_sum3 [ 1050 ][ 1050 ] = { 0 }; int mp_sum4 [ 1050 ][ 1050 ] = { 0 }; int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dis [ i ][ j ] = inf ; } } for ( int i = 0 ; i < 1050 ; i ++ ) for ( int j = 0 ; j < 1050 ; j ++ ) mp_sum1 [ i ][ j ] = mp_sum2 [ i ][ j ] = mp_sum3 [ i ][ j ] = mp_sum4 [ i ][ j ] = inf ; int sum = 0 ; for ( int i = 0 ; i <= n + 1 ; i ++ ) { int j = 0 ; mp [ i + j ][ i - j + 500 ] = inf ; j = m + 1 ; mp [ i + j ][ i - j + 500 ] = inf ; } for ( int j = 0 ; j <= m + 1 ; j ++ ) { int i = 0 ; mp [ i + j ][ i - j + 500 ] = inf ; i = n + 1 ; mp [ i + j ][ i - j + 500 ] = inf ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ][ j ] == '*' ) { sum ++ ; mp [ i + j ][ i - j + 500 ] = -1 ; } else { mp [ i + j ][ i - j + 500 ] = 1 ; } if ( a [ i ][ j ] == 'S' ) sx = i , sy = j ; if ( a [ i ][ j ] == 'E' ) ex = i , ey = j ; } } for ( int i = 1 ; i < 1050 ; i ++ ) { for ( int j = 1 ; j < 1050 ; j ++ ) { if ( mp [ i ][ j ] == -1 ) mp_sum1 [ i ][ j ] = 0 ; else mp_sum1 [ i ][ j ] = min ( mp_sum1 [ i ][ j ], min ( mp_sum1 [ i -1 ][ j ], mp_sum1 [ i ][ j -1 ]) + mp [ i ][ j ]); } } for ( int i = 1 ; i < 1050 ; i ++ ) { for ( int j = 1049 ; j >= 1 ; j -- ) { if ( mp [ i ][ j ] == -1 ) mp_sum2 [ i ][ j ] = 0 ; else mp_sum2 [ i ][ j ] = min ( mp_sum2 [ i ][ j ], min ( mp_sum2 [ i -1 ][ j ], mp_sum2 [ i ][ j + 1 ]) + mp [ i ][ j ]); } } for ( int i = 1049 ; i >= 1 ; i -- ) { for ( int j = 1 ; j < 1050 ; j ++ ) { if ( mp [ i ][ j ] == -1 ) mp_sum3 [ i ][ j ] = 0 ; else mp_sum3 [ i ][ j ] = min ( mp_sum3 [ i ][ j ], min ( mp_sum3 [ i + 1 ][ j ], mp_sum3 [ i ][ j -1 ]) + mp [ i ][ j ]); } } for ( int i = 1049 ; i >= 1 ; i -- ) { for ( int j = 1049 ; j >= 1 ; j -- ) { if ( mp [ i ][ j ] == -1 ) mp_sum4 [ i ][ j ] = 0 ; else mp_sum4 [ i ][ j ] = min ( mp_sum4 [ i ][ j ], min ( mp_sum4 [ i + 1 ][ j ], mp_sum4 [ i ][ j + 1 ]) + mp [ i ][ j ]); } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int xx = i + j , yy = i - j + 500 ; dis [ i ][ j ] = min ( min ( mp_sum1 [ xx ][ yy ], mp_sum2 [ xx ][ yy ]), min ( mp_sum3 [ xx ][ yy ], mp_sum4 [ xx ][ yy ])); } } dfs ( sx , sy , dis [ sx ][ sy ]); if ( ans != -1 && sum == 0 ) { printf ( \"safe \\n \" ); return 0 ; } printf ( \"%d \\n \" , ans ); }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"USACO 2021 February Contest, Bronze Problem 3. Clockwise Fence \u00b6 The fence surrounding Farmer John's largest pasture has fallen into disrepair, and he has finally decided to replace it with a new fence. Unfortunately, as Farmer John is laying out the new fence, a large bee ends up chasing him around the pasture, and as a result, the fence ends up following a rather irregular path. The fence can be described by a string of characters, each either \"N\" (north), \"E\" (east), \"S\" (south), or \"W\" (west). Each character describes a 1-meter run of the fence. For example, if the string is NESW, this means the fence starts by moving north for 1 meter, then east for 1 meter, then south for 1 meter, then west for 1 meter, returning to its starting point. The fence ends at the position where it started, and this is the only point visited more than once by the path of the fence (and the starting point is only re-visited once, at the end). As a result, the fence does indeed enclose a single connected region of the grassy pasture, even though this region could have a rather strange shape. Farmer John is curious if the path in which he laid the fence traveled clockwise (with the enclosed region on the right side of the fence as one walks along the path of the fence in the order specified by the string) or counter-clockwise (with the enclosed region on the left side of the fence). INPUT FORMAT (input arrives from the terminal / stdin): \u00b6 The first line of input contains an integer NN (1\u2264N\u2264201\u2264N\u226420). Each of the next NN lines contains a string of length at least 4 and at most 100, describing a single fence path. OUTPUT FORMAT (print output to the terminal / stdout): \u00b6 For each of the NN fence paths described in the input, output a line containing either \"CW\" (clockwise) or \"CCW\" (counterclockwise). SAMPLE INPUT: \u00b6 2 NESW WSSSEENWNEESSENNNNWWWS SAMPLE OUTPUT: \u00b6 CW CCW The two fence paths with denoting the starting point: *>* ^ v <* *<*<*<* v ^ *< * v ^ * *>*>* * v ^ v ^ * *<* * * v ^ v ^ *>*>* *>* Problem credits: Brian Dean \u9898\u89e3 \u00b6 \u53c2\u7167\u4e8e\uff1a \u7a7a\u95f4\u591a\u8fb9\u5f62\u987a\u9006\u65f6\u9488\u7684\u5224\u65ad \u6839\u636e\u5b57\u7b26\u4e32\u6a21\u62df\u8fd0\u52a8\u65b9\u5411\uff0c\u6839\u636e\u5411\u91cf\u5224\u65ad\u987a\u9006\u65f6\u9488\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; char a [ 200 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , a + 1 ); int x = 0 , y = 0 , sumz = 0 , sumf = 0 ; for ( int j = 1 ; a [ j ]; j ++ ) { int xx , yy ; if ( a [ j ] == 'N' ) yy = y -1 ; else if ( a [ j ] == 'S' ) yy = y + 1 ; else if ( a [ j ] == 'W' ) xx = x -1 ; else if ( a [ j ] == 'E' ) xx = x + 1 ; int val = x * yy - xx * y ; if ( val > 0 ) sumz ++ ; else if ( val < 0 ) sumf ++ ; x = xx , y = yy ; } if ( sumz < sumf ) printf ( \"CCW \\n \" ); else printf ( \"CW \\n \" ); } }","title":"2021-02-28-2\u670828\u65e5\u9898\u89e3"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/#usaco-2021-february-contest-bronze-problem-3-clockwise-fence","text":"The fence surrounding Farmer John's largest pasture has fallen into disrepair, and he has finally decided to replace it with a new fence. Unfortunately, as Farmer John is laying out the new fence, a large bee ends up chasing him around the pasture, and as a result, the fence ends up following a rather irregular path. The fence can be described by a string of characters, each either \"N\" (north), \"E\" (east), \"S\" (south), or \"W\" (west). Each character describes a 1-meter run of the fence. For example, if the string is NESW, this means the fence starts by moving north for 1 meter, then east for 1 meter, then south for 1 meter, then west for 1 meter, returning to its starting point. The fence ends at the position where it started, and this is the only point visited more than once by the path of the fence (and the starting point is only re-visited once, at the end). As a result, the fence does indeed enclose a single connected region of the grassy pasture, even though this region could have a rather strange shape. Farmer John is curious if the path in which he laid the fence traveled clockwise (with the enclosed region on the right side of the fence as one walks along the path of the fence in the order specified by the string) or counter-clockwise (with the enclosed region on the left side of the fence).","title":"USACO 2021 February Contest, Bronze Problem 3. Clockwise Fence"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/#input-format-input-arrives-from-the-terminal-stdin","text":"The first line of input contains an integer NN (1\u2264N\u2264201\u2264N\u226420). Each of the next NN lines contains a string of length at least 4 and at most 100, describing a single fence path.","title":"INPUT FORMAT (input arrives from the terminal / stdin):"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/#output-format-print-output-to-the-terminal-stdout","text":"For each of the NN fence paths described in the input, output a line containing either \"CW\" (clockwise) or \"CCW\" (counterclockwise).","title":"OUTPUT FORMAT (print output to the terminal / stdout):"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/#sample-input","text":"2 NESW WSSSEENWNEESSENNNNWWWS","title":"SAMPLE INPUT:"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/#sample-output","text":"CW CCW The two fence paths with denoting the starting point: *>* ^ v <* *<*<*<* v ^ *< * v ^ * *>*>* * v ^ v ^ * *<* * * v ^ v ^ *>*>* *>* Problem credits: Brian Dean","title":"SAMPLE OUTPUT:"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u53c2\u7167\u4e8e\uff1a \u7a7a\u95f4\u591a\u8fb9\u5f62\u987a\u9006\u65f6\u9488\u7684\u5224\u65ad \u6839\u636e\u5b57\u7b26\u4e32\u6a21\u62df\u8fd0\u52a8\u65b9\u5411\uff0c\u6839\u636e\u5411\u91cf\u5224\u65ad\u987a\u9006\u65f6\u9488\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#include <bits/stdc++.h> using namespace std ; char a [ 200 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , a + 1 ); int x = 0 , y = 0 , sumz = 0 , sumf = 0 ; for ( int j = 1 ; a [ j ]; j ++ ) { int xx , yy ; if ( a [ j ] == 'N' ) yy = y -1 ; else if ( a [ j ] == 'S' ) yy = y + 1 ; else if ( a [ j ] == 'W' ) xx = x -1 ; else if ( a [ j ] == 'E' ) xx = x + 1 ; int val = x * yy - xx * y ; if ( val > 0 ) sumz ++ ; else if ( val < 0 ) sumf ++ ; x = xx , y = yy ; } if ( sumz < sumf ) printf ( \"CCW \\n \" ); else printf ( \"CW \\n \" ); } }","title":"\u4ee3\u7801"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"Codeforces Global Round 13 \u00b6 C\u9898 \u00b6 \u9898\u89e3 \u00b6 \u8d2a\u5fc3\uff0cPekora \u4e00\u5b9a\u4ece\u7b2c\u4e00\u4e2a\u5f00\u59cb\u8df3\uff0c\u76f4\u5230\u628a\u7b2c\u4e00\u4e2a\u53d8\u4e3a1\uff0c\u7136\u540e\u8df3\u5230\u7b2c2\u4e2a\uff0c\u8fd9\u6837\u80fd\u591f\u8fbe\u5230\u6700\u4f18\u89e3\u3002 \u5728\u628a\u4e00\u4e2a\u4f4d\u7f6e\u4e3ai\u4e14\u9ad8\u5ea6\u4e3acur\u7684\u8e66\u5e8a\u53d8\u4e3a1\u65f6\uff0c\u4ece[i+2,cur+i]\u8fd9\u4e2a\u533a\u95f4\u5185\u6240\u6709\u8e66\u5e8a\u7684\u9ad8\u5ea6\u5c06\u51cf\u5c111\u3002 \u5982\u679c\u4f4d\u7f6ei\u7684\u8e66\u5e8a\u9ad8\u5ea6\u5df2\u7ecf\u4e3a1\uff0c\u5219\u5e94\u5f53\u8f6c\u79fb\u5230\u7b2ci+1\u4e2a\u4e0a\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 6000 ] = { 0 }, cur [ 6000 ] = { 0 }; int main () { ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); cur [ i ] = 0 ; } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll now = cur [ i ]; if ( now < a [ i ] -1 ) { ans += a [ i ] - now -1 ; now += a [ i ] - now -1 ; } cur [ i + 1 ] += now - a [ i ] + 1 ; ///\u591a\u51fa\u6765\u7684\u8df3\u5230\u4e0b\u4e00\u4e2a for ( ll j = i + 2 ; j <= min ( n , i + a [ i ]); j ++ ) cur [ j ] += 1 ; } printf ( \"%lld \\n \" , ans ); } } D\u9898 \u00b6 \u9898\u89e3 \u00b6 \u5bb9\u6613\u53d1\u73b0\u5982\u679c\u4e00\u4e2a\u6570u\u4e8c\u8fdb\u5236\u67d0\u4e00\u4f4d\u4e3a1\uff0c\u5219\u53ef\u4ee5\u4e14\u4e00\u4e2a\u5176\u4f59\u5168\u4e3a0\uff0c\u53ea\u6709\u8be5\u4f4d\u7f6e\u4e3a1\u7684\u53e6\u4e00\u4e2a\u6570v\u5e76\u4e14\u7ed3\u679c\u4f9d\u7136\u4e3av\uff0c\u5c06v\u52a0\u5230u\u4e0a\u4fbf\u53ef\u4ee5\u628au\u76841\u524d\u79fb\u4e00\u4f4d\uff0c\u7528\u524d\u7f00\u548c\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <stdio.h> using namespace std ; int a [ 50 ] = { 0 }; int b [ 50 ] = { 0 }; int sum1 [ 50 ] = { 0 }; int sum2 [ 50 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { long long u , v ; scanf ( \"%lld%lld\" , & u , & v ); if ( v < u ) { printf ( \"NO \\n \" ); continue ; } for ( int i = 1 ; i <= 40 ; i ++ ) { a [ i ] = u % 2 , u /= 2 ; sum1 [ i ] = sum1 [ i -1 ] + a [ i ]; } for ( int i = 1 ; i <= 40 ; i ++ ) { b [ i ] = v % 2 , v /= 2 ; sum2 [ i ] = sum2 [ i -1 ] + b [ i ]; } int flag = 1 ; for ( int i = 1 ; i <= 40 ; i ++ ) { if ( sum1 [ i ] < sum2 [ i ]) flag = 0 ; } if ( flag ) printf ( \"YES \\n \" ); else printf ( \"NO \\n \" ); } }","title":"2021-03-02-3\u67082\u65e5\u9898\u89e3"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#codeforces-global-round-13","text":"","title":"Codeforces Global Round 13"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#c","text":"","title":"C\u9898"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u8d2a\u5fc3\uff0cPekora \u4e00\u5b9a\u4ece\u7b2c\u4e00\u4e2a\u5f00\u59cb\u8df3\uff0c\u76f4\u5230\u628a\u7b2c\u4e00\u4e2a\u53d8\u4e3a1\uff0c\u7136\u540e\u8df3\u5230\u7b2c2\u4e2a\uff0c\u8fd9\u6837\u80fd\u591f\u8fbe\u5230\u6700\u4f18\u89e3\u3002 \u5728\u628a\u4e00\u4e2a\u4f4d\u7f6e\u4e3ai\u4e14\u9ad8\u5ea6\u4e3acur\u7684\u8e66\u5e8a\u53d8\u4e3a1\u65f6\uff0c\u4ece[i+2,cur+i]\u8fd9\u4e2a\u533a\u95f4\u5185\u6240\u6709\u8e66\u5e8a\u7684\u9ad8\u5ea6\u5c06\u51cf\u5c111\u3002 \u5982\u679c\u4f4d\u7f6ei\u7684\u8e66\u5e8a\u9ad8\u5ea6\u5df2\u7ecf\u4e3a1\uff0c\u5219\u5e94\u5f53\u8f6c\u79fb\u5230\u7b2ci+1\u4e2a\u4e0a\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 6000 ] = { 0 }, cur [ 6000 ] = { 0 }; int main () { ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); cur [ i ] = 0 ; } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll now = cur [ i ]; if ( now < a [ i ] -1 ) { ans += a [ i ] - now -1 ; now += a [ i ] - now -1 ; } cur [ i + 1 ] += now - a [ i ] + 1 ; ///\u591a\u51fa\u6765\u7684\u8df3\u5230\u4e0b\u4e00\u4e2a for ( ll j = i + 2 ; j <= min ( n , i + a [ i ]); j ++ ) cur [ j ] += 1 ; } printf ( \"%lld \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#d","text":"","title":"D\u9898"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u5bb9\u6613\u53d1\u73b0\u5982\u679c\u4e00\u4e2a\u6570u\u4e8c\u8fdb\u5236\u67d0\u4e00\u4f4d\u4e3a1\uff0c\u5219\u53ef\u4ee5\u4e14\u4e00\u4e2a\u5176\u4f59\u5168\u4e3a0\uff0c\u53ea\u6709\u8be5\u4f4d\u7f6e\u4e3a1\u7684\u53e6\u4e00\u4e2a\u6570v\u5e76\u4e14\u7ed3\u679c\u4f9d\u7136\u4e3av\uff0c\u5c06v\u52a0\u5230u\u4e0a\u4fbf\u53ef\u4ee5\u628au\u76841\u524d\u79fb\u4e00\u4f4d\uff0c\u7528\u524d\u7f00\u548c\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"#include <stdio.h> using namespace std ; int a [ 50 ] = { 0 }; int b [ 50 ] = { 0 }; int sum1 [ 50 ] = { 0 }; int sum2 [ 50 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { long long u , v ; scanf ( \"%lld%lld\" , & u , & v ); if ( v < u ) { printf ( \"NO \\n \" ); continue ; } for ( int i = 1 ; i <= 40 ; i ++ ) { a [ i ] = u % 2 , u /= 2 ; sum1 [ i ] = sum1 [ i -1 ] + a [ i ]; } for ( int i = 1 ; i <= 40 ; i ++ ) { b [ i ] = v % 2 , v /= 2 ; sum2 [ i ] = sum2 [ i -1 ] + b [ i ]; } int flag = 1 ; for ( int i = 1 ; i <= 40 ; i ++ ) { if ( sum1 [ i ] < sum2 [ i ]) flag = 0 ; } if ( flag ) printf ( \"YES \\n \" ); else printf ( \"NO \\n \" ); } }","title":"\u4ee3\u7801"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"\u95ee\u9898E Group Project \u00b6 \u9898\u76ee\u63cf\u8ff0 \u00b6 The big day has finally arrived: today you are going to form groups of two in which you will do the end-of-the-year project. When you arrive at school, you learn that the teacher of the other class is sick, and that your teacher, Mr. B.A.P. Cee, will also have to make groups for the other class. Mr. B.A.P. Cee is a smart guy and realizes that he can use these unfortunate circumstances to his advantage. Ending up with groups of one should be avoided at all cost, so mixing the students of the two classes may avoid this situation. However, while it is easy to pair up two students from the same class, it is more difficult to match up students from different classes. Throughout the years there has been a lot of rivalry between the two groups, and many students dislike students in the other class. Mr. B.A.P. Cee knows which pairs of students will result in a fight and a failed project. You are given a list of pairs of students who cannot work together. How many disjoint groups of two can Mr. B.A.P. Cee make that will not result in a failed project? \u8f93\u5165 \u00b6 The input consists of: \u2022 A line with two integers n (1 \u2264 n \u2264 105 ), the number of students, and m (0 \u2264 m \u2264 2 \u00b7 105 ),the number of pairs of students who cannot work together. \u2022 m lines, each with two distinct integers i and j (1 \u2264 i, j \u2264 n , i \u2260 j ), giving a pair of students who cannot work together. Students are identified by the numbers 1 through n . It is guaranteed that it is possible to split the students into two classes in such a way that all students from the same class get along. \u8f93\u51fa \u00b6 Output the number of pairs of students Mr. B.A.P. Cee can make without making any pair of students who cannot work together. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 3 2 1 2 3 1 \u3010\u6837\u4f8b2\u3011 5 6 1 4 2 4 3 4 1 5 2 5 3 5 \u3010\u6837\u4f8b3\u3011 6 6 1 4 2 5 3 6 1 5 3 5 2 6 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 2 \u3010\u6837\u4f8b3\u3011 3 \u9898\u89e3 \u00b6 \u9898\u76ee\u5927\u610f\u4e3a\u4e24\u4e2a\u73ed\u4e4b\u95f4\u8981\u8fdb\u884c\u4e24\u4e24\u7ec4\u961f\u5408\u4f5c\uff0c\u5176\u4e2d\u6709\u4e9b\u4eba\u4e0d\u80fd\u548c\u53e6\u4e00\u73ed\u7ea7\u4e2d\u4e00\u4e9b\u4eba\u8fdb\u884c\u7ec4\u961f\uff0c\u5e76\u4e14\u73ed\u7ea7\u5185\u90e8\u90fd\u53ef\u4ee5\u8fdb\u884c\u7ec4\u961f\uff0c\u95ee\u6700\u591a\u53ef\u4ee5\u7ec4\u961f\u7684\u961f\u6570\u3002 \u5148\u7528DFS\u5212\u5206\u51fa\u4e24\u4e2a\u73ed\u7684\u4eba\uff0c\u7136\u540e\u5224\u65ad\u4e24\u4e2a\u73ed\u7ea7\u4e4b\u95f4\u662f\u5426\u4e24\u4e24\u90fd\u6709\u77db\u76fe\uff0c\u5206\u4e24\u79cd\u60c5\u51b5\u8ba8\u8bba\u3002 \u5982\u679c\u4efb\u4f55\u4e24\u4e2a\u4eba\u90fd\u6709\u77db\u76fe\uff0c\u5219\u5e94\u5f53\u73ed\u7ea7\u5185\u90e8\u8fdb\u884c\u5206\u7ec4\u5408\u4f5c\u3002 \u5982\u679c\u4e0d\u662f\u6240\u6709\u4eba\u4e4b\u95f4\u90fd\u6709\u77db\u76fe\uff0c\u5219\u7b54\u6848\u5e94\u4e3a\u603b\u4eba\u6570\u9664\u4ee52\uff0c\u5206\u4ee5\u4e0b\u4e09\u79cd\u60c5\u51b5\u8ba8\u8bba\uff1a \u4e24\u4e2a\u73ed\u4e2d\u4eba\u6570\u5747\u4e3a\u5076\u6570\uff0c\u5219\u4e24\u4e2a\u73ed\u7ea7\u5185\u90e8\u4e4b\u95f4\u76f4\u63a5\u8fdb\u884c\u5206\u7ec4\uff0c\u7b54\u6848\u4e3an/2 \u4e24\u4e2a\u73ed\u4e2d\u4eba\u6570\u4e00\u5947\u4e00\u5076\uff0c\u4e24\u4e2a\u73ed\u7ea7\u5185\u90e8\u76f4\u63a5\u5206\u7ec4\uff0c\u7b54\u6848\u4ecd\u4e3an/2 \u4e24\u4e2a\u73ed\u4e2d\u4eba\u6570\u5747\u4e3a\u5947\u6570\uff0c\u5219\u4e24\u4e2a\u73ed\u7ea7\u4e4b\u95f4\u80af\u5b9a\u5b58\u5728\u4e00\u5bf9\u8de8\u73ed\u7ea7\u7684\u4eba\u6ca1\u6709\u77db\u76fe\uff0c\u53ef\u4ee5\u7ec4\u6210\u4e00\u5bf9\uff0c\u5176\u4ed6\u5185\u90e8\u4e4b\u95f4\u5206\u7ec4\uff0c\u7b54\u6848\u4ecd\u672an/2 \u7efc\u4e0a\uff0c\u7b54\u6848\u4e3a\u603b\u4eba\u6570\u9664\u4ee52\uff0c\u5373\u4e3an/2 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; vector < int > edge [ 100500 ]; int depth [ 100500 ] = { 0 }; int vis [ 100500 ] = { 0 }; int dfs ( int k , int dep ) { depth [ k ] = dep ; for ( int to : edge [ k ]) { if ( depth [ to ] == 0 ) { dfs ( to , 3 - dep ); } } return 0 ; } int main () { int n , m , s , e ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & s , & e ); edge [ s ]. push_back ( e ); edge [ e ]. push_back ( s ); } dfs ( 1 , 1 ); int sum1 = 0 , sum2 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( depth [ i ] == 1 ) sum1 ++ ; if ( depth [ i ] == 2 ) sum2 ++ ; } if ( sum1 + sum2 == n && sum1 * sum2 == m ) printf ( \"%d \\n \" , sum1 / 2 + sum2 / 2 ); else printf ( \"%d \\n \" , n / 2 ); } \u9898\u89e3 \u00b6 \u7528multiset\u7ef4\u62a4\u8d28\u56e0\u6570\u4e2a\u6570\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; ll qpow ( ll a , ll n ) { ll r = 1 ; while ( n ) { if ( n & 1 ) r = ( r * a ) % mod ; n >>= 1 ; a = ( a * a ) % mod ; } return r ; } multiset < ll > st [ 200500 ]; map < ll , ll > mp [ 200500 ]; vector < ll > prime ; int vis [ 200500 ] = { 0 }; ll last [ 200500 ] = { 0 }; int main () { ll n , m , k , pos ; scanf ( \"%lld%lld\" , & n , & k ); for ( int i = 2 ; i <= 200000 ; i ++ ) { if ( ! vis [ i ]) prime . push_back ( i ); for ( int j = 2 ; j * i <= 200000 ; j ++ ) vis [ i * j ] = 1 ; } for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & m ); for ( ll j : prime ) { if ( m == 1 ) break ; if ( ! vis [ m ]) { mp [ i ][ m ] = 1 ; st [ m ]. insert ( 1 ); break ; } ll t = 0 ; while ( m % j == 0 ) { m /= j ; t ++ ; } if ( t ) { mp [ i ][ j ] = t ; st [ j ]. insert ( t ); } } } ll ans = 1 ; for ( ll j : prime ) { if ( st [ j ]. size () == n ) { int tem = * st [ j ]. begin (); if ( tem != last [ j ]) { ans = ans * qpow ( j , tem - last [ j ]) % mod ; last [ j ] = tem ; } } } while ( k -- ) { scanf ( \"%lld%lld\" , & pos , & m ); for ( ll j : prime ) { if ( m == 1 ) break ; if ( ! vis [ m ]) { ll & tem = mp [ pos ][ m ]; if ( tem ) st [ m ]. erase ( st [ m ]. lower_bound ( tem )); tem ++ ; st [ m ]. insert ( tem ); if ( st [ m ]. size () == n ) { int tem1 = * st [ m ]. begin (); if ( tem1 != last [ m ]) { ans = ans * qpow ( m , tem1 - last [ m ]) % mod ; last [ m ] = tem1 ; } } break ; } ll t = 0 ; while ( m % j == 0 ) { m /= j ; t ++ ; } if ( t ) { ll & tem = mp [ pos ][ j ]; if ( tem ) st [ j ]. erase ( st [ j ]. lower_bound ( tem )); tem += t ; st [ j ]. insert ( tem ); if ( st [ j ]. size () == n ) { int tem1 = * st [ j ]. begin (); if ( tem1 != last [ j ]) { ans = ans * qpow ( j , tem1 - last [ j ]) % mod ; last [ j ] = tem1 ; } } } } printf ( \"%lld \\n \" , ans ); } }","title":"2021-03-07-3\u67087\u65e5\u9898\u89e3"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#e-group-project","text":"","title":"\u95ee\u9898E Group Project"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"The big day has finally arrived: today you are going to form groups of two in which you will do the end-of-the-year project. When you arrive at school, you learn that the teacher of the other class is sick, and that your teacher, Mr. B.A.P. Cee, will also have to make groups for the other class. Mr. B.A.P. Cee is a smart guy and realizes that he can use these unfortunate circumstances to his advantage. Ending up with groups of one should be avoided at all cost, so mixing the students of the two classes may avoid this situation. However, while it is easy to pair up two students from the same class, it is more difficult to match up students from different classes. Throughout the years there has been a lot of rivalry between the two groups, and many students dislike students in the other class. Mr. B.A.P. Cee knows which pairs of students will result in a fight and a failed project. You are given a list of pairs of students who cannot work together. How many disjoint groups of two can Mr. B.A.P. Cee make that will not result in a failed project?","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"The input consists of: \u2022 A line with two integers n (1 \u2264 n \u2264 105 ), the number of students, and m (0 \u2264 m \u2264 2 \u00b7 105 ),the number of pairs of students who cannot work together. \u2022 m lines, each with two distinct integers i and j (1 \u2264 i, j \u2264 n , i \u2260 j ), giving a pair of students who cannot work together. Students are identified by the numbers 1 through n . It is guaranteed that it is possible to split the students into two classes in such a way that all students from the same class get along.","title":"\u8f93\u5165"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"Output the number of pairs of students Mr. B.A.P. Cee can make without making any pair of students who cannot work together.","title":"\u8f93\u51fa"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"\u3010\u6837\u4f8b1\u3011 3 2 1 2 3 1 \u3010\u6837\u4f8b2\u3011 5 6 1 4 2 4 3 4 1 5 2 5 3 5 \u3010\u6837\u4f8b3\u3011 6 6 1 4 2 5 3 6 1 5 3 5 2 6","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 2 \u3010\u6837\u4f8b3\u3011 3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"\u9898\u76ee\u5927\u610f\u4e3a\u4e24\u4e2a\u73ed\u4e4b\u95f4\u8981\u8fdb\u884c\u4e24\u4e24\u7ec4\u961f\u5408\u4f5c\uff0c\u5176\u4e2d\u6709\u4e9b\u4eba\u4e0d\u80fd\u548c\u53e6\u4e00\u73ed\u7ea7\u4e2d\u4e00\u4e9b\u4eba\u8fdb\u884c\u7ec4\u961f\uff0c\u5e76\u4e14\u73ed\u7ea7\u5185\u90e8\u90fd\u53ef\u4ee5\u8fdb\u884c\u7ec4\u961f\uff0c\u95ee\u6700\u591a\u53ef\u4ee5\u7ec4\u961f\u7684\u961f\u6570\u3002 \u5148\u7528DFS\u5212\u5206\u51fa\u4e24\u4e2a\u73ed\u7684\u4eba\uff0c\u7136\u540e\u5224\u65ad\u4e24\u4e2a\u73ed\u7ea7\u4e4b\u95f4\u662f\u5426\u4e24\u4e24\u90fd\u6709\u77db\u76fe\uff0c\u5206\u4e24\u79cd\u60c5\u51b5\u8ba8\u8bba\u3002 \u5982\u679c\u4efb\u4f55\u4e24\u4e2a\u4eba\u90fd\u6709\u77db\u76fe\uff0c\u5219\u5e94\u5f53\u73ed\u7ea7\u5185\u90e8\u8fdb\u884c\u5206\u7ec4\u5408\u4f5c\u3002 \u5982\u679c\u4e0d\u662f\u6240\u6709\u4eba\u4e4b\u95f4\u90fd\u6709\u77db\u76fe\uff0c\u5219\u7b54\u6848\u5e94\u4e3a\u603b\u4eba\u6570\u9664\u4ee52\uff0c\u5206\u4ee5\u4e0b\u4e09\u79cd\u60c5\u51b5\u8ba8\u8bba\uff1a \u4e24\u4e2a\u73ed\u4e2d\u4eba\u6570\u5747\u4e3a\u5076\u6570\uff0c\u5219\u4e24\u4e2a\u73ed\u7ea7\u5185\u90e8\u4e4b\u95f4\u76f4\u63a5\u8fdb\u884c\u5206\u7ec4\uff0c\u7b54\u6848\u4e3an/2 \u4e24\u4e2a\u73ed\u4e2d\u4eba\u6570\u4e00\u5947\u4e00\u5076\uff0c\u4e24\u4e2a\u73ed\u7ea7\u5185\u90e8\u76f4\u63a5\u5206\u7ec4\uff0c\u7b54\u6848\u4ecd\u4e3an/2 \u4e24\u4e2a\u73ed\u4e2d\u4eba\u6570\u5747\u4e3a\u5947\u6570\uff0c\u5219\u4e24\u4e2a\u73ed\u7ea7\u4e4b\u95f4\u80af\u5b9a\u5b58\u5728\u4e00\u5bf9\u8de8\u73ed\u7ea7\u7684\u4eba\u6ca1\u6709\u77db\u76fe\uff0c\u53ef\u4ee5\u7ec4\u6210\u4e00\u5bf9\uff0c\u5176\u4ed6\u5185\u90e8\u4e4b\u95f4\u5206\u7ec4\uff0c\u7b54\u6848\u4ecd\u672an/2 \u7efc\u4e0a\uff0c\u7b54\u6848\u4e3a\u603b\u4eba\u6570\u9664\u4ee52\uff0c\u5373\u4e3an/2","title":"\u9898\u89e3"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"#include <bits/stdc++.h> using namespace std ; vector < int > edge [ 100500 ]; int depth [ 100500 ] = { 0 }; int vis [ 100500 ] = { 0 }; int dfs ( int k , int dep ) { depth [ k ] = dep ; for ( int to : edge [ k ]) { if ( depth [ to ] == 0 ) { dfs ( to , 3 - dep ); } } return 0 ; } int main () { int n , m , s , e ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & s , & e ); edge [ s ]. push_back ( e ); edge [ e ]. push_back ( s ); } dfs ( 1 , 1 ); int sum1 = 0 , sum2 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( depth [ i ] == 1 ) sum1 ++ ; if ( depth [ i ] == 2 ) sum2 ++ ; } if ( sum1 + sum2 == n && sum1 * sum2 == m ) printf ( \"%d \\n \" , sum1 / 2 + sum2 / 2 ); else printf ( \"%d \\n \" , n / 2 ); }","title":"\u4ee3\u7801"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"\u7528multiset\u7ef4\u62a4\u8d28\u56e0\u6570\u4e2a\u6570\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; ll qpow ( ll a , ll n ) { ll r = 1 ; while ( n ) { if ( n & 1 ) r = ( r * a ) % mod ; n >>= 1 ; a = ( a * a ) % mod ; } return r ; } multiset < ll > st [ 200500 ]; map < ll , ll > mp [ 200500 ]; vector < ll > prime ; int vis [ 200500 ] = { 0 }; ll last [ 200500 ] = { 0 }; int main () { ll n , m , k , pos ; scanf ( \"%lld%lld\" , & n , & k ); for ( int i = 2 ; i <= 200000 ; i ++ ) { if ( ! vis [ i ]) prime . push_back ( i ); for ( int j = 2 ; j * i <= 200000 ; j ++ ) vis [ i * j ] = 1 ; } for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & m ); for ( ll j : prime ) { if ( m == 1 ) break ; if ( ! vis [ m ]) { mp [ i ][ m ] = 1 ; st [ m ]. insert ( 1 ); break ; } ll t = 0 ; while ( m % j == 0 ) { m /= j ; t ++ ; } if ( t ) { mp [ i ][ j ] = t ; st [ j ]. insert ( t ); } } } ll ans = 1 ; for ( ll j : prime ) { if ( st [ j ]. size () == n ) { int tem = * st [ j ]. begin (); if ( tem != last [ j ]) { ans = ans * qpow ( j , tem - last [ j ]) % mod ; last [ j ] = tem ; } } } while ( k -- ) { scanf ( \"%lld%lld\" , & pos , & m ); for ( ll j : prime ) { if ( m == 1 ) break ; if ( ! vis [ m ]) { ll & tem = mp [ pos ][ m ]; if ( tem ) st [ m ]. erase ( st [ m ]. lower_bound ( tem )); tem ++ ; st [ m ]. insert ( tem ); if ( st [ m ]. size () == n ) { int tem1 = * st [ m ]. begin (); if ( tem1 != last [ m ]) { ans = ans * qpow ( m , tem1 - last [ m ]) % mod ; last [ m ] = tem1 ; } } break ; } ll t = 0 ; while ( m % j == 0 ) { m /= j ; t ++ ; } if ( t ) { ll & tem = mp [ pos ][ j ]; if ( tem ) st [ j ]. erase ( st [ j ]. lower_bound ( tem )); tem += t ; st [ j ]. insert ( tem ); if ( st [ j ]. size () == n ) { int tem1 = * st [ j ]. begin (); if ( tem1 != last [ j ]) { ans = ans * qpow ( j , tem1 - last [ j ]) % mod ; last [ j ] = tem1 ; } } } } printf ( \"%lld \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/2021-03-09-%E6%95%B0%E8%AE%BA/","text":"\u53c2\u8003\u94fe\u63a5 \u00b6 \u4e58\u6cd5\u9006\u5143 \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u7406 \u6b27\u62c9\u51fd\u6570\u63a8\u5bfc \u6b27\u62c9\u51fd\u6570\u4ee3\u7801 \u6b27\u62c9\u51fd\u6570\u8be6\u7ec6\u63a8\u5bfc \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u6c42\u9006\u5143 \u00b6 \u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll exgcd ( ll a , ll b , ll & x , ll & y ) ///\u540e\u4e24\u4e2a\u53c2\u6570\u4e3a\u5f15\u7528 { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll gcd_ans = exgcd ( b , a % b , x , y ); ll tem = x ; x = y ; y = tem - a / b * y ; return gcd_ans ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; ll a , q , x = 0 , y = 0 ; cin >> a >> q ; ll gcd_ans = exgcd ( q , a , x , y ); ll mul = q / gcd_ans ; y = ( y % mul + mul ) % mul ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << y << endl ; } \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u8fd8\u6709\u5176\u4ed6\u5e94\u7528\uff0c\u4f8b\u5982\u6c42\u89e3\u540c\u4f59\u65b9\u7a0b\uff0c\u5176\u4f59\u8bf7\u53c2\u8003 \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u7406 \u535a\u5ba2\u3002 \u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u89e3\u9006\u5143 \u00b6 \u53ea\u9002\u7528\u4e8eq\u4e3a\u8d28\u6570\u65f6\uff0c\u53ef\u4ee5\u6c42\u89e3\u9006\u5143\u3002 \u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a , q ; ll ksm ( ll n , ll k ) { ll sum1 = 1 , sum2 = n ; while ( k != 0 ) { if ( k % 2 == 1 ) sum1 = sum1 * sum2 % q ; sum2 = sum2 * sum2 % q ; k /= 2 ; } return sum1 ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; cin >> a >> q ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << ksm ( a , q -2 ) << endl ; } \u8d39\u9a6c\u5c0f\u5b9a\u7406\u4e58\u6cd5\u9006\u5143\u4e00\u4e2a\u5e94\u7528\u4fbf\u662f\u6c42\u7ec4\u5408\u6570\uff0c\u4e00\u822c\u5bf91e9+7\u8fdb\u884c\u53d6\u4f59\uff0c\u800c1e9+7\u662f\u4e00\u4e2a\u8d28\u6570\uff0c\u53ef\u4ee5\u7528\u5c0f\u8d39\u9a6c\u5b9a\u7406\u6765\u6c42\u9006\u5143\uff0c\u4ee3\u7801\u4e3a\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll mod = 1e9 + 7 ; ll jc [ 100500 ] = { 0 }; ll ny [ 100500 ] = { 0 }; ll ksm ( ll n , ll k ) { ll sum1 = 1 , sum2 = n ; while ( k != 0 ) { if ( k % 2 == 1 ) sum1 = sum1 * sum2 % mod ; sum2 = sum2 * sum2 % mod ; k /= 2 ; } return sum1 ; } ll c ( ll n , ll m ) { if ( n < m ) swap ( n , m ); return ( jc [ n ] % mod * ny [ m ] % mod ) % mod * ny [ n - m ] % mod ; } int main () { jc [ 0 ] = 1 ; for ( int i = 1 ; i <= 100000 ; i ++ ) { jc [ i ] = jc [ i -1 ] * i ; ny [ i ] = ksm ( jc [ i ], mod -2 ); } int n , m ; cin >> n >> m ; cout << c ( n , m ) << endl ; } \u6b27\u62c9\u51fd\u6570 \u00b6 \u6b27\u62c9\u51fd\u6570\u7528\u6765\u6c42\u6bd4n\u5c0f\u4e14\u548cn\u4e92\u8d28\u5143\u7d20\u4e2a\u6570\u3002 \u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; int is_prime [ 100500 ] = { 0 }; vector < int > prime ; int oula_table [ 100500 ] = { 0 }; void init ( int n ) ///\u6253\u7d20\u6570\u8868 { for ( int i = 2 ; i <= n ; i ++ ) { if ( ! is_prime [ i ]) prime . push_back ( i ); for ( int j = 0 ; j <= prime . size () && i * prime [ j ] <= n ; j ++ ) { is_prime [ i * prime [ j ]] = 1 ; if ( i % prime [ j ] == 0 ) break ; } } } int oula1 ( int n ) ///\u6839\u636e\u7d20\u6570\u8868\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int ans = n ; for ( int i = 0 ; prime [ i ] * prime [ i ] <= n ; i ++ ) { if ( n % prime [ i ] == 0 ) ans = ans - ans / prime [ i ]; while ( n % prime [ i ] == 0 ) n /= prime [ i ]; } return ans ; } int oula2 ( int n ) ///\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int m = n ; int ans = n ; for ( int i = 2 ; i <= sqrt ( n ); i ++ ) { if ( m % i == 0 ) ans = ans - ans / i ; while ( m % i == 0 ) m /= i ; } if ( m != 1 ) ans = ans - ans / m ; return ans ; } void get_oula_table ( int n ) ///\u6b27\u62c9\u6253\u8868 { for ( int i = 1 ; i <= n ; i ++ ) oula_table [ i ] = 0 ; oula_table [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! oula_table [ i ]) ///\u8bf4\u660ei\u662f\u8d28\u6570 { for ( int j = i ; j <= n ; j += i ) //\u53bb\u627ei\u7684\u500d\u6570 { if ( ! oula_table [ j ]) oula_table [ j ] = j ; oula_table [ j ] = oula_table [ j ] / i * ( i -1 ); } } } } int main () { int n ; cin >> n ; init ( n ); cout << \"\u627e\u7d20\u6570\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula1 ( n ) << endl ; cout << \"\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula2 ( n ) << endl ; get_oula_table ( n ); cout << \"\u6253\u8868\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" ; for ( int i = 1 ; i <= n ; i ++ ) cout << oula_table [ i ] << ' ' ; } \u6b27\u62c9\u51fd\u6570\u7684\u5e94\u7528 \u8fb9\u585e\u4efb\u52a1 \u4f60\u7684\u8981\u585e\u2fa5\u6709N\u540d\u968f\u4ece\uff0c\u6bcf\u540d\u968f\u4ece\u6709\u2f00\u4e2a\u6218\u2f43\u2f12\u503cAi\uff0c\u4e0d\u540c\u968f\u4ece\u7684\u6218\u2f43\u2f12\u53ef\u4ee5\u76f8\u540c\uff0c\u4e14\u6c38\u8fdc\u4e0d\u8d85\u8fc7N\u3002\u2f00\u4e2a\u8981\u585e\u4efb\u52a1\u9700\u8981\u6070\u597dM\u4e2a\u968f\u4ece\u53c2\u4e0e\u3002 \u8981\u585e\u4efb\u52a1\u7684\u5956\u52b1\u53d6\u51b3\u4e8e\u968f\u4ece\u4eec\u914d\u5408\u7684\u7a0b\u5ea6\u3002\uff08\u663e\u2f7d\u6613\u89c1\u5730\uff09\uff0cM\u4e2a\u968f\u4ece\u7684\u8054\u5408\u6218\u2f43\u2f12A\u4e3a\u5b83\u4eec\u6218\u2f43\u2f12\u7684\u6700\u2f24\u516c\u7ea6\u6570\uff0c\u2f7d\u4efb\u52a1\u7684\u5956\u52b1\u5206\u6570\u5b9a\u4e49\u4e3a\u03d5(A)\u3002 \u6c42\u6700\u2f24\u53ef\u80fd\u7684\u5956\u52b1\u5206\u6570\u3002 \u8f93\u5165 \u672c\u9898\u6709\u591a\u7ec4\u6570\u636e\uff0c\u7b2c\u2f00\u2f8f\u4e3a\u6570\u636e\u7ec4\u6570T\uff08T\u226410\uff09\u3002 \u63a5\u4e0b\u6765\u6bcf\u7ec4\u6570\u636e\u6709\u4e24\u2f8f\uff0c\u7b2c\u2f00\u2f8f\u4e24\u4e2a\u6574\u6570N\uff0cM\uff0c\u7b2c\u2f06\u2f8fN\u4e2a\u6574\u6570Ai\uff08N\uff0cM\uff0cAi\u2264100000\uff09\u3002 \u8f93\u51fa \u6700\u591a\u7684\u5956\u52b1\u5206\u6570\u3002 \u6837\u4f8b\u8f93\u5165 1 5 2 1 4 6 9 12 \u6837\u4f8b\u8f93\u51fa 2 \u63d0\u793a \u6837\u4f8b\u89e3\u91ca\uff1a\u6d3e\u51fa\u7f16\u53f7\u4e3a6\u548c12\u7684\u968f\u4ece\uff0c\u8054\u5408\u6218\u2f43\u2f12\u4e3a3\uff0c\u5956\u52b1\u5206\u65702\u3002 \u4ee3\u7801 #include <iostream> #include <bits/stdc++.h> using namespace std ; const int N = 100000 ; typedef long long int ll ; int pd [ 100500 ] = { 0 }; //01\u6570\u7ec4\u5b58\u653e\u662f\u5426\u4e3a\u8d28\u6570 int b [ 100500 ] = { 0 }; //\u5b58\u653e\u7684\u8d28\u6570\u6570\u5217 int out [ 100500 ] = { 0 }; //\u6b27\u62c9\u51fd\u6570 \u03c6(A) int num [ 100500 ] = { 0 }; //\u8ba1\u6570\u7528\u7684 void init () { //\u6b27\u62c9\u7b5b\u6cd5 int sum = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( ! pd [ i ]) { b [ ++ sum ] = i ; out [ i ] = i - 1 ; } for ( int j = 1 ; b [ j ] * i <= N ; j ++ ) { pd [ b [ j ] * i ] = 1 ; if ( i % b [ j ] == 0 ) break ; } } //\u6c42\u03c6(A) out [ 1 ] = 1 ; int t ; for ( int i = 2 ; i <= N ; i ++ ) { if ( pd [ i ]) { out [ i ] = i ; t = i ; for ( int j = 1 ; j <= sum && t > 1 ; j ++ ) { if ( i % b [ j ] == 0 ) { out [ i ] = out [ i ] * ( b [ j ] - 1 ) / b [ j ]; //\u5957\u7528\u516c\u5f0f while ( t % b [ j ] == 0 ) { t = t / b [ j ]; } } if ( b [ j ] * 2 > i ) break ; } } } } int main () { init (); int t ; scanf ( \"%d\" , & t ); for ( int k1 = 0 ; k1 < t ; k1 ++ ) { int n , k ; int ans = -1 ; memset ( num , 0 , sizeof ( num )); //\u6e05\u7a7a\uff0c\u52ff\u5fd8@\uff01\uff01\uff01 scanf ( \"%d%d\" , & n , & k ); ll max1 = -1 ; for ( int i = 0 ; i < n ; i ++ ) { ll x ; scanf ( \"%lld\" , & x ); num [ x ] ++ ; //\u8ba1\u6570 max1 = max ( max1 , x ); } for ( int i = 1 ; i <= max1 ; i ++ ) { ll tot = 0 ; for ( int j = i ; j <= max1 ; j = j + i ) //j\u6bcf\u4e00\u6b21\u9012\u589ei\u5219\u8fd9\u4e9b\u6570\u80af\u5b9a\u6709\u4e00\u4e2a\u516c\u7ea6\u6570i { tot += num [ j ]; //\u8ba1\u6570 } if ( tot >= k ) //\u5982\u679c\u6570\u76ee\u5927\u4e8ek { ans = max ( ans , out [ i ]); //\u8ba1\u7b97 \u03c6(A) \u5e76\u6c42\u6700\u5927\u503c } } cout << ans << endl ; } return 0 ; }","title":"2021-03-09-\u6570\u8bba"},{"location":"problem/2021-03-09-%E6%95%B0%E8%AE%BA/#_1","text":"\u4e58\u6cd5\u9006\u5143 \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u7406 \u6b27\u62c9\u51fd\u6570\u63a8\u5bfc \u6b27\u62c9\u51fd\u6570\u4ee3\u7801 \u6b27\u62c9\u51fd\u6570\u8be6\u7ec6\u63a8\u5bfc \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406","title":"\u53c2\u8003\u94fe\u63a5"},{"location":"problem/2021-03-09-%E6%95%B0%E8%AE%BA/#_2","text":"\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll exgcd ( ll a , ll b , ll & x , ll & y ) ///\u540e\u4e24\u4e2a\u53c2\u6570\u4e3a\u5f15\u7528 { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll gcd_ans = exgcd ( b , a % b , x , y ); ll tem = x ; x = y ; y = tem - a / b * y ; return gcd_ans ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; ll a , q , x = 0 , y = 0 ; cin >> a >> q ; ll gcd_ans = exgcd ( q , a , x , y ); ll mul = q / gcd_ans ; y = ( y % mul + mul ) % mul ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << y << endl ; } \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u8fd8\u6709\u5176\u4ed6\u5e94\u7528\uff0c\u4f8b\u5982\u6c42\u89e3\u540c\u4f59\u65b9\u7a0b\uff0c\u5176\u4f59\u8bf7\u53c2\u8003 \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u7406 \u535a\u5ba2\u3002","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u6c42\u9006\u5143"},{"location":"problem/2021-03-09-%E6%95%B0%E8%AE%BA/#_3","text":"\u53ea\u9002\u7528\u4e8eq\u4e3a\u8d28\u6570\u65f6\uff0c\u53ef\u4ee5\u6c42\u89e3\u9006\u5143\u3002 \u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a , q ; ll ksm ( ll n , ll k ) { ll sum1 = 1 , sum2 = n ; while ( k != 0 ) { if ( k % 2 == 1 ) sum1 = sum1 * sum2 % q ; sum2 = sum2 * sum2 % q ; k /= 2 ; } return sum1 ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; cin >> a >> q ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << ksm ( a , q -2 ) << endl ; } \u8d39\u9a6c\u5c0f\u5b9a\u7406\u4e58\u6cd5\u9006\u5143\u4e00\u4e2a\u5e94\u7528\u4fbf\u662f\u6c42\u7ec4\u5408\u6570\uff0c\u4e00\u822c\u5bf91e9+7\u8fdb\u884c\u53d6\u4f59\uff0c\u800c1e9+7\u662f\u4e00\u4e2a\u8d28\u6570\uff0c\u53ef\u4ee5\u7528\u5c0f\u8d39\u9a6c\u5b9a\u7406\u6765\u6c42\u9006\u5143\uff0c\u4ee3\u7801\u4e3a\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll mod = 1e9 + 7 ; ll jc [ 100500 ] = { 0 }; ll ny [ 100500 ] = { 0 }; ll ksm ( ll n , ll k ) { ll sum1 = 1 , sum2 = n ; while ( k != 0 ) { if ( k % 2 == 1 ) sum1 = sum1 * sum2 % mod ; sum2 = sum2 * sum2 % mod ; k /= 2 ; } return sum1 ; } ll c ( ll n , ll m ) { if ( n < m ) swap ( n , m ); return ( jc [ n ] % mod * ny [ m ] % mod ) % mod * ny [ n - m ] % mod ; } int main () { jc [ 0 ] = 1 ; for ( int i = 1 ; i <= 100000 ; i ++ ) { jc [ i ] = jc [ i -1 ] * i ; ny [ i ] = ksm ( jc [ i ], mod -2 ); } int n , m ; cin >> n >> m ; cout << c ( n , m ) << endl ; }","title":"\u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u89e3\u9006\u5143"},{"location":"problem/2021-03-09-%E6%95%B0%E8%AE%BA/#_4","text":"\u6b27\u62c9\u51fd\u6570\u7528\u6765\u6c42\u6bd4n\u5c0f\u4e14\u548cn\u4e92\u8d28\u5143\u7d20\u4e2a\u6570\u3002 \u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; int is_prime [ 100500 ] = { 0 }; vector < int > prime ; int oula_table [ 100500 ] = { 0 }; void init ( int n ) ///\u6253\u7d20\u6570\u8868 { for ( int i = 2 ; i <= n ; i ++ ) { if ( ! is_prime [ i ]) prime . push_back ( i ); for ( int j = 0 ; j <= prime . size () && i * prime [ j ] <= n ; j ++ ) { is_prime [ i * prime [ j ]] = 1 ; if ( i % prime [ j ] == 0 ) break ; } } } int oula1 ( int n ) ///\u6839\u636e\u7d20\u6570\u8868\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int ans = n ; for ( int i = 0 ; prime [ i ] * prime [ i ] <= n ; i ++ ) { if ( n % prime [ i ] == 0 ) ans = ans - ans / prime [ i ]; while ( n % prime [ i ] == 0 ) n /= prime [ i ]; } return ans ; } int oula2 ( int n ) ///\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int m = n ; int ans = n ; for ( int i = 2 ; i <= sqrt ( n ); i ++ ) { if ( m % i == 0 ) ans = ans - ans / i ; while ( m % i == 0 ) m /= i ; } if ( m != 1 ) ans = ans - ans / m ; return ans ; } void get_oula_table ( int n ) ///\u6b27\u62c9\u6253\u8868 { for ( int i = 1 ; i <= n ; i ++ ) oula_table [ i ] = 0 ; oula_table [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! oula_table [ i ]) ///\u8bf4\u660ei\u662f\u8d28\u6570 { for ( int j = i ; j <= n ; j += i ) //\u53bb\u627ei\u7684\u500d\u6570 { if ( ! oula_table [ j ]) oula_table [ j ] = j ; oula_table [ j ] = oula_table [ j ] / i * ( i -1 ); } } } } int main () { int n ; cin >> n ; init ( n ); cout << \"\u627e\u7d20\u6570\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula1 ( n ) << endl ; cout << \"\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula2 ( n ) << endl ; get_oula_table ( n ); cout << \"\u6253\u8868\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" ; for ( int i = 1 ; i <= n ; i ++ ) cout << oula_table [ i ] << ' ' ; } \u6b27\u62c9\u51fd\u6570\u7684\u5e94\u7528 \u8fb9\u585e\u4efb\u52a1 \u4f60\u7684\u8981\u585e\u2fa5\u6709N\u540d\u968f\u4ece\uff0c\u6bcf\u540d\u968f\u4ece\u6709\u2f00\u4e2a\u6218\u2f43\u2f12\u503cAi\uff0c\u4e0d\u540c\u968f\u4ece\u7684\u6218\u2f43\u2f12\u53ef\u4ee5\u76f8\u540c\uff0c\u4e14\u6c38\u8fdc\u4e0d\u8d85\u8fc7N\u3002\u2f00\u4e2a\u8981\u585e\u4efb\u52a1\u9700\u8981\u6070\u597dM\u4e2a\u968f\u4ece\u53c2\u4e0e\u3002 \u8981\u585e\u4efb\u52a1\u7684\u5956\u52b1\u53d6\u51b3\u4e8e\u968f\u4ece\u4eec\u914d\u5408\u7684\u7a0b\u5ea6\u3002\uff08\u663e\u2f7d\u6613\u89c1\u5730\uff09\uff0cM\u4e2a\u968f\u4ece\u7684\u8054\u5408\u6218\u2f43\u2f12A\u4e3a\u5b83\u4eec\u6218\u2f43\u2f12\u7684\u6700\u2f24\u516c\u7ea6\u6570\uff0c\u2f7d\u4efb\u52a1\u7684\u5956\u52b1\u5206\u6570\u5b9a\u4e49\u4e3a\u03d5(A)\u3002 \u6c42\u6700\u2f24\u53ef\u80fd\u7684\u5956\u52b1\u5206\u6570\u3002 \u8f93\u5165 \u672c\u9898\u6709\u591a\u7ec4\u6570\u636e\uff0c\u7b2c\u2f00\u2f8f\u4e3a\u6570\u636e\u7ec4\u6570T\uff08T\u226410\uff09\u3002 \u63a5\u4e0b\u6765\u6bcf\u7ec4\u6570\u636e\u6709\u4e24\u2f8f\uff0c\u7b2c\u2f00\u2f8f\u4e24\u4e2a\u6574\u6570N\uff0cM\uff0c\u7b2c\u2f06\u2f8fN\u4e2a\u6574\u6570Ai\uff08N\uff0cM\uff0cAi\u2264100000\uff09\u3002 \u8f93\u51fa \u6700\u591a\u7684\u5956\u52b1\u5206\u6570\u3002 \u6837\u4f8b\u8f93\u5165 1 5 2 1 4 6 9 12 \u6837\u4f8b\u8f93\u51fa 2 \u63d0\u793a \u6837\u4f8b\u89e3\u91ca\uff1a\u6d3e\u51fa\u7f16\u53f7\u4e3a6\u548c12\u7684\u968f\u4ece\uff0c\u8054\u5408\u6218\u2f43\u2f12\u4e3a3\uff0c\u5956\u52b1\u5206\u65702\u3002 \u4ee3\u7801 #include <iostream> #include <bits/stdc++.h> using namespace std ; const int N = 100000 ; typedef long long int ll ; int pd [ 100500 ] = { 0 }; //01\u6570\u7ec4\u5b58\u653e\u662f\u5426\u4e3a\u8d28\u6570 int b [ 100500 ] = { 0 }; //\u5b58\u653e\u7684\u8d28\u6570\u6570\u5217 int out [ 100500 ] = { 0 }; //\u6b27\u62c9\u51fd\u6570 \u03c6(A) int num [ 100500 ] = { 0 }; //\u8ba1\u6570\u7528\u7684 void init () { //\u6b27\u62c9\u7b5b\u6cd5 int sum = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( ! pd [ i ]) { b [ ++ sum ] = i ; out [ i ] = i - 1 ; } for ( int j = 1 ; b [ j ] * i <= N ; j ++ ) { pd [ b [ j ] * i ] = 1 ; if ( i % b [ j ] == 0 ) break ; } } //\u6c42\u03c6(A) out [ 1 ] = 1 ; int t ; for ( int i = 2 ; i <= N ; i ++ ) { if ( pd [ i ]) { out [ i ] = i ; t = i ; for ( int j = 1 ; j <= sum && t > 1 ; j ++ ) { if ( i % b [ j ] == 0 ) { out [ i ] = out [ i ] * ( b [ j ] - 1 ) / b [ j ]; //\u5957\u7528\u516c\u5f0f while ( t % b [ j ] == 0 ) { t = t / b [ j ]; } } if ( b [ j ] * 2 > i ) break ; } } } } int main () { init (); int t ; scanf ( \"%d\" , & t ); for ( int k1 = 0 ; k1 < t ; k1 ++ ) { int n , k ; int ans = -1 ; memset ( num , 0 , sizeof ( num )); //\u6e05\u7a7a\uff0c\u52ff\u5fd8@\uff01\uff01\uff01 scanf ( \"%d%d\" , & n , & k ); ll max1 = -1 ; for ( int i = 0 ; i < n ; i ++ ) { ll x ; scanf ( \"%lld\" , & x ); num [ x ] ++ ; //\u8ba1\u6570 max1 = max ( max1 , x ); } for ( int i = 1 ; i <= max1 ; i ++ ) { ll tot = 0 ; for ( int j = i ; j <= max1 ; j = j + i ) //j\u6bcf\u4e00\u6b21\u9012\u589ei\u5219\u8fd9\u4e9b\u6570\u80af\u5b9a\u6709\u4e00\u4e2a\u516c\u7ea6\u6570i { tot += num [ j ]; //\u8ba1\u6570 } if ( tot >= k ) //\u5982\u679c\u6570\u76ee\u5927\u4e8ek { ans = max ( ans , out [ i ]); //\u8ba1\u7b97 \u03c6(A) \u5e76\u6c42\u6700\u5927\u503c } } cout << ans << endl ; } return 0 ; }","title":"\u6b27\u62c9\u51fd\u6570"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"6\u67085\u65e5\u9898\u89e3 \u00b6 \u4ea4\u6362 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2828&pid=9 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u7ed9\u51fa\u4e00\u4e2a\u5e8f\u5217A\uff0c\u5176\u4e2d\u7b2ci\u4e2a\u6570\u5b57\u4e3aai\uff0c\u4f60\u6bcf\u6b21\u53ef\u4ee5\u9009\u62e9\u4e00\u4e2a\u6570\u5b57\u4e0d\u53d8\uff0c\u5c06\u5176\u4ed6\u6570\u5b57\u5168\u90e8\u4e58\u4ee5x\u3002\u5176\u4e2dx\u4e3a\u4efb\u610f\u7d20\u6570\u3002 \u65e0\u9700\u8003\u8651\u8fd9\u4e9b\u6570\u5b57\u5728\u53d8\u6362\u8fc7\u7a0b\u4e2d\u662f\u5426\u8d85\u8fc7long long\u7684\u5b58\u50a8\u8303\u56f4\u3002\u8bf7\u56de\u7b54\uff1a\u6700\u5c11\u7ecf\u8fc7\u591a\u5c11\u6b21\u64cd\u4f5c\uff0c\u53ef\u4ee5\u4f7f\u5f97\u5e8f\u5217\u4e2d\u6240\u6709\u6570\u5b57\u5168\u90e8\u76f8\u540c\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u5305\u542b\u4e00\u4e2a\u6b63\u6574\u6570n\uff0c\u4ee3\u8868\u5e8f\u5217\u957f\u5ea6\u3002 \u63a5\u4e0b\u6765\u4e00\u884c\u5305\u542bn\u4e2a\u6b63\u6574\u6570\uff0c\u63cf\u8ff0\u5e8f\u5217\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5143\u7d20\u3002 \u8f93\u51fa \u00b6 \u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570\u8868\u793a\u7b54\u6848\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 2 5 7 \u6837\u4f8b\u8f93\u51fa \u00b6 2 \u63d0\u793a \u00b6 \u6837\u4f8b\u8bf4\u660e\uff1a \u53ef\u4ee5\u9009\u4e2d\u7b2c\u4e8c\u4e2a\u6570\u5b57\u4e0d\u53d8\uff0c\u5c06\u7b2c\u4e00\u4e2a\u6570\u5b57\u9664\u4ee55\uff0c\u7136\u540e\u9009\u4e2d\u7b2c\u4e00\u4e2a\u6570\u5b57\u4e0d\u53d8\uff0c\u5c06\u7b2c\u4e8c\u4e2a\u6570\u5b57\u9664\u4ee57\u3002\u4e24\u6b21\u64cd\u4f5c\u540e\uff0c\u6570\u7ec4\u4e2d\u6240\u6709\u6570\u5b57\u5747\u53d8\u4e3a1\u3002\u5f53\u7136\u8fd8\u6709\u5176\u4ed6\u65b9\u6cd5\uff0c\u5982\u5c06\u4e24\u4e2a\u6570\u5b57\u6700\u7ec8\u90fd\u53d8\u4e3a35\u4e5f\u53ea\u9700\u89812\u6b21\u64cd\u4f5c\u3002 \u3010\u6570\u636e\u8303\u56f4\u3011 \u5bf9\u4e8e20%\u7684\u6570\u636e\uff0c\u6ee1\u8db3n=2,ai\u2264106 \u5bf9\u4e8e40%\u7684\u6570\u636e\uff0c\u6ee1\u8db3n\u226410,ai\u2264106 \u5bf9\u4e8e\u53e6\u591620%\u7684\u6570\u636e\uff0c\u6ee1\u8db3n\u22644\u2217104,ai\u226420 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c\u6ee1\u8db31\u2264n\u2264106,1\u2264ai\u2264106 \u9898\u89e3 \u00b6 \u5bf9\u5176\u4ed6\u6570\u8fdb\u884c\u505a\u4e58\u6cd5\u76f8\u5f53\u4e8e\u5bf9\u81ea\u5df1\u505a\u4e58\u6cd5\uff0c\u53ef\u4ee5\u5bf9\u6bcf\u4e00\u4e2a\u6570\u9664\u6389\u6700\u5927\u516c\u7ea6\u6570\u4e92\u8d28\u540e\uff0c\u7edf\u8ba1\u548c\u8ba1\u7b97\u8d28\u56e0\u6570\u7684\u4e2a\u6570\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 1005000 ] = { 0 }; ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ); } ll prime [ 1005000 ] = { 0 }; ll is_prime [ 1005000 ] = { 0 }; int main () { ll cnt = 0 ; for ( ll i = 2 ; i <= 1e6 ; i ++ ) { if ( ! is_prime [ i ]) prime [ ++ cnt ] = i ; for ( ll j = 1 ; j <= cnt ; j ++ ) { if ( i * prime [ j ] > 1e6 ) break ; is_prime [ i * prime [ j ]] = 1 ; if ( i % prime [ j ] == 0 ) break ; } } ll n , m = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); m = gcd ( a [ i ], m ); } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { a [ i ] /= m ; for ( ll j = 1 ; j <= cnt && prime [ j ] * prime [ j ] <= a [ i ]; j ++ ) { while ( a [ i ] % prime [ j ] == 0 ) { ans ++ ; a [ i ] /= prime [ j ]; } } if ( a [ i ] != 1 ) ans ++ ; } printf ( \"%lld \\n \" , ans ); } Disjoint Set of Common Divisors \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2826&pid=4 \u9898\u76ee\u63cf\u8ff0 \u00b6 Given are positive integers A and B. Let us choose some number of positive common divisors of A and B. Here, any two of the chosen divisors must be coprime. At most, how many divisors can we choose? \u2192Definition of common divisor \u00b7An integer d is said to be a common divisor of integers x and y when d divides both x and y. \u2192Definition of being coprime \u00b7Integers x and y are said to be coprime when x and y have no positive common divisors other than 1. \u2192Definition of dividing \u00b7An integer x is said to divide another integer y when there exists an integer \u03b1 such that y=\u03b1x. Constraints \u00b7All values in input are integers. \u00b71\u2264A,B\u22641012 \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: A B \u8f93\u51fa \u00b6 Print the maximum number of divisors that can be chosen to satisfy the condition. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 12 18 \u3010\u6837\u4f8b2\u3011 420 660 \u3010\u6837\u4f8b3\u3011 1 2019 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 3 \u3010\u6837\u4f8b2\u3011 4 \u3010\u6837\u4f8b3\u3011 1 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca 12 and 18 have the following positive common divisors: 1, 2, 3, and 6. 1 and 2 are coprime, 2 and 3 are coprime, and 3 and 1 are coprime, so we can choose 1, 2, and 3, which achieve the maximum result. \u6837\u4f8b3\u89e3\u91ca 1 and 2019 have no positive common divisors other than 1. \u9898\u89e3 \u00b6 \u6c42gcd(A,B)\u7684\u8d28\u56e0\u6570\u6709\u591a\u5c11\u4e2a\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n , m ; cin >> n >> m ; ll k = __gcd ( n , m ); ll ans = 1 ; for ( ll i = 2 ; i * i <= k ; i ++ ) { if ( k % i == 0 ) ans ++ ; while ( k % i == 0 ) k /= i ; } if ( k != 1 ) ans ++ ; cout << ans << endl ; return 0 ; } \u725b\u725b\u7684\u6ed1\u52a8\u7a97\u53e3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2826&pid=9 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u725b\u725b\u6700\u8fd1\u5b66\u4e60\u4e86\u6ed1\u52a8\u7a97\u53e3\u7c7b\u7684\u7b97\u6cd5\uff0c\u6ed1\u52a8\u7a97\u53e3\u7b97\u6cd5\u53ef\u4ee5\u89e3\u51b3\u4e00\u4e9b\u7ebf\u6027\u6570\u7ec4\u7684\u79bb\u7ebf\u9759\u6001\u533a\u95f4\u67e5\u8be2\u7c7b\u95ee\u9898\u3002 \u5177\u4f53\u6765\u8bf4\uff0c\u5047\u8bbe\u5bf9\u4e8e\u4e00\u4e2a\u6570\u7ec4\u8fdb\u884cm\u6b21\u9759\u6001\u533a\u95f4\u67e5\u8be2\u95ee\u9898\u3002\u5982\u679c\u8fd9\u4e9b\u67e5\u8be2\u6ee1\u8db3\u6761\u4ef6\uff1a\u2200i,j\u5f53li\u2264lj\u65f6\uff0c\u603b\u6709ri\u2264rj\u3002\uff08i,j\u8868\u793a\u67e5\u8be2\u7684\u7f16\u53f7\uff0cl,r\u8868\u793a\u67e5\u8be2\u7684\u5de6\u53f3\u7aef\u70b9\uff09 \u63a5\u4e0b\u6765\u53ea\u8981\u67e5\u8be2\u7684\u95ee\u9898\u6ee1\u8db3\u53ef\u4ee5\u5feb\u901f\u63d2\u5165\u548c\u5220\u9664\u5355\u70b9\uff0c\u5c31\u53ef\u4ee5\u4f7f\u7528\u6ed1\u52a8\u7a97\u53e3\u4f18\u5316\uff0c\u5c06\u8fd9m\u6b21\u67e5\u8be2\u7684\u590d\u6742\u5ea6\u964d\u4f4e\u5230O(n)\u3002 \u663e\u7136\uff0c\u5982\u679c\u5bf9\u4e8e\u4e00\u4e2a\u6570\u7ec4\u7684\u533a\u95f4\u67e5\u8be2\u95ee\u9898\uff0c\u67e5\u8be2\u7684\u533a\u95f4\u957f\u5ea6\u7ed9\u5b9a\u4e3ak\u65f6\uff0c\u603b\u662f\u6ee1\u8db3\u2200i,j\u5f53li\u2008\u2264\u2008lj\u65f6\uff0c\u603b\u6709ri\u2264rj\u8fd9\u4e00\u6761\u4ef6\u7684\u3002 \u725b\u725b\u63a5\u4e0b\u6765\u60f3\u8981\u95ee\u4f60\u7684\u95ee\u9898\u4e5f\u548c\u5b9a\u957f\u6ed1\u52a8\u7a97\u53e3\u6709\u5173\u3002 \u4f17\u6240\u5468\u77e5\uff0c\u957f\u5ea6\u4e3ak\u7684\u6ed1\u52a8\u7a97\u53e3\u4ece\u5de6\u5230\u53f3\u53bb\u622a\u53d6\u4e00\u4e2a\u957f\u5ea6\u5927\u5c0f\u4e3an\u7684\u6570\u7ec4\u65f6\uff0c\u4e00\u5171\u53ef\u4ee5\u622a\u53d6\u5230n-k+1\u4e2a\u5b50\u6570\u7ec4\u3002 \u725b\u725b\u5c06\u8fd9n-k+1\u4e2a\u5b50\u6570\u7ec4\u7684\u6781\u5927\u503c\u4e0e\u6781\u5c0f\u503c\u7684\u4e58\u79ef\u6c42\u548c\u79f0\u4e3a\u8be5\u6570\u7ec4\u7684\"\u7b2ck\u7a97\u53e3\u503c\"\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5047\u8bbe\u957f\u5ea6\u4e3a5\u7684\u6570\u7ec4\u4e3a[1,5,2,4,3]\uff0c\u957f\u5ea6\u4e3a3\u7684\u6ed1\u52a8\u7a97\u53e3\u53ef\u4ee5\u622a\u53d6\u4e09\u4e2a\u5b50\u6570\u7ec4\uff0c\u5b83\u4eec\u5206\u522b\u4e3a[1,5,2],[5,2,4],[2,4,3]\u3002 \u6240\u4ee5\u8be5\u6570\u7ec4\u7684\u201c\u7b2c3\u7a97\u53e3\u503c\u201d\u4e3a1*5+2*5+2*4=23\u3002 \u5bf9\u4e8e\u4e00\u4e2a\u7ed9\u5b9a\u5927\u5c0f\u7684\u6570\u7ec4n\uff0c\u725b\u725b\u73b0\u5728\u60f3\u8981\u77e5\u9053\u5b83\u7684\u7b2c1,2,3,4,5...n\u7a97\u53e3\u503c\u5404\u662f\u591a\u5c11\uff0c\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u89e3\u51b3\u4ed6\u7684\u95ee\u9898\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u8f93\u5165\u4e00\u4e2a\u6b63\u6574\u6570n\uff0c\u8868\u793a\u6570\u7ec4\u7684\u5927\u5c0f\u3002 \u63a5\u4e0b\u6765\u4e00\u884c\u8f93\u5165n\u4e2a\u6b63\u6574\u6570ai\uff0c\u8868\u793a\u6570\u7ec4\u7684\u5185\u5bb9 \u8f93\u51fa \u00b6 \u8f93\u51fa\u4e00\u884cn\u4e2a\u6b63\u6574\u6570\uff0c\u8868\u793a\u6ed1\u52a8\u7a97\u53e3\u7684\u957f\u5ea6\u5206\u522b\u4e3a1,2,3,4,5...n\u65f6\uff0c\u95ee\u9898\u7684\u7b54\u6848\u3002 \u8f93\u51fa\u7684\u6574\u6570\u4e4b\u95f4\u7528\u7a7a\u683c\u9694\u5f00\uff0c\u884c\u672b\u4e0d\u5141\u8bb8\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 5 1 5 2 4 3 \u6837\u4f8b\u8f93\u51fa \u00b6 55 35 23 15 5 \u63d0\u793a \u00b6 \u6837\u4f8b\u89e3\u91ca\uff1a \u7b2c1\u7a97\u53e3\u503c=1*1+5*5+2*2+4*4+3*3=55 \u7b2c2\u7a97\u53e3\u503c=5*1+5*2+4*2+4*3=35 \u7b2c3\u7a97\u53e3\u503c=5*1+5*2+4*2=23 \u7b2c4\u7a97\u53e3\u503c=5*1+5*2=15 \u7b2c5\u7a97\u53e3\u503c=5*1=5 \u5bf9\u4e8e10%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u226410 \u5bf9\u4e8e20%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u2264100 \u5bf9\u4e8e30%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u22641000 \u5bf9\u4e8e50%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u22646000 \u5bf9\u4e8e\u53e6\u591610%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264ai\u226410 \u5bf9\u4e8e100%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u2264105,1\u2264ai\u2264100 \u9898\u89e3 \u00b6 \u6682\u672a\u60f3\u51fa\uff0c\u601d\u8def\u4e3a\u5355\u8c03\u6808\uff0c\u5f85\u8865\uff01\uff01\uff01 https://blog.csdn.net/weixin_43346722/article/details/109151074 \u4ee3\u7801 \u00b6 #include <cstdio> #include <iostream> using namespace std ; struct node { int x , num ; } bigstack [ 101 ], smallstack [ 101 ]; int n , a [ 100001 ], ans [ 100001 ], bigtop , smalltop , maxn , minn ; int lft , bignow , smallnow ; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); for ( int i = 1 ; i <= n ; i ++ ) { while ( bigtop && bigstack [ bigtop ]. x <= a [ i ]) bigtop -- ; while ( smalltop && smallstack [ smalltop ]. x >= a [ i ]) smalltop -- ; //\u6808\u7684\u5f39\u51fa bigstack [ ++ bigtop ] = ( node ){ a [ i ], i }; //\u63d2\u5165 smallstack [ ++ smalltop ] = ( node ){ a [ i ], i }; maxn = minn = a [ i ]; lft = i ; bignow = bigtop - 1 ; smallnow = smalltop - 1 ; while ( bignow || smallnow ) { //\u4e00\u70b9\u4e00\u70b9\u5f80\u540e\u79fb\uff0c\u7b97\u8d21\u732e if ( bignow && smallnow ) { if ( bigstack [ bignow ]. num >= smallstack [ smallnow ]. num ) { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - bigstack [ bignow ]. num + 1 ] -= maxn * minn ; lft = bigstack [ bignow ]. num ; maxn = bigstack [ bignow ]. x ; bignow -- ; } else { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - smallstack [ smallnow ]. num + 1 ] -= maxn * minn ; lft = smallstack [ smallnow ]. num ; minn = smallstack [ smallnow ]. x ; smallnow -- ; } continue ; } if ( bignow ) { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - bigstack [ bignow ]. num + 1 ] -= maxn * minn ; lft = bigstack [ bignow ]. num ; maxn = bigstack [ bignow ]. x ; bignow -- ; } else { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - smallstack [ smallnow ]. num + 1 ] -= maxn * minn ; lft = smallstack [ smallnow ]. num ; minn = smallstack [ smallnow ]. x ; smallnow -- ; } } ans [ i - lft + 1 ] += maxn * minn ; ans [ i + 1 ] -= maxn * minn ; } for ( int i = 1 ; i <= n ; i ++ ) { ans [ i ] += ans [ i - 1 ]; //\u56e0\u4e3a\u662f\u5dee\u5206\uff0c\u6240\u4ee5\u8981\u52a0\u4e0a\u524d\u9762\u7684 printf ( \"%d \" , ans [ i ]); } return 0 ; } \u7b49\u5dee\u5e8f\u5217\u524d\u7f00\u548c\uff08\u53cc\u524d\u7f00\u548c\uff09 \u00b6 \u542c\u8bf4\u7f57\u7fd4\u8001\u5e08\u6700\u8fd1\u5f88\u706b\u3002 \u5f20\u4e09\u4eca\u5929\u8feb\u4e0d\u53ca\u5f85\u60f3\u72af\u7f6a\u3002\u5c31\u51b3\u5b9a\u662f\u7206\u70b8\u7f6a\u4e86\uff0c\u6b63\u597d\u7f57\u8001\u5e08\u8bb2\u4e86\u8fd9\u4e2a\u6848\u4f8b\u3002 \u4ed6\u4e00\u773c\u5c31\u770b\u4e0a\u4e86 CaPeF_Yyx \u7684\u5bb6 \uff08\u6216\u8bb8\u662f\u4ed6\u592a duliu \u4e86\uff09 \u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u86ee\u4e0d\u8bb2\u7406\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u4f1a\u6ce2\u53ca\u90e8\u5206\u8857\u9053\u3002\u6bcf\u6b21\u7206\u70b8\u4f1a\u9020\u6210\u4e00\u5b9a\u7684\u635f\u574f\u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u51fa\u4eba\u610f\u6599\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u6ce2\u53ca\u7684\u8303\u56f4\u6bcf\u6b21\u90fd\u4e0d\u4e00\u6837\u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u5341\u6076\u4e0d\u8d66\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u4f1a\u8fdb\u884cm \u6b21 \uff08CaPeF_Yyx \u7684\u5bb6\u4e5f\u592a\u575a\u56fa\u4e86\u5427\uff09 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u4e95\u4e95\u6709\u6761\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u6ce2\u53ca\u7684\u8303\u56f4\u662f\u4e00\u4e2a\u95ed\u533a\u95f4\u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u7cbe\u76ca\u6c42\u7cbe\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u4ee5\u7b49\u5dee\u6570\u5217\u7684\u65b9\u5f0f\u9020\u6210\u4f24\u5bb3\u3002 CaPeF_Yyx \u5bb6\u5728\u504f\u8fdc\u89d2\u843d\uff0c\u8857\u9053\u7f16\u53f7\u4ece1~n \u3002 CaPeF_Yyx \u8857\u9053\u521a\u7ffb\u65b0\uff0c\u6bcf\u95f4\u623f\u5c4b\u7834\u574f\u7a0b\u5ea6\u90fd\u4e3a0\u3002 \u7f57\u7fd4\u8001\u5e08\u53ef\u4ee5\u9884\u6d4b\u6bcf\u6b21\u7206\u70b8\u7684\u8303\u56f4\u3002\u4f1a\u7ed9\u5230 CaPeF_Yyx \u5f62\u5982[l,r] \u7684\u95ed\u533a\u95f4\u3002 \u7f57\u7fd4\u8001\u5e08\u53ef\u4ee5\u9884\u6d4b\u6bcf\u6b21\u7206\u70b8\u7684\u4f24\u5bb3\u3002\u4f1a\u7ed9\u5230 CaPeF_Yyx \u5f62\u5982l,r,bg,ed \u7684 4 \u4e2a\u6570\u3002 \u8868\u793a\u5f62\u5982{ql,ql+1,...,qr-1,qr},ql=bg,qr=ed\u7684\u7b49\u5dee\u6570\u5217\uff0c\u5bf9\u4e8e\u8857\u9053ai(l\u2264i\u2264r)\uff0c\u9020\u6210qi\u7684\u4f24\u5bb3\u3002 CaPeF_Yyx \u627e\u5230\u4e86 Rainy7 \u4fee\u590d\u8857\u9053\u3002\u53ef\u662f\u5979\u5fc5\u987b\u5148\u77e5\u9053\u8857\u9053\u5230\u5e95\u635f\u574f\u4e86\u591a\u5c11\u3002 \u5979\u8fd8\u5fd9\u7740\u62ef\u6551\u4e16\u754c\u5462\uff0cCaPeF_Yyx \u88ab\u5413\u5f97\u4e0d\u8f7b\uff0c\u4e8e\u662f\u53ea\u80fd\u8ba9\u4f60\u5e2e\u52a9\u5979\u4e86\u3002 \u51fa\u9898\u4eba\u4e0d\u60f3\u592a duliu \uff0c\u5979\u8ba9\u4f60\u53ea\u8981\u8f93\u51fa\u6240\u6709\u623f\u5c4b\u635f\u5bb3\u7a0b\u5ea6\u7684\u6700\u5927\u503c\u548c\u5f02\u6216\u548c\u3002 Q\uff1a\u8bdd\u8bf4\u4e3a\u4ec0\u4e48\u4e0d\u76f4\u63a5\u7528\u9b54\u6cd5\u963b\u6b62\u5f20\u4e09\uff1f A\uff1a\u56e0\u4e3a \u552f\u6211\u6cd5\u5916\u72c2\u5f92\u5f20\u4e09\u6c38\u4e16\u957f\u5b58 !!! \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\uff0c\u4e24\u4e2a\u6574\u6570n,m\u8868\u793a\u623f\u5c4b\u7684\u6570\u91cf\uff0c\u548c\u7206\u70b8\u6b21\u6570\u3002 \u63a5\u4e0b\u6765m\u884c\uff0c\u6bcf\u884c\u56db\u4e2a\u6574\u6570l,r,bg,ed\uff0c\u5206\u522b\u8868\u793a\u7b49\u5dee\u6570\u5217\u7684\u9996\u9879\u6807\u53f7\uff0c\u672b\u9879\u6807\u53f7\uff0c\u9996\u9879\u503c\uff0c\u672b\u9879\u503c\u3002 \u8f93\u51fa \u00b6 \u4e00\u884c\uff0c\u4e24\u4e2a\u6570\uff0c\u5206\u522b\u8868\u793a\u6240\u6709\u623f\u5c4b\u635f\u5bb3\u7a0b\u5ea6\u7684\u6700\u5927\u503c\u548c\u5f02\u6216\u548c\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 5 2 1 5 2 10 2 4 1 1 \u3010\u6837\u4f8b2\u3011 6 2 1 5 2 10 2 4 1 1 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 3 10 \u3010\u6837\u4f8b2\u3011 3 10 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca: \u7b2c\u4e00\u6b21\u7206\u70b8\u4ea7\u751f\u7684\u4f24\u5bb3\uff1a[2,4,6,8,10]\u3002 \u7b2c\u4e8c\u6b21\u7206\u70b8\u4ea7\u751f\u7684\u4f24\u5bb3\uff1a[0,1,1,1,0]\u3002 \u6240\u6709\u7206\u70b8\u7ed3\u675f\u540e\u6bcf\u4e2a\u623f\u5c4b\u7684\u635f\u4f24\u7a0b\u5ea6\uff1a[2,5,7,9,10]\u3002 \u8f93\u51fa\u5f02\u6216\u548c\uff1a \u3002 \u8f93\u51fa\u6700\u5927\u503c\uff1a \u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; const long long int N = 1e7 + 500 ; long long int out [ N ] = { 0 }; int main () { std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( 0 ); register long long int n , m , l , r , ks , e1 , dc , tmp = 0 ; register long long int max1 = 0 , ans = 0 ; cin >> n >> m ; register long long int i ; for ( i = 1 ; i <= m ; i ++ ) { cin >> l >> r >> ks >> e1 ; dc = ( e1 - ks ) / ( r - l ); out [ l ] = out [ l ] + ks ; out [ l + 1 ] = out [ l + 1 ] + dc - ks ; out [ r + 1 ] = out [ r + 1 ] - dc - e1 ; out [ r + 2 ] = out [ r + 2 ] + e1 ; } for ( i = 1 ; i <= n ; i ++ ) { out [ i ] = out [ i - 1 ] + out [ i ]; tmp += out [ i ]; max1 = max ( max1 , tmp ); ans = ans ^ tmp ; } cout << ans << ' ' << max1 << endl ; return 0 ; }","title":"2021-06-05-6\u67085\u65e5\u9898\u89e3"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#65","text":"","title":"6\u67085\u65e5\u9898\u89e3"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"","title":"\u4ea4\u6362"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"http://icpc.upc.edu.cn/problem.php?cid=2828&pid=9","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u7ed9\u51fa\u4e00\u4e2a\u5e8f\u5217A\uff0c\u5176\u4e2d\u7b2ci\u4e2a\u6570\u5b57\u4e3aai\uff0c\u4f60\u6bcf\u6b21\u53ef\u4ee5\u9009\u62e9\u4e00\u4e2a\u6570\u5b57\u4e0d\u53d8\uff0c\u5c06\u5176\u4ed6\u6570\u5b57\u5168\u90e8\u4e58\u4ee5x\u3002\u5176\u4e2dx\u4e3a\u4efb\u610f\u7d20\u6570\u3002 \u65e0\u9700\u8003\u8651\u8fd9\u4e9b\u6570\u5b57\u5728\u53d8\u6362\u8fc7\u7a0b\u4e2d\u662f\u5426\u8d85\u8fc7long long\u7684\u5b58\u50a8\u8303\u56f4\u3002\u8bf7\u56de\u7b54\uff1a\u6700\u5c11\u7ecf\u8fc7\u591a\u5c11\u6b21\u64cd\u4f5c\uff0c\u53ef\u4ee5\u4f7f\u5f97\u5e8f\u5217\u4e2d\u6240\u6709\u6570\u5b57\u5168\u90e8\u76f8\u540c\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"\u7b2c\u4e00\u884c\u5305\u542b\u4e00\u4e2a\u6b63\u6574\u6570n\uff0c\u4ee3\u8868\u5e8f\u5217\u957f\u5ea6\u3002 \u63a5\u4e0b\u6765\u4e00\u884c\u5305\u542bn\u4e2a\u6b63\u6574\u6570\uff0c\u63cf\u8ff0\u5e8f\u5217\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5143\u7d20\u3002","title":"\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570\u8868\u793a\u7b54\u6848\u3002","title":"\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"2 5 7","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"\u6837\u4f8b\u8bf4\u660e\uff1a \u53ef\u4ee5\u9009\u4e2d\u7b2c\u4e8c\u4e2a\u6570\u5b57\u4e0d\u53d8\uff0c\u5c06\u7b2c\u4e00\u4e2a\u6570\u5b57\u9664\u4ee55\uff0c\u7136\u540e\u9009\u4e2d\u7b2c\u4e00\u4e2a\u6570\u5b57\u4e0d\u53d8\uff0c\u5c06\u7b2c\u4e8c\u4e2a\u6570\u5b57\u9664\u4ee57\u3002\u4e24\u6b21\u64cd\u4f5c\u540e\uff0c\u6570\u7ec4\u4e2d\u6240\u6709\u6570\u5b57\u5747\u53d8\u4e3a1\u3002\u5f53\u7136\u8fd8\u6709\u5176\u4ed6\u65b9\u6cd5\uff0c\u5982\u5c06\u4e24\u4e2a\u6570\u5b57\u6700\u7ec8\u90fd\u53d8\u4e3a35\u4e5f\u53ea\u9700\u89812\u6b21\u64cd\u4f5c\u3002 \u3010\u6570\u636e\u8303\u56f4\u3011 \u5bf9\u4e8e20%\u7684\u6570\u636e\uff0c\u6ee1\u8db3n=2,ai\u2264106 \u5bf9\u4e8e40%\u7684\u6570\u636e\uff0c\u6ee1\u8db3n\u226410,ai\u2264106 \u5bf9\u4e8e\u53e6\u591620%\u7684\u6570\u636e\uff0c\u6ee1\u8db3n\u22644\u2217104,ai\u226420 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c\u6ee1\u8db31\u2264n\u2264106,1\u2264ai\u2264106","title":"\u63d0\u793a"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"\u5bf9\u5176\u4ed6\u6570\u8fdb\u884c\u505a\u4e58\u6cd5\u76f8\u5f53\u4e8e\u5bf9\u81ea\u5df1\u505a\u4e58\u6cd5\uff0c\u53ef\u4ee5\u5bf9\u6bcf\u4e00\u4e2a\u6570\u9664\u6389\u6700\u5927\u516c\u7ea6\u6570\u4e92\u8d28\u540e\uff0c\u7edf\u8ba1\u548c\u8ba1\u7b97\u8d28\u56e0\u6570\u7684\u4e2a\u6570\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_10","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 1005000 ] = { 0 }; ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ); } ll prime [ 1005000 ] = { 0 }; ll is_prime [ 1005000 ] = { 0 }; int main () { ll cnt = 0 ; for ( ll i = 2 ; i <= 1e6 ; i ++ ) { if ( ! is_prime [ i ]) prime [ ++ cnt ] = i ; for ( ll j = 1 ; j <= cnt ; j ++ ) { if ( i * prime [ j ] > 1e6 ) break ; is_prime [ i * prime [ j ]] = 1 ; if ( i % prime [ j ] == 0 ) break ; } } ll n , m = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); m = gcd ( a [ i ], m ); } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { a [ i ] /= m ; for ( ll j = 1 ; j <= cnt && prime [ j ] * prime [ j ] <= a [ i ]; j ++ ) { while ( a [ i ] % prime [ j ] == 0 ) { ans ++ ; a [ i ] /= prime [ j ]; } } if ( a [ i ] != 1 ) ans ++ ; } printf ( \"%lld \\n \" , ans ); }","title":"\u4ee3\u7801"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#disjoint-set-of-common-divisors","text":"","title":"Disjoint Set of Common Divisors"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_11","text":"http://icpc.upc.edu.cn/problem.php?cid=2826&pid=4","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_12","text":"Given are positive integers A and B. Let us choose some number of positive common divisors of A and B. Here, any two of the chosen divisors must be coprime. At most, how many divisors can we choose? \u2192Definition of common divisor \u00b7An integer d is said to be a common divisor of integers x and y when d divides both x and y. \u2192Definition of being coprime \u00b7Integers x and y are said to be coprime when x and y have no positive common divisors other than 1. \u2192Definition of dividing \u00b7An integer x is said to divide another integer y when there exists an integer \u03b1 such that y=\u03b1x. Constraints \u00b7All values in input are integers. \u00b71\u2264A,B\u22641012","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_13","text":"Input is given from Standard Input in the following format: A B","title":"\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_14","text":"Print the maximum number of divisors that can be chosen to satisfy the condition.","title":"\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_15","text":"\u3010\u6837\u4f8b1\u3011 12 18 \u3010\u6837\u4f8b2\u3011 420 660 \u3010\u6837\u4f8b3\u3011 1 2019","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_16","text":"\u3010\u6837\u4f8b1\u3011 3 \u3010\u6837\u4f8b2\u3011 4 \u3010\u6837\u4f8b3\u3011 1","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_17","text":"\u6837\u4f8b1\u89e3\u91ca 12 and 18 have the following positive common divisors: 1, 2, 3, and 6. 1 and 2 are coprime, 2 and 3 are coprime, and 3 and 1 are coprime, so we can choose 1, 2, and 3, which achieve the maximum result. \u6837\u4f8b3\u89e3\u91ca 1 and 2019 have no positive common divisors other than 1.","title":"\u63d0\u793a"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_18","text":"\u6c42gcd(A,B)\u7684\u8d28\u56e0\u6570\u6709\u591a\u5c11\u4e2a\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_19","text":"#include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n , m ; cin >> n >> m ; ll k = __gcd ( n , m ); ll ans = 1 ; for ( ll i = 2 ; i * i <= k ; i ++ ) { if ( k % i == 0 ) ans ++ ; while ( k % i == 0 ) k /= i ; } if ( k != 1 ) ans ++ ; cout << ans << endl ; return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_20","text":"","title":"\u725b\u725b\u7684\u6ed1\u52a8\u7a97\u53e3"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_21","text":"http://icpc.upc.edu.cn/problem.php?cid=2826&pid=9","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_22","text":"\u725b\u725b\u6700\u8fd1\u5b66\u4e60\u4e86\u6ed1\u52a8\u7a97\u53e3\u7c7b\u7684\u7b97\u6cd5\uff0c\u6ed1\u52a8\u7a97\u53e3\u7b97\u6cd5\u53ef\u4ee5\u89e3\u51b3\u4e00\u4e9b\u7ebf\u6027\u6570\u7ec4\u7684\u79bb\u7ebf\u9759\u6001\u533a\u95f4\u67e5\u8be2\u7c7b\u95ee\u9898\u3002 \u5177\u4f53\u6765\u8bf4\uff0c\u5047\u8bbe\u5bf9\u4e8e\u4e00\u4e2a\u6570\u7ec4\u8fdb\u884cm\u6b21\u9759\u6001\u533a\u95f4\u67e5\u8be2\u95ee\u9898\u3002\u5982\u679c\u8fd9\u4e9b\u67e5\u8be2\u6ee1\u8db3\u6761\u4ef6\uff1a\u2200i,j\u5f53li\u2264lj\u65f6\uff0c\u603b\u6709ri\u2264rj\u3002\uff08i,j\u8868\u793a\u67e5\u8be2\u7684\u7f16\u53f7\uff0cl,r\u8868\u793a\u67e5\u8be2\u7684\u5de6\u53f3\u7aef\u70b9\uff09 \u63a5\u4e0b\u6765\u53ea\u8981\u67e5\u8be2\u7684\u95ee\u9898\u6ee1\u8db3\u53ef\u4ee5\u5feb\u901f\u63d2\u5165\u548c\u5220\u9664\u5355\u70b9\uff0c\u5c31\u53ef\u4ee5\u4f7f\u7528\u6ed1\u52a8\u7a97\u53e3\u4f18\u5316\uff0c\u5c06\u8fd9m\u6b21\u67e5\u8be2\u7684\u590d\u6742\u5ea6\u964d\u4f4e\u5230O(n)\u3002 \u663e\u7136\uff0c\u5982\u679c\u5bf9\u4e8e\u4e00\u4e2a\u6570\u7ec4\u7684\u533a\u95f4\u67e5\u8be2\u95ee\u9898\uff0c\u67e5\u8be2\u7684\u533a\u95f4\u957f\u5ea6\u7ed9\u5b9a\u4e3ak\u65f6\uff0c\u603b\u662f\u6ee1\u8db3\u2200i,j\u5f53li\u2008\u2264\u2008lj\u65f6\uff0c\u603b\u6709ri\u2264rj\u8fd9\u4e00\u6761\u4ef6\u7684\u3002 \u725b\u725b\u63a5\u4e0b\u6765\u60f3\u8981\u95ee\u4f60\u7684\u95ee\u9898\u4e5f\u548c\u5b9a\u957f\u6ed1\u52a8\u7a97\u53e3\u6709\u5173\u3002 \u4f17\u6240\u5468\u77e5\uff0c\u957f\u5ea6\u4e3ak\u7684\u6ed1\u52a8\u7a97\u53e3\u4ece\u5de6\u5230\u53f3\u53bb\u622a\u53d6\u4e00\u4e2a\u957f\u5ea6\u5927\u5c0f\u4e3an\u7684\u6570\u7ec4\u65f6\uff0c\u4e00\u5171\u53ef\u4ee5\u622a\u53d6\u5230n-k+1\u4e2a\u5b50\u6570\u7ec4\u3002 \u725b\u725b\u5c06\u8fd9n-k+1\u4e2a\u5b50\u6570\u7ec4\u7684\u6781\u5927\u503c\u4e0e\u6781\u5c0f\u503c\u7684\u4e58\u79ef\u6c42\u548c\u79f0\u4e3a\u8be5\u6570\u7ec4\u7684\"\u7b2ck\u7a97\u53e3\u503c\"\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5047\u8bbe\u957f\u5ea6\u4e3a5\u7684\u6570\u7ec4\u4e3a[1,5,2,4,3]\uff0c\u957f\u5ea6\u4e3a3\u7684\u6ed1\u52a8\u7a97\u53e3\u53ef\u4ee5\u622a\u53d6\u4e09\u4e2a\u5b50\u6570\u7ec4\uff0c\u5b83\u4eec\u5206\u522b\u4e3a[1,5,2],[5,2,4],[2,4,3]\u3002 \u6240\u4ee5\u8be5\u6570\u7ec4\u7684\u201c\u7b2c3\u7a97\u53e3\u503c\u201d\u4e3a1*5+2*5+2*4=23\u3002 \u5bf9\u4e8e\u4e00\u4e2a\u7ed9\u5b9a\u5927\u5c0f\u7684\u6570\u7ec4n\uff0c\u725b\u725b\u73b0\u5728\u60f3\u8981\u77e5\u9053\u5b83\u7684\u7b2c1,2,3,4,5...n\u7a97\u53e3\u503c\u5404\u662f\u591a\u5c11\uff0c\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u89e3\u51b3\u4ed6\u7684\u95ee\u9898\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_23","text":"\u7b2c\u4e00\u884c\u8f93\u5165\u4e00\u4e2a\u6b63\u6574\u6570n\uff0c\u8868\u793a\u6570\u7ec4\u7684\u5927\u5c0f\u3002 \u63a5\u4e0b\u6765\u4e00\u884c\u8f93\u5165n\u4e2a\u6b63\u6574\u6570ai\uff0c\u8868\u793a\u6570\u7ec4\u7684\u5185\u5bb9","title":"\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_24","text":"\u8f93\u51fa\u4e00\u884cn\u4e2a\u6b63\u6574\u6570\uff0c\u8868\u793a\u6ed1\u52a8\u7a97\u53e3\u7684\u957f\u5ea6\u5206\u522b\u4e3a1,2,3,4,5...n\u65f6\uff0c\u95ee\u9898\u7684\u7b54\u6848\u3002 \u8f93\u51fa\u7684\u6574\u6570\u4e4b\u95f4\u7528\u7a7a\u683c\u9694\u5f00\uff0c\u884c\u672b\u4e0d\u5141\u8bb8\u6709\u591a\u4f59\u7a7a\u683c\u3002","title":"\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_25","text":"5 1 5 2 4 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_26","text":"55 35 23 15 5","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_27","text":"\u6837\u4f8b\u89e3\u91ca\uff1a \u7b2c1\u7a97\u53e3\u503c=1*1+5*5+2*2+4*4+3*3=55 \u7b2c2\u7a97\u53e3\u503c=5*1+5*2+4*2+4*3=35 \u7b2c3\u7a97\u53e3\u503c=5*1+5*2+4*2=23 \u7b2c4\u7a97\u53e3\u503c=5*1+5*2=15 \u7b2c5\u7a97\u53e3\u503c=5*1=5 \u5bf9\u4e8e10%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u226410 \u5bf9\u4e8e20%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u2264100 \u5bf9\u4e8e30%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u22641000 \u5bf9\u4e8e50%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u22646000 \u5bf9\u4e8e\u53e6\u591610%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264ai\u226410 \u5bf9\u4e8e100%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u2264105,1\u2264ai\u2264100","title":"\u63d0\u793a"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_28","text":"\u6682\u672a\u60f3\u51fa\uff0c\u601d\u8def\u4e3a\u5355\u8c03\u6808\uff0c\u5f85\u8865\uff01\uff01\uff01 https://blog.csdn.net/weixin_43346722/article/details/109151074","title":"\u9898\u89e3"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_29","text":"#include <cstdio> #include <iostream> using namespace std ; struct node { int x , num ; } bigstack [ 101 ], smallstack [ 101 ]; int n , a [ 100001 ], ans [ 100001 ], bigtop , smalltop , maxn , minn ; int lft , bignow , smallnow ; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); for ( int i = 1 ; i <= n ; i ++ ) { while ( bigtop && bigstack [ bigtop ]. x <= a [ i ]) bigtop -- ; while ( smalltop && smallstack [ smalltop ]. x >= a [ i ]) smalltop -- ; //\u6808\u7684\u5f39\u51fa bigstack [ ++ bigtop ] = ( node ){ a [ i ], i }; //\u63d2\u5165 smallstack [ ++ smalltop ] = ( node ){ a [ i ], i }; maxn = minn = a [ i ]; lft = i ; bignow = bigtop - 1 ; smallnow = smalltop - 1 ; while ( bignow || smallnow ) { //\u4e00\u70b9\u4e00\u70b9\u5f80\u540e\u79fb\uff0c\u7b97\u8d21\u732e if ( bignow && smallnow ) { if ( bigstack [ bignow ]. num >= smallstack [ smallnow ]. num ) { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - bigstack [ bignow ]. num + 1 ] -= maxn * minn ; lft = bigstack [ bignow ]. num ; maxn = bigstack [ bignow ]. x ; bignow -- ; } else { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - smallstack [ smallnow ]. num + 1 ] -= maxn * minn ; lft = smallstack [ smallnow ]. num ; minn = smallstack [ smallnow ]. x ; smallnow -- ; } continue ; } if ( bignow ) { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - bigstack [ bignow ]. num + 1 ] -= maxn * minn ; lft = bigstack [ bignow ]. num ; maxn = bigstack [ bignow ]. x ; bignow -- ; } else { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - smallstack [ smallnow ]. num + 1 ] -= maxn * minn ; lft = smallstack [ smallnow ]. num ; minn = smallstack [ smallnow ]. x ; smallnow -- ; } } ans [ i - lft + 1 ] += maxn * minn ; ans [ i + 1 ] -= maxn * minn ; } for ( int i = 1 ; i <= n ; i ++ ) { ans [ i ] += ans [ i - 1 ]; //\u56e0\u4e3a\u662f\u5dee\u5206\uff0c\u6240\u4ee5\u8981\u52a0\u4e0a\u524d\u9762\u7684 printf ( \"%d \" , ans [ i ]); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_30","text":"\u542c\u8bf4\u7f57\u7fd4\u8001\u5e08\u6700\u8fd1\u5f88\u706b\u3002 \u5f20\u4e09\u4eca\u5929\u8feb\u4e0d\u53ca\u5f85\u60f3\u72af\u7f6a\u3002\u5c31\u51b3\u5b9a\u662f\u7206\u70b8\u7f6a\u4e86\uff0c\u6b63\u597d\u7f57\u8001\u5e08\u8bb2\u4e86\u8fd9\u4e2a\u6848\u4f8b\u3002 \u4ed6\u4e00\u773c\u5c31\u770b\u4e0a\u4e86 CaPeF_Yyx \u7684\u5bb6 \uff08\u6216\u8bb8\u662f\u4ed6\u592a duliu \u4e86\uff09 \u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u86ee\u4e0d\u8bb2\u7406\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u4f1a\u6ce2\u53ca\u90e8\u5206\u8857\u9053\u3002\u6bcf\u6b21\u7206\u70b8\u4f1a\u9020\u6210\u4e00\u5b9a\u7684\u635f\u574f\u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u51fa\u4eba\u610f\u6599\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u6ce2\u53ca\u7684\u8303\u56f4\u6bcf\u6b21\u90fd\u4e0d\u4e00\u6837\u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u5341\u6076\u4e0d\u8d66\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u4f1a\u8fdb\u884cm \u6b21 \uff08CaPeF_Yyx \u7684\u5bb6\u4e5f\u592a\u575a\u56fa\u4e86\u5427\uff09 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u4e95\u4e95\u6709\u6761\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u6ce2\u53ca\u7684\u8303\u56f4\u662f\u4e00\u4e2a\u95ed\u533a\u95f4\u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u7cbe\u76ca\u6c42\u7cbe\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u4ee5\u7b49\u5dee\u6570\u5217\u7684\u65b9\u5f0f\u9020\u6210\u4f24\u5bb3\u3002 CaPeF_Yyx \u5bb6\u5728\u504f\u8fdc\u89d2\u843d\uff0c\u8857\u9053\u7f16\u53f7\u4ece1~n \u3002 CaPeF_Yyx \u8857\u9053\u521a\u7ffb\u65b0\uff0c\u6bcf\u95f4\u623f\u5c4b\u7834\u574f\u7a0b\u5ea6\u90fd\u4e3a0\u3002 \u7f57\u7fd4\u8001\u5e08\u53ef\u4ee5\u9884\u6d4b\u6bcf\u6b21\u7206\u70b8\u7684\u8303\u56f4\u3002\u4f1a\u7ed9\u5230 CaPeF_Yyx \u5f62\u5982[l,r] \u7684\u95ed\u533a\u95f4\u3002 \u7f57\u7fd4\u8001\u5e08\u53ef\u4ee5\u9884\u6d4b\u6bcf\u6b21\u7206\u70b8\u7684\u4f24\u5bb3\u3002\u4f1a\u7ed9\u5230 CaPeF_Yyx \u5f62\u5982l,r,bg,ed \u7684 4 \u4e2a\u6570\u3002 \u8868\u793a\u5f62\u5982{ql,ql+1,...,qr-1,qr},ql=bg,qr=ed\u7684\u7b49\u5dee\u6570\u5217\uff0c\u5bf9\u4e8e\u8857\u9053ai(l\u2264i\u2264r)\uff0c\u9020\u6210qi\u7684\u4f24\u5bb3\u3002 CaPeF_Yyx \u627e\u5230\u4e86 Rainy7 \u4fee\u590d\u8857\u9053\u3002\u53ef\u662f\u5979\u5fc5\u987b\u5148\u77e5\u9053\u8857\u9053\u5230\u5e95\u635f\u574f\u4e86\u591a\u5c11\u3002 \u5979\u8fd8\u5fd9\u7740\u62ef\u6551\u4e16\u754c\u5462\uff0cCaPeF_Yyx \u88ab\u5413\u5f97\u4e0d\u8f7b\uff0c\u4e8e\u662f\u53ea\u80fd\u8ba9\u4f60\u5e2e\u52a9\u5979\u4e86\u3002 \u51fa\u9898\u4eba\u4e0d\u60f3\u592a duliu \uff0c\u5979\u8ba9\u4f60\u53ea\u8981\u8f93\u51fa\u6240\u6709\u623f\u5c4b\u635f\u5bb3\u7a0b\u5ea6\u7684\u6700\u5927\u503c\u548c\u5f02\u6216\u548c\u3002 Q\uff1a\u8bdd\u8bf4\u4e3a\u4ec0\u4e48\u4e0d\u76f4\u63a5\u7528\u9b54\u6cd5\u963b\u6b62\u5f20\u4e09\uff1f A\uff1a\u56e0\u4e3a \u552f\u6211\u6cd5\u5916\u72c2\u5f92\u5f20\u4e09\u6c38\u4e16\u957f\u5b58 !!!","title":"\u7b49\u5dee\u5e8f\u5217\u524d\u7f00\u548c\uff08\u53cc\u524d\u7f00\u548c\uff09"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_31","text":"\u7b2c\u4e00\u884c\uff0c\u4e24\u4e2a\u6574\u6570n,m\u8868\u793a\u623f\u5c4b\u7684\u6570\u91cf\uff0c\u548c\u7206\u70b8\u6b21\u6570\u3002 \u63a5\u4e0b\u6765m\u884c\uff0c\u6bcf\u884c\u56db\u4e2a\u6574\u6570l,r,bg,ed\uff0c\u5206\u522b\u8868\u793a\u7b49\u5dee\u6570\u5217\u7684\u9996\u9879\u6807\u53f7\uff0c\u672b\u9879\u6807\u53f7\uff0c\u9996\u9879\u503c\uff0c\u672b\u9879\u503c\u3002","title":"\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_32","text":"\u4e00\u884c\uff0c\u4e24\u4e2a\u6570\uff0c\u5206\u522b\u8868\u793a\u6240\u6709\u623f\u5c4b\u635f\u5bb3\u7a0b\u5ea6\u7684\u6700\u5927\u503c\u548c\u5f02\u6216\u548c\u3002","title":"\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_33","text":"\u3010\u6837\u4f8b1\u3011 5 2 1 5 2 10 2 4 1 1 \u3010\u6837\u4f8b2\u3011 6 2 1 5 2 10 2 4 1 1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_34","text":"\u3010\u6837\u4f8b1\u3011 3 10 \u3010\u6837\u4f8b2\u3011 3 10","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_35","text":"\u6837\u4f8b1\u89e3\u91ca: \u7b2c\u4e00\u6b21\u7206\u70b8\u4ea7\u751f\u7684\u4f24\u5bb3\uff1a[2,4,6,8,10]\u3002 \u7b2c\u4e8c\u6b21\u7206\u70b8\u4ea7\u751f\u7684\u4f24\u5bb3\uff1a[0,1,1,1,0]\u3002 \u6240\u6709\u7206\u70b8\u7ed3\u675f\u540e\u6bcf\u4e2a\u623f\u5c4b\u7684\u635f\u4f24\u7a0b\u5ea6\uff1a[2,5,7,9,10]\u3002 \u8f93\u51fa\u5f02\u6216\u548c\uff1a \u3002 \u8f93\u51fa\u6700\u5927\u503c\uff1a \u3002","title":"\u63d0\u793a"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_36","text":"#include <bits/stdc++.h> using namespace std ; const long long int N = 1e7 + 500 ; long long int out [ N ] = { 0 }; int main () { std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( 0 ); register long long int n , m , l , r , ks , e1 , dc , tmp = 0 ; register long long int max1 = 0 , ans = 0 ; cin >> n >> m ; register long long int i ; for ( i = 1 ; i <= m ; i ++ ) { cin >> l >> r >> ks >> e1 ; dc = ( e1 - ks ) / ( r - l ); out [ l ] = out [ l ] + ks ; out [ l + 1 ] = out [ l + 1 ] + dc - ks ; out [ r + 1 ] = out [ r + 1 ] - dc - e1 ; out [ r + 2 ] = out [ r + 2 ] + e1 ; } for ( i = 1 ; i <= n ; i ++ ) { out [ i ] = out [ i - 1 ] + out [ i ]; tmp += out [ i ]; max1 = max ( max1 , tmp ); ans = ans ^ tmp ; } cout << ans << ' ' << max1 << endl ; return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/_coverpage/","text":"Tim-wcx \u00b6 \u4e2a\u4eba\u6587\u6863\u7f51\u7ad9 \u00b6 GitHub Get Started","title":"Tim-wcx"},{"location":"problem/_coverpage/#tim-wcx","text":"","title":"Tim-wcx"},{"location":"problem/_coverpage/#_1","text":"GitHub Get Started","title":"\u4e2a\u4eba\u6587\u6863\u7f51\u7ad9"},{"location":"problem/_sidebar/","text":"\u4e0a\u4e00\u7ea7 ICPC\u9898\u89e3 \u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u56db\uff09 \u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e09\uff09 \u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e8c\uff09 \u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e00\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e94\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u56db\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e09\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e8c\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e00\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e5d\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516b\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e03\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516d\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e94\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u56db\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e09\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e8c\uff09 \u6691\u5047\u96c6\u8bad\u9898\u89e3\u7cfb\u5217\uff08\u4e00\uff09 2021-02-02-2\u67082\u65e5\u9898\u89e3 2021-02-07-2\u67087\u65e5\u9898\u89e3 2021-02-02-2\u67082\u65e5\u9898\u89e3 2021-02-07-2\u67087\u65e5\u9898\u89e3 2021-02-08-2\u67088\u65e5\u9898\u89e3 2021-02-09-2\u67089\u65e5\u9898\u89e3 2021-02-12-\u5b89\u5353\u8bfe\u8868\u5ba2\u6237\u7aef+\u670d\u52a1\u7aef\u6ce8\u89e3 2021-02-16-2\u670816\u65e5\u9898\u89e3 2021-02-19-2\u670819\u65e5\u9898\u89e3 2021-02-20-2\u670820\u65e5\u9898\u89e3 2021-02-22-2\u670822\u65e5\u9898\u89e3 2021-02-24-2\u670824\u65e5\u9898\u89e3 2021-02-28-2\u670828\u65e5\u9898\u89e3 2021-03-02-3\u67082\u65e5\u9898\u89e3 2021-03-07-3\u67087\u65e5\u9898\u89e3 2021-03-09-\u6570\u8bba 2021-06-05-6\u67085\u65e5\u9898\u89e3","title":" sidebar"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e03\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Cow Steeplechase \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has a brilliant idea for the next great spectator sport: Cow Steeplechase! As everyone knows, regular steeplechase involves a group of horses that race around a course filled with obstacles they must jump over.FJ figures the same contest should work with highly-trained cows, as long as the obstacles are made short enough. In order to design his course, FJ makes a diagram of all the N (1 <= N <=250) possible obstacles he could potentially build. Each one is represented by a line segment in the 2D plane that is parallel to the horizontal or vertical axis. Obstacle i has distinct endpoints (X1_i, Y1_i) and (X2_i, Y2_i) (1 <= X1_i, Y1_i, X2_i, Y2_i <= 1,000,000,000). An example is as follows: --+------- -----+----- ---+--- | | | | --+-----+--+- | | | | | | | --+--+--+-+- | | | | | FJ would like to build as many of these obstacles as possible, subject to the constraint that no two of them intersect. Starting with the diagram above, FJ can build 7 obstacles: ---------- ----------- ------- | | | | | | | | | | | | | | | | | | | Two segments are said to intersect if they share any point in common, even an endpoint of one or both of the segments. FJ is certain that no two horizontal segments in the original input diagram will intersect, and that similarly no two vertical segments in the input diagram will intersect. Please help FJ determine the maximum number of obstacles he can build. \u8f93\u5165 \u00b6 Line 1: A single integer: N. Lines 2..N+1: Line i+1 contains four space-separated integers representing an obstacle: X1_i, Y1_i, X2_i, and Y2_i. \u8f93\u51fa \u00b6 Line 1: The maximum number of non-crossing segments FJ can choose. \u6837\u4f8b\u8f93\u5165 \u00b6 3 4 5 10 5 6 2 6 12 8 3 8 5 \u6837\u4f8b\u8f93\u51fa \u00b6 2 \u63d0\u793a \u00b6 There are three potential obstacles. The first is a horizontal segment connecting (4, 5) to (10, 5); the second and third are vertical segments connecting (6, 2) to (6, 12) and (8, 3) to (8, 5).The optimal solution is to choose both vertical segments. \u9898\u89e3 \u00b6 \u7f51\u7edc\u6d41\u7b97\u6cd5\uff0c\u5c06\u6a2a\u5411\u76f4\u7ebf\u6807\u53f7\u5e76\u4e0e\u6e90\u70b9\u5efa\u8fb9\uff0c\u5e76\u8d4b\u6743\u503c1\uff1b\u5c06\u7eb5\u5411\u76f4\u7ebf\u6807\u53f7\u4e0e\u6c47\u70b9\u5efa\u8fb9\uff0c\u8d4b\u6743\u503c1\uff1b\u5c06\u6a2a\u7eb5\u4ea4\u53c9\u7684\u76f4\u7ebf\u5efa\u8fb9\uff0c\u8d4b\u6743\u503c\u4e3a\u6b63\u65e0\u7a77\uff1b\u7531\u6700\u5927\u6d41\u7b49\u4e8e\u6700\u5c0f\u5272\uff0c\u6240\u4ee5\u6839\u636eEK\u7b97\u6cd5\u6216\u8005Dinic\u7b97\u6cd5\u7b97\u51fa\u6700\u5927\u6d41\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll to , val , next ; }; node edge [ 100500 ] = { 0 }; ll head [ 4050 ] = { 0 }; ll cnt = 0 ; ll s = 1 , e = 1 ; void add_edge ( ll from , ll to , ll val ) { edge [ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. val = val ; head [ from ] = cnt ++ ; } ll pre [ 4050 ] = { 0 }, tag [ 4050 ] = { 0 }, vis [ 4050 ] = { 0 }; ll bfs () { queue < ll > que ; memset ( tag , 0 , sizeof ( tag )); memset ( pre , 0 , sizeof ( pre )); memset ( vis , 0 , sizeof ( vis )); que . push ( s ); vis [ s ] = 1 ; while ( ! que . empty ()) { ll now = que . front (); que . pop (); for ( ll i = head [ now ]; i != -1 ; i = edge [ i ]. next ) { ll to = edge [ i ]. to , val = edge [ i ]. val ; if ( ! vis [ to ] && val > 0 ) { vis [ to ] = 1 ; pre [ to ] = now ; tag [ to ] = i ; if ( to == e ) return 1 ; que . push ( to ); } } } return 0 ; } ll EK () { ll ans = 0 ; while ( bfs ()) { ll min1 = inf ; for ( ll i = e ; i != s ; i = pre [ i ]) { min1 = min ( min1 , edge [ tag [ i ]]. val ); } for ( ll i = e ; i != s ; i = pre [ i ]) { edge [ tag [ i ]]. val -= min1 ; edge [ tag [ i ] ^ 1 ]. val += min1 ; } ans += min1 ; } return ans ; } struct node1 { ll x1 , y1 , x2 , y2 , num ; }; node1 a [ 4050 ] = { 0 }, b [ 4050 ] = { 0 }; ll cnta = 0 , cntb = 0 ; int main () { //freopen(\"in.txt\", \"r\", stdin); ll n ; scanf ( \"%lld\" , & n ); ll x1 , x2 , y1 , y2 ; for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); if ( x1 > x2 ) swap ( x1 , x2 ); if ( y1 > y2 ) swap ( y1 , y2 ); if ( x1 == x2 ) a [ ++ cnta ] = { x1 , y1 , x2 , y2 , i }; else b [ ++ cntb ] = { x1 , y1 , x2 , y2 , i }; } for ( ll i = 0 ; i < 4050 ; i ++ ) head [ i ] = -1 ; e = 4000 , s = 0 ; for ( ll i = 1 ; i <= cnta ; i ++ ) { add_edge ( s , a [ i ]. num , 1 ); add_edge ( a [ i ]. num , s , 0 ); //cout << s << ' ' << a[i].num << ' ' << 1 << endl; } for ( ll i = 1 ; i <= cntb ; i ++ ) { add_edge ( e , b [ i ]. num , 0 ); add_edge ( b [ i ]. num , e , 1 ); //cout << e << ' ' << b[i].num << ' ' << 1 << endl; } for ( ll i = 1 ; i <= cnta ; i ++ ) { for ( ll j = 1 ; j <= cntb ; j ++ ) { if (( b [ j ]. x1 <= a [ i ]. x1 && a [ i ]. x1 <= b [ j ]. x2 ) && ( a [ i ]. y1 <= b [ j ]. y1 && b [ j ]. y1 <= a [ i ]. y2 )) { add_edge ( a [ i ]. num , b [ j ]. num , inf ); add_edge ( b [ j ]. num , a [ i ]. num , 0 ); //cout << a[i].num << ' ' << b[j].num << ' ' << inf << endl; } } } printf ( \"%lld \\n \" , n - EK ()); } \u8be5\u9898\u53e6\u5916\u4e00\u79cd\u505a\u6cd5\u4e3a\u4e8c\u5206\u56fe\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; vector < int > v [ 1005 ]; map < int , int > mp , vis , mp1 ; int dfs ( int now ) { for ( int i = 0 ; i < v [ now ]. size (); i ++ ) { int to = v [ now ][ i ]; if ( ! vis [ to ]) { vis [ to ] = 1 ; if ( mp [ to ] == 0 || dfs ( mp [ to ])) { mp [ to ] = now ; mp1 [ now ] = to ; return 1 ; } } } return 0 ; } struct node1 { ll x1 , y1 , x2 , y2 , num ; }; node1 a [ 4050 ] = { 0 }, b [ 4050 ] = { 0 }; ll cnta = 0 , cntb = 0 ; int main () { ll n ; scanf ( \"%lld\" , & n ); ll x1 , x2 , y1 , y2 ; for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); if ( x1 > x2 ) swap ( x1 , x2 ); if ( y1 > y2 ) swap ( y1 , y2 ); if ( x1 == x2 ) { cnta ++ ; a [ cnta ] = { x1 , y1 , x2 , y2 , cnta }; } else { cntb ++ ; b [ cntb ] = { x1 , y1 , x2 , y2 , cntb }; } } for ( ll i = 1 ; i <= cnta ; i ++ ) { for ( ll j = 1 ; j <= cntb ; j ++ ) { if (( b [ j ]. x1 <= a [ i ]. x1 && a [ i ]. x1 <= b [ j ]. x2 ) && ( a [ i ]. y1 <= b [ j ]. y1 && b [ j ]. y1 <= a [ i ]. y2 )) { v [ a [ i ]. num ]. push_back ( b [ j ]. num ); } } } int ans = 0 ; for ( int i = 1 ; i <= cnta ; i ++ ) { vis . clear (); ans += dfs ( i ); } cout << n - ans << endl ; } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Above the Median \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has lined up his N (1 <= N <= 100,000) cows in a row to measure their heights; cow i has height H_i (1 <= H_i <= 1,000,000,000) nanometers--FJ believes in precise measurements! He wants to take a picture of some contiguous subsequence of the cows to submit to a bovine photography contest at the county fair. The fair has a very strange rule about all submitted photos: a photograph is only valid to submit if it depicts a group of cows whose median height is at least a certain threshold X (1 <= X <= 1,000,000,000). For purposes of this problem, we define the median of an array A[0...K] to be A[ceiling(K/2)] after A is sorted, where ceiling(K/2) gives K/2 rounded up to the nearest integer (or K/2 itself, it K/2 is an integer to begin with). For example the median of {7, 3, 2, 6} is 6, and the median of {5, 4, 8} is 5. Please help FJ count the number of different contiguous subsequences of his cows that he could potentially submit to the photography contest. \u8f93\u5165 \u00b6 * Line 1: Two space-separated integers: N and X. * Lines 2..N+1: Line i+1 contains the single integer H_i. \u8f93\u51fa \u00b6 * Line 1: The number of subsequences of FJ's cows that have median at least X. Note this may not fit into a 32-bit integer. \u6837\u4f8b\u8f93\u5165 \u00b6 4 6 10 5 6 2 \u6837\u4f8b\u8f93\u51fa \u00b6 7 \u63d0\u793a \u00b6 FJ's four cows have heights 10, 5, 6, 2. We want to know how many contiguous subsequences have median at least 6.There are 10 possible contiguous subsequences to consider. Of these, only 7 have median at least 6. They are {10}, {6}, {10, 5}, {5, 6}, {6, 2}, {10,5, 6}, {10, 5, 6, 2}. \u9898\u89e3 \u00b6 sum\u6570\u7ec4\u8bb0\u5f55\u6c42\u51fa\u5927\u4e8ek\u7684\u6570\u5b57\u4e2a\u6570\u7684\u524d\u7f00\u548c\uff0c\u5219\u9898\u76ee\u53ef\u4ee5\u8f6c\u53d8\u4e3a\u5bfb\u627e\u533a\u95f4[l,r]\u6ee1\u8db3sum[r]-sum[l-1]>=0\uff0c\u5229\u7528\u6811\u72b6\u6570\u7ec4\u67e5\u627e\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll tree [ 300500 ] = { 0 }; ll maxn = 300500 ; ll lowbit ( ll n ) { return n & ( - n ); } void add ( ll pos , ll val ) { for ( ll i = pos ; i <= maxn ; i += lowbit ( i )) tree [ i ] += val ; } ll query ( ll pos ) { ll ans = 0 ; for ( ll i = pos ; i > 0 ; i -= lowbit ( i )) ans += tree [ i ]; return ans ; } int main () { ll n , m , k , sum = 0 , ans = 0 ; scanf ( \"%lld%lld\" , & n , & k ) add ( n , 1 ); ///\u4e3a\u9632\u6b62\u8d1f\u6570\u51fa\u73b0\uff0c\u7edf\u4e00\u52a0n\uff0c\u8fd9\u91cc\u521d\u59cb\u5316\u589e\u6dfb\u4e00\u4e2a0 for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & m ); if ( m < k ) sum -= 1 ; else sum += 1 ; ans += query ( sum + n ); add ( sum + n , 1 ); } cout << ans << endl ; } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Eddy Walker \u9898\u76ee\u63cf\u8ff0 \u00b6 Eddy likes to walk around. Especially, he likes to walk in a loop called \"Infinite loop\". But, actually, it's just a loop with finite length(Anyway, the name doesn't matter). Eddy can walk in a fixed length. He finds that it takes him N steps to walk through the loop a cycle. Then, he puts N marks on the \"Infinite loop\" labeled with 0,1,\u2026,N\u22121, where i and i+1 are a step away each other, so as 0 and N-1. After that, Eddy stands on the mark labeled 0 and start walking around. For each step, Eddy will independently uniformly randomly choose to move forward or backward. If currently Eddy is on the mark labeled i, he will on the mark labeled i+1 if move forward or i-1 if move backward. If Eddy is on the mark labeled N-1 and moves forward, he will stand on the mark labeled 0. If Eddy is on the mark labeled 0 and moves backward, he will stand on the mark labeled N-1. Although, Eddy likes to walk around. He will get bored after he reaches each mark at least once. After that, Eddy will pick up all the marks, go back to work and stop walking around. You, somehow, notice the weird convention Eddy is doing. And, you record T scenarios that Eddy walks around. For i-th scenario, you record two numbers Ni, Mi, where Ni tells that in the i-th scenario, Eddy can walk through the loop a cycle in exactly Ni steps(Yes! Eddy can walk in different fixed length for different day.). While Mi tells that you found that in the i-th scenario, after Eddy stands on the mark labeled Mi, he reached all the marks. However, when you review your records, you are not sure whether the data is correct or even possible. Thus, you want to know the probability that those scenarios will happen. Precisely, you are going to compute the probability that first i scenarios will happen sequentially for each i. \u8f93\u5165 \u00b6 The first line of input contains an integers T. Following T lines each contains two space-separated integers Ni and Mi. 1\u2264T\u22641021 0\u2264Mi<Ni\u2264109 \u8f93\u51fa \u00b6 Output T lines each contains an integer representing the probability that first i scenarios will happen sequentially. you should output the number module 109+7(1000000007). Suppose the probability is P/Q, the desired output will be P\u00d7Q\u22121 mod 109+7 \u6837\u4f8b\u8f93\u5165 \u00b6 3 1 0 2 1 3 0 \u6837\u4f8b\u8f93\u51fa \u00b6 1 1 0 \u9898\u89e3 \u00b6 \u6253\u8868\u627e\u89c4\u5f8b\uff0c\u6253\u8868\u4ee3\u7801\u5982\u4e0b\uff1a #include <iostream> #include <cstdlib> #include <cstring> #include <ctime> using namespace std ; int num [ 520 ]; bool vis [ 520 ]; int main (){ srand (( unsigned ) time ( NULL )); int n ; while ( cin >> n ){ memset ( num , 0 , sizeof ( num )); for ( int i = 1 ; i <= 10000000 ; i ++ ){ //\u6570\u636e\u5f00\u7684\u5927\uff0c\u8dd1\u5f97\u6162\uff0c\u8010\u5fc3\u7b49\u5f85\uff0c\u53ef\u4ee5\u8c03\u5c0f\u4e00\u70b9 memset ( vis , false , sizeof ( vis )); int pos = 0 ; int cnt = 1 ; vis [ 0 ] = true ; while ( cnt < n ){ int x = rand () % 2 ; if ( ! x ) x = -1 ; pos += x ; pos = ( pos + n ) % n ; if ( ! vis [ pos ]){ vis [ pos ] = true ; cnt ++ ; } if ( cnt == n ){ num [ pos ] ++ ; } } } for ( int i = 0 ; i < n ; i ++ ){ cout << i << \": \" << num [ i ] << endl ; } } return 0 ; } \u9644\uff1a C++\u4ea7\u751f\u4efb\u610f\u533a\u95f4\u7684\u968f\u673a\u6570\uff1anumber = (rand()%(maxValue - minValue +1)) + minValue; rand()\u4f1a\u8fd4\u56de\u4e00\u968f\u673a\u6570\u503c, \u8303\u56f4\u57280\u81f3RAND_MAX \u95f4\u3002RAND_MAX\u5b9a\u4e49\u5728stdlib.h, \u5176\u503c\u4e3a2147483647\u3002 srand()\u53ef\u7528\u6765\u8bbe\u7f6erand()\u4ea7\u751f\u968f\u673a\u6570\u65f6\u7684\u968f\u673a\u6570\u79cd\u5b50\u3002\u901a\u8fc7\u8bbe\u7f6e\u4e0d\u540c\u7684\u79cd\u5b50\uff0c\u6211\u4eec\u53ef\u4ee5\u83b7\u53d6\u4e0d\u540c\u7684\u968f\u673a\u6570\u5e8f\u5217\u3002\u53ef\u4ee5\u5229\u7528srand((int)(time(NULL))\u7684\u65b9\u6cd5\uff0c\u5229\u7528\u7cfb\u7edf\u65f6\u949f\uff0c\u4ea7\u751f\u4e0d\u540c\u7684\u968f\u673a\u6570\u79cd\u5b50\u3002 \u6253\u8868\u7ed3\u8bba\uff1a\u5982\u679cn==1\u663e\u7136\u6982\u7387\u662f1\uff0c\u5982\u679cm==0\uff0c\u4ece\u6837\u4f8b\u53ef\u4ee5\u770b\u51fa\u662f0\uff0c\u5176\u4ed6\u60c5\u51b5\u662f1/(n-1), \u53c2\u8003\u4e8e\uff1a https://blog.csdn.net/lgz0921/article/details/96695326 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b % 2 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } int main () { // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); ll t ; scanf ( \"%lld\" , & t ); ll n , m , ans = 1 ; while ( t -- ) { scanf ( \"%lld%lld\" , & n , & m ); if ( n == 1 ) ans *= 1 ; else if ( m == 0 ) ans = 0 ; else ans = ( ans * ksm ( n - 1 , mod - 2 )) % mod ; printf ( \"%lld \\n \" , ans ); } }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e03\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e03\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_2","text":"Cow Steeplechase","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_3","text":"Farmer John has a brilliant idea for the next great spectator sport: Cow Steeplechase! As everyone knows, regular steeplechase involves a group of horses that race around a course filled with obstacles they must jump over.FJ figures the same contest should work with highly-trained cows, as long as the obstacles are made short enough. In order to design his course, FJ makes a diagram of all the N (1 <= N <=250) possible obstacles he could potentially build. Each one is represented by a line segment in the 2D plane that is parallel to the horizontal or vertical axis. Obstacle i has distinct endpoints (X1_i, Y1_i) and (X2_i, Y2_i) (1 <= X1_i, Y1_i, X2_i, Y2_i <= 1,000,000,000). An example is as follows: --+------- -----+----- ---+--- | | | | --+-----+--+- | | | | | | | --+--+--+-+- | | | | | FJ would like to build as many of these obstacles as possible, subject to the constraint that no two of them intersect. Starting with the diagram above, FJ can build 7 obstacles: ---------- ----------- ------- | | | | | | | | | | | | | | | | | | | Two segments are said to intersect if they share any point in common, even an endpoint of one or both of the segments. FJ is certain that no two horizontal segments in the original input diagram will intersect, and that similarly no two vertical segments in the input diagram will intersect. Please help FJ determine the maximum number of obstacles he can build.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_4","text":"Line 1: A single integer: N. Lines 2..N+1: Line i+1 contains four space-separated integers representing an obstacle: X1_i, Y1_i, X2_i, and Y2_i.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_5","text":"Line 1: The maximum number of non-crossing segments FJ can choose.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_6","text":"3 4 5 10 5 6 2 6 12 8 3 8 5","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_7","text":"2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_8","text":"There are three potential obstacles. The first is a horizontal segment connecting (4, 5) to (10, 5); the second and third are vertical segments connecting (6, 2) to (6, 12) and (8, 3) to (8, 5).The optimal solution is to choose both vertical segments.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_9","text":"\u7f51\u7edc\u6d41\u7b97\u6cd5\uff0c\u5c06\u6a2a\u5411\u76f4\u7ebf\u6807\u53f7\u5e76\u4e0e\u6e90\u70b9\u5efa\u8fb9\uff0c\u5e76\u8d4b\u6743\u503c1\uff1b\u5c06\u7eb5\u5411\u76f4\u7ebf\u6807\u53f7\u4e0e\u6c47\u70b9\u5efa\u8fb9\uff0c\u8d4b\u6743\u503c1\uff1b\u5c06\u6a2a\u7eb5\u4ea4\u53c9\u7684\u76f4\u7ebf\u5efa\u8fb9\uff0c\u8d4b\u6743\u503c\u4e3a\u6b63\u65e0\u7a77\uff1b\u7531\u6700\u5927\u6d41\u7b49\u4e8e\u6700\u5c0f\u5272\uff0c\u6240\u4ee5\u6839\u636eEK\u7b97\u6cd5\u6216\u8005Dinic\u7b97\u6cd5\u7b97\u51fa\u6700\u5927\u6d41\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_10","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll to , val , next ; }; node edge [ 100500 ] = { 0 }; ll head [ 4050 ] = { 0 }; ll cnt = 0 ; ll s = 1 , e = 1 ; void add_edge ( ll from , ll to , ll val ) { edge [ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. val = val ; head [ from ] = cnt ++ ; } ll pre [ 4050 ] = { 0 }, tag [ 4050 ] = { 0 }, vis [ 4050 ] = { 0 }; ll bfs () { queue < ll > que ; memset ( tag , 0 , sizeof ( tag )); memset ( pre , 0 , sizeof ( pre )); memset ( vis , 0 , sizeof ( vis )); que . push ( s ); vis [ s ] = 1 ; while ( ! que . empty ()) { ll now = que . front (); que . pop (); for ( ll i = head [ now ]; i != -1 ; i = edge [ i ]. next ) { ll to = edge [ i ]. to , val = edge [ i ]. val ; if ( ! vis [ to ] && val > 0 ) { vis [ to ] = 1 ; pre [ to ] = now ; tag [ to ] = i ; if ( to == e ) return 1 ; que . push ( to ); } } } return 0 ; } ll EK () { ll ans = 0 ; while ( bfs ()) { ll min1 = inf ; for ( ll i = e ; i != s ; i = pre [ i ]) { min1 = min ( min1 , edge [ tag [ i ]]. val ); } for ( ll i = e ; i != s ; i = pre [ i ]) { edge [ tag [ i ]]. val -= min1 ; edge [ tag [ i ] ^ 1 ]. val += min1 ; } ans += min1 ; } return ans ; } struct node1 { ll x1 , y1 , x2 , y2 , num ; }; node1 a [ 4050 ] = { 0 }, b [ 4050 ] = { 0 }; ll cnta = 0 , cntb = 0 ; int main () { //freopen(\"in.txt\", \"r\", stdin); ll n ; scanf ( \"%lld\" , & n ); ll x1 , x2 , y1 , y2 ; for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); if ( x1 > x2 ) swap ( x1 , x2 ); if ( y1 > y2 ) swap ( y1 , y2 ); if ( x1 == x2 ) a [ ++ cnta ] = { x1 , y1 , x2 , y2 , i }; else b [ ++ cntb ] = { x1 , y1 , x2 , y2 , i }; } for ( ll i = 0 ; i < 4050 ; i ++ ) head [ i ] = -1 ; e = 4000 , s = 0 ; for ( ll i = 1 ; i <= cnta ; i ++ ) { add_edge ( s , a [ i ]. num , 1 ); add_edge ( a [ i ]. num , s , 0 ); //cout << s << ' ' << a[i].num << ' ' << 1 << endl; } for ( ll i = 1 ; i <= cntb ; i ++ ) { add_edge ( e , b [ i ]. num , 0 ); add_edge ( b [ i ]. num , e , 1 ); //cout << e << ' ' << b[i].num << ' ' << 1 << endl; } for ( ll i = 1 ; i <= cnta ; i ++ ) { for ( ll j = 1 ; j <= cntb ; j ++ ) { if (( b [ j ]. x1 <= a [ i ]. x1 && a [ i ]. x1 <= b [ j ]. x2 ) && ( a [ i ]. y1 <= b [ j ]. y1 && b [ j ]. y1 <= a [ i ]. y2 )) { add_edge ( a [ i ]. num , b [ j ]. num , inf ); add_edge ( b [ j ]. num , a [ i ]. num , 0 ); //cout << a[i].num << ' ' << b[j].num << ' ' << inf << endl; } } } printf ( \"%lld \\n \" , n - EK ()); } \u8be5\u9898\u53e6\u5916\u4e00\u79cd\u505a\u6cd5\u4e3a\u4e8c\u5206\u56fe\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; vector < int > v [ 1005 ]; map < int , int > mp , vis , mp1 ; int dfs ( int now ) { for ( int i = 0 ; i < v [ now ]. size (); i ++ ) { int to = v [ now ][ i ]; if ( ! vis [ to ]) { vis [ to ] = 1 ; if ( mp [ to ] == 0 || dfs ( mp [ to ])) { mp [ to ] = now ; mp1 [ now ] = to ; return 1 ; } } } return 0 ; } struct node1 { ll x1 , y1 , x2 , y2 , num ; }; node1 a [ 4050 ] = { 0 }, b [ 4050 ] = { 0 }; ll cnta = 0 , cntb = 0 ; int main () { ll n ; scanf ( \"%lld\" , & n ); ll x1 , x2 , y1 , y2 ; for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); if ( x1 > x2 ) swap ( x1 , x2 ); if ( y1 > y2 ) swap ( y1 , y2 ); if ( x1 == x2 ) { cnta ++ ; a [ cnta ] = { x1 , y1 , x2 , y2 , cnta }; } else { cntb ++ ; b [ cntb ] = { x1 , y1 , x2 , y2 , cntb }; } } for ( ll i = 1 ; i <= cnta ; i ++ ) { for ( ll j = 1 ; j <= cntb ; j ++ ) { if (( b [ j ]. x1 <= a [ i ]. x1 && a [ i ]. x1 <= b [ j ]. x2 ) && ( a [ i ]. y1 <= b [ j ]. y1 && b [ j ]. y1 <= a [ i ]. y2 )) { v [ a [ i ]. num ]. push_back ( b [ j ]. num ); } } } int ans = 0 ; for ( int i = 1 ; i <= cnta ; i ++ ) { vis . clear (); ans += dfs ( i ); } cout << n - ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_11","text":"Above the Median","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_12","text":"Farmer John has lined up his N (1 <= N <= 100,000) cows in a row to measure their heights; cow i has height H_i (1 <= H_i <= 1,000,000,000) nanometers--FJ believes in precise measurements! He wants to take a picture of some contiguous subsequence of the cows to submit to a bovine photography contest at the county fair. The fair has a very strange rule about all submitted photos: a photograph is only valid to submit if it depicts a group of cows whose median height is at least a certain threshold X (1 <= X <= 1,000,000,000). For purposes of this problem, we define the median of an array A[0...K] to be A[ceiling(K/2)] after A is sorted, where ceiling(K/2) gives K/2 rounded up to the nearest integer (or K/2 itself, it K/2 is an integer to begin with). For example the median of {7, 3, 2, 6} is 6, and the median of {5, 4, 8} is 5. Please help FJ count the number of different contiguous subsequences of his cows that he could potentially submit to the photography contest.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_13","text":"* Line 1: Two space-separated integers: N and X. * Lines 2..N+1: Line i+1 contains the single integer H_i.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_14","text":"* Line 1: The number of subsequences of FJ's cows that have median at least X. Note this may not fit into a 32-bit integer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_15","text":"4 6 10 5 6 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_16","text":"7","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_17","text":"FJ's four cows have heights 10, 5, 6, 2. We want to know how many contiguous subsequences have median at least 6.There are 10 possible contiguous subsequences to consider. Of these, only 7 have median at least 6. They are {10}, {6}, {10, 5}, {5, 6}, {6, 2}, {10,5, 6}, {10, 5, 6, 2}.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_18","text":"sum\u6570\u7ec4\u8bb0\u5f55\u6c42\u51fa\u5927\u4e8ek\u7684\u6570\u5b57\u4e2a\u6570\u7684\u524d\u7f00\u548c\uff0c\u5219\u9898\u76ee\u53ef\u4ee5\u8f6c\u53d8\u4e3a\u5bfb\u627e\u533a\u95f4[l,r]\u6ee1\u8db3sum[r]-sum[l-1]>=0\uff0c\u5229\u7528\u6811\u72b6\u6570\u7ec4\u67e5\u627e\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_19","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll tree [ 300500 ] = { 0 }; ll maxn = 300500 ; ll lowbit ( ll n ) { return n & ( - n ); } void add ( ll pos , ll val ) { for ( ll i = pos ; i <= maxn ; i += lowbit ( i )) tree [ i ] += val ; } ll query ( ll pos ) { ll ans = 0 ; for ( ll i = pos ; i > 0 ; i -= lowbit ( i )) ans += tree [ i ]; return ans ; } int main () { ll n , m , k , sum = 0 , ans = 0 ; scanf ( \"%lld%lld\" , & n , & k ) add ( n , 1 ); ///\u4e3a\u9632\u6b62\u8d1f\u6570\u51fa\u73b0\uff0c\u7edf\u4e00\u52a0n\uff0c\u8fd9\u91cc\u521d\u59cb\u5316\u589e\u6dfb\u4e00\u4e2a0 for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & m ); if ( m < k ) sum -= 1 ; else sum += 1 ; ans += query ( sum + n ); add ( sum + n , 1 ); } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_20","text":"Eddy Walker","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_21","text":"Eddy likes to walk around. Especially, he likes to walk in a loop called \"Infinite loop\". But, actually, it's just a loop with finite length(Anyway, the name doesn't matter). Eddy can walk in a fixed length. He finds that it takes him N steps to walk through the loop a cycle. Then, he puts N marks on the \"Infinite loop\" labeled with 0,1,\u2026,N\u22121, where i and i+1 are a step away each other, so as 0 and N-1. After that, Eddy stands on the mark labeled 0 and start walking around. For each step, Eddy will independently uniformly randomly choose to move forward or backward. If currently Eddy is on the mark labeled i, he will on the mark labeled i+1 if move forward or i-1 if move backward. If Eddy is on the mark labeled N-1 and moves forward, he will stand on the mark labeled 0. If Eddy is on the mark labeled 0 and moves backward, he will stand on the mark labeled N-1. Although, Eddy likes to walk around. He will get bored after he reaches each mark at least once. After that, Eddy will pick up all the marks, go back to work and stop walking around. You, somehow, notice the weird convention Eddy is doing. And, you record T scenarios that Eddy walks around. For i-th scenario, you record two numbers Ni, Mi, where Ni tells that in the i-th scenario, Eddy can walk through the loop a cycle in exactly Ni steps(Yes! Eddy can walk in different fixed length for different day.). While Mi tells that you found that in the i-th scenario, after Eddy stands on the mark labeled Mi, he reached all the marks. However, when you review your records, you are not sure whether the data is correct or even possible. Thus, you want to know the probability that those scenarios will happen. Precisely, you are going to compute the probability that first i scenarios will happen sequentially for each i.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_22","text":"The first line of input contains an integers T. Following T lines each contains two space-separated integers Ni and Mi. 1\u2264T\u22641021 0\u2264Mi<Ni\u2264109","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_23","text":"Output T lines each contains an integer representing the probability that first i scenarios will happen sequentially. you should output the number module 109+7(1000000007). Suppose the probability is P/Q, the desired output will be P\u00d7Q\u22121 mod 109+7","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_24","text":"3 1 0 2 1 3 0","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_25","text":"1 1 0","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_26","text":"\u6253\u8868\u627e\u89c4\u5f8b\uff0c\u6253\u8868\u4ee3\u7801\u5982\u4e0b\uff1a #include <iostream> #include <cstdlib> #include <cstring> #include <ctime> using namespace std ; int num [ 520 ]; bool vis [ 520 ]; int main (){ srand (( unsigned ) time ( NULL )); int n ; while ( cin >> n ){ memset ( num , 0 , sizeof ( num )); for ( int i = 1 ; i <= 10000000 ; i ++ ){ //\u6570\u636e\u5f00\u7684\u5927\uff0c\u8dd1\u5f97\u6162\uff0c\u8010\u5fc3\u7b49\u5f85\uff0c\u53ef\u4ee5\u8c03\u5c0f\u4e00\u70b9 memset ( vis , false , sizeof ( vis )); int pos = 0 ; int cnt = 1 ; vis [ 0 ] = true ; while ( cnt < n ){ int x = rand () % 2 ; if ( ! x ) x = -1 ; pos += x ; pos = ( pos + n ) % n ; if ( ! vis [ pos ]){ vis [ pos ] = true ; cnt ++ ; } if ( cnt == n ){ num [ pos ] ++ ; } } } for ( int i = 0 ; i < n ; i ++ ){ cout << i << \": \" << num [ i ] << endl ; } } return 0 ; } \u9644\uff1a C++\u4ea7\u751f\u4efb\u610f\u533a\u95f4\u7684\u968f\u673a\u6570\uff1anumber = (rand()%(maxValue - minValue +1)) + minValue; rand()\u4f1a\u8fd4\u56de\u4e00\u968f\u673a\u6570\u503c, \u8303\u56f4\u57280\u81f3RAND_MAX \u95f4\u3002RAND_MAX\u5b9a\u4e49\u5728stdlib.h, \u5176\u503c\u4e3a2147483647\u3002 srand()\u53ef\u7528\u6765\u8bbe\u7f6erand()\u4ea7\u751f\u968f\u673a\u6570\u65f6\u7684\u968f\u673a\u6570\u79cd\u5b50\u3002\u901a\u8fc7\u8bbe\u7f6e\u4e0d\u540c\u7684\u79cd\u5b50\uff0c\u6211\u4eec\u53ef\u4ee5\u83b7\u53d6\u4e0d\u540c\u7684\u968f\u673a\u6570\u5e8f\u5217\u3002\u53ef\u4ee5\u5229\u7528srand((int)(time(NULL))\u7684\u65b9\u6cd5\uff0c\u5229\u7528\u7cfb\u7edf\u65f6\u949f\uff0c\u4ea7\u751f\u4e0d\u540c\u7684\u968f\u673a\u6570\u79cd\u5b50\u3002 \u6253\u8868\u7ed3\u8bba\uff1a\u5982\u679cn==1\u663e\u7136\u6982\u7387\u662f1\uff0c\u5982\u679cm==0\uff0c\u4ece\u6837\u4f8b\u53ef\u4ee5\u770b\u51fa\u662f0\uff0c\u5176\u4ed6\u60c5\u51b5\u662f1/(n-1), \u53c2\u8003\u4e8e\uff1a https://blog.csdn.net/lgz0921/article/details/96695326","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_27","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b % 2 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } int main () { // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); ll t ; scanf ( \"%lld\" , & t ); ll n , m , ans = 1 ; while ( t -- ) { scanf ( \"%lld%lld\" , & n , & m ); if ( n == 1 ) ans *= 1 ; else if ( m == 0 ) ans = 0 ; else ans = ( ans * ksm ( n - 1 , mod - 2 )) % mod ; printf ( \"%lld \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e09\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 I love exam \u9898\u76ee\u63cf\u8ff0 \u00b6 Student Z doesn't love exams The exam was about to be done soon, but student Z didn't even read the book, He had collapsed. Student Z has a total of n exams, and there are still t days before the start of the exam, which means he still has t days to PREVIEW. But student Z couldn\u2019t even read the textbooks, and couldn\u2019t review it at all. Fortunately, a kind classmate gave him m sets of review materials. The i set of materials can improve the grades of the si course. The i set of materials needs to be studied for yi days. You can increase xi points later (the upper limit of each course is 100 points, so after it is upgraded to 100 points, there will be no further increase).and note that each set of review materials can only be used once. Student Z now has a zero-point level in every course. it is impossible to review all the materials, so he needs to choose some materials to review, but he can fail at most p courses in this semester (if the score of one course is less than 60 points will fail), otherwise he will be talked to by the professor. Student Z now wants to know the maximum points he can get in all courses under the premise of fail no more than p courses this semester. If he cannot meet the conditions, please output \u22121 . \u8f93\u5165 \u00b6 A positive integer T (T\u226410) in the first line represents the number of test cases. For each test case: The first line contains a positive integer n (n\u226450) represents the total number of courses in this semester. The second line contains n strings which length is no more than 15, representing the course name of each course in this semester. The third line contains a positive integer m (m\u226415000) represents the number of review materials he obtained. In the next m lines, each line have a string s and two positive integers x(1\u2264x\u226410) and y(1\u2264y\u226410) , representing the course of this set of materials review, the improved scores and The number of days required for learning(data assurance this course was studied this semester ). The last line has two integers t, p(1\u2264t\u2264500,0\u2264p\u22643) represents the number of review days that student Z has and the upper limit of the number of failed courses in this semester. \u8f93\u51fa \u00b6 For each test case, output a line with a positive integer representing the maximum score that student Z can obtain in the case of meeting the conditions .If he must be talked to by the professor, output \u22121\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 1 3 mathematics physics signals 20 physics 10 1 physics 10 1 physics 10 1 physics 10 1 physics 10 1 physics 10 1 physics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 signals 10 1 signals 10 1 signals 10 1 signals 10 1 signals 10 1 signals 10 2 19 1 \u6837\u4f8b\u8f93\u51fa \u00b6 190 \u9898\u89e3 \u00b6 \u9996\u514801\u80cc\u5305\u6c42\u51fa\u6bcf\u95e8\u8bfe\u82b1\u8d39k\u5929\u53ef\u4ee5\u6700\u591a\u5f97\u5230\u591a\u5c11\u5206\uff0c\u7136\u540edp[i][k][l]\u524di\u95e8\u8bfe\u7a0b,\u590d\u4e60\u4e86k\u5929\uff0c \u6302\u4e86l\u95e8\u8bfe\u7a0b\u7684\u6700\u5927\u5206\u6570\u3002 dp[i][k][l]=max(dp[i-1][k-j][l-x]+f[j],dp[i][k][l]); \u5177\u4f53\u53ef\u53c2\u7167\u535a\u5ba2\uff1a https://blog.csdn.net/m0_46062697/article/details/119008022 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int mx [ 600 ] = { 0 }; int dp [ 60 ][ 600 ][ 60 ] = { 0 }; ///dp[i][j][k]\u4ee3\u8868\u5b66\u4e60\u524di\u95e8\uff0c\u7528\u65f6j\u5929\u3002\u6302\u6389k\u95e8\u7684\u6700\u5927\u5206\u6570 map < string , int > mp ; string str ; vector < pair < int , int >> v [ 60 ]; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) v [ i ]. clear (); memset ( dp , -0x3f , sizeof ( dp )); mp . clear (); for ( int i = 1 ; i <= n ; i ++ ) { cin >> str ; mp [ str ] = i ; } int m , x , y ; scanf ( \"%d\" , & m ); for ( int i = 1 ; i <= m ; i ++ ) { cin >> str ; scanf ( \"%d %d\" , & x , & y ); int index = mp [ str ]; v [ index ]. push_back ({ x , y }); } int t , p ; scanf ( \"%d%d\" , & t , & p ); dp [ 0 ][ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { memset ( mx , -0x3f , sizeof ( mx )); mx [ 0 ] = 0 ; for ( int j = 0 ; j < v [ i ]. size (); j ++ ) for ( int k = t ; k >= v [ i ][ j ]. second ; k -- ) mx [ k ] = max ( mx [ k ], mx [ k - v [ i ][ j ]. second ] + v [ i ][ j ]. first ); for ( int j = 0 ; j <= t ; j ++ ) { for ( int k = j ; k <= t ; k ++ ) { for ( int l = 0 ; l <= p ; l ++ ) { if ( mx [ j ] < 0 ) continue ; int x = 0 ; if ( mx [ j ] < 60 ) x = 1 ; mx [ j ] = min ( mx [ j ], 100 ); if ( l >= x ) dp [ i ][ k ][ l ] = max ( dp [ i ][ k ][ l ], dp [ i - 1 ][ k - j ][ l - x ] + mx [ j ]); } } } } int ans = -0x3f ; for ( int i = 0 ; i <= t ; i ++ ) for ( int j = 0 ; j <= p ; j ++ ) ans = max ( ans , dp [ n ][ i ][ j ]); if ( ans < 0 ) puts ( \"-1\" ); else printf ( \"%d \\n \" , ans ); } }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e09\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e09\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_2","text":"I love exam","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_3","text":"Student Z doesn't love exams The exam was about to be done soon, but student Z didn't even read the book, He had collapsed. Student Z has a total of n exams, and there are still t days before the start of the exam, which means he still has t days to PREVIEW. But student Z couldn\u2019t even read the textbooks, and couldn\u2019t review it at all. Fortunately, a kind classmate gave him m sets of review materials. The i set of materials can improve the grades of the si course. The i set of materials needs to be studied for yi days. You can increase xi points later (the upper limit of each course is 100 points, so after it is upgraded to 100 points, there will be no further increase).and note that each set of review materials can only be used once. Student Z now has a zero-point level in every course. it is impossible to review all the materials, so he needs to choose some materials to review, but he can fail at most p courses in this semester (if the score of one course is less than 60 points will fail), otherwise he will be talked to by the professor. Student Z now wants to know the maximum points he can get in all courses under the premise of fail no more than p courses this semester. If he cannot meet the conditions, please output \u22121 .","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_4","text":"A positive integer T (T\u226410) in the first line represents the number of test cases. For each test case: The first line contains a positive integer n (n\u226450) represents the total number of courses in this semester. The second line contains n strings which length is no more than 15, representing the course name of each course in this semester. The third line contains a positive integer m (m\u226415000) represents the number of review materials he obtained. In the next m lines, each line have a string s and two positive integers x(1\u2264x\u226410) and y(1\u2264y\u226410) , representing the course of this set of materials review, the improved scores and The number of days required for learning(data assurance this course was studied this semester ). The last line has two integers t, p(1\u2264t\u2264500,0\u2264p\u22643) represents the number of review days that student Z has and the upper limit of the number of failed courses in this semester.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_5","text":"For each test case, output a line with a positive integer representing the maximum score that student Z can obtain in the case of meeting the conditions .If he must be talked to by the professor, output \u22121\u3002","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_6","text":"1 3 mathematics physics signals 20 physics 10 1 physics 10 1 physics 10 1 physics 10 1 physics 10 1 physics 10 1 physics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 signals 10 1 signals 10 1 signals 10 1 signals 10 1 signals 10 1 signals 10 2 19 1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_7","text":"190","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_8","text":"\u9996\u514801\u80cc\u5305\u6c42\u51fa\u6bcf\u95e8\u8bfe\u82b1\u8d39k\u5929\u53ef\u4ee5\u6700\u591a\u5f97\u5230\u591a\u5c11\u5206\uff0c\u7136\u540edp[i][k][l]\u524di\u95e8\u8bfe\u7a0b,\u590d\u4e60\u4e86k\u5929\uff0c \u6302\u4e86l\u95e8\u8bfe\u7a0b\u7684\u6700\u5927\u5206\u6570\u3002 dp[i][k][l]=max(dp[i-1][k-j][l-x]+f[j],dp[i][k][l]); \u5177\u4f53\u53ef\u53c2\u7167\u535a\u5ba2\uff1a https://blog.csdn.net/m0_46062697/article/details/119008022","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_9","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int mx [ 600 ] = { 0 }; int dp [ 60 ][ 600 ][ 60 ] = { 0 }; ///dp[i][j][k]\u4ee3\u8868\u5b66\u4e60\u524di\u95e8\uff0c\u7528\u65f6j\u5929\u3002\u6302\u6389k\u95e8\u7684\u6700\u5927\u5206\u6570 map < string , int > mp ; string str ; vector < pair < int , int >> v [ 60 ]; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) v [ i ]. clear (); memset ( dp , -0x3f , sizeof ( dp )); mp . clear (); for ( int i = 1 ; i <= n ; i ++ ) { cin >> str ; mp [ str ] = i ; } int m , x , y ; scanf ( \"%d\" , & m ); for ( int i = 1 ; i <= m ; i ++ ) { cin >> str ; scanf ( \"%d %d\" , & x , & y ); int index = mp [ str ]; v [ index ]. push_back ({ x , y }); } int t , p ; scanf ( \"%d%d\" , & t , & p ); dp [ 0 ][ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { memset ( mx , -0x3f , sizeof ( mx )); mx [ 0 ] = 0 ; for ( int j = 0 ; j < v [ i ]. size (); j ++ ) for ( int k = t ; k >= v [ i ][ j ]. second ; k -- ) mx [ k ] = max ( mx [ k ], mx [ k - v [ i ][ j ]. second ] + v [ i ][ j ]. first ); for ( int j = 0 ; j <= t ; j ++ ) { for ( int k = j ; k <= t ; k ++ ) { for ( int l = 0 ; l <= p ; l ++ ) { if ( mx [ j ] < 0 ) continue ; int x = 0 ; if ( mx [ j ] < 60 ) x = 1 ; mx [ j ] = min ( mx [ j ], 100 ); if ( l >= x ) dp [ i ][ k ][ l ] = max ( dp [ i ][ k ][ l ], dp [ i - 1 ][ k - j ][ l - x ] + mx [ j ]); } } } } int ans = -0x3f ; for ( int i = 0 ; i <= t ; i ++ ) for ( int j = 0 ; j <= p ; j ++ ) ans = max ( ans , dp [ n ][ i ][ j ]); if ( ans < 0 ) puts ( \"-1\" ); else printf ( \"%d \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e5d\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Spread of Information \u9898\u76ee\u63cf\u8ff0 \u00b6 Takahashi Kingdom has N towns, called Town 1 through N. There are N\u22121 roads in this kingdom. The i-th road connects Town ui and Town vi bidirectionally. For any two towns a and b, it is possible to get from Town a to Town b by traversing some roads. Takahashi, the king, wants to spread some information all over the kingdom. Since he is busy, he can directly transmit this information to at most K towns. Assume that Takahashi finishes transmitting the information at time 0. Then, for each t=1,2,3,\u22ef, the following happens: For towns a and b directly connected by a road, if a has already received the information at time t\u22120.5 but b has not, b receives it at time t. Takahashi wants to choose the K towns to transmit the information to minimize the time taken until every town receives it. Find the minimum time this takes. Constraints All values in input are integers. 1\u2264K<N\u2264 2\u00d710^5 2\u00d710^5 1\u2264ui,vi\u2264N For any two towns a and b, it is possible to get from Town a to Town b by traversing some roads. \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N K u1 v1 u2 v2 \u22ee uN\u22121 vN\u22121 \u8f93\u51fa \u00b6 Print the answer. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 5 2 1 2 2 3 3 4 4 5 \u3010\u6837\u4f8b2\u3011 5 1 1 2 1 3 1 4 5 4 \u3010\u6837\u4f8b3\u3011 20 3 2 15 6 5 12 1 7 9 17 2 15 5 2 4 17 16 12 2 8 17 17 19 18 11 20 8 20 3 13 9 11 10 11 20 14 8 11 7 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 2 \u3010\u6837\u4f8b3\u3011 3 \u9898\u89e3 \u00b6 \u6811\u4e0aDP\uff0c\u8be6\u7ec6\u89c1\u4ee3\u7801\u6ce8\u91ca\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/qq_48099121/article/details/115670878 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; struct node { int to , next ; }; node edge [ 400500 ] = { 0 }; int head [ 200500 ] = { 0 }; int cnt = 0 , num = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } int f [ 200500 ] = { 0 }; ///f\u4ee3\u8868\u4ee5u\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u8ddd\u79bbu\u6700\u8fd1\u7684\u7279\u6b8a\u70b9 int g [ 200500 ] = { 0 }; ///g\u4ee3\u8868\u4ee5u\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u672a\u88ab\u8986\u76d6\u5230\u7684\u6700\u8fdc\u7684\u70b9 int dfs ( int now , int fa , int mid ) { f [ now ] = inf , g [ now ] = 0 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to == fa ) continue ; dfs ( to , now , mid ); f [ now ] = min ( f [ now ], f [ to ] + 1 ); g [ now ] = max ( g [ now ], g [ to ] + 1 ); } if ( g [ now ] + f [ now ] <= mid ) g [ now ] =- inf ; else if ( g [ now ] == mid ) g [ now ] =- inf , f [ now ] = 0 , num ++ ; } int check ( int mid ) { num = 0 ; dfs ( 1 , -1 , mid ); if ( g [ 1 ] >= 0 ) ///\u8fd8\u6709\u672a\u88ab\u8986\u76d6\u5230\u7684\u70b9 num ++ ; return num ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n -1 ; i ++ ) { int x , y ; scanf ( \"%d%d\" , & x , & y ); add_edge ( x , y ); add_edge ( y , x ); } int l = 0 , r = n ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( check ( mid ) <= m ) r = mid ; else l = mid + 1 ; } cout << l << endl ; } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2889&pid=5 \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has just received a new shipment of N (1 <= N <= 20) bales of hay, where bale i has size S_i (1 <= S_i <= 100). He wants to divide the bales between his three barns as fairly as possible. After some careful thought, FJ decides that a \"fair\" division of the hay bales should make the largest share as small as possible. That is, if B_1, B_2, and B_3 are the total sizes of all the bales placed in barns 1, 2, and 3, respectively (where B_1 >= B_2 >= B_3), then FJ wants to make B_1 as small as possible. For example, if there are 8 bales in these sizes: 2 4 5 8 9 14 15 20 A fair solution is Barn 1: 2 9 15 B_1 = 26 Barn 2: 4 8 14 B_2 = 26 Barn 3: 5 20 B_3 = 25 Please help FJ determine the value of B_1 for a fair division of the hay bales. \u8f93\u5165 \u00b6 * Line 1: The number of bales, N. * Lines 2..1+N: Line i+1 contains S_i, the size of the ith bale. \u8f93\u51fa \u00b6 * Line 1: Please output the value of B_1 in a fair division of the hay bales. \u6837\u4f8b\u8f93\u5165 \u00b6 8 14 2 5 15 8 9 20 4 \u6837\u4f8b\u8f93\u51fa \u00b6 26 \u9898\u89e3 \u00b6 \u4e09\u7ef4\u52a8\u6001\u89c4\u5212\u8f6c\u79fb\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll a [ 25 ] = { 0 }; bool dp [ 2 ][ 2005 ][ 2005 ] = { 0 }; int main () { ll n , sum = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); sum += a [ i ]; } dp [ 1 ][ 0 ][ 0 ] = true ; ll last = 1 , now = 0 ; ll ans = sum ; for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 0 ; j < 2005 ; j ++ ) { for ( ll k = 0 ; k < 2005 ; k ++ ) { if ( dp [ i & 1 ][ j ][ k ] == 1 ) { dp [( i + 1 ) & 1 ][ j ][ k ] = true ; if ( k + a [ i ] < 2005 ) dp [( i + 1 ) & 1 ][ j ][ k + a [ i ]] = true ; if ( j + a [ i ] < 2005 ) dp [( i + 1 ) & 1 ][ j + a [ i ]][ k ] = true ; } } } } for ( ll j = 0 ; j < 2005 ; j ++ ) { for ( ll k = 0 ; k < 2005 ; k ++ ) { if ( dp [ n & 1 ][ j ][ k ]) { ans = min ( ans , max ( sum - j - k , max ( j , k ))); } } } cout << ans << endl ; } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2889&pid=7 \u9898\u76ee\u63cf\u8ff0 \u00b6 Given are two sequences of length N each: A=(A1,A2,A3,\u2026,AN) and B=(B1,B2,B3,\u2026,BN). Determine whether it is possible to make A equal B by repeatedly doing the operation below (possibly zero times). If it is possible, find the minimum number of operations required to do so. Choose an integer i such that 1\u2264i<N, and do the following in order: swap Ai and Ai+1; add 1 to Ai; subtract 1 from Ai+1. Constraints 2\u2264N\u2264 2\u00d710^5 2\u00d710^5 \u200b\u200b 0\u2264Ai\u2264 10^9 10^9 \u200b 0\u2264Bi\u2264 10^9 10^9 All values in input are integers. \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N A1 A2 A3 \u2026 AN B1 B2 B3 \u2026 BN \u8f93\u51fa \u00b6 If it is impossible to make A equal B, print -1. Otherwise, print the minimum number of operations required to do so. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 3 3 1 4 6 2 0 \u3010\u6837\u4f8b2\u3011 3 1 1 1 1 1 2 \u3010\u6837\u4f8b3\u3011 5 5 4 1 3 2 5 4 1 3 2 \u3010\u6837\u4f8b4\u3011 6 8 5 4 7 4 5 10 5 6 7 4 1 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 2 \u3010\u6837\u4f8b2\u3011 -1 \u3010\u6837\u4f8b3\u3011 0 \u3010\u6837\u4f8b4\u3011 7 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca\uff1a We can match A with B in two operations, as follows: First, do the operation with i=2, making A=(3,5,0). Next, do the operation with i=1, making A=(6,2,0). We cannot meet our objective in one or fewer operations. \u6837\u4f8b2\u89e3\u91ca\uff1a In this case, it is impossible to match A with B. \u6837\u4f8b3\u89e3\u91ca\uff1a A may equal B before doing any operation. \u9898\u89e3 \u00b6 \u5bf9\u4e00\u4e2a\u6570\u7ec4\u8fdb\u884c\u5982\u4e0a\u7684\u4e09\u6b21\u64cd\u4f5c\u4e4b\u540e i+a[i] i+a[i] \u200b\u7684\u503c\u4fdd\u6301\u4e0d\u53d8\uff0c\u6240\u4ee5\u53ea\u8981\u628aa\u6570\u7ec4 i+a[i] i+a[i] \u200b\u8f6c\u53d8\u4e3ab\u6570\u7ec4\u4e2d j+b[j] j+b[j] \u200b\u5373\u53ef\uff0c\u53c8\u56e0\u4e3a\u4e3a\u76f8\u90bb\u4ea4\u6362\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u6c42\u51fa\u9006\u5e8f\u5bf9\u5373\u53ef\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/weixin_45483201/article/details/117699573 https://www.cnblogs.com/spnooyseed/p/14810702.html \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3.\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; const ll maxn = 400000 ; ll tree [ 400500 ] = { 0 }; ll a [ 200500 ] = { 0 }; ll b [ 200500 ] = { 0 }; unordered_map < int , vector < int > > mpa , mpb ; ll lowbit ( ll x ) { return x & ( - x ); } void add ( ll pos , ll val ) { for ( ll i = pos ; i <= 400000 ; i += lowbit ( i )) tree [ i ] += val ; } ll query ( ll pos ) { ll ans = 0 ; for ( ll i = pos ; i >= 1 ; i -= lowbit ( i )) ans += tree [ i ]; return ans ; } int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); a [ i ] += i ; mpa [ a [ i ]]. push_back ( i ); } for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & b [ i ]); b [ i ] += i ; mpb [ b [ i ]]. push_back ( i ); } for ( auto v : mpa ) { if ( v . second . size () != mpb [ v . first ]. size ()) return 0 * puts ( \"-1\" ); auto v2 = mpb [ v . first ]; for ( int i = 0 ; i < v . second . size (); i ++ ) a [ v . second [ i ]] = v2 [ i ]; } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { add ( a [ i ], 1 ); ans += i - query ( a [ i ]); } cout << ans << endl ; } \u9898\u76ee4 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2890&pid=3 \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has discovered that his cows produce higher quality milk when they are subject to strenuous exercise. He therefore decides to send his N cows (1 <= N <= 25,000) to climb up and then back down a nearby mountain! Cow i takes U(i) time to climb up the mountain and then D(i) time to climb down the mountain. Being domesticated cows, each cow needs the help of a farmer for each leg of the climb, but due to the poor economy, there are only two farmers available, Farmer John and his cousin Farmer Don. FJ plans to guide cows for the upward climb, and FD will then guide the cows for the downward climb. Since every cow needs a guide, and there is only one farmer for each part of the voyage, at most one cow may be climbing upward at any point in time (assisted by FJ), and at most one cow may be climbing down at any point in time (assisted by FD). A group of cows may temporarily accumulate at the top of the mountain if they climb up and then need to wait for FD's assistance before climbing down. Cows may climb down in a different order than they climbed up. Please determine the least possible amount of time for all N cows to make the entire journey. \u8f93\u5165 \u00b6 Line 1: The number of cows, N. Lines 2..1+N: Line i+1 contains two space-separated integers: U(i) and D(i). (1 <= U(i), D(i) <= 50,000). \u8f93\u51fa \u00b6 Line 1: A single integer representing the least amount of time for all the cows to cross the mountain. \u6837\u4f8b\u8f93\u5165 \u00b6 3 6 4 8 1 2 3 \u6837\u4f8b\u8f93\u51fa \u00b6 17 \u9898\u89e3 \u00b6 \u8d2a\u5fc3\uff0c\u8be6\u7ec6\u89c1\u4ee3\u7801\u6ce8\u91ca\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll u , d , sum , sum1 ; }; bool cmp ( node a , node b ) { if ( a . d > a . u && b . d <= b . u ) ///\u4e0b\u5c71\u6bd4\u4e0a\u5c71\u6162\u7684\u7684\u4f18\u5148\u4e0a return 1 ; else if ( a . d <= a . u && b . d > b . u ) return 0 ; else if ( a . d > a . u ) ///\u5148\u4e0a\u7684\u4f18\u5148\u8ba9\u4e0a\u5c71\u5feb\u7684\u4e0a\uff0c\u52a0\u901f\u65f6\u95f4 return a . u < b . u ; else return a . d > b . d ; ///\u540e\u4e0a\u7684\u4f18\u5148\u8ba9\u4e0b\u5c71\u7684\u6162\u7684\u4e0a\uff0c\u5c3d\u53ef\u80fd\u62d6\u5ef6\u65f6\u95f4 } node a [ 25500 ] = { 0 }; int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld%lld\" , & a [ i ]. u , & a [ i ]. d ); sort ( a + 1 , a + n + 1 , cmp ); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) a [ i ]. sum = a [ i -1 ]. sum + a [ i ]. u ; for ( ll i = 1 ; i <= n ; i ++ ) { a [ i ]. sum1 = max ( a [ i ]. sum , a [ i -1 ]. sum1 ) + a [ i ]. d ; ans = max ( ans , a [ i ]. sum1 ); } cout << ans << endl ; }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e5d\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e5d\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_2","text":"Spread of Information","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_3","text":"Takahashi Kingdom has N towns, called Town 1 through N. There are N\u22121 roads in this kingdom. The i-th road connects Town ui and Town vi bidirectionally. For any two towns a and b, it is possible to get from Town a to Town b by traversing some roads. Takahashi, the king, wants to spread some information all over the kingdom. Since he is busy, he can directly transmit this information to at most K towns. Assume that Takahashi finishes transmitting the information at time 0. Then, for each t=1,2,3,\u22ef, the following happens: For towns a and b directly connected by a road, if a has already received the information at time t\u22120.5 but b has not, b receives it at time t. Takahashi wants to choose the K towns to transmit the information to minimize the time taken until every town receives it. Find the minimum time this takes. Constraints All values in input are integers. 1\u2264K<N\u2264 2\u00d710^5 2\u00d710^5 1\u2264ui,vi\u2264N For any two towns a and b, it is possible to get from Town a to Town b by traversing some roads.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_4","text":"Input is given from Standard Input in the following format: N K u1 v1 u2 v2 \u22ee uN\u22121 vN\u22121","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_5","text":"Print the answer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_6","text":"\u3010\u6837\u4f8b1\u3011 5 2 1 2 2 3 3 4 4 5 \u3010\u6837\u4f8b2\u3011 5 1 1 2 1 3 1 4 5 4 \u3010\u6837\u4f8b3\u3011 20 3 2 15 6 5 12 1 7 9 17 2 15 5 2 4 17 16 12 2 8 17 17 19 18 11 20 8 20 3 13 9 11 10 11 20 14 8 11 7","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_7","text":"\u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 2 \u3010\u6837\u4f8b3\u3011 3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_8","text":"\u6811\u4e0aDP\uff0c\u8be6\u7ec6\u89c1\u4ee3\u7801\u6ce8\u91ca\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/qq_48099121/article/details/115670878","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_9","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; struct node { int to , next ; }; node edge [ 400500 ] = { 0 }; int head [ 200500 ] = { 0 }; int cnt = 0 , num = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } int f [ 200500 ] = { 0 }; ///f\u4ee3\u8868\u4ee5u\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u8ddd\u79bbu\u6700\u8fd1\u7684\u7279\u6b8a\u70b9 int g [ 200500 ] = { 0 }; ///g\u4ee3\u8868\u4ee5u\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u672a\u88ab\u8986\u76d6\u5230\u7684\u6700\u8fdc\u7684\u70b9 int dfs ( int now , int fa , int mid ) { f [ now ] = inf , g [ now ] = 0 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to == fa ) continue ; dfs ( to , now , mid ); f [ now ] = min ( f [ now ], f [ to ] + 1 ); g [ now ] = max ( g [ now ], g [ to ] + 1 ); } if ( g [ now ] + f [ now ] <= mid ) g [ now ] =- inf ; else if ( g [ now ] == mid ) g [ now ] =- inf , f [ now ] = 0 , num ++ ; } int check ( int mid ) { num = 0 ; dfs ( 1 , -1 , mid ); if ( g [ 1 ] >= 0 ) ///\u8fd8\u6709\u672a\u88ab\u8986\u76d6\u5230\u7684\u70b9 num ++ ; return num ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n -1 ; i ++ ) { int x , y ; scanf ( \"%d%d\" , & x , & y ); add_edge ( x , y ); add_edge ( y , x ); } int l = 0 , r = n ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( check ( mid ) <= m ) r = mid ; else l = mid + 1 ; } cout << l << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_10","text":"http://icpc.upc.edu.cn/problem.php?cid=2889&pid=5","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_11","text":"Farmer John has just received a new shipment of N (1 <= N <= 20) bales of hay, where bale i has size S_i (1 <= S_i <= 100). He wants to divide the bales between his three barns as fairly as possible. After some careful thought, FJ decides that a \"fair\" division of the hay bales should make the largest share as small as possible. That is, if B_1, B_2, and B_3 are the total sizes of all the bales placed in barns 1, 2, and 3, respectively (where B_1 >= B_2 >= B_3), then FJ wants to make B_1 as small as possible. For example, if there are 8 bales in these sizes: 2 4 5 8 9 14 15 20 A fair solution is Barn 1: 2 9 15 B_1 = 26 Barn 2: 4 8 14 B_2 = 26 Barn 3: 5 20 B_3 = 25 Please help FJ determine the value of B_1 for a fair division of the hay bales.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_12","text":"* Line 1: The number of bales, N. * Lines 2..1+N: Line i+1 contains S_i, the size of the ith bale.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_13","text":"* Line 1: Please output the value of B_1 in a fair division of the hay bales.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_14","text":"8 14 2 5 15 8 9 20 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_15","text":"26","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_16","text":"\u4e09\u7ef4\u52a8\u6001\u89c4\u5212\u8f6c\u79fb\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_17","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll a [ 25 ] = { 0 }; bool dp [ 2 ][ 2005 ][ 2005 ] = { 0 }; int main () { ll n , sum = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); sum += a [ i ]; } dp [ 1 ][ 0 ][ 0 ] = true ; ll last = 1 , now = 0 ; ll ans = sum ; for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 0 ; j < 2005 ; j ++ ) { for ( ll k = 0 ; k < 2005 ; k ++ ) { if ( dp [ i & 1 ][ j ][ k ] == 1 ) { dp [( i + 1 ) & 1 ][ j ][ k ] = true ; if ( k + a [ i ] < 2005 ) dp [( i + 1 ) & 1 ][ j ][ k + a [ i ]] = true ; if ( j + a [ i ] < 2005 ) dp [( i + 1 ) & 1 ][ j + a [ i ]][ k ] = true ; } } } } for ( ll j = 0 ; j < 2005 ; j ++ ) { for ( ll k = 0 ; k < 2005 ; k ++ ) { if ( dp [ n & 1 ][ j ][ k ]) { ans = min ( ans , max ( sum - j - k , max ( j , k ))); } } } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_18","text":"http://icpc.upc.edu.cn/problem.php?cid=2889&pid=7","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_19","text":"Given are two sequences of length N each: A=(A1,A2,A3,\u2026,AN) and B=(B1,B2,B3,\u2026,BN). Determine whether it is possible to make A equal B by repeatedly doing the operation below (possibly zero times). If it is possible, find the minimum number of operations required to do so. Choose an integer i such that 1\u2264i<N, and do the following in order: swap Ai and Ai+1; add 1 to Ai; subtract 1 from Ai+1. Constraints 2\u2264N\u2264 2\u00d710^5 2\u00d710^5 \u200b\u200b 0\u2264Ai\u2264 10^9 10^9 \u200b 0\u2264Bi\u2264 10^9 10^9 All values in input are integers.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_20","text":"Input is given from Standard Input in the following format: N A1 A2 A3 \u2026 AN B1 B2 B3 \u2026 BN","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_21","text":"If it is impossible to make A equal B, print -1. Otherwise, print the minimum number of operations required to do so.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_22","text":"\u3010\u6837\u4f8b1\u3011 3 3 1 4 6 2 0 \u3010\u6837\u4f8b2\u3011 3 1 1 1 1 1 2 \u3010\u6837\u4f8b3\u3011 5 5 4 1 3 2 5 4 1 3 2 \u3010\u6837\u4f8b4\u3011 6 8 5 4 7 4 5 10 5 6 7 4 1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_23","text":"\u3010\u6837\u4f8b1\u3011 2 \u3010\u6837\u4f8b2\u3011 -1 \u3010\u6837\u4f8b3\u3011 0 \u3010\u6837\u4f8b4\u3011 7","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_24","text":"\u6837\u4f8b1\u89e3\u91ca\uff1a We can match A with B in two operations, as follows: First, do the operation with i=2, making A=(3,5,0). Next, do the operation with i=1, making A=(6,2,0). We cannot meet our objective in one or fewer operations. \u6837\u4f8b2\u89e3\u91ca\uff1a In this case, it is impossible to match A with B. \u6837\u4f8b3\u89e3\u91ca\uff1a A may equal B before doing any operation.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_25","text":"\u5bf9\u4e00\u4e2a\u6570\u7ec4\u8fdb\u884c\u5982\u4e0a\u7684\u4e09\u6b21\u64cd\u4f5c\u4e4b\u540e i+a[i] i+a[i] \u200b\u7684\u503c\u4fdd\u6301\u4e0d\u53d8\uff0c\u6240\u4ee5\u53ea\u8981\u628aa\u6570\u7ec4 i+a[i] i+a[i] \u200b\u8f6c\u53d8\u4e3ab\u6570\u7ec4\u4e2d j+b[j] j+b[j] \u200b\u5373\u53ef\uff0c\u53c8\u56e0\u4e3a\u4e3a\u76f8\u90bb\u4ea4\u6362\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u6c42\u51fa\u9006\u5e8f\u5bf9\u5373\u53ef\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/weixin_45483201/article/details/117699573 https://www.cnblogs.com/spnooyseed/p/14810702.html","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_26","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3.\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; const ll maxn = 400000 ; ll tree [ 400500 ] = { 0 }; ll a [ 200500 ] = { 0 }; ll b [ 200500 ] = { 0 }; unordered_map < int , vector < int > > mpa , mpb ; ll lowbit ( ll x ) { return x & ( - x ); } void add ( ll pos , ll val ) { for ( ll i = pos ; i <= 400000 ; i += lowbit ( i )) tree [ i ] += val ; } ll query ( ll pos ) { ll ans = 0 ; for ( ll i = pos ; i >= 1 ; i -= lowbit ( i )) ans += tree [ i ]; return ans ; } int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); a [ i ] += i ; mpa [ a [ i ]]. push_back ( i ); } for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & b [ i ]); b [ i ] += i ; mpb [ b [ i ]]. push_back ( i ); } for ( auto v : mpa ) { if ( v . second . size () != mpb [ v . first ]. size ()) return 0 * puts ( \"-1\" ); auto v2 = mpb [ v . first ]; for ( int i = 0 ; i < v . second . size (); i ++ ) a [ v . second [ i ]] = v2 [ i ]; } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { add ( a [ i ], 1 ); ans += i - query ( a [ i ]); } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#4","text":"","title":"\u9898\u76ee4"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_27","text":"http://icpc.upc.edu.cn/problem.php?cid=2890&pid=3","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_28","text":"Farmer John has discovered that his cows produce higher quality milk when they are subject to strenuous exercise. He therefore decides to send his N cows (1 <= N <= 25,000) to climb up and then back down a nearby mountain! Cow i takes U(i) time to climb up the mountain and then D(i) time to climb down the mountain. Being domesticated cows, each cow needs the help of a farmer for each leg of the climb, but due to the poor economy, there are only two farmers available, Farmer John and his cousin Farmer Don. FJ plans to guide cows for the upward climb, and FD will then guide the cows for the downward climb. Since every cow needs a guide, and there is only one farmer for each part of the voyage, at most one cow may be climbing upward at any point in time (assisted by FJ), and at most one cow may be climbing down at any point in time (assisted by FD). A group of cows may temporarily accumulate at the top of the mountain if they climb up and then need to wait for FD's assistance before climbing down. Cows may climb down in a different order than they climbed up. Please determine the least possible amount of time for all N cows to make the entire journey.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_29","text":"Line 1: The number of cows, N. Lines 2..1+N: Line i+1 contains two space-separated integers: U(i) and D(i). (1 <= U(i), D(i) <= 50,000).","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_30","text":"Line 1: A single integer representing the least amount of time for all the cows to cross the mountain.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_31","text":"3 6 4 8 1 2 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_32","text":"17","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_33","text":"\u8d2a\u5fc3\uff0c\u8be6\u7ec6\u89c1\u4ee3\u7801\u6ce8\u91ca\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_34","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll u , d , sum , sum1 ; }; bool cmp ( node a , node b ) { if ( a . d > a . u && b . d <= b . u ) ///\u4e0b\u5c71\u6bd4\u4e0a\u5c71\u6162\u7684\u7684\u4f18\u5148\u4e0a return 1 ; else if ( a . d <= a . u && b . d > b . u ) return 0 ; else if ( a . d > a . u ) ///\u5148\u4e0a\u7684\u4f18\u5148\u8ba9\u4e0a\u5c71\u5feb\u7684\u4e0a\uff0c\u52a0\u901f\u65f6\u95f4 return a . u < b . u ; else return a . d > b . d ; ///\u540e\u4e0a\u7684\u4f18\u5148\u8ba9\u4e0b\u5c71\u7684\u6162\u7684\u4e0a\uff0c\u5c3d\u53ef\u80fd\u62d6\u5ef6\u65f6\u95f4 } node a [ 25500 ] = { 0 }; int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld%lld\" , & a [ i ]. u , & a [ i ]. d ); sort ( a + 1 , a + n + 1 , cmp ); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) a [ i ]. sum = a [ i -1 ]. sum + a [ i ]. u ; for ( ll i = 1 ; i <= n ; i ++ ) { a [ i ]. sum1 = max ( a [ i ]. sum , a [ i -1 ]. sum1 ) + a [ i ]. d ; ans = max ( ans , a [ i ]. sum1 ); } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e8c\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2852&pid=5 \u9898\u76ee\u63cf\u8ff0 \u00b6 Given a sequence of integers of length n, find the shortest consecutive subsequence witch XOR sum not less than k. If there are multiple consecutive subsequences of the same length, print the consecutive subsequence with the smallest left end point. If there are no consecutive subsequence witch XOR sum not less than k, just print \"-1\". \u8f93\u5165 \u00b6 The first line contains a single integer t (t<=100) representing the number of test cases in the input. Then t test cases follow. The first line of each test case contains two integers n (1<=n<=100000) and k (0<=k<2^30), representing the length of sequence. The second line of each test contains n integers ai (0<=ai<2^30), representing the integers in sequence. The number of test witch n>1000 does not exceed 5. \u8f93\u51fa \u00b6 For each test case, print two integers in one line, representing the left end point and right end point of the consecutive subsequence. If there are no consecutive subsequence witch XOR sum not less than k, print \"-1\" in one line. \u6837\u4f8b\u8f93\u5165 \u00b6 2 3 2 1 2 2 9 7 3 1 3 2 4 0 3 5 1 \u6837\u4f8b\u8f93\u51fa \u00b6 2 2 5 7 \u9898\u89e3 \u00b6 \u6784\u902001\u5b57\u5178\u6811\uff0c\u904d\u5386\u53f3\u8282\u70b9\uff0c\u67e5\u627e\u7b26\u5408\u6761\u4ef6\u7684\u5de6\u8282\u70b9\u6700\u5927\u503c\uff0c\u53ef\u53c2\u7167\u535a\u5ba2\uff1a https://www.cnblogs.com/lipoicyclic/p/15040070.html#4911382 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; int ch [ 3005000 ][ 2 ] = { 0 }; int val [ 3005000 ] = { 0 }; int max_pos [ 3005000 ] = { 0 }; int total = 0 ; int sum [ 100500 ] = { 0 }, a [ 100600 ] = { 0 }; int n , k ; void init () { ch [ 0 ][ 0 ] = ch [ 0 ][ 1 ] = 0 ; total = 1 ; for ( int i = 0 ; i <= 32 * n ; i ++ ) max_pos [ i ] = 0 ; } void insert ( int x , int pos ) { int u = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { int v = ( x >> i ) & 1 ; max_pos [ u ] = max ( max_pos [ u ], pos ); if ( ! ch [ u ][ v ]) { ch [ total ][ 0 ] = ch [ total ][ 1 ] = 0 ; ///\u521d\u59cb\u5316 val [ total ] = 0 ; ///\u672a\u5230\u5e95\u90e8\u8282\u70b9\uff0c\u4e3a0 ch [ u ][ v ] = total ++ ; } u = ch [ u ][ v ]; } val [ u ] = x ; max_pos [ u ] = max ( max_pos [ u ], pos ); } int dfs ( int p , int sum , int i , int k , int x ) { int ans = -1 ; if ( sum >= k ) return max_pos [ p ]; if ( sum + ((( 1l l << ( i + 1 )) - 1 )) < k ) return -1 ; if ( ch [ p ][ 0 ]) ans = max ( ans , dfs ( ch [ p ][ 0 ], sum + ( x & ( 1 << i )), i - 1 , k , x )); if ( ch [ p ][ 1 ]) ans = max ( ans , dfs ( ch [ p ][ 1 ], sum + (( x & ( 1 << i )) ^ ( 1 << i )), i - 1 , k , x )); return ans ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & k ); init (); insert ( 0 , 0 ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); sum [ i ] = sum [ i - 1 ] ^ a [ i ]; } int min_num = inf , ansl = -1 , ansr = -1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] >= k ) { min_num = 1 ; ansl = ansr = i ; break ; } int lpos = dfs ( 0 , 0 , 31 , k , sum [ i ]); if ( lpos != -1 && ( sum [ i ] ^ sum [ lpos ]) >= k ) { int len = i - lpos ; if ( len < min_num ) { min_num = len ; ansl = lpos + 1 ; ansr = i ; } else if ( len == min_num ) { if ( lpos + 1 < ansl ) ansl = lpos + 1 , ansr = i ; } } insert ( sum [ i ], i ); } if ( min_num != inf ) { printf ( \"%d %d \\n \" , ansl , ansr ); } else { printf ( \"-1 \\n \" ); } } } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2852&pid=7 \u9898\u76ee\u63cf\u8ff0 \u00b6 Given a matrix of n rows and m columns,find the largest area submatrix which is non decreasing on each column \u8f93\u5165 \u00b6 The first line contains an integer T(1\u2264T\u226410)representing the number of test cases. For each test case, the first line contains two integers n,m(1\u2264n,m\u22642\u2217103)representing the size of the matrix the next n line followed. the i-th line contains m integers vij(1\u2264vij\u22645\u2217103)representing the value of matrix It is guaranteed that there are no more than 2 testcases with n\u2217m>10000 \u8f93\u51fa \u00b6 For each test case, print a integer representing the Maximal submatrix \u6837\u4f8b\u8f93\u5165 \u00b6 1 2 3 1 2 4 2 3 3 \u6837\u4f8b\u8f93\u51fa \u00b6 4 \u9898\u89e3 \u00b6 \u627e\u6700\u5927\u7684\u4e0a\u5347\u5b50\u77e9\u9635\uff0c\u5229\u7528\u5355\u8c03\u6808\u7ef4\u62a4\u6bcf\u4e00\u884c\u7684\u5217\u6700\u5927\u4e0a\u5347\u503c\u548c\u5bbd\u5ea6\u7684\u4e58\u79ef\u5e76\u6c42\u51fa\u6700\u5927\u503c\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 2050 ][ 2050 ] = { 0 }; int sum [ 2050 ][ 2050 ] = { 0 }; struct node { int pos , val ; }; node s [ 100500 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d %d\" , & n , & m ); for ( int i = 0 ; i <= n + 1 ; i ++ ) for ( int j = 0 ; j <= m + 1 ; j ++ ) a [ i ][ j ] = sum [ i ][ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) scanf ( \"%d\" , & a [ i ][ j ]); for ( int j = 1 ; j <= m ; j ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ][ j ] >= a [ i - 1 ][ j ]) sum [ i ][ j ] = sum [ i - 1 ][ j ] + 1 ; else sum [ i ][ j ] = 1 ; } } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll top = 0 ; for ( ll j = 1 ; j <= m + 1 ; j ++ ) { if ( top == 0 ) { s [ ++ top ] = { j , sum [ i ][ j ]}; } else { while ( s [ top ]. val > sum [ i ][ j ]) { ll tmp = ( ll )( j - s [ top -1 ]. pos - 1 ) * ( ll ) s [ top ]. val ; top -- ; ans = max ( ans , tmp ); } s [ ++ top ] = { j , sum [ i ][ j ]}; } } } printf ( \"%lld \\n \" , ans ); } } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 https://ac.nowcoder.com/acm/contest/11255/J \u9898\u76ee\u622a\u56fe \u00b6 \u9898\u89e3 \u00b6 \u4e8c\u5206\u7b54\u6848\uff0c\u67e5\u627e\u957f\u5ea6\u5927\u4e8e\u67d0\u4e00\u7279\u5b9a\u503c\u7684\u5b50\u5e8f\u5217\u5e73\u5747\u503c\u6700\u5927\u503c\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; int a [ 100500 ] = { 0 }, b [ 100500 ] = { 0 }; int check ( int a [], double mid , int n , int k ) { double sum [ 100500 ] = { 0 }; double min1 [ 100500 ] = { 0 }; for ( int i = 1 ; i <= n ; i ++ ) min1 [ i ] = 2e5 ; for ( int i = 1 ; i <= n ; i ++ ) { sum [ i ] = sum [ i -1 ] + a [ i ] - mid ; min1 [ i ] = min ( min1 [ i -1 ], sum [ i ]); } for ( int i = k ; i <= n ; i ++ ) { if (( sum [ i ] - min1 [ i - k ]) >= 0.0000 ) return 1 ; } return 0 ; } int main () { int n , m , x , y ; scanf ( \"%d%d\" , & n , & m ); scanf ( \"%d%d\" , & x , & y ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); for ( int i = 1 ; i <= m ; i ++ ) scanf ( \"%d\" , & b [ i ]); double l = 0 , r = 1e5 ; while ( abs ( l - r ) > 1e-9 ) { double mid = ( l + r ) / 2.0 ; if ( check ( a , mid , n , x )) l = mid ; else r = mid ; } double ans1 = l ; l = 0 , r = 1e5 ; while ( abs ( l - r ) > 1e-9 ) { double mid = ( l + r ) / 2.0 ; if ( check ( b , mid , m , y )) l = mid ; else r = mid ; } double ans2 = l ; printf ( \"%.10f \\n \" , ans2 + ans1 ); }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e8c\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e8c\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_2","text":"http://icpc.upc.edu.cn/problem.php?cid=2852&pid=5","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_3","text":"Given a sequence of integers of length n, find the shortest consecutive subsequence witch XOR sum not less than k. If there are multiple consecutive subsequences of the same length, print the consecutive subsequence with the smallest left end point. If there are no consecutive subsequence witch XOR sum not less than k, just print \"-1\".","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_4","text":"The first line contains a single integer t (t<=100) representing the number of test cases in the input. Then t test cases follow. The first line of each test case contains two integers n (1<=n<=100000) and k (0<=k<2^30), representing the length of sequence. The second line of each test contains n integers ai (0<=ai<2^30), representing the integers in sequence. The number of test witch n>1000 does not exceed 5.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_5","text":"For each test case, print two integers in one line, representing the left end point and right end point of the consecutive subsequence. If there are no consecutive subsequence witch XOR sum not less than k, print \"-1\" in one line.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_6","text":"2 3 2 1 2 2 9 7 3 1 3 2 4 0 3 5 1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_7","text":"2 2 5 7","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_8","text":"\u6784\u902001\u5b57\u5178\u6811\uff0c\u904d\u5386\u53f3\u8282\u70b9\uff0c\u67e5\u627e\u7b26\u5408\u6761\u4ef6\u7684\u5de6\u8282\u70b9\u6700\u5927\u503c\uff0c\u53ef\u53c2\u7167\u535a\u5ba2\uff1a https://www.cnblogs.com/lipoicyclic/p/15040070.html#4911382","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_9","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; int ch [ 3005000 ][ 2 ] = { 0 }; int val [ 3005000 ] = { 0 }; int max_pos [ 3005000 ] = { 0 }; int total = 0 ; int sum [ 100500 ] = { 0 }, a [ 100600 ] = { 0 }; int n , k ; void init () { ch [ 0 ][ 0 ] = ch [ 0 ][ 1 ] = 0 ; total = 1 ; for ( int i = 0 ; i <= 32 * n ; i ++ ) max_pos [ i ] = 0 ; } void insert ( int x , int pos ) { int u = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { int v = ( x >> i ) & 1 ; max_pos [ u ] = max ( max_pos [ u ], pos ); if ( ! ch [ u ][ v ]) { ch [ total ][ 0 ] = ch [ total ][ 1 ] = 0 ; ///\u521d\u59cb\u5316 val [ total ] = 0 ; ///\u672a\u5230\u5e95\u90e8\u8282\u70b9\uff0c\u4e3a0 ch [ u ][ v ] = total ++ ; } u = ch [ u ][ v ]; } val [ u ] = x ; max_pos [ u ] = max ( max_pos [ u ], pos ); } int dfs ( int p , int sum , int i , int k , int x ) { int ans = -1 ; if ( sum >= k ) return max_pos [ p ]; if ( sum + ((( 1l l << ( i + 1 )) - 1 )) < k ) return -1 ; if ( ch [ p ][ 0 ]) ans = max ( ans , dfs ( ch [ p ][ 0 ], sum + ( x & ( 1 << i )), i - 1 , k , x )); if ( ch [ p ][ 1 ]) ans = max ( ans , dfs ( ch [ p ][ 1 ], sum + (( x & ( 1 << i )) ^ ( 1 << i )), i - 1 , k , x )); return ans ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & k ); init (); insert ( 0 , 0 ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); sum [ i ] = sum [ i - 1 ] ^ a [ i ]; } int min_num = inf , ansl = -1 , ansr = -1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] >= k ) { min_num = 1 ; ansl = ansr = i ; break ; } int lpos = dfs ( 0 , 0 , 31 , k , sum [ i ]); if ( lpos != -1 && ( sum [ i ] ^ sum [ lpos ]) >= k ) { int len = i - lpos ; if ( len < min_num ) { min_num = len ; ansl = lpos + 1 ; ansr = i ; } else if ( len == min_num ) { if ( lpos + 1 < ansl ) ansl = lpos + 1 , ansr = i ; } } insert ( sum [ i ], i ); } if ( min_num != inf ) { printf ( \"%d %d \\n \" , ansl , ansr ); } else { printf ( \"-1 \\n \" ); } } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_10","text":"http://icpc.upc.edu.cn/problem.php?cid=2852&pid=7","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_11","text":"Given a matrix of n rows and m columns,find the largest area submatrix which is non decreasing on each column","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_12","text":"The first line contains an integer T(1\u2264T\u226410)representing the number of test cases. For each test case, the first line contains two integers n,m(1\u2264n,m\u22642\u2217103)representing the size of the matrix the next n line followed. the i-th line contains m integers vij(1\u2264vij\u22645\u2217103)representing the value of matrix It is guaranteed that there are no more than 2 testcases with n\u2217m>10000","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_13","text":"For each test case, print a integer representing the Maximal submatrix","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_14","text":"1 2 3 1 2 4 2 3 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_15","text":"4","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_16","text":"\u627e\u6700\u5927\u7684\u4e0a\u5347\u5b50\u77e9\u9635\uff0c\u5229\u7528\u5355\u8c03\u6808\u7ef4\u62a4\u6bcf\u4e00\u884c\u7684\u5217\u6700\u5927\u4e0a\u5347\u503c\u548c\u5bbd\u5ea6\u7684\u4e58\u79ef\u5e76\u6c42\u51fa\u6700\u5927\u503c\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_17","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 2050 ][ 2050 ] = { 0 }; int sum [ 2050 ][ 2050 ] = { 0 }; struct node { int pos , val ; }; node s [ 100500 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d %d\" , & n , & m ); for ( int i = 0 ; i <= n + 1 ; i ++ ) for ( int j = 0 ; j <= m + 1 ; j ++ ) a [ i ][ j ] = sum [ i ][ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) scanf ( \"%d\" , & a [ i ][ j ]); for ( int j = 1 ; j <= m ; j ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ][ j ] >= a [ i - 1 ][ j ]) sum [ i ][ j ] = sum [ i - 1 ][ j ] + 1 ; else sum [ i ][ j ] = 1 ; } } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll top = 0 ; for ( ll j = 1 ; j <= m + 1 ; j ++ ) { if ( top == 0 ) { s [ ++ top ] = { j , sum [ i ][ j ]}; } else { while ( s [ top ]. val > sum [ i ][ j ]) { ll tmp = ( ll )( j - s [ top -1 ]. pos - 1 ) * ( ll ) s [ top ]. val ; top -- ; ans = max ( ans , tmp ); } s [ ++ top ] = { j , sum [ i ][ j ]}; } } } printf ( \"%lld \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_18","text":"https://ac.nowcoder.com/acm/contest/11255/J","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_19","text":"","title":"\u9898\u76ee\u622a\u56fe"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_20","text":"\u4e8c\u5206\u7b54\u6848\uff0c\u67e5\u627e\u957f\u5ea6\u5927\u4e8e\u67d0\u4e00\u7279\u5b9a\u503c\u7684\u5b50\u5e8f\u5217\u5e73\u5747\u503c\u6700\u5927\u503c\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_21","text":"#include <bits/stdc++.h> using namespace std ; int a [ 100500 ] = { 0 }, b [ 100500 ] = { 0 }; int check ( int a [], double mid , int n , int k ) { double sum [ 100500 ] = { 0 }; double min1 [ 100500 ] = { 0 }; for ( int i = 1 ; i <= n ; i ++ ) min1 [ i ] = 2e5 ; for ( int i = 1 ; i <= n ; i ++ ) { sum [ i ] = sum [ i -1 ] + a [ i ] - mid ; min1 [ i ] = min ( min1 [ i -1 ], sum [ i ]); } for ( int i = k ; i <= n ; i ++ ) { if (( sum [ i ] - min1 [ i - k ]) >= 0.0000 ) return 1 ; } return 0 ; } int main () { int n , m , x , y ; scanf ( \"%d%d\" , & n , & m ); scanf ( \"%d%d\" , & x , & y ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); for ( int i = 1 ; i <= m ; i ++ ) scanf ( \"%d\" , & b [ i ]); double l = 0 , r = 1e5 ; while ( abs ( l - r ) > 1e-9 ) { double mid = ( l + r ) / 2.0 ; if ( check ( a , mid , n , x )) l = mid ; else r = mid ; } double ans1 = l ; l = 0 , r = 1e5 ; while ( abs ( l - r ) > 1e-9 ) { double mid = ( l + r ) / 2.0 ; if ( check ( b , mid , m , y )) l = mid ; else r = mid ; } double ans2 = l ; printf ( \"%.10f \\n \" , ans2 + ans1 ); }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e94\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u9e3d\u5b50 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u4f60\u7684\u673a\u623f\u5171\u6709 n \u53f0\u7535\u8111\uff0c\u4f46\u662f\u7b2c k \u53f0\u7535\u8111\u574f\u4e86\u3002 \u4f60\u7684\u8001\u5e08\u7ed9\u4f60 m \u6b21\u8981\u6c42\uff0c\u6bcf\u6b21\u8981\u6c42\u4f60\u5c06\u7b2c ui \u548c vi \u53f0\u7535\u8111\u4ea4\u6362\uff0c\u8fd9\u6837\u574f\u7684\u7535\u8111\u5c31\u53ef\u80fd\u4f1a\u88ab\u4ea4\u6362\u5230\u4e00\u4e2a\u65b0\u7684\u4f4d\u7f6e\u3002 \u4f46\u7531\u4e8e\u4f60\u5e0c\u671b\u8fdb\u884c\u6697\u7bb1\u64cd\u4f5c\uff0c\u4f60\u53ef\u4ee5\u62d2\u7edd\u6267\u884c\u5176\u4e2d\u7684\u82e5\u5e72\u6761\u8981\u6c42\uff0c\u4f7f\u5f97\u574f\u7684\u7535\u8111\u6700\u7ec8\u4ea4\u6362\u5230 j \u53f7\u4f4d\u7f6e\u3002 \u7531\u4e8e\u9a97\u8fc7\u8001\u5e08\u5f88\u7d2f\uff0c\u8bf7\u5bf9\u4e8e j=1...n \u6c42\u51fa\u6700\u5c11\u53ef\u80fd\u7684\u4e0d\u6267\u884c\u8981\u6c42\u6761\u6570\uff0c\u4f7f\u5f97\u574f\u7684\u7535\u8111\u5728\u7b2c j \u4e2a\u4f4d\u7f6e\u3002 \u8f93\u5165 \u00b6 \u672c\u9898\u6709\u591a\u7ec4\u6d4b\u8bd5\u6570\u636e\u3002 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6570 T \u8868\u793a\u4e00\u5171\u6709 T \u7ec4\u6570\u636e\u3002\u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u6570\u636e\uff1a \u7b2c\u4e00\u884c\u4e09\u4e2a\u6574\u6570 n,m,k \uff0c\u8868\u793a\u7535\u8111\u4e2a\u6570\uff0c\u603b\u64cd\u4f5c\u6b21\u6570\u548c\u574f\u7535\u8111\u7684\u521d\u59cb\u4f4d\u7f6e\u3002 \u4e0b\u9762 m \u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6b63\u6574\u6570 ui , vi \uff0c\u8868\u793a\u8fd9\u6b21\u64cd\u4f5c\u9009\u62e9\u7684\u4e24\u4e2a\u4f4d\u7f6e\u3002 \u6ee1\u8db3 1\u2264T\u22645\uff0c1\u2264n\u226410 5\uff0c0\u2264m\u226410 5\uff0c1\u2264k\u2264n\u3002 \u8f93\u51fa \u00b6 \u5bf9\u6bcf\u7ec4\u6570\u636e\uff0c\u8f93\u51fa\u5171\u4e00\u884c n \u4e2a\u6574\u6570\uff0c\u7b2c i \u4e2a\u6574\u6570\u8868\u793a\u4f7f\u574f\u7535\u8111\u6700\u7ec8\u505c\u7559\u5728\u8be5\u4f4d\u7f6e\u6240\u9700\u7684\u6700\u5c11\u6697\u7bb1\u64cd\u4f5c\u6b21\u6570\u3002 \u82e5\u6700\u7ec8\u574f\u7535\u8111\u4e0d\u53ef\u80fd\u505c\u7559\u5728\u8be5\u4f4d\u7f6e\uff0c\u5219\u8f93\u51fa \u22121\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 1 5 5 1 3 5 2 1 4 1 3 1 3 1 \u6837\u4f8b\u8f93\u51fa \u00b6 2 0 3 1 -1 \u9898\u89e3 \u00b6 \u52a8\u6001\u89c4\u5212\uff0c\u5f53\u8981\u6c42\u8f6c\u79fbu\u548cv\u65f6\uff1a dp[i][u]=min(dp[i-1][u]+1,dp[i-1][v]); dp[i][v]=min(dp[i-1][v]+1,dp[i-1][u]); \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll dp [ 200500 ] = { 0 }; int main () { // freopen(\"in.txt\",\"r\",stdin); // freopen(\"out.txt\",\"w\",stdout); ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , m , k ; scanf ( \"%lld%lld%lld\" , & n , & m , & k ); for ( ll i = 1 ; i <= n ; i ++ ) dp [ i ] = inf ; dp [ k ] = 0 ; ll u , v ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld\" , & u , & v ); ll tmpv = min ( dp [ v ] + 1 , dp [ u ]); ll tmpu = min ( dp [ u ] + 1 , dp [ v ]); dp [ v ] = tmpv ; dp [ u ] = tmpu ; } for ( ll i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] == inf ) { if ( i != n ) printf ( \"-1 \" ); else printf ( \"-1\" ); } else { if ( i != n ) printf ( \"%lld \" , dp [ i ]); else printf ( \"%lld\" , dp [ i ]); } } printf ( \" \\n \" ); } } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u8ff7\u5931 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u5c0f T \u8ff7\u5931\u5728\u4e86\u4e00\u4e2a\u6709 n \u4e2a\u70b9\u7684\u7fa4\u5c9b\u4e0a\u3002 \u521d\u59cb\u65f6\u4ed6\u5728 1 \u53f7\u5c9b\uff0c\u4ed6\u8981\u901a\u8fc7\u67b6\u5728\u5c9b\u95f4\u7684 m \u5ea7\u53cc\u5411\u6865\uff0c\u5728\u6b63\u597d\u8fc7 k \u5ea7\u6865\u65f6\u8fbe\u5230 n \u53f7\u5c9b\u7684\u5927\u95e8\u3002 \u8fd9\u4e9b\u6865\u4e2d\u6709\u82e5\u5e72\u5ea7\u9644\u9b54\u6865\u3002\u5f53\u5c0f T \u7ecf\u8fc7\u4e00\u5ea7\u9644\u9b54\u6865\u65f6\uff0c\u5982\u679c\u4ed6\u8eab\u4e0a\u6ca1\u6709\u9644\u9b54\u6807\u8bb0\u5219\u88ab\u6807\u8bb0\uff0c\u5982\u679c\u4ed6\u8eab\u4e0a\u5df2\u6709\u9644\u9b54\u6807\u8bb0\u5219\u6807\u8bb0\u6d88\u5931\u3002 \u5927\u95e8\u53ea\u4f1a\u5728\u4ed6\u8eab\u4e0a\u6709\u9644\u9b54\u6807\u8bb0\u65f6\u624d\u4f1a\u5f00\u542f\uff0c\u53ea\u6709\u8fd9\u6837\u4ed6\u624d\u80fd\u9003\u79bb\u3002 \u5c0f T \u8ff7\u5931\u5728\u4e86\u7fa4\u5c9b\u4e4b\u95f4\uff0c\u4ed6\u6bcf\u6b21\u4f1a\u7b49\u6982\u7387\u968f\u673a\u6311\u9009\u4e00\u5ea7\u4e0e\u4ed6\u6240\u5728\u5c9b\u5c7f\u76f8\u8fde\u7684\u6865\u8d70\u3002\u5c0f T \u5411\u4f60\u8be2\u95ee\u4ed6\u80fd\u9003\u79bb\u7684\u6982\u7387\u3002 \u4fdd\u8bc1\u56fe\u65e0\u81ea\u73af\u65e0\u91cd\u8fb9\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6570 T \u8868\u793a\u4e00\u5171\u6709 T \u7ec4\u6570\u636e\u3002\u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u6570\u636e\uff1a \u7b2c\u4e00\u884c\u4e09\u4e2a\u6b63\u6574\u6570 n\uff0cm\uff0ck\u3002 \u6b64\u540e m \u884c\uff0c\u6bcf\u884c\u4e09\u4e2a\u6570 ui\uff0cvi\uff0cwi \uff0c\u8868\u793a\u4e00\u5ea7\u4ece ui \u5230 vi \u7684\u6865\u3002\u82e5 wi=1 \u5219\u8be5\u6865\u662f\u9644\u9b54\u6865\uff0c\u5426\u5219\uff08wi=0\uff09\u662f\u666e\u901a\u6865\u3002 \u4fdd\u8bc1\u65e0\u81ea\u73af\u65e0\u91cd\u8fb9\uff0cT\u226410\uff0c1\u2264ui,vi\u2264n\uff0cwi \u4e3a 0 \u5230 1 \u7684\u6574\u6570\uff0c\u6ee1\u8db3 2\u2264n\u2264100\uff0c1\u2264m\u2264n\u00d7(n\u22121)/2\uff0c1\u2264k\u226410^6\u3002 \u8f93\u51fa \u00b6 \u8f93\u51fa\u4e00\u5171 T \u884c\u3002\u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u6570\u636e\uff0c\u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570\uff1a\u4ed6\u80fd\u9003\u79bb\u7684\u6982\u7387\u5bf9 998244353 \u7684\u6a21\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 2 4 4 2 1 2 1 2 4 0 1 3 0 3 4 0 6 7 2 1 2 0 1 3 1 1 4 1 2 5 0 3 5 0 3 6 0 4 6 0 \u6837\u4f8b\u8f93\u51fa \u00b6 748683265 610038216 \u63d0\u793a \u00b6 \u7b2c\u4e00\u7ec4\u6570\u636e \u4ece 1 1 \u8d70\u5230 n n \u5e76\u4e14\u7ecf\u8fc7\u4e00\u6761\u9644\u9b54\u8fb9\u7684\u6982\u7387\u4e3a 1/4 1/4 \uff0c\u5bf9 998244353 998244353 \u53d6\u6a21\u540e\u4e3a 748683265 748683265 \u3002 \u7b2c\u4e8c\u7ec4\u6570\u636e \u6982\u7387\u4e3a 5/18 5/18 \uff0c\u5bf9 998244353 998244353 \u53d6\u6a21\u540e\u4e3a 610038216 610038216 \u200b\u3002 \u9898\u89e3 \u00b6 \u77e9\u9635\u5feb\u901f\u5e42\uff0c\u901a\u8fc7\u6784\u9020\u90bb\u63a5\u77e9\u9635\u505a\u4e58\u6cd5\u5e42\u8fd0\u7b97\u7684\u65b9\u5f0f\u8ba1\u7b97\u51fa\u6700\u7ec8\u7684\u6982\u7387\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b % 2 ) ans1 = ( ans2 * ans1 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } ll a [ 400 ][ 400 ] = { 0 }; ll ans1 [ 400 ][ 400 ] = { 0 }; ll ans2 [ 400 ][ 400 ] = { 0 }; vector < pair < int , int >> v [ 400 ]; int n , m , k ; void cf ( ll a [ 400 ][ 400 ], ll b [ 400 ][ 400 ]) { ll c [ 400 ][ 400 ] = { 0 }; for ( ll i = 1 ; i <= 2 * n ; i ++ ) { for ( ll j = 1 ; j <= 2 * n ; j ++ ) { for ( ll k = 1 ; k <= 2 * n ; k ++ ) { c [ i ][ j ] += a [ i ][ k ] * b [ k ][ j ]; c [ i ][ j ] %= mod ; } } } for ( ll i = 1 ; i <= 2 * n ; i ++ ) { for ( ll j = 1 ; j <= 2 * n ; j ++ ) { a [ i ][ j ] = c [ i ][ j ]; a [ i ][ j ] %= mod ; } } } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d %d\" , & n , & m , & k ); memset ( a , 0 , sizeof ( a )); for ( int i = 1 ; i <= n ; i ++ ) v [ i ]. clear (); int from , to , val ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d %d %d\" , & from , & to , & val ); v [ from ]. push_back ({ to , val }); v [ to ]. push_back ({ from , val }); } for ( int i = 1 ; i <= n ; i ++ ) { ll tmp = ksm (( ll ) v [ i ]. size (), mod - 2 ); for ( int k = 0 ; k < v [ i ]. size (); k ++ ) { pair < int , int > j = v [ i ][ k ]; if ( j . second == 0 ) { a [ i * 2 - 1 ][ j . first * 2 - 1 ] = tmp ; a [ i * 2 ][ j . first * 2 ] = tmp ; } else { a [ i * 2 - 1 ][ j . first * 2 ] = tmp ; a [ i * 2 ][ j . first * 2 - 1 ] = tmp ; } } } for ( ll i = 1 ; i <= 2 * n ; i ++ ) { for ( ll j = 1 ; j <= 2 * n ; j ++ ) { ans1 [ i ][ j ] = a [ i ][ j ]; if ( i == j ) ans2 [ i ][ j ] = 1 ; else ans2 [ i ][ j ] = 0 ; } } while ( k != 0 ) { if ( k % 2 ) cf ( ans2 , ans1 ); cf ( ans1 , ans1 ); k /= 2 ; } printf ( \"%lld \\n \" , ans2 [ 1 ][ 2 * n ]); } } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 https://ac.nowcoder.com/acm/contest/11256/K \u9898\u76ee \u00b6 \u9898\u89e3 \u00b6 \u7ef4\u62a4\u5355\u8c03\u5b50\u5e8f\u5217\uff0c\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u533a\u95f4\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); while ( m -- ) { ll k ; scanf ( \"%lld\" , & k ); deque < ll > que1 , que2 ; ///\u7ef4\u62a4\u9012\u589e\u5e8f\u5217\u548c\u9012\u51cf\u5e8f\u5217 ll ans = 0 , last = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { while ( ! que1 . empty () && a [ que1 . back ()] < a [ i ]) ///\u9012\u51cf que1 . pop_back (); que1 . push_back ( i ); while ( ! que2 . empty () && a [ que2 . back ()] > a [ i ]) ///\u9012\u589e que2 . pop_back (); que2 . push_back ( i ); while ( ! que1 . empty () && ! que2 . empty () && a [ que1 . front ()] - a [ que2 . front ()] > k ) { if ( que1 . front () < que2 . front ()) ans += ( n - que2 . front () + 1 ) * ( que1 . front () - last ), last = que1 . front (), que1 . pop_front (); else ans += ( n - que1 . front () + 1 ) * ( que2 . front () - last ), last = que2 . front (), que2 . pop_front (); } } printf ( \"%lld \\n \" , ans ); } }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e94\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e94\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_2","text":"\u9e3d\u5b50","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_3","text":"\u4f60\u7684\u673a\u623f\u5171\u6709 n \u53f0\u7535\u8111\uff0c\u4f46\u662f\u7b2c k \u53f0\u7535\u8111\u574f\u4e86\u3002 \u4f60\u7684\u8001\u5e08\u7ed9\u4f60 m \u6b21\u8981\u6c42\uff0c\u6bcf\u6b21\u8981\u6c42\u4f60\u5c06\u7b2c ui \u548c vi \u53f0\u7535\u8111\u4ea4\u6362\uff0c\u8fd9\u6837\u574f\u7684\u7535\u8111\u5c31\u53ef\u80fd\u4f1a\u88ab\u4ea4\u6362\u5230\u4e00\u4e2a\u65b0\u7684\u4f4d\u7f6e\u3002 \u4f46\u7531\u4e8e\u4f60\u5e0c\u671b\u8fdb\u884c\u6697\u7bb1\u64cd\u4f5c\uff0c\u4f60\u53ef\u4ee5\u62d2\u7edd\u6267\u884c\u5176\u4e2d\u7684\u82e5\u5e72\u6761\u8981\u6c42\uff0c\u4f7f\u5f97\u574f\u7684\u7535\u8111\u6700\u7ec8\u4ea4\u6362\u5230 j \u53f7\u4f4d\u7f6e\u3002 \u7531\u4e8e\u9a97\u8fc7\u8001\u5e08\u5f88\u7d2f\uff0c\u8bf7\u5bf9\u4e8e j=1...n \u6c42\u51fa\u6700\u5c11\u53ef\u80fd\u7684\u4e0d\u6267\u884c\u8981\u6c42\u6761\u6570\uff0c\u4f7f\u5f97\u574f\u7684\u7535\u8111\u5728\u7b2c j \u4e2a\u4f4d\u7f6e\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_4","text":"\u672c\u9898\u6709\u591a\u7ec4\u6d4b\u8bd5\u6570\u636e\u3002 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6570 T \u8868\u793a\u4e00\u5171\u6709 T \u7ec4\u6570\u636e\u3002\u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u6570\u636e\uff1a \u7b2c\u4e00\u884c\u4e09\u4e2a\u6574\u6570 n,m,k \uff0c\u8868\u793a\u7535\u8111\u4e2a\u6570\uff0c\u603b\u64cd\u4f5c\u6b21\u6570\u548c\u574f\u7535\u8111\u7684\u521d\u59cb\u4f4d\u7f6e\u3002 \u4e0b\u9762 m \u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6b63\u6574\u6570 ui , vi \uff0c\u8868\u793a\u8fd9\u6b21\u64cd\u4f5c\u9009\u62e9\u7684\u4e24\u4e2a\u4f4d\u7f6e\u3002 \u6ee1\u8db3 1\u2264T\u22645\uff0c1\u2264n\u226410 5\uff0c0\u2264m\u226410 5\uff0c1\u2264k\u2264n\u3002","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_5","text":"\u5bf9\u6bcf\u7ec4\u6570\u636e\uff0c\u8f93\u51fa\u5171\u4e00\u884c n \u4e2a\u6574\u6570\uff0c\u7b2c i \u4e2a\u6574\u6570\u8868\u793a\u4f7f\u574f\u7535\u8111\u6700\u7ec8\u505c\u7559\u5728\u8be5\u4f4d\u7f6e\u6240\u9700\u7684\u6700\u5c11\u6697\u7bb1\u64cd\u4f5c\u6b21\u6570\u3002 \u82e5\u6700\u7ec8\u574f\u7535\u8111\u4e0d\u53ef\u80fd\u505c\u7559\u5728\u8be5\u4f4d\u7f6e\uff0c\u5219\u8f93\u51fa \u22121\u3002","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_6","text":"1 5 5 1 3 5 2 1 4 1 3 1 3 1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_7","text":"2 0 3 1 -1","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_8","text":"\u52a8\u6001\u89c4\u5212\uff0c\u5f53\u8981\u6c42\u8f6c\u79fbu\u548cv\u65f6\uff1a dp[i][u]=min(dp[i-1][u]+1,dp[i-1][v]); dp[i][v]=min(dp[i-1][v]+1,dp[i-1][u]);","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_9","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll dp [ 200500 ] = { 0 }; int main () { // freopen(\"in.txt\",\"r\",stdin); // freopen(\"out.txt\",\"w\",stdout); ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , m , k ; scanf ( \"%lld%lld%lld\" , & n , & m , & k ); for ( ll i = 1 ; i <= n ; i ++ ) dp [ i ] = inf ; dp [ k ] = 0 ; ll u , v ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld\" , & u , & v ); ll tmpv = min ( dp [ v ] + 1 , dp [ u ]); ll tmpu = min ( dp [ u ] + 1 , dp [ v ]); dp [ v ] = tmpv ; dp [ u ] = tmpu ; } for ( ll i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] == inf ) { if ( i != n ) printf ( \"-1 \" ); else printf ( \"-1\" ); } else { if ( i != n ) printf ( \"%lld \" , dp [ i ]); else printf ( \"%lld\" , dp [ i ]); } } printf ( \" \\n \" ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_10","text":"\u8ff7\u5931","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_11","text":"\u5c0f T \u8ff7\u5931\u5728\u4e86\u4e00\u4e2a\u6709 n \u4e2a\u70b9\u7684\u7fa4\u5c9b\u4e0a\u3002 \u521d\u59cb\u65f6\u4ed6\u5728 1 \u53f7\u5c9b\uff0c\u4ed6\u8981\u901a\u8fc7\u67b6\u5728\u5c9b\u95f4\u7684 m \u5ea7\u53cc\u5411\u6865\uff0c\u5728\u6b63\u597d\u8fc7 k \u5ea7\u6865\u65f6\u8fbe\u5230 n \u53f7\u5c9b\u7684\u5927\u95e8\u3002 \u8fd9\u4e9b\u6865\u4e2d\u6709\u82e5\u5e72\u5ea7\u9644\u9b54\u6865\u3002\u5f53\u5c0f T \u7ecf\u8fc7\u4e00\u5ea7\u9644\u9b54\u6865\u65f6\uff0c\u5982\u679c\u4ed6\u8eab\u4e0a\u6ca1\u6709\u9644\u9b54\u6807\u8bb0\u5219\u88ab\u6807\u8bb0\uff0c\u5982\u679c\u4ed6\u8eab\u4e0a\u5df2\u6709\u9644\u9b54\u6807\u8bb0\u5219\u6807\u8bb0\u6d88\u5931\u3002 \u5927\u95e8\u53ea\u4f1a\u5728\u4ed6\u8eab\u4e0a\u6709\u9644\u9b54\u6807\u8bb0\u65f6\u624d\u4f1a\u5f00\u542f\uff0c\u53ea\u6709\u8fd9\u6837\u4ed6\u624d\u80fd\u9003\u79bb\u3002 \u5c0f T \u8ff7\u5931\u5728\u4e86\u7fa4\u5c9b\u4e4b\u95f4\uff0c\u4ed6\u6bcf\u6b21\u4f1a\u7b49\u6982\u7387\u968f\u673a\u6311\u9009\u4e00\u5ea7\u4e0e\u4ed6\u6240\u5728\u5c9b\u5c7f\u76f8\u8fde\u7684\u6865\u8d70\u3002\u5c0f T \u5411\u4f60\u8be2\u95ee\u4ed6\u80fd\u9003\u79bb\u7684\u6982\u7387\u3002 \u4fdd\u8bc1\u56fe\u65e0\u81ea\u73af\u65e0\u91cd\u8fb9\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_12","text":"\u7b2c\u4e00\u884c\u4e00\u4e2a\u6570 T \u8868\u793a\u4e00\u5171\u6709 T \u7ec4\u6570\u636e\u3002\u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u6570\u636e\uff1a \u7b2c\u4e00\u884c\u4e09\u4e2a\u6b63\u6574\u6570 n\uff0cm\uff0ck\u3002 \u6b64\u540e m \u884c\uff0c\u6bcf\u884c\u4e09\u4e2a\u6570 ui\uff0cvi\uff0cwi \uff0c\u8868\u793a\u4e00\u5ea7\u4ece ui \u5230 vi \u7684\u6865\u3002\u82e5 wi=1 \u5219\u8be5\u6865\u662f\u9644\u9b54\u6865\uff0c\u5426\u5219\uff08wi=0\uff09\u662f\u666e\u901a\u6865\u3002 \u4fdd\u8bc1\u65e0\u81ea\u73af\u65e0\u91cd\u8fb9\uff0cT\u226410\uff0c1\u2264ui,vi\u2264n\uff0cwi \u4e3a 0 \u5230 1 \u7684\u6574\u6570\uff0c\u6ee1\u8db3 2\u2264n\u2264100\uff0c1\u2264m\u2264n\u00d7(n\u22121)/2\uff0c1\u2264k\u226410^6\u3002","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_13","text":"\u8f93\u51fa\u4e00\u5171 T \u884c\u3002\u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u6570\u636e\uff0c\u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570\uff1a\u4ed6\u80fd\u9003\u79bb\u7684\u6982\u7387\u5bf9 998244353 \u7684\u6a21\u3002","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_14","text":"2 4 4 2 1 2 1 2 4 0 1 3 0 3 4 0 6 7 2 1 2 0 1 3 1 1 4 1 2 5 0 3 5 0 3 6 0 4 6 0","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_15","text":"748683265 610038216","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_16","text":"\u7b2c\u4e00\u7ec4\u6570\u636e \u4ece 1 1 \u8d70\u5230 n n \u5e76\u4e14\u7ecf\u8fc7\u4e00\u6761\u9644\u9b54\u8fb9\u7684\u6982\u7387\u4e3a 1/4 1/4 \uff0c\u5bf9 998244353 998244353 \u53d6\u6a21\u540e\u4e3a 748683265 748683265 \u3002 \u7b2c\u4e8c\u7ec4\u6570\u636e \u6982\u7387\u4e3a 5/18 5/18 \uff0c\u5bf9 998244353 998244353 \u53d6\u6a21\u540e\u4e3a 610038216 610038216 \u200b\u3002","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_17","text":"\u77e9\u9635\u5feb\u901f\u5e42\uff0c\u901a\u8fc7\u6784\u9020\u90bb\u63a5\u77e9\u9635\u505a\u4e58\u6cd5\u5e42\u8fd0\u7b97\u7684\u65b9\u5f0f\u8ba1\u7b97\u51fa\u6700\u7ec8\u7684\u6982\u7387\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_18","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b % 2 ) ans1 = ( ans2 * ans1 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } ll a [ 400 ][ 400 ] = { 0 }; ll ans1 [ 400 ][ 400 ] = { 0 }; ll ans2 [ 400 ][ 400 ] = { 0 }; vector < pair < int , int >> v [ 400 ]; int n , m , k ; void cf ( ll a [ 400 ][ 400 ], ll b [ 400 ][ 400 ]) { ll c [ 400 ][ 400 ] = { 0 }; for ( ll i = 1 ; i <= 2 * n ; i ++ ) { for ( ll j = 1 ; j <= 2 * n ; j ++ ) { for ( ll k = 1 ; k <= 2 * n ; k ++ ) { c [ i ][ j ] += a [ i ][ k ] * b [ k ][ j ]; c [ i ][ j ] %= mod ; } } } for ( ll i = 1 ; i <= 2 * n ; i ++ ) { for ( ll j = 1 ; j <= 2 * n ; j ++ ) { a [ i ][ j ] = c [ i ][ j ]; a [ i ][ j ] %= mod ; } } } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d %d\" , & n , & m , & k ); memset ( a , 0 , sizeof ( a )); for ( int i = 1 ; i <= n ; i ++ ) v [ i ]. clear (); int from , to , val ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d %d %d\" , & from , & to , & val ); v [ from ]. push_back ({ to , val }); v [ to ]. push_back ({ from , val }); } for ( int i = 1 ; i <= n ; i ++ ) { ll tmp = ksm (( ll ) v [ i ]. size (), mod - 2 ); for ( int k = 0 ; k < v [ i ]. size (); k ++ ) { pair < int , int > j = v [ i ][ k ]; if ( j . second == 0 ) { a [ i * 2 - 1 ][ j . first * 2 - 1 ] = tmp ; a [ i * 2 ][ j . first * 2 ] = tmp ; } else { a [ i * 2 - 1 ][ j . first * 2 ] = tmp ; a [ i * 2 ][ j . first * 2 - 1 ] = tmp ; } } } for ( ll i = 1 ; i <= 2 * n ; i ++ ) { for ( ll j = 1 ; j <= 2 * n ; j ++ ) { ans1 [ i ][ j ] = a [ i ][ j ]; if ( i == j ) ans2 [ i ][ j ] = 1 ; else ans2 [ i ][ j ] = 0 ; } } while ( k != 0 ) { if ( k % 2 ) cf ( ans2 , ans1 ); cf ( ans1 , ans1 ); k /= 2 ; } printf ( \"%lld \\n \" , ans2 [ 1 ][ 2 * n ]); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_19","text":"https://ac.nowcoder.com/acm/contest/11256/K","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_20","text":"","title":"\u9898\u76ee"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_21","text":"\u7ef4\u62a4\u5355\u8c03\u5b50\u5e8f\u5217\uff0c\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u533a\u95f4\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_22","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); while ( m -- ) { ll k ; scanf ( \"%lld\" , & k ); deque < ll > que1 , que2 ; ///\u7ef4\u62a4\u9012\u589e\u5e8f\u5217\u548c\u9012\u51cf\u5e8f\u5217 ll ans = 0 , last = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { while ( ! que1 . empty () && a [ que1 . back ()] < a [ i ]) ///\u9012\u51cf que1 . pop_back (); que1 . push_back ( i ); while ( ! que2 . empty () && a [ que2 . back ()] > a [ i ]) ///\u9012\u589e que2 . pop_back (); que2 . push_back ( i ); while ( ! que1 . empty () && ! que2 . empty () && a [ que1 . front ()] - a [ que2 . front ()] > k ) { if ( que1 . front () < que2 . front ()) ans += ( n - que2 . front () + 1 ) * ( que1 . front () - last ), last = que1 . front (), que1 . pop_front (); else ans += ( n - que1 . front () + 1 ) * ( que2 . front () - last ), last = que2 . front (), que2 . pop_front (); } } printf ( \"%lld \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516b\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Grass Planting \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has N barren pastures (2 <= N <= 100,000) connected by N-1 bidirectional roads, such that there is exactly one path between any two pastures. Bessie, a cow who loves her grazing time, often complains about how there is no grass on the roads between pastures. Farmer John loves Bessie very much, and today he is finally going to plant grass on the roads. He will do so using a procedure consisting of M steps (1 <= M <=100,000). At each step one of two things will happen: - FJ will choose two pastures, and plant a patch of grass along each road in between the two pastures, or, - Bessie will ask about how many patches of grass on a particular road, and Farmer John must answer her question. Farmer John is a very poor counter -- help him answer Bessie's questions! \u8f93\u5165 \u00b6 Line 1: Two space-separated integers N and M Lines 2..N: Two space-separated integers describing the endpoints of a road. Lines N+1..N+M: Line i+1 describes step i. The first character of the line is either P or Q, which describes whether or not FJ is planting grass or simply querying. This is followed by two space-separated integers A_i and B_i (1 <= A_i, B_i <= N) which describe FJ's action or query. \u8f93\u51fa \u00b6 Lines 1..???: Each line has the answer to a query, appearing in the same order as the queries appear in the input. \u6837\u4f8b\u8f93\u5165 \u00b6 4 6 1 4 2 4 3 4 P 2 3 P 1 3 Q 3 4 P 1 4 Q 2 4 Q 1 4 \u6837\u4f8b\u8f93\u51fa \u00b6 2 1 2 \u9898\u89e3 \u00b6 \u6811\u94fe\u5256\u5206\uff0c\u5c06\u6811\u8fdb\u884c\u8fb9\u5256\u5206\u5229\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://oi-wiki.org/graph/hld/#_4 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll sum [ 400500 ] = { 0 }, lazy [ 400500 ] = { 0 }; ll dep [ 200500 ] = { 0 }, size1 [ 200500 ] = { 0 }, son [ 200500 ] = { 0 }, f [ 200500 ] = { 0 }, id [ 200500 ] = { 0 }, top [ 200500 ] = { 0 }; struct node { ll to , next ; }; node edge [ 400500 ] = { 0 }; ll head [ 400500 ] = { 0 }; ll num = 0 , cnt = 0 ; void add_edge ( ll from , ll to ) { edge [ ++ num ] = { to , head [ from ]}; head [ from ] = num ; } void dfs1 ( ll now , ll fa ) { size1 [ now ] = 1 ; for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == fa ) continue ; f [ to ] = now ; dep [ to ] = dep [ now ] + 1 ; dfs1 ( to , now ); size1 [ now ] += size1 [ to ]; if ( size1 [ to ] > size1 [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( ll now , ll fa ) { id [ now ] = ++ cnt ; top [ now ] = fa ; if ( son [ now ]) dfs2 ( son [ now ], fa ); for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == f [ now ] || to == son [ now ]) continue ; dfs2 ( to , to ); } } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t + 1 ] += lazy [ t ]; lazy [ 2 * t ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += ( mid - l + 1 ) * lazy [ t ]; sum [ 2 * t + 1 ] += ( r - mid ) * lazy [ t ]; lazy [ t ] = 0 ; } void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { lazy [ t ] += add ; sum [ t ] += add * ( R - L + 1 ); return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query ( ll t , ll l , ll r , ll L , ll R ) { if ( l <= L && R <= r ) return sum [ t ]; push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; ll ans = 0 ; if ( l <= mid ) ans += query ( 2 * t , l , r , L , mid ); if ( mid < r ) ans += query ( 2 * t + 1 , l , r , mid + 1 , R ); return ans ; } void update_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ]; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); update ( 1 , id [ fx ], id [ x ], 1 , cnt , 1 ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); update ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt , 1 ); } ll query_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ], ans = 0 ; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); ans += query ( 1 , id [ fx ], id [ x ], 1 , cnt ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); ans += query ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt ); return ans ; } int main () { ll n , m , from , to ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } f [ 1 ] = 0 , dep [ 1 ] = 1 ; dfs1 ( 1 , 0 ), dfs2 ( 1 , 1 ); char c [ 10 ]; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , c + 1 , & from , & to ); if ( c [ 1 ] == 'P' ) update_chain ( from , to ); else printf ( \"%lld \\n \" , query_chain ( from , to )); } }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516b\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516b\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_2","text":"Grass Planting","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_3","text":"Farmer John has N barren pastures (2 <= N <= 100,000) connected by N-1 bidirectional roads, such that there is exactly one path between any two pastures. Bessie, a cow who loves her grazing time, often complains about how there is no grass on the roads between pastures. Farmer John loves Bessie very much, and today he is finally going to plant grass on the roads. He will do so using a procedure consisting of M steps (1 <= M <=100,000). At each step one of two things will happen: - FJ will choose two pastures, and plant a patch of grass along each road in between the two pastures, or, - Bessie will ask about how many patches of grass on a particular road, and Farmer John must answer her question. Farmer John is a very poor counter -- help him answer Bessie's questions!","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_4","text":"Line 1: Two space-separated integers N and M Lines 2..N: Two space-separated integers describing the endpoints of a road. Lines N+1..N+M: Line i+1 describes step i. The first character of the line is either P or Q, which describes whether or not FJ is planting grass or simply querying. This is followed by two space-separated integers A_i and B_i (1 <= A_i, B_i <= N) which describe FJ's action or query.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_5","text":"Lines 1..???: Each line has the answer to a query, appearing in the same order as the queries appear in the input.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_6","text":"4 6 1 4 2 4 3 4 P 2 3 P 1 3 Q 3 4 P 1 4 Q 2 4 Q 1 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_7","text":"2 1 2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_8","text":"\u6811\u94fe\u5256\u5206\uff0c\u5c06\u6811\u8fdb\u884c\u8fb9\u5256\u5206\u5229\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://oi-wiki.org/graph/hld/#_4","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_9","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll sum [ 400500 ] = { 0 }, lazy [ 400500 ] = { 0 }; ll dep [ 200500 ] = { 0 }, size1 [ 200500 ] = { 0 }, son [ 200500 ] = { 0 }, f [ 200500 ] = { 0 }, id [ 200500 ] = { 0 }, top [ 200500 ] = { 0 }; struct node { ll to , next ; }; node edge [ 400500 ] = { 0 }; ll head [ 400500 ] = { 0 }; ll num = 0 , cnt = 0 ; void add_edge ( ll from , ll to ) { edge [ ++ num ] = { to , head [ from ]}; head [ from ] = num ; } void dfs1 ( ll now , ll fa ) { size1 [ now ] = 1 ; for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == fa ) continue ; f [ to ] = now ; dep [ to ] = dep [ now ] + 1 ; dfs1 ( to , now ); size1 [ now ] += size1 [ to ]; if ( size1 [ to ] > size1 [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( ll now , ll fa ) { id [ now ] = ++ cnt ; top [ now ] = fa ; if ( son [ now ]) dfs2 ( son [ now ], fa ); for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == f [ now ] || to == son [ now ]) continue ; dfs2 ( to , to ); } } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t + 1 ] += lazy [ t ]; lazy [ 2 * t ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += ( mid - l + 1 ) * lazy [ t ]; sum [ 2 * t + 1 ] += ( r - mid ) * lazy [ t ]; lazy [ t ] = 0 ; } void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { lazy [ t ] += add ; sum [ t ] += add * ( R - L + 1 ); return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query ( ll t , ll l , ll r , ll L , ll R ) { if ( l <= L && R <= r ) return sum [ t ]; push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; ll ans = 0 ; if ( l <= mid ) ans += query ( 2 * t , l , r , L , mid ); if ( mid < r ) ans += query ( 2 * t + 1 , l , r , mid + 1 , R ); return ans ; } void update_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ]; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); update ( 1 , id [ fx ], id [ x ], 1 , cnt , 1 ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); update ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt , 1 ); } ll query_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ], ans = 0 ; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); ans += query ( 1 , id [ fx ], id [ x ], 1 , cnt ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); ans += query ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt ); return ans ; } int main () { ll n , m , from , to ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } f [ 1 ] = 0 , dep [ 1 ] = 1 ; dfs1 ( 1 , 0 ), dfs2 ( 1 , 1 ); char c [ 10 ]; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , c + 1 , & from , & to ); if ( c [ 1 ] == 'P' ) update_chain ( from , to ); else printf ( \"%lld \\n \" , query_chain ( from , to )); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516d\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Hopping Rabbit \u9898\u76ee \u00b6 \u9898\u89e3 \u00b6 \u626b\u63cf\u7ebf+\u7ebf\u6bb5\u6811\uff0c\u5c06\u9677\u9631\u533a\u57df\u6620\u5c04\u5230(0,0)-(d-1,d-1)\u7684\u77e9\u5f62\u5f53\u4e2d\uff0c\u53ea\u8981\u67e5\u627e\u77e9\u5f62\u4e2d\u4e3a\u88ab\u9677\u9631\u8986\u76d6\u7684\u90e8\u5206\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <stdio.h> #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll n , d ; ll num [ 200500 ] = { 0 }; ll lazy [ 800500 ] = { 0 }; ll min1 [ 800500 ] = { 0 }; void push_up ( ll t ) { min1 [ t ] = min ( min1 [ 2 * t ], min1 [ 2 * t + 1 ]); } void push_down ( ll t ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t ] += lazy [ t ]; lazy [ 2 * t + 1 ] += lazy [ t ]; min1 [ 2 * t ] += lazy [ t ]; min1 [ 2 * t + 1 ] += lazy [ t ]; lazy [ t ] = 0 ; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( l <= L && r >= R ) { min1 [ t ] += add ; lazy [ t ] += add ; return ; } push_down ( t ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query_pos ( ll t , ll l , ll r ) { if ( l == r ) return l ; ll mid = ( l + r ) / 2 ; push_down ( t ); if ( min1 [ 2 * t ] == 0 ) return query_pos ( 2 * t , l , mid ); else return query_pos ( 2 * t + 1 , mid + 1 , r ); } struct node { ll l , r ; }; vector < node > v1 [ 100500 ], v2 [ 100500 ]; void clc ( ll & x ) { x = ( x % d + d ) % d ; } void option1 ( ll x1 , ll y1 , ll x2 , ll y2 ) { if ( x1 >= x2 || y1 >= y2 ) return ; v1 [ x1 ]. push_back ({ y1 + 1 , y2 }); v2 [ x2 ]. push_back ({ y1 + 1 , y2 }); } void option ( ll x1 , ll y1 , ll x2 , ll y2 ) { if ( y2 - y1 >= d ) { option1 ( x1 , 0 , x2 , d ); return ; } clc ( y1 ), clc ( y2 ); if ( y1 > y2 ) { option1 ( x1 , 0 , x2 , y2 ); option1 ( x1 , y1 , x2 , d ); return ; } else { option1 ( x1 , y1 , x2 , y2 ); return ; } } int main () { scanf ( \"%lld%lld\" , & n , & d ); for ( ll i = 1 ; i <= n ; i ++ ) { ll x1 , y1 , x2 , y2 ; scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); if ( x2 - x1 >= d ) { option ( 0 , y1 , d , y2 ); continue ; } clc ( x1 ), clc ( x2 ); if ( x1 > x2 ) { option ( 0 , y1 , x2 , y2 ); option ( x1 , y1 , d , y2 ); } else { option ( x1 , y1 , x2 , y2 ); } } for ( ll i = 0 ; i < d ; i ++ ) { for ( node x : v1 [ i ]) update ( 1 , x . l , x . r , 1 , d , 1 ); for ( node x : v2 [ i ]) update ( 1 , x . l , x . r , 1 , d , -1 ); if ( min1 [ 1 ] != 0 ) continue ; printf ( \"YES \\n %lld %lld \\n \" , i , query_pos ( 1 , 1 , d ) - 1 ); return 0 ; } printf ( \"NO \\n \" ); }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516d\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516d\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/#_2","text":"Hopping Rabbit","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/#_3","text":"","title":"\u9898\u76ee"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/#_4","text":"\u626b\u63cf\u7ebf+\u7ebf\u6bb5\u6811\uff0c\u5c06\u9677\u9631\u533a\u57df\u6620\u5c04\u5230(0,0)-(d-1,d-1)\u7684\u77e9\u5f62\u5f53\u4e2d\uff0c\u53ea\u8981\u67e5\u627e\u77e9\u5f62\u4e2d\u4e3a\u88ab\u9677\u9631\u8986\u76d6\u7684\u90e8\u5206\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/#_5","text":"#include <stdio.h> #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll n , d ; ll num [ 200500 ] = { 0 }; ll lazy [ 800500 ] = { 0 }; ll min1 [ 800500 ] = { 0 }; void push_up ( ll t ) { min1 [ t ] = min ( min1 [ 2 * t ], min1 [ 2 * t + 1 ]); } void push_down ( ll t ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t ] += lazy [ t ]; lazy [ 2 * t + 1 ] += lazy [ t ]; min1 [ 2 * t ] += lazy [ t ]; min1 [ 2 * t + 1 ] += lazy [ t ]; lazy [ t ] = 0 ; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( l <= L && r >= R ) { min1 [ t ] += add ; lazy [ t ] += add ; return ; } push_down ( t ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query_pos ( ll t , ll l , ll r ) { if ( l == r ) return l ; ll mid = ( l + r ) / 2 ; push_down ( t ); if ( min1 [ 2 * t ] == 0 ) return query_pos ( 2 * t , l , mid ); else return query_pos ( 2 * t + 1 , mid + 1 , r ); } struct node { ll l , r ; }; vector < node > v1 [ 100500 ], v2 [ 100500 ]; void clc ( ll & x ) { x = ( x % d + d ) % d ; } void option1 ( ll x1 , ll y1 , ll x2 , ll y2 ) { if ( x1 >= x2 || y1 >= y2 ) return ; v1 [ x1 ]. push_back ({ y1 + 1 , y2 }); v2 [ x2 ]. push_back ({ y1 + 1 , y2 }); } void option ( ll x1 , ll y1 , ll x2 , ll y2 ) { if ( y2 - y1 >= d ) { option1 ( x1 , 0 , x2 , d ); return ; } clc ( y1 ), clc ( y2 ); if ( y1 > y2 ) { option1 ( x1 , 0 , x2 , y2 ); option1 ( x1 , y1 , x2 , d ); return ; } else { option1 ( x1 , y1 , x2 , y2 ); return ; } } int main () { scanf ( \"%lld%lld\" , & n , & d ); for ( ll i = 1 ; i <= n ; i ++ ) { ll x1 , y1 , x2 , y2 ; scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); if ( x2 - x1 >= d ) { option ( 0 , y1 , d , y2 ); continue ; } clc ( x1 ), clc ( x2 ); if ( x1 > x2 ) { option ( 0 , y1 , x2 , y2 ); option ( x1 , y1 , d , y2 ); } else { option ( x1 , y1 , x2 , y2 ); } } for ( ll i = 0 ; i < d ; i ++ ) { for ( node x : v1 [ i ]) update ( 1 , x . l , x . r , 1 , d , 1 ); for ( node x : v2 [ i ]) update ( 1 , x . l , x . r , 1 , d , -1 ); if ( min1 [ 1 ] != 0 ) continue ; printf ( \"YES \\n %lld %lld \\n \" , i , query_pos ( 1 , 1 , d ) - 1 ); return 0 ; } printf ( \"NO \\n \" ); }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e00\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Add or Multiply 1 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u6837\u4f8b\u8f93\u5165 \u00b6 3 2 1 5 5 100 100 \u6837\u4f8b\u8f93\u51fa \u00b6 4 329462 294770659 \u9898\u89e3 \u00b6 \u5c06+\u548c*\u5206\u522b\u8f6c\u6362\u4e3a\u767d\u7403\u548c\u9ed1\u7403\uff0c\u5c06\u9898\u76ee\u8f6c\u6362\u4e3an\u4e2a\u4e0d\u540c\u7684\u5c0f\u7403\u653e\u5230m\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u4e14\u4e0d\u4e3a\u7a7a\uff0c\u5373\u4e3a\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\uff0c\u8be6\u89c1\uff1a https://github.tim-wcx.ltd/#/icpc/?id=\u7ec4\u5408\u6570\u5b66 \uff0c\u7136\u540e\u679a\u4e3e\u767d\u8272\u5c0f\u7403\u76d2\u5b50\u6570\u76een\uff0c\u5219\u5bf9\u4e8e\u9ed1\u8272\u5c0f\u7403\uff0c\u6709\u4e09\u79cd\u5206\u6cd5\uff1an\u4e2a\u76d2\u5b50\uff0cn-1\u4e2a\u76d2\u5b50\u548cn+1\u4e2a\u76d2\u5b50\uff0c\u5bf9\u4e8e\u4e09\u79cd\u60c5\u51b5\u5206\u522b\u8ba1\u7b97\u6c42\u548c\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; ll dp [ 4000 ][ 4000 ] = { 0 }; ll jc [ 4000 ] = { 0 }; int main () { jc [ 0 ] = 1 ; for ( ll i = 1 ; i < 4000 ; i ++ ) { jc [ i ] = jc [ i - 1 ] * i % mod ; } dp [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i < 4000 ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { dp [ i ][ j ] = ( dp [ i -1 ][ j -1 ] + ( ll ) j * dp [ i -1 ][ j ] % mod ) % mod ; } } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); ll ans = 0 ; for ( ll i = 0 ; i <= max ( n , m ); i ++ ) { ll tmp1 = dp [ n ][ i ] * jc [ i ]; tmp1 %= mod ; ans += tmp1 * dp [ m ][ i - 1 ] % mod * jc [ i - 1 ] % mod ; ans %= mod ; ans += tmp1 * dp [ m ][ i ] % mod * jc [ i ] % mod * 2 % mod ; ans %= mod ; ans += tmp1 * dp [ m ][ i + 1 ] % mod * jc [ i + 1 ] % mod ; ans %= mod ; } printf ( \"%lld \\n \" , ans ); } } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u4ed3\u9889\u9020\u6570 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u9aa4\u98ce\u8d77\uff0c\u4ed3\u9889\u98d8\u98d8\u4e4e\u4e0d\u81ea\u89c9\u4e8e\u5b64\u5c9b\u7109\u3002\u5c9b\u65e0\u4eba\u8ff9\uff0c\u552f\u6709\u6709\u7406\u6570\u4e8c\u65cf\u5c14\u3002\u4e00\u65cf\u66f0\u7532\u5206\u4e4b\u4e59\uff0c \u4e00\u65cf\u66f0\u4e59\u5206\u4e4b\u7532\uff0c\u7532\u3001\u4e59\u7686\u6b63\u6574\u6570\u3002\u6570\u4e4b\uff0c\u5219\u65cf\u65cf\u4e0d\u7aed\u5176\u6570\u3002 \u9e66\u9e49\u8c13\u4ed3\u9889\uff1a\u201c\u65e5\u62e9\u4e8c\u6570\uff0c\u5408\u5176\u4e3a\u5e73\u5747\u6216\u8c03\u548c\u5e73\u5747\u3002\u9020\u5f97\u4e00\uff0c\u543e\u9001\u6c5d\u5f52\uff01\u201d \u4ed3\u9889\u80fd\u5f52\u4e8e\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d\u4ebf\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d\u4e07\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d\u65e5\u5426\uff1f \u4ed3\u9889\u88ab\u4e00\u9635\u98ce\u522e\u5230\u4e86\u4e00\u4e2a\u8352\u65e0\u4eba\u70df\u7684\u5c0f\u5c9b\u4e0a\uff0c\u90a3\u91cc\u6709\u4e24\u65cf\u6709\u7406\u6570\uff0cab\u548cba\uff0c\uff08a,b \u4e3a\u6b63\u6574\u6570\uff09\uff0c\u6bcf\u65cf\u6570\u6709\u65e0\u7a77\u591a\u4e2a\u3002 \u9e66\u9e49\u544a\u8bc9\u4ed3\u9889\uff1a\u201c\u6bcf\u5929\uff0c\u4f60\u53ef\u4ee5\u9009\u4e24\u4e2a\u5df2\u6709\u7684\u6570 x,y\uff0c\u5c06\u5b83\u4eec\u5408\u6210\u4e3a \\frac{x+y}{2} \\frac{x+y}{2} \u6216 \\frac{2x*y}{x+y} \\frac{2x*y}{x+y} \u3002\u5982\u679c\u4f60\u80fd\u5408\u6210 1\uff0c\u6211\u5c31\u9001\u4f60\u56de\u5bb6\uff01\u201d \u4ed3\u9889\u80fd\u5728 999999999999 \u5929\u5185\u56de\u5bb6\u5417\uff1f T \u7ec4\u6570\u636e\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570 T(1\u2264T\u2264400)\uff0c\u8868\u793a\u6570\u636e\u7ec4\u6570\u3002 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff1a \u8f93\u5165\u4e00\u884c\u4e24\u4e2a\u6574\u6570 a,b(1\u2264a,b\u2264 10^9 10^9 )\uff0c\u8868\u793a\u521d\u59cb\u7684\u6709\u7406\u6570\u4e3a \\frac{a}{b} \\frac{a}{b} \u548c \\frac{b}{a} \\frac{b}{a} \u3002 \u8f93\u51fa \u00b6 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff1a \u8f93\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 \u201cYes\u201d \u6216\u8005 \u201cNo\u201d\uff08\u5747\u4e0d\u542b\u5f15\u53f7\uff09\uff0c\u5206\u522b\u8868\u793a\u4ed3\u9889\u80fd\u6216\u8005\u4e0d\u80fd\u5728 999999999999 \u5929\u5185\u5408\u6210\u6570\u5b57 1\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 3 1 1 1 2 5 3 \u6837\u4f8b\u8f93\u51fa \u00b6 Yes No Yes \u9898\u89e3 \u00b6 \u89c4\u5f8b\u9898\uff0c\u7531\u4e8ea/b\u548cb/a\u662f\u4efb\u610f\u591a\u4e2a\u7684\uff0c\u53ef\u4ee5\u591a\u5199\u51e0\u9879\u627e\u627e\u89c4\u5f8b\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f #define inf1 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; map < ll , ll > mp ; int main () { ll sum = 1 ; for ( ll i = 1 ; i <= 40 ; i ++ ) { mp [ sum ] = 1 ; sum = sum * 2 ; } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll a , b ; scanf ( \"%lld%lld\" , & a , & b ); ll tmp = __gcd ( a , b ); a /= tmp , b /= tmp ; if ( a == b ) { puts ( \"Yes\" ); continue ; } if ( mp [ a + b ] && a % 2 == 1 && b % 2 == 1 ) puts ( \"Yes\" ); else puts ( \"No\" ); } } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 123 Triangle \u9898\u76ee\u63cf\u8ff0 \u00b6 Given is a sequence of N digits a1a2\u2026aN, where each element is 1, 2, or 3. Let xi,j defined as follows: \u00b7x_{1,j}:=a_j (1\u2264j\u2264N) \u00b7x_{1,j}:=a_j (1\u2264j\u2264N) \u00b7x_{i,j}:=|x_{i\u22121,j}\u2212x_{i\u22121,j+1}| (2\u2264i\u2264N and 1\u2264j\u2264N+1\u2212i) \u00b7x_{i,j}:=|x_{i\u22121,j}\u2212x_{i\u22121,j+1}| (2\u2264i\u2264N and 1\u2264j\u2264N+1\u2212i) Find xN,1. Constraints \u00b7 2\u2264N\u226410^6 2\u2264N\u226410^6 \u00b7ai=1,2,3 (1\u2264i\u2264N) \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N a1a2\u2026aN \u8f93\u51fa \u00b6 Print x_{N,1} x_{N,1} . \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 4 1231 \u3010\u6837\u4f8b2\u3011 10 2311312312 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 0 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca x1,1,x1,2,x1,3,x1,4 are respectively 1,2,3,1. x2,1,x2,2,x2,3 are respectively |1\u22122|=1,|2\u22123|=1,|3\u22121|=2. x3,1,x3,2 are respectively |1\u22121|=0,|1\u22122|=1. Finally, x4,1=|0\u22121|=1, so the answer is 1. \u9898\u89e3 \u00b6 \u51cf\u6cd5\u76f8\u5f53\u4e8e\u6a212\u52a0\uff0c\u5c06\u9898\u76ee\u8f6c\u53d8\u4e3a \u5373\u7edf\u8ba1\u6bcf\u4e00\u4f4d\u6570\u52a0\u4e86\u591a\u5c11\u6b21\uff0c\u901a\u8fc7\u89c2\u5bdf\uff0c\u6bcf\u4e00\u4f4d\u6570\u52a0 C_{i-1}^{n-1} C_{i-1}^{n-1} \uff0c\u5373\u5224\u65ad\u5947\u5076\u5373\u53ef\u3002 \u53c2\u8003\u535a\u5ba2\uff1a https://blog.csdn.net/weixin_45750972/article/details/105271373 https://blog.csdn.net/weixin_45750972/article/details/105272194 https://www.cnblogs.com/Willems/p/12552885.html \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; int b [ 10 ] = { 0 }; char a [ 1005000 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , a + 1 ); int f1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] -- ; ///\u7531\u4e8en>=2\uff0c123\u7b49\u4ef7\u4e8e012\u8ba1\u7b97 if ( a [ i ] == '1' ) f1 = 1 ; b [ a [ i ] - '0' ] += ( int )((( n - 1 ) & ( i - 1 )) == ( i - 1 )); } if ( b [ 1 ] & 1 ) puts ( \"1\" ); else if ( f1 == 0 && ( b [ 2 ] & 1 )) puts ( \"2\" ); else puts ( \"0\" ); }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e00\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e00\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_2","text":"Add or Multiply 1","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_3","text":"","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_4","text":"3 2 1 5 5 100 100","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_5","text":"4 329462 294770659","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_6","text":"\u5c06+\u548c*\u5206\u522b\u8f6c\u6362\u4e3a\u767d\u7403\u548c\u9ed1\u7403\uff0c\u5c06\u9898\u76ee\u8f6c\u6362\u4e3an\u4e2a\u4e0d\u540c\u7684\u5c0f\u7403\u653e\u5230m\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u4e14\u4e0d\u4e3a\u7a7a\uff0c\u5373\u4e3a\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\uff0c\u8be6\u89c1\uff1a https://github.tim-wcx.ltd/#/icpc/?id=\u7ec4\u5408\u6570\u5b66 \uff0c\u7136\u540e\u679a\u4e3e\u767d\u8272\u5c0f\u7403\u76d2\u5b50\u6570\u76een\uff0c\u5219\u5bf9\u4e8e\u9ed1\u8272\u5c0f\u7403\uff0c\u6709\u4e09\u79cd\u5206\u6cd5\uff1an\u4e2a\u76d2\u5b50\uff0cn-1\u4e2a\u76d2\u5b50\u548cn+1\u4e2a\u76d2\u5b50\uff0c\u5bf9\u4e8e\u4e09\u79cd\u60c5\u51b5\u5206\u522b\u8ba1\u7b97\u6c42\u548c\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_7","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; ll dp [ 4000 ][ 4000 ] = { 0 }; ll jc [ 4000 ] = { 0 }; int main () { jc [ 0 ] = 1 ; for ( ll i = 1 ; i < 4000 ; i ++ ) { jc [ i ] = jc [ i - 1 ] * i % mod ; } dp [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i < 4000 ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { dp [ i ][ j ] = ( dp [ i -1 ][ j -1 ] + ( ll ) j * dp [ i -1 ][ j ] % mod ) % mod ; } } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); ll ans = 0 ; for ( ll i = 0 ; i <= max ( n , m ); i ++ ) { ll tmp1 = dp [ n ][ i ] * jc [ i ]; tmp1 %= mod ; ans += tmp1 * dp [ m ][ i - 1 ] % mod * jc [ i - 1 ] % mod ; ans %= mod ; ans += tmp1 * dp [ m ][ i ] % mod * jc [ i ] % mod * 2 % mod ; ans %= mod ; ans += tmp1 * dp [ m ][ i + 1 ] % mod * jc [ i + 1 ] % mod ; ans %= mod ; } printf ( \"%lld \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_8","text":"\u4ed3\u9889\u9020\u6570","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_9","text":"\u9aa4\u98ce\u8d77\uff0c\u4ed3\u9889\u98d8\u98d8\u4e4e\u4e0d\u81ea\u89c9\u4e8e\u5b64\u5c9b\u7109\u3002\u5c9b\u65e0\u4eba\u8ff9\uff0c\u552f\u6709\u6709\u7406\u6570\u4e8c\u65cf\u5c14\u3002\u4e00\u65cf\u66f0\u7532\u5206\u4e4b\u4e59\uff0c \u4e00\u65cf\u66f0\u4e59\u5206\u4e4b\u7532\uff0c\u7532\u3001\u4e59\u7686\u6b63\u6574\u6570\u3002\u6570\u4e4b\uff0c\u5219\u65cf\u65cf\u4e0d\u7aed\u5176\u6570\u3002 \u9e66\u9e49\u8c13\u4ed3\u9889\uff1a\u201c\u65e5\u62e9\u4e8c\u6570\uff0c\u5408\u5176\u4e3a\u5e73\u5747\u6216\u8c03\u548c\u5e73\u5747\u3002\u9020\u5f97\u4e00\uff0c\u543e\u9001\u6c5d\u5f52\uff01\u201d \u4ed3\u9889\u80fd\u5f52\u4e8e\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d\u4ebf\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d\u4e07\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d\u65e5\u5426\uff1f \u4ed3\u9889\u88ab\u4e00\u9635\u98ce\u522e\u5230\u4e86\u4e00\u4e2a\u8352\u65e0\u4eba\u70df\u7684\u5c0f\u5c9b\u4e0a\uff0c\u90a3\u91cc\u6709\u4e24\u65cf\u6709\u7406\u6570\uff0cab\u548cba\uff0c\uff08a,b \u4e3a\u6b63\u6574\u6570\uff09\uff0c\u6bcf\u65cf\u6570\u6709\u65e0\u7a77\u591a\u4e2a\u3002 \u9e66\u9e49\u544a\u8bc9\u4ed3\u9889\uff1a\u201c\u6bcf\u5929\uff0c\u4f60\u53ef\u4ee5\u9009\u4e24\u4e2a\u5df2\u6709\u7684\u6570 x,y\uff0c\u5c06\u5b83\u4eec\u5408\u6210\u4e3a \\frac{x+y}{2} \\frac{x+y}{2} \u6216 \\frac{2x*y}{x+y} \\frac{2x*y}{x+y} \u3002\u5982\u679c\u4f60\u80fd\u5408\u6210 1\uff0c\u6211\u5c31\u9001\u4f60\u56de\u5bb6\uff01\u201d \u4ed3\u9889\u80fd\u5728 999999999999 \u5929\u5185\u56de\u5bb6\u5417\uff1f T \u7ec4\u6570\u636e\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_10","text":"\u7b2c\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570 T(1\u2264T\u2264400)\uff0c\u8868\u793a\u6570\u636e\u7ec4\u6570\u3002 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff1a \u8f93\u5165\u4e00\u884c\u4e24\u4e2a\u6574\u6570 a,b(1\u2264a,b\u2264 10^9 10^9 )\uff0c\u8868\u793a\u521d\u59cb\u7684\u6709\u7406\u6570\u4e3a \\frac{a}{b} \\frac{a}{b} \u548c \\frac{b}{a} \\frac{b}{a} \u3002","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_11","text":"\u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff1a \u8f93\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 \u201cYes\u201d \u6216\u8005 \u201cNo\u201d\uff08\u5747\u4e0d\u542b\u5f15\u53f7\uff09\uff0c\u5206\u522b\u8868\u793a\u4ed3\u9889\u80fd\u6216\u8005\u4e0d\u80fd\u5728 999999999999 \u5929\u5185\u5408\u6210\u6570\u5b57 1\u3002","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_12","text":"3 1 1 1 2 5 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_13","text":"Yes No Yes","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_14","text":"\u89c4\u5f8b\u9898\uff0c\u7531\u4e8ea/b\u548cb/a\u662f\u4efb\u610f\u591a\u4e2a\u7684\uff0c\u53ef\u4ee5\u591a\u5199\u51e0\u9879\u627e\u627e\u89c4\u5f8b\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_15","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f #define inf1 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; map < ll , ll > mp ; int main () { ll sum = 1 ; for ( ll i = 1 ; i <= 40 ; i ++ ) { mp [ sum ] = 1 ; sum = sum * 2 ; } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll a , b ; scanf ( \"%lld%lld\" , & a , & b ); ll tmp = __gcd ( a , b ); a /= tmp , b /= tmp ; if ( a == b ) { puts ( \"Yes\" ); continue ; } if ( mp [ a + b ] && a % 2 == 1 && b % 2 == 1 ) puts ( \"Yes\" ); else puts ( \"No\" ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_16","text":"123 Triangle","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_17","text":"Given is a sequence of N digits a1a2\u2026aN, where each element is 1, 2, or 3. Let xi,j defined as follows: \u00b7x_{1,j}:=a_j (1\u2264j\u2264N) \u00b7x_{1,j}:=a_j (1\u2264j\u2264N) \u00b7x_{i,j}:=|x_{i\u22121,j}\u2212x_{i\u22121,j+1}| (2\u2264i\u2264N and 1\u2264j\u2264N+1\u2212i) \u00b7x_{i,j}:=|x_{i\u22121,j}\u2212x_{i\u22121,j+1}| (2\u2264i\u2264N and 1\u2264j\u2264N+1\u2212i) Find xN,1. Constraints \u00b7 2\u2264N\u226410^6 2\u2264N\u226410^6 \u00b7ai=1,2,3 (1\u2264i\u2264N)","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_18","text":"Input is given from Standard Input in the following format: N a1a2\u2026aN","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_19","text":"Print x_{N,1} x_{N,1} .","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_20","text":"\u3010\u6837\u4f8b1\u3011 4 1231 \u3010\u6837\u4f8b2\u3011 10 2311312312","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_21","text":"\u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 0","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_22","text":"\u6837\u4f8b1\u89e3\u91ca x1,1,x1,2,x1,3,x1,4 are respectively 1,2,3,1. x2,1,x2,2,x2,3 are respectively |1\u22122|=1,|2\u22123|=1,|3\u22121|=2. x3,1,x3,2 are respectively |1\u22121|=0,|1\u22122|=1. Finally, x4,1=|0\u22121|=1, so the answer is 1.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_23","text":"\u51cf\u6cd5\u76f8\u5f53\u4e8e\u6a212\u52a0\uff0c\u5c06\u9898\u76ee\u8f6c\u53d8\u4e3a \u5373\u7edf\u8ba1\u6bcf\u4e00\u4f4d\u6570\u52a0\u4e86\u591a\u5c11\u6b21\uff0c\u901a\u8fc7\u89c2\u5bdf\uff0c\u6bcf\u4e00\u4f4d\u6570\u52a0 C_{i-1}^{n-1} C_{i-1}^{n-1} \uff0c\u5373\u5224\u65ad\u5947\u5076\u5373\u53ef\u3002 \u53c2\u8003\u535a\u5ba2\uff1a https://blog.csdn.net/weixin_45750972/article/details/105271373 https://blog.csdn.net/weixin_45750972/article/details/105272194 https://www.cnblogs.com/Willems/p/12552885.html","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_24","text":"#include <bits/stdc++.h> using namespace std ; int b [ 10 ] = { 0 }; char a [ 1005000 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , a + 1 ); int f1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] -- ; ///\u7531\u4e8en>=2\uff0c123\u7b49\u4ef7\u4e8e012\u8ba1\u7b97 if ( a [ i ] == '1' ) f1 = 1 ; b [ a [ i ] - '0' ] += ( int )((( n - 1 ) & ( i - 1 )) == ( i - 1 )); } if ( b [ 1 ] & 1 ) puts ( \"1\" ); else if ( f1 == 0 && ( b [ 2 ] & 1 )) puts ( \"2\" ); else puts ( \"0\" ); }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e09\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Nuske vs Phantom Thnook \u9898\u76ee\u63cf\u8ff0 \u00b6 Nuske has a grid with N rows and M columns of squares. The rows are numbered 1 through N from top to bottom, and the columns are numbered 1 through M from left to right. Each square in the grid is painted in either blue or white. If S_{i,j} S_{i,j} is 1, the square at the i-th row and j-th column is blue; if S_{i,j} S_{i,j} is 0, the square is white. For every pair of two blue square a and b, there is at most one path that starts from a, repeatedly proceeds to an adjacent (side by side) blue square and finally reaches b, without traversing the same square more than once. Phantom Thnook, Nuske's eternal rival, gives Q queries to Nuske. The i-th query consists of four integers x_{i,1} x_{i,1} , y_{i,1} y_{i,1} , x_{i,2} x_{i,2} and y_{i,2} y_{i,2} and asks him the following: when the rectangular region of the grid bounded by (and including) the xi,1-th row, xi,2-th row, yi,1-th column and yi,2-th column is cut out, how many connected components consisting of blue squares there are in the region? Process all the queries. Constraints 1\u2264N,M\u22642000 1\u2264Q\u2264200000 Si,j is either 0 or 1. Si,j satisfies the condition explained in the statement. 1\u2264 x_{i,1} x_{i,1} \u2264 x_{i,2} x_{i,2} \u2264N(1\u2264i\u2264Q) 1\u2264 y_{i,1} y_{i,1} \u2264 y_{i,2} y_{i,2} \u2264M(1\u2264i\u2264Q) \u8f93\u5165 \u00b6 The input is given from Standard Input in the following format: N M Q S1,1..S1,M : SN,1..SN,M x1,1 yi,1 xi,2 yi,2 : xQ,1 yQ,1 xQ,2 yQ,2 \u8f93\u51fa \u00b6 For each query, print the number of the connected components consisting of blue squares in the region. \u6837\u4f8b\u8f93\u5165 \u00b6 3 4 4 1101 0110 1101 1 1 3 4 1 1 3 1 2 2 3 4 1 2 2 4 \u6837\u4f8b\u8f93\u51fa \u00b6 3 2 2 2 \u63d0\u793a \u00b6 In the first query, the whole grid is specified. There are three components consisting of blue squares, and thus 3 should be printed. In the second query, the region within the red frame is specified. There are two components consisting of blue squares, and thus 2 should be printed. Note that squares that belong to the same component in the original grid may belong to different components. \u9898\u89e3 \u00b6 \u524d\u7f00\u548c\u4ee5\u53ca\u6811\u7684\u6027\u8d28\uff0c\u68ee\u6797\u7684\u4e2a\u6570\u7b49\u4e8e\u70b9\u7684\u4e2a\u6570\u51cf\u53bb\u8fb9\u7684\u6570\u76ee\uff0c\u7528\u524d\u7f00\u548c\u7ef4\u62a4\u8fb9\u7684\u6570\u76ee\u548c\u70b9\u7684\u6570\u76ee\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; char a [ 2050 ][ 2050 ] = { 0 }; int qzh [ 2050 ][ 2050 ] = { 0 }; int qzl [ 2050 ][ 2050 ] = { 0 }; int sum [ 2050 ][ 2050 ] = { 0 }; int main () { int n , m , q ; scanf ( \"%d%d%d\" , & n , & m , & q ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { sum [ i ][ j ] = - sum [ i - 1 ][ j - 1 ] + sum [ i ][ j - 1 ] + sum [ i - 1 ][ j ] + a [ i ][ j ] - '0' ; if ( a [ i ][ j ] == '1' ) { int tmp1 = 0 , tmp2 = 0 ; if ( a [ i - 1 ][ j ] == '1' ) tmp2 ++ ; if ( a [ i ][ j - 1 ] == '1' ) tmp1 ++ ; qzh [ i ][ j ] = - qzh [ i - 1 ][ j - 1 ] + qzh [ i ][ j - 1 ] + qzh [ i - 1 ][ j ] + tmp1 ; qzl [ i ][ j ] = - qzl [ i - 1 ][ j - 1 ] + qzl [ i ][ j - 1 ] + qzl [ i - 1 ][ j ] + tmp2 ; } else { qzh [ i ][ j ] = - qzh [ i - 1 ][ j - 1 ] + qzh [ i ][ j - 1 ] + qzh [ i - 1 ][ j ]; qzl [ i ][ j ] = - qzl [ i - 1 ][ j - 1 ] + qzl [ i ][ j - 1 ] + qzl [ i - 1 ][ j ]; } } } while ( q -- ) { int x1 , y1 , x2 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & y1 , & x2 , & y2 ); int ans = sum [ x2 ][ y2 ] - sum [ x1 - 1 ][ y2 ] - sum [ x2 ][ y1 - 1 ] + sum [ x1 - 1 ][ y1 - 1 ]; ans = ans - ( qzh [ x2 ][ y2 ] - qzh [ x1 - 1 ][ y2 ] - qzh [ x2 ][ y1 ] + qzh [ x1 - 1 ][ y1 ]); ans = ans - ( qzl [ x2 ][ y2 ] - qzl [ x1 ][ y2 ] - qzl [ x2 ][ y1 - 1 ] + qzl [ x1 ][ y1 - 1 ]); printf ( \"%d \\n \" , ans ); } } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 A or...or B Problem \u9898\u76ee\u63cf\u8ff0 \u00b6 Nukes has an integer that can be represented as the bitwise OR of one or more integers between A and B (inclusive). How many possible candidates of the value of Nukes's integer there are? Constraints 1\u2264A\u2264B< 2^{60} 2^{60} A and B are integers. \u8f93\u5165 \u00b6 The input is given from Standard Input in the following format: A B \u8f93\u51fa \u00b6 Print the number of possible candidates of the value of Nukes's integer. \u6837\u4f8b\u8f93\u5165 \u00b6 7 9 \u6837\u4f8b\u8f93\u51fa \u00b6 4 \u63d0\u793a \u00b6 In this case, A=7 and B=9. There are four integers that can be represented as the bitwise OR of a non-empty subset of {7, 8, 9}: 7, 8, 9 and 15. \u9898\u89e3 \u00b6 \u5047\u8bbeA\uff0cB\u4e24\u4e2a\u6570\u7684\u4e8c\u8fdb\u5236\u5982\u4e0b\uff1a A\uff1axxxxxx..0***** B\uff1axxxxxx..10----- \u5219\uff1a C\uff1axxxxxx..011111 D\uff1axxxxxx..100000 C\u548cD\u4e00\u5b9a\u6ee1\u8db3A<=C<=D<=B \u5219\uff1a E\uff1axxxxxx..1***** F\uff1axxxxxx..111111 G\uff1axxxxxx..100111 \u5176\u4e2d [E,F] [E,F] \u53ef\u4ee5\u7531 [A,C] [A,C] \u548cD\u6216\u8fd0\u7b97\u5f97\u5230\uff0c [D,G] [D,G] \u53ef\u4ee5\u7531 [D,B] [D,B] \u6216\u8fd0\u7b97\u5f97\u5230\uff0c\u6240\u4ee5\u7b54\u6848\u5373\u4e3a [A,G]\\cup[E,F] [A,G]\\cup[E,F] \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll a , b ; cin >> a >> b ; if ( a > b ) swap ( a , b ); ll tmp = b , aa = a ; for ( ll i = 60 ; i >= 0 ; i -- ) { if ((( a ^ b ) >> i ) & 1 ) { for ( ll j = i - 1 ; j >= 0 ; j -- ) tmp |= ( 1l l << j ); ///\u7b49\u6548\u4e8exxxxx..111111 a |= ( 1l l << i ); ///\u7b49\u6548\u4e8exxxxx..1***** for ( i -- ; i >= 0 && ! (( b >> i ) & 1 ); i -- ) ; for (; i >= 0 ; i -- ) b |= ( 1l l << i ); ///\u7b49\u6548\u4e8exxxxx..100111 break ; } } ll ans = 0 ; if ( b >= a ) ans = tmp - aa + 1 ; else ans = tmp - a + 1 + b - aa + 1 ; cout << ans << endl ; } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u62a2\u5360\u57ce\u5821 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u51ac\u51ac\u6b63\u548c\u4ed6\u7684\u670b\u53cb\u4e00\u8d77\u73a9\u62a2\u5360\u57ce\u5821\u7684\u6e38\u620f\uff0c\u8be5\u6e38\u620f\u53ef\u4ee5\u8868\u793a\u4e3a\u5927\u5c0f\u4e3an\u00d7m\u7684\u7f51\u683c\uff0c\u6bcf\u4e2a\u683c\u5b50\u6700\u591a\u53ea\u80fd\u5bb9\u4e0b\u4e00\u5ea7\u57ce\u5821\uff0c\u6bcf\u4e2a\u683c\u5b50\u6709\u4e09\u79cd\u72b6\u6001\uff1a 1\u3001\u7a7a\u57ce\u5821\u7528\u201c.\u201d\u8868\u793a\uff1b 2\u3001\u969c\u788d\u7269\u7528\u201c*\u201d\u8868\u793a\uff0c\u6240\u6709\u73a9\u5bb6\u90fd\u4e0d\u80fd\u901a\u8fc7\u5b83\uff1b 3\u3001\u4e00\u540d\u6e38\u620f\u73a9\u5bb6\u7684\u7f16\u53f7\u5373\u4e3a\u6570\u5b57x\uff0c\u8868\u793a\u8be5\u57ce\u5821\u88abx\u5360\u9886\u3002 \u6e38\u620f\u662f\u6309\u73a9\u5bb6\u7f16\u53f7\u4ece\u5c0f\u5230\u5927\u8f6e\u6d41\u8fdb\u884c\u7684\uff0c\u5728\u6bcf\u4e00\u8f6e\u4e2d\uff0c\u73a9\u5bb6\u8f6e\u6d41\u6269\u5f20\u52bf\u529b\u8303\u56f4\uff1a\u9996\u5148\uff0c\u7b2c\u4e00\u4e2a\u73a9\u5bb6\u6269\u5f20\uff0c\u7136\u540e\u7b2c\u4e8c\u4e2a\u73a9\u5bb6\u6269\u5f20\uff0c\u4f9d\u6b64\u7c7b\u63a8\u3002\u6269\u5f20\u89c4\u5219\u5982\u4e0b\uff1a \u5bf9\u4e8e\u73a9\u5bb6\u73b0\u5728\u62e5\u6709\u7684\u6bcf\u4e2a\u57ce\u5821\uff0c\u53ef\u4ee5\u6269\u5f20\u5230\u9644\u8fd1\u7684\u7a7a\u57ce\u5821\uff08\u672a\u88ab\u4eba\u5360\u9886\u7684\uff09\u3002 \u73a9\u5bb6i\u53ef\u4ee5\u4ece\u4ed6\u5df2\u5360\u9886\u7684\u57ce\u5821\u5411\u4e0a\u3001\u4e0b\u3001\u5de6\u3001\u53f3\u56db\u4e2a\u65b9\u5411\u6269\u5f20\uff0c\u4e14\u6bcf\u540d\u73a9\u5bb6\u90fd\u6709\u4e00\u4e2a\u653b\u51fb\u529bsi\uff0c\u5982\u679c\u80fd\u5728si\u6b65\u5185\uff08\u542bsi\uff09\u5230\u8fbe\u9644\u8fd1\u7684\u7a7a\u57ce\u5821\u5219\u53ef\u4ee5\u62a2\u5360\u8be5\u57ce\u5821\u3002 \u5f53\u6240\u6709\u73a9\u5bb6\u90fd\u4e0d\u80fd\u7ee7\u7eed\u62a2\u5360\u7684\u65f6\u5019\u6e38\u620f\u7ed3\u675f\uff0c\u51ac\u51ac\u60f3\u77e5\u9053\u6e38\u620f\u7ed3\u675f\u65f6\u6bcf\u540d\u73a9\u5bb6\u6240\u5360\u7684\u57ce\u5821\u6570\u662f\u591a\u5c11\uff1f \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u5305\u542b\u4e09\u4e2a\u6574\u6570n\uff0cm\u548cp\uff081\u2264n\uff0cm\u22641000,1\u2264p\u22649\uff09\u8868\u793a\u7f51\u683c\u7684\u884c\u548c\u5217\u4ee5\u53ca\u73a9\u5bb6\u6570\u91cf\u3002 \u7b2c\u4e8c\u884c\u5305\u542bp\u6574\u6570si\uff081\u2264si\u22645000\uff09\u8868\u793a\u6bcf\u540d\u73a9\u5bb6\u7684\u6269\u5f20\u901f\u5ea6\u3002 \u4ee5\u4e0bn\u884c\u63cf\u8ff0\u4e86\u6e38\u620f\u7f51\u683c\uff0c\u6bcf\u884c\u7531m\u4e2a\u7b26\u53f7\u7ec4\u6210\uff0c\u5176\u4e2d'.'\u8868\u793a\u7a7a\u57ce\u5821\uff0c'*'\u8868\u793a\u969c\u788d\u4eec\uff0c\u6570\u5b57x\uff081\u2264x\u2264p\uff09\u8868\u793a\u7531\u73a9\u5bb6x\u62e5\u6709\u7684\u57ce\u5821\u3002 \u4fdd\u8bc1\u6bcf\u540d\u73a9\u5bb6\u5728\u7f51\u683c\u4e0a\u81f3\u5c11\u6709\u4e00\u5ea7\u57ce\u5821\u3002 \u8f93\u51fa \u00b6 \u8f93\u51fap\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6e38\u620f\u7ed3\u675f\u540e\u6bcf\u540d\u73a9\u5bb6\u62a2\u5360\u7684\u57ce\u5821\u6570\u91cf\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 3 3 2 1 1 1.. ... ..2 \u3010\u6837\u4f8b2\u3011 3 4 4 1 1 1 1 .... *... 1234 \u3010\u6837\u4f8b3\u3011 3 4 4 1 1 2 1 .... *... 1234 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 6 3 \u3010\u6837\u4f8b2\u3011 1 4 3 3 \u3010\u6837\u4f8b3\u3011 1 4 5 1 \u63d0\u793a \u00b6 \u5bf9\u4e8e10%\u7684\u6570\u636e\uff0c1\u2264n\uff0cm\u22641000\uff0cp=1\u3002 \u5bf9\u4e8e20%\u7684\u6570\u636e\uff0c1\u2264n\uff0cm\u22641000\uff0cp=2\u3002 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c1\u2264n\uff0cm\u22641000,1\u2264p\u22649\uff0c1\u2264si\u22645000\u3002 \u9898\u89e3 \u00b6 BFS\u76f4\u63a5\u641c\u7d22\u5373\u53ef\uff0c\u6ce8\u610f\u641c\u7d22\u6280\u5de7\uff0c\u6269\u5c55\u6280\u5de7\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char a [ 1050 ][ 1050 ] = { 0 }; int s [ 20 ] = { 0 }; int ans [ 20 ] = { 0 }; int vis [ 1050 ][ 1050 ] = { 0 }; int n , m , p ; int dx [] = { 0 , 1 , -1 , 0 , 0 }; int dy [] = { 0 , 0 , 0 , 1 , -1 }; struct node { int x , y ; }; queue < node > que [ 1005 ]; void bfs ( int k ) { for ( int p = 1 ; p <= s [ k ]; p ++ ) { int tmp = que [ k ]. size (); if ( tmp == 0 ) break ; for ( int i = 0 ; i < tmp ; i ++ ) { int x = que [ k ]. front (). x ; int y = que [ k ]. front (). y ; que [ k ]. pop (); for ( int j = 1 ; j <= 4 ; j ++ ) { int xx = x + dx [ j ]; int yy = y + dy [ j ]; if ( xx <= 0 || xx > n || yy <= 0 || yy > m || vis [ xx ][ yy ] != 0 ) continue ; vis [ xx ][ yy ] = k ; que [ k ]. push ({ xx , yy }); } } } } int main () { scanf ( \"%d%d%d\" , & n , & m , & p ); for ( int i = 1 ; i <= p ; i ++ ) scanf ( \"%d\" , & s [ i ]); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ][ j ] == '.' ) ; else { if ( a [ i ][ j ] == '*' ) { vis [ i ][ j ] = -1 ; } else { vis [ i ][ j ] = a [ i ][ j ] - '0' ; que [ a [ i ][ j ] - '0' ]. push ({ i , j }); } } } } while ( 1 ) { int flag = 1 ; for ( int p1 = 1 ; p1 <= p ; p1 ++ ) { if ( que [ p1 ]. size () > 0 ) { bfs ( p1 ); flag = 0 ; } } if ( flag ) break ; } for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) if ( vis [ i ][ j ] != -1 ) ans [ vis [ i ][ j ]] ++ ; for ( int i = 1 ; i <= p ; i ++ ) printf ( \"%d \" , ans [ i ]); }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e09\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e09\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_2","text":"Nuske vs Phantom Thnook","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_3","text":"Nuske has a grid with N rows and M columns of squares. The rows are numbered 1 through N from top to bottom, and the columns are numbered 1 through M from left to right. Each square in the grid is painted in either blue or white. If S_{i,j} S_{i,j} is 1, the square at the i-th row and j-th column is blue; if S_{i,j} S_{i,j} is 0, the square is white. For every pair of two blue square a and b, there is at most one path that starts from a, repeatedly proceeds to an adjacent (side by side) blue square and finally reaches b, without traversing the same square more than once. Phantom Thnook, Nuske's eternal rival, gives Q queries to Nuske. The i-th query consists of four integers x_{i,1} x_{i,1} , y_{i,1} y_{i,1} , x_{i,2} x_{i,2} and y_{i,2} y_{i,2} and asks him the following: when the rectangular region of the grid bounded by (and including) the xi,1-th row, xi,2-th row, yi,1-th column and yi,2-th column is cut out, how many connected components consisting of blue squares there are in the region? Process all the queries. Constraints 1\u2264N,M\u22642000 1\u2264Q\u2264200000 Si,j is either 0 or 1. Si,j satisfies the condition explained in the statement. 1\u2264 x_{i,1} x_{i,1} \u2264 x_{i,2} x_{i,2} \u2264N(1\u2264i\u2264Q) 1\u2264 y_{i,1} y_{i,1} \u2264 y_{i,2} y_{i,2} \u2264M(1\u2264i\u2264Q)","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_4","text":"The input is given from Standard Input in the following format: N M Q S1,1..S1,M : SN,1..SN,M x1,1 yi,1 xi,2 yi,2 : xQ,1 yQ,1 xQ,2 yQ,2","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_5","text":"For each query, print the number of the connected components consisting of blue squares in the region.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_6","text":"3 4 4 1101 0110 1101 1 1 3 4 1 1 3 1 2 2 3 4 1 2 2 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_7","text":"3 2 2 2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_8","text":"In the first query, the whole grid is specified. There are three components consisting of blue squares, and thus 3 should be printed. In the second query, the region within the red frame is specified. There are two components consisting of blue squares, and thus 2 should be printed. Note that squares that belong to the same component in the original grid may belong to different components.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_9","text":"\u524d\u7f00\u548c\u4ee5\u53ca\u6811\u7684\u6027\u8d28\uff0c\u68ee\u6797\u7684\u4e2a\u6570\u7b49\u4e8e\u70b9\u7684\u4e2a\u6570\u51cf\u53bb\u8fb9\u7684\u6570\u76ee\uff0c\u7528\u524d\u7f00\u548c\u7ef4\u62a4\u8fb9\u7684\u6570\u76ee\u548c\u70b9\u7684\u6570\u76ee\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_10","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; char a [ 2050 ][ 2050 ] = { 0 }; int qzh [ 2050 ][ 2050 ] = { 0 }; int qzl [ 2050 ][ 2050 ] = { 0 }; int sum [ 2050 ][ 2050 ] = { 0 }; int main () { int n , m , q ; scanf ( \"%d%d%d\" , & n , & m , & q ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { sum [ i ][ j ] = - sum [ i - 1 ][ j - 1 ] + sum [ i ][ j - 1 ] + sum [ i - 1 ][ j ] + a [ i ][ j ] - '0' ; if ( a [ i ][ j ] == '1' ) { int tmp1 = 0 , tmp2 = 0 ; if ( a [ i - 1 ][ j ] == '1' ) tmp2 ++ ; if ( a [ i ][ j - 1 ] == '1' ) tmp1 ++ ; qzh [ i ][ j ] = - qzh [ i - 1 ][ j - 1 ] + qzh [ i ][ j - 1 ] + qzh [ i - 1 ][ j ] + tmp1 ; qzl [ i ][ j ] = - qzl [ i - 1 ][ j - 1 ] + qzl [ i ][ j - 1 ] + qzl [ i - 1 ][ j ] + tmp2 ; } else { qzh [ i ][ j ] = - qzh [ i - 1 ][ j - 1 ] + qzh [ i ][ j - 1 ] + qzh [ i - 1 ][ j ]; qzl [ i ][ j ] = - qzl [ i - 1 ][ j - 1 ] + qzl [ i ][ j - 1 ] + qzl [ i - 1 ][ j ]; } } } while ( q -- ) { int x1 , y1 , x2 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & y1 , & x2 , & y2 ); int ans = sum [ x2 ][ y2 ] - sum [ x1 - 1 ][ y2 ] - sum [ x2 ][ y1 - 1 ] + sum [ x1 - 1 ][ y1 - 1 ]; ans = ans - ( qzh [ x2 ][ y2 ] - qzh [ x1 - 1 ][ y2 ] - qzh [ x2 ][ y1 ] + qzh [ x1 - 1 ][ y1 ]); ans = ans - ( qzl [ x2 ][ y2 ] - qzl [ x1 ][ y2 ] - qzl [ x2 ][ y1 - 1 ] + qzl [ x1 ][ y1 - 1 ]); printf ( \"%d \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_11","text":"A or...or B Problem","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_12","text":"Nukes has an integer that can be represented as the bitwise OR of one or more integers between A and B (inclusive). How many possible candidates of the value of Nukes's integer there are? Constraints 1\u2264A\u2264B< 2^{60} 2^{60} A and B are integers.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_13","text":"The input is given from Standard Input in the following format: A B","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_14","text":"Print the number of possible candidates of the value of Nukes's integer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_15","text":"7 9","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_16","text":"4","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_17","text":"In this case, A=7 and B=9. There are four integers that can be represented as the bitwise OR of a non-empty subset of {7, 8, 9}: 7, 8, 9 and 15.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_18","text":"\u5047\u8bbeA\uff0cB\u4e24\u4e2a\u6570\u7684\u4e8c\u8fdb\u5236\u5982\u4e0b\uff1a A\uff1axxxxxx..0***** B\uff1axxxxxx..10----- \u5219\uff1a C\uff1axxxxxx..011111 D\uff1axxxxxx..100000 C\u548cD\u4e00\u5b9a\u6ee1\u8db3A<=C<=D<=B \u5219\uff1a E\uff1axxxxxx..1***** F\uff1axxxxxx..111111 G\uff1axxxxxx..100111 \u5176\u4e2d [E,F] [E,F] \u53ef\u4ee5\u7531 [A,C] [A,C] \u548cD\u6216\u8fd0\u7b97\u5f97\u5230\uff0c [D,G] [D,G] \u53ef\u4ee5\u7531 [D,B] [D,B] \u6216\u8fd0\u7b97\u5f97\u5230\uff0c\u6240\u4ee5\u7b54\u6848\u5373\u4e3a [A,G]\\cup[E,F] [A,G]\\cup[E,F]","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_19","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll a , b ; cin >> a >> b ; if ( a > b ) swap ( a , b ); ll tmp = b , aa = a ; for ( ll i = 60 ; i >= 0 ; i -- ) { if ((( a ^ b ) >> i ) & 1 ) { for ( ll j = i - 1 ; j >= 0 ; j -- ) tmp |= ( 1l l << j ); ///\u7b49\u6548\u4e8exxxxx..111111 a |= ( 1l l << i ); ///\u7b49\u6548\u4e8exxxxx..1***** for ( i -- ; i >= 0 && ! (( b >> i ) & 1 ); i -- ) ; for (; i >= 0 ; i -- ) b |= ( 1l l << i ); ///\u7b49\u6548\u4e8exxxxx..100111 break ; } } ll ans = 0 ; if ( b >= a ) ans = tmp - aa + 1 ; else ans = tmp - a + 1 + b - aa + 1 ; cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_20","text":"\u62a2\u5360\u57ce\u5821","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_21","text":"\u51ac\u51ac\u6b63\u548c\u4ed6\u7684\u670b\u53cb\u4e00\u8d77\u73a9\u62a2\u5360\u57ce\u5821\u7684\u6e38\u620f\uff0c\u8be5\u6e38\u620f\u53ef\u4ee5\u8868\u793a\u4e3a\u5927\u5c0f\u4e3an\u00d7m\u7684\u7f51\u683c\uff0c\u6bcf\u4e2a\u683c\u5b50\u6700\u591a\u53ea\u80fd\u5bb9\u4e0b\u4e00\u5ea7\u57ce\u5821\uff0c\u6bcf\u4e2a\u683c\u5b50\u6709\u4e09\u79cd\u72b6\u6001\uff1a 1\u3001\u7a7a\u57ce\u5821\u7528\u201c.\u201d\u8868\u793a\uff1b 2\u3001\u969c\u788d\u7269\u7528\u201c*\u201d\u8868\u793a\uff0c\u6240\u6709\u73a9\u5bb6\u90fd\u4e0d\u80fd\u901a\u8fc7\u5b83\uff1b 3\u3001\u4e00\u540d\u6e38\u620f\u73a9\u5bb6\u7684\u7f16\u53f7\u5373\u4e3a\u6570\u5b57x\uff0c\u8868\u793a\u8be5\u57ce\u5821\u88abx\u5360\u9886\u3002 \u6e38\u620f\u662f\u6309\u73a9\u5bb6\u7f16\u53f7\u4ece\u5c0f\u5230\u5927\u8f6e\u6d41\u8fdb\u884c\u7684\uff0c\u5728\u6bcf\u4e00\u8f6e\u4e2d\uff0c\u73a9\u5bb6\u8f6e\u6d41\u6269\u5f20\u52bf\u529b\u8303\u56f4\uff1a\u9996\u5148\uff0c\u7b2c\u4e00\u4e2a\u73a9\u5bb6\u6269\u5f20\uff0c\u7136\u540e\u7b2c\u4e8c\u4e2a\u73a9\u5bb6\u6269\u5f20\uff0c\u4f9d\u6b64\u7c7b\u63a8\u3002\u6269\u5f20\u89c4\u5219\u5982\u4e0b\uff1a \u5bf9\u4e8e\u73a9\u5bb6\u73b0\u5728\u62e5\u6709\u7684\u6bcf\u4e2a\u57ce\u5821\uff0c\u53ef\u4ee5\u6269\u5f20\u5230\u9644\u8fd1\u7684\u7a7a\u57ce\u5821\uff08\u672a\u88ab\u4eba\u5360\u9886\u7684\uff09\u3002 \u73a9\u5bb6i\u53ef\u4ee5\u4ece\u4ed6\u5df2\u5360\u9886\u7684\u57ce\u5821\u5411\u4e0a\u3001\u4e0b\u3001\u5de6\u3001\u53f3\u56db\u4e2a\u65b9\u5411\u6269\u5f20\uff0c\u4e14\u6bcf\u540d\u73a9\u5bb6\u90fd\u6709\u4e00\u4e2a\u653b\u51fb\u529bsi\uff0c\u5982\u679c\u80fd\u5728si\u6b65\u5185\uff08\u542bsi\uff09\u5230\u8fbe\u9644\u8fd1\u7684\u7a7a\u57ce\u5821\u5219\u53ef\u4ee5\u62a2\u5360\u8be5\u57ce\u5821\u3002 \u5f53\u6240\u6709\u73a9\u5bb6\u90fd\u4e0d\u80fd\u7ee7\u7eed\u62a2\u5360\u7684\u65f6\u5019\u6e38\u620f\u7ed3\u675f\uff0c\u51ac\u51ac\u60f3\u77e5\u9053\u6e38\u620f\u7ed3\u675f\u65f6\u6bcf\u540d\u73a9\u5bb6\u6240\u5360\u7684\u57ce\u5821\u6570\u662f\u591a\u5c11\uff1f","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_22","text":"\u7b2c\u4e00\u884c\u5305\u542b\u4e09\u4e2a\u6574\u6570n\uff0cm\u548cp\uff081\u2264n\uff0cm\u22641000,1\u2264p\u22649\uff09\u8868\u793a\u7f51\u683c\u7684\u884c\u548c\u5217\u4ee5\u53ca\u73a9\u5bb6\u6570\u91cf\u3002 \u7b2c\u4e8c\u884c\u5305\u542bp\u6574\u6570si\uff081\u2264si\u22645000\uff09\u8868\u793a\u6bcf\u540d\u73a9\u5bb6\u7684\u6269\u5f20\u901f\u5ea6\u3002 \u4ee5\u4e0bn\u884c\u63cf\u8ff0\u4e86\u6e38\u620f\u7f51\u683c\uff0c\u6bcf\u884c\u7531m\u4e2a\u7b26\u53f7\u7ec4\u6210\uff0c\u5176\u4e2d'.'\u8868\u793a\u7a7a\u57ce\u5821\uff0c'*'\u8868\u793a\u969c\u788d\u4eec\uff0c\u6570\u5b57x\uff081\u2264x\u2264p\uff09\u8868\u793a\u7531\u73a9\u5bb6x\u62e5\u6709\u7684\u57ce\u5821\u3002 \u4fdd\u8bc1\u6bcf\u540d\u73a9\u5bb6\u5728\u7f51\u683c\u4e0a\u81f3\u5c11\u6709\u4e00\u5ea7\u57ce\u5821\u3002","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_23","text":"\u8f93\u51fap\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6e38\u620f\u7ed3\u675f\u540e\u6bcf\u540d\u73a9\u5bb6\u62a2\u5360\u7684\u57ce\u5821\u6570\u91cf\u3002","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_24","text":"\u3010\u6837\u4f8b1\u3011 3 3 2 1 1 1.. ... ..2 \u3010\u6837\u4f8b2\u3011 3 4 4 1 1 1 1 .... *... 1234 \u3010\u6837\u4f8b3\u3011 3 4 4 1 1 2 1 .... *... 1234","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_25","text":"\u3010\u6837\u4f8b1\u3011 6 3 \u3010\u6837\u4f8b2\u3011 1 4 3 3 \u3010\u6837\u4f8b3\u3011 1 4 5 1","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_26","text":"\u5bf9\u4e8e10%\u7684\u6570\u636e\uff0c1\u2264n\uff0cm\u22641000\uff0cp=1\u3002 \u5bf9\u4e8e20%\u7684\u6570\u636e\uff0c1\u2264n\uff0cm\u22641000\uff0cp=2\u3002 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c1\u2264n\uff0cm\u22641000,1\u2264p\u22649\uff0c1\u2264si\u22645000\u3002","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_27","text":"BFS\u76f4\u63a5\u641c\u7d22\u5373\u53ef\uff0c\u6ce8\u610f\u641c\u7d22\u6280\u5de7\uff0c\u6269\u5c55\u6280\u5de7\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_28","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char a [ 1050 ][ 1050 ] = { 0 }; int s [ 20 ] = { 0 }; int ans [ 20 ] = { 0 }; int vis [ 1050 ][ 1050 ] = { 0 }; int n , m , p ; int dx [] = { 0 , 1 , -1 , 0 , 0 }; int dy [] = { 0 , 0 , 0 , 1 , -1 }; struct node { int x , y ; }; queue < node > que [ 1005 ]; void bfs ( int k ) { for ( int p = 1 ; p <= s [ k ]; p ++ ) { int tmp = que [ k ]. size (); if ( tmp == 0 ) break ; for ( int i = 0 ; i < tmp ; i ++ ) { int x = que [ k ]. front (). x ; int y = que [ k ]. front (). y ; que [ k ]. pop (); for ( int j = 1 ; j <= 4 ; j ++ ) { int xx = x + dx [ j ]; int yy = y + dy [ j ]; if ( xx <= 0 || xx > n || yy <= 0 || yy > m || vis [ xx ][ yy ] != 0 ) continue ; vis [ xx ][ yy ] = k ; que [ k ]. push ({ xx , yy }); } } } } int main () { scanf ( \"%d%d%d\" , & n , & m , & p ); for ( int i = 1 ; i <= p ; i ++ ) scanf ( \"%d\" , & s [ i ]); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ][ j ] == '.' ) ; else { if ( a [ i ][ j ] == '*' ) { vis [ i ][ j ] = -1 ; } else { vis [ i ][ j ] = a [ i ][ j ] - '0' ; que [ a [ i ][ j ] - '0' ]. push ({ i , j }); } } } } while ( 1 ) { int flag = 1 ; for ( int p1 = 1 ; p1 <= p ; p1 ++ ) { if ( que [ p1 ]. size () > 0 ) { bfs ( p1 ); flag = 0 ; } } if ( flag ) break ; } for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) if ( vis [ i ][ j ] != -1 ) ans [ vis [ i ][ j ]] ++ ; for ( int i = 1 ; i <= p ; i ++ ) printf ( \"%d \" , ans [ i ]); }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e8c\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Flowerpot \u9898\u76ee\u63cf\u8ff0 \u00b6 \u8001\u677f\u9700\u8981\u4f60\u5e2e\u5fd9\u6d47\u82b1\u3002\u7ed9\u51faN\u6ef4\u6c34\u7684\u5750\u6807\uff0cy\u8868\u793a\u6c34\u6ef4\u7684\u9ad8\u5ea6\uff0cx\u8868\u793a\u5b83\u4e0b\u843d\u5230x\u8f74\u7684\u4f4d\u7f6e\u3002 \u6bcf\u6ef4\u6c34\u4ee5\u6bcf\u79d21\u4e2a\u5355\u4f4d\u957f\u5ea6\u7684\u901f\u5ea6\u4e0b\u843d\u3002\u4f60\u9700\u8981\u628a\u82b1\u76c6\u653e\u5728x\u8f74\u4e0a\u7684\u67d0\u4e2a\u4f4d\u7f6e\uff0c\u4f7f\u5f97\u4ece\u88ab\u82b1\u76c6\u63a5\u7740\u7684\u7b2c1\u6ef4\u6c34\u5f00\u59cb\uff0c\u5230\u88ab\u82b1\u76c6\u63a5\u7740\u7684\u6700\u540e1\u6ef4\u6c34\u7ed3\u675f\uff0c\u4e4b\u95f4\u7684\u65f6\u95f4\u5dee\u81f3\u5c11\u4e3aD\u3002 \u6211\u4eec\u8ba4\u4e3a\uff0c\u53ea\u8981\u6c34\u6ef4\u843d\u5230x\u8f74\u4e0a\uff0c\u4e0e\u82b1\u76c6\u7684\u8fb9\u6cbf\u5bf9\u9f50\uff0c\u5c31\u8ba4\u4e3a\u88ab\u63a5\u4f4f\u3002\u7ed9\u51faN\u6ef4\u6c34\u7684\u5750\u6807\u548cD\u7684\u5927\u5c0f\uff0c\u8bf7\u7b97\u51fa\u6700\u5c0f\u7684\u82b1\u76c6\u7684\u5bbd\u5ea6W\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c2\u4e2a\u6574\u6570 N \u548c D\u3002 \u7b2c2.. N+1\u884c\u6bcf\u884c2\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6c34\u6ef4\u7684\u5750\u6807(x,y)\u3002 1 \u2264 N \u2264 100000\uff0c1 \u2264 D \u2264 1000000\uff0c0\u2264x,y\u2264106\u3002 \u8f93\u51fa \u00b6 \u4ec5\u4e00\u884c1\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6700\u5c0f\u7684\u82b1\u76c6\u7684\u5bbd\u5ea6\u3002\u5982\u679c\u65e0\u6cd5\u6784\u9020\u51fa\u8db3\u591f\u5bbd\u7684\u82b1\u76c6\uff0c\u4f7f\u5f97\u5728D\u5355\u4f4d\u7684\u65f6\u95f4\u63a5\u4f4f\u6ee1\u8db3\u8981\u6c42\u7684\u6c34\u6ef4\uff0c\u5219\u8f93\u51fa-1\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 4 5 6 3 2 4 4 10 12 15 \u6837\u4f8b\u8f93\u51fa \u00b6 2 \u63d0\u793a \u00b6 \u67094\u6ef4\u6c34\uff0c (6,3), (2,4), (4,10), (12,15).\u6c34\u6ef4\u5fc5\u987b\u7528\u81f3\u5c115\u79d2\u65f6\u95f4\u843d\u5165\u82b1\u76c6\u3002\u82b1\u76c6\u7684\u5bbd\u5ea6\u4e3a2\u662f\u5fc5\u987b\u4e14\u8db3\u591f\u7684\u3002\u628a\u82b1\u76c6\u653e\u5728x=4..6\u7684\u4f4d\u7f6e\uff0c\u5b83\u53ef\u4ee5\u63a5\u52301\u548c3\u6c34\u6ef4, \u4e4b\u95f4\u7684\u65f6\u95f4\u5dee\u4e3a10-3 = 7\u6ee1\u8db3\u6761\u4ef6\u3002 \u9898\u89e3 \u00b6 \u5355\u8c03\u6808\uff0c\u7ef4\u62a4\u5355\u8c03\u4e0a\u5347\u7684y\uff0c\u7136\u540e\u6c42x\u4e4b\u5dee\u7684\u6700\u5c0f\u503c\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; struct node { int x , y ; bool operator < ( const node & a ) const { if ( a . x != x ) return x < a . x ; else return y < a . y ; } }; node a [ 100500 ] = { 0 }, s [ 100500 ] = { 0 }; int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d%d\" , & a [ i ]. x , & a [ i ]. y ); sort ( a + 1 , a + n + 1 ); int head = 1 , tail = 1 , ans = inf ; s [ 1 ] = a [ 1 ]; for ( int i = 2 ; i <= n ; i ++ ) { while ( tail >= head && s [ tail ]. y > a [ i ]. y ) { if ( s [ tail ]. y - a [ i ]. y >= m ) ans = min ( ans , a [ i ]. x - s [ tail ]. x ); tail -- ; } s [ ++ tail ] = a [ i ]; while ( tail >= head && s [ tail ]. y - s [ head ]. y >= m ) ans = min ( ans , s [ tail ]. x - s [ head ]. x ), head ++ ; } printf ( \"%d \\n \" , ans == inf ? -1 : ans ); } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Haybale Restacking \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has just ordered a large number of bales of hay. He would like to organize these into N piles (1 <= N <= 100,000) arranged in a circle, where pile i contains B_i bales of hay. Unfortunately, the truck driver delivering the hay was not listening carefully when Farmer John provided this information, and only remembered to leave the hay in N piles arranged in a circle. After delivery, Farmer John notes that pile i contains A_i bales of hay. Of course, the A_i's and the B_i's have the same sum. Farmer John would like to move the bales of hay from their current configuration (described by the A_i's) into his desired target configuration (described by the B_i's). It takes him x units of work to move one hay bale from one pile to a pile that is x steps away around the circle. Please help him compute the minimum amount of work he will need to spend. \u8f93\u5165 \u00b6 * Line 1: The single integer N. * Lines 2..1+N: Line i+1 contains the two integers A_i and B_i (1 <= A_i, B_i <= 1000). \u8f93\u51fa \u00b6 * Line 1:the minimum amount of work he will need to spend. \u6837\u4f8b\u8f93\u5165 \u00b6 4 7 1 3 4 9 2 1 13 \u6837\u4f8b\u8f93\u51fa \u00b6 13 \u63d0\u793a \u00b6 \u8bbexi\u4e3a\u7b2ci\u5806\u5e72\u8349\u4e0e\u7b2ci-1\u5806\u5e72\u8349\u7684\u4ea4\u6362\u6570 \u4ee4B[i]\u7b49\u4e8eB[i]-A[i],\u5219\u6211\u4eec\u7684\u76ee\u6807\u662f\u8ba9B[i]\u5168\u90e8\u53d8\u4e3a0 B[1]-x1+x2=0 ==> x2=x1-B[1] B[2]-x2+x3=0 ==> x3=x2-B[2]=x1-B[1]-B[2] ......xn-1=x1-B[1]-B[2]-...-B[n-1] \u800c\u6211\u4eec\u8981\u4f7f x1+x2+x3+...+xn-1 \u6700\u5c0f, \u5373|x1|+|x1-B[1]|+...+|x1-B[1]-B[2]-...-B[n-1]| \u6700\u5c0f \u6240\u4ee5x1\u8981\u7b49\u4e8eB[1],B[1]+B[2],...,B[1]+B[2]+...+B[n-1]\u7684\u4e2d\u4f4d\u6570 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; ll b [ 100500 ] = { 0 }; ll a [ 100500 ] = { 0 }; ll sum [ 100500 ] = { 0 }; int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld\" , & a [ i ], & b [ i ]); b [ i ] -= a [ i ]; sum [ i ] = sum [ i -1 ] + b [ i ]; } sort ( sum + 1 , sum + n + 1 ); ll tmp = sum [( n + 1 ) / 2 ], ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) ans += abs ( sum [ i ] - tmp ); cout << ans << endl ; } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 123 Triangle \u9898\u76ee\u63cf\u8ff0 \u00b6 You are given four positive integers x0, x1, a, b. And you know x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} for all i\u22652. Given two positive integers n, and MOD, please calculate xn modulo MOD. Does the problem look simple? Surprise! The value of n may have many many digits! \u8f93\u5165 \u00b6 The input contains two lines. The first line contains four integers x0, x1, a, b,a,b (1\u2264x0,x1,a,b\u2264109). The second line contains two integers n, MOD ( , n has no leading zero). \u8f93\u51fa \u00b6 Print one integer representing the answer. \u6837\u4f8b\u8f93\u5165 \u00b6 1 1 1 1 10 1000000001 \u6837\u4f8b\u8f93\u51fa \u00b6 89 \u63d0\u793a \u00b6 The resulting sequence x is Fibonacci sequence. The 11-th item is 89. \u9898\u89e3 \u00b6 \u9996\u5148\u662f\u5341\u8fdb\u5236\u5feb\u901f\u5e42\uff0c\u4f8b\u5982\uff1a 3^{1234}=((((ans*3^1)^{10}*3^2)^{10}*3^3)^{10}*3^4)^{10} 3^{1234}=((((ans*3^1)^{10}*3^2)^{10}*3^3)^{10}*3^4)^{10} \u7136\u540e\u662f\u77e9\u9635\u5feb\u901f\u5e42\uff0c x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} \u53ef\u4ee5\u8f6c\u6362\u4e3a\uff1a $\\left( \\matrix{ a & b \\ 1& 0 } \\right) ^{n-1} * \\left(\\matrix {x1 \\ x0 } \\right) $ \u6c42\u51fa\u77e9\u9635\u53d8\u4e3a\u7b54\u6848\u3002 \u53c2\u8003\u4e0e\uff1a https://blog.csdn.net/qq_41650771/article/details/98108098 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll x0 , x1 , a , b , mod ; struct node { ll data [ 3 ][ 3 ]; void clear1 () { data [ 1 ][ 2 ] = data [ 2 ][ 1 ] = 0 ; data [ 1 ][ 1 ] = data [ 2 ][ 2 ] = 0 ; } void clear () { data [ 1 ][ 2 ] = data [ 2 ][ 1 ] = 0 ; data [ 1 ][ 1 ] = data [ 2 ][ 2 ] = 1 ; } node operator * ( const node & a ) const { node tmp ; tmp . clear1 (); for ( ll i = 1 ; i <= 2 ; i ++ ) { for ( ll j = 1 ; j <= 2 ; j ++ ) { for ( ll k = 1 ; k <= 2 ; k ++ ) { tmp . data [ i ][ j ] += data [ i ][ k ] * a . data [ k ][ j ]; tmp . data [ i ][ j ] %= mod ; } } } return tmp ; } void print () { printf ( \"%lld %lld \\n %lld %lld \\n ** \\n \" , data [ 1 ][ 1 ], data [ 1 ][ 2 ], data [ 2 ][ 1 ], data [ 2 ][ 2 ]); } }; char t [ 1005000 ] = { 0 }; node ksm ( node a , int b ) { node ans1 , ans2 = a ; ans1 . clear (); while ( b != 0 ) { if ( b % 2 ) ans1 = ans1 * ans2 ; ans2 = ans2 * ans2 ; b /= 2 ; } return ans1 ; } int main () { scanf ( \"%lld%lld%lld%lld\" , & x0 , & x1 , & a , & b ); scanf ( \"%s\" , t + 1 ); scanf ( \"%lld\" , & mod ); node tmp1 , tmp2 ; tmp2 . data [ 1 ][ 1 ] = a ; tmp2 . data [ 1 ][ 2 ] = 1 ; tmp2 . data [ 2 ][ 1 ] = b ; tmp2 . data [ 2 ][ 2 ] = 0 ; tmp1 . data [ 1 ][ 1 ] = x1 ; tmp1 . data [ 1 ][ 2 ] = x0 ; tmp1 . data [ 2 ][ 1 ] = 0 ; tmp1 . data [ 2 ][ 2 ] = 0 ; node tmp4 ; tmp4 . clear (); for ( int i = 1 ; t [ i ]; i ++ ) { tmp4 = ksm ( tmp4 , 10 ); node tmp3 = ksm ( tmp2 , t [ i ] - '0' ); tmp4 = tmp3 * tmp4 ; } tmp1 = tmp1 * tmp4 ; cout << tmp1 . data [ 1 ][ 2 ] << endl ; } \u9898\u76ee4 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 XOR Game \u9898\u76ee\u63cf\u8ff0 \u00b6 There are 2N integers written on a blackboard. The i-th integer is Ai. Alice and Bob will play a game consisting of N rounds. In each round, they do the following: First, Alice chooses an integer on the blackboard and erases it. Let x be the integer erased here. Second, Bob chooses an integer on the blackboard and erases it. Let y be the integer erased here. Finally, write the value x\u2295y on a notebook, where \u2295 denotes the bitwise XOR. In the end, all the integers on the blackboard will be erased, and the notebook will have N integers written on it. The greatest integer written on the notebook will be the score of the game. Alice wants to maximize this score, while Bob wants to minimize it. Find the score of the game when both players play optimally under their objectives. Constraints 1\u2264N\u2264 2\u00d710^5 2\u00d710^5 0\u2264Ai< 2^{30} 2^{30} All values in input are integers. \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N A1 A2 \u22ef A2N \u8f93\u51fa \u00b6 Print the answer. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 2 0 1 3 5 \u3010\u6837\u4f8b2\u3011 2 0 0 0 0 \u3010\u6837\u4f8b3\u3011 10 974654030 99760550 750234695 255777344 907989127 917878091 818948631 690392797 579845317 549202360 511962375 203530861 491981716 64663831 561104719 541423175 301832976 252317904 471905694 350223945 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 4 \u3010\u6837\u4f8b2\u3011 0 \u3010\u6837\u4f8b3\u3011 268507123 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca\uff1a Below is one possible progress of the game (it may contain suboptimal choices). Round 1: Alice chooses A1=0. Bob chooses A3=3. They write 0\u22953=3 on the notebook. Round 2: Alice chooses A4=5. Bob chooses A2=1. They write 5\u22951=4 on the notebook. The score of the game is max(3,4)=4. \u9898\u89e3 \u00b6 \u5b57\u5178\u6811\uff0c\u537301trai\uff0c\u7531\u4e8e\u4e00\u4e2a\u8981\u6700\u5927\u5316\u5f02\u6216\u503c\uff0c\u4e00\u4e2a\u8981\u6700\u5c0f\u5316\u5f02\u6216\u503c\uff0c\u5219\u7b54\u6848\u4e3a\u5f02\u6216\u540e\u6700\u5927\u503c\u7684\u6700\u5c0f\u503c\uff0c\u5373\u627e\u4e24\u4e2a\u6570\u4f7f\u5f97\u5176\u5f02\u6216\u503c\u6700\u5c0f\u5316\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; int tree [ 10000005 ][ 2 ] = { 0 }; int size1 [ 10000005 ] = { 0 }; int cnt = 1 ; void insert1 ( int k ) { int p = 1 ; size1 [ p ] ++ ; for ( int i = 29 ; i >= 0 ; i -- ) { int tmp = ( k & ( 1 << i )) ? 1 : 0 ; if ( tree [ p ][ tmp ] == 0 ) tree [ p ][ tmp ] =++ cnt ; p = tree [ p ][ tmp ]; size1 [ p ] ++ ; } } int solve ( int a , int b , int dp ) { if ( dp < 0 ) return 0 ; if ( size1 [ a ] == 0 || size1 [ b ] == 0 ) return inf ; ///\u5de6\u53f3\u65e0\u6cd5\u518d\u8fdb\u884c\u5339\u914d if ( a == b ) { if ( size1 [ tree [ a ][ 0 ]] % 2 == 1 ) { return solve ( tree [ a ][ 0 ], tree [ a ][ 1 ], dp -1 ) + ( 1 << dp ); } else { int tmp1 = solve ( tree [ a ][ 0 ], tree [ a ][ 0 ], dp -1 ); int tmp2 = solve ( tree [ a ][ 1 ], tree [ a ][ 1 ], dp -1 ); if ( tmp1 >= inf ) return tmp2 ; else if ( tmp2 >= inf ) return tmp1 ; else return max ( tmp1 , tmp2 ); } } else { int ans = inf ; if (( tree [ a ][ 0 ] && tree [ b ][ 0 ]) || ( tree [ a ][ 1 ] && tree [ b ][ 1 ])) { ans = min ( ans , solve ( tree [ a ][ 0 ], tree [ b ][ 0 ], dp -1 )); ans = min ( ans , solve ( tree [ a ][ 1 ], tree [ b ][ 1 ], dp -1 )); } else { ans = min ( ans , solve ( tree [ a ][ 1 ], tree [ b ][ 0 ], dp -1 ) + ( 1 << dp )); ans = min ( ans , solve ( tree [ a ][ 0 ], tree [ b ][ 1 ], dp -1 ) + ( 1 << dp )); } return ans ; } } int main () { int n , m ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= 2 * n ; i ++ ) { scanf ( \"%d\" , & m ); insert1 ( m ); } cout << solve ( 1 , 1 , 29 ) << endl ; } \u9898\u76ee5 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Mountain Climbing \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has discovered that his cows produce higher quality milk when they are subject to strenuous exercise. He therefore decides to send his N cows (1 <= N <= 25,000) to climb up and then back down a nearby mountain! Cow i takes U(i) time to climb up the mountain and then D(i) time to climb down the mountain. Being domesticated cows, each cow needs the help of a farmer for each leg of the climb, but due to the poor economy, there are only two farmers available, Farmer John and his cousin Farmer Don. FJ plans to guide cows for the upward climb, and FD will then guide the cows for the downward climb. Since every cow needs a guide, and there is only one farmer for each part of the voyage, at most one cow may be climbing upward at any point in time (assisted by FJ), and at most one cow may be climbing down at any point in time (assisted by FD). A group of cows may temporarily accumulate at the top of the mountain if they climb up and then need to wait for FD's assistance before climbing down. Cows may climb down in a different order than they climbed up. Please determine the least possible amount of time for all N cows to make the entire journey. \u8f93\u5165 \u00b6 * Line 1: The number of cows, N. * Lines 2..1+N: Line i+1 contains two space-separated integers: U(i) and D(i). (1 <= U(i), D(i) <= 50,000). \u8f93\u51fa \u00b6 * Line 1: A single integer representing the least amount of time for all the cows to cross the mountain. \u6837\u4f8b\u8f93\u5165 \u00b6 3 6 4 8 1 2 3 \u6837\u4f8b\u8f93\u51fa \u00b6 17 \u9898\u89e3 \u00b6 \u4e8c\u7ea7\u8f66\u95f4\u8c03\u5ea6\u95ee\u9898\uff0c\u8d2a\u5fc3\uff0c\u8ba9\u4e0b\u5c71\u6bd4\u4e0a\u5c71\u5feb\u7684\u5148\u4e0a\uff0c\u7136\u540e\u5728\u8d2a\u5fc3\u7684\u7f29\u77ed\u4e0a\u5c71\u65f6\u95f4\u548c\u6269\u5927\u4e0b\u5c71\u65f6\u95f4\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll u , d , sum , sum1 ; }; bool cmp ( node a , node b ) { if ( a . d > a . u && b . d <= b . u ) ///\u4e0b\u7684\u6162\u7684\u4f18\u5148 return 1 ; else if ( a . d <= a . u && b . d > b . u ) return 0 ; else if ( a . d > a . u ) return a . u < b . u ; ///\u4e0a\u7684\u5feb\u7684\u4f18\u5148 else return a . d > b . d ; ///\u4e0b\u7684\u6162\u7684\u4f18\u5148 } node a [ 25500 ] = { 0 }; int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld%lld\" , & a [ i ]. u , & a [ i ]. d ); sort ( a + 1 , a + n + 1 , cmp ); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) a [ i ]. sum = a [ i -1 ]. sum + a [ i ]. u ; for ( ll i = 1 ; i <= n ; i ++ ) { a [ i ]. sum1 = max ( a [ i ]. sum , a [ i -1 ]. sum1 ) + a [ i ]. d ; ans = max ( ans , a [ i ]. sum1 ); } cout << ans << endl ; } \u9898\u76ee6 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Tower \u9898\u76ee\u63cf\u8ff0 \u00b6 There are N blocks, numbered 1,2,\u2026,N. For each i (1\u2264i\u2264N), Block i has a weight of wi, a solidness of si and a value of vi. Taro has decided to build a tower by choosing some of the N blocks and stacking them vertically in some order. Here, the tower must satisfy the following condition: For each Block i contained in the tower, the sum of the weights of the blocks stacked above it is not greater than si. Find the maximum possible sum of the values of the blocks contained in the tower. Constraints All values in input are integers. 1\u2264N\u2264 10^3 10^3 1\u2264wi,si\u2264 10^4 10^4 1\u2264vi\u2264 10^9 10^9 \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N w1 s1 v1 w2 s2 v2 : wN sN vN \u8f93\u51fa \u00b6 Print the maximum possible sum of the values of the blocks contained in the tower. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b 1 \u3011 3 2 2 20 2 1 30 3 1 40 \u3010\u6837\u4f8b 2 \u3011 4 1 2 10 3 1 10 2 4 10 1 6 10 \u3010\u6837\u4f8b 3 \u3011 5 1 10000 1000000000 1 10000 1000000000 1 10000 1000000000 1 10000 1000000000 1 10000 1000000000 \u3010\u6837\u4f8b 4 \u3011 8 9 5 7 6 2 7 5 7 3 7 8 8 1 9 6 3 3 3 4 1 7 4 5 5 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 50 \u3010\u6837\u4f8b2\u3011 40 \u3010\u6837\u4f8b3\u3011 5000000000 \u3010\u6837\u4f8b4\u3011 22 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca\uff1aIf Blocks 2,1 are stacked in this order from top to bottom, this tower will satisfy the condition, with the total value of 30+20=50. \u6837\u4f8b2\u89e3\u91ca\uff1aBlocks 1,2,3,4 should be stacked in this order from top to bottom. \u6837\u4f8b3\u89e3\u91ca\uff1aThe answer may not fit into a 32-bit integer type. \u6837\u4f8b4\u89e3\u91ca\uff1aWe should, for example, stack Blocks 5,6,8,4 in this order from top to bottom. \u9898\u89e3 \u00b6 \u9996\u5148\u8d2a\u5fc3\u6392\u5e8f\uff0c\u5bf9\u4e8ea\u548cb\u4e24\u4e2a\u7269\u54c1\uff0c\u5982\u679ca\u653e\u5728b\u4e0a\u9762\u5219\u6743\u503c\u4e3as[b]-w[a]\uff0c\u5982\u679cb\u653e\u5728a\u4e0a\u9762\uff0c\u5219\u6743\u503c\u4e3as[a]-w[b]\uff0c\u5219a\u548cb\u7684\u987a\u5e8f\u7531s[b]-w[a]\u548cs[a]-w[b]\u6240\u51b3\u5b9a\uff0c\u79fb\u9879\u53ef\u5f97\u5373\u4e3a\u6bd4\u8f83s[a]+w[a]\u548cs[b]+w[b]\uff0c\u6240\u4ee5\u6839\u636es[a]+w[a]\u7684\u5927\u5c0f\u8d2a\u5fc3\u6392\u5e8f\uff0c\u540e\u6839\u636e\u91cd\u91cf\u9650\u5236\u52a8\u6001\u89c4\u5212\uff0c\u5373\u5047\u8bbedp[i]\u4e3a\u91cd\u91cf\u4e3ai\u65f6\u7684\u6700\u5927\u6743\u503c\uff0c\u5219\u8f6c\u79fb\u65b9\u7a0b\u4e3a\uff1a dp[j+w[i]]=max(dp[j+w[i]],dp[j]+v[i])(0<=j<=s[i]) dp[j+w[i]]=max(dp[j+w[i]],dp[j]+v[i])(0<=j<=s[i]) \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll w , s , v ; }; node a [ 1005 ] = { 0 }; ll dp [ 30050 ] = { 0 }; int main () { ll n ; scanf ( \"%d\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%d%d%d\" , & a [ i ]. w , & a [ i ]. s , & a [ i ]. v ); sort ( a + 1 , a + n + 1 , []( node a , node b ) { return a . s + a . w < b . s + b . w ; }); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = a [ i ]. s ; j >= 0 ; j -- ) dp [ j + a [ i ]. w ] = max ( dp [ j + a [ i ]. w ], dp [ j ] + a [ i ]. v ); } for ( ll j = 0 ; j < 30050 ; j ++ ) ans = max ( ans , dp [ j ]); cout << ans << endl ; }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e8c\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e8c\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_2","text":"Flowerpot","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_3","text":"\u8001\u677f\u9700\u8981\u4f60\u5e2e\u5fd9\u6d47\u82b1\u3002\u7ed9\u51faN\u6ef4\u6c34\u7684\u5750\u6807\uff0cy\u8868\u793a\u6c34\u6ef4\u7684\u9ad8\u5ea6\uff0cx\u8868\u793a\u5b83\u4e0b\u843d\u5230x\u8f74\u7684\u4f4d\u7f6e\u3002 \u6bcf\u6ef4\u6c34\u4ee5\u6bcf\u79d21\u4e2a\u5355\u4f4d\u957f\u5ea6\u7684\u901f\u5ea6\u4e0b\u843d\u3002\u4f60\u9700\u8981\u628a\u82b1\u76c6\u653e\u5728x\u8f74\u4e0a\u7684\u67d0\u4e2a\u4f4d\u7f6e\uff0c\u4f7f\u5f97\u4ece\u88ab\u82b1\u76c6\u63a5\u7740\u7684\u7b2c1\u6ef4\u6c34\u5f00\u59cb\uff0c\u5230\u88ab\u82b1\u76c6\u63a5\u7740\u7684\u6700\u540e1\u6ef4\u6c34\u7ed3\u675f\uff0c\u4e4b\u95f4\u7684\u65f6\u95f4\u5dee\u81f3\u5c11\u4e3aD\u3002 \u6211\u4eec\u8ba4\u4e3a\uff0c\u53ea\u8981\u6c34\u6ef4\u843d\u5230x\u8f74\u4e0a\uff0c\u4e0e\u82b1\u76c6\u7684\u8fb9\u6cbf\u5bf9\u9f50\uff0c\u5c31\u8ba4\u4e3a\u88ab\u63a5\u4f4f\u3002\u7ed9\u51faN\u6ef4\u6c34\u7684\u5750\u6807\u548cD\u7684\u5927\u5c0f\uff0c\u8bf7\u7b97\u51fa\u6700\u5c0f\u7684\u82b1\u76c6\u7684\u5bbd\u5ea6W\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_4","text":"\u7b2c\u4e00\u884c2\u4e2a\u6574\u6570 N \u548c D\u3002 \u7b2c2.. N+1\u884c\u6bcf\u884c2\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6c34\u6ef4\u7684\u5750\u6807(x,y)\u3002 1 \u2264 N \u2264 100000\uff0c1 \u2264 D \u2264 1000000\uff0c0\u2264x,y\u2264106\u3002","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_5","text":"\u4ec5\u4e00\u884c1\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6700\u5c0f\u7684\u82b1\u76c6\u7684\u5bbd\u5ea6\u3002\u5982\u679c\u65e0\u6cd5\u6784\u9020\u51fa\u8db3\u591f\u5bbd\u7684\u82b1\u76c6\uff0c\u4f7f\u5f97\u5728D\u5355\u4f4d\u7684\u65f6\u95f4\u63a5\u4f4f\u6ee1\u8db3\u8981\u6c42\u7684\u6c34\u6ef4\uff0c\u5219\u8f93\u51fa-1\u3002","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_6","text":"4 5 6 3 2 4 4 10 12 15","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_7","text":"2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_8","text":"\u67094\u6ef4\u6c34\uff0c (6,3), (2,4), (4,10), (12,15).\u6c34\u6ef4\u5fc5\u987b\u7528\u81f3\u5c115\u79d2\u65f6\u95f4\u843d\u5165\u82b1\u76c6\u3002\u82b1\u76c6\u7684\u5bbd\u5ea6\u4e3a2\u662f\u5fc5\u987b\u4e14\u8db3\u591f\u7684\u3002\u628a\u82b1\u76c6\u653e\u5728x=4..6\u7684\u4f4d\u7f6e\uff0c\u5b83\u53ef\u4ee5\u63a5\u52301\u548c3\u6c34\u6ef4, \u4e4b\u95f4\u7684\u65f6\u95f4\u5dee\u4e3a10-3 = 7\u6ee1\u8db3\u6761\u4ef6\u3002","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_9","text":"\u5355\u8c03\u6808\uff0c\u7ef4\u62a4\u5355\u8c03\u4e0a\u5347\u7684y\uff0c\u7136\u540e\u6c42x\u4e4b\u5dee\u7684\u6700\u5c0f\u503c\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_10","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; struct node { int x , y ; bool operator < ( const node & a ) const { if ( a . x != x ) return x < a . x ; else return y < a . y ; } }; node a [ 100500 ] = { 0 }, s [ 100500 ] = { 0 }; int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d%d\" , & a [ i ]. x , & a [ i ]. y ); sort ( a + 1 , a + n + 1 ); int head = 1 , tail = 1 , ans = inf ; s [ 1 ] = a [ 1 ]; for ( int i = 2 ; i <= n ; i ++ ) { while ( tail >= head && s [ tail ]. y > a [ i ]. y ) { if ( s [ tail ]. y - a [ i ]. y >= m ) ans = min ( ans , a [ i ]. x - s [ tail ]. x ); tail -- ; } s [ ++ tail ] = a [ i ]; while ( tail >= head && s [ tail ]. y - s [ head ]. y >= m ) ans = min ( ans , s [ tail ]. x - s [ head ]. x ), head ++ ; } printf ( \"%d \\n \" , ans == inf ? -1 : ans ); }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_11","text":"Haybale Restacking","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_12","text":"Farmer John has just ordered a large number of bales of hay. He would like to organize these into N piles (1 <= N <= 100,000) arranged in a circle, where pile i contains B_i bales of hay. Unfortunately, the truck driver delivering the hay was not listening carefully when Farmer John provided this information, and only remembered to leave the hay in N piles arranged in a circle. After delivery, Farmer John notes that pile i contains A_i bales of hay. Of course, the A_i's and the B_i's have the same sum. Farmer John would like to move the bales of hay from their current configuration (described by the A_i's) into his desired target configuration (described by the B_i's). It takes him x units of work to move one hay bale from one pile to a pile that is x steps away around the circle. Please help him compute the minimum amount of work he will need to spend.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_13","text":"* Line 1: The single integer N. * Lines 2..1+N: Line i+1 contains the two integers A_i and B_i (1 <= A_i, B_i <= 1000).","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_14","text":"* Line 1:the minimum amount of work he will need to spend.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_15","text":"4 7 1 3 4 9 2 1 13","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_16","text":"13","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_17","text":"\u8bbexi\u4e3a\u7b2ci\u5806\u5e72\u8349\u4e0e\u7b2ci-1\u5806\u5e72\u8349\u7684\u4ea4\u6362\u6570 \u4ee4B[i]\u7b49\u4e8eB[i]-A[i],\u5219\u6211\u4eec\u7684\u76ee\u6807\u662f\u8ba9B[i]\u5168\u90e8\u53d8\u4e3a0 B[1]-x1+x2=0 ==> x2=x1-B[1] B[2]-x2+x3=0 ==> x3=x2-B[2]=x1-B[1]-B[2] ......xn-1=x1-B[1]-B[2]-...-B[n-1] \u800c\u6211\u4eec\u8981\u4f7f x1+x2+x3+...+xn-1 \u6700\u5c0f, \u5373|x1|+|x1-B[1]|+...+|x1-B[1]-B[2]-...-B[n-1]| \u6700\u5c0f \u6240\u4ee5x1\u8981\u7b49\u4e8eB[1],B[1]+B[2],...,B[1]+B[2]+...+B[n-1]\u7684\u4e2d\u4f4d\u6570","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_18","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; ll b [ 100500 ] = { 0 }; ll a [ 100500 ] = { 0 }; ll sum [ 100500 ] = { 0 }; int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld\" , & a [ i ], & b [ i ]); b [ i ] -= a [ i ]; sum [ i ] = sum [ i -1 ] + b [ i ]; } sort ( sum + 1 , sum + n + 1 ); ll tmp = sum [( n + 1 ) / 2 ], ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) ans += abs ( sum [ i ] - tmp ); cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_19","text":"123 Triangle","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_20","text":"You are given four positive integers x0, x1, a, b. And you know x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} for all i\u22652. Given two positive integers n, and MOD, please calculate xn modulo MOD. Does the problem look simple? Surprise! The value of n may have many many digits!","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_21","text":"The input contains two lines. The first line contains four integers x0, x1, a, b,a,b (1\u2264x0,x1,a,b\u2264109). The second line contains two integers n, MOD ( , n has no leading zero).","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_22","text":"Print one integer representing the answer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_23","text":"1 1 1 1 10 1000000001","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_24","text":"89","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_25","text":"The resulting sequence x is Fibonacci sequence. The 11-th item is 89.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_26","text":"\u9996\u5148\u662f\u5341\u8fdb\u5236\u5feb\u901f\u5e42\uff0c\u4f8b\u5982\uff1a 3^{1234}=((((ans*3^1)^{10}*3^2)^{10}*3^3)^{10}*3^4)^{10} 3^{1234}=((((ans*3^1)^{10}*3^2)^{10}*3^3)^{10}*3^4)^{10} \u7136\u540e\u662f\u77e9\u9635\u5feb\u901f\u5e42\uff0c x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} \u53ef\u4ee5\u8f6c\u6362\u4e3a\uff1a $\\left( \\matrix{ a & b \\ 1& 0 } \\right) ^{n-1} * \\left(\\matrix {x1 \\ x0 } \\right) $ \u6c42\u51fa\u77e9\u9635\u53d8\u4e3a\u7b54\u6848\u3002 \u53c2\u8003\u4e0e\uff1a https://blog.csdn.net/qq_41650771/article/details/98108098","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_27","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll x0 , x1 , a , b , mod ; struct node { ll data [ 3 ][ 3 ]; void clear1 () { data [ 1 ][ 2 ] = data [ 2 ][ 1 ] = 0 ; data [ 1 ][ 1 ] = data [ 2 ][ 2 ] = 0 ; } void clear () { data [ 1 ][ 2 ] = data [ 2 ][ 1 ] = 0 ; data [ 1 ][ 1 ] = data [ 2 ][ 2 ] = 1 ; } node operator * ( const node & a ) const { node tmp ; tmp . clear1 (); for ( ll i = 1 ; i <= 2 ; i ++ ) { for ( ll j = 1 ; j <= 2 ; j ++ ) { for ( ll k = 1 ; k <= 2 ; k ++ ) { tmp . data [ i ][ j ] += data [ i ][ k ] * a . data [ k ][ j ]; tmp . data [ i ][ j ] %= mod ; } } } return tmp ; } void print () { printf ( \"%lld %lld \\n %lld %lld \\n ** \\n \" , data [ 1 ][ 1 ], data [ 1 ][ 2 ], data [ 2 ][ 1 ], data [ 2 ][ 2 ]); } }; char t [ 1005000 ] = { 0 }; node ksm ( node a , int b ) { node ans1 , ans2 = a ; ans1 . clear (); while ( b != 0 ) { if ( b % 2 ) ans1 = ans1 * ans2 ; ans2 = ans2 * ans2 ; b /= 2 ; } return ans1 ; } int main () { scanf ( \"%lld%lld%lld%lld\" , & x0 , & x1 , & a , & b ); scanf ( \"%s\" , t + 1 ); scanf ( \"%lld\" , & mod ); node tmp1 , tmp2 ; tmp2 . data [ 1 ][ 1 ] = a ; tmp2 . data [ 1 ][ 2 ] = 1 ; tmp2 . data [ 2 ][ 1 ] = b ; tmp2 . data [ 2 ][ 2 ] = 0 ; tmp1 . data [ 1 ][ 1 ] = x1 ; tmp1 . data [ 1 ][ 2 ] = x0 ; tmp1 . data [ 2 ][ 1 ] = 0 ; tmp1 . data [ 2 ][ 2 ] = 0 ; node tmp4 ; tmp4 . clear (); for ( int i = 1 ; t [ i ]; i ++ ) { tmp4 = ksm ( tmp4 , 10 ); node tmp3 = ksm ( tmp2 , t [ i ] - '0' ); tmp4 = tmp3 * tmp4 ; } tmp1 = tmp1 * tmp4 ; cout << tmp1 . data [ 1 ][ 2 ] << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#4","text":"","title":"\u9898\u76ee4"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_28","text":"XOR Game","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_29","text":"There are 2N integers written on a blackboard. The i-th integer is Ai. Alice and Bob will play a game consisting of N rounds. In each round, they do the following: First, Alice chooses an integer on the blackboard and erases it. Let x be the integer erased here. Second, Bob chooses an integer on the blackboard and erases it. Let y be the integer erased here. Finally, write the value x\u2295y on a notebook, where \u2295 denotes the bitwise XOR. In the end, all the integers on the blackboard will be erased, and the notebook will have N integers written on it. The greatest integer written on the notebook will be the score of the game. Alice wants to maximize this score, while Bob wants to minimize it. Find the score of the game when both players play optimally under their objectives. Constraints 1\u2264N\u2264 2\u00d710^5 2\u00d710^5 0\u2264Ai< 2^{30} 2^{30} All values in input are integers.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_30","text":"Input is given from Standard Input in the following format: N A1 A2 \u22ef A2N","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_31","text":"Print the answer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_32","text":"\u3010\u6837\u4f8b1\u3011 2 0 1 3 5 \u3010\u6837\u4f8b2\u3011 2 0 0 0 0 \u3010\u6837\u4f8b3\u3011 10 974654030 99760550 750234695 255777344 907989127 917878091 818948631 690392797 579845317 549202360 511962375 203530861 491981716 64663831 561104719 541423175 301832976 252317904 471905694 350223945","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_33","text":"\u3010\u6837\u4f8b1\u3011 4 \u3010\u6837\u4f8b2\u3011 0 \u3010\u6837\u4f8b3\u3011 268507123","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_34","text":"\u6837\u4f8b1\u89e3\u91ca\uff1a Below is one possible progress of the game (it may contain suboptimal choices). Round 1: Alice chooses A1=0. Bob chooses A3=3. They write 0\u22953=3 on the notebook. Round 2: Alice chooses A4=5. Bob chooses A2=1. They write 5\u22951=4 on the notebook. The score of the game is max(3,4)=4.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_35","text":"\u5b57\u5178\u6811\uff0c\u537301trai\uff0c\u7531\u4e8e\u4e00\u4e2a\u8981\u6700\u5927\u5316\u5f02\u6216\u503c\uff0c\u4e00\u4e2a\u8981\u6700\u5c0f\u5316\u5f02\u6216\u503c\uff0c\u5219\u7b54\u6848\u4e3a\u5f02\u6216\u540e\u6700\u5927\u503c\u7684\u6700\u5c0f\u503c\uff0c\u5373\u627e\u4e24\u4e2a\u6570\u4f7f\u5f97\u5176\u5f02\u6216\u503c\u6700\u5c0f\u5316\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_36","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; int tree [ 10000005 ][ 2 ] = { 0 }; int size1 [ 10000005 ] = { 0 }; int cnt = 1 ; void insert1 ( int k ) { int p = 1 ; size1 [ p ] ++ ; for ( int i = 29 ; i >= 0 ; i -- ) { int tmp = ( k & ( 1 << i )) ? 1 : 0 ; if ( tree [ p ][ tmp ] == 0 ) tree [ p ][ tmp ] =++ cnt ; p = tree [ p ][ tmp ]; size1 [ p ] ++ ; } } int solve ( int a , int b , int dp ) { if ( dp < 0 ) return 0 ; if ( size1 [ a ] == 0 || size1 [ b ] == 0 ) return inf ; ///\u5de6\u53f3\u65e0\u6cd5\u518d\u8fdb\u884c\u5339\u914d if ( a == b ) { if ( size1 [ tree [ a ][ 0 ]] % 2 == 1 ) { return solve ( tree [ a ][ 0 ], tree [ a ][ 1 ], dp -1 ) + ( 1 << dp ); } else { int tmp1 = solve ( tree [ a ][ 0 ], tree [ a ][ 0 ], dp -1 ); int tmp2 = solve ( tree [ a ][ 1 ], tree [ a ][ 1 ], dp -1 ); if ( tmp1 >= inf ) return tmp2 ; else if ( tmp2 >= inf ) return tmp1 ; else return max ( tmp1 , tmp2 ); } } else { int ans = inf ; if (( tree [ a ][ 0 ] && tree [ b ][ 0 ]) || ( tree [ a ][ 1 ] && tree [ b ][ 1 ])) { ans = min ( ans , solve ( tree [ a ][ 0 ], tree [ b ][ 0 ], dp -1 )); ans = min ( ans , solve ( tree [ a ][ 1 ], tree [ b ][ 1 ], dp -1 )); } else { ans = min ( ans , solve ( tree [ a ][ 1 ], tree [ b ][ 0 ], dp -1 ) + ( 1 << dp )); ans = min ( ans , solve ( tree [ a ][ 0 ], tree [ b ][ 1 ], dp -1 ) + ( 1 << dp )); } return ans ; } } int main () { int n , m ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= 2 * n ; i ++ ) { scanf ( \"%d\" , & m ); insert1 ( m ); } cout << solve ( 1 , 1 , 29 ) << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#5","text":"","title":"\u9898\u76ee5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_37","text":"Mountain Climbing","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_38","text":"Farmer John has discovered that his cows produce higher quality milk when they are subject to strenuous exercise. He therefore decides to send his N cows (1 <= N <= 25,000) to climb up and then back down a nearby mountain! Cow i takes U(i) time to climb up the mountain and then D(i) time to climb down the mountain. Being domesticated cows, each cow needs the help of a farmer for each leg of the climb, but due to the poor economy, there are only two farmers available, Farmer John and his cousin Farmer Don. FJ plans to guide cows for the upward climb, and FD will then guide the cows for the downward climb. Since every cow needs a guide, and there is only one farmer for each part of the voyage, at most one cow may be climbing upward at any point in time (assisted by FJ), and at most one cow may be climbing down at any point in time (assisted by FD). A group of cows may temporarily accumulate at the top of the mountain if they climb up and then need to wait for FD's assistance before climbing down. Cows may climb down in a different order than they climbed up. Please determine the least possible amount of time for all N cows to make the entire journey.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_39","text":"* Line 1: The number of cows, N. * Lines 2..1+N: Line i+1 contains two space-separated integers: U(i) and D(i). (1 <= U(i), D(i) <= 50,000).","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_40","text":"* Line 1: A single integer representing the least amount of time for all the cows to cross the mountain.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_41","text":"3 6 4 8 1 2 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_42","text":"17","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_43","text":"\u4e8c\u7ea7\u8f66\u95f4\u8c03\u5ea6\u95ee\u9898\uff0c\u8d2a\u5fc3\uff0c\u8ba9\u4e0b\u5c71\u6bd4\u4e0a\u5c71\u5feb\u7684\u5148\u4e0a\uff0c\u7136\u540e\u5728\u8d2a\u5fc3\u7684\u7f29\u77ed\u4e0a\u5c71\u65f6\u95f4\u548c\u6269\u5927\u4e0b\u5c71\u65f6\u95f4\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_44","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll u , d , sum , sum1 ; }; bool cmp ( node a , node b ) { if ( a . d > a . u && b . d <= b . u ) ///\u4e0b\u7684\u6162\u7684\u4f18\u5148 return 1 ; else if ( a . d <= a . u && b . d > b . u ) return 0 ; else if ( a . d > a . u ) return a . u < b . u ; ///\u4e0a\u7684\u5feb\u7684\u4f18\u5148 else return a . d > b . d ; ///\u4e0b\u7684\u6162\u7684\u4f18\u5148 } node a [ 25500 ] = { 0 }; int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld%lld\" , & a [ i ]. u , & a [ i ]. d ); sort ( a + 1 , a + n + 1 , cmp ); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) a [ i ]. sum = a [ i -1 ]. sum + a [ i ]. u ; for ( ll i = 1 ; i <= n ; i ++ ) { a [ i ]. sum1 = max ( a [ i ]. sum , a [ i -1 ]. sum1 ) + a [ i ]. d ; ans = max ( ans , a [ i ]. sum1 ); } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#6","text":"","title":"\u9898\u76ee6"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_45","text":"Tower","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_46","text":"There are N blocks, numbered 1,2,\u2026,N. For each i (1\u2264i\u2264N), Block i has a weight of wi, a solidness of si and a value of vi. Taro has decided to build a tower by choosing some of the N blocks and stacking them vertically in some order. Here, the tower must satisfy the following condition: For each Block i contained in the tower, the sum of the weights of the blocks stacked above it is not greater than si. Find the maximum possible sum of the values of the blocks contained in the tower. Constraints All values in input are integers. 1\u2264N\u2264 10^3 10^3 1\u2264wi,si\u2264 10^4 10^4 1\u2264vi\u2264 10^9 10^9","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_47","text":"Input is given from Standard Input in the following format: N w1 s1 v1 w2 s2 v2 : wN sN vN","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_48","text":"Print the maximum possible sum of the values of the blocks contained in the tower.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_49","text":"\u3010\u6837\u4f8b 1 \u3011 3 2 2 20 2 1 30 3 1 40 \u3010\u6837\u4f8b 2 \u3011 4 1 2 10 3 1 10 2 4 10 1 6 10 \u3010\u6837\u4f8b 3 \u3011 5 1 10000 1000000000 1 10000 1000000000 1 10000 1000000000 1 10000 1000000000 1 10000 1000000000 \u3010\u6837\u4f8b 4 \u3011 8 9 5 7 6 2 7 5 7 3 7 8 8 1 9 6 3 3 3 4 1 7 4 5 5","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_50","text":"\u3010\u6837\u4f8b1\u3011 50 \u3010\u6837\u4f8b2\u3011 40 \u3010\u6837\u4f8b3\u3011 5000000000 \u3010\u6837\u4f8b4\u3011 22","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_51","text":"\u6837\u4f8b1\u89e3\u91ca\uff1aIf Blocks 2,1 are stacked in this order from top to bottom, this tower will satisfy the condition, with the total value of 30+20=50. \u6837\u4f8b2\u89e3\u91ca\uff1aBlocks 1,2,3,4 should be stacked in this order from top to bottom. \u6837\u4f8b3\u89e3\u91ca\uff1aThe answer may not fit into a 32-bit integer type. \u6837\u4f8b4\u89e3\u91ca\uff1aWe should, for example, stack Blocks 5,6,8,4 in this order from top to bottom.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_52","text":"\u9996\u5148\u8d2a\u5fc3\u6392\u5e8f\uff0c\u5bf9\u4e8ea\u548cb\u4e24\u4e2a\u7269\u54c1\uff0c\u5982\u679ca\u653e\u5728b\u4e0a\u9762\u5219\u6743\u503c\u4e3as[b]-w[a]\uff0c\u5982\u679cb\u653e\u5728a\u4e0a\u9762\uff0c\u5219\u6743\u503c\u4e3as[a]-w[b]\uff0c\u5219a\u548cb\u7684\u987a\u5e8f\u7531s[b]-w[a]\u548cs[a]-w[b]\u6240\u51b3\u5b9a\uff0c\u79fb\u9879\u53ef\u5f97\u5373\u4e3a\u6bd4\u8f83s[a]+w[a]\u548cs[b]+w[b]\uff0c\u6240\u4ee5\u6839\u636es[a]+w[a]\u7684\u5927\u5c0f\u8d2a\u5fc3\u6392\u5e8f\uff0c\u540e\u6839\u636e\u91cd\u91cf\u9650\u5236\u52a8\u6001\u89c4\u5212\uff0c\u5373\u5047\u8bbedp[i]\u4e3a\u91cd\u91cf\u4e3ai\u65f6\u7684\u6700\u5927\u6743\u503c\uff0c\u5219\u8f6c\u79fb\u65b9\u7a0b\u4e3a\uff1a dp[j+w[i]]=max(dp[j+w[i]],dp[j]+v[i])(0<=j<=s[i]) dp[j+w[i]]=max(dp[j+w[i]],dp[j]+v[i])(0<=j<=s[i])","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_53","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll w , s , v ; }; node a [ 1005 ] = { 0 }; ll dp [ 30050 ] = { 0 }; int main () { ll n ; scanf ( \"%d\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%d%d%d\" , & a [ i ]. w , & a [ i ]. s , & a [ i ]. v ); sort ( a + 1 , a + n + 1 , []( node a , node b ) { return a . s + a . w < b . s + b . w ; }); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = a [ i ]. s ; j >= 0 ; j -- ) dp [ j + a [ i ]. w ] = max ( dp [ j + a [ i ]. w ], dp [ j ] + a [ i ]. v ); } for ( ll j = 0 ; j < 30050 ; j ++ ) ans = max ( ans , dp [ j ]); cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e94\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u95ee\u9898 C: Safe Distance \u9898\u76ee\u63cf\u8ff0 \u00b6 The past year has been difficult, with a virus spreading among the population. Fortunately, Alice knows that one of the keys to be healthy is to keep a safe distance from other people. Alice is currently in a closed room, represented in the 2D plane, with width X and height Y. There are N other people inside the room, and we\u2019re given their (xi, yi) coordinates. We consider Alice and the N people as points in the 2D plane. Alice\u2019s initial position is (0, 0) and she wants to move to the exit at position (X, Y). She can move freely in any direction inside the room,but can not step outside the room bounds. Find the maximum distance Alice can keep from other people while moving from (0, 0) to (X, Y). \u8f93\u5165 \u00b6 The input begins with one line containing two space-separated integers, X and Y, where X is the width, and Y is the height of the room. The second line consists of a single integer N, the number of people in the room. Then N lines follow, each of them consisting of two floating-point numbers xi and yi, the coordinates of the ith person in the room. \u2022 1\u2264X, Y\u22641 000 000 \u2022 1\u2264N\u22641 000 \u2022 0\u2264xi\u2264X \u2022 0\u2264yi\u2264Y \u8f93\u51fa \u00b6 The output consists of a single value d, the maximum safe distance, as a floating-point number. An additive or multiplicative error of 10\u22125 is tolerated: if d is the answer, any number either within [d \u2212 10^{\u22125} 10^{\u22125} ; d + 10^{\u22125} 10^{\u22125} ] or within [(1 \u2212 10^{\u22125} 10^{\u22125} )d; (1 + 10^{\u22125} 10^{\u22125} )d] is accepted. \u6837\u4f8b\u8f93\u5165 \u00b6 8 6 3 3 1 3 5.5 6.5 1.5 \u6837\u4f8b\u8f93\u51fa \u00b6 2.250000 \u63d0\u793a \u00b6 Alice can keep a distance of 2.25 from every other person, and this is the best she can do. The picture below shows a possible path (in green). \u9898\u89e3 \u00b6 \u5e76\u67e5\u96c6\u9898\u76ee\uff0c\u5c06\u5de6\u548c\u4e0a\u9762\u7684\u4e24\u6761\u8fb9\u770b\u4f5c\u8d77\u70b9\uff0c\u5c06\u53f3\u548c\u4e0b\u9762\u7684\u4e24\u6761\u8fb9\u770b\u4f5c\u7ec8\u70b9\uff0c\u5982\u679c\u8d77\u70b9\u548c\u7ec8\u70b9\u76f8\u4e92\u8fde\u901a\uff0c\u5219S\u548cF\u70b9\u5c06\u65e0\u6cd5\u8fde\u901a\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int from , to ; double val ; }; vector < node > v ; int fa [ 100500 ] = { 0 }; double xx [ 100500 ] = { 0 }, yy [ 100500 ] = { 0 }; int findfa ( int x ) { if ( x == fa [ x ]) return x ; return fa [ x ] = findfa ( fa [ x ]); } bool cmp ( node a , node b ) { return a . val < b . val ; } int main () { double x , y ; scanf ( \"%lf%lf\" , & x , & y ); int n ; scanf ( \"%d\" , & n ); int s = n + 1 , e = n + 2 ; fa [ s ] = s , fa [ e ] = e ; for ( int i = 1 ; i <= n ; i ++ ) { fa [ i ] = i ; scanf ( \"%lf%lf\" , & xx [ i ], & yy [ i ]); v . push_back ({ s , i , min ( xx [ i ], y - yy [ i ])}); v . push_back ({ e , i , min ( x - xx [ i ], yy [ i ])}); for ( int j = 1 ; j < i ; j ++ ) v . push_back ({ i , j , sqrt (( xx [ i ] - xx [ j ]) * ( xx [ i ] - xx [ j ]) + ( yy [ i ] - yy [ j ]) * ( yy [ i ] - yy [ j ])) / 2.0 }); } sort ( v . begin (), v . end (), cmp ); for ( int i = 0 ; i < v . size (); i ++ ) { int fx = findfa ( v [ i ]. from ); int fy = findfa ( v [ i ]. to ); if ( fx == fy ) continue ; fa [ fx ] = fy ; if ( findfa ( s ) == findfa ( e )) { printf ( \"%.8f \\n \" , v [ i ]. val ); return 0 ; } } }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e94\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e94\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_2","text":"\u95ee\u9898 C: Safe Distance","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_3","text":"The past year has been difficult, with a virus spreading among the population. Fortunately, Alice knows that one of the keys to be healthy is to keep a safe distance from other people. Alice is currently in a closed room, represented in the 2D plane, with width X and height Y. There are N other people inside the room, and we\u2019re given their (xi, yi) coordinates. We consider Alice and the N people as points in the 2D plane. Alice\u2019s initial position is (0, 0) and she wants to move to the exit at position (X, Y). She can move freely in any direction inside the room,but can not step outside the room bounds. Find the maximum distance Alice can keep from other people while moving from (0, 0) to (X, Y).","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_4","text":"The input begins with one line containing two space-separated integers, X and Y, where X is the width, and Y is the height of the room. The second line consists of a single integer N, the number of people in the room. Then N lines follow, each of them consisting of two floating-point numbers xi and yi, the coordinates of the ith person in the room. \u2022 1\u2264X, Y\u22641 000 000 \u2022 1\u2264N\u22641 000 \u2022 0\u2264xi\u2264X \u2022 0\u2264yi\u2264Y","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_5","text":"The output consists of a single value d, the maximum safe distance, as a floating-point number. An additive or multiplicative error of 10\u22125 is tolerated: if d is the answer, any number either within [d \u2212 10^{\u22125} 10^{\u22125} ; d + 10^{\u22125} 10^{\u22125} ] or within [(1 \u2212 10^{\u22125} 10^{\u22125} )d; (1 + 10^{\u22125} 10^{\u22125} )d] is accepted.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_6","text":"8 6 3 3 1 3 5.5 6.5 1.5","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_7","text":"2.250000","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_8","text":"Alice can keep a distance of 2.25 from every other person, and this is the best she can do. The picture below shows a possible path (in green).","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_9","text":"\u5e76\u67e5\u96c6\u9898\u76ee\uff0c\u5c06\u5de6\u548c\u4e0a\u9762\u7684\u4e24\u6761\u8fb9\u770b\u4f5c\u8d77\u70b9\uff0c\u5c06\u53f3\u548c\u4e0b\u9762\u7684\u4e24\u6761\u8fb9\u770b\u4f5c\u7ec8\u70b9\uff0c\u5982\u679c\u8d77\u70b9\u548c\u7ec8\u70b9\u76f8\u4e92\u8fde\u901a\uff0c\u5219S\u548cF\u70b9\u5c06\u65e0\u6cd5\u8fde\u901a\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_10","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int from , to ; double val ; }; vector < node > v ; int fa [ 100500 ] = { 0 }; double xx [ 100500 ] = { 0 }, yy [ 100500 ] = { 0 }; int findfa ( int x ) { if ( x == fa [ x ]) return x ; return fa [ x ] = findfa ( fa [ x ]); } bool cmp ( node a , node b ) { return a . val < b . val ; } int main () { double x , y ; scanf ( \"%lf%lf\" , & x , & y ); int n ; scanf ( \"%d\" , & n ); int s = n + 1 , e = n + 2 ; fa [ s ] = s , fa [ e ] = e ; for ( int i = 1 ; i <= n ; i ++ ) { fa [ i ] = i ; scanf ( \"%lf%lf\" , & xx [ i ], & yy [ i ]); v . push_back ({ s , i , min ( xx [ i ], y - yy [ i ])}); v . push_back ({ e , i , min ( x - xx [ i ], yy [ i ])}); for ( int j = 1 ; j < i ; j ++ ) v . push_back ({ i , j , sqrt (( xx [ i ] - xx [ j ]) * ( xx [ i ] - xx [ j ]) + ( yy [ i ] - yy [ j ]) * ( yy [ i ] - yy [ j ])) / 2.0 }); } sort ( v . begin (), v . end (), cmp ); for ( int i = 0 ; i < v . size (); i ++ ) { int fx = findfa ( v [ i ]. from ); int fy = findfa ( v [ i ]. to ); if ( fx == fy ) continue ; fa [ fx ] = fy ; if ( findfa ( s ) == findfa ( e )) { printf ( \"%.8f \\n \" , v [ i ]. val ); return 0 ; } } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u56db\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u95ee\u9898 F: Fair Distribution \u9898\u76ee\u63cf\u8ff0 \u00b6 There are n robots and m energy bars in the Dream Kingdom. DreamGrid, the king, is trying to make a fair distribution of the energy bars. A fair distribution exists if and only if the number of the energy bars is a multiple of the number of robots. The only tool DreamGrid has is a powerful laser gun. Every time he turns on the laser gun, he can do exactly one of the two things: Create a new energy bar. Destroy a robot. To avoid the extinction of robots, it's forbidden to destroy all the n robots. It takes one dollar to turn on the laser gun once. You are asked to find the minimum cost of making a fair distribution. \u8f93\u5165 \u00b6 There are multiple test cases. The first line of the input contains an integer T (1\u2264T\u22641000), indicating the number of test cases. For each test case: The only line contains two integers n and m (1\u2264n,m\u2264108), indicating the initial number of robots and energy bars. \u8f93\u51fa \u00b6 For each test case output one line containing an integer, indicating the minimum cost to get a fair distribution. \u6837\u4f8b\u8f93\u5165 \u00b6 3 3 12 10 6 8 20 \u6837\u4f8b\u8f93\u51fa \u00b6 0 4 2 \u63d0\u793a \u00b6 For the third sample, the best way is to destroy a robot and create an energy bar. After that, we have 7 robots and 21 energy bars, which leads to a fair distribution. \u9898\u89e3 \u00b6 \u679a\u4e3e\u673a\u5668\u4eba\u5c11\u4e86x\u4e2a\uff0c\u5219\u53ef\u5f97\u5f53\u524d\u7684\u7b54\u6848\uff1a n-(n-x)+(\\frac{m+n-x-1}{n-x})*(n-x)-m=n-m+\\frac{m-1}{n-x}*(n-x) n-(n-x)+(\\frac{m+n-x-1}{n-x})*(n-x)-m=n-m+\\frac{m-1}{n-x}*(n-x) \u5176\u4e2d \\frac{m-1}{n-x}*(n-x) \\frac{m-1}{n-x}*(n-x) \u53ef\u4ee5\u7531\u6574\u6570\u5206\u5757\u5f97\u5230\uff0c\u7c7b\u4f3c\u4e8e \\sum{\\frac{n}{i}} \\sum{\\frac{n}{i}} \uff0c\u6700\u540e\u7edf\u8ba1\u7b54\u6848\u53d6\u6700\u5c0f\u503c\u5373\u53ef\u3002 \u53c2\u8003\u535a\u5ba2\uff1a https://blog.csdn.net/qq_50377393/article/details/119151746 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); if ( n >= m ) { printf ( \"%d \\n \" , n - m ); continue ; } int ans = 0x3f3f3f3f ; for ( int l = 1 , r ; l <= n ; l = r + 1 ) { r = min ( n , ( m - 1 ) / (( m - 1 ) / l )); ans = min ( ans , n - m + ( m - 1 ) / l * l ); } printf ( \"%d \\n \" , ans ); } }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u56db\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u56db\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_2","text":"\u95ee\u9898 F: Fair Distribution","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_3","text":"There are n robots and m energy bars in the Dream Kingdom. DreamGrid, the king, is trying to make a fair distribution of the energy bars. A fair distribution exists if and only if the number of the energy bars is a multiple of the number of robots. The only tool DreamGrid has is a powerful laser gun. Every time he turns on the laser gun, he can do exactly one of the two things: Create a new energy bar. Destroy a robot. To avoid the extinction of robots, it's forbidden to destroy all the n robots. It takes one dollar to turn on the laser gun once. You are asked to find the minimum cost of making a fair distribution.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_4","text":"There are multiple test cases. The first line of the input contains an integer T (1\u2264T\u22641000), indicating the number of test cases. For each test case: The only line contains two integers n and m (1\u2264n,m\u2264108), indicating the initial number of robots and energy bars.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_5","text":"For each test case output one line containing an integer, indicating the minimum cost to get a fair distribution.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_6","text":"3 3 12 10 6 8 20","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_7","text":"0 4 2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_8","text":"For the third sample, the best way is to destroy a robot and create an energy bar. After that, we have 7 robots and 21 energy bars, which leads to a fair distribution.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_9","text":"\u679a\u4e3e\u673a\u5668\u4eba\u5c11\u4e86x\u4e2a\uff0c\u5219\u53ef\u5f97\u5f53\u524d\u7684\u7b54\u6848\uff1a n-(n-x)+(\\frac{m+n-x-1}{n-x})*(n-x)-m=n-m+\\frac{m-1}{n-x}*(n-x) n-(n-x)+(\\frac{m+n-x-1}{n-x})*(n-x)-m=n-m+\\frac{m-1}{n-x}*(n-x) \u5176\u4e2d \\frac{m-1}{n-x}*(n-x) \\frac{m-1}{n-x}*(n-x) \u53ef\u4ee5\u7531\u6574\u6570\u5206\u5757\u5f97\u5230\uff0c\u7c7b\u4f3c\u4e8e \\sum{\\frac{n}{i}} \\sum{\\frac{n}{i}} \uff0c\u6700\u540e\u7edf\u8ba1\u7b54\u6848\u53d6\u6700\u5c0f\u503c\u5373\u53ef\u3002 \u53c2\u8003\u535a\u5ba2\uff1a https://blog.csdn.net/qq_50377393/article/details/119151746","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_10","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); if ( n >= m ) { printf ( \"%d \\n \" , n - m ); continue ; } int ans = 0x3f3f3f3f ; for ( int l = 1 , r ; l <= n ; l = r + 1 ) { r = min ( n , ( m - 1 ) / (( m - 1 ) / l )); ans = min ( ans , n - m + ( m - 1 ) / l * l ); } printf ( \"%d \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Multiple Sequences \u9898\u76ee\u63cf\u8ff0 \u00b6 Given are integers N and M. How many sequences A of N integers satisfy the following conditions? 1\u2264Ai\u2264M(i=1,2,\u2026,N) Ai+1 is a multiple of Ai. (i=1,2,\u2026,N\u22121) Since the answer can be enormous, report it modulo 998244353. Constraints All values in input are integers. 1\u2264N\u22642\u00d7 10^5 10^5 1\u2264M\u22642\u00d7 10^5 10^5 \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N M \u8f93\u51fa \u00b6 Print the answer. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 3 4 \u3010\u6837\u4f8b2\u3011 20 30 \u3010\u6837\u4f8b3\u3011 200000 200000 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 13 \u3010\u6837\u4f8b2\u3011 71166 \u3010\u6837\u4f8b3\u3011 835917264 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca Some of the sequences A satisfying the conditions follow: A=(1,1,4) A=(3,3,3) A=(1,2,4) \u9898\u89e3 \u00b6 \u6392\u5217\u7ec4\u5408+\u8d28\u56e0\u6570\u5206\u89e3\uff0c\u679a\u4e3eAn\u7684\u53d6\u503c\u8303\u56f4\uff0c\u53731-m\uff0c\u540e\u5bf9An\u8fdb\u884c\u8d28\u56e0\u6570\u5206\u89e3\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u56e0\u5b50p\uff0c\u8bbe\u5176\u4e3ae\u6b21\u5e42\uff0c\u5219\u5bf9\u4e8ep\u56e0\u5b50\uff0c\u53ef\u4ee5\u653e\u5728n\u4e2a\u4f4d\u7f6e\u4e0a\uff0c\u6a21\u578b\u8f6c\u4e3a\u5c06e\u4e2a\u5c0f\u7403\u653e\u5230n\u4e2a\u76d2\u5b50\u4e2d\u4e14\u76d2\u5b50\u53ef\u4ee5\u4e3a\u7a7a\uff0c\u5219\u7b54\u6848\u4e3a$ \\tbinom{n+e-1}{e}$\u200b \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/weixin_43184669/article/details/116059248 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b % 2 ) ans1 = ( ans2 * ans1 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } ll inv [ 300500 ] = { 0 }; ll jc [ 300500 ] = { 0 }; ll C ( ll a , ll b ) { if ( a == b ) return 1 ; if ( b > a || a == 0 ) return 0 ; ll res = jc [ a ] * inv [ b ] % mod * inv [ a - b ] % mod ; return res ; } int main () { jc [ 0 ] = 1 ; for ( ll i = 1 ; i <= 300100 ; i ++ ) jc [ i ] = ( jc [ i -1 ] * i ) % mod ; inv [ 300100 ] = ksm ( jc [ 300100 ], mod -2 ); for ( ll i = 300100-1 ; i >= 1 ; i -- ) inv [ i ] = inv [ i + 1 ] * ( i + 1 ) % mod ; ll n , m , ans = 0 ; cin >> n >> m ; for ( ll i = 1 ; i <= m ; i ++ ) { vector < ll > v ; ll tmp = i ; for ( ll j = 2 ; j * j <= tmp ; j ++ ) { if ( tmp % j != 0 ) continue ; ll cnt = 0 ; while ( tmp % j == 0 ) { tmp /= j ; cnt ++ ; } v . push_back ( cnt ); } if ( tmp != 1 ) v . push_back ( 1 ); tmp = 1 ; for ( int i = 0 ; i < v . size (); i ++ ) tmp = ( tmp * C ( n + v [ i ] -1 , v [ i ])) % mod ; ans = ( ans + tmp ) % mod ; } cout << ans << endl ; } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Grass Planting \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has N barren pastures (2 <= N <= 100,000) connected by N-1 bidirectional roads, such that there is exactly one path between any two pastures. Bessie, a cow who loves her grazing time, often complains about how there is no grass on the roads between pastures. Farmer John loves Bessie very much, and today he is finally going to plant grass on the roads. He will do so using a procedure consisting of M steps (1 <= M <=100,000). At each step one of two things will happen: - FJ will choose two pastures, and plant a patch of grass along each road in between the two pastures, or, - Bessie will ask about how many patches of grass on a particular road, and Farmer John must answer her question. Farmer John is a very poor counter -- help him answer Bessie's questions! \u8f93\u5165 \u00b6 Line 1: Two space-separated integers N and M Lines 2..N: Two space-separated integers describing the endpoints of a road. Lines N+1..N+M: Line i+1 describes step i. The first character of the line is either P or Q, which describes whether or not FJ is planting grass or simply querying. This is followed by two space-separated integers A_i and B_i (1 <= A_i, B_i <= N) which describe FJ's action or query. \u8f93\u51fa \u00b6 Lines 1..???: Each line has the answer to a query, appearing in the same order as the queries appear in the input. \u6837\u4f8b\u8f93\u5165 \u00b6 4 6 1 4 2 4 3 4 P 2 3 P 1 3 Q 3 4 P 1 4 Q 2 4 Q 1 4 \u6837\u4f8b\u8f93\u51fa \u00b6 2 1 2 \u9898\u89e3 \u00b6 \u6811\u94fe\u5256\u5206\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll sum [ 400500 ] = { 0 }, lazy [ 400500 ] = { 0 }; ll dep [ 200500 ] = { 0 }, size1 [ 200500 ] = { 0 }, son [ 200500 ] = { 0 }, f [ 200500 ] = { 0 }, id [ 200500 ] = { 0 }, top [ 200500 ] = { 0 }; struct node { ll to , next ; }; node edge [ 400500 ] = { 0 }; ll head [ 400500 ] = { 0 }; ll num = 0 , cnt = 0 ; void add_edge ( ll from , ll to ) { edge [ ++ num ] = { to , head [ from ]}; head [ from ] = num ; } void dfs1 ( ll now , ll fa ) { size1 [ now ] = 1 ; for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == fa ) continue ; f [ to ] = now ; dep [ to ] = dep [ now ] + 1 ; dfs1 ( to , now ); size1 [ now ] += size1 [ to ]; if ( size1 [ to ] > size1 [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( ll now , ll fa ) { id [ now ] = ++ cnt ; top [ now ] = fa ; if ( son [ now ]) dfs2 ( son [ now ], fa ); for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == f [ now ] || to == son [ now ]) continue ; dfs2 ( to , to ); } } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t + 1 ] += lazy [ t ]; lazy [ 2 * t ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += ( mid - l + 1 ) * lazy [ t ]; sum [ 2 * t + 1 ] += ( r - mid ) * lazy [ t ]; lazy [ t ] = 0 ; } void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { lazy [ t ] += add ; sum [ t ] += add * ( R - L + 1 ); return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query ( ll t , ll l , ll r , ll L , ll R ) { if ( l <= L && R <= r ) return sum [ t ]; push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; ll ans = 0 ; if ( l <= mid ) ans += query ( 2 * t , l , r , L , mid ); if ( mid < r ) ans += query ( 2 * t + 1 , l , r , mid + 1 , R ); return ans ; } void update_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ]; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); update ( 1 , id [ fx ], id [ x ], 1 , cnt , 1 ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); update ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt , 1 ); } ll query_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ], ans = 0 ; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); ans += query ( 1 , id [ fx ], id [ x ], 1 , cnt ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); ans += query ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt ); return ans ; } int main () { ll n , m , from , to ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } f [ 1 ] = 0 , dep [ 1 ] = 1 ; dfs1 ( 1 , 0 ), dfs2 ( 1 , 1 ); char c [ 10 ]; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , c + 1 , & from , & to ); if ( c [ 1 ] == 'P' ) update_chain ( from , to ); else printf ( \"%lld \\n \" , query_chain ( from , to )); } } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Eyjafjalla \u9898\u76ee \u00b6 \u9898\u89e3 \u00b6 \u6811\u94fe\u5256\u5206\uff0c\u5c06\u6811\u4e0a\u7684\u70b9\u6620\u5c04\u4e3a\u7ebf\u6bb5\u6811\u4e2d\u7684\u70b9\uff0c\u7136\u540e\u8be2\u95ee\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; vector < ll > v [ 100500 ]; ll size1 [ 100500 ] = { 0 }, id [ 100500 ] = { 0 }, fa [ 100500 ][ 30 ] = { 0 }, dep [ 100500 ] = { 0 }, tem [ 100500 ] = { 0 }, w [ 100500 ] = { 0 }; ll cnt = 0 ; ll max1 [ 400500 ] = { 0 }, min1 [ 400500 ] = { 0 }; void dfs ( ll now , ll fa1 ) { id [ now ] = ++ cnt ; dep [ now ] = dep [ fa1 ] + 1 ; size1 [ now ] = 1 ; w [ cnt ] = tem [ now ]; fa [ now ][ 0 ] = fa1 ; for ( ll i = 1 ; ( 1 << i ) <= dep [ now ]; i ++ ) fa [ now ][ i ] = fa [ fa [ now ][ i - 1 ]][ i - 1 ]; for ( ll i = 0 ; i < v [ now ]. size (); i ++ ) { ll to = v [ now ][ i ]; if ( to == fa1 ) continue ; dfs ( to , now ); size1 [ now ] += size1 [ to ]; } } bool check ( ll x , ll l , ll r ) { if ( x <= r && x >= l ) return 1 ; return 0 ; } void push_up ( ll t ) { min1 [ t ] = min ( min1 [ 2 * t ], min1 [ 2 * t + 1 ]); max1 [ t ] = max ( max1 [ 2 * t ], max1 [ 2 * t + 1 ]); } void build ( ll t , ll l , ll r ) { if ( l == r ) { max1 [ t ] = min1 [ t ] = w [ l ]; return ; } ll mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); push_up ( t ); } ll query_sum ( ll t , ll l , ll r , ll L , ll R , ll lt , ll rt ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( min1 [ t ] > rt || max1 [ t ] < lt ) return 0 ; else if ( l <= L && R <= r ) { if ( check ( max1 [ t ], lt , rt ) && check ( min1 [ t ], lt , rt )) return R - L + 1 ; } ll mid = ( L + R ) / 2 , sum = 0 ; if ( l <= mid ) sum += query_sum ( 2 * t , l , r , L , mid , lt , rt ); if ( mid < r ) sum += query_sum ( 2 * t + 1 , l , r , mid + 1 , R , lt , rt ); return sum ; } int main () { ll n , from , to ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i < n ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); v [ from ]. push_back ( to ); v [ to ]. push_back ( from ); } for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & tem [ i ]); dfs ( 1 , 0 ); build ( 1 , 1 , n ); ll x , l , r , q ; scanf ( \"%lld\" , & q ); for ( ll i = 1 ; i <= q ; i ++ ) { scanf ( \"%lld%lld%lld\" , & x , & l , & r ); if ( ! check ( tem [ x ], l , r )) { puts ( \"0\" ); continue ; } for ( int i = 21 ; i >= 0 ; i -- ) { int fa1 = fa [ x ][ i ]; if ( fa1 != 0 ) { if ( check ( tem [ fa1 ], l , r )) x = fa1 ; } } printf ( \"%lld \\n \" , query_sum ( 1 , id [ x ], id [ x ] + size1 [ x ] - 1 , 1 , n , l , r )); } } \u9898\u76ee4 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Simplifying the Farm \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has been taking an evening algorithms course at his local university, and he has just learned about minimum spanning trees. However, Farmer John now realizes that the design of his farm is not as efficient as it could be, and he wants to simplify the layout of his farm. The farm is currently arranged like a graph, with vertices representing fields and edges representing pathways between these fields, each having an associated length. Farmer John notes that for each distinct length, at most three pathways on his farm share this length. FJ would like to remove some of the pathways on his farm so that it becomes a tree -- that is, so that there is one unique route between any pair of fields. Moreover, Farmer John would like this to be a minimum spanning tree -- a tree having the smallest possible sum of edge lengths. Help Farmer John compute not only the sum of edge lengths in a minimum spanning tree derived from his farm graph, but also the number of different possible minimum spanning trees he can create. \u8f93\u5165 \u00b6 Line 1: Two integers N and M (1 <= N <= 40,000; 1 <= M <= 100,000), representing the number of vertices and edges in the farm graph, respectively. Vertices are numbered as 1..N. Lines 2..M+1: Three integers a_i, b_i and n_i (1 <= a_i, b_i <= N; 1<= n_i <= 1,000,000) representing an edge from vertex a_i to b_i with length n_i. No edge length n_i will occur more than three times. \u8f93\u51fa \u00b6 Line 1: Two integers representing the length of the minimal spanning tree and the number of minimal spanning trees (mod 1,000,000,007). \u6837\u4f8b\u8f93\u5165 \u00b6 4 5 1 2 1 3 4 1 1 3 2 1 4 2 2 3 2 \u6837\u4f8b\u8f93\u51fa \u00b6 4 3 \u63d0\u793a \u00b6 Picking both edges with length 1 and any edge with length 2 yields a minimum spanning tree of length 4. \u9898\u89e3 \u00b6 \u6700\u5c0f\u751f\u6210\u6811\uff0c\u5206\u7c7b\u8ba8\u8bba\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; struct node { int from , to , val ; }; node a [ 100500 ] = { 0 }; bool cmp ( node a , node b ) { return a . val < b . val ; } int fa [ 100500 ] = { 0 }; int findfa ( int n ) { if ( n == fa [ n ]) return n ; return fa [ n ] = findfa ( fa [ n ]); } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) scanf ( \"%d%d%d\" , & a [ i ]. from , & a [ i ]. to , & a [ i ]. val ); for ( int i = 1 ; i <= n ; i ++ ) fa [ i ] = i ; sort ( a + 1 , a + m + 1 , cmp ); ll ans = 0 , sum = 1 ; for ( int i = 1 ; i <= m ;) { int cnt = 0 , num = 0 ; set < pair < int , int >> s ; int j ; for ( j = i ; a [ j ]. val == a [ i ]. val && j <= m ; j ++ ) { int fx = findfa ( a [ j ]. from ); int fy = findfa ( a [ j ]. to ); if ( fx > fy ) swap ( fx , fy ); if ( fx != fy ) { cnt ++ ; s . insert ({ fx , fy }); } } for (; i < j ; i ++ ) { int fx = findfa ( a [ i ]. from ); int fy = findfa ( a [ i ]. to ); if ( fx != fy ) { num ++ ; fa [ fx ] = fy ; ans += a [ i ]. val ; } } if ( num == 1 ) { sum = sum * cnt % mod ; } else if ( num == 2 ) { if ( cnt == 3 && s . size () == 2 ) sum = sum * 2 % mod ; else if ( cnt == 3 && s . size () == 3 ) sum = sum * 3 % mod ; } } cout << ans << ' ' << sum << endl ; } \u9898\u76ee5 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 GCD Game \u9898\u76ee\u63cf\u8ff0 \u00b6 Alice and Bob are playing a game. They take turns to operate. There are n numbers, a1 , a2 , ... , an. Every time, the player plays in 3 steps. 1.Arbitrarily chooses one number ai. 2.Arbitrarily chooses another number x(1\u2264x<ai). 3.Replace the number ai with gcd(ai,x). Here, gcd(u,v) refers to the Greatest Common Divisor of u and v. When a player can not make a single move he/she loses the game. Alice moves the first and she asks you to tell her who will win the game if both player play optimally. \u8f93\u5165 \u00b6 The first line contains a number T(1\u2264T\u2264100), the number of testcases. For each testcase, there are two lines. The first line contains one number n(1\u2264n\u2264 10^6 10^6 ). The second line contains n numbers a1 , a2 , ... , an(1\u2264ai\u2264 10^7 10^7 ). It is guaranteed that for all testcases, \u2211n\u2264 10^6 10^6 \u200b. \u8f93\u51fa \u00b6 Line 1: Two integers representing the length of the minimal spanning tree and the number of minimal spanning trees (mod 1,000,000,007). \u6837\u4f8b\u8f93\u5165 \u00b6 2 1 1 1 2 \u6837\u4f8b\u8f93\u51fa \u00b6 Bob Alice \u9898\u89e3 \u00b6 \u5c3c\u5c14\u535a\u5f08\u53d8\u5f62\uff0c\u6c42\u89e3\u8d28\u56e0\u6570\u7684\u4e2a\u6570\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; const ll maxn = 1e7 + 5 ; ll low_prime [ 10050000 ] = { 0 }; ll prime [ 700500 ] = { 0 }; ll cnt = 0 ; int main () { for ( ll i = 2 ; i <= maxn ; i ++ ) { if ( low_prime [ i ] == 0 ) { low_prime [ i ] = i ; prime [ ++ cnt ] = i ; } for ( ll j = 1 ; j <= cnt && prime [ j ] * i <= maxn ; j ++ ) { low_prime [ prime [ j ] * i ] = prime [ j ]; if ( i % prime [ j ] == 0 ) break ; } } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , flag = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { ll m , sum = 0 ; scanf ( \"%lld\" , & m ); while ( m > 1 ) { m /= low_prime [ m ]; sum ++ ; } flag ^= sum ; } if ( ! flag ) puts ( \"Bob\" ); else puts ( \"Alice\" ); } }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_2","text":"Multiple Sequences","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_3","text":"Given are integers N and M. How many sequences A of N integers satisfy the following conditions? 1\u2264Ai\u2264M(i=1,2,\u2026,N) Ai+1 is a multiple of Ai. (i=1,2,\u2026,N\u22121) Since the answer can be enormous, report it modulo 998244353. Constraints All values in input are integers. 1\u2264N\u22642\u00d7 10^5 10^5 1\u2264M\u22642\u00d7 10^5 10^5","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_4","text":"Input is given from Standard Input in the following format: N M","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_5","text":"Print the answer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_6","text":"\u3010\u6837\u4f8b1\u3011 3 4 \u3010\u6837\u4f8b2\u3011 20 30 \u3010\u6837\u4f8b3\u3011 200000 200000","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_7","text":"\u3010\u6837\u4f8b1\u3011 13 \u3010\u6837\u4f8b2\u3011 71166 \u3010\u6837\u4f8b3\u3011 835917264","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_8","text":"\u6837\u4f8b1\u89e3\u91ca Some of the sequences A satisfying the conditions follow: A=(1,1,4) A=(3,3,3) A=(1,2,4)","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_9","text":"\u6392\u5217\u7ec4\u5408+\u8d28\u56e0\u6570\u5206\u89e3\uff0c\u679a\u4e3eAn\u7684\u53d6\u503c\u8303\u56f4\uff0c\u53731-m\uff0c\u540e\u5bf9An\u8fdb\u884c\u8d28\u56e0\u6570\u5206\u89e3\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u56e0\u5b50p\uff0c\u8bbe\u5176\u4e3ae\u6b21\u5e42\uff0c\u5219\u5bf9\u4e8ep\u56e0\u5b50\uff0c\u53ef\u4ee5\u653e\u5728n\u4e2a\u4f4d\u7f6e\u4e0a\uff0c\u6a21\u578b\u8f6c\u4e3a\u5c06e\u4e2a\u5c0f\u7403\u653e\u5230n\u4e2a\u76d2\u5b50\u4e2d\u4e14\u76d2\u5b50\u53ef\u4ee5\u4e3a\u7a7a\uff0c\u5219\u7b54\u6848\u4e3a$ \\tbinom{n+e-1}{e}$\u200b \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/weixin_43184669/article/details/116059248","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_10","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b % 2 ) ans1 = ( ans2 * ans1 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } ll inv [ 300500 ] = { 0 }; ll jc [ 300500 ] = { 0 }; ll C ( ll a , ll b ) { if ( a == b ) return 1 ; if ( b > a || a == 0 ) return 0 ; ll res = jc [ a ] * inv [ b ] % mod * inv [ a - b ] % mod ; return res ; } int main () { jc [ 0 ] = 1 ; for ( ll i = 1 ; i <= 300100 ; i ++ ) jc [ i ] = ( jc [ i -1 ] * i ) % mod ; inv [ 300100 ] = ksm ( jc [ 300100 ], mod -2 ); for ( ll i = 300100-1 ; i >= 1 ; i -- ) inv [ i ] = inv [ i + 1 ] * ( i + 1 ) % mod ; ll n , m , ans = 0 ; cin >> n >> m ; for ( ll i = 1 ; i <= m ; i ++ ) { vector < ll > v ; ll tmp = i ; for ( ll j = 2 ; j * j <= tmp ; j ++ ) { if ( tmp % j != 0 ) continue ; ll cnt = 0 ; while ( tmp % j == 0 ) { tmp /= j ; cnt ++ ; } v . push_back ( cnt ); } if ( tmp != 1 ) v . push_back ( 1 ); tmp = 1 ; for ( int i = 0 ; i < v . size (); i ++ ) tmp = ( tmp * C ( n + v [ i ] -1 , v [ i ])) % mod ; ans = ( ans + tmp ) % mod ; } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_11","text":"Grass Planting","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_12","text":"Farmer John has N barren pastures (2 <= N <= 100,000) connected by N-1 bidirectional roads, such that there is exactly one path between any two pastures. Bessie, a cow who loves her grazing time, often complains about how there is no grass on the roads between pastures. Farmer John loves Bessie very much, and today he is finally going to plant grass on the roads. He will do so using a procedure consisting of M steps (1 <= M <=100,000). At each step one of two things will happen: - FJ will choose two pastures, and plant a patch of grass along each road in between the two pastures, or, - Bessie will ask about how many patches of grass on a particular road, and Farmer John must answer her question. Farmer John is a very poor counter -- help him answer Bessie's questions!","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_13","text":"Line 1: Two space-separated integers N and M Lines 2..N: Two space-separated integers describing the endpoints of a road. Lines N+1..N+M: Line i+1 describes step i. The first character of the line is either P or Q, which describes whether or not FJ is planting grass or simply querying. This is followed by two space-separated integers A_i and B_i (1 <= A_i, B_i <= N) which describe FJ's action or query.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_14","text":"Lines 1..???: Each line has the answer to a query, appearing in the same order as the queries appear in the input.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_15","text":"4 6 1 4 2 4 3 4 P 2 3 P 1 3 Q 3 4 P 1 4 Q 2 4 Q 1 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_16","text":"2 1 2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_17","text":"\u6811\u94fe\u5256\u5206\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_18","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll sum [ 400500 ] = { 0 }, lazy [ 400500 ] = { 0 }; ll dep [ 200500 ] = { 0 }, size1 [ 200500 ] = { 0 }, son [ 200500 ] = { 0 }, f [ 200500 ] = { 0 }, id [ 200500 ] = { 0 }, top [ 200500 ] = { 0 }; struct node { ll to , next ; }; node edge [ 400500 ] = { 0 }; ll head [ 400500 ] = { 0 }; ll num = 0 , cnt = 0 ; void add_edge ( ll from , ll to ) { edge [ ++ num ] = { to , head [ from ]}; head [ from ] = num ; } void dfs1 ( ll now , ll fa ) { size1 [ now ] = 1 ; for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == fa ) continue ; f [ to ] = now ; dep [ to ] = dep [ now ] + 1 ; dfs1 ( to , now ); size1 [ now ] += size1 [ to ]; if ( size1 [ to ] > size1 [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( ll now , ll fa ) { id [ now ] = ++ cnt ; top [ now ] = fa ; if ( son [ now ]) dfs2 ( son [ now ], fa ); for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == f [ now ] || to == son [ now ]) continue ; dfs2 ( to , to ); } } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t + 1 ] += lazy [ t ]; lazy [ 2 * t ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += ( mid - l + 1 ) * lazy [ t ]; sum [ 2 * t + 1 ] += ( r - mid ) * lazy [ t ]; lazy [ t ] = 0 ; } void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { lazy [ t ] += add ; sum [ t ] += add * ( R - L + 1 ); return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query ( ll t , ll l , ll r , ll L , ll R ) { if ( l <= L && R <= r ) return sum [ t ]; push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; ll ans = 0 ; if ( l <= mid ) ans += query ( 2 * t , l , r , L , mid ); if ( mid < r ) ans += query ( 2 * t + 1 , l , r , mid + 1 , R ); return ans ; } void update_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ]; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); update ( 1 , id [ fx ], id [ x ], 1 , cnt , 1 ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); update ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt , 1 ); } ll query_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ], ans = 0 ; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); ans += query ( 1 , id [ fx ], id [ x ], 1 , cnt ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); ans += query ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt ); return ans ; } int main () { ll n , m , from , to ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } f [ 1 ] = 0 , dep [ 1 ] = 1 ; dfs1 ( 1 , 0 ), dfs2 ( 1 , 1 ); char c [ 10 ]; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , c + 1 , & from , & to ); if ( c [ 1 ] == 'P' ) update_chain ( from , to ); else printf ( \"%lld \\n \" , query_chain ( from , to )); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_19","text":"Eyjafjalla","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_20","text":"","title":"\u9898\u76ee"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_21","text":"\u6811\u94fe\u5256\u5206\uff0c\u5c06\u6811\u4e0a\u7684\u70b9\u6620\u5c04\u4e3a\u7ebf\u6bb5\u6811\u4e2d\u7684\u70b9\uff0c\u7136\u540e\u8be2\u95ee\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_22","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; vector < ll > v [ 100500 ]; ll size1 [ 100500 ] = { 0 }, id [ 100500 ] = { 0 }, fa [ 100500 ][ 30 ] = { 0 }, dep [ 100500 ] = { 0 }, tem [ 100500 ] = { 0 }, w [ 100500 ] = { 0 }; ll cnt = 0 ; ll max1 [ 400500 ] = { 0 }, min1 [ 400500 ] = { 0 }; void dfs ( ll now , ll fa1 ) { id [ now ] = ++ cnt ; dep [ now ] = dep [ fa1 ] + 1 ; size1 [ now ] = 1 ; w [ cnt ] = tem [ now ]; fa [ now ][ 0 ] = fa1 ; for ( ll i = 1 ; ( 1 << i ) <= dep [ now ]; i ++ ) fa [ now ][ i ] = fa [ fa [ now ][ i - 1 ]][ i - 1 ]; for ( ll i = 0 ; i < v [ now ]. size (); i ++ ) { ll to = v [ now ][ i ]; if ( to == fa1 ) continue ; dfs ( to , now ); size1 [ now ] += size1 [ to ]; } } bool check ( ll x , ll l , ll r ) { if ( x <= r && x >= l ) return 1 ; return 0 ; } void push_up ( ll t ) { min1 [ t ] = min ( min1 [ 2 * t ], min1 [ 2 * t + 1 ]); max1 [ t ] = max ( max1 [ 2 * t ], max1 [ 2 * t + 1 ]); } void build ( ll t , ll l , ll r ) { if ( l == r ) { max1 [ t ] = min1 [ t ] = w [ l ]; return ; } ll mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); push_up ( t ); } ll query_sum ( ll t , ll l , ll r , ll L , ll R , ll lt , ll rt ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( min1 [ t ] > rt || max1 [ t ] < lt ) return 0 ; else if ( l <= L && R <= r ) { if ( check ( max1 [ t ], lt , rt ) && check ( min1 [ t ], lt , rt )) return R - L + 1 ; } ll mid = ( L + R ) / 2 , sum = 0 ; if ( l <= mid ) sum += query_sum ( 2 * t , l , r , L , mid , lt , rt ); if ( mid < r ) sum += query_sum ( 2 * t + 1 , l , r , mid + 1 , R , lt , rt ); return sum ; } int main () { ll n , from , to ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i < n ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); v [ from ]. push_back ( to ); v [ to ]. push_back ( from ); } for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & tem [ i ]); dfs ( 1 , 0 ); build ( 1 , 1 , n ); ll x , l , r , q ; scanf ( \"%lld\" , & q ); for ( ll i = 1 ; i <= q ; i ++ ) { scanf ( \"%lld%lld%lld\" , & x , & l , & r ); if ( ! check ( tem [ x ], l , r )) { puts ( \"0\" ); continue ; } for ( int i = 21 ; i >= 0 ; i -- ) { int fa1 = fa [ x ][ i ]; if ( fa1 != 0 ) { if ( check ( tem [ fa1 ], l , r )) x = fa1 ; } } printf ( \"%lld \\n \" , query_sum ( 1 , id [ x ], id [ x ] + size1 [ x ] - 1 , 1 , n , l , r )); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#4","text":"","title":"\u9898\u76ee4"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_23","text":"Simplifying the Farm","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_24","text":"Farmer John has been taking an evening algorithms course at his local university, and he has just learned about minimum spanning trees. However, Farmer John now realizes that the design of his farm is not as efficient as it could be, and he wants to simplify the layout of his farm. The farm is currently arranged like a graph, with vertices representing fields and edges representing pathways between these fields, each having an associated length. Farmer John notes that for each distinct length, at most three pathways on his farm share this length. FJ would like to remove some of the pathways on his farm so that it becomes a tree -- that is, so that there is one unique route between any pair of fields. Moreover, Farmer John would like this to be a minimum spanning tree -- a tree having the smallest possible sum of edge lengths. Help Farmer John compute not only the sum of edge lengths in a minimum spanning tree derived from his farm graph, but also the number of different possible minimum spanning trees he can create.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_25","text":"Line 1: Two integers N and M (1 <= N <= 40,000; 1 <= M <= 100,000), representing the number of vertices and edges in the farm graph, respectively. Vertices are numbered as 1..N. Lines 2..M+1: Three integers a_i, b_i and n_i (1 <= a_i, b_i <= N; 1<= n_i <= 1,000,000) representing an edge from vertex a_i to b_i with length n_i. No edge length n_i will occur more than three times.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_26","text":"Line 1: Two integers representing the length of the minimal spanning tree and the number of minimal spanning trees (mod 1,000,000,007).","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_27","text":"4 5 1 2 1 3 4 1 1 3 2 1 4 2 2 3 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_28","text":"4 3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_29","text":"Picking both edges with length 1 and any edge with length 2 yields a minimum spanning tree of length 4.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_30","text":"\u6700\u5c0f\u751f\u6210\u6811\uff0c\u5206\u7c7b\u8ba8\u8bba\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_31","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; struct node { int from , to , val ; }; node a [ 100500 ] = { 0 }; bool cmp ( node a , node b ) { return a . val < b . val ; } int fa [ 100500 ] = { 0 }; int findfa ( int n ) { if ( n == fa [ n ]) return n ; return fa [ n ] = findfa ( fa [ n ]); } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) scanf ( \"%d%d%d\" , & a [ i ]. from , & a [ i ]. to , & a [ i ]. val ); for ( int i = 1 ; i <= n ; i ++ ) fa [ i ] = i ; sort ( a + 1 , a + m + 1 , cmp ); ll ans = 0 , sum = 1 ; for ( int i = 1 ; i <= m ;) { int cnt = 0 , num = 0 ; set < pair < int , int >> s ; int j ; for ( j = i ; a [ j ]. val == a [ i ]. val && j <= m ; j ++ ) { int fx = findfa ( a [ j ]. from ); int fy = findfa ( a [ j ]. to ); if ( fx > fy ) swap ( fx , fy ); if ( fx != fy ) { cnt ++ ; s . insert ({ fx , fy }); } } for (; i < j ; i ++ ) { int fx = findfa ( a [ i ]. from ); int fy = findfa ( a [ i ]. to ); if ( fx != fy ) { num ++ ; fa [ fx ] = fy ; ans += a [ i ]. val ; } } if ( num == 1 ) { sum = sum * cnt % mod ; } else if ( num == 2 ) { if ( cnt == 3 && s . size () == 2 ) sum = sum * 2 % mod ; else if ( cnt == 3 && s . size () == 3 ) sum = sum * 3 % mod ; } } cout << ans << ' ' << sum << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#5","text":"","title":"\u9898\u76ee5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_32","text":"GCD Game","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_33","text":"Alice and Bob are playing a game. They take turns to operate. There are n numbers, a1 , a2 , ... , an. Every time, the player plays in 3 steps. 1.Arbitrarily chooses one number ai. 2.Arbitrarily chooses another number x(1\u2264x<ai). 3.Replace the number ai with gcd(ai,x). Here, gcd(u,v) refers to the Greatest Common Divisor of u and v. When a player can not make a single move he/she loses the game. Alice moves the first and she asks you to tell her who will win the game if both player play optimally.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_34","text":"The first line contains a number T(1\u2264T\u2264100), the number of testcases. For each testcase, there are two lines. The first line contains one number n(1\u2264n\u2264 10^6 10^6 ). The second line contains n numbers a1 , a2 , ... , an(1\u2264ai\u2264 10^7 10^7 ). It is guaranteed that for all testcases, \u2211n\u2264 10^6 10^6 \u200b.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_35","text":"Line 1: Two integers representing the length of the minimal spanning tree and the number of minimal spanning trees (mod 1,000,000,007).","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_36","text":"2 1 1 1 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_37","text":"Bob Alice","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_38","text":"\u5c3c\u5c14\u535a\u5f08\u53d8\u5f62\uff0c\u6c42\u89e3\u8d28\u56e0\u6570\u7684\u4e2a\u6570\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_39","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; const ll maxn = 1e7 + 5 ; ll low_prime [ 10050000 ] = { 0 }; ll prime [ 700500 ] = { 0 }; ll cnt = 0 ; int main () { for ( ll i = 2 ; i <= maxn ; i ++ ) { if ( low_prime [ i ] == 0 ) { low_prime [ i ] = i ; prime [ ++ cnt ] = i ; } for ( ll j = 1 ; j <= cnt && prime [ j ] * i <= maxn ; j ++ ) { low_prime [ prime [ j ] * i ] = prime [ j ]; if ( i % prime [ j ] == 0 ) break ; } } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , flag = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { ll m , sum = 0 ; scanf ( \"%lld\" , & m ); while ( m > 1 ) { m /= low_prime [ m ]; sum ++ ; } flag ^= sum ; } if ( ! flag ) puts ( \"Bob\" ); else puts ( \"Alice\" ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u56db\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Reversible Cards \u9898\u76ee\u63cf\u8ff0 \u00b6 We have N cards numbered 1 to N. Each side of each card has a color represented by a positive integer. One side of Card i has a color ai, and the other side has a color bi. For each card, you can choose which side shows up. Find the maximum possible number of different colors showing up. Constraints 1\u2264N\u2264200000 1\u2264ai,bi\u2264400000 All numbers in input are integers. \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N a1 b1 a2 b2 : aN bN \u8f93\u51fa \u00b6 Print the answer. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 4 1 2 1 3 4 2 2 3 \u3010\u6837\u4f8b2\u3011 2 111 111 111 111 \u3010\u6837\u4f8b3\u3011 12 5 2 5 6 1 2 9 7 2 7 5 5 4 2 6 7 2 2 7 8 9 7 1 8 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 4 \u3010\u6837\u4f8b2\u3011 1 \u3010\u6837\u4f8b3\u3011 8 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca We can choose the sides with 1, 3, 4, 2 to have four colors. \u6837\u4f8b2\u89e3\u91ca They are painted with just one color. \u9898\u89e3 \u00b6 \u5e76\u67e5\u96c6\uff0c\u5efa\u7acb\u8fde\u901a\u5757\u3002\u5206\u4e24\u79cd\u60c5\u51b5\uff1a \u8fde\u901a\u5757\u65e0\u73af\uff0c\u4e3a\u4e00\u68f5\u6811\uff0c\u5219\u8be5\u8fde\u901a\u5757\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u5ea6\u4e3a\u70b9\u7684\u4e2a\u6570\u51cf1\uff0c\u4f8b\u59821-2\uff0c2-3\uff0c3-4\uff0c\u8fd9\u79cd\u60c5\u51b5\u7b54\u6848\u4e3a3 \u8fde\u901a\u5757\u6709\u73af\uff0c\u5219\u8be5\u8fde\u901a\u5757\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u5ea6\u4e3a\u70b9\u7684\u6570\u76ee\uff0c\u4f8b\u59821-2\uff0c2-3\uff0c3-1\uff0c\u8be5\u60c5\u51b5\u7b54\u6848\u4e3a4 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll fa [ 400500 ] = { 0 }; ll huan [ 400500 ] = { 0 }; ll sum [ 400500 ] = { 0 }; ll findfa ( ll n ) { if ( n == fa [ n ]) return n ; return fa [ n ] = findfa ( fa [ n ]); } int main () { ll n , s , e ; for ( ll i = 1 ; i <= 400000 ; i ++ ) fa [ i ] = i ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { ll x , y ; scanf ( \"%lld%lld\" , & x , & y ); ll fx = findfa ( x ); ll fy = findfa ( y ); if ( fx == fy ) huan [ fx ] = huan [ fy ] = 1 ; else fa [ fy ] = fx ; } for ( ll i = 1 ; i <= 400000 ; i ++ ) { findfa ( i ); huan [ fa [ i ]] |= huan [ i ]; sum [ fa [ i ]] ++ ; } ll ans = 0 ; for ( ll i = 1 ; i <= 400000 ; i ++ ) { if ( sum [ i ] != 0 ) { if ( huan [ i ]) ans += sum [ i ]; else ans += sum [ i ] -1 ; } } cout << ans << endl ; } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Second Large Rectangle \u9898\u76ee\u63cf\u8ff0 \u00b6 Given a N\u00d7M binary matrix. Please output the size of second large rectangle containing all \"1\". Containing all \"1\" means that the entries of the rectangle are all \"1\". A rectangle can be defined as four integers x1,y1,x2,y2 where 1\u2264x1\u2264x2\u2264N and 1\u2264y1\u2264y2\u2264M. Then, the rectangle is composed of all the cell (x, y) where x1\u2264x\u2264x2 and y1\u2264y\u2264y2. If all of the cell in the rectangle is \"1\", this is a valid rectangle. Please find out the size of the second largest rectangle, two rectangles are different if exists a cell belonged to one of them but not belonged to the other. \u8f93\u5165 \u00b6 The first line of input contains two space-separated integers N and M. Following N lines each contains M characters cij. 1\u2264N,M\u22641000 N\u00d7M\u22652 cij\u2208\"01\" \u8f93\u51fa \u00b6 Output one line containing an integer representing the answer. If there are less than 2 rectangles containning all \"1\", output \"0\". \u6837\u4f8b\u8f93\u5165 \u00b6 1 2 01 \u6837\u4f8b\u8f93\u51fa \u00b6 0 \u9898\u89e3 \u00b6 \u6784\u9020\u5217\u65b9\u5411\u7684\u524d\u7f00\u548c\uff0c\u540e\u7528\u5355\u8c03\u6808\u6c42\u51fa\u533a\u95f4\u6700\u5c0f\u503c\u548c\u533a\u95f4\u957f\u5ea6\u4e58\u79ef\u7684\u7b2c\u4e8c\u5927\u503c\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int sum [ 2050 ][ 2050 ] = { 0 }; int a [ 2050 ][ 2050 ] = { 0 }; struct node { ll pos , val ; }; node s [ 100500 ] = { 0 }; int main () { int n , m ; scanf ( \"%d %d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) scanf ( \"%1d\" , & a [ i ][ j ]); for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ][ j ]) sum [ i ][ j ] = sum [ i - 1 ][ j ] + a [ i ][ j ]; else sum [ i ][ j ] = 0 ; } ll ans = 0 ; ll max1 = 0 , max2 = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll top = 0 ; for ( ll j = 1 ; j <= m + 1 ; j ++ ) { if ( top == 0 ) { s [ ++ top ] = { j , sum [ i ][ j ]}; } else { while ( s [ top ]. val > sum [ i ][ j ]) { ll tmp = ( ll )( j - s [ top - 1 ]. pos - 1 ) * ( ll ) s [ top ]. val ; ll tmp1 = ( ll )( j - s [ top - 1 ]. pos - 2 ) * ( ll ) s [ top ]. val ; ll tmp2 = ( ll )( j - s [ top - 1 ]. pos - 1 ) * ( ll )( s [ top ]. val - 1 ); top -- ; if ( tmp > max1 ) swap ( max1 , tmp ); if ( tmp > max2 ) swap ( max2 , tmp ); if ( tmp1 > max1 ) swap ( max1 , tmp1 ); if ( tmp1 > max2 ) swap ( max2 , tmp1 ); if ( tmp2 > max1 ) swap ( max1 , tmp2 ); if ( tmp2 > max2 ) swap ( max2 , tmp2 ); } s [ ++ top ] = { j , sum [ i ][ j ]}; } } } cout << max2 << endl ; } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Simple Math 2 \u9898\u76ee\u63cf\u8ff0 \u00b6 Given positive integers N and M, find the remainder when \u230a10^N/M\u230b \u230a10^N/M\u230b \u200b\u200b is divided by M. What is \u230ax\u230b?\u230ax\u230b denotes the greatest integer not exceeding x. For example: \u230a2.5\u230b=2 \u230a3\u230b=3 \u230a9.9999999\u230b=9 \u230a100/3\u230b=\u230a33.33...\u230b=33 Constraints 1\u2264N\u2264 10^{18} 10^{18} 1\u2264M\u226410000 \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N a1 b1 a2 b2 : aN bN \u8f93\u51fa \u00b6 Print the answer. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 1 2 \u3010\u6837\u4f8b2\u3011 2 7 \u3010\u6837\u4f8b3\u3011 1000000000000000000 9997 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 0 \u3010\u6837\u4f8b3\u3011 9015 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca\uff1a We have \u230a10^\u00bd\u230b=5, so we should print the remainder when 5 is divided by 2, that is, 1. \u9898\u89e3 \u00b6 \u230a\\frac{10^N}{M}\u230b \\% m =\u230a\\frac{10^N}{M}-k*m\u230b \\% m =\u230a\\frac{10^N-k*m^2}{M}\u230b\\% m=\u230a\\frac{10^N \\% m^2}{M}\u230b\\% m \u230a\\frac{10^N}{M}\u230b \\% m =\u230a\\frac{10^N}{M}-k*m\u230b \\% m =\u230a\\frac{10^N-k*m^2}{M}\u230b\\% m=\u230a\\frac{10^N \\% m^2}{M}\u230b\\% m \u200b\u200b\u200b\u200b\u200b\u200b \u6240\u4ee5\uff0c\u53ea\u9700\u8981\u5229\u7528\u5feb\u901f\u5e42\u7b97\u6cd5\u8ba1\u7b97\u51fa $ 10 ^N \\% m^2$\u200b\u200b \u5373\u53ef \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; map < ll , ll > mp ; vector < ll > v ; int main () { ll n , m ; cin >> n >> m ; ll mod = m * m , ans1 = 1 , ans2 = 10 ; while ( n != 0 ) { if ( n % 2 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; n /= 2 ; } ll ans = ( ans1 / m + m ) % m ; cout << ans << endl ; }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u56db\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u56db\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_2","text":"Reversible Cards","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_3","text":"We have N cards numbered 1 to N. Each side of each card has a color represented by a positive integer. One side of Card i has a color ai, and the other side has a color bi. For each card, you can choose which side shows up. Find the maximum possible number of different colors showing up. Constraints 1\u2264N\u2264200000 1\u2264ai,bi\u2264400000 All numbers in input are integers.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_4","text":"Input is given from Standard Input in the following format: N a1 b1 a2 b2 : aN bN","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_5","text":"Print the answer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_6","text":"\u3010\u6837\u4f8b1\u3011 4 1 2 1 3 4 2 2 3 \u3010\u6837\u4f8b2\u3011 2 111 111 111 111 \u3010\u6837\u4f8b3\u3011 12 5 2 5 6 1 2 9 7 2 7 5 5 4 2 6 7 2 2 7 8 9 7 1 8","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_7","text":"\u3010\u6837\u4f8b1\u3011 4 \u3010\u6837\u4f8b2\u3011 1 \u3010\u6837\u4f8b3\u3011 8","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_8","text":"\u6837\u4f8b1\u89e3\u91ca We can choose the sides with 1, 3, 4, 2 to have four colors. \u6837\u4f8b2\u89e3\u91ca They are painted with just one color.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_9","text":"\u5e76\u67e5\u96c6\uff0c\u5efa\u7acb\u8fde\u901a\u5757\u3002\u5206\u4e24\u79cd\u60c5\u51b5\uff1a \u8fde\u901a\u5757\u65e0\u73af\uff0c\u4e3a\u4e00\u68f5\u6811\uff0c\u5219\u8be5\u8fde\u901a\u5757\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u5ea6\u4e3a\u70b9\u7684\u4e2a\u6570\u51cf1\uff0c\u4f8b\u59821-2\uff0c2-3\uff0c3-4\uff0c\u8fd9\u79cd\u60c5\u51b5\u7b54\u6848\u4e3a3 \u8fde\u901a\u5757\u6709\u73af\uff0c\u5219\u8be5\u8fde\u901a\u5757\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u5ea6\u4e3a\u70b9\u7684\u6570\u76ee\uff0c\u4f8b\u59821-2\uff0c2-3\uff0c3-1\uff0c\u8be5\u60c5\u51b5\u7b54\u6848\u4e3a4","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_10","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll fa [ 400500 ] = { 0 }; ll huan [ 400500 ] = { 0 }; ll sum [ 400500 ] = { 0 }; ll findfa ( ll n ) { if ( n == fa [ n ]) return n ; return fa [ n ] = findfa ( fa [ n ]); } int main () { ll n , s , e ; for ( ll i = 1 ; i <= 400000 ; i ++ ) fa [ i ] = i ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { ll x , y ; scanf ( \"%lld%lld\" , & x , & y ); ll fx = findfa ( x ); ll fy = findfa ( y ); if ( fx == fy ) huan [ fx ] = huan [ fy ] = 1 ; else fa [ fy ] = fx ; } for ( ll i = 1 ; i <= 400000 ; i ++ ) { findfa ( i ); huan [ fa [ i ]] |= huan [ i ]; sum [ fa [ i ]] ++ ; } ll ans = 0 ; for ( ll i = 1 ; i <= 400000 ; i ++ ) { if ( sum [ i ] != 0 ) { if ( huan [ i ]) ans += sum [ i ]; else ans += sum [ i ] -1 ; } } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_11","text":"Second Large Rectangle","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_12","text":"Given a N\u00d7M binary matrix. Please output the size of second large rectangle containing all \"1\". Containing all \"1\" means that the entries of the rectangle are all \"1\". A rectangle can be defined as four integers x1,y1,x2,y2 where 1\u2264x1\u2264x2\u2264N and 1\u2264y1\u2264y2\u2264M. Then, the rectangle is composed of all the cell (x, y) where x1\u2264x\u2264x2 and y1\u2264y\u2264y2. If all of the cell in the rectangle is \"1\", this is a valid rectangle. Please find out the size of the second largest rectangle, two rectangles are different if exists a cell belonged to one of them but not belonged to the other.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_13","text":"The first line of input contains two space-separated integers N and M. Following N lines each contains M characters cij. 1\u2264N,M\u22641000 N\u00d7M\u22652 cij\u2208\"01\"","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_14","text":"Output one line containing an integer representing the answer. If there are less than 2 rectangles containning all \"1\", output \"0\".","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_15","text":"1 2 01","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_16","text":"0","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_17","text":"\u6784\u9020\u5217\u65b9\u5411\u7684\u524d\u7f00\u548c\uff0c\u540e\u7528\u5355\u8c03\u6808\u6c42\u51fa\u533a\u95f4\u6700\u5c0f\u503c\u548c\u533a\u95f4\u957f\u5ea6\u4e58\u79ef\u7684\u7b2c\u4e8c\u5927\u503c\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_18","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int sum [ 2050 ][ 2050 ] = { 0 }; int a [ 2050 ][ 2050 ] = { 0 }; struct node { ll pos , val ; }; node s [ 100500 ] = { 0 }; int main () { int n , m ; scanf ( \"%d %d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) scanf ( \"%1d\" , & a [ i ][ j ]); for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ][ j ]) sum [ i ][ j ] = sum [ i - 1 ][ j ] + a [ i ][ j ]; else sum [ i ][ j ] = 0 ; } ll ans = 0 ; ll max1 = 0 , max2 = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll top = 0 ; for ( ll j = 1 ; j <= m + 1 ; j ++ ) { if ( top == 0 ) { s [ ++ top ] = { j , sum [ i ][ j ]}; } else { while ( s [ top ]. val > sum [ i ][ j ]) { ll tmp = ( ll )( j - s [ top - 1 ]. pos - 1 ) * ( ll ) s [ top ]. val ; ll tmp1 = ( ll )( j - s [ top - 1 ]. pos - 2 ) * ( ll ) s [ top ]. val ; ll tmp2 = ( ll )( j - s [ top - 1 ]. pos - 1 ) * ( ll )( s [ top ]. val - 1 ); top -- ; if ( tmp > max1 ) swap ( max1 , tmp ); if ( tmp > max2 ) swap ( max2 , tmp ); if ( tmp1 > max1 ) swap ( max1 , tmp1 ); if ( tmp1 > max2 ) swap ( max2 , tmp1 ); if ( tmp2 > max1 ) swap ( max1 , tmp2 ); if ( tmp2 > max2 ) swap ( max2 , tmp2 ); } s [ ++ top ] = { j , sum [ i ][ j ]}; } } } cout << max2 << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_19","text":"Simple Math 2","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_20","text":"Given positive integers N and M, find the remainder when \u230a10^N/M\u230b \u230a10^N/M\u230b \u200b\u200b is divided by M. What is \u230ax\u230b?\u230ax\u230b denotes the greatest integer not exceeding x. For example: \u230a2.5\u230b=2 \u230a3\u230b=3 \u230a9.9999999\u230b=9 \u230a100/3\u230b=\u230a33.33...\u230b=33 Constraints 1\u2264N\u2264 10^{18} 10^{18} 1\u2264M\u226410000","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_21","text":"Input is given from Standard Input in the following format: N a1 b1 a2 b2 : aN bN","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_22","text":"Print the answer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_23","text":"\u3010\u6837\u4f8b1\u3011 1 2 \u3010\u6837\u4f8b2\u3011 2 7 \u3010\u6837\u4f8b3\u3011 1000000000000000000 9997","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_24","text":"\u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 0 \u3010\u6837\u4f8b3\u3011 9015","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_25","text":"\u6837\u4f8b1\u89e3\u91ca\uff1a We have \u230a10^\u00bd\u230b=5, so we should print the remainder when 5 is divided by 2, that is, 1.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_26","text":"\u230a\\frac{10^N}{M}\u230b \\% m =\u230a\\frac{10^N}{M}-k*m\u230b \\% m =\u230a\\frac{10^N-k*m^2}{M}\u230b\\% m=\u230a\\frac{10^N \\% m^2}{M}\u230b\\% m \u230a\\frac{10^N}{M}\u230b \\% m =\u230a\\frac{10^N}{M}-k*m\u230b \\% m =\u230a\\frac{10^N-k*m^2}{M}\u230b\\% m=\u230a\\frac{10^N \\% m^2}{M}\u230b\\% m \u200b\u200b\u200b\u200b\u200b\u200b \u6240\u4ee5\uff0c\u53ea\u9700\u8981\u5229\u7528\u5feb\u901f\u5e42\u7b97\u6cd5\u8ba1\u7b97\u51fa $ 10 ^N \\% m^2$\u200b\u200b \u5373\u53ef","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_27","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; map < ll , ll > mp ; vector < ll > v ; int main () { ll n , m ; cin >> n >> m ; ll mod = m * m , ans1 = 1 , ans2 = 10 ; while ( n != 0 ) { if ( n % 2 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; n /= 2 ; } ll ans = ( ans1 / m + m ) % m ; cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u9898\u89e3\u7cfb\u5217\uff08\u4e00\uff09 \u00b6 \u9898\u76ee1 \u00b6 Alice and Bob \u9898\u89e3 \u00b6 \u6253\u8868\u66b4\u529b\u9898\u76ee\uff08\u6bd4\u8d5b\u65f6\u9ad8\u4f30\u4e86\u65f6\u95f4\u590d\u6742\u5ea6\uff0cQAQ\uff09 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; bool a [ 5050 ][ 5050 ] = { 0 }; ///\u7528bool\uff0cint\u4f1a\u8d85\u65f6 int main () { for ( int i = 0 ; i <= 5000 ; i ++ ) for ( int j = 0 ; j <= 5000 ; j ++ ) { if ( ! a [ i ][ j ]) { for ( int k = 1 ; i + k <= 5000 ; k ++ ) for ( int x = 0 ; x * k + j <= 5000 ; x ++ ) a [ i + k ][ x * k + j ] = 1 ; for ( int k = 1 ; j + k <= 5000 ; k ++ ) for ( int x = 0 ; x * k + i <= 5000 ; x ++ ) a [ i + x * k ][ k + j ] = 1 ; } } int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); if ( a [ n ][ m ]) puts ( \"Alice\" ); else puts ( \"Bob\" ); } } \u9898\u76ee2 \u00b6 Hash Function \u9898\u89e3 \u00b6 \u4e24\u4e2afor\u5faa\u73af\u904d\u5386\uff0c\u5bfb\u627e\u6700\u4f18\u7b54\u6848\uff0c\u5982\u679c\u7b54\u6848\u4e0d\u7b26\u5408\uff0c\u5219\u9000\u56de\u8c03\u6574\u7b54\u6848\u3002 \u53e6\u8be5\u9898\u76ee\u53ef\u4ee5\u7528NTT\u6765\u5b8c\u6210\uff0c\u53ef\u53c2\u8003\u535a\u5ba2\uff1a https://blog.nowcoder.net/n/9e67ea84ea1f4b8fa1046762f6e41210 https://blog.nowcoder.net/n/97fe1e13d21141349751df63315eaa97 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int a [ 500500 ] = { 0 }; int num [ 500500 ] = { 0 }; int main () { std :: ios :: sync_with_stdio ( 0 ); cin . tie ( 0 ); int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ], num [ a [ i ]] = 1 ; sort ( a + 1 , a + n + 1 ); int idx = 1 , jdx = 1 , ans = n , ndx = 1 ; while ( idx <= n ) { int jdx = a [ idx ] % ans ; int flag = 1 ; for (; jdx <= a [ n ]; jdx += ans ) { if ( num [ jdx ]) { if ( flag == 2 ) ///\u6709\u4e24\u4e2a\u6570\u540c\u4f59\uff0c\u8df3\u51fa\u5faa\u73af { flag = 0 ; break ; } flag ++ ; } } if ( flag == 0 ) idx = ndx , ans ++ ; ///\u56de\u9000 if ( a [ idx ] <= ans ) ndx = idx ; ///\u8bb0\u5f55\u4e0a\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7b54\u6848\uff08\u7531\u4e8e\u5df2\u6392\u5e8f\u4e14\u5f53\u524d\u503c\u5c0f\u4e8e\u53d6\u6a21\u7684\u503c\uff0c\u6240\u4ee5\u524d\u9762\u7684\u80af\u5b9a\u7b26\u5408\u3002 idx ++ ; } cout << ans << endl ; }","title":"\u6691\u5047\u96c6\u8bad\u9898\u89e3\u7cfb\u5217\uff08\u4e00\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u9898\u89e3\u7cfb\u5217\uff08\u4e00\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/#1","text":"Alice and Bob","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/#_2","text":"\u6253\u8868\u66b4\u529b\u9898\u76ee\uff08\u6bd4\u8d5b\u65f6\u9ad8\u4f30\u4e86\u65f6\u95f4\u590d\u6742\u5ea6\uff0cQAQ\uff09","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/#_3","text":"#include <bits/stdc++.h> using namespace std ; bool a [ 5050 ][ 5050 ] = { 0 }; ///\u7528bool\uff0cint\u4f1a\u8d85\u65f6 int main () { for ( int i = 0 ; i <= 5000 ; i ++ ) for ( int j = 0 ; j <= 5000 ; j ++ ) { if ( ! a [ i ][ j ]) { for ( int k = 1 ; i + k <= 5000 ; k ++ ) for ( int x = 0 ; x * k + j <= 5000 ; x ++ ) a [ i + k ][ x * k + j ] = 1 ; for ( int k = 1 ; j + k <= 5000 ; k ++ ) for ( int x = 0 ; x * k + i <= 5000 ; x ++ ) a [ i + x * k ][ k + j ] = 1 ; } } int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); if ( a [ n ][ m ]) puts ( \"Alice\" ); else puts ( \"Bob\" ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/#2","text":"Hash Function","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/#_4","text":"\u4e24\u4e2afor\u5faa\u73af\u904d\u5386\uff0c\u5bfb\u627e\u6700\u4f18\u7b54\u6848\uff0c\u5982\u679c\u7b54\u6848\u4e0d\u7b26\u5408\uff0c\u5219\u9000\u56de\u8c03\u6574\u7b54\u6848\u3002 \u53e6\u8be5\u9898\u76ee\u53ef\u4ee5\u7528NTT\u6765\u5b8c\u6210\uff0c\u53ef\u53c2\u8003\u535a\u5ba2\uff1a https://blog.nowcoder.net/n/9e67ea84ea1f4b8fa1046762f6e41210 https://blog.nowcoder.net/n/97fe1e13d21141349751df63315eaa97","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/#_5","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int a [ 500500 ] = { 0 }; int num [ 500500 ] = { 0 }; int main () { std :: ios :: sync_with_stdio ( 0 ); cin . tie ( 0 ); int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ], num [ a [ i ]] = 1 ; sort ( a + 1 , a + n + 1 ); int idx = 1 , jdx = 1 , ans = n , ndx = 1 ; while ( idx <= n ) { int jdx = a [ idx ] % ans ; int flag = 1 ; for (; jdx <= a [ n ]; jdx += ans ) { if ( num [ jdx ]) { if ( flag == 2 ) ///\u6709\u4e24\u4e2a\u6570\u540c\u4f59\uff0c\u8df3\u51fa\u5faa\u73af { flag = 0 ; break ; } flag ++ ; } } if ( flag == 0 ) idx = ndx , ans ++ ; ///\u56de\u9000 if ( a [ idx ] <= ans ) ndx = idx ; ///\u8bb0\u5f55\u4e0a\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7b54\u6848\uff08\u7531\u4e8e\u5df2\u6392\u5e8f\u4e14\u5f53\u524d\u503c\u5c0f\u4e8e\u53d6\u6a21\u7684\u503c\uff0c\u6240\u4ee5\u524d\u9762\u7684\u80af\u5b9a\u7b26\u5408\u3002 idx ++ ; } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/","text":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e00\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u95ee\u9898 A: Matrix Equation \u9898\u76ee\u63cf\u8ff0 \u00b6 We call a matrix \u201c01 Square\u201d if and only if it\u2019s a N \u00d7 N matrix and its elements are all 0 or 1. For two 01 Squares X,Y , we de\ufb01ne two operators X \u00d7 Y and X Y . The value of them are also 01 Square matrices and calculated below(we use Z to abbreviate X \u00d7 Y and D to abbreviate X Y ): Now MianKing has two 01 Squares A, B, he wants to solve the matrix equation below: A \u00d7 C = B C You need to help MainKing solve this problem by calculating how many 01 Squares C satisfy this equation. The answer may be very large, so you only need to output the answer module 998244353. \u8f93\u5165 \u00b6 The first line has one integer N Then there are N lines and each line has N integers, the j-th integer of the i-th line denotes A_{i,j} A_{i,j} Then there are N lines and each line has N integers, the j-th integer of the i-th line denotes B_{i,j} B_{i,j} 1\u2264N\u2264200, A_{i,j} A_{i,j} ,$ B_{i,j}$\u2208{ 0, 1 } \u8f93\u51fa \u00b6 Output the answer module 998244353. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 2 0 1 1 1 1 0 0 1 \u3010\u6837\u4f8b2\u3011 3 1 0 0 0 1 0 0 0 1 1 1 1 1 1 1 1 1 1 \u3010\u6837\u4f8b3\u3011 4 0 1 0 1 0 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 0 1 1 1 1 0 0 1 1 1 1 0 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 2 \u3010\u6837\u4f8b2\u3011 512 \u3010\u6837\u4f8b3\u3011 8 \u9898\u89e3 \u00b6 \u9ad8\u65af\u6d88\u5143\u6cd5\u6c42\u89e3\u77e9\u9635\u7684\u79e9\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u5217\u5355\u72ec\u8003\u8651\u53ef\u4ee5\u5c06\u9898\u76ee\u8f6c\u6362\u4e3a\u4ee5\u4e0b\u65b9\u7a0b\uff1a \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u65b9\u7a0b\u7ec4\u7cfb\u6570\u77e9\u9635\uff0c\u5982\u679c\u79e9\u4e3ak\uff0c\u5219 C_k,C_{K+1} .... C_n C_k,C_{K+1} .... C_n \uff0c\u53ef\u4ee5\u4efb\u610f\u9009\u62e90\u548c1\uff0c\u5219\u5bf9\u5e94\u7b54\u6848\u4e3a 2^{n-k} 2^{n-k} \uff0c\u6700\u540e\u5c06\u6bcf\u4e00\u5217\u7684\u7b54\u6848\u4e58\u8d77\u6765\u5373\u4e3a\u7b54\u6848\u3002 \u53c2\u8003\u4e8e\uff1a https://blog.csdn.net/hddddh/article/details/111828336 https://blog.csdn.net/weixin_45697774/article/details/113198407 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; bitset < 330 > a [ 330 ]; int A [ 330 ][ 330 ] = { 0 }; int C [ 330 ][ 330 ] = { 0 }; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } ll guess ( ll n ) { ll maxx = 0 , row = 0 ; for ( ll col = 0 ; col < n ; col ++ ) { for ( maxx = row ; maxx < n ; maxx ++ ) if ( a [ maxx ][ col ] != 0 ) break ; if ( maxx == n ) continue ; if ( a [ maxx ][ col ] == 0 ) continue ; swap ( a [ maxx ], a [ row ]); for ( ll i = row + 1 ; i < n ; i ++ ) { if ( a [ i ][ col ] != 0 ) a [ i ] ^= a [ row ]; } row ++ ; } return ksm ( 2 , n - row ); } int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) scanf ( \"%d\" , & A [ i ][ j ]); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) scanf ( \"%d\" , & C [ i ][ j ]); ll ans = 1 ; for ( int col = 0 ; col < n ; col ++ ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) a [ i ][ j ] = A [ i ][ j ]; for ( int i = 0 ; i < n ; i ++ ) a [ i ][ i ] = A [ i ][ i ] ^ C [ i ][ col ]; ans = ( ans * guess ( n )) % mod ; } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e00\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_1","text":"","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e00\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_2","text":"\u95ee\u9898 A: Matrix Equation","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_3","text":"We call a matrix \u201c01 Square\u201d if and only if it\u2019s a N \u00d7 N matrix and its elements are all 0 or 1. For two 01 Squares X,Y , we de\ufb01ne two operators X \u00d7 Y and X Y . The value of them are also 01 Square matrices and calculated below(we use Z to abbreviate X \u00d7 Y and D to abbreviate X Y ): Now MianKing has two 01 Squares A, B, he wants to solve the matrix equation below: A \u00d7 C = B C You need to help MainKing solve this problem by calculating how many 01 Squares C satisfy this equation. The answer may be very large, so you only need to output the answer module 998244353.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_4","text":"The first line has one integer N Then there are N lines and each line has N integers, the j-th integer of the i-th line denotes A_{i,j} A_{i,j} Then there are N lines and each line has N integers, the j-th integer of the i-th line denotes B_{i,j} B_{i,j} 1\u2264N\u2264200, A_{i,j} A_{i,j} ,$ B_{i,j}$\u2208{ 0, 1 }","title":"\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_5","text":"Output the answer module 998244353.","title":"\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_6","text":"\u3010\u6837\u4f8b1\u3011 2 0 1 1 1 1 0 0 1 \u3010\u6837\u4f8b2\u3011 3 1 0 0 0 1 0 0 0 1 1 1 1 1 1 1 1 1 1 \u3010\u6837\u4f8b3\u3011 4 0 1 0 1 0 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 0 1 1 1 1 0 0 1 1 1 1 0","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_7","text":"\u3010\u6837\u4f8b1\u3011 2 \u3010\u6837\u4f8b2\u3011 512 \u3010\u6837\u4f8b3\u3011 8","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_8","text":"\u9ad8\u65af\u6d88\u5143\u6cd5\u6c42\u89e3\u77e9\u9635\u7684\u79e9\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u5217\u5355\u72ec\u8003\u8651\u53ef\u4ee5\u5c06\u9898\u76ee\u8f6c\u6362\u4e3a\u4ee5\u4e0b\u65b9\u7a0b\uff1a \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u65b9\u7a0b\u7ec4\u7cfb\u6570\u77e9\u9635\uff0c\u5982\u679c\u79e9\u4e3ak\uff0c\u5219 C_k,C_{K+1} .... C_n C_k,C_{K+1} .... C_n \uff0c\u53ef\u4ee5\u4efb\u610f\u9009\u62e90\u548c1\uff0c\u5219\u5bf9\u5e94\u7b54\u6848\u4e3a 2^{n-k} 2^{n-k} \uff0c\u6700\u540e\u5c06\u6bcf\u4e00\u5217\u7684\u7b54\u6848\u4e58\u8d77\u6765\u5373\u4e3a\u7b54\u6848\u3002 \u53c2\u8003\u4e8e\uff1a https://blog.csdn.net/hddddh/article/details/111828336 https://blog.csdn.net/weixin_45697774/article/details/113198407","title":"\u9898\u89e3"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_9","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; bitset < 330 > a [ 330 ]; int A [ 330 ][ 330 ] = { 0 }; int C [ 330 ][ 330 ] = { 0 }; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } ll guess ( ll n ) { ll maxx = 0 , row = 0 ; for ( ll col = 0 ; col < n ; col ++ ) { for ( maxx = row ; maxx < n ; maxx ++ ) if ( a [ maxx ][ col ] != 0 ) break ; if ( maxx == n ) continue ; if ( a [ maxx ][ col ] == 0 ) continue ; swap ( a [ maxx ], a [ row ]); for ( ll i = row + 1 ; i < n ; i ++ ) { if ( a [ i ][ col ] != 0 ) a [ i ] ^= a [ row ]; } row ++ ; } return ksm ( 2 , n - row ); } int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) scanf ( \"%d\" , & A [ i ][ j ]); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) scanf ( \"%d\" , & C [ i ][ j ]); ll ans = 1 ; for ( int col = 0 ; col < n ; col ++ ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) a [ i ][ j ] = A [ i ][ j ]; for ( int i = 0 ; i < n ; i ++ ) a [ i ][ i ] = A [ i ][ i ] ^ C [ i ][ col ]; ans = ( ans * guess ( n )) % mod ; } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/","text":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e09\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u667a\u4e43\u9171\u7684\u5b50\u96c6\u4e0e\u8d85\u96c6 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u6837\u4f8b\u8f93\u5165 \u00b6 2 2 2 1 3 1 2 2 2 3 2 \u6837\u4f8b\u8f93\u51fa \u00b6 15 168 \u9898\u89e3 \u00b6 \u628a N \u4e2a\u7269\u54c1\u7406\u89e3\u4e3a\u5411\u91cf\uff0c\u5148\u60f3\u4e8c\u7ef4\u7684\u60c5\u51b5 F[A][B] = v[A][B] F[A][B] += F[0][B] + F[A][0] \u63a8\u5e7f\u5230 N \u7ef4\uff1a F[A][B][C][D][E]... = v[A][B][C][D][E]... F[A][B][C][D][E]... += v[A][0][0][0][0]... + ... \u5199\u6210\u5bb9\u65a5\uff0c\u5728\u7ef4\u5ea6\u4e0a\u662f\u4e0d\u597d\u6269\u5c55\u7684\u3002\u800c\u5199\u6210\u7a7a\u95f4\u5411\u91cf\u7684\u7406\u89e3\uff0c\u662f\u5f88\u597d\u6269\u5c55\u7684 \u52a0\u4e0a\u4e8c\u8fdb\u5236\u4f4d\u8fd0\u7b97 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.nowcoder.net/n/fba9bdd58cda4937a10bbd293bd3a7ec https://blog.csdn.net/eternity19/article/details/119735293 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 50 ] = { 0 }; ll ans [ 1050000 ] = { 0 }; ll sum1 [ 1050000 ] = { 0 }; ll sum2 [ 1050000 ] = { 0 }; int main () { // freopen(\"in.txt\", \"r\", stdin); ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 0 ; i < n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); for ( ll i = 0 ; i < ( 1 << n ); i ++ ) { for ( ll j = 0 ; j < n ; j ++ ) if (( i >> j ) & 1 ) ans [ i ] ^= a [ j ]; sum1 [ i ] = ans [ i ]; sum2 [ i ] = ans [ i ]; } for ( ll j = 0 ; j < n ; j ++ ) \\\\\u4f9d\u6b21\u8003\u8651\u653e\u7f6e\u6bcf\u4e00\u4e2a\u7269\u54c1 { for ( ll i = 0 ; i < ( 1 << n ); i ++ ) { if (( i >> j ) & 1 ) sum1 [ i ] += sum1 [ i ^ ( 1 << j )]; else sum2 [ i ] += sum2 [ i ^ ( 1 << j )]; } } for ( ll i = 1 ; i <= m ; i ++ ) { ll k , m , p = 0 ; scanf ( \"%lld\" , & k ); for ( ll j = 1 ; j <= k ; j ++ ) { scanf ( \"%lld\" , & m ); m -- ; p += ( 1 << m ); } printf ( \"%lld %lld \\n \" , sum1 [ p ], sum2 [ p ]); } return 0 ; }","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e09\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#_1","text":"","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e09\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#_2","text":"\u667a\u4e43\u9171\u7684\u5b50\u96c6\u4e0e\u8d85\u96c6","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#_3","text":"","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#_4","text":"2 2 2 1 3 1 2 2 2 3 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#_5","text":"15 168","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#_6","text":"\u628a N \u4e2a\u7269\u54c1\u7406\u89e3\u4e3a\u5411\u91cf\uff0c\u5148\u60f3\u4e8c\u7ef4\u7684\u60c5\u51b5 F[A][B] = v[A][B] F[A][B] += F[0][B] + F[A][0] \u63a8\u5e7f\u5230 N \u7ef4\uff1a F[A][B][C][D][E]... = v[A][B][C][D][E]... F[A][B][C][D][E]... += v[A][0][0][0][0]... + ... \u5199\u6210\u5bb9\u65a5\uff0c\u5728\u7ef4\u5ea6\u4e0a\u662f\u4e0d\u597d\u6269\u5c55\u7684\u3002\u800c\u5199\u6210\u7a7a\u95f4\u5411\u91cf\u7684\u7406\u89e3\uff0c\u662f\u5f88\u597d\u6269\u5c55\u7684 \u52a0\u4e0a\u4e8c\u8fdb\u5236\u4f4d\u8fd0\u7b97 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.nowcoder.net/n/fba9bdd58cda4937a10bbd293bd3a7ec https://blog.csdn.net/eternity19/article/details/119735293","title":"\u9898\u89e3"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#_7","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 50 ] = { 0 }; ll ans [ 1050000 ] = { 0 }; ll sum1 [ 1050000 ] = { 0 }; ll sum2 [ 1050000 ] = { 0 }; int main () { // freopen(\"in.txt\", \"r\", stdin); ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 0 ; i < n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); for ( ll i = 0 ; i < ( 1 << n ); i ++ ) { for ( ll j = 0 ; j < n ; j ++ ) if (( i >> j ) & 1 ) ans [ i ] ^= a [ j ]; sum1 [ i ] = ans [ i ]; sum2 [ i ] = ans [ i ]; } for ( ll j = 0 ; j < n ; j ++ ) \\\\\u4f9d\u6b21\u8003\u8651\u653e\u7f6e\u6bcf\u4e00\u4e2a\u7269\u54c1 { for ( ll i = 0 ; i < ( 1 << n ); i ++ ) { if (( i >> j ) & 1 ) sum1 [ i ] += sum1 [ i ^ ( 1 << j )]; else sum2 [ i ] += sum2 [ i ^ ( 1 << j )]; } } for ( ll i = 1 ; i <= m ; i ++ ) { ll k , m , p = 0 ; scanf ( \"%lld\" , & k ); for ( ll j = 1 ; j <= k ; j ++ ) { scanf ( \"%lld\" , & m ); m -- ; p += ( 1 << m ); } printf ( \"%lld %lld \\n \" , sum1 [ p ], sum2 [ p ]); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/","text":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e8c\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u95ee\u9898 A: Matrix Equation \u9898\u76ee\u63cf\u8ff0 \u00b6 You are given an integer n. Please output the answer of modulo 998244353. n is represented in the form of factorization. \u03c6(n) is Euler\u2019s totient function, and it is defi ned more formally as the number of integers k in the interval 1\u2264k\u2264n for which the greatest common divisor gcd(n,k) is equal to 1. For example, the totatives of n = 9 are the six numbers 1, 2, 4, 5, 7 and 8. They are all co-prime to 9, but the other three numbers in this interval, 3, 6, and 9 are not, because gcd(9,3) = gcd(9,6) = 3 and gcd(9,9) = 9. Therefore, \u03c6(9) = 6. As another example, \u03c6(1) = 1 since for n = 1 the only integer in the interval from 1 to n is 1 itself, and gcd(1,1) = 1. And there are several formulas for computing \u03c6(n), for example, Euler\u2019s product formula states like: where the product is all the distinct prime numbers (p in the formula) dividing n. \u8f93\u5165 \u00b6 The fi rst line contains an integer T (1\u2264T\u226420) representing the number of test cases. For each test case, the fi rst line contains an integer m\uffff(1\u2264m\u226420) is the number of prime factors. The following m lines each contains two integers pi and qi (2\u2264pi\u2264108 , 1\u2264qi\u2264108 ) describing that n contains the factor piqi , in other words, . It is guaranteed that all pi are prime numbers and diff erent from each other. \u8f93\u51fa \u00b6 For each test case, print the the answer modulo 998244353 in one line. \u6837\u4f8b\u8f93\u5165 \u00b6 2 2 2 1 3 1 2 2 2 3 2 \u6837\u4f8b\u8f93\u51fa \u00b6 15 168 \u63d0\u793a \u00b6 For first test case, n = 21*31= 6, and the answer is (\u03c6(1)*n/1+\u03c6(2)*n/2+\u03c6(3)*n/3+\u03c6(6)*n/6) mod 998244353 = (6 + 3 + 4 + 2) mod 998244353 = 15. \u9898\u89e3 \u00b6 \u9898\u76ee\u8981\u6c42\u6c42\u89e3 F(n)=\\sum_{d|n} \\varphi(d)*\\frac{n}{d} F(n)=\\sum_{d|n} \\varphi(d)*\\frac{n}{d} \uff0c\u7531\u4e8e\u6b27\u62c9\u51fd\u6570\u548c \\frac{n}{d} \\frac{n}{d} \u5747\u4e3a\u79ef\u6027\u51fd\u6570\uff0c\u5219\u6709 F(m*n)=F(m)*F(n) F(m*n)=F(m)*F(n) \u5373\u4e3a F( \\prod p_i^{q_i})=\\prod F(p_i^{q_i}) F( \\prod p_i^{q_i})=\\prod F(p_i^{q_i}) \uff0c\u5219 F(p_i^{q_i})=\\sum_{d|n}\\varphi(d)*\\frac{n}{d}=\\varphi(1)*n+\\sum_{i=1}^{q} \\varphi(p^i)*\\frac{n}{p^i}=p_i^{q_i}+\\sum _{i=1} ^{q_i}(p_i-1)*(p_i^{i-1}*\\frac{p_i^{q_i}}{p_i}) F(p_i^{q_i})=\\sum_{d|n}\\varphi(d)*\\frac{n}{d}=\\varphi(1)*n+\\sum_{i=1}^{q} \\varphi(p^i)*\\frac{n}{p^i}=p_i^{q_i}+\\sum _{i=1} ^{q_i}(p_i-1)*(p_i^{i-1}*\\frac{p_i^{q_i}}{p_i}) =p_i^{q_i}+p_i^{q_i-1}*(p_i-1)*{q_i}=p_i^{q_i-1}*(p_i+q_i*(p_i-1)) =p_i^{q_i}+p_i^{q_i-1}*(p_i-1)*{q_i}=p_i^{q_i-1}*(p_i+q_i*(p_i-1)) \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/xiongshuxian2019/article/details/109631325 https://blog.csdn.net/consciousman/article/details/77888386 https://www.cnblogs.com/letlifestop/p/10262791.html \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ll n , p , q , ans = 1 ; scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld\" , & p , & q ); ans = ( ans * ksm ( p , q - 1 ) % mod * (( p + q * ( p - 1 )) % mod + mod ) % mod ) % mod ; } printf ( \"%lld \\n \" , ans % mod ); } return 0 ; } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u95ee\u9898 D: Master of Random \u9898\u76ee\u63cf\u8ff0 \u00b6 Hakase provides Nano with a problem. There is a rooted tree with values on nodes. For each query,you are asked to calculate the sum of the values in the subtree. However, Nano is a rookie so she decides to guess the answer. She has known how the data generator works: it identifi es the nodes with labels from 0 to n-1 and then visits them one by one. For each i (1\u2264i\u2264n), the generator selects a node whose label is smaller than i to be its father. The pseudocode is like this: \u200b for i = 1 to n - 1: \u200b father[i] = random(0, i - 1); where random(a, b) randomly generates a uniformly distributed random integer in range [a, b]. Knowing n and the value of the i-th node ai , Nano decides to randomly choose a subtree and sum up all of the values in the subtree as the answer. Now Hakase wants to know what the expectation of the answer is. Can you help her? \u8f93\u5165 \u00b6 The first line contains an integer T (1\u2264T\u226410) representing the number of test cases. For each test case, the fi rst line contains an integer n (1\u2264n\u2264100000), the number of the nodes in the rooted tree. The second line contains n integers a0,a1,..., a_{n-1} a_{n-1} (1\u2264ai\u2264100000) represent the values of nodes. \u8f93\u51fa \u00b6 It can be proven that the answer equals to an irreducible fraction p/q. For each test case, print p*q^{-1} p*q^{-1} mod 998244353 in one line. q^{-1} q^{-1} is the inverse of q under module number 998244353. \u6837\u4f8b\u8f93\u5165 \u00b6 2 2 1 1 3 1 2 3 \u6837\u4f8b\u8f93\u51fa \u00b6 499122178 166374063 \u63d0\u793a \u00b6 The shape of the tree in the first test case is unique. The father of node 1 is 0. It is possible to choose node 0 or 1 with equal possibility. The sum of the subtree with 0 as the root is 2 while the sum of the subtree with 1 as the root is 1. So the expectation is (2 + 1)/2 = 3/2. The output is 3*2-1 mod 998244353 = 400122178. There are two possible shapes in the second test case, node 1\u2019s father destines to be 0, but node 2\u2019s father might be node 0 or node 1. Both conditions are equally possible. If node 2\u2019s father is node 0, we randomly choose a node. The sum of the subtree with node 0 as the root is 6. The sum of the subtree with node 1 as the root is 2. The sum of the subtree with node 2 as the root is 3. If node 2\u2019s father is node 1, we randomly choose a node. The sum of the subtree with node 0 as the root is 6. The sum of the subtree with node 1 as the root is 5. The sum of the subtree with node 2 as the root is 3. So the expectation is (6 + 2 + 3 + 6 + 5 + 3)/6 = 25/6. The output is 25* 6^{-1} 6^{-1} mod 998244353 = 166374063. \u9898\u89e3 \u00b6 n\u4e2a\u70b9\u53ef\u4ee5\u5f62\u6210\u6811\u7684\u79cd\u7c7b\u4e3a(n-1)!\uff0c\u7136\u540e\u968f\u673a\u9009\u53d6\u4e00\u4e2a\u70b9\u8ba1\u7b97\u5b50\u6811\u7684\u6743\u503c\uff0c\u6240\u4ee5\u603b\u5171\u6709n!\u79cd\u53ef\u80fd\u3002 \u8003\u8651\u6bcf\u4e00\u4e2a\u70b9\u5bf9\u7b54\u6848\u7684\u8d21\u732e\uff0c\u5373\u8003\u8651\u6bcf\u4e2a\u70b9\u5728\u6240\u9009\u51fa\u7684\u5b50\u6811\u4e2d\u6709\u591a\u5c11\u79cd\u53ef\u80fd\u88ab\u5305\u542b\u3002 0: (n-1)! 0: (n-1)! \u200b 0\u70b9\u53ea\u6709\u9009\u53d60\u8fd9\u4e2a\u8282\u70b9\u65f6\u624d\u4f1a\u88ab\u9009\u62e9\uff0c\u5171\u6709(n-1)!\u79cd\u5f62\u6001\u7684\u6811\uff0c\u6240\u4ee5\u4e3a(n-1)! 1: (n-1)!+(n-1)! 1: (n-1)!+(n-1)! \u200b 1\u70b9\u53ea\u6709\u9009\u53d60\u548c1\u8fd9\u4e24\u4e2a\u8282\u70b9\u65f6\u624d\u4f1a\u88ab\u9009\u62e9 2:(n-1)!+(n-1)!/2+(n-1)! 2:(n-1)!+(n-1)!/2+(n-1)! \u200b 2\u70b9\u53ea\u6709\u9009\u53d60\u70b9\u65f6\u548c\u9009\u53d61\u70b9\uff082\u70b9\u4e0d\u57280\u4e0b\u9762\uff09\u548c\u9009\u53d62\u70b9\u65f6\u624d\u4f1a\u88ab\u9009\u62e9 ... k:(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! k:(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u70b9\uff0c\u5047\u8bbek\u51fa\u73b0\u7684\u79cd\u6811\u4e3a cnt[k]=(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! cnt[k]=(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! \uff0c\u6743\u503c\u4e3aa[k]\uff0c\u5219\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u4e3a cnt[k]*a[k]*(n!)^{-1} cnt[k]*a[k]*(n!)^{-1} \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/weixin_44178736/article/details/113450079 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll jc [ 100500 ] = { 0 }; ll a [ 100500 ] = { 0 }; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } int main () { jc [ 0 ] = 1 ; for ( int i = 1 ; i <= 100000 ; i ++ ) jc [ i ] = jc [ i - 1 ] * i % mod ; int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); ll cnt = jc [ n - 1 ] % mod , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt = ( cnt + jc [ n - 1 ] * ksm ( i , mod - 2 ) % mod ) % mod ; ans = ( ans + a [ i ] * cnt ) % mod ; } ans = ans * ksm ( jc [ n ], mod - 2 ); printf ( \"%lld \\n \" , ans % mod ); } return 0 ; }","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e8c\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_1","text":"","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e8c\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_2","text":"\u95ee\u9898 A: Matrix Equation","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_3","text":"You are given an integer n. Please output the answer of modulo 998244353. n is represented in the form of factorization. \u03c6(n) is Euler\u2019s totient function, and it is defi ned more formally as the number of integers k in the interval 1\u2264k\u2264n for which the greatest common divisor gcd(n,k) is equal to 1. For example, the totatives of n = 9 are the six numbers 1, 2, 4, 5, 7 and 8. They are all co-prime to 9, but the other three numbers in this interval, 3, 6, and 9 are not, because gcd(9,3) = gcd(9,6) = 3 and gcd(9,9) = 9. Therefore, \u03c6(9) = 6. As another example, \u03c6(1) = 1 since for n = 1 the only integer in the interval from 1 to n is 1 itself, and gcd(1,1) = 1. And there are several formulas for computing \u03c6(n), for example, Euler\u2019s product formula states like: where the product is all the distinct prime numbers (p in the formula) dividing n.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_4","text":"The fi rst line contains an integer T (1\u2264T\u226420) representing the number of test cases. For each test case, the fi rst line contains an integer m\uffff(1\u2264m\u226420) is the number of prime factors. The following m lines each contains two integers pi and qi (2\u2264pi\u2264108 , 1\u2264qi\u2264108 ) describing that n contains the factor piqi , in other words, . It is guaranteed that all pi are prime numbers and diff erent from each other.","title":"\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_5","text":"For each test case, print the the answer modulo 998244353 in one line.","title":"\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_6","text":"2 2 2 1 3 1 2 2 2 3 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_7","text":"15 168","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_8","text":"For first test case, n = 21*31= 6, and the answer is (\u03c6(1)*n/1+\u03c6(2)*n/2+\u03c6(3)*n/3+\u03c6(6)*n/6) mod 998244353 = (6 + 3 + 4 + 2) mod 998244353 = 15.","title":"\u63d0\u793a"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_9","text":"\u9898\u76ee\u8981\u6c42\u6c42\u89e3 F(n)=\\sum_{d|n} \\varphi(d)*\\frac{n}{d} F(n)=\\sum_{d|n} \\varphi(d)*\\frac{n}{d} \uff0c\u7531\u4e8e\u6b27\u62c9\u51fd\u6570\u548c \\frac{n}{d} \\frac{n}{d} \u5747\u4e3a\u79ef\u6027\u51fd\u6570\uff0c\u5219\u6709 F(m*n)=F(m)*F(n) F(m*n)=F(m)*F(n) \u5373\u4e3a F( \\prod p_i^{q_i})=\\prod F(p_i^{q_i}) F( \\prod p_i^{q_i})=\\prod F(p_i^{q_i}) \uff0c\u5219 F(p_i^{q_i})=\\sum_{d|n}\\varphi(d)*\\frac{n}{d}=\\varphi(1)*n+\\sum_{i=1}^{q} \\varphi(p^i)*\\frac{n}{p^i}=p_i^{q_i}+\\sum _{i=1} ^{q_i}(p_i-1)*(p_i^{i-1}*\\frac{p_i^{q_i}}{p_i}) F(p_i^{q_i})=\\sum_{d|n}\\varphi(d)*\\frac{n}{d}=\\varphi(1)*n+\\sum_{i=1}^{q} \\varphi(p^i)*\\frac{n}{p^i}=p_i^{q_i}+\\sum _{i=1} ^{q_i}(p_i-1)*(p_i^{i-1}*\\frac{p_i^{q_i}}{p_i}) =p_i^{q_i}+p_i^{q_i-1}*(p_i-1)*{q_i}=p_i^{q_i-1}*(p_i+q_i*(p_i-1)) =p_i^{q_i}+p_i^{q_i-1}*(p_i-1)*{q_i}=p_i^{q_i-1}*(p_i+q_i*(p_i-1)) \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/xiongshuxian2019/article/details/109631325 https://blog.csdn.net/consciousman/article/details/77888386 https://www.cnblogs.com/letlifestop/p/10262791.html","title":"\u9898\u89e3"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_10","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ll n , p , q , ans = 1 ; scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld\" , & p , & q ); ans = ( ans * ksm ( p , q - 1 ) % mod * (( p + q * ( p - 1 )) % mod + mod ) % mod ) % mod ; } printf ( \"%lld \\n \" , ans % mod ); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_11","text":"\u95ee\u9898 D: Master of Random","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_12","text":"Hakase provides Nano with a problem. There is a rooted tree with values on nodes. For each query,you are asked to calculate the sum of the values in the subtree. However, Nano is a rookie so she decides to guess the answer. She has known how the data generator works: it identifi es the nodes with labels from 0 to n-1 and then visits them one by one. For each i (1\u2264i\u2264n), the generator selects a node whose label is smaller than i to be its father. The pseudocode is like this: \u200b for i = 1 to n - 1: \u200b father[i] = random(0, i - 1); where random(a, b) randomly generates a uniformly distributed random integer in range [a, b]. Knowing n and the value of the i-th node ai , Nano decides to randomly choose a subtree and sum up all of the values in the subtree as the answer. Now Hakase wants to know what the expectation of the answer is. Can you help her?","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_13","text":"The first line contains an integer T (1\u2264T\u226410) representing the number of test cases. For each test case, the fi rst line contains an integer n (1\u2264n\u2264100000), the number of the nodes in the rooted tree. The second line contains n integers a0,a1,..., a_{n-1} a_{n-1} (1\u2264ai\u2264100000) represent the values of nodes.","title":"\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_14","text":"It can be proven that the answer equals to an irreducible fraction p/q. For each test case, print p*q^{-1} p*q^{-1} mod 998244353 in one line. q^{-1} q^{-1} is the inverse of q under module number 998244353.","title":"\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_15","text":"2 2 1 1 3 1 2 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_16","text":"499122178 166374063","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_17","text":"The shape of the tree in the first test case is unique. The father of node 1 is 0. It is possible to choose node 0 or 1 with equal possibility. The sum of the subtree with 0 as the root is 2 while the sum of the subtree with 1 as the root is 1. So the expectation is (2 + 1)/2 = 3/2. The output is 3*2-1 mod 998244353 = 400122178. There are two possible shapes in the second test case, node 1\u2019s father destines to be 0, but node 2\u2019s father might be node 0 or node 1. Both conditions are equally possible. If node 2\u2019s father is node 0, we randomly choose a node. The sum of the subtree with node 0 as the root is 6. The sum of the subtree with node 1 as the root is 2. The sum of the subtree with node 2 as the root is 3. If node 2\u2019s father is node 1, we randomly choose a node. The sum of the subtree with node 0 as the root is 6. The sum of the subtree with node 1 as the root is 5. The sum of the subtree with node 2 as the root is 3. So the expectation is (6 + 2 + 3 + 6 + 5 + 3)/6 = 25/6. The output is 25* 6^{-1} 6^{-1} mod 998244353 = 166374063.","title":"\u63d0\u793a"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_18","text":"n\u4e2a\u70b9\u53ef\u4ee5\u5f62\u6210\u6811\u7684\u79cd\u7c7b\u4e3a(n-1)!\uff0c\u7136\u540e\u968f\u673a\u9009\u53d6\u4e00\u4e2a\u70b9\u8ba1\u7b97\u5b50\u6811\u7684\u6743\u503c\uff0c\u6240\u4ee5\u603b\u5171\u6709n!\u79cd\u53ef\u80fd\u3002 \u8003\u8651\u6bcf\u4e00\u4e2a\u70b9\u5bf9\u7b54\u6848\u7684\u8d21\u732e\uff0c\u5373\u8003\u8651\u6bcf\u4e2a\u70b9\u5728\u6240\u9009\u51fa\u7684\u5b50\u6811\u4e2d\u6709\u591a\u5c11\u79cd\u53ef\u80fd\u88ab\u5305\u542b\u3002 0: (n-1)! 0: (n-1)! \u200b 0\u70b9\u53ea\u6709\u9009\u53d60\u8fd9\u4e2a\u8282\u70b9\u65f6\u624d\u4f1a\u88ab\u9009\u62e9\uff0c\u5171\u6709(n-1)!\u79cd\u5f62\u6001\u7684\u6811\uff0c\u6240\u4ee5\u4e3a(n-1)! 1: (n-1)!+(n-1)! 1: (n-1)!+(n-1)! \u200b 1\u70b9\u53ea\u6709\u9009\u53d60\u548c1\u8fd9\u4e24\u4e2a\u8282\u70b9\u65f6\u624d\u4f1a\u88ab\u9009\u62e9 2:(n-1)!+(n-1)!/2+(n-1)! 2:(n-1)!+(n-1)!/2+(n-1)! \u200b 2\u70b9\u53ea\u6709\u9009\u53d60\u70b9\u65f6\u548c\u9009\u53d61\u70b9\uff082\u70b9\u4e0d\u57280\u4e0b\u9762\uff09\u548c\u9009\u53d62\u70b9\u65f6\u624d\u4f1a\u88ab\u9009\u62e9 ... k:(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! k:(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u70b9\uff0c\u5047\u8bbek\u51fa\u73b0\u7684\u79cd\u6811\u4e3a cnt[k]=(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! cnt[k]=(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! \uff0c\u6743\u503c\u4e3aa[k]\uff0c\u5219\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u4e3a cnt[k]*a[k]*(n!)^{-1} cnt[k]*a[k]*(n!)^{-1} \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/weixin_44178736/article/details/113450079","title":"\u9898\u89e3"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_19","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll jc [ 100500 ] = { 0 }; ll a [ 100500 ] = { 0 }; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } int main () { jc [ 0 ] = 1 ; for ( int i = 1 ; i <= 100000 ; i ++ ) jc [ i ] = jc [ i - 1 ] * i % mod ; int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); ll cnt = jc [ n - 1 ] % mod , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt = ( cnt + jc [ n - 1 ] * ksm ( i , mod - 2 ) % mod ) % mod ; ans = ( ans + a [ i ] * cnt ) % mod ; } ans = ans * ksm ( jc [ n ], mod - 2 ); printf ( \"%lld \\n \" , ans % mod ); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/","text":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u56db\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u667a\u4e43\u9171\u7684\u524d\u7f00\u548c\u4e0e\u5dee\u5206 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u6837\u4f8b\u8f93\u5165 \u00b6 10 2 11 1000 1000 1000 100000 1000 1000 10000 10000 10000 100000 1 10 0 100 1 10 1 1 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 1 10 \u6837\u4f8b\u8f93\u51fa \u00b6 1101 1102 1103 100104 1105 1106 10107 10108 10109 100110 236055 \u9898\u89e3 \u00b6 \u7531\u4e8e\u6a21\u6570\u5927\u4e8e\u5e8f\u5217\u957f\u5ea6\uff0c\u6240\u4ee5\u5bf9\u8d1f\u6570\u7684\u5dee\u5206\u53ef\u4ee5\u8f6c\u5316\u4e3a\u53d6\u6a21\u540e\u7684\u524d\u7f00\u548c\u3002 \u5bf9\u5e8f\u5217{ a_0 a_0 ,0,0,0,0}\u505a\u524d\u7f00\u53ef\u5f97 \u5e8f\u53f7 0 1 2 3 4 \u539f\u5e8f\u5217 a_0 a_0 0 0 0 0 \u4e00\u6b21\u524d\u7f00\u548c a_0 a_0 a_0 a_0 a_0 a_0 a_0 a_0 a_0 a_0 \u4e8c\u6b21\u524d\u7f00\u548c a_0 a_0 2 a_0 a_0 3 a_0 a_0 4 a_0 a_0 5 a_0 a_0 \u4e09\u6b21\u524d\u7f00\u548c a_0 a_0 3 a_0 a_0 6 a_0 a_0 10 a_0 a_0 15 a_0 a_0 \u5219\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u9012\u63a8\u5f0f\uff1a b[k][i]=b[k-1][i]+b[k][i-1] b[k][i]=b[k-1][i]+b[k][i-1] \uff0c\u8be5\u516c\u5f0f\u5373\u4e3a\u4ece(0,0)\u70b9\u8d70\u5230(k,i)\u70b9\u7684\u8def\u5f84\u79cd\u7c7b\u6570\uff0c\u4e14\u901a\u9879\u516c\u5f0f\u5373\u4e3a\uff1a b[k][i]=C_{i+k-1}^{i-1} b[k][i]=C_{i+k-1}^{i-1} \u56e0\u6b64\u53ef\u4ee5\u901a\u8fc7\u7ec4\u5408\u6570\u9012\u63a8\u7684\u65b9\u5f0f\u6c42\u51fa\u7cfb\u6570\u3002 \u5982\u679c\u8003\u8651 {a_0,a_1,a_2,.....,a_k} {a_0,a_1,a_2,.....,a_k} \u5e8f\u5217\uff0c\u5219\u53ef\u5f97\u5230\u4e00\u4e0b\u8ba1\u7b97\uff1a \u7b54\u6848\u5373\u4e3a {a_0,a_1,a_2,...,a_k} {a_0,a_1,a_2,...,a_k} \u548c {b_0,b_1,b_2,...,b_k} {b_0,b_1,b_2,...,b_k} \u5377\u79ef\u7684\u7ed3\u679c\uff0c\u6839\u636eNTT\u7b97\u6cd5\u53ef\u4ee5\u5728 O(nlogn) O(nlogn) \u65f6\u95f4\u590d\u6742\u5ea6\u5185\u5f97\u51fa\u7b54\u6848\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.nowcoder.net/n/d1e592fc44b648668bcddc3fe44b7927 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; const ll G = 3 ; ll n , m , L , R [ 600500 ] = { 0 }; ll a [ 600500 ] = { 0 }, b [ 600500 ] = { 0 }, inv [ 600500 ] = { 0 }; ll qpow ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ans1 * ans2 % mod ; ans2 = ans2 * ans2 % mod ; b /= 2 ; } return ans1 % mod ; } void NTT ( ll * a , ll f ) { for ( ll i = 0 ; i < n ; i ++ ) { if ( i < R [ i ]) swap ( a [ i ], a [ R [ i ]]); } for ( ll i = 1 ; i < n ; i <<= 1 ) { ll gn = qpow ( G , ( mod - 1 ) / ( i << 1 )); for ( ll j = 0 ; j < n ; j += ( i << 1 )) { ll g = 1 ; for ( ll k = 0 ; k < i ; k ++ , g = g * gn % mod ) { ll x = a [ j + k ], y = g * a [ j + k + i ] % mod ; a [ j + k ] = ( x + y ) % mod ; a [ j + k + i ] = ( x - y + mod ) % mod ; } } } if ( f == 1 ) return ; ll inv = qpow ( n , mod - 2 ); reverse ( a + 1 , a + n ); for ( ll i = 0 ; i < n ; i ++ ) a [ i ] = 1l l * a [ i ] * inv % mod ; } void solve ( ll * A , ll * B ) { m = n + m ; for ( n = 1 ; n <= m ; n <<= 1 ) L ++ ; for ( int i = 0 ; i < n ; i ++ ) R [ i ] = ( R [ i >> 1 ] >> 1 ) | (( i & 1 ) << ( L - 1 )); NTT ( A , 1 ); NTT ( B , 1 ); for ( int i = 0 ; i < n ; i ++ ) A [ i ] = ( A [ i ] % mod * B [ i ] % mod + mod ) % mod ; NTT ( A , -1 ); } int main () { ll k ; scanf ( \"%lld%lld\" , & n , & k ); m = n ; ll nn = n ; for ( ll i = 0 ; i < n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); inv [ 1 ] = 1 ; for ( ll i = 2 ; i < 200500 ; i ++ ) inv [ i ] = ( ll )( mod - mod / i ) * inv [ mod % i ] % mod ; b [ 0 ] = 1 ; ll kk = ( k % mod + mod ) % mod ; for ( ll i = 1 ; i < n ; i ++ ) b [ i ] = b [ i - 1 ] * ( i + kk - 1 ) % mod * inv [ i ] % mod ; solve ( a , b ); for ( ll i = 0 ; i < nn ; i ++ ) printf ( \"%lld \" , a [ i ]); return 0 ; } \u9898\u76ee2 \u00b6 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u7ed9\u5b9a\u6b63\u6574\u6570 n n \uff0c\u6c42 1\\le x,y\\le n 1\\le x,y\\le n \u4e14 gcd(x,y) gcd(x,y) \u4e3a\u7d20\u6570\u7684\u6570\u5bf9 (x,y) (x,y) \u6709\u591a\u5c11\u5bf9\u3002 \u8f93\u5165\u683c\u5f0f \u00b6 \u53ea\u6709\u4e00\u884c\u4e00\u4e2a\u6574\u6570\uff0c\u4ee3\u8868 n n \u3002 \u8f93\u51fa\u683c\u5f0f \u00b6 \u4e00\u884c\u4e00\u4e2a\u6574\u6570\u8868\u793a\u7b54\u6848\u3002 \u8f93\u5165 \u00b6 4 \u8f93\u51fa \u00b6 4 \u63d0\u793a \u00b6 \u5bf9\u4e8e\u6837\u4f8b\uff0c\u6ee1\u8db3\u6761\u4ef6\u7684 (x,y) \u4e3a (2,2)\uff0c(2,4)\uff0c(3,3)\uff0c(4,2) \u6570\u636e\u89c4\u6a21\u4e0e\u7ea6\u5b9a \u00b6 \u5bf9\u4e8e 100% \u7684\u6570\u636e\uff0c\u4fdd\u8bc1 1\\le n\\le10^7 1\\le n\\le10^7 \u3002 \u9898\u89e3 \u00b6 \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; bool is_prime [ 10050000 ] = { 0 }; ll prime [ 5005000 ] = { 0 }; ll mu [ 10050000 ] = { 0 }; ll sum [ 10050000 ] = { 0 }; ll cnt = 0 ; void get_mu ( ll n ) { mu [ 1 ] = 1 ; for ( ll i = 2 ; i <= n ; i ++ ) { if ( ! is_prime [ i ]) { prime [ ++ cnt ] = i ; mu [ i ] = -1 ; } for ( ll j = 1 ; j <= cnt && prime [ j ] * i <= n ; j ++ ) { is_prime [ prime [ j ] * i ] = 1 ; if ( i % prime [ j ] == 0 ) break ; else mu [ i * prime [ j ]] = - mu [ i ]; } } } int main () { ll n ; scanf ( \"%lld\" , & n ); get_mu ( n ); for ( ll i = 1 ; i <= cnt ; i ++ ) for ( ll j = 1 ; j * prime [ i ] <= n ; j ++ ) sum [ j * prime [ i ]] += mu [ j ]; for ( int i = 1 ; i <= n ; i ++ ) sum [ i ] += sum [ i - 1 ]; ll ans = 0 ; for ( ll l = 1 , r ; l <= n ; l = r + 1 ) { r = n / ( n / l ); ans += ( sum [ r ] - sum [ l - 1 ]) * ( n / l ) * ( n / l ); } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u56db\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_1","text":"","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u56db\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_2","text":"\u667a\u4e43\u9171\u7684\u524d\u7f00\u548c\u4e0e\u5dee\u5206","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_3","text":"","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_4","text":"10 2 11 1000 1000 1000 100000 1000 1000 10000 10000 10000 100000 1 10 0 100 1 10 1 1 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 1 10","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_5","text":"1101 1102 1103 100104 1105 1106 10107 10108 10109 100110 236055","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_6","text":"\u7531\u4e8e\u6a21\u6570\u5927\u4e8e\u5e8f\u5217\u957f\u5ea6\uff0c\u6240\u4ee5\u5bf9\u8d1f\u6570\u7684\u5dee\u5206\u53ef\u4ee5\u8f6c\u5316\u4e3a\u53d6\u6a21\u540e\u7684\u524d\u7f00\u548c\u3002 \u5bf9\u5e8f\u5217{ a_0 a_0 ,0,0,0,0}\u505a\u524d\u7f00\u53ef\u5f97 \u5e8f\u53f7 0 1 2 3 4 \u539f\u5e8f\u5217 a_0 a_0 0 0 0 0 \u4e00\u6b21\u524d\u7f00\u548c a_0 a_0 a_0 a_0 a_0 a_0 a_0 a_0 a_0 a_0 \u4e8c\u6b21\u524d\u7f00\u548c a_0 a_0 2 a_0 a_0 3 a_0 a_0 4 a_0 a_0 5 a_0 a_0 \u4e09\u6b21\u524d\u7f00\u548c a_0 a_0 3 a_0 a_0 6 a_0 a_0 10 a_0 a_0 15 a_0 a_0 \u5219\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u9012\u63a8\u5f0f\uff1a b[k][i]=b[k-1][i]+b[k][i-1] b[k][i]=b[k-1][i]+b[k][i-1] \uff0c\u8be5\u516c\u5f0f\u5373\u4e3a\u4ece(0,0)\u70b9\u8d70\u5230(k,i)\u70b9\u7684\u8def\u5f84\u79cd\u7c7b\u6570\uff0c\u4e14\u901a\u9879\u516c\u5f0f\u5373\u4e3a\uff1a b[k][i]=C_{i+k-1}^{i-1} b[k][i]=C_{i+k-1}^{i-1} \u56e0\u6b64\u53ef\u4ee5\u901a\u8fc7\u7ec4\u5408\u6570\u9012\u63a8\u7684\u65b9\u5f0f\u6c42\u51fa\u7cfb\u6570\u3002 \u5982\u679c\u8003\u8651 {a_0,a_1,a_2,.....,a_k} {a_0,a_1,a_2,.....,a_k} \u5e8f\u5217\uff0c\u5219\u53ef\u5f97\u5230\u4e00\u4e0b\u8ba1\u7b97\uff1a \u7b54\u6848\u5373\u4e3a {a_0,a_1,a_2,...,a_k} {a_0,a_1,a_2,...,a_k} \u548c {b_0,b_1,b_2,...,b_k} {b_0,b_1,b_2,...,b_k} \u5377\u79ef\u7684\u7ed3\u679c\uff0c\u6839\u636eNTT\u7b97\u6cd5\u53ef\u4ee5\u5728 O(nlogn) O(nlogn) \u65f6\u95f4\u590d\u6742\u5ea6\u5185\u5f97\u51fa\u7b54\u6848\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.nowcoder.net/n/d1e592fc44b648668bcddc3fe44b7927","title":"\u9898\u89e3"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_7","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; const ll G = 3 ; ll n , m , L , R [ 600500 ] = { 0 }; ll a [ 600500 ] = { 0 }, b [ 600500 ] = { 0 }, inv [ 600500 ] = { 0 }; ll qpow ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ans1 * ans2 % mod ; ans2 = ans2 * ans2 % mod ; b /= 2 ; } return ans1 % mod ; } void NTT ( ll * a , ll f ) { for ( ll i = 0 ; i < n ; i ++ ) { if ( i < R [ i ]) swap ( a [ i ], a [ R [ i ]]); } for ( ll i = 1 ; i < n ; i <<= 1 ) { ll gn = qpow ( G , ( mod - 1 ) / ( i << 1 )); for ( ll j = 0 ; j < n ; j += ( i << 1 )) { ll g = 1 ; for ( ll k = 0 ; k < i ; k ++ , g = g * gn % mod ) { ll x = a [ j + k ], y = g * a [ j + k + i ] % mod ; a [ j + k ] = ( x + y ) % mod ; a [ j + k + i ] = ( x - y + mod ) % mod ; } } } if ( f == 1 ) return ; ll inv = qpow ( n , mod - 2 ); reverse ( a + 1 , a + n ); for ( ll i = 0 ; i < n ; i ++ ) a [ i ] = 1l l * a [ i ] * inv % mod ; } void solve ( ll * A , ll * B ) { m = n + m ; for ( n = 1 ; n <= m ; n <<= 1 ) L ++ ; for ( int i = 0 ; i < n ; i ++ ) R [ i ] = ( R [ i >> 1 ] >> 1 ) | (( i & 1 ) << ( L - 1 )); NTT ( A , 1 ); NTT ( B , 1 ); for ( int i = 0 ; i < n ; i ++ ) A [ i ] = ( A [ i ] % mod * B [ i ] % mod + mod ) % mod ; NTT ( A , -1 ); } int main () { ll k ; scanf ( \"%lld%lld\" , & n , & k ); m = n ; ll nn = n ; for ( ll i = 0 ; i < n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); inv [ 1 ] = 1 ; for ( ll i = 2 ; i < 200500 ; i ++ ) inv [ i ] = ( ll )( mod - mod / i ) * inv [ mod % i ] % mod ; b [ 0 ] = 1 ; ll kk = ( k % mod + mod ) % mod ; for ( ll i = 1 ; i < n ; i ++ ) b [ i ] = b [ i - 1 ] * ( i + kk - 1 ) % mod * inv [ i ] % mod ; solve ( a , b ); for ( ll i = 0 ; i < nn ; i ++ ) printf ( \"%lld \" , a [ i ]); return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_8","text":"\u7ed9\u5b9a\u6b63\u6574\u6570 n n \uff0c\u6c42 1\\le x,y\\le n 1\\le x,y\\le n \u4e14 gcd(x,y) gcd(x,y) \u4e3a\u7d20\u6570\u7684\u6570\u5bf9 (x,y) (x,y) \u6709\u591a\u5c11\u5bf9\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_9","text":"\u53ea\u6709\u4e00\u884c\u4e00\u4e2a\u6574\u6570\uff0c\u4ee3\u8868 n n \u3002","title":"\u8f93\u5165\u683c\u5f0f"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_10","text":"\u4e00\u884c\u4e00\u4e2a\u6574\u6570\u8868\u793a\u7b54\u6848\u3002","title":"\u8f93\u51fa\u683c\u5f0f"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_11","text":"4","title":"\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_12","text":"4","title":"\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_13","text":"\u5bf9\u4e8e\u6837\u4f8b\uff0c\u6ee1\u8db3\u6761\u4ef6\u7684 (x,y) \u4e3a (2,2)\uff0c(2,4)\uff0c(3,3)\uff0c(4,2)","title":"\u63d0\u793a"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_14","text":"\u5bf9\u4e8e 100% \u7684\u6570\u636e\uff0c\u4fdd\u8bc1 1\\le n\\le10^7 1\\le n\\le10^7 \u3002","title":"\u6570\u636e\u89c4\u6a21\u4e0e\u7ea6\u5b9a"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_15","text":"\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u3002","title":"\u9898\u89e3"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_16","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; bool is_prime [ 10050000 ] = { 0 }; ll prime [ 5005000 ] = { 0 }; ll mu [ 10050000 ] = { 0 }; ll sum [ 10050000 ] = { 0 }; ll cnt = 0 ; void get_mu ( ll n ) { mu [ 1 ] = 1 ; for ( ll i = 2 ; i <= n ; i ++ ) { if ( ! is_prime [ i ]) { prime [ ++ cnt ] = i ; mu [ i ] = -1 ; } for ( ll j = 1 ; j <= cnt && prime [ j ] * i <= n ; j ++ ) { is_prime [ prime [ j ] * i ] = 1 ; if ( i % prime [ j ] == 0 ) break ; else mu [ i * prime [ j ]] = - mu [ i ]; } } } int main () { ll n ; scanf ( \"%lld\" , & n ); get_mu ( n ); for ( ll i = 1 ; i <= cnt ; i ++ ) for ( ll j = 1 ; j * prime [ i ] <= n ; j ++ ) sum [ j * prime [ i ]] += mu [ j ]; for ( int i = 1 ; i <= n ; i ++ ) sum [ i ] += sum [ i - 1 ]; ll ans = 0 ; for ( ll l = 1 , r ; l <= n ; l = r + 1 ) { r = n / ( n / l ); ans += ( sum [ r ] - sum [ l - 1 ]) * ( n / l ) * ( n / l ); } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"\u4ee3\u7801"},{"location":"question/","text":"\u9898\u5355 \u00b6 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u516b\u573a \u00b6 \u95ee\u9898 A: Radio Prize \u00b6 \u7b97\u6cd5\uff1a\u6811\u4e0aDP \u95ee\u9898 B: Perfect Flush \u00b6 \u7b97\u6cd5\uff1a\u6a21\u62df \u95ee\u9898 C: Coloring Contention \u00b6 \u7b97\u6cd5\uff1a\u6a21\u62df \u95ee\u9898 L: Party Invitations \u00b6 \u7b97\u6cd5\uff1aBFS \u95ee\u9898 M: Liars and Truth Tellers \u00b6 \u7b97\u6cd5\uff1a\u5e76\u67e5\u96c6 \u95ee\u9898 K: Seating \u00b6 \u7b97\u6cd5\uff1a\u7ebf\u6bb5\u6811\u7ef4\u62a4\u524d\u7f00 \u95ee\u9898 J: Interstellar Travel \u00b6 \u7b97\u6cd5\uff1a\u5dee\u5206 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e94\u573a \u00b6 \u95ee\u9898 A: Almost Origami \u00b6 \u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55 \u95ee\u9898 D: Dividing Candy \u00b6 \u7b97\u6cd5\uff1a\u6a21\u62df \u95ee\u9898 C: Crisis at the Wedding \u00b6 \u7b97\u6cd5\uff1a\u6a21\u62df \u95ee\u9898 E: Excellent Views \u00b6 \u7b97\u6cd5\uff1a\u5355\u8c03\u6808 \u95ee\u9898 H: Halting Wolf \u00b6 \u7b97\u6cd5\uff1a\u7f51\u7edc\u6d41 \u95ee\u9898 J: Job Allocator \u00b6 \u7b97\u6cd5\uff1a\u66b4\u529b\u679a\u4e3e \u95ee\u9898 F: Fascinating Partitions \u00b6 \u7b97\u6cd5\uff1aDP+\u4f18\u5316 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e8c\u573a \u00b6 \u95ee\u9898 J: Tree Constructer \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe \u95ee\u9898 D: Fight against involution \u00b6 \u7b97\u6cd5\uff1a\u8d2a\u5fc3 \u95ee\u9898 G: Xor Transformation \u00b6 \u7b97\u6cd5\uff1a\u6784\u9020 \u95ee\u9898 A: Matrix Equation \u00b6 \u7b97\u6cd5\uff1a\u7ebf\u6027\u4ee3\u6570--\u9ad8\u65af\u6d88\u5143\u6cd5 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u56db\u573a \u00b6 \u95ee\u9898 C: Hakase and Nano \u00b6 \u7b97\u6cd5\uff1a\u535a\u5f08\u8bba \u95ee\u9898 B: Master of Phi \u00b6 \u7b97\u6cd5\uff1a\u6570\u8bba\uff08\u6b27\u62c9\u5b9a\u7406\uff09 \u95ee\u9898 K: Master of Sequence \u00b6 \u7b97\u6cd5\uff1a\u968f\u673a\u5316 \u95ee\u9898 D: Master of Random \u00b6 \u7b97\u6cd5\uff1a\u89c4\u5f8b 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e8c\u573a \u00b6 \u95ee\u9898 J: Tree Constructer \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe \u95ee\u9898 D: Fight against involution \u00b6 \u7b97\u6cd5\uff1a\u8d2a\u5fc3 \u95ee\u9898 G: Xor Transformation \u00b6 \u7b97\u6cd5\uff1a\u6784\u9020 \u95ee\u9898 A: Matrix Equation \u00b6 \u7b97\u6cd5\uff1a\u7ebf\u6027\u4ee3\u6570--\u9ad8\u65af\u6d88\u5143\u6cd5 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e00\u573a \u00b6 \u95ee\u9898 B: Collatz Conjecture \u00b6 \u7b97\u6cd5\uff1aGCD \u6027\u8d28 \u95ee\u9898 G: Hoarse Horses \u00b6 \u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55+\u56fe\u7684\u6027\u8d28 \u95ee\u9898 K: Lemonade Trade \u00b6 \u7b97\u6cd5\uff1a\u6570\u5b66\uff0c\u4e58\u6cd5---\u5bf9\u6570\u53d8\u6362--->\u52a0\u6cd5 \u95ee\u9898 L: Manhattan Mornings \u00b6 \u7b97\u6cd5\uff1a\u6700\u5927\u4e0a\u5347\u5b50\u5e8f\u5217 \u95ee\u9898 H: Irrational Division \u00b6 \u7b97\u6cd5\uff1a\u89c4\u5f8b\u9898 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e5d\u573a \u00b6 \u95ee\u9898 H: Prime Set \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe\u5339\u914d+\u5308\u7259\u5229\u7f51\u8def \u95ee\u9898 G: NumbersI \u00b6 \u7b97\u6cd5\uff1aJava\u9ad8\u7cbe\u5ea6+\u8d2a\u5fc3 \u95ee\u9898 C: Crusaders Quest \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32 \u95ee\u9898 E: String of CCPC \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32 \u95ee\u9898 L: One-Dimensional Maze \u00b6 \u7b97\u6cd5\uff1a\u524d\u540e\u7f00 \u95ee\u9898 A: Balloon Robot \u00b6 \u7b97\u6cd5\uff1a\u524d\u540e\u7f00 \u95ee\u9898 M: Safest Buildings \u00b6 \u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u516b\u573a \u00b6 \u95ee\u9898 F: Hopscotch \u00b6 \u7b97\u6cd5\uff1a\u591a\u6e90\u6700\u77ed\u8def \u95ee\u9898 H: Letter Wheels \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u54c8\u5e0c \u95ee\u9898 G: ICPC Camp \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206+\u5339\u914d \u95ee\u9898 K: Rooted Subtrees \u00b6 \u7b97\u6cd5\uff1aLCA+ST\u500d\u589e \u95ee\u9898 B: Mini Battleship \u00b6 \u7b97\u6cd5\uff1a\u641c\u7d22 \u95ee\u9898 D: All Kill \u00b6 \u7b97\u6cd5\uff1a\u6982\u7387\u8bba+\u6253\u8868/\u627e\u89c4\u5f8b 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e03\u573a \u00b6 \u95ee\u9898 A: Anagram \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u6a21\u62df \u95ee\u9898 C: Cities \u00b6 \u7b97\u6cd5\uff1a\u6700\u5c0f\u751f\u6210\u6811 \u95ee\u9898 F: Four-tuples \u00b6 \u7b97\u6cd5\uff1a\u5bb9\u65a5\u539f\u7406 \u95ee\u9898 B: Bullet \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206+\u4e8c\u5206\u56fe\u5339\u914d \u95ee\u9898 G: Games \u00b6 \u7b97\u6cd5\uff1a\u535a\u5f08\u8bba+\u52a8\u6001\u89c4\u5212 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u516d\u573a \u00b6 \u95ee\u9898 L: Mixtape Management \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u6784\u9020\u9898\u76ee \u95ee\u9898 A: Adolescent Architecture \u00b6 \u7b97\u6cd5\uff1a\u6392\u5e8f \u95ee\u9898 B: Bookshelf Building \u00b6 \u7b97\u6cd5\uff1a\u52a8\u6001\u89c4\u5212 \u95ee\u9898 J: Knightly Knowledge \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206\u67e5\u627e \u95ee\u9898 K: Lexicographical Lecturing \u00b6 \u7b97\u6cd5\uff1a\u601d\u7ef4+\u5b57\u7b26\u4e32 \u95ee\u9898 C: Decorative Dominoes \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe\u7684\u5339\u914d \u95ee\u9898 F: Gravity Grid \u00b6 \u7b97\u6cd5\uff1a\u5927\u6a21\u62df 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e94\u573a \u00b6 \u95ee\u9898 C: Safe Distance \u00b6 \u7b97\u6cd5\uff1a\u5e76\u67e5\u96c6 \u95ee\u9898 G: Decoration \u00b6 \u7b97\u6cd5\uff1a\u56fe\u8bba+\u6570\u8bba \u95ee\u9898 I: Emails \u00b6 \u7b97\u6cd5\uff1aBFS\uff0c\u65e0\u5411\u56fe\u76f4\u5f84 \u95ee\u9898 K: Unique Activities \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32+\u4e8c\u5206check 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u56db\u573a \u00b6 \u95ee\u9898 F: Fair Distribution \u00b6 \u7b97\u6cd5\uff1a\u6570\u8bba+\u6574\u6570\u5206\u5757 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e09\u573a \u00b6 \u95ee\u9898 E: Interview Queue \u00b6 \u7b97\u6cd5\uff1aSTL+\u6a21\u62df \u95ee\u9898 F: Conquest \u00b6 \u7b97\u6cd5\uff1a\u4f18\u5148\u961f\u5217+BFS \u95ee\u9898 H: Antimatter Rain \u00b6 \u7b97\u6cd5\uff1a\u626b\u63cf\u7ebf+\u7ebf\u6bb5\u6811 \u95ee\u9898 J: Pegs and Legs \u00b6 \u7b97\u6cd5\uff1a\u56fe\u8bba+\u6982\u7387\u8bba 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e8c\u573a \u00b6 \u95ee\u9898 A: Three-Axis Views \u00b6 \u7b97\u6cd5\uff1a\u4e09\u89c6\u56fe\u6a21\u62df \u95ee\u9898 B: Secrets of Legendary Treasure \u00b6 \u7b97\u6cd5\uff1a\u6784\u9020+\u6a21\u62df\u9898\u76ee \u95ee\u9898 E: Jewelry Size \u00b6 \u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55 \u95ee\u9898 G: To be Connected, or not to be, that is the Question \u00b6 \u7b97\u6cd5\uff1a\u5e76\u67e5\u96c6\u7684\u64a4\u9500 \u95ee\u9898 H: LCM of GCDs \u00b6 \u7b97\u6cd5\uff1a\u7ebf\u6bb5\u6811+GCD&LCM\u6027\u8d28 \u95ee\u9898 I: High-Tech Detective \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32+\u52a8\u6001\u89c4\u5212 \u95ee\u9898 J: Formica Sokobanica \u00b6 \u7b97\u6cd5\uff1a\u641c\u7d22 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e00\u573a \u00b6 \u95ee\u9898 F: Agamemnon\u2019s Odyssey \u00b6 \u7b97\u6cd5\uff1a\u6811\u7684\u76f4\u5f84 \u95ee\u9898 D: Substring Characters \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32 \u95ee\u9898 J: Ada Loveslaces \u00b6 \u7b97\u6cd5\uff1a\u72b6\u538b \u95ee\u9898 I: Staggering to the Finish \u00b6 \u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55\uff0c\u6709\u70b9\u96be \u95ee\u9898 K: ICPC Record Matching \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u54c8\u5e0c\uff0c\u6a21\u62df \u95ee\u9898 A: LogDB \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u6a21\u62df \u95ee\u9898 B: Ride-Hailing \u00b6 \u7b97\u6cd5\uff1a\u56fe\u5339\u914d+\u6700\u5927\u6d41Dinic\u7b97\u6cd5 2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c52\u573a \u00b6 \u95ee\u9898 C: \u62a2\u5360\u57ce\u5821 \u00b6 \u7b97\u6cd5\uff1a\u76f4\u63a5\u641c\u7d22\uff0c\u6ce8\u610f\u6709\u5751\uff01\uff01\uff01 \u95ee\u9898 H: \u5305\u542b \u00b6 \u7b97\u6cd5\uff1a\u5b57\u5178\u6811+\u641c\u7d20 \u95ee\u9898 K: GCD \u00b6 \u7b97\u6cd5\uff1a\u8d28\u56e0\u6570 \u95ee\u9898 B: \u653e\u725b\u5976\u7684\u51b0\u7bb1 \u00b6 \u7b97\u6cd5\uff1a\u672a\u77e5\uff0c\u8fd8\u6ca1\u8865\uff0cqaq\uff0c\u53ef\u4ee5\u66b4\u529b\u6216\u4e8c\u5206\u8bd5\u8bd5 \u95ee\u9898 I: Reverse and Compare \u00b6 \u7b97\u6cd5\uff1a\u89c4\u5f8b\u9898\uff0c\u7ed9\u4e2a\u6837\u4f8b\u63d0\u793a\uff1aabca\uff0c\u6682\u65f6\u8fd8\u6ca1\u8865 \u95ee\u9898 J: Fountain Walk \u00b6 \u7b97\u6cd5\uff1a\u6700\u5927\u4e0a\u5347\u5b50\u5e8f\u5217\uff0c\u53ef\u4ee5\u5148\u653e\u4e00\u653e\uff0c\u6211\u8fd8\u6ca1\u8865\u51fa\u6765\uff0cqaq 2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c51\u573a \u00b6 \u95ee\u9898 B: Getting Difference \u00b6 \u7b97\u6cd5\uff1a\u601d\u7ef4+\u6570\u8bba \u95ee\u9898 C: \u91ce\u725b\u4e0e\u72fc \u00b6 \u7b97\u6cd5\uff1a\u524d\u7f00+\u601d\u7ef4 \u95ee\u9898 D: \u8001\u6b7b\u4e0d\u76f8\u5f80\u6765 \u00b6 \u7b97\u6cd5\uff1a\u79bb\u6563\u5316 \u95ee\u9898 G: Cow Lineup I \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206\u6216\u8005\u66b4\u529b \u95ee\u9898 K: Painting the Fence \u00b6 \u7b97\u6cd5\uff1a\u79bb\u6563\u5316+\u524d\u7f00 2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c50\u573a \u00b6 \u95ee\u9898 C: \u725b\u725b\u7684\u65b9\u7a0b\u5f0f \u00b6 \u7b97\u6cd5\uff1a\u7b7e\u5230\u9898\uff0c\u6570\u8bba \u95ee\u9898 M: Milk Routing \u00b6 \u7b97\u6cd5\uff1a\u56fe\u8bba\uff0c\u6700\u77ed\u8def\uff0c\u641c\u7d20 \u95ee\u9898 D: \u725b\u725b\u7684\u731c\u7403\u6e38\u620f \u00b6 \u7b97\u6cd5\uff1a\u601d\u7ef4\u9898\u76ee \u95ee\u9898 A: LH \u64b8\u4e32\u4e32 \u00b6 \u7b97\u6cd5\uff1a\u65e0\u8111\u66b4\u529b \u95ee\u9898 J: Moderate Differences \u00b6 \u7b97\u6cd5\uff1a\u601d\u7ef4+\u679a\u4e3e \u95ee\u9898 K: Biscuits \u00b6 \u7b97\u6cd5\uff1a\u52a8\u6001\u89c4\u5212/\u7ec4\u5408\u6570\u5b66 2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c49\u573a \u00b6 \u95ee\u9898 A: \u00b1 Rectangle \u00b6 \u7b97\u6cd5\uff1a\u6bd4\u8f83\u96be\u7684\u6784\u9020\u9898\uff0c\u4e0d\u8fc7\u6a21\u62df\u4e5f\u53ef\u4ee5\u8fc7\uff0c\u989d \u95ee\u9898 H: Wifi Setup \u00b6 \u7b97\u6cd5\uff1aDP\uff1f\u53ef\u80fd\u662f\u5427 \u95ee\u9898 J: Shrinking \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32 \u95ee\u9898 G: Colorful Hats \u00b6 \u7b97\u6cd5\uff1a\u672a\u77e5\uff0c\u8fd8\u6ca1\u8865\u51fa\u6765\uff0c \u95ee\u9898 D: Scrambled Letters \u00b6 \u7b97\u6cd5\uff1a\u672a\u77e5\uff0c\u8fd8\u6ca1\u8865\u51fa\u6765\uff0c 2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c48\u573a \u00b6 \u95ee\u9898F\uff1a\u62ec\u53f7\u5e8f\u5217 \u00b6 \u7b97\u6cd5\uff1a\u6808\u7684\u5e94\u7528 \u95ee\u9898 L: A or...or B Problem \u00b6 \u7b97\u6cd5\uff1a\u601d\u7ef4\uff0c\u4f4d\u8fd0\u7b97 \u95ee\u9898 H: Nuske vs Phantom Thnook \u00b6 \u7b97\u6cd5\uff1a\u524d\u7f00\u548c\u3001\u6811\u7684\u6027\u8d28 \u95ee\u9898 K: \u5b57\u6bcd\u91d1\u5b57\u5854 \u00b6 \u7b97\u6cd5\uff1a\u5927\u6a21\u62df\uff0c\u53ef\u4ee5\u5148\u653e\u4e00\u653e <script> console.log(\"Hello World!\"); </script> <script> console.log(\"\u4f60\u597d\u554a\uff01\"); </script>","title":"ICPC\u9898\u5355"},{"location":"question/#_1","text":"","title":"\u9898\u5355"},{"location":"question/#2021","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u516b\u573a"},{"location":"question/#a-radio-prize","text":"\u7b97\u6cd5\uff1a\u6811\u4e0aDP","title":"\u95ee\u9898 A: Radio Prize"},{"location":"question/#b-perfect-flush","text":"\u7b97\u6cd5\uff1a\u6a21\u62df","title":"\u95ee\u9898 B: Perfect Flush"},{"location":"question/#c-coloring-contention","text":"\u7b97\u6cd5\uff1a\u6a21\u62df","title":"\u95ee\u9898 C: Coloring Contention"},{"location":"question/#l-party-invitations","text":"\u7b97\u6cd5\uff1aBFS","title":"\u95ee\u9898 L: Party Invitations"},{"location":"question/#m-liars-and-truth-tellers","text":"\u7b97\u6cd5\uff1a\u5e76\u67e5\u96c6","title":"\u95ee\u9898 M: Liars and Truth Tellers"},{"location":"question/#k-seating","text":"\u7b97\u6cd5\uff1a\u7ebf\u6bb5\u6811\u7ef4\u62a4\u524d\u7f00","title":"\u95ee\u9898 K: Seating"},{"location":"question/#j-interstellar-travel","text":"\u7b97\u6cd5\uff1a\u5dee\u5206","title":"\u95ee\u9898 J: Interstellar Travel"},{"location":"question/#2021_1","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e94\u573a"},{"location":"question/#a-almost-origami","text":"\u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55","title":"\u95ee\u9898 A: Almost Origami"},{"location":"question/#d-dividing-candy","text":"\u7b97\u6cd5\uff1a\u6a21\u62df","title":"\u95ee\u9898 D: Dividing Candy"},{"location":"question/#c-crisis-at-the-wedding","text":"\u7b97\u6cd5\uff1a\u6a21\u62df","title":"\u95ee\u9898 C: Crisis at the Wedding"},{"location":"question/#e-excellent-views","text":"\u7b97\u6cd5\uff1a\u5355\u8c03\u6808","title":"\u95ee\u9898 E: Excellent Views"},{"location":"question/#h-halting-wolf","text":"\u7b97\u6cd5\uff1a\u7f51\u7edc\u6d41","title":"\u95ee\u9898 H: Halting Wolf"},{"location":"question/#j-job-allocator","text":"\u7b97\u6cd5\uff1a\u66b4\u529b\u679a\u4e3e","title":"\u95ee\u9898 J: Job Allocator"},{"location":"question/#f-fascinating-partitions","text":"\u7b97\u6cd5\uff1aDP+\u4f18\u5316","title":"\u95ee\u9898 F: Fascinating Partitions"},{"location":"question/#2021_2","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e8c\u573a"},{"location":"question/#j-tree-constructer","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe","title":"\u95ee\u9898 J: Tree Constructer"},{"location":"question/#d-fight-against-involution","text":"\u7b97\u6cd5\uff1a\u8d2a\u5fc3","title":"\u95ee\u9898 D: Fight against involution"},{"location":"question/#g-xor-transformation","text":"\u7b97\u6cd5\uff1a\u6784\u9020","title":"\u95ee\u9898 G: Xor Transformation"},{"location":"question/#a-matrix-equation","text":"\u7b97\u6cd5\uff1a\u7ebf\u6027\u4ee3\u6570--\u9ad8\u65af\u6d88\u5143\u6cd5","title":"\u95ee\u9898 A: Matrix Equation"},{"location":"question/#2021_3","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u56db\u573a"},{"location":"question/#c-hakase-and-nano","text":"\u7b97\u6cd5\uff1a\u535a\u5f08\u8bba","title":"\u95ee\u9898 C: Hakase and Nano"},{"location":"question/#b-master-of-phi","text":"\u7b97\u6cd5\uff1a\u6570\u8bba\uff08\u6b27\u62c9\u5b9a\u7406\uff09","title":"\u95ee\u9898 B: Master of Phi"},{"location":"question/#k-master-of-sequence","text":"\u7b97\u6cd5\uff1a\u968f\u673a\u5316","title":"\u95ee\u9898 K: Master of Sequence"},{"location":"question/#d-master-of-random","text":"\u7b97\u6cd5\uff1a\u89c4\u5f8b","title":"\u95ee\u9898 D: Master of Random"},{"location":"question/#2021_4","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e8c\u573a"},{"location":"question/#j-tree-constructer_1","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe","title":"\u95ee\u9898 J: Tree Constructer"},{"location":"question/#d-fight-against-involution_1","text":"\u7b97\u6cd5\uff1a\u8d2a\u5fc3","title":"\u95ee\u9898 D: Fight against involution"},{"location":"question/#g-xor-transformation_1","text":"\u7b97\u6cd5\uff1a\u6784\u9020","title":"\u95ee\u9898 G: Xor Transformation"},{"location":"question/#a-matrix-equation_1","text":"\u7b97\u6cd5\uff1a\u7ebf\u6027\u4ee3\u6570--\u9ad8\u65af\u6d88\u5143\u6cd5","title":"\u95ee\u9898 A: Matrix Equation"},{"location":"question/#2021_5","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e00\u573a"},{"location":"question/#b-collatz-conjecture","text":"\u7b97\u6cd5\uff1aGCD \u6027\u8d28","title":"\u95ee\u9898 B: Collatz Conjecture"},{"location":"question/#g-hoarse-horses","text":"\u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55+\u56fe\u7684\u6027\u8d28","title":"\u95ee\u9898 G: Hoarse Horses"},{"location":"question/#k-lemonade-trade","text":"\u7b97\u6cd5\uff1a\u6570\u5b66\uff0c\u4e58\u6cd5---\u5bf9\u6570\u53d8\u6362--->\u52a0\u6cd5","title":"\u95ee\u9898 K: Lemonade Trade"},{"location":"question/#l-manhattan-mornings","text":"\u7b97\u6cd5\uff1a\u6700\u5927\u4e0a\u5347\u5b50\u5e8f\u5217","title":"\u95ee\u9898 L: Manhattan Mornings"},{"location":"question/#h-irrational-division","text":"\u7b97\u6cd5\uff1a\u89c4\u5f8b\u9898","title":"\u95ee\u9898 H: Irrational Division"},{"location":"question/#2021_6","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e5d\u573a"},{"location":"question/#h-prime-set","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe\u5339\u914d+\u5308\u7259\u5229\u7f51\u8def","title":"\u95ee\u9898 H: Prime Set"},{"location":"question/#g-numbersi","text":"\u7b97\u6cd5\uff1aJava\u9ad8\u7cbe\u5ea6+\u8d2a\u5fc3","title":"\u95ee\u9898 G: NumbersI"},{"location":"question/#c-crusaders-quest","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32","title":"\u95ee\u9898 C: Crusaders Quest"},{"location":"question/#e-string-of-ccpc","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32","title":"\u95ee\u9898 E: String of CCPC"},{"location":"question/#l-one-dimensional-maze","text":"\u7b97\u6cd5\uff1a\u524d\u540e\u7f00","title":"\u95ee\u9898 L: One-Dimensional Maze"},{"location":"question/#a-balloon-robot","text":"\u7b97\u6cd5\uff1a\u524d\u540e\u7f00","title":"\u95ee\u9898 A: Balloon Robot"},{"location":"question/#m-safest-buildings","text":"\u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55","title":"\u95ee\u9898 M: Safest Buildings"},{"location":"question/#2021_7","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u516b\u573a"},{"location":"question/#f-hopscotch","text":"\u7b97\u6cd5\uff1a\u591a\u6e90\u6700\u77ed\u8def","title":"\u95ee\u9898 F: Hopscotch"},{"location":"question/#h-letter-wheels","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u54c8\u5e0c","title":"\u95ee\u9898 H: Letter Wheels"},{"location":"question/#g-icpc-camp","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206+\u5339\u914d","title":"\u95ee\u9898 G: ICPC Camp"},{"location":"question/#k-rooted-subtrees","text":"\u7b97\u6cd5\uff1aLCA+ST\u500d\u589e","title":"\u95ee\u9898 K: Rooted Subtrees"},{"location":"question/#b-mini-battleship","text":"\u7b97\u6cd5\uff1a\u641c\u7d22","title":"\u95ee\u9898 B: Mini Battleship"},{"location":"question/#d-all-kill","text":"\u7b97\u6cd5\uff1a\u6982\u7387\u8bba+\u6253\u8868/\u627e\u89c4\u5f8b","title":"\u95ee\u9898 D: All Kill"},{"location":"question/#2021_8","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e03\u573a"},{"location":"question/#a-anagram","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u6a21\u62df","title":"\u95ee\u9898 A: Anagram"},{"location":"question/#c-cities","text":"\u7b97\u6cd5\uff1a\u6700\u5c0f\u751f\u6210\u6811","title":"\u95ee\u9898 C: Cities"},{"location":"question/#f-four-tuples","text":"\u7b97\u6cd5\uff1a\u5bb9\u65a5\u539f\u7406","title":"\u95ee\u9898 F: Four-tuples"},{"location":"question/#b-bullet","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206+\u4e8c\u5206\u56fe\u5339\u914d","title":"\u95ee\u9898 B: Bullet"},{"location":"question/#g-games","text":"\u7b97\u6cd5\uff1a\u535a\u5f08\u8bba+\u52a8\u6001\u89c4\u5212","title":"\u95ee\u9898 G: Games"},{"location":"question/#2021_9","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u516d\u573a"},{"location":"question/#l-mixtape-management","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u6784\u9020\u9898\u76ee","title":"\u95ee\u9898 L: Mixtape Management"},{"location":"question/#a-adolescent-architecture","text":"\u7b97\u6cd5\uff1a\u6392\u5e8f","title":"\u95ee\u9898 A: Adolescent Architecture"},{"location":"question/#b-bookshelf-building","text":"\u7b97\u6cd5\uff1a\u52a8\u6001\u89c4\u5212","title":"\u95ee\u9898 B: Bookshelf Building"},{"location":"question/#j-knightly-knowledge","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206\u67e5\u627e","title":"\u95ee\u9898 J: Knightly Knowledge"},{"location":"question/#k-lexicographical-lecturing","text":"\u7b97\u6cd5\uff1a\u601d\u7ef4+\u5b57\u7b26\u4e32","title":"\u95ee\u9898 K: Lexicographical Lecturing"},{"location":"question/#c-decorative-dominoes","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe\u7684\u5339\u914d","title":"\u95ee\u9898 C: Decorative Dominoes"},{"location":"question/#f-gravity-grid","text":"\u7b97\u6cd5\uff1a\u5927\u6a21\u62df","title":"\u95ee\u9898 F: Gravity Grid"},{"location":"question/#2021_10","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e94\u573a"},{"location":"question/#c-safe-distance","text":"\u7b97\u6cd5\uff1a\u5e76\u67e5\u96c6","title":"\u95ee\u9898 C: Safe Distance"},{"location":"question/#g-decoration","text":"\u7b97\u6cd5\uff1a\u56fe\u8bba+\u6570\u8bba","title":"\u95ee\u9898 G: Decoration"},{"location":"question/#i-emails","text":"\u7b97\u6cd5\uff1aBFS\uff0c\u65e0\u5411\u56fe\u76f4\u5f84","title":"\u95ee\u9898 I: Emails"},{"location":"question/#k-unique-activities","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32+\u4e8c\u5206check","title":"\u95ee\u9898 K: Unique Activities"},{"location":"question/#2021_11","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u56db\u573a"},{"location":"question/#f-fair-distribution","text":"\u7b97\u6cd5\uff1a\u6570\u8bba+\u6574\u6570\u5206\u5757","title":"\u95ee\u9898 F: Fair Distribution"},{"location":"question/#2021_12","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e09\u573a"},{"location":"question/#e-interview-queue","text":"\u7b97\u6cd5\uff1aSTL+\u6a21\u62df","title":"\u95ee\u9898 E: Interview Queue"},{"location":"question/#f-conquest","text":"\u7b97\u6cd5\uff1a\u4f18\u5148\u961f\u5217+BFS","title":"\u95ee\u9898 F: Conquest"},{"location":"question/#h-antimatter-rain","text":"\u7b97\u6cd5\uff1a\u626b\u63cf\u7ebf+\u7ebf\u6bb5\u6811","title":"\u95ee\u9898 H: Antimatter Rain"},{"location":"question/#j-pegs-and-legs","text":"\u7b97\u6cd5\uff1a\u56fe\u8bba+\u6982\u7387\u8bba","title":"\u95ee\u9898 J: Pegs and Legs"},{"location":"question/#2021_13","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e8c\u573a"},{"location":"question/#a-three-axis-views","text":"\u7b97\u6cd5\uff1a\u4e09\u89c6\u56fe\u6a21\u62df","title":"\u95ee\u9898 A: Three-Axis Views"},{"location":"question/#b-secrets-of-legendary-treasure","text":"\u7b97\u6cd5\uff1a\u6784\u9020+\u6a21\u62df\u9898\u76ee","title":"\u95ee\u9898 B: Secrets of Legendary Treasure"},{"location":"question/#e-jewelry-size","text":"\u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55","title":"\u95ee\u9898 E: Jewelry Size"},{"location":"question/#g-to-be-connected-or-not-to-be-that-is-the-question","text":"\u7b97\u6cd5\uff1a\u5e76\u67e5\u96c6\u7684\u64a4\u9500","title":"\u95ee\u9898 G: To be Connected, or not to be, that is the Question"},{"location":"question/#h-lcm-of-gcds","text":"\u7b97\u6cd5\uff1a\u7ebf\u6bb5\u6811+GCD&LCM\u6027\u8d28","title":"\u95ee\u9898 H: LCM of GCDs"},{"location":"question/#i-high-tech-detective","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32+\u52a8\u6001\u89c4\u5212","title":"\u95ee\u9898 I: High-Tech Detective"},{"location":"question/#j-formica-sokobanica","text":"\u7b97\u6cd5\uff1a\u641c\u7d22","title":"\u95ee\u9898 J: Formica Sokobanica"},{"location":"question/#2021_14","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e00\u573a"},{"location":"question/#f-agamemnons-odyssey","text":"\u7b97\u6cd5\uff1a\u6811\u7684\u76f4\u5f84","title":"\u95ee\u9898 F: Agamemnon\u2019s Odyssey"},{"location":"question/#d-substring-characters","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32","title":"\u95ee\u9898 D: Substring Characters"},{"location":"question/#j-ada-loveslaces","text":"\u7b97\u6cd5\uff1a\u72b6\u538b","title":"\u95ee\u9898 J: Ada Loveslaces"},{"location":"question/#i-staggering-to-the-finish","text":"\u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55\uff0c\u6709\u70b9\u96be","title":"\u95ee\u9898 I: Staggering to the Finish"},{"location":"question/#k-icpc-record-matching","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u54c8\u5e0c\uff0c\u6a21\u62df","title":"\u95ee\u9898 K: ICPC Record Matching"},{"location":"question/#a-logdb","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u6a21\u62df","title":"\u95ee\u9898 A: LogDB"},{"location":"question/#b-ride-hailing","text":"\u7b97\u6cd5\uff1a\u56fe\u5339\u914d+\u6700\u5927\u6d41Dinic\u7b97\u6cd5","title":"\u95ee\u9898 B: Ride-Hailing"},{"location":"question/#202152","text":"","title":"2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c52\u573a"},{"location":"question/#c","text":"\u7b97\u6cd5\uff1a\u76f4\u63a5\u641c\u7d22\uff0c\u6ce8\u610f\u6709\u5751\uff01\uff01\uff01","title":"\u95ee\u9898 C: \u62a2\u5360\u57ce\u5821"},{"location":"question/#h","text":"\u7b97\u6cd5\uff1a\u5b57\u5178\u6811+\u641c\u7d20","title":"\u95ee\u9898 H: \u5305\u542b"},{"location":"question/#k-gcd","text":"\u7b97\u6cd5\uff1a\u8d28\u56e0\u6570","title":"\u95ee\u9898 K: GCD"},{"location":"question/#b","text":"\u7b97\u6cd5\uff1a\u672a\u77e5\uff0c\u8fd8\u6ca1\u8865\uff0cqaq\uff0c\u53ef\u4ee5\u66b4\u529b\u6216\u4e8c\u5206\u8bd5\u8bd5","title":"\u95ee\u9898 B: \u653e\u725b\u5976\u7684\u51b0\u7bb1"},{"location":"question/#i-reverse-and-compare","text":"\u7b97\u6cd5\uff1a\u89c4\u5f8b\u9898\uff0c\u7ed9\u4e2a\u6837\u4f8b\u63d0\u793a\uff1aabca\uff0c\u6682\u65f6\u8fd8\u6ca1\u8865","title":"\u95ee\u9898 I: Reverse and Compare"},{"location":"question/#j-fountain-walk","text":"\u7b97\u6cd5\uff1a\u6700\u5927\u4e0a\u5347\u5b50\u5e8f\u5217\uff0c\u53ef\u4ee5\u5148\u653e\u4e00\u653e\uff0c\u6211\u8fd8\u6ca1\u8865\u51fa\u6765\uff0cqaq","title":"\u95ee\u9898 J: Fountain Walk"},{"location":"question/#202151","text":"","title":"2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c51\u573a"},{"location":"question/#b-getting-difference","text":"\u7b97\u6cd5\uff1a\u601d\u7ef4+\u6570\u8bba","title":"\u95ee\u9898 B: Getting Difference"},{"location":"question/#c_1","text":"\u7b97\u6cd5\uff1a\u524d\u7f00+\u601d\u7ef4","title":"\u95ee\u9898 C: \u91ce\u725b\u4e0e\u72fc"},{"location":"question/#d","text":"\u7b97\u6cd5\uff1a\u79bb\u6563\u5316","title":"\u95ee\u9898 D: \u8001\u6b7b\u4e0d\u76f8\u5f80\u6765"},{"location":"question/#g-cow-lineup-i","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206\u6216\u8005\u66b4\u529b","title":"\u95ee\u9898 G: Cow Lineup I"},{"location":"question/#k-painting-the-fence","text":"\u7b97\u6cd5\uff1a\u79bb\u6563\u5316+\u524d\u7f00","title":"\u95ee\u9898 K: Painting the Fence"},{"location":"question/#202150","text":"","title":"2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c50\u573a"},{"location":"question/#c_2","text":"\u7b97\u6cd5\uff1a\u7b7e\u5230\u9898\uff0c\u6570\u8bba","title":"\u95ee\u9898 C: \u725b\u725b\u7684\u65b9\u7a0b\u5f0f"},{"location":"question/#m-milk-routing","text":"\u7b97\u6cd5\uff1a\u56fe\u8bba\uff0c\u6700\u77ed\u8def\uff0c\u641c\u7d20","title":"\u95ee\u9898 M: Milk Routing"},{"location":"question/#d_1","text":"\u7b97\u6cd5\uff1a\u601d\u7ef4\u9898\u76ee","title":"\u95ee\u9898 D: \u725b\u725b\u7684\u731c\u7403\u6e38\u620f"},{"location":"question/#a-lh","text":"\u7b97\u6cd5\uff1a\u65e0\u8111\u66b4\u529b","title":"\u95ee\u9898 A: LH \u64b8\u4e32\u4e32"},{"location":"question/#j-moderate-differences","text":"\u7b97\u6cd5\uff1a\u601d\u7ef4+\u679a\u4e3e","title":"\u95ee\u9898 J: Moderate Differences"},{"location":"question/#k-biscuits","text":"\u7b97\u6cd5\uff1a\u52a8\u6001\u89c4\u5212/\u7ec4\u5408\u6570\u5b66","title":"\u95ee\u9898 K: Biscuits"},{"location":"question/#202149","text":"","title":"2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c49\u573a"},{"location":"question/#a-rectangle","text":"\u7b97\u6cd5\uff1a\u6bd4\u8f83\u96be\u7684\u6784\u9020\u9898\uff0c\u4e0d\u8fc7\u6a21\u62df\u4e5f\u53ef\u4ee5\u8fc7\uff0c\u989d","title":"\u95ee\u9898 A: +/- Rectangle"},{"location":"question/#h-wifi-setup","text":"\u7b97\u6cd5\uff1aDP\uff1f\u53ef\u80fd\u662f\u5427","title":"\u95ee\u9898 H: Wifi Setup"},{"location":"question/#j-shrinking","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32","title":"\u95ee\u9898 J: Shrinking"},{"location":"question/#g-colorful-hats","text":"\u7b97\u6cd5\uff1a\u672a\u77e5\uff0c\u8fd8\u6ca1\u8865\u51fa\u6765\uff0c","title":"\u95ee\u9898 G: Colorful Hats"},{"location":"question/#d-scrambled-letters","text":"\u7b97\u6cd5\uff1a\u672a\u77e5\uff0c\u8fd8\u6ca1\u8865\u51fa\u6765\uff0c","title":"\u95ee\u9898 D: Scrambled Letters"},{"location":"question/#202148","text":"","title":"2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c48\u573a"},{"location":"question/#f","text":"\u7b97\u6cd5\uff1a\u6808\u7684\u5e94\u7528","title":"\u95ee\u9898F\uff1a\u62ec\u53f7\u5e8f\u5217"},{"location":"question/#l-a-oror-b-problem","text":"\u7b97\u6cd5\uff1a\u601d\u7ef4\uff0c\u4f4d\u8fd0\u7b97","title":"\u95ee\u9898 L: A or...or B Problem"},{"location":"question/#h-nuske-vs-phantom-thnook","text":"\u7b97\u6cd5\uff1a\u524d\u7f00\u548c\u3001\u6811\u7684\u6027\u8d28","title":"\u95ee\u9898 H: Nuske vs Phantom Thnook"},{"location":"question/#k","text":"\u7b97\u6cd5\uff1a\u5927\u6a21\u62df\uff0c\u53ef\u4ee5\u5148\u653e\u4e00\u653e <script> console.log(\"Hello World!\"); </script> <script> console.log(\"\u4f60\u597d\u554a\uff01\"); </script>","title":"\u95ee\u9898 K: \u5b57\u6bcd\u91d1\u5b57\u5854"},{"location":"question/_coverpage/","text":"Tim-wcx \u00b6 \u4e2a\u4eba\u6587\u6863\u7f51\u7ad9 \u00b6 GitHub Get Started","title":"Tim-wcx"},{"location":"question/_coverpage/#tim-wcx","text":"","title":"Tim-wcx"},{"location":"question/_coverpage/#_1","text":"GitHub Get Started","title":"\u4e2a\u4eba\u6587\u6863\u7f51\u7ad9"},{"location":"question/_sidebar/","text":"\u4e0a\u4e00\u7ea7 ICPC\u9898\u5355","title":" sidebar"}]}