{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u6b22\u8fce\u8bbf\u95ee \u00b6 \u53cb\u60c5\u94fe\u63a5\uff1a \u00b6 \u4e2a\u4eba\u5bfc\u822a\u754c\u9762\uff1a http://ubuntu.tim-wcx.ltd/ Gtihub\u4e3b\u9875\uff1a https://github.com/WCX1024979076 \u4e2a\u4eba\u535a\u5ba2\uff1a https://tim-wcx.ltd/ Github\u535a\u5ba2CDN\uff1a https://blog.tim-wcx.workers.dev/ \u4ee3\u7801paste\uff1a https://paste.tim-wcx.ltd/ \u53c2\u8003\u94fe\u63a5\uff1a \u00b6 Cloudflare rawgithub\u52a0\u901f\uff1a https://rawgithub.tim-wcx.workers.dev/ Github\u56fe\u5e8a\uff1a https://github.com/WCX1024979076/image1 docsify\uff1a https://docsify.js.org/ \u672c\u7ad9\u603b\u8bbf\u95ee\u91cf \u6b21 \u672c\u7ad9\u8bbf\u5ba2\u6570 \u4eba","title":"Home"},{"location":"#_1","text":"","title":"\u6b22\u8fce\u8bbf\u95ee"},{"location":"#_2","text":"\u4e2a\u4eba\u5bfc\u822a\u754c\u9762\uff1a http://ubuntu.tim-wcx.ltd/ Gtihub\u4e3b\u9875\uff1a https://github.com/WCX1024979076 \u4e2a\u4eba\u535a\u5ba2\uff1a https://tim-wcx.ltd/ Github\u535a\u5ba2CDN\uff1a https://blog.tim-wcx.workers.dev/ \u4ee3\u7801paste\uff1a https://paste.tim-wcx.ltd/","title":"\u53cb\u60c5\u94fe\u63a5\uff1a"},{"location":"#_3","text":"Cloudflare rawgithub\u52a0\u901f\uff1a https://rawgithub.tim-wcx.workers.dev/ Github\u56fe\u5e8a\uff1a https://github.com/WCX1024979076/image1 docsify\uff1a https://docsify.js.org/ \u672c\u7ad9\u603b\u8bbf\u95ee\u91cf \u6b21 \u672c\u7ad9\u8bbf\u5ba2\u6570 \u4eba","title":"\u53c2\u8003\u94fe\u63a5\uff1a"},{"location":"_coverpage/","text":"Tim-Wcx \u00b6 \u4e2a\u4eba\u6587\u6863\u7f51\u7ad9 \u00b6 GitHub Get Started","title":"Tim-Wcx"},{"location":"_coverpage/#tim-wcx","text":"","title":"Tim-Wcx"},{"location":"_coverpage/#_1","text":"GitHub Get Started","title":"\u4e2a\u4eba\u6587\u6863\u7f51\u7ad9"},{"location":"_sidebar/","text":"ICPC\u9898\u89e3 ICPC\u6a21\u677f ICPC\u9898\u5355 \u8bfe\u7a0b\u590d\u4e60 csdn\u5bfc\u51fa","title":" sidebar"},{"location":"course/","text":"\u8bfe\u7a0b\u590d\u4e60\u7cfb\u5217","title":"Index"},{"location":"course/_coverpage/","text":"Tim-wcx \u00b6 \u4e2a\u4eba\u6587\u6863\u7f51\u7ad9 \u00b6 GitHub Get Started","title":"Tim-wcx"},{"location":"course/_coverpage/#tim-wcx","text":"","title":"Tim-wcx"},{"location":"course/_coverpage/#_1","text":"GitHub Get Started","title":"\u4e2a\u4eba\u6587\u6863\u7f51\u7ad9"},{"location":"course/_sidebar/","text":"\u4e0a\u4e00\u7ea7 \u8bfe\u7a0b\u590d\u4e60 \u6570\u5b57\u56fe\u50cf\u5904\u7406 \u73b0\u4ee3\u5bc6\u7801\u5b66 \u8f6f\u4ef6\u5de5\u7a0b \u8ba1\u7b97\u673a\u56fe\u5f62\u5b66 \u8ba1\u7b97\u673a\u64cd\u4f5c\u7cfb\u7edf","title":" sidebar"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","text":"\u6570\u5b57\u56fe\u50cf\u5904\u7406\u603b\u590d\u4e60 \u00b6 \u7b2c\u4e00\u7ae0 \u7eea\u8bba \u00b6 \u56fe\u50cf\u548c\u6570\u5b57\u56fe\u50cf \u56fe\u50cf\u4e3a\u53ef\u4ee5\u770b\u4f5c\u662f\u5bf9\u7269\u4f53\u6216\u573a\u666f\u7684\u4e00\u79cd\u8868\u73b0\u5f62\u5f0f\uff0c\u62bd\u8c61\u5b9a\u4e49\uff1a\u4e8c\u7ef4\u51fd\u6570f(x, y) \u6570\u5b57\u56fe\u50cf\u4e3a\u79bb\u6563\u5316\u4e86\u7684\u56fe\u50cf\uff0c\u5373\u5bf9x\uff0cy \u548c f \u8fdb\u884c\u79bb\u6563\u5316 \u6570\u5b57\u56fe\u50cf\u5904\u7406\u6982\u5ff5 1.\u72ed\u4e49\uff08\u8f93\u5165\u548c\u8f93\u51fa\uff09\uff1a\u5bf9\u56fe\u50cf\u8fdb\u884c\u5404\u79cd\u52a0\u5de5\uff0c\u4ee5\u6539\u5584\u56fe\u50cf\u7684\u89c6\u89c9\u6548\u679c\u6216\u7a81\u51fa\u76ee\u6807\uff0c\u5f3a\u8c03\u56fe\u50cf\u4e4b\u95f4\u8fdb\u884c\u7684\u53d8\u6362\uff0c\u662f\u4e00\u4e2a\u4ece\u56fe\u50cf\u5230\u56fe\u50cf\u7684\u8fc7\u7a0b 2.\u5e7f\u4e49\uff1a\u4e0e\u56fe\u50cf\u76f8\u5173\u7684\u5904\u7406\uff08\u56fe\u50cf\u5206\u6790\u3001\u7406\u89e3\u548c\u673a\u5668\u89c6\u89c9\uff09 3.\u5e7f\u4e49\u4e0a\u5206\u4e3a\u4e09\u79cd\u7c7b\u578b\uff1a\u4f4e\u3001\u4e2d\u3001\u9ad8\u7ea7\u5904\u7406 \u200b 1\uff09\u4f4e\u7ea7\u5904\u7406\uff1a\u8f93\u5165\u8f93\u51fa\u90fd\u662f\u56fe\u50cf\uff08\u589e\u5f3a\uff0c\u590d\u539f\uff0c\u7f16\u7801\uff0c\u538b\u7f29\uff09 \u200b 2\uff09\u4e2d\u7ea7\u5904\u7406\uff1a\u56fe\u50cf\u5206\u5272\u53ca\u76ee\u6807\u7684\u63cf\u8ff0\uff0c\u8f93\u51fa\u662f\u76ee\u6807\u7684\u7279\u5f81\u6570\u636e \uff08\u68c0\u6d4b\uff0c\u5206\u5272\uff09 \u200b 3\uff09\u9ad8\u7ea7\u5904\u7406\uff1a\u76ee\u6807\u7269\u4f53\u53ca\u76f8\u4e92\u5173\u7cfb\u7684\u7406\u89e3\uff0c\u8f93\u51fa\u662f\u66f4\u62bd\u8c61\u7684\u6570\u636e\uff08\u5206\u7c7b\uff0c\u8bc6\u522b\uff0c\u89e3\u91ca\uff09 \u56fe\u50cf\u5904\u7406\u4e3b\u8981\u662f\u4f4e\u7ea7\u5904\u7406\u53ca\u90e8\u5206\u4e2d\u7ea7\u5904\u7406\u3002 \u7b2c\u4e8c\u7ae0 \u6570\u5b57\u56fe\u50cf\u57fa\u7840 \u00b6 \u56fe\u50cf\u83b7\u53d6 \u4eba\u7c7b\u89c6\u89c9\u7cfb\u7edf\u3001\u5149\u548c\u7535\u78c1\u6ce2\u7406\u8bba\u662f\u6570\u5b57\u56fe\u50cf\u6765\u6e90\u7684\u57fa\u7840 \u4eae\u5ea6\u6210\u50cf\u6a21\u578b 2-D\u4eae\u5ea6\u51fd\u6570\uff1af (x, y)=r (x, y) (\u6ce8\uff1a\u53cd\u5c04\u6210\u5206) * i (x, y) (\u6ce8\uff1a\u7167\u5ea6\u6210\u5206) \u89c6\u7f51\u819c\u4e2d\u592e\u7684\u201c\u89c6\u9525\u7ec6\u80de\u89c6\u89c9\u201d\u548c\u89c6\u7f51\u819c\u8fb9\u7f18\u7684\u201c\u89c6\u6746\u7ec6\u80de\u89c6\u89c9\u201d\uff0c\u4e5f\u53eb\u505a\u660e\u89c6\u89c9\u548c\u6697\u89c6\u89c9\u3002 \u9525\u72b6\u7ec6\u80de\u8d1f\u8d23\u611f\u53d7\u989c\u8272\u4fe1\u606f\u7684\u3002 \u56fe\u50cf\u6570\u5b57\u5316 \u5c06\u4ee3\u8868\u56fe\u50cf\u7684\u8fde\u7eed(\u6a21\u62df)\u4fe1\u53f7\u8f6c\u6362\u4e3a\u79bb\u6563(\u6570\u5b57)\u4fe1\u53f7\u7684\u8fc7\u7a0b\u79f0\u4e3a\u56fe\u50cf\u6570\u5b57\u5316 \u6b65\u9aa4\uff1a\u91c7\u6837\u548c\u91cf\u5316 \u4e3b\u8981\u6280\u672f\uff1a 1) \u6210\u50cf\uff1a\u5149\u4fe1\u606f\uff0d>\u7535\u4fe1\u53f7 2) \u6a21\u6570\u8f6c\u6362\uff08A/D Converter \uff09 \u56fe\u50cf\u91c7\u6837\u548c\u91cf\u5316 \u91c7\u6837\u662f\u5747\u5300\u7684\uff0c\u91cf\u5316\u53ef\u4ee5\u5747\u5300\uff0c\u53ef\u4ee5\u975e\u5747\u5300\u3002 \u91c7\u6837\u548c\u91cf\u5316\u662f\u56fe\u50cf\u83b7\u53d6\u4e2d\u7684\u4e24\u5927\u6280\u672f\u3002 \u7a7a\u95f4\u548c\u7070\u5ea6\u5206\u8fa8\u7387\u662f\u56fe\u50cf\u7684\u57fa\u672c\u5c5e\u6027 1\uff09\u91c7\u6837 \u7a7a\u95f4\u5750\u6807\u7684\u79bb\u6563\u5316\u79f0\u4e3a\u7a7a\u95f4\u91c7\u6837\uff0c\u7b80\u79f0\u91c7\u6837\uff0c\u786e\u5b9a\u4e86\u56fe\u50cf\u7684\u7a7a\u95f4\u5206\u8fa8\u7387 \u5373\u7528\u7a7a\u95f4\u4e0a\u90e8\u5206\u70b9\u7684\u7070\u5ea6\u503c\u4ee3\u8868\u56fe\u50cf\u3002\u8fd9\u4e9b\u70b9\u79f0\u4e3a\u91c7 \u6837\u70b9 \u65b9\u5f0f\u4e3a\u70b9\u9635\u91c7\u6837\uff1a\u76f4\u63a5\u5bf9\u8868\u793a\u56fe\u50cf\u7684\u4e8c\u7ef4\u51fd\u6570\u503c\u8fdb\u884c\u91c7\u6837\uff0c \u6240\u5f97\u7684\u7ed3\u679c\u5c31\u662f\u4e00\u4e2a\u6837\u70b9\u503c\u5e8f\u5217 2\uff09\u91cf\u5316 \u5bf9\u91c7\u6837\u70b9\u4eae\u5ea6\uff08\u7070\u5ea6\uff09\u503c\u7684\u79bb\u6563\u5316\u8fc7\u7a0b\u3002\u786e\u5b9a\u4e86\u56fe\u50cf \u7684\u7070\uff08\u5e45\uff09\u5ea6\u5206\u8fa8\u7387 \u4e24\u79cd\u91cf\u5316\uff1a\u5747\u5300\u91cf\u5316\u3001\u975e\u5747\u5300\u91cf\u5316 \u5747\u5300\u91cf\u5316: \u5c06\u6837\u70b9\u7070\u5ea6\u7ea7\u503c\u7b49\u95f4\u9694\u5206\u6863\u53d6\u6574\uff0c\u79f0\u4e3a\u5747\u5300\u91cf\u5316 \u975e\u5747\u5300\u91cf\u5316: \u5c06\u6837\u70b9\u7070\u5ea6\u7ea7\u503c\u4e0d\u7b49\u95f4\u9694\u5206\u6863\u53d6\u6574 3\uff09\u91c7\u6837\u548c\u91cf\u5316\u7684\u7ea7\u6570 \u5047\u5b9a\u56fe\u50cf\u53d6M\u00d7N\u4e2a\u91c7\u6837\u70b9\uff0c\u5bf9\u6837\u672c\u70b9\u7070\u5ea6\u503c\u8fdb\u884cG\u7ea7\u5206\u6863\u53d6\u6574 \u2013 M, N, G \u4e00\u822c\u53d62\u7684\u6574\u6570\u6b21\u5e42 \u2013M= 2^m 2^m \uff1bN= 2^n 2^n \uff1bG= 2^k 2^k \u50cf\u7d20\u7a7a\u95f4\u7684\u5173\u7cfb 1\uff09\u50cf\u7d20\u7684\u90bb\u57df\u4e0e\u8fde\u63a5 \u90bb\u63a5---\u50cf\u7d20\u95f4\u7684\u7a7a\u95f4\u5173\u7cfb \u2460 \u56db\u90bb\u57df N_4(p),p(x,y)=(x+1,y),(x-1,y),(x,y+1),(x,y-1) N_4(p),p(x,y)=(x+1,y),(x-1,y),(x,y+1),(x,y-1) \u2461 \u5bf9\u89d2\u90bb\u57df N_D(p):p(x,y)=(x-1,y-1),(x+1,y-1),(x-1,y+1),(x+1,y+1) N_D(p):p(x,y)=(x-1,y-1),(x+1,y-1),(x-1,y+1),(x+1,y+1) \u2462 8-\u90bb\u57df N_8(P):p(x,y)=N_4(p)+N_D(p) N_8(P):p(x,y)=N_4(p)+N_D(p) 2\uff09\u8fde\u63a5 \u8fde\u63a5\uff1a\u7a7a\u95f4\u4e0a\u90bb\u63a5\u4e14\u50cf\u7d20\u7070\u5ea6\u503c\u76f8\u4f3c \u4e24\u4e2a\u50cf\u7d20\u662f\u5426\u8fde\u63a5\uff1a (1) \u662f\u5426\u63a5\u89e6\uff08\u90bb\u63a5\uff09 (2) \u7070\u5ea6\u503c\u662f\u5426\u6ee1\u8db3\u67d0\u4e2a\u7279\u5b9a\u7684\u76f8\u4f3c\u51c6\u5219 \u7070\u5ea6\u503c\u76f8\u7b49 \u6216 \u540c\u5728\u4e00\u4e2a\u7070\u5ea6\u503c\u96c6\u5408\u4e2d \u4e09\u79cd\u8fde\u63a5\u65b9\u5f0f\uff0c\u5047\u8bbeV\u4e3a\u7070\u5ea6\u503c\u96c6\u5408 \u2460 4-\u8fde\u63a5 2\u4e2a\u50cf\u7d20 p \u548c r \u5728V \u4e2d\u53d6\u503c \u4e14 r \u5728N4 (p)\u4e2d \u2461 8-\u8fde\u63a5 2\u4e2a\u50cf\u7d20 p \u548c r \u5728V \u4e2d\u53d6\u503c \u4e14 r \u5728N8 (p)\u4e2d \u2462 m-\u8fde\u63a5\uff08\u6df7\u5408\u8fde\u63a5\uff09 2\u4e2a\u50cf\u7d20 p \u548c r \u5728V \u4e2d\u53d6\u503c\uff0c\u4e14\u6ee1\u8db3\u4e0b\u5217\u6761\u4ef6\u4e4b\u4e00 (a) r \u5728 N_4 (p) N_4 (p) \u4e2d (b) r \u5728 N_D (p) N_D (p) \u4e2d\u4e14\u96c6\u5408 N_4 (p) \u2229 N_4 (r) N_4 (p) \u2229 N_4 (r) \u662f\u7a7a\u96c6 \uff08\u8fd9\u4e2a\u96c6\u5408\u662f\u7531 p \u548c r \u7684\u5728V\u4e2d\u53d6\u503c\u76844-\u8fde\u63a5\u50cf\u7d20\u7ec4\u6210\u7684\uff09 3\uff09\u8fde\u901a\u6027 \u50cf\u7d20\u7684\u8fde\u901a \u2013 \u53cd\u6620\u4e24\u4e2a\u50cf\u7d20\u95f4\u7684\u7a7a\u95f4\u5173\u7cfb \u901a\u8def\u548c\u8fde\u901a\uff0c\u79cd\u7c7b\u5206\u4e3a\u56db\u8fde\u901a\uff0c\u516b\u8fde\u901a\uff0cm\u8fde\u901a 4\uff09\u8ddd\u79bb\u5ea6\u91cf \u8ddd\u79bb\u51fd\u6570\u5b9a\u4e49\uff1a \u5bf9\u4e8e\u50cf\u7d20p, q\u548cz, \u5206\u522b\u5177\u6709\u5750\u6807(x, y), (s, t), (u, v), \u5982\u679c\uff1a (a) D(p, q)\u22650 [D(p, q)= 0, \u5f53\u4e14\u4ec5\u5f53 p=q] (b) D(p, q)= D(q, p) \u00a9 D(p, z) \u2264 D(p, q) + D(q, z) \u5219D\u662f\u8ddd\u79bb\u51fd\u6570\u6216\u5ea6\u91cf \u2460 \u6b27\u6c0f\u8ddd\u79bb D_e(p,q)=[(x-s)^2+(y-t)^2]^{1/2} D_e(p,q)=[(x-s)^2+(y-t)^2]^{1/2} \u2461 D4\u8ddd\u79bb\uff08\u57ce\u5e02\u8ddd\u79bb\uff09 D_4( p,q) = |x \u2212 s| + |y \u2212t| D_4( p,q) = |x \u2212 s| + |y \u2212t| \u2462 D8\u8ddd\u79bb\uff08\u68cb\u76d8\u8ddd\u79bb\uff09 D_8(p,q) = max(|x \u2212 s|,| y \u2212t|) D_8(p,q) = max(|x \u2212 s|,| y \u2212t|) \u6ce8\u610f\uff1a De\u8ddd\u79bb\u4e0e\u50cf\u7d20\u7684\u70b9\u5750\u6807\u76f8\u5173\uff0c\u4e0e\u50cf\u7d20\u95f4\u7684\u8fde\u901a\u6027\u65e0\u5173 D4\u548cD8\u8ddd\u79bb\u53ef\u4ee5\u770b\u4f5c\u662f\u901a\u8def\u4e0a\u8fde\u63a5\u7684\u6570\u76ee\u6700\u5c0f\u503c \u5bf9\u4e8eD4\u3001D8\u548cDm\uff0c\u5982\u679c\u50cf\u7d20p\u548cq\u95f4\u65e0\u8fde\u63a5\uff0c\u5219\u8ddd\u79bb\u662f\u65e0\u7a77\u5927 \u4ee5\u540e\u7684\u8ddd\u79bb\u9690\u542b\u8fde\u901a\u6027 \u56fe\u50cf\u7684\u8fd0\u7b97 \u52a0\u6cd5\uff1aC(x, y) = A(x, y) + B(x, y) \u51cf\u6cd5\uff1aC(x, y) = A(x, y) - B(x, y) \u4e58\u6cd5\uff1aC(x, y) = A(x, y) * B(x, y) \u6c42\u53cd\uff1ag(x, y) = 255 - f(x, y) \u5f02\u6216\uff1ag(x, y) = f(x, y) \u2295 h(x, y) \u6216\u8fd0\u7b97\uff1ag(x, y) = f(x, y) | h(x, y) \u4e0e\u8fd0\u7b97\uff1a g(x, y) = f(x, y) & h(x, y) \u56fe\u50cf\u5185\u63d2 \u56fe\u50cf\u5185\u63d2\uff1a\u653e\u5927\uff0c\u6536\u7f29\uff0c\u65cb\u8f6c\uff0c\u51e0\u4f55\u77eb\u6b63 \u653e\u5927\u8fc7\u7a0b\uff1a \u00bb \u539f\u6765\u56fe\u50cf\u5206\u8fa8\u7387\u4e3am\u00d7n \u00bb \u5c06\u56fe\u50cf\u653e\u59271.5\u500d\u4e4b\u540e\uff0c\u5177\u67091.5m\u00d71.5n= 2.25m\u00d7n\u4e2a\u50cf\u7d20 \u00bb \u4e0e\u539f\u6765\u56fe\u50cf\u5177\u6709\u76f8\u540c\u7684\u50cf\u7d20\uff0c\u50cf\u7d20\u6570\u91cf\u662f\u539f\u67652.25\u500d \u00bb \u5c06\u5176\u6536\u7f29\uff0c\u4e0e\u539f\u6765\u56fe\u50cf\u5339\u914d \u00bb \u50cf\u7d20\u95f4\u9694\u5c0f\u4e8e\u539f\u6765\u56fe\u50cf\u50cf\u7d20\u95f4\u9694 \u00bb \u4ece\u539f\u6765\u56fe\u50cf\u50cf\u7d20\u503c\u63d0\u53d6\u4fe1\u606f\u8d4b\u7ed9\u65b0\u56fe\u50cf\u76f8\u5e94\u50cf\u7d20 \u56fe\u50cf\u5185\u63d2\u7684\u4e3b\u8981\u65b9\u6cd5 \u6700\u8fd1\u90bb\u5185\u63d2\u6cd5 \u53cc\u7ebf\u6027\u5185\u63d2\u6cd5 \u53cc\u4e09\u6b21\u5185\u63d2\u6cd5\u3002 \u56fe\u50cf\u7cfb\u7edf \u56fe\u50cf\u5904\u7406\u7cfb\u7edf\u5177\u6709\u56fe\u50cf\u8f93\u5165\u3001\u8f93\u51fa\u3001\u5b58\u50a8\u548c\u5904\u7406\u529f\u80fd\u3002 \u56fe\u50cf\u4e4b\u95f4\u7684\u56db\u5219\u8fd0\u7b97\uff0c\u53ea\u8981\u76f4\u63a5\u8fd0\u7b97\u5c31\u884c\u3002--\u9700\u5bf9\u8d85\u51fa\u7070\u5ea6\u8303\u56f4\u7684\u50cf\u7d20\u8fdb\u884c\u5904\u7406\u3002 \u7b2c\u4e09\u7ae0 \u7a7a\u57df\u589e\u5f3a\u6280\u672f \u00b6 \u7a7a\u57df\u589e\u5f3a\u57fa\u7840 \ud835\udc88(\ud835\udc99, \ud835\udc9a)= \ud835\udc7b[\ud835\udc87(\ud835\udc99, y)] \ud835\udc88(\ud835\udc99, \ud835\udc9a)= \ud835\udc7b[\ud835\udc87(\ud835\udc99, y)] \u5176\u4e2d\ud835\udc87(\ud835\udc99, \ud835\udc9a) \u662f\u8f93\u5165\u56fe\u50cf\uff0c \ud835\udc88(\ud835\udc99, \ud835\udc9a) \u662f\u5904\u7406\u540e\u56fe\u50cf \ud835\udc7b\u662f\u5728\u70b9 (\ud835\udc99, \ud835\udc9a) \u90bb\u57df\u4e0a\u5b9a\u4e49\u7684\u5173\u4e8e\ud835\udc87\u7684\u589e\u5f3a\u64cd\u4f5c\u3002 \u7a7a\u57df\u589e\u5f3a\u8ba1\u7b97\u8fc7\u7a0b\uff1a-\u904d\u5386\u56fe\u50cf\u6240\u6709\u50cf\u7d20 \u2013 \u6bcf\u4e2a\u50cf\u7d20\u5904\uff0c\u7528T\u8ddf\u4ee5(x,y)\u4e3a\u4e2d\u5fc3\u7684\u90bb\u57df\u8fdb\u884c\u8ba1\u7b97 \u2013 \u8fb9\u7f18\u5904\u7406\uff1a\u586b\u96f6 \u76f4\u63a5\u7070\u5ea6\u6620\u5c04 \u5c06 f (x, y)\u4e2d\u7684\u6bcf\u4e2a\u50cf\u7d20\u7070\u5ea6\u6309\ud835\udc7b\u64cd\u4f5c\u76f4\u63a5\u53d8\u6362\u4ee5\u5f97\u5230 g(x, y) \u5178\u578b\u65b9\u6cd5\uff1a \u5bf9\u6570\u53d8\u6362 s=c*log(r+1) s=c*log(r+1) \u6307\u6570\u53d8\u6362 s=cr^{\\gamma} s=cr^{\\gamma} \u03b3>1\u4f4e\u7070\u5ea6\u538b\u7f29\uff0c\u9ad8\u7070\u5ea6\u62c9\u4f38 \u03b3<1\u4f4e\u7070\u5ea6\u62c9\u4f38\uff0c\u9ad8\u7070\u5ea6\u538b\u7f29 \u03b3=1\u5c31\u662f\u6052\u7b49\u53d8\u6362 \u76f4\u65b9\u56fe\u53d8\u6362 \u76f4\u65b9\u56fe\uff08Histogram \uff09 \u6570\u5b57\u56fe\u50cf\u4e2d\u6bcf\u4e00\u7070\u5ea6\u7ea7\uff0c\u5b83\u51fa\u73b0\u7684\u9891\u6570\u7684\u7edf\u8ba1 \u63d0\u4f9b\u4e86\u56fe\u50cf\u50cf\u7d20\u7684\u7070\u5ea6\u503c\u5206\u5e03\u60c5\u51b5 1\uff09\u76f4\u65b9\u56fe\u5747\u8861\u5316 \u76f4\u65b9\u56fe\u5747\u8861\u5316\uff1a\u6307\u56fe\u50cf\u7ecf\u7070\u5ea6\u53d8\u6362\u540e\uff0c\u4f7f\u5f97\u7070\u5ea6\u7684\u6982\u7387\u5bc6\u5ea6\u5206\u5e03\u53d8\u4e3a\u5e38 \u6570\uff0c\u5373\u5747\u5300\u5206\u5e03 \u6ce8\uff1a\u5728\u8be5\u76f4\u65b9\u56fe\u4e2d\uff0c\u5171\u67098\u949f\u7070\u5ea6\uff0c\u5373L=8\u3002 2\uff09\u76f4\u65b9\u56fe\u89c4\u5b9a\u5316 \u901a\u8fc7\u6307\u5b9a\u7684\u51fd\u6570\u5c06\u539f\u56fe\u50cf\u7684\u7070\u5ea6\u76f4\u65b9\u56fe\u53d8\u6362\u6210\u53e6\u4e00\u79cd\u5206\u5e03\u7684\u7070\u5ea6\u76f4\u65b9\u56fe\uff0c\u5373\u786e\u5b9a\u4e00\u4e2aT\u51fd\u6570\uff0c\u6839\u636e\u8fd9\u4e2a\u76f4\u65b9\u56fe\u786e\u5b9a\u4e00\u7070\u5ea6\u7ea7\u53d8\u6362 T\u00ae, \u4f7f\u7531 T\u4ea7\u751f\u7684 \u65b0\u56fe\u8c61\u7684\u76f4\u65b9\u7b26\u5408\u6307\u5b9a\u7684\u76f4\u65b9\u56fe\u3002 3\uff09\u5c40\u90e8\u76f4\u65b9\u56fe\u5904\u7406 \u6709\u65f6\u9700\u8981\u5bf9\u56fe\u50cf\u5c0f\u533a\u57df\u7ec6\u8282\u7684\u5c40\u90e8\u589e\u5f3a\u3002\u89e3\u51b3\u7684\u529e\u6cd5\u5c31\u662f\u5728\u56fe\u50cf\u4e2d\u6bcf\u4e00\u4e2a\u7d20\u7684\u90bb\u57df\u5c31\u662f\u5728\u56fe\u50cf\u4e2d\uff0c\u6839\u636e\u7070\u5ea6\u7ea7\u5206\u5e03 \u8bbe\u8ba1\u53d8\u6362\u51fd\u6570\u3002\u7136\u540e\u5229\u7528\u524d\u9762\u4ecb\u7ecd\u7684\u6280\u672f\u6765\u8fdb\u884c\u5c40\u90e8\u589e\u5f3a\u3002 \u7ebf\u6027\u6ee4\u6ce2 \u6ee4\u6ce2\u5668\u53ef\u5206\u4e3a\u7ebf\u6027\u6ee4\u6ce2\u5668\u548c\u975e\u7ebf\u6027\u6ee4\u6ce2\u5668\uff0c\u9510\u5316\u548c\u5e73\u6ed1\u3002 \u975e\u7ebf\u6027\u6ee4\u6ce2\u5668\u4f5c\u7528\uff1a\u65e2\u6d88\u9664\u566a\u58f0\u53c8\u4fdd\u6301\u7ec6\u8282\uff08\u4e0d\u6a21\u7cca\uff09 \u5e38\u89c1\u6ee4\u6ce2\u5668\uff1a \u90bb\u57df\u5e73\u5747 --\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u6a21\u7248\u7cfb\u6570\u90fd\u662f\u6b63\u7684\uff0c\u4fdd\u6301\u7070\u5ea6\u503c\u8303\u56f4\uff08\u7cfb\u6570\u4e4b\u548c\u4e3a1\uff09 z=\\frac{1}{M} \\sum ^{M-1}_{i=0} (k_i*s_i) z=\\frac{1}{M} \\sum ^{M-1}_{i=0} (k_i*s_i) M\u7684\u5927\u5c0f\u4e0d\u540c\uff0c\u5e73\u6ed1\u7684\u6548\u679c\u4e5f\u4e0d\u540c\u3002 \u6a21\u677f\u5c3a\u5bf8\u589e\u5927\u65f6\uff0c\u5bf9\u566a\u58f0\u6d88\u9664\u6548\u679c\u589e\u5f3a\uff0c\u4f46\u56fe\u50cf\u53d8\u5f97\u6a21\u7cca\uff0c\u5373\u8fb9\u7f18\u7ec6\u8282\u51cf\u5c11\u3002 \u52a0\u6743\u5e73\u5747 --\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u4e0d\u540c\u4f4d\u7f6e\u7684\u7cfb\u6570\u91c7\u7528\u4e0d\u540c\u7684\u503c\uff0c\u4e00\u822c\u8ba4\u4e3a\uff1a\u79bb\u6a21\u677f\u4e2d\u5fc3\u8fd1\u7684\u50cf\u7d20\u5bf9\u6ee4\u6ce2\u8d21\u732e\u5927\uff0c\u6240\u4ee5\u7cfb\u6570\u5927\uff1b \u800c\u5468\u56f4\u7cfb\u6570\u5c0f\u3002 \u4e2d\u503c\u6ee4\u6ce2\u5668 --\u975e\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u5c06\u6a21\u677f\u4e2d\u5fc3\u4e0e\u50cf\u7d20\u4f4d\u7f6e\u91cd\u5408\uff0c\u8bfb\u53d6\u6a21\u677f\u4e0b\u5404\u5bf9\u5e94\u50cf\u7d20\u7684\u7070\u5ea6\u503c\uff0c\u5c06\u8fd9\u4e9b\u7070\u5ea6\u503c\u4ece\u5c0f\u5230\u5927\u6392\u6210 1\u5217\uff0c\u627e\u51fa\u8fd9\u4e9b\u503c\u91cc\u6392\u5728\u4e2d\u95f4\u7684 1\u4e2a\uff0c\u5c06\u8fd9\u4e2a\u4e2d\u95f4\u503c\u8d4b\u7ed9\u6a21\u677f\u5fc3\u4f4d\u7f6e\u50cf\u7d20\u3002 \u4e2d\u503c\u6ee4\u6ce2\u5668\u7684\u6d88\u566a\u58f0\u6548\u679c\u4e0e\u6a21\u677f\u7684\u5c3a\u5bf8\u548c\u53c2\u4e0e\u8fd0\u7b97\u7684\u50cf\u7d20\u6570\u6709\u5173\u3002 \u56fe\u50cf\u4e2d\u5c3a\u5bf8\u5c0f\u4e8e\u6a21\u677f\u5c3a\u5bf8\u4e00\u534a\u7684\u8fc7\u4eae\u6216\u8fc7\u6697\u533a\u57df\u5c06\u4f1a\u5728\u6ee4\u6ce2\u540e\u4f1a\u88ab\u6d88\u9664\u6389\u3002 \u767e\u5206\u6bd4\u6ee4\u6ce2\u5668 --\u975e\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u6700\u5927\u503c\u6ee4\u6ce2\u5668\uff1a g_{max}(x,y)=max_{(s,t)\u2208N(x,y)}[f(s,t)] g_{max}(x,y)=max_{(s,t)\u2208N(x,y)}[f(s,t)] \u6700\u5c0f\u503c\u6ee4\u6ce2\u5668\uff1a g_{min}(x,y)=min_{(s,t)\u2208N(x,y)}[f(s,t)] g_{min}(x,y)=min_{(s,t)\u2208N(x,y)}[f(s,t)] \u4e2d\u70b9\u6ee4\u6ce2\u5668\uff1a g_{mid}(x,y)=\\frac{1}{2}(g_{max}(x,y)+g_{min}(x,y)) g_{mid}(x,y)=\\frac{1}{2}(g_{max}(x,y)+g_{min}(x,y)) \u68af\u5ea6\u6ee4\u6ce2\u5668 --\u975e\u7ebf\u6027\u9510\u5316\u6ee4\u6ce2\u5668 \u5404\u5411\u5f02\u6027\uff0c\u5728X\u548cY\u4e24\u4e2a\u65b9\u5411\u4e0d\u540c\u3002 \u200b \u68af\u5ea6\u66ff\u4ee3\u8ba1\u7b97\u65b9\u6cd5 \u62c9\u666e\u62c9\u65af\u7b97\u5b50\uff0c\u4e8c\u9636\u5bfc\u6570 --\u975e\u7ebf\u6027\u9510\u5316\u6ee4\u6ce2\u5668 \u5fae\u5206\u7b97\u5b50\uff0c\u4f7f\u7528\u540e\u589e\u5f3a\u4e86\u56fe\u50cf\u4e2d\u7070\u5ea6\u7684\u7a81\u53d8\uff0c\u4e0d\u7ea7\u7f13\u6162\u53d8\u5316\u533a\u57df \u628a\u539f\u56fe\u50cf\u4e0e laplace laplace \u56fe\u50cf\u7ebf\u6027\u7ec4\u5408\uff0c\u53ef\u4ee5\u540c\u65f6\u4fdd\u6301 laplace laplace laplace\u9510\u5316\u548c\u539f\u56fe\u50cf\u80cc\u666f\u3002 \u5982\u679c laplace \u7b97\u5b50\u4e2d\u5fc3\u7cfb\u6570\u4e3a\u6b63\uff0c\u5219\u7528\u539f\u56fe\u50cf\u52a0\u4e0a laplace \u56fe\u50cf\uff1b \u5982\u679c laplace \u7b97\u5b50\u4e2d\u5fc3\u7cfb\u6570\u4e3a\u8d1f\uff0c\u5219\u7528\u539f\u56fe\u50cf\u51cf\u53bb laplace\u56fe\u50cf\u3002 \u5c40\u90e8\u589e\u5f3a \u7a7a\u95f4\u57df\u5c40\u90e8\u589e\u5f3a-\u5c40\u90e8\u9009\u62e9\u6839\u636e\u5b9e\u9645\u95ee\u9898\u8981\u6c42\u7075\u6d3b\u8bbe\u5b9a\u3002 \u5bf9\u56fe\u50cf\u5c40\u90e8\u7ec6\u8282\u7684\u589e\u5f3a\u5904\u7406 \u56fe\u50cf\u7684\u7edf\u8ba1\u91cf\uff1a \u7070\u5ea6\u5e73\u5747\u503c m=\\sum^{L-1}_{i=0}r_i*p(r_i) m=\\sum^{L-1}_{i=0}r_i*p(r_i) \u65b9\u5dee\uff08\u4e8c\u9636\u77e9\uff09 \\mu_2(r)=\\sum^{L-1}_{i=0}(r_i-m)^2p(r_i) \\mu_2(r)=\\sum^{L-1}_{i=0}(r_i-m)^2p(r_i) r\u7684n\u9636\u77e9\uff1a \\mu_n(r)=\\sum^{L-1}_{i=0}(r_i-m)^np(r_i) \\mu_n(r)=\\sum^{L-1}_{i=0}(r_i-m)^np(r_i) \u5c40\u90e8\u589e\u5f3a\u7684\u65b9\u6cd5\uff1a g(x,y)=A(x,y)[f(x,y)-m(x,y)]+m(x,y),\u5176\u4e2dA(x,y)=\\frac{k*M}{\\sigma(x,y)} g(x,y)=A(x,y)[f(x,y)-m(x,y)]+m(x,y),\u5176\u4e2dA(x,y)=\\frac{k*M}{\\sigma(x,y)} M\u4e3af(x,y)\u7684\u5747\u503c,m(x,y)\u548c\\sigma(x,y)\u4e3a\u4ee5(x,y)\u4e3a\u4e2d\u5fc3\u90bb\u57df\u5185\u7684\u5747\u503c\u548c\u5747\u65b9\u5dee\u503c M\u4e3af(x,y)\u7684\u5747\u503c,m(x,y)\u548c\\sigma(x,y)\u4e3a\u4ee5(x,y)\u4e3a\u4e2d\u5fc3\u90bb\u57df\u5185\u7684\u5747\u503c\u548c\u5747\u65b9\u5dee\u503c \u57fa\u4e8e\u5c40\u90e8\u7edf\u8ba1\u7684\u589e\u5f3a\u65b9\u6cd5\uff1a \u4ee4 (x,y) (x,y) \u4e3a\u4e00\u50cf\u7d20\u5750\u6807\uff0c S_{xy} S_{xy} \u8868\u793a\u4e00\u786e\u5b9a\u5927\u5c0f\u7684\u90bb\u57df\uff08\u5b50\u56fe\u50cf\uff09\uff0c\u5219 S_{xy} S_{xy} \u7684\u5e73\u5747\u503c m_{xy} m_{xy} \u4e3a\uff1a m_{xy}=\\sum_{(s,t)\u2208(S_{xy}))}(r_{s,t}\u00d7p(r_{s,t})) m_{xy}=\\sum_{(s,t)\u2208(S_{xy}))}(r_{s,t}\u00d7p(r_{s,t})) S_{xy} S_{xy} \u4e2d\u50cf\u7d20\u7684\u65b9\u5dee\u4e3a\uff1a \\sigma^2_{S_{xy}}=\\sum^{(L-1)}_{(s,t)\u2208S_{xy}}\\{[r_{s,t}-m_{s_{xy}}]^2\u00d7p(s_{s,t})\\} \\sigma^2_{S_{xy}}=\\sum^{(L-1)}_{(s,t)\u2208S_{xy}}\\{[r_{s,t}-m_{s_{xy}}]^2\u00d7p(s_{s,t})\\} \u6839\u636e\u4eae\u6697\u548c\u5bf9\u6bd4\u5ea6\u6765\u5224\u65ad\u662f\u5426\u589e\u5f3a\u67d0\u4e00\u70b9\u7684\u4eae\u5ea6\uff0c\u7136\u540e\u5bf9\u5176\u8fdb\u884c\u589e\u5f3a \u4ee4\u6761\u4ef6T=m_{s_{xy}}<=k_0*M_G,k_0<=1.0\u4e14k_1D_G<=\\sigma_{S_{xy}}<=k_2D_G,k_1<=k_2 \u4ee4\u6761\u4ef6T=m_{s_{xy}}<=k_0*M_G,k_0<=1.0\u4e14k_1D_G<=\\sigma_{S_{xy}}<=k_2D_G,k_1<=k_2 g(x,y)=T?E*f(x,y):f(x,y) g(x,y)=T?E*f(x,y):f(x,y) \u7b2c\u56db\u7ae0 \u9891\u57df\u5904\u7406 \u00b6 \u5085\u91cc\u53f6\u53d8\u6362 \u65f6\u57df\u56fe\u50cf\u662f\u4e00\u4e2a\u5468\u671f\u4e14\u8fde\u7eed\u7684\u51fd\u6570\uff0c\u9891\u57df\u56fe\u50cf\u548c\u76f8\u4f4d\u56fe\u50cf\u662f\u4e00\u4e2a\u975e\u5468\u671f\u79bb\u6563\u7684\u51fd\u6570\u3002 \u6b27\u62c9\u516c\u5f0f\uff1a e^{ix}=cos(x)+i*sin(x) e^{ix}=cos(x)+i*sin(x) \u5085\u91cc\u53f6\u53d8\u6362\u7684\u5b9a\u4e49 1\uff09\u4e00\u7ef4\u5085\u91cc\u53f6\u53d8\u6362 \u8fde\u7eed\u51fd\u6570 \u6b63\u53d8\u6362 F\\{f(x)\\}=F(u)=\\int^{+\\infty}_{-\\infty}f(x)e^{-j2*\\pi ux}dx F\\{f(x)\\}=F(u)=\\int^{+\\infty}_{-\\infty}f(x)e^{-j2*\\pi ux}dx \u9006\uff08\u53cd\uff09\u53d8\u6362 f(x)=\\int^{+\\infty}_{-\\infty}F(u)e^{j*2\\pi ux}du f(x)=\\int^{+\\infty}_{-\\infty}F(u)e^{j*2\\pi ux}du \u79bb\u6563\u51fd\u6570 \u6b63\u53d8\u6362 F\\{f(x)\\}=F(u)=\\sum^{N-1}_{x=0}f(x)e^{-2j\\pi ux/N} F\\{f(x)\\}=F(u)=\\sum^{N-1}_{x=0}f(x)e^{-2j\\pi ux/N} \u9006\uff08\u53cd\uff09\u53d8\u6362 F^{-1}\\{f(x)\\}=f(x)=\\frac{1}{N}\\sum^{N-1}_{x=0}F(u)e^{2j\\pi ux} F^{-1}\\{f(x)\\}=f(x)=\\frac{1}{N}\\sum^{N-1}_{x=0}F(u)e^{2j\\pi ux} u=0,1,2,...,N-1 u=0,1,2,...,N-1 2\uff09\u4e8c\u7ef4\u5085\u91cc\u53f6\u53d8\u6362 \u8fde\u7eed\u51fd\u6570 \u6b63\u53d8\u6362 F\\{f(x,y)\\}=F(u,v)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} f(x,y)e^{-j2\\pi ux}dxdy F\\{f(x,y)\\}=F(u,v)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} f(x,y)e^{-j2\\pi ux}dxdy \u9006\uff08\u53cd\uff09\u53d8\u6362 F^{-1}\\{f(x,y)\\}=f(x,y)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} F(u,v)e^{j2\\pi ux}dudv F^{-1}\\{f(x,y)\\}=f(x,y)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} F(u,v)e^{j2\\pi ux}dudv \u79bb\u6563\u51fd\u6570 \u6b63\u53d8\u6362 F(u,v)=\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} f(x,y) e^{-j2\\pi (ux/M+vy/N)} F(u,v)=\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} f(x,y) e^{-j2\\pi (ux/M+vy/N)} u=0,1,2,...,M-1,v=0,1,2,...,N-1 u=0,1,2,...,M-1,v=0,1,2,...,N-1 \u9006\u53d8\u6362 f(x,y)=\\frac{1}{MN}\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} F(u,v) e^{j2\\pi (ux/M+vy/N)} f(x,y)=\\frac{1}{MN}\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} F(u,v) e^{j2\\pi (ux/M+vy/N)} x=0,1,2,...,M-1,y=0,1,2,...,N-1 x=0,1,2,...,M-1,y=0,1,2,...,N-1 3\uff09\u9891\u8c31\u57df \u5b9a\u4e49\uff1a\u7531\u5085\u7acb\u53f6\u53d8\u6362\u548c\u9891\u7387\u53d8\u91cf( u, v)\u5b9a\u4e49\u7684\u7a7a\u95f4 \u6027\u8d28\uff1a \u53d8\u6362\u6700\u6162\u7684\u9891\u7387\u6210\u5206(u=0,v=0)\u5bf9\u5e94\u4e00\u5e45\u56fe\u50cf\u7684\u5e73\u5747\u7070\u5ea6\uff0c\u8bc1\u660e\u4e3a\uff1a F(0,0)=\\sum_{x=0}^{M-1}\\sum^{N-1}_{y=0}f(x,y) F(0,0)=\\sum_{x=0}^{M-1}\\sum^{N-1}_{y=0}f(x,y) \u5373 F(0,0)=mean(f(x,y))*M*N F(0,0)=mean(f(x,y))*M*N \uff0c\u6240\u4ee5 |F(0,0)| |F(0,0)| \u662f\u9891\u8c31\u7684\u6700\u5927\u5206\u91cf\u3002 \u9891\u57df\u6709\u67d0\u4e00\u65b9\u5411\u7684\u4eae\u7ebf\u6761\uff0c\u8bf4\u660e\u56fe\u50cf\u4e2d\u4e0e\u4e4b\u5782\u76f4\u65b9\u5411\u4e0a\u6709\u8f83\u591a\u7ebf\u6761\u3002 \u5085\u91cc\u53f6\u53d8\u6362\u662f\u5171\u8f6d\u5bf9\u79f0\u7684\uff0c\u5373 F^*(u,v)=F(-u,-v) F^*(u,v)=F(-u,-v) \u6570\u5b57\u56fe\u50cf\u7684\u9891\u8c31\u662f\u5173\u4e8e\u539f\u70b9\u5076\u5bf9\u79f0\u7684\uff0c\u5373 |F(u,v)|=|F(-u,-v)| |F(u,v)|=|F(-u,-v)| \u6570\u5b57\u56fe\u50cf\u7684\u76f8\u4f4d\u89d2\u662f\u5173\u4e8e\u8fdc\u70b9\u5947\u5bf9\u79f0\u7684\uff0c\u5373 \\varphi(u,v)=-\\varphi(-u,-v) \\varphi(u,v)=-\\varphi(-u,-v) \u5e73\u79fb\u6027\u8d28 \u5085\u7acb\u53f6\u53d8\u6362\u5e73\u79fb\u6027\u8d28\uff0c\u662f\u6307\u5f53\u7a7a\u57df\u56fe\u50cf\u76ee\u6807\u4f4d\u7f6e\u53d8\u5316\u4e4b\u540e\uff0c\u5176\u9891\u8c31\u4e0d\u53d1\u751f\u6539\u53d8\u3002 \u65cb\u8f6c\u6027\u8d28 \u5c3a\u5ea6\u5b9a\u7406 \u5468\u671f\u6027 \u5e94\u7528\uff1a f(x)(-1)^x==F(u-\\frac{M}{2}) f(x)(-1)^x==F(u-\\frac{M}{2}) \u8bc1\u660e\u4e3a\uff1a \u4e8c\u7ef4\u540c\u6837\uff1a 4\uff09\u5085\u91cc\u53f6\u53d8\u6362\u76f8\u4f4d\u8c31 \u7531\u5085\u7acb\u53f6\u53d8\u6362\u7684\u76f8\u4f4d\u6784\u6210\u7684\u77e9\u9635\u3002 \u76f8\u4f4d\u5206\u91cf\u662f\u6307\u5404\u4e2a\u6b63\u5f26\u5206\u91cf\u5173\u4e8e\u539f\u70b9\u7684\u4f4d\u79fb\u7684\u5ea6\u91cf\uff0c\u51b3\u5b9a\u4e86\u56fe\u50cf\u4e2d\u53ef\u8fa8\u522b\u7269\u4f53\u5b9a\u4f4d\u4fe1\u606f\u3002 5\uff09\u5377\u79ef\u5b9a\u7406 6\uff09\u5085\u91cc\u53f6\u53d8\u6362\u65f6\u95f4\u590d\u6742\u5ea6 \u8ba1\u7b97\u4e00\u7ef4\u79bb\u6563\u5085\u91cc\u53f6\u53d8\u6362\uff08DFT\uff09\u516c\u5f0f\u5982\u4e0b\uff1a \u200b \u5176\u4e2d\uff0cN\u8868\u793a\u6570\u636e\u957f\u5ea6\u3002\u7531\u4e0a\u5f0f\u53ef\u77e5\uff0cDFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(N*N) \u4e00\u7ef4FFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(N*logN)\uff0c\u5176\u4e2dN\u8868\u793a\u6570\u636e\u957f\u5ea6 \u5bf9\u4e8e\u4e00\u4e2aM*N\u7684\u4e8c\u7ef4\u6570\u636e\uff0cFFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO( M*N*log(M*N) ) \u82e5M=N\uff0c\u5219\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u7b80\u5316\u4e3aO(N^2*logN) \u5bf9\u4e8eM\u7ef4\u7684\u6570\u636e\uff08\u6bcf\u4e00\u7ef4\u957f\u5ea6\u4e3aA\uff0cB\uff0cC\uff0c...\uff09\uff0c\u5219FFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO( A*B*C*...* log(A*B*C*...) ) \u82e5\u6bcf\u4e00\u7ef4\u957f\u5ea6\u76f8\u540c\uff0c\u5373A=B=C=...=N\uff0c\u5219\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u7b80\u5316\u4e3aO(N^M*logN) \u79bb\u6563\u4f59\u5f26\u53d8\u6362 1\uff09\u4e8c\u7ef4\u79bb\u6563\u4f59\u5f26\u53d8\u6362\u5b9a\u4e49 \u6c83\u5c14\u4ec0\u53d8\u6362 \u7b2c\u4e94\u7ae0 \u9891\u7387\u57df\u56fe\u50cf\u589e\u5f3a \u00b6 \u9891\u7387\u57df\u589e\u5f3a\u539f\u7406 1\uff09\u5377\u79ef\u4ee5\u53ca\u5377\u79ef\u5b9a\u7406 \u8bbe\u51fd\u6570f (x, y)\u4e0e\u7b97\u5b50h(x, y)\u7684\u5377\u79ef\u7ed3\u679c\u662fg(x, y)\uff0c\u5373 g(x, y) = h(x, y) * f (x, y)\uff0c\u90a3\u4e48\u6839\u636e\u5377\u79ef\u5b9a\u7406\u5728\u9891\u57df\u6709\uff1a G(u,v) = H(u,v)F(u,v)\uff0c\u5176\u4e2dG(u, v)\uff0cH(u, v)\uff0cF(u, v)\u5206\u522b\u662fg(x, y)\uff0ch(x, y)\uff0cf (x, y)\u7684\u5085\u7acb\u53f6(\u6216\u5176\u5b83)\u53d8\u6362\uff0c\u79f0H(u, v)\u4e3a\u8f6c\u79fb\u51fd\u6570 G(u,v) = H(u,v)F(u,v) 2\uff09\u56fe\u50cf\u589e\u5f3a\u539f\u7406 \u5176\u4e2dT\u4ee3\u8868\u5085\u91cc\u53f6\u53d8\u6362 3\uff09\u56fe\u50cf\u589e\u5f3a\u5177\u4f53\u5b9e\u73b0 \u5377\u79ef\u5b9a\u7406\uff1a G(u,v)=H(u,v)F(u,v) G(u,v)=H(u,v)F(u,v) \u589e\u5f3a\u56fe\u50cf\uff1a g(x,y)=T^{-1}[H(u,v)F(u,v)] g(x,y)=T^{-1}[H(u,v)F(u,v)] \u6b65 \u9aa4\uff1a (1) \u8ba1\u7b97\u56fe\u50cf\u7684\u9891\u57df\u53d8\u6362 (2) \u5728\u9891\u57df\u6ee4\u6ce2 (3) \u53cd\u53d8\u6362\u56de\u56fe\u50cf\u7a7a\u95f4 \u9891\u57df\u6ee4\u6ce2: \u4f4e\u901a\uff0c\u9ad8\u901a\uff0c\u540c\u6001 \u9891\u7387\u57df\u5e73\u6ed1\u6ee4\u6ce2\u5668 1\uff09\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u56fe\u50cf\u4e2d\u7684\u8fb9\u7f18\u548c\u566a\u58f0\u90fd\u5bf9\u5e94\u56fe\u50cf\u5085\u7acb\u53f6\u53d8\u6362\u4e2d\u7684\u9ad8\u9891\u90e8\u5206 \uff0c\u6240\u4ee5\u5982\u8981\u5728\u9891\u57df\u4e2d\u6d88\u5f31\u5176\u5f71\u54cd\u5c31\u8981\u8bbe\u6cd5\u51cf\u5f31\u8fd9\u90e8\u5206\u9891\u7387\u7684\u5206\u91cf\u3002 2\uff09\u7406\u60f3\u4f4e\u901a\u6ee4\u6ce2\u5668 H(u,v)=1:0?D(u,v)<D_0\uff0c\u5176\u4e2dD(u,v)=(u^2+v^2)^{1/2} H(u,v)=1:0?D(u,v)<D_0\uff0c\u5176\u4e2dD(u,v)=(u^2+v^2)^{1/2} \u95ee\u9898\uff1a\u6a21\u7cca\uff0c\u632f\u94c3\u6548\u5e94\u3002 3\uff09\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668 \u51cf\u5c11\u632f\u94c3\u6548\u5e94\uff0c\u9ad8\u4f4e\u9891\u7387\u95f4\u7684\u8fc7\u6e21\u6bd4\u8f83\u5149\u6ed1\u3002 \u9636\u6570\u4e3an\u7684\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668\u516c\u5f0f\u4e3a\uff1a H(u,v)=\\frac{1}{1+D(u,v)^{2n}} H(u,v)=\\frac{1}{1+D(u,v)^{2n}} \u9636\u6570\u5bf9\u632f\u94c3\u73b0\u8c61\u7684\u5f71\u54cd\uff1a\u9636\u6570\u8d8a\u9ad8\uff0c\u8d8a\u660e\u663e\u3002 \u5f53\u9636\u6570\u8d8b\u4e8e\u65e0\u7a77\u65f6\uff0c\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u53d8\u6210\u7406\u60f3\u4f4e\u901a\u6ee4\u6ce2\u3002 4\uff09\u5e94\u7528 \u56fe\u50cf\u7531\u4e8e\u91cf\u5316\u4e0d\u8db3\u4ea7\u751f\u865a\u5047\u8f6e\u5ed3\u65f6\u5e38\u53ef\u7528\u4f4e\u901a\u6ee4\u6ce2\u8fdb\u884c\u5e73\u6ed1\u4ee5\u6539\u8fdb\u56fe\u50cf\u8d28\u91cf\u3002 5\uff09\u9ad8\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668 \u9ad8\u65af\u6ee4\u6ce2\u5668\u662f\u5b8c\u5168\u4e0d\u4f1a\u4ea7\u751f\u632f\u94c3\u6548\u5e94\u7684\u3002 H(u,v)=e^{-D^2(u,v)/2D_0)^2} H(u,v)=e^{-D^2(u,v)/2D_0)^2} 6\uff09\u5176\u4ed6\u4f4e\u901a\u6ee4\u6ce2\u5668 \u9891\u7387\u57df\u9510\u5316\u6ee4\u6ce2\u5668 1\uff09\u7406\u60f3\u9ad8\u901a\u6ee4\u6ce2\u5668 \u5f62\u72b6\u4e0e\u4f4e\u901a\u6ee4\u6ce2\u5668\u7684\u5f62\u72b6\u6b63\u597d\u76f8\u53cd H(u,v)=0:1?D(u,v)>D_0 H(u,v)=0:1?D(u,v)>D_0 2\uff09\u5df4\u7279\u6c83\u65af\u9ad8\u901a\u6ee4\u6ce2\u5668 \u5f62\u72b6\u4e0e\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668\u7684\u5f62\u72b6\u6b63\u597d\u76f8\u53cd H(u,v)=\\frac{1}{1+[D_0/D(u,v)]^{2n}} H(u,v)=\\frac{1}{1+[D_0/D(u,v)]^{2n}} 3\uff09\u9ad8\u65af\u9ad8\u901a\u6ee4\u6ce2\u5668 \u5f62\u72b6\u4e0e\u9ad8\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668\u7684\u5f62\u72b6\u6b63\u597d\u76f8\u53cd H(u,v)=1-e^{-D^2(u,v)/2D_0)^2} H(u,v)=1-e^{-D^2(u,v)/2D_0)^2} \u9ad8\u9891\u5f3a\u8c03\u6ee4\u6ce2\u5668 \u9ad8\u901a\u6ee4\u6ce2\u7684\u7ed3\u679c\uff1a\u8fb9\u7f18\u52a0\u5f3a\uff0c\u5149\u6ed1\u533a\u57df\u53d8\u6697 \u9ad8\u901a\u6ee4\u6ce2\uff1a G(u,v)=H(u,v)F(u,v) G(u,v)=H(u,v)F(u,v) \u9ad8\u901a\u5f3a\u8c03\u8f6c\u79fb\u51fd\u6570\uff1a H_c(u,v)=k\u00d7H(u,v)+c H_c(u,v)=k\u00d7H(u,v)+c \u9ad8\u9891\u5f3a\u8c03\u8f93\u51fa\u56fe\u7684\u5085\u7acb\u53f6\u53d8\u6362\uff1a G_c(u,v)=k\u00d7G(u,v)+c\u00d7F(u,c) G_c(u,v)=k\u00d7G(u,v)+c\u00d7F(u,c) \u53cd\u53d8\u6362\u4e3a\uff1a g(x,y)=k\u00d7g(x,y)+c\u00d7f(x,y) g(x,y)=k\u00d7g(x,y)+c\u00d7f(x,y) \u9ad8\u9891\u63d0\u5347\u6ee4\u6ce2\u5668 \u7528\u539f\u59cb\u56fe\u51cf\u53bb\u4f4e\u901a\u56fe\u5f97\u5230\u9ad8\u901a\u6ee4\u6ce2\u5668\u7684\u6548\u679c\u3002 \u628a\u539f\u59cb\u56fe\u4e58\u4ee5\u4e00\u4e2a\u653e\u5927\u7cfb\u6570A\u518d\u51cf\u53bb\u4f4e\u901a\u56fe\u5c31\u53ef\u6784 \u6210\u9ad8\u9891\u63d0\u5347\uff08high-boost\uff09\u6ee4\u6ce2\u5668 G_{HB}(u,v)=A\u00d7F(u,v)-F_L(u,v)=(A-1)F(u,v)+F_H(u,v) G_{HB}(u,v)=A\u00d7F(u,v)-F_L(u,v)=(A-1)F(u,v)+F_H(u,v) A = 1 \uff1a\u9ad8\u901a\u6ee4\u6ce2\u5668 A > 1 \uff1a\u539f\u59cb\u56fe\u7684\u4e00\u90e8\u5206\u4e0e\u9ad8\u901a\u56fe\u76f8\u52a0\uff0c\u6062\u590d\u4e86\u9ad8\u901a\u6ee4\u6ce2\u65f6\u4e22\u5931\u7684\u4f4e\u9891\u5206\u91cf \u540c\u6001\u6ee4\u6ce2 \u5c06\u660e\u4eae\u5747\u8861\u5316\uff0c\u4f7f\u4eae\u5ea6\u548c\u7070\u5ea6\u5747\u8861\u5316\u3002 \u9009\u62e9\u6027\u6ee4\u6ce2 \u5206\u4e3a\u4e24\u79cd\uff1a \u5e26\u963b\u6ee4\u6ce2\u5668&\u5e26\u901a\u6ee4\u6ce2\u5668 1\uff09\u5e26\u963b\u6ee4\u6ce2\u5668 \u5e26\u963b\u6ee4\u6ce2\u5668\u4e5f\u6709\u4e09\u79cd\u7279\u6027\u3002\u7406\u60f3\u3001\u5df4\u7279\u6c83\u65af\u548c\u9ad8\u65af 2\uff09\u5e26\u901a\u6ee4\u6ce2\u5668 \u5e26\u963b\u6ee4\u6ce2\u5668\u4e5f\u6709\u4e09\u79cd\u7279\u6027\u3002\u7406\u60f3\u3001\u5df4\u7279\u6c83\u65af\u548c\u9ad8\u65af 3\uff09\u9677\u6ce2\u6ee4\u6ce2\u5668(Notch Filter) \u9677\u6ce2\u6ee4\u6ce2\u5668\u672c\u8d28\u4e0a\u662f\u591a\u4e2a\u9ad8\u901a\u6ee4\u6ce2\u5668\u8fdb\u884c\u5e73\u79fb\u540e\u518d\u76f8\u4e58\u3002 \u591a\u4e2a\u5e26\u963b\u6ee4\u6ce2\u5668\u7ecf\u8fc7\u5e73\u79fb\u83b7\u5f97\u3002 \u9891\u57df\u6280\u672f\u4e0e\u7a7a\u57df\u6280\u672f 1\uff09\u7a7a\u95f4\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u6d88\u9664\u6216\u51cf\u5f31\u56fe\u50cf\u4e2d\u7070\u5ea6\u503c\u5177\u6709\u8f83\u5927\u8f83\u5feb\u53d8\u5316\u90e8\u5206\u7684\u5f71\u54cd\uff0c \u8fd9\u4e9b\u90e8\u5206\u5bf9\u5e94\u9891\u57df\u4e2d\u7684\u9ad8\u9891\u5206\u91cf\uff0c\u6240\u4ee5\u53ef\u7528\u9891\u57df\u4f4e\u901a\u6ee4\u6ce2\u6765\u5b9e\u73b0 \u9891\u57df\u8d8a\u5bbd\uff0c\u7a7a\u57df\u8d8a\u7a84\uff0c\u5e73\u6ed1\u4f5c\u7528\u8d8a\u5f31 \u9891\u57df\u8d8a\u7a84\uff0c\u7a7a\u57df\u8d8a\u5bbd\uff0c\u6a21\u7cca\u4f5c\u7528\u8d8a\u5f3a \u5e73\u6ed1\u6a21\u677f\u7cfb\u6570\u4e3a\u6b63\uff0c\u4e14\u4e2d\u90e8\u7cfb\u6570\u503c\u8f83\u5927 2\uff09\u7a7a\u95f4\u9510\u5316\u6ee4\u6ce2\u5668 \u6d88\u9664\u6216\u51cf\u5f31\u56fe\u50cf\u4e2d\u7070\u5ea6\u503c\u7f13\u6162\u53d8\u5316\u7684\u90e8\u5206\uff0c\u8fd9\u4e9b\u90e8\u5206\u5bf9\u5e94 \u9891\u57df\u4e2d\u7684\u4f4e\u9891\u5206\u91cf\uff0c\u6240\u4ee5\u53ef\u7528\u9891\u57df\u9ad8\u901a\u6ee4\u6ce2\u6765\u5b9e\u73b0 \u7a7a\u57df\u6709\u6b63\u8d1f\u503c\uff0c\u6a21\u677f\u4e2d\u5fc3\u7cfb\u6570\u503c\u8f83\u5927 \u7b2c\u516d\u7ae0 \u56fe\u50cf\u6062\u590d \u00b6 \u56fe\u50cf\u6062\u590dvs.\u56fe\u50cf\u589e\u5f3a \u76f8\u540c\u4e4b\u5904\uff1a \u6539\u8fdb\u8f93\u5165\u56fe\u50cf\u7684\u89c6\u89c9\u8d28\u91cf \u4e0d\u540c\u4e4b\u5904\uff1a \u4e0d\u8003\u8651\u56fe\u50cf\u964d\u8d28\u7684\u539f\u56e0\uff0c\u53ea\u5c06\u56fe\u50cf\u4e2d\u611f\u5174\u8da3\u7684\u7279\u5f81\u6709\u9009\u62e9\u5730 \u7a81\u51fa\uff08\u589e\u5f3a\uff09\uff0c\u800c\u8870\u51cf\u5176\u4e0d\u9700\u8981\u7684\u7279\u5f81\uff0c\u6539\u5584\u540e\u7684\u56fe\u50cf\u4e0d\u4e00\u5b9a\u8981\u53bb \u903c\u8fd1\u539f\u56fe\u50cf\u3002\u56fe\u50cf\u589e\u5f3a\u501f\u52a9\u4eba\u7684\u89c6\u89c9\u7cfb\u7edf\u7279\u6027\uff0c\u4ee5\u53d6\u5f97\u8f83\u597d\u7684\u89c6 \u89c9\u7ed3\u679c\uff08\u4e0d\u8003\u8651\u9000\u5316\u539f\u56e0\uff09 \u56fe\u50cf\u6062\u590d\u6839\u636e\u76f8\u5e94\u7684\u9000\u5316\u6a21\u578b\u548c\u77e5\u8bc6\u91cd\u5efa\u6216\u6062\u590d\u539f\u59cb\u7684\u56fe\u50cf \uff08\u8003\u8651\u9000\u5316\u539f\u56e0\uff09 \u56fe\u50cf\u9000\u5316\u793a\u4f8b \u56fe\u50cf\u9000\u5316\u6307\u7531\u573a\u666f\u5f97\u5230\u7684\u56fe\u50cf\u6ca1\u80fd\u5b8c\u5168\u5730\u53cd\u6620\u573a\u666f\u7684\u771f \u5b9e\u5185\u5bb9\uff0c\u4ea7\u751f\u4e86\u5931\u771f\u7b49\u95ee\u9898 \u539f\u56e0\uff1a\u900f\u955c\u50cf\u5dee/\u8272\u5dee\u3001\u805a\u7126\u4e0d\u51c6\uff08\u5931\u7126\uff0c\u9650\u5236\u4e86\u56fe\u50cf\u9510\u5ea6\uff09\u3001\u6a21\u7cca\uff08\u9650\u5236\u9891\u8c31\u5bbd\u5ea6\uff09\u3001\u566a\u58f0\uff08\u662f\u4e00\u4e2a\u7edf\u8ba1\u8fc7\u7a0b\uff09\u3001\u6296\u52a8\uff08\u673a\u68b0\u3001\u7535\u5b50\uff09 \u56fe\u50cf\u9000\u5316\u590d\u539f\u8fc7\u7a0b\u6a21\u578b \u9000\u5316\u8fc7\u7a0b\u662f\u4e00\u4e2a\u9000\u5316\u51fd\u6570\ud835\udc6f(\u2219) \u548c\u4e00\u4e2a\u52a0\u6027\u566a\u58f0 \ud835\udf3c (\ud835\udc99, \ud835\udc9a) \uff0c\u4f5c\u7528\u5230\u4e00\u5e45\u56fe\u50cf\ud835\udc87(\ud835\udc99, \ud835\udc9a)\u4e0a\uff0c\u4ea7\u751f\u9000\u5316\u540e\u7684 \u56fe\u50cf\ud835\udc88(\ud835\udc99, \ud835\udc9a)\u3002 \u590d\u539f\u8fc7\u7a0b\u662f\u7ed9\u5b9a\u9000\u5316\u56fe\ud835\udc88(\ud835\udc99, \ud835\udc9a)\u548c\u5173\u4e8e\u9000\u5316\u51fd\u6570\ud835\udc6f(\u2219)\u7684\u4e00\u4e9b\u77e5\u8bc6\u53ca\u5173\u4e8e\u52a0\u6027\u566a\u58f0\u9879\ud835\udf3c(\ud835\udc99, \ud835\udc9a)\u7684\u77e5\u8bc6\uff0c\u83b7\u5f97 \u539f\u59cb\u56fe\u50cf\u7684\u4e00\u4e2a\u4f30\u8ba1\ud835\udc87(x,y)\u3002 \u9000\u5316\u6a21\u578b\uff1a g(x,y)=H[f(x,y)]+\\eta(x,y)=h(x,y)*f(x,y)+\\eta(x,y),*\u4e3a\u5377\u79ef g(x,y)=H[f(x,y)]+\\eta(x,y)=h(x,y)*f(x,y)+\\eta(x,y),*\u4e3a\u5377\u79ef G(x,y)=H(x,y)F(x,y+N(x,y)) G(x,y)=H(x,y)F(x,y+N(x,y)) \u566a\u58f0\u6a21\u578b 1\uff09\u5e38\u89c1\u566a\u58f0 \u70ed\u566a\u58f0\uff1a\u4e0e\u7269\u4f53\u7684\u7edd\u5bf9\u6e29\u5ea6\u6709\u5173\u3002 \u4e5f\u79f0\uff1a \u767d\u566a\u58f0 \uff08\u9891\u7387\u8986\u76d6\u6574\u4e2a\u9891\u8c31\uff09 \u9ad8\u65af\u566a\u58f0\uff08\u5e45\u5ea6\u7b26\u5408\u9ad8\u65af\u5206\u5e03\uff09 \u95ea\u70c1\u566a\u58f0\uff1a\u7535\u6d41\u8fd0\u52a8\u4ea7\u751f\u3002 \u5177\u6709\u53cd\u6bd4\u4e8e\u9891\u7387\uff081/f\uff09\u7684\u9891\u8c31 \u4e5f\u79f0\u7c89\u8272\u566a\u58f0\uff08\u5728\u5bf9\u6570\u9891\u7387\u95f4\u9694\u5185\u6709\u76f8\u540c\u7684\u80fd\u91cf\uff09 \u53d1\u5c04\u566a\u58f0\uff1a\u9ad8\u65af\u5206\u5e03\uff08\u7535\u5b50\u8fd0\u52a8\u7684\u968f\u673a\u6027\uff09 **\u52a0\u6027\u566a\u58f0**\u4e00\u822c\u6307\u70ed\u566a\u58f0\u3001\u6563\u5f39\u566a\u58f0\u7b49\uff0c\u5b83\u4eec\u4e0e\u4fe1\u53f7\u7684\u5173\u7cfb\u662f\u76f8\u52a0\uff0c\u4e0d\u7ba1\u6709\u6ca1\u6709\u4fe1\u53f7\uff0c\u8be5\u7c7b\u566a\u58f0\u662f\u4e00\u76f4\u5b58\u5728\u7684\u3002\u4e00\u822c\u901a\u4fe1\u4e2d\u628a\u52a0\u6027\u968f\u673a\u6027\u770b\u6210\u662f\u7cfb\u7edf\u7684\u80cc\u666f\u566a\u58f0\u3002 **\u4e58\u6027\u566a\u58f0**\u4e00\u822c\u7531\u4fe1\u9053\u4e0d\u7406\u60f3\u5f15\u8d77\uff0c\u5b83\u4eec\u4e0e\u4fe1\u53f7\u7684\u5173\u7cfb\u662f\u76f8\u4e58\uff0c\u4fe1\u53f7\u5728\u5b83\u5728\uff0c\u4fe1\u53f7\u4e0d\u5728\u4ed6\u4e5f\u5c31\u4e0d\u5728\u3002\u4e58\u6027\u968f\u673a\u6027\u770b\u6210\u7cfb\u7edf\u7684\u65f6\u53d8\u6027\uff08\u5982\u8870\u843d\u6216\u8005\u591a\u666e\u52d2\uff09\u6216\u8005\u975e\u7ebf\u6027\u6240\u9020\u6210\u7684\u3002 2\uff09\u566a\u58f0\u6982\u7387\u5bc6\u5ea6\u51fd\u6570 3\uff09\u5468\u671f\u566a\u58f0 \u4e00\u5e45\u56fe\u50cf\u7684\u5468\u671f\u566a\u58f0\u662f\u5728\u56fe\u50cf\u83b7\u53d6\u671f\u95f4\u7531\u7535\u529b\u6216\u673a\u7535\u5e72\u6270\u4ea7\u751f\u7684\u3002 \u662f\u4e00\u79cd\u7a7a\u95f4\u76f8\u5173\u566a\u58f0\u3002 \u5468\u671f\u566a\u58f0\uff08\u6b63\u5f26\uff09\u5728\u5085\u91cc\u53f6\u53d8\u6362\u540e\uff0c\u662f\u4f4d\u4e8e\u6b63\u5f26\u6ce2\u5171\u8f6d\u9891\u7387\u5904\u7684\u4e00\u5bf9\u5171\u8f6d\u8109\u51b2\u3002 \u5468\u671f\u566a\u58f0\u53c2\u6570\u4f30\u8ba1\uff1a \u901a\u8fc7\u68c0\u9a8c\u5085\u91cc\u53f6\u8c31\u6765\u4f30\u8ba1\u5468\u671f\u3002 \u5468\u671f\u566a\u58f0\u901a\u5e38\u4f1a\u4ea7\u751f\u9891\u7387\u5c16\u5cf0\uff0c\u53ef\u4ee5\u8fdb\u884c\u68c0\u6d4b\u3002 \u566a\u58f0\u53c2\u6570\u4f30\u8ba1 \u566a\u58f0\u7684PDF\u53c2\u6570 \u6210\u50cf\u7cfb\u7edf\u53ef\u4f7f\u7528 \u4f7f\u7528\u6210\u50cf\u7cfb\u7edf\u83b7\u53d6\u4e00\u7ec4\u201c\u5e73\u5766\u201d\u73af\u5883\u56fe\u50cf\uff0c\u4f5c\u4e3a\u6837\u672c\uff1b\u5373\uff1a\u62cd\u6444\u5149\u7167\u5747\u5300\u7684\u7eaf\u8272\u7070\u5ea6\u56fe\u50cf \u6210\u50cf\u7cfb\u7edf\u4e0d\u53ef\u4f7f\u7528\uff0c\u53ea\u6709\u5176\u751f\u6210\u56fe\u50cf \u4ece\u56fe\u50cf\u4e2d\uff0c\u627e\u4e00\u5757\u5408\u7406\u7684\u6052\u5b9a\u7070\u5ea6\u503c\u533a\u57df\uff0c\u4f5c\u4e3a\u6837\u672c \u56fe\u50cf\u566a\u58f0\u7684\u6982\u7387\u5bc6\u5ea6\u51fd\u6570\u8868\u793a\uff0c\u5176\u81ea\u53d8\u91cf\u662f\u56fe\u50cf\u7070\u5ea6\u503c\u3002 \u53ea\u6709\u566a\u58f0\u7684\u590d\u539f-\u7a7a\u95f4\u6ee4\u6ce2 \u5bf9\u4e8e\u5468\u671f\u566a\u58f0\uff0c\u5728\u9891\u57df\u4f30\u8ba1\ud835\udc75(\ud835\udc96, \ud835\udc97) \uff0c\u76f4\u63a5\u53bb\u6389\uff0c\u53d8\u6362\u5230\u7a7a\u95f4\u57df\u3002 \u52a0\u6027\u566a\u58f0\uff0c\u7a7a\u95f4\u6ee4\u6ce2\u3002 \u5bf9\u4e8e\u56fe\u50cf\u4e2d\u7684\u52a0\u6027\u566a\u58f0\uff0c\u91c7\u7528\u7b97\u672f\u5747\u503c\u6ee4\u6ce2\u3001\u51e0\u4f55\u5747\u503c\u6ee4\u6ce2\u3001\u9006\u8c10\u6ce2\u5747\u503c\u6ee4\u6ce2\u548c\u8c10\u6ce2\u5747\u503c\u6ee4\u6ce2\u53bb\u9664\u3002 1\uff09\u5747\u503c\u6ee4\u6ce2\u5668 2\uff09\u8c10\u6ce2\u5747\u503c\u6ee4\u6ce2\u5668 3\uff09\u4fee\u6b63alpha\u5747\u503c\u6ee4\u6ce2\u5668 4\uff09\u81ea\u9002\u5e94\u6ee4\u6ce2\u5668 \u6ee4\u6ce2\u5668\u7279\u5f81\u53d8\u5316\u662f\u4ee5\ud835\udc8e \u00d7 \ud835\udc8f\u7684\u77e9\u5f62\u7a97\u53e3\ud835\udc7a\ud835\udc99\ud835\udc9a\u5b9a\u4e49\u7684\u6ee4\u6ce2\u5668\u533a\u57df\u5185\u56fe\u50cf\u7684\u7edf\u8ba1\u7279\u5f81\u4e3a\u57fa\u7840 \u81ea\u9002\u5e94\u6ee4\u6ce2\u5668\u6027\u80fd\u4f18\u4e8e\u5168\u5c40\u6ee4\u6ce2\u5668 \u8ba1\u7b97\u590d\u6742\u5ea6\u9ad8 5\uff09\u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u5168\u5c40\u4e2d\u503c\u6ee4\u6ce2\uff0c\u5728\u8109\u51b2\u566a\u58f0\u7a7a\u95f4\u5bc6\u5ea6\u4e0d\u5927\u662f\uff0c\u6027\u80fd\u5f88\u597d\uff08\u7ecf\u9a8c\uff1a\ud835\udc77\ud835\udc82 < \ud835\udfce. \ud835\udfd0\uff0c\ud835\udc77\ud835\udc83 < \ud835\udfce. \ud835\udfd0\uff09 \u2013 \u5bc6\u5ea6\u5927\uff0c\u4e0d\u597d\u7528 \u2013 \u4e0d\u80fd\u5904\u7406\u975e\u8109\u51b2\u566a\u58f0\uff0c\u540c\u65f6\u4fdd\u7559\u7ec6\u8282 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2 \u2013 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u53ef\u4ee5\u5904\u7406\u66f4\u5927\u7684\u5bc6\u5ea6 \u2013 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u80fd\u591f\u5728\u5e73\u6ed1\u975e\u8109\u51b2\u566a\u58f0\u65f6\uff0c\u4fdd\u7559\u7ec6\u8282 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u76f8\u540c\uff1a \u2013 \u6ee4\u6ce2\u5668\u4f5c\u7528\u4e8e\u5c40\u90e8\u533a\u57df\ud835\udc7a\ud835\udc99\ud835\udc9a \u533a\u522b\uff1a \u2013 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u6839\u636e\u67d0\u4e9b\u6761\u4ef6\u6539\u53d8\ud835\udc7a\ud835\udc99\ud835\udc9a\u7684\u5c3a\u5bf8 \u4f7f\u7528\uff1a \u2013 \u6ee4\u6ce2\u5668\u8f93\u51fa\u4e00\u4e2a\u5355\u503c\uff0c\u7528\u4e8e\u4ee3\u66ff\u6ee4\u6ce2\u5668\u7a97\u53e3\ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u5fc3\u5904\u50cf\u7d20 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u7b26\u53f7\uff1a \ud835\udc9b\ud835\udc8e\ud835\udc8a\ud835\udc8f = \ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u7684\u6700\u5c0f\u7070\u5ea6\u503c \ud835\udc9b\ud835\udc8e\ud835\udc82\ud835\udc99 = \ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u7684\u6700\u5927\u7070\u5ea6\u503c \ud835\udc9b\ud835\udc8e\ud835\udc86\ud835\udc85 = \ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u7684\u7070\u5ea6\u503c\u4e2d\u503c \ud835\udc9b\ud835\udc99\ud835\udc9a =\u5750\u6807 \ud835\udc99, \ud835\udc9a \u5904\u7684\u7070\u5ea6\u503c \ud835\udc7a\ud835\udc8e\ud835\udc82\ud835\udc99 = \ud835\udc7a\ud835\udc99\ud835\udc9a\u5141\u8bb8\u7684\u6700\u5927\u5c3a\u5bf8 \u5468\u671f\u566a\u58f0\u6d88\u9664 \u5e26\u963b\u6ee4\u6ce2\u5668 \u5e26\u901a\u6ee4\u6ce2\u5668 \uff08\u63d0\u53d6\u566a\u58f0\u6a21\u5f0f\uff09 \u9677\u6ce2\u6ee4\u6ce2\u5668 \u7ebf\u6027\u3001\u4f4d\u7f6e\u4e0d\u53d8\u7684\u9000\u5316 1\uff09\u9000\u5316\u6a21\u578b \u9000\u5316\u6a21\u578b\u516c\u5f0f\uff1a \ud835\udc88(\ud835\udc99, \ud835\udc9a) = \ud835\udc6f[\ud835\udc87(\ud835\udc99, \ud835\udc9a)] + \ud835\udf3c(\ud835\udc99, \ud835\udc9a) \u7b80\u5316\u6a21\u578b\uff1a \ud835\udf3c(\ud835\udc99, \ud835\udc9a)=0 2\uff09\u9000\u5316\u7cfb\u7edfH\u7684\u6027\u8d28 \u4f30\u8ba1\u9000\u5316\u51fd\u6570 \u56fe\u50cf\u89c2\u5bdf\u4f30\u8ba1 \u2013 \u6761\u4ef6\uff1a\u53ea\u6709\u9000\u5316\u56fe\u50cf\uff0c\u6ca1\u6709\u5173\u4e8e\u9000\u5316\u51fd\u6570H\u7684\u4efb\u4f55\u77e5\u8bc6\u3002 \u4ece\u56fe\u50cf\u672c\u8eab\u6765\u6536\u96c6\u4fe1\u606f\uff0c\u5373\u901a\u8fc7\u89c2\u5bdf\u56fe\u50cf\uff0c\u8fdb\u884c\u5904\u7406 \u6765\u83b7\u5f97\u9000\u5316\u51fd\u6570\u4fe1\u606f\u3002 \u65b9\u6cd5\uff1a \u2013 \u4ece\u56fe\u50cf\u4e2d\u9009\u62e9\u4e00\u5c0f\u5757\u533a\u57df\uff0c\u4f5c\u4e3a\u5b50\u56fe\u50cf \u2013 \u56fe\u50cf\u4e2d\u7269\u4f53\u6216\u56fe\u50cf\u80cc\u666f\u4e00\u90e8\u5206 \u2013 \u4e3a\u964d\u4f4e\u566a\u58f0\u5f71\u54cd\uff0c\u627e\u6709\u5f88\u5f3a\u4fe1\u53f7\u7684\u533a\u57df\uff08\u9ad8\u5bf9\u6bd4\u533a\u57df\uff09 \u2013 \u624b\u5de5\u5904\u7406\u5b50\u56fe\u50cf\uff0c\u53bb\u9664\u6a21\u7cca\u3002 \u2013 \u8ba1\u7b97\u51faH(u,v) \u8bd5\u9a8c\u4f30\u8ba1 \u2013 \u6761\u4ef6\uff1a\u53ef\u4ee5\u83b7\u5f97\u4e0e\u9000\u5316\u56fe\u50cf\u8bbe\u5907\u76f8\u4f3c\u7684\u7cfb\u7edf \u2013 \u7406\u8bba\u4e0a\uff1a\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u51c6\u786e\u7684\u9000\u5316\u4f30\u8ba1 \u65b9\u6cd5\uff1a \u2013 \u901a\u8fc7\u8bbe\u7f6e\u7cfb\u7edf\uff0c\u83b7\u5f97\u4e0e\u9000\u5316\u56fe\u50cf\u63a5\u8fd1\u7684\u56fe\u50cf\uff1b \u2013 \u7528\u8be5\u7cfb\u7edf\u4e00\u5e45\u51b2\u6fc0\u6210\u50cf\uff0c\u5f97\u5230\u9000\u5316\u7684\u51b2\u6fc0\u54cd\u5e94\uff1b \u2013 \u51b2\u6fc0\u7528\u4e00\u4e2a\u5c0f\u4eae\u70b9\u6765\u6a21\u62df\uff0c\u5c3d\u53ef\u80fd\u4eae\uff1b \u2013 \ud835\udc6f(\ud835\udc96, \ud835\udc97)= \ud835\udc6e(\ud835\udc96,\ud835\udc97)/\ud835\udc68 \u200b \ud835\udc6e(\ud835\udc96, \ud835\udc97)\u662f\u51b2\u6fc0\u6210\u50cf\u56fe\u50cf\u7684\u5085\u91cc\u53f6\u53d8\u6362\uff0c\ud835\udc68\u662f\u51b2\u6fc0\u7684\u5085\u91cc\u53f6\u53d8\u6362 \u5efa\u6a21\u4f30\u8ba1 \u4ece\u5f15\u8d77\u9000\u5316\u7684\u73af\u5883\u6761\u4ef6\u8003\u8651\uff0c\u8fdb\u884c\u4f30\u8ba1 \u6e4d\u6d41\u9000\u5316\u6a21\u578b\u662f\u5927\u6c14\u6e4d\u6d41\u7269\u7406\u7279\u6027\u7684 \u901a\u7528\u5f62\u5f0f\uff1a \ud835\udc6f(\ud835\udc96, \ud835\udc97)= \ud835\udc86^{\u2212\ud835\udc8c(\ud835\udc96^\ud835\udfd0+\ud835\udc97^\ud835\udfd0)^{\ud835\udfd3/6}} \ud835\udc6f(\ud835\udc96, \ud835\udc97)= \ud835\udc86^{\u2212\ud835\udc8c(\ud835\udc96^\ud835\udfd0+\ud835\udc97^\ud835\udfd0)^{\ud835\udfd3/6}} \u5176\u4e2d\uff0c \ud835\udc8c\u662f\u4e0e\u6e4d\u6d41\u6027\u8d28\u6709\u5173\u7684\u5e38\u6570 \ud835\udc8c = \ud835\udfce. \ud835\udfce\ud835\udfce\ud835\udfd0\ud835\udfd3\u5267\u70c8\u6e4d\u6d41 \ud835\udc8c = \ud835\udfce. \ud835\udfce\ud835\udfce\ud835\udfcf\u4e2d\u7b49\u6e4d\u6d41 \ud835\udc8c = \ud835\udfce. \ud835\udfce\ud835\udfce\ud835\udfce\ud835\udfd0\ud835\udfd3\u8f7b\u5fae\u6e4d\u6d41 \u9006\u6ee4\u6ce2 --\u65e0\u7ea6\u675f\u6062\u590d \u9006\u6ee4\u6ce2\u4e2d\uff0c\u9006\u6ee4\u6ce2\u4e2d\uff0c\u6309\u7167\u79bb\u9891\u8c31\u4e2d\u5fc3\u7684\u8fdc\u8fd1\u5b9a\u4e49\u4e86\u6062\u590d\u8f6c\u79fb\u51fd\u6570\u662f\u632f\u94c3\u6548\u5e94\u51fa\u73b0\u7684\u539f\u56e0\u3002 \u6700\u5c0f\u5747\u65b9\u8bef\u5dee\u6ee4\u6ce2\uff08\u7ef4\u7eb3\u6ee4\u6ce2\uff09 --\u6709\u7ea6\u675f\u6062\u590d \u4e86\u89e3 \u6709\u7ea6\u675f\u6700\u5c0f\u4e8c\u4e58\u65b9\u6062\u590d --\u6709\u7ea6\u675f\u6062\u590d \u4e86\u89e3 \u7b2c\u4e03\u7ae0 \u5f69\u8272\u56fe\u50cf\u5904\u7406 \u00b6 \u5f69\u8272\u57fa\u7840 1\uff09\u989c\u8272\u7684\u672c\u8d28 \u4e0d\u540c\u989c\u8272\u7684\u5149\u5b9e\u8d28\u662f \u4e0d\u540c\u9891\u7387\u7684\u7535\u78c1\u6ce2 \u2013 \u53ef\u89c1\u5149\u8c31\u7684\u6ce2\u957f\u8303\u56f4\uff1a400\uff5e700nm 2\uff09\u4e09\u57fa\u8272 \u5927\u591a\u6570\u7684\u989c\u8272\u53ef\u4ee5\u901a \u8fc7\u7ea2\u3001\u7eff\u3001\u84dd\u4e09\u8272\u6309\u7167 \u4e0d\u540c\u7684\u6bd4\u4f8b\u5408\u6210\u4ea7\u751f 3\uff09\u8272\u5ea6 \u8272\u5ea6 \u5f69\u8272\u7684\u4e09\u79cd\u57fa\u672c\u7279\u6027\u91cf \u4eae\u5ea6\uff1a \u4e0e\u7269\u4f53\u7684\u53cd\u5c04\u7387\u6210\u6b63\u6bd4 \u8272\u8c03\uff1a \u4e0e\u5149\u8c31\u4e2d\u5149\u7684\u6ce2\u957f\u76f8\u8054\u7cfb \u9971\u548c\u5ea6\uff1a\u4e0e\u4e00\u5b9a\u8272\u8c03\u5149\u7684\u7eaf\u5ea6\u6709\u5173 \u8272\u5ea6\uff1a\u8272\u8c03\u548c\u9971\u548c\u5ea6\u5408\u79f0 \u5f69\u8272\u53ef\u7528\u4eae\u5ea6\u548c\u8272\u5ea6\u5171\u540c\u8868\u793a 4\uff09\u8272\u5ea6\u56fe \u5f69\u8272\u6253\u5370\u673a\u662f\u76f8 \u52a0\u8272\u5f69\u548c\u76f8\u51cf\u8272\u5f69\u7684\u6df7\u5408\u7684 \u7ec4\u5408\uff0c\u6240\u4ee5\u5f69\u8272\u57df\u8fb9\u754c\u4e0d\u89c4\u5219\u3002 \u5f69\u8272\u8f6c\u5316\u4e3a\u7070\u5ea6\uff0c\u9002\u5408\u663e\u793a\u5668\u548c\u6444\u50cf\u673a\uff1a Y_{709} = 0.2125R + 0.7154G + 0.0721B Y_{709} = 0.2125R + 0.7154G + 0.0721B \u5f69\u8272\u6a21\u578b \u4e3a\u4e86\u6b63\u786e\u6709\u6548\u5730\u8868\u8fbe\u5f69\u8272\u4fe1\u606f\uff0c\u9700\u8981\u5efa\u7acb\u5408\u9002\u7684\u5f69\u8272\u8868\u8fbe\u6a21\u578b\u3002 1\uff09\u5f69\u8272\u8868\u8fbe\u6a21\u578b \u5f69\u8272\u8868\u8fbe\u6a21\u578b\u5206\u4e3a\u4e24\u79cd\uff1a \u9762\u5411\u786c\u8bbe\u5907\u7684\u5f69\u8272\u6a21\u578b\uff0c\u8bf8\u5982\u5f69\u8272\u663e\u793a\u5668\u6216\u6253\u5370\u673a\u4e4b\u7c7b\u7684\u786c\u8bbe\u5907\uff0c\u4f8b\u5982RGB\uff0cCMY\u6a21\u578b\u7b49\u3002 \u9762\u5411\u89c6\u89c9\u611f\u77e5\u7684\u5f69\u8272\u6a21\u578b\uff0c\u4ee5\u5f69\u8272\u5904\u7406\u4e3a\u76ee\u7684\u7684\u5e94\u7528\uff0c\u4f8b\u5982HSI\u3001HSV\u6a21\u578b\u7b49\u3002 2\uff09RGB\u6a21\u578b \u5efa\u7acb\u5728\u7b1b\u5361\u513f\u5750\u6807\u7cfb\u7edf\u91cc\uff0c\u5176\u4e2d\u4e09 \u4e2a\u8f74\u5206\u522b\u4e3aR\uff0cG\uff0cB\uff0c \u2013 \u6a21\u578b\u7684\u7a7a\u95f4\u662f\u6b63\u65b9\u4f53\uff0c\u539f\u70b9\u5bf9\u5e94\u9ed1 \u8272\uff0c\u79bb\u539f\u70b9\u6700\u8fdc\u7684\u9876\u70b9\u5bf9\u5e94\u767d\u8272 \u2013 \u4ece\u9ed1\u5230\u767d\u7684\u7070\u5ea6\u503c\u5206\u5e03\u5728\u4ece\u539f\u70b9\u5230 \u79bb\u539f\u70b9\u6700\u8fdc\u9876\u70b9\u95f4\u7684\u8fde\u7ebf\u4e0a\uff0c\u800c\u7acb\u65b9\u4f53\u5185\u5176\u4f59\u5404\u70b9\u5bf9\u5e94\u4e0d\u540c\u7684\u989c\u8272\uff0c \u53ef\u7528\u4ece\u539f\u70b9\u5230\u8be5\u70b9\u7684\u77e2\u91cf\u8868\u793a 3\uff09CMY\u6a21\u578b \u4e09\u8865\u8272\uff1a \u84dd\u7eff(C, cyan)\uff0c\u54c1\u7ea2(M, magenta)\uff0c\u9ec4(Y, yellow) \u2013 \u4e3b\u8981\u7528\u4e8e\u5f69\u8272\u6253\u5370\uff0c\u8fd9\u4e09\u79cd\u8865\u8272\u53ef\u5206\u522b\u7531\u4ece\u767d\u5149\u4e2d\u51cf\u53bb\u4e09\u79cd\u57fa\u8272\u800c\u5f97\u5230 \u2013 \u4eceCMY\u5230RGB\u7684\u8f6c\u6362\u4e3aR =1\u2212C\uff0cG =1\u2212 M\uff0cB =1\u2212Y 4\uff09HSI\u6a21\u578b H\uff1a\u70b9s\u7684H\u4e3a\u4e09\u89d2\u5f62 \u4e2d\u5fc3\u70b9\u5230s\u7684\u77e2\u91cf\u4e0eR\u8f74\u7684\u5939\u89d2 S\uff1a\u70b9s\u7684S\u4e3a\u4e09\u89d2 \u5f62\u4e2d\u5fc3\u70b9\u5230s\u7684\u77e2\u91cf\u957f\u5ea6 I\uff1a\u79bb\u5f00\u4e2d\u95f4\u622a\u9762 \u5411\u4e0a\u53d8\u767d\uff1b\u5411\u4e0b\u53d8\u9ed1 \u8272\u8c03\u548c\u9971\u548c\u5ea6\u4e8c\u8005\u5408\u5e76\u79f0\u4e3a\u8272\u5ea6\uff0c\u4eae\u5ea6\u4e2d\u4e0d\u542b\u6709\u989c\u8272\u4fe1\u606f\u3002 H \u8868\u793a\u8272\u8c03\uff08hue\uff09 S \u8868\u793a\u9971\u548c\u5ea6\uff08saturation\uff09 I \u8868\u793a\u5bc6\u5ea6\uff08intensity\uff0c\u5bf9\u5e94\u6210\u50cf\u4eae\u5ea6\u548c\u56fe\u50cf\u7070\u5ea6\uff09 H\u548cS\u5408\u79f0\u8272\u5ea6 I \u5206\u91cf\u4e0e\u56fe\u50cf\u7684\u5f69\u8272\u4fe1\u606f\u65e0\u5173 H \u548c S \u5206\u91cf\u4e0e\u4eba\u611f\u53d7\u989c\u8272\u7684\u65b9\u5f0f\u7d27\u5bc6\u76f8\u8fde \u4f2a\u5f69\u8272\u5904\u7406 \u4eba\u773c\u5bf9\u5f69\u8272\u8272\u6bd4\u5bf9\u7070\u5ea6\u6709\u8f83\u5927\u7684\u5206\u8fa8\u80fd\u529b\u3002 \u4f2a\u5f69\u8272(pseudocolor)\u5904\u7406\u662f\u6307\u5bf9\u539f\u6765\u7070\u5ea6\u56fe\u50cf\u4e2d\u4e0d\u540c\u7070\u5ea6\u503c\u7684\u533a\u57df\u8d4b\u4e88\u4e0d\u540c\u7684\u989c\u8272\u3002 \u5178\u578b\u65b9\u6cd5 (1) \u4eae\u5ea6\u5207\u5272 (2) \u5229\u7528\u53d8\u6362\u51fd\u6570 (3) \u9891\u57df\u6ee4\u6ce2 1\uff09\u4eae\u5ea6\u5207\u5272 \u75281\u4e2a\u5e73\u884c\u4e8e\u56fe\u50cf\u5750\u6807\u5e73\u9762\u7684\u5e73\u9762\u53bb\u5207\u5272\u56fe\u50cf\u4eae\u5ea6\u51fd\u6570\uff0c\u4ece\u800c\u628a\u4eae \u5ea6\u51fd\u6570\u5206\u62102\u4e2a\u7070\u5ea6\u503c\u533a\u95f4\u3002 2\uff09\u4ece\u7070\u5ea6\u5230\u5f69\u8272\u7684\u53d8\u6362\uff08\u6620\u5c04\uff09 3\uff09\u9891\u57df\u6ee4\u6ce2 \u5bf9\u539f\u6765\u7070\u5ea6\u56fe\u50cf\u4e2d\u7684\u4e0d\u540c\u9891\u7387\u5206\u91cf\uff08\u53ef\u5206\u522b\u501f\u52a9\u4f4e\u901a\uff0c\u5e26\u901a/\u5e26\u963b\uff0c\u9ad8\u901a\u6ee4\u6ce2\u5668\u83b7\u5f97\uff09\u8d4b\u4e88\u4e0d\u540c\u7684\u989c\u8272 \u771f\u5f69\u8272\u5904\u7406 1\uff09\u5904\u7406\u65b9\u6cd5 \u5c06\u4e00\u5e45\u5f69\u8272\u56fe\u50cf\u770b\u4f5c\u4e09\u5e45\u5206\u91cf\u56fe\u50cf\u7684\u7ec4\u5408\u4f53\uff0c\u5148\u5206\u522b\u5355\u72ec\u5904\u7406\u6bcf\u4e00\u5e45\u5206\u91cf\u56fe\u50cf\uff0c\u518d\u5c06\u7ed3\u679c\u5408\u6210\u4e00\u5e45\u5904\u7406\u8fc7\u7684\u5408\u6210\u5f69\u8272\u56fe\u50cf \u5c06\u4e00\u5e45\u5f69\u8272\u56fe\u50cf\u4e2d\u7684\u6bcf\u4e2a\u50cf\u7d20\u770b\u4f5c\u5177\u6709\u4e09\u4e2a\u5c5e\u6027\u503c\uff0c\u5373\u5c5e\u6027\u73b0\u5728\u4e3a\u4e00\u4e2a\u77e2\u91cf\uff0c\u5229\u7528\u5bf9\u77e2\u91cf\u7684\u8868\u8fbe\u65b9\u6cd5\u8fdb\u884c\u5904\u7406 2\uff09\u5f69\u8272\u53d8\u6362 g(x,y)=T(f(x,y)) g(x,y)=T(f(x,y)) \u5176\u4e2d\uff0c\ud835\udc87(\ud835\udc99, \ud835\udc9a) \u662f\u5f69\u8272\u8f93\u5165\u56fe\u50cf\uff0c \ud835\udc88(\ud835\udc99, \ud835\udc9a) \u662f\u53d8\u6362\u540e\u7684\u5f69\u8272\u56fe\u50cf\uff0c \ud835\udc7b\u662f\u5728 (\ud835\udc99, \ud835\udc9a) \u7684\u7a7a\u95f4\u90bb\u57df\u4e0a\u5bf9\ud835\udc87\u7684\u4e00\u4e2a\u7b97\u5b50\u3002 \u5206\u91cf\u5f62\u5f0f\uff1a\ud835\udc94\ud835\udc8a = \ud835\udc7b\ud835\udc8a(\ud835\udc93\ud835\udfcf, \ud835\udc93\ud835\udfd0, \u22ef , \ud835\udc93\ud835\udc8f)\uff0c\ud835\udc8a = \ud835\udfcf, \ud835\udfd0, \u22ef , \ud835\udc8f \ud835\udc93\ud835\udc8a\u548c\ud835\udc94\ud835\udc8a\u662f\ud835\udc87 \ud835\udc99, \ud835\udc9a \u548c\ud835\udc88 \ud835\udc99, \ud835\udc9a \u5728\u4efb\u4f55\u70b9\u5904\u5f69\u8272\u5206\u91cf\u53d8\u91cf\uff0c\ud835\udc8f\u662f\u5f69\u8272\u5206\u91cf\u6570\uff1b \ud835\udc7b\ud835\udc8a\u662f\u5bf9\ud835\udc93\ud835\udc8a\u5904\u7406\u4ea7\u751f\ud835\udc94\ud835\udc8a\u7684\u6620\u5c04\u51fd\u6570\uff1b \ud835\udc8f = \ud835\udfd1\u65f6\u5019\uff0c\u662fRGB\u7a7a\u95f4\uff0c\ud835\udc8f = \ud835\udfd2\u65f6\u5019\uff0c\u662fCMYK\u7a7a\u95f4\uff0c 3\uff09\u5f69\u8272\u5f3a\u5ea6\u589e\u5f3a\u53d8\u6362 \u53d8\u6362\u589e\u5f3a \u5bf9\u4e8e\u5f69\u8272\u56fe\u50cf\u589e\u5f3a\u5176\u5f3a\u5ea6\u503c\uff0c\u5373intensity \u8981\u5224\u65ad\u989c\u8272\u6a21\u578b\uff0c\u7136\u540e\u5904\u7406 HSI\u6a21\u578b\uff0cI\u5355\u5206\u91cf\u8fdb\u884c\u589e\u5f3a\u7684\u6b65\u9aa4 (1) \u5c06R\uff0cG\uff0cB\u5206\u91cf\u56fe\u8f6c\u5316\u4e3aH\uff0cS\uff0cI\u5206\u91cf\u56fe (2) \u5229\u7528\u5bf9\u7070\u5ea6\u56fe\u589e\u5f3a\u7684\u65b9\u6cd5\u589e\u5f3a\u5176\u4e2d\u7684I\u5206\u91cf \ud835\udc94\ud835\udfd1 = \ud835\udc8c\ud835\udc93\ud835\udfd1 (3) \u518d\u5c06\u7ed3\u679c\u8f6c\u6362\u4e3aR\uff0cG\uff0cB\u5206\u91cf\u56fe RGB\u6a21\u578b\uff0c\u5f3a\u5ea6\u589e\u5f3a \u4e09\u4e2a\u5206\u91cf\u90fd\u53d8\u6362 \ud835\udc94\ud835\udc8a = \ud835\udc8c\ud835\udc93\ud835\udc8a\uff0c\ud835\udc8a = \ud835\udfcf, \ud835\udfd0, 3 4\uff09\u8865\u8272 \u5728\u8272\u73af\u4e0a\uff0c\u4e0e\u8272\u8c03\u76f4\u63a5\u76f8\u5bf9 \u7684\u53e6\u4e00\u7aef\u79f0\u4e3a\u8865\u8272 \u5728RGB\u7a7a\u95f4\uff0c \u76f4\u63a5\u6c42\u8865\uff1b \u5728HSI\u7a7a\u95f4\uff0c \u6ca1\u6709\u76f4\u63a5\u65b9\u6cd5\uff0c \u53ea\u80fd\u8fd1\u4f3c\u3002 5\uff09\u76f4\u65b9\u56fe\u5747\u8861\u5316 \u5355\u72ec\u5bf9RGB\u5f69\u8272\u56fe\u50cf\u5206\u91cf\u8fdb\u884c\u76f4\u65b9\u56fe\u5747\u8861 \u2013 \u4ea7\u751f\u4e0d\u6b63\u786e\u989c\u8272 \u5747\u5300\u5730\u5c55\u5f00\u8fd9\u79cd\u5f69\u8272\u7070\u5ea6\uff0c\u4fdd\u6301\u5f69\u8272\u672c\u8272\uff08\u8272\u8c03\uff09 \u4e0d\u53d8 \u2013 \u5728HSI\u4e2d\uff0c\u5747\u8861\u5316\u5f69\u8272\u5206\u91cfI\uff0c\u5f69\u8272\u672c\u8eab\uff08\u8272\u8c03\uff09\u4e0d\u53d8 6\uff09\u5f69\u8272\u5e73\u6ed1 \u5c06\u7070\u5ea6\u56fe\u50cf\u90bb\u57df\u5e73\u5747\u6269\u5c55\u5230\u5f69\u8272\u56fe\u50cf\uff0c\u4f7f\u7528\u5411\u91cf\u5e73\u6ed1\u7b97\u5b50 \u5bf9HSI\u6a21\u578b\u4e2d\u7684I\u901a\u9053\u8fdb\u884c\u5e73\u6ed1\uff0cH\u548cS\u901a\u9053\u4e0d\u5904\u7406\uff0c \u989c\u8272\u6ca1\u6709\u53d8\u5316\u3002 7\uff09\u5f69\u8272\u9510\u5316 8\uff09\u9971\u548c\u5ea6\u589e\u5f3a \u2013 \u65b9\u6cd5\uff1a\u8f6c\u5230HSI\u989c\u8272\u7a7a\u95f4\uff0c\u5bf9S\u901a\u9053\u8fdb\u884c\u589e\u5f3a \u2013 \u6548\u679c\uff1a \u2013 \u589e\u5927\u50cf\u7d20\u9971\u548c\u5ea6\u4f1a\u4f7f\u56fe\u50cf\u8272\u5f69\u66f4\u9c9c\u660e \u2013 \u51cf\u5c0f\u50cf\u7d20\u9971\u548c\u5ea6\u4f1a\u4f7f\u56fe\u50cf\u8272\u5f69\u611f\u51cf\u5c11\uff0c\u663e\u5f97\u5e73\u6de1 9\uff09\u8272\u8c03\u589e\u5f3a \u2013 \u65b9\u6cd5\uff1a\u8f6c\u6362\u5230HSI\u989c\u8272\u7a7a\u95f4\uff0c\u7136\u540e\u5bf9H\u8fdb\u884c\u589e\u5f3a \u6548\u679c\uff1a\u56e0\u4e3a\u8272\u8c03\u5bf9\u5e94\u4e00\u4e2a\u89d2\u5ea6 \u2013 \u5fae\u589e\u4e00\u4e2a\u5e38\u6570\uff0c\u4f1a\u4f7f\u989c\u8272\u5728\u8272\u8c31\u4e0a\u79fb\u52a8\u3002 \u2013 \u5e38\u6570\u8f83\u5c0f\u65f6\uff0c\u4f1a\u4f7f\u8272\u8c03\u53d8\u201c\u6696\u201d\u6216\u53d8\u201c\u51b7\u201d \u2013 \u5e38\u6570\u8f83\u5927\u65f6\uff0c\u4f1a\u4f7f\u5f69\u8272\u56fe\u50cf\u53d1\u751f\u5267\u70c8\u53d8\u6362 \u7b2c\u516b\u7ae0 \u5f62\u6001\u5b66\u56fe\u50cf\u5904\u7406 \u00b6 \u7ed3\u6784\u5143 \u5bf9\u6bcf\u4e2a\u7ed3\u6784\u5143\u7d20\uff0c\u5148\u8981\u6307\u5b9a\u4e00\u4e2a\u539f\u70b9\uff0c\u5b83\u662f\u7ed3\u6784\u5143\u7d20\u53c2\u4e0e \u5f62\u6001\u5b66\u8fd0\u7b97\u7684\u53c2\u8003\u70b9\u3002 \u6ce8\u610f\uff1a\u539f\u70b9\u53ef\u4ee5\u5305\u542b\u5728\u7ed3\u6784\u5143\u7d20\u4e2d\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u5305\u542b\u5728\u7ed3 \u6784\u5143\u7d20\u4e2d\uff08\u5373\u539f\u70b9\u5e76\u4e0d\u4e00\u5b9a\u8981\u5c5e\u4e8e\u7ed3\u6784\u5143\u7d20\uff09 \u5bf9\u56fe\u50cf\u64cd\u4f5c\u65f6\u8981\u6c42\u7ed3\u6784\u5143\u7d20\u662f\u77e9\u5f62\u9635\u5217\uff0c\u901a\u8fc7\u6dfb\u52a0\u6700\u5c11\u53ef\u80fd\u7684\u80cc\u666f\u5143\u7d20\u5b9e\u73b0\u3002 \u57fa\u672c\u5f62\u6001\u5b66\u64cd\u4f5c \u6620\u50cf\u548c\u4f4d\u79fb\u662f\u5f62\u6001\u5b66\u5904\u7406\u4e2d\u6269\u5c55\u7684\u96c6\u5408\u8fd0\u7b97\u3002 1\uff09\u81a8\u80c0 A\u2295B = \\{x|(B\u02c6) x \u2229 A \u2260 \\phi \\},\u02c6\u4e3a\u7ffb\u8f6c\u8fd0\u7b97 A\u2295B = \\{x|(B\u02c6) x \u2229 A \u2260 \\phi \\},\u02c6\u4e3a\u7ffb\u8f6c\u8fd0\u7b97 \u5148\u5bf9B\u505a==\u5173\u4e8e\u539f\u70b9\u7684\u6620\u8c61==\uff0c\u518d\u5c06\u5176\u6620\u8c61\u5e73\u79fbx\uff0c\u7ed3\u679c\u662f\u5e73\u79fb\u540e\u4e0eA\u4ea4\u96c6\u4e0d\u4e3a\u7a7a\u7684x\u96c6\u5408\u3002 \u5373\u4e3a\u7528B\u6765\u81a8\u80c0A\u5f97\u5230\u7684\u96c6\u5408\u662f \u7684\u4f4d\u79fb\u4e0eA\u81f3\u5c11\u6709\u4e00 \u4e2a\u975e\u96f6\u5143\u7d20\u5373\u76f8\u4ea4\u65f6B\u7684\u539f\u70b9\u4f4d\u7f6e\u7684\u96c6\u5408\u3002 2\uff09\u8150\u8680 A\u3280B = \\{x |(B)x \u2286 A \\} A\u3280B = \\{x |(B)x \u2286 A \\} B\u79fb\u52a8\u540e\u5b8c\u5168\u5305\u542b\u5728A\u4e2d\u65f6\uff0cB\u7684\u539f\u70b9\u4f4d\u7f6e\u7684\u96c6\u5408 \u4f5c\u7528\uff1a \u539f\u70b9\u5728\u7ed3\u6784\u5143\u7d20\uff08B\u4e2d\uff0c\u6536\u7f29\u56fe\u50cf\u3002 \u7ed3\u6784\u5143\u7d20\u4e0d\u5305\u542b\u539f\u70b9\u65f6\uff0c\u53ef\u4ee5\u7528\u4f5c\u586b\u5145\u5185\u90e8\u7a7a\u6d1e 3\uff09\u8150\u8680\u548c\u81a8\u80c0\u5bf9\u5076\u6027 (A\u3280B)^c=A^c\u2295B\u02c6 (A\u3280B)^c=A^c\u2295B\u02c6 \uff0c\u5176\u4e2dc\u4e3a\u53d6\u8865\u8fd0\u7b97 3\uff09\u5f00\u64cd\u4f5c \u5b9a\u4e49\uff1aB\u5bf9A\u8fdb\u884c\u7684\u5f00\u64cd\u4f5c\u5c31\u662f\u5148\u7528B\u5bf9A\u8150\u8680\uff0c\u7136\u540e\u7528B \u5bf9\u7ed3\u679c\u8fdb\u884c\u81a8\u80c0 \u4f5c\u7528\uff1a\u5f00\u64cd\u4f5c\u65ad\u5f00\u72ed\u7a84\u7684\u95f4\u65ad\u548c\u6d88\u9664\u7ec6\u7684\u7a81\u51fa\u7269 A\u2299B=(A\u3280B)\u2295B A\u2299B=(A\u3280B)\u2295B 4\uff09\u95ed\u64cd\u4f5c \u5b9a\u4e49\uff1aB\u5bf9A\u8fdb\u884c\u7684\u95ed\u64cd\u4f5c\u5c31\u662f\u5148\u7528B\u5bf9A\u81a8\u80c0\uff0c\u7136\u540e\u7528B \u5bf9\u7ed3\u679c\u8fdb\u884c\u8150\u8680 \u4f5c\u7528\uff1a\u95ed\u64cd\u4f5c\u6d88\u5f25\u72ed\u7a84\u7684\u95f4\u65ad\u548c\u957f\u7ec6\u7684\u9e3f\u6c9f\uff0c\u6d88\u9664\u5c0f\u7684\u5b54\u6d1e\uff0c\u5e76 \u586b\u8865\u8f6e\u5ed3\u7ebf\u4e2d\u5c0f\u7684\u65ad\u88c2 A\u2022B=(A\u2295B)\u3280B A\u2022B=(A\u2295B)\u3280B 5\uff09\u5f00\u548c\u95ed\u64cd\u4f5c\u6027\u8d28 (A\u2022B)^c=(A^c\u2299B\u02c6) (A\u2022B)^c=(A^c\u2299B\u02c6) (A\u2299B)\u2286A (A\u2299B)\u2286A A\u2286A\u2022B A\u2286A\u2022B 6\uff09\u51fb\u4e2d\u6216\u51fb\u4e0d\u4e2d\u53d8\u6362 \u57fa\u672c\u7684\u5f62\u6001\u5b66\u7b97\u6cd5 1\uff09\u8fb9\u754c\u63d0\u53d6 \u8bbe\u96c6\u5408A\u7684\u8fb9\u754c\u8868\u793a\u4e3a \u03b2(A)\uff0c\u9009\u53d6\u7ed3\u6784\u5143\u7d20B\uff0c\u5148\u8fdb\u884cB\u5bf9 A\u8150\u8680\uff0c\u800c\u540e\u7528A\u51cf\u53bb\u8150\u8680\u7684\u7ed3\u679c\u3002 2\uff09\u533a\u57df\u586b\u5145 3\uff09\u7ec6\u5316\u64cd\u4f5c \u63d0\u53d6\u56fe\u50cf\u7684\u4e3b\u8981\u6846\u67b6 4\uff09\u8054\u901a\u533a\u57df\u63d0\u53d6 \u65b9\u6cd5\uff1a X_k = (X_{k\u22121} \u2295 B)\u2229A X_k = (X_{k\u22121} \u2295 B)\u2229A \u76f4\u81f3 X_k X_k \u548c X_{k-1} X_{k-1} \u76f8\u540c 5\uff09\u51f8\u58f3 \u57fa\u672c\u7070\u5ea6\u7ea7\u56fe\u50cf\u6269\u5c55\u64cd\u4f5c 1\uff09\u81a8\u80c0 f\u2295b(s,t)=max\\{f(s-x,t-y)+b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} f\u2295b(s,t)=max\\{f(s-x,t-y)+b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} Df\u548cDb\u5206\u522b\u4e3a f \u548c b \u7684\u5b9a\u4e49\u57df\u3002 \u50cf\u7d20\u90fd\u5fc5\u987b\u5728\u5b9a\u4e49\u57df\u5185\uff0c\u4e0e\u96c6\u5408\u4ea4\u96c6\u4e00\u81f4 \u81a8\u80c0\u64cd\u4f5c\u7684\u7ed3\u679c\uff1a \uff08a\uff09\u5982\u679c\u7ed3\u6784\u5143 \u7d20\u7684\u503c\u90fd\u4e3a\u6b63\uff0c\u90a3\u4e48\u8f93\u51fa\u56fe\u50cf\u4f1a\u66f4\u4eae \uff08b\uff09\u6697\u7684\u7ec6\u8282\u90e8 \u5206\u7684\u53d8\u5316\u53d6\u51b3\u4e8e\u7ed3\u6784\u5143\u7d20\u7684\u503c\u548c\u5f62\u72b6 2\uff09\u8150\u8680 f\u3280b(s,t)=min\\{f(s-x,t-y)-b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} f\u3280b(s,t)=min\\{f(s-x,t-y)-b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} Df\u548cDb\u5206\u522b\u4e3a f \u548c b \u7684\u5b9a\u4e49\u57df\u3002 \u50cf\u7d20\u90fd\u5fc5\u987b\u5728\u5b9a\u4e49\u57df\u5185\uff0c\u4e0e\u7ed3\u6784\u5143\u7d20\u5fc5\u987b\u5b8c\u5168\u5305\u542b\u5728\u88ab\u8150\u8680\u7684 \u96c6\u5408\u5185\u4e00\u81f4 \u8150\u8680\u64cd\u4f5c\u7684\u7ed3\u679c\uff1a \uff08a\uff09\u5982\u679c\u7ed3\u6784\u5143\u7d20\u7684 \u503c\u90fd\u4e3a\u6b63\uff0c\u90a3\u4e48\u8f93\u51fa\u56fe\u50cf\u4f1a\u66f4\u6697 \uff08b\uff09\u4eae\u7684\u7ec6\u8282\u90e8\u5206\u7684\u53d8\u5316\u53d6\u51b3\u4e8e\u7ed3\u6784\u5143\u7d20\u7684\u503c\u548c\u5f62\u72b6 3\uff09\u5f00\u64cd\u4f5c \u5f00\u64cd\u4f5c\uff1a\u5c0f\u7684\u660e\u4eae\u7ec6\u8282\u5c3a\u5bf8\u53d8\u5c0f\uff0c\u6697\u7684\u6548\u679c\u53d7\u5f71\u54cd\u8f83\u5c0f \u95ed\u64cd\u4f5c\uff1a\u5c0f\u7684\u6697\u7ec6\u8282\u7684\u5c3a\u5bf8\u7f29\u5c0f\uff0c\u660e\u4eae\u90e8\u5206\u53d7\u5f71\u54cd\u8f83\u5c0f \u57fa\u672c\u7684\u7070\u5ea6\u7ea7\u5f62\u6001\u5b66\u7b97\u6cd5 1\uff09\u5f62\u6001\u5b66\u5e73\u6ed1 \u5148\u8fdb\u884c\u5f00\u64cd\u4f5c\uff0c\u540e\u8fdb\u884c\u95ed\u64cd\u4f5c \u8ba1\u7b97\u516c\u5f0f\u4e3a\uff1a g=(f\u2299b)\u2022b g=(f\u2299b)\u2022b 2\uff09\u5f62\u6001\u5b66\u68af\u5ea6 \u5f00\u64cd\u4f5c\u51cf\u95ed\u64cd\u4f5c \u8ba1\u7b97\u516c\u5f0f\u4e3a\uff1a g=(f\u2295b)-(f\u3280b) g=(f\u2295b)-(f\u3280b) 3\uff09\u5e3d\u53d8\u6362 \u7528\u4e00\u4e2a\u7ed3\u6784\u5143\u901a\u8fc7\u5f00\u64cd\u4f5c\u6216\u95ed\u64cd\u4f5c\u4ece\u56fe\u50cf\u4e2d\u5220\u9664\u7269\u4f53\u3002 \u7136\u540e\u5dee\u64cd\u4f5c\u5f97\u5230\u4e00\u5e45\u4ec5\u4fdd\u7559\u5df2\u5220\u9664\u5206\u91cf\u7684\u56fe\u50cf\u3002 \u9876\u5e3d\u53d8\u6362 T_{hat}(f)=f-(f\u2299b) T_{hat}(f)=f-(f\u2299b) \u7070\u5ea6\u7ea7\u56fe\u50cff\u7684\u9876\u5e3d\u53d8\u6362\u662ff\u51cf\u53bb\u5176\u5f00\u64cd\u4f5c \u9876\u5e3d\u53d8\u6362\u7528\u4e8e\u5f97\u5230\u6697\u80cc\u666f\u4e0a\u7684\u4eae\u7269\u4f53\uff08\u767d\u9876\u5e3d\uff09 \u4f4e\u5e3d\u53d8\u6362 T_{hat}(f)=(f\u2022b)-f T_{hat}(f)=(f\u2022b)-f \u7070\u5ea6\u7ea7\u56fe\u50cff\u7684\u5e95\u5e3d\u53d8\u6362\u662ff\u7684\u95ed\u64cd\u4f5c\u51cf\u53bbf \u5e95\u5e3d\u53d8\u6362\u7528\u4e8e\u5f97\u5230\u4eae\u80cc\u666f\u4e0a\u7684\u6697\u7269\u4f53\uff08\u9ed1\u5e95\u5e3d\uff09 \u5e3d\u53d8\u6362\u7684\u5e94\u7528\u6709\u6821\u6b63\u4e0d\u5747\u5300\u5149\u7167\u5f71\u54cd\u3001\u7eb9\u7406\u5206\u5272\u548c\u7c92\u5ea6\u6d4b\u5b9a\uff0c\u5177\u4f53\u4f7f\u7528\u7684\u662f\u5f00\u64cd\u4f5c\uff0c\u51cf\u5c11\u4eae\u5ea6\u8f83\u9ad8\u7684\u90e8\u5206\u3002 \u7b2c\u4e5d\u7ae0 \u56fe\u50cf\u7f16\u7801 \u00b6 \u56fe\u7247\u538b\u7f29 1\uff09\u6570\u636e\u548c\u4fe1\u606f \u6570\u636e\u662f\u4fe1\u606f\u7684\u8f7d\u4f53 \u540c\u91cf\u7684\u6570\u636e\u53ef\u8868\u8fbe\u4e0d\u4fe1\u606f\uff0c\u540c\u91cf\u7684\u4fe1\u606f\u53ef\u7528\u4e0d\u6570\u636e\u8868\u8fbe 2\uff09\u56fe\u7247\u538b\u7f29\u79cd\u7c7b \u4fe1\u606f\u4fdd\u5b58\u578b\u548c\u4fe1\u606f\u635f\u5931\u578b \u6570\u636e\u5197\u4f59 1\uff09\u5197\u4f59\u79cd\u7c7b \u5197\u4f59\u6709\u4e24\u79cd\uff0c\u5206\u522b\u4e3a\u6570\u636e\u8868\u8fbe\u4e86\u65e0\u7528\u7684\u4fe1\u606f\u548c\u6570\u636e\u8868\u8fbe\u4e86\u5df2\u8868\u8fbe\u7684\u4fe1\u606f\u3002 2\uff09\u76f8\u5bf9\u538b\u7f29\u5197\u4f59 \u76f8\u5bf9\u5197\u4f59\u516c\u5f0f\u4e3a R_D=1-\\frac{1}{C_R} R_D=1-\\frac{1}{C_R} \uff0c\u538b\u7f29\u7387\u4e3a C_R=\\frac{n_1}{n2} C_R=\\frac{n_1}{n2} \uff0c C_R C_R \u5728\u533a\u95f4 (0,+\\infty) (0,+\\infty) \u4e2d\u53d6\u503c\u3002n1\u548cn2\u4ee3\u8868\u4e24\u4e2a\u6570\u636e\u96c6\u5408\u4e2d\u7684\u4fe1\u606f\u8f7d\u4f53\u5355\u4f4d\u7684\u6570\u91cf\u3002 3\uff09\u5197\u4f59\u7684\u7c7b\u522b \u7f16\u7801\u5197\u4f59\u3001\u50cf\u7d20\u76f8\u5173\u5197\u4f59\u548c\u5fc3\u91cc\u89c6\u89c9\u5197\u4f59\u3002 \u7f16\u7801\u5197\u4f59\u548c\u4e0e\u7070\u5ea6\u5206\u5e03\u7684\u6982\u7387\u7279\u6027\u6709\u5173\u3002 \u50cf\u7d20\u76f8\u5173\u5197\u4f59\u548c\u7a7a\u95f4\u5197\u4f59\uff0c\u65f6\u95f4\u5197\u4f59\u6709\u5173\u3002 \u5fc3\u7406\u89c6\u89c9\u5197\u4f59\u548c\u4e3b\u89c2\u611f\u89c9\u6709\u5173\u3002 4\uff09\u7f16\u7801\u5197\u4f59 \u56fe\u50cf\u4e2d\u7070\u5ea6\u51fa\u73b0\u7684\u6982\u7387\uff1a p_s(s_k)=n_k/n,k=0,1,..,L-1 p_s(s_k)=n_k/n,k=0,1,..,L-1 \u5e73\u5747\u6bd4\u7279\u6570\uff1a L_{avg}=\\sum^{L-1}_{k=0}l(s_k)p_k(s_k) L_{avg}=\\sum^{L-1}_{k=0}l(s_k)p_k(s_k) \u9884\u671f\u7ed3\u679c\u4e3a\u7528\u8f83\u5c11\u7684\u6bd4\u7279\u6570\u8868\u793a\u51fa\u73b0\u6982\u7387\u8f83\u5927\u7684\u7070\u5ea6\u7ea7\uff0c\u7528\u8f83\u591a\u7684\u6bd4\u7279\u6570\u8868\u793a\u51fa\u73b0\u6982\u7387\u8f83\u5c0f\u7684\u7070\u5ea6\u7ea7 5\uff09\u50cf\u7d20\u95f4\u5197\u4f59 \u4e3b\u8981\u4f53\u73b0\u50cf\u7d20\u95f4\u76f8\u5173\u6027\uff0c\u81ea\u76f8\u5173\u7cfb\u6570\u4e3a\uff1a A(\\Delta n)=\\frac{1}{N-\\Delta n} \\sum^{N-\\Delta n-1}_{X=0}f(x,y)f(x+\\Delta n,y) A(\\Delta n)=\\frac{1}{N-\\Delta n} \\sum^{N-\\Delta n-1}_{X=0}f(x,y)f(x+\\Delta n,y) 3\uff09\u5fc3\u91cc\u89c6\u89c9\u5197\u4f59 \u4e3b\u8981\u4e0e\u4eba\u89c2\u5bdf\u56fe\u50cf\u7684\u65b9\u5f0f\u6709\u5173\uff0c\u5fc3\u7406\u89c6\u89c9\u5197\u4f59\u4e0e\u5b9e\u5728\u7684\u89c6\u89c9\u4fe1\u606f\u6709\u8054\u7cfb \u56fe\u50cf\u4fdd\u771f\u5ea6 \u63cf\u8ff0\u89e3\u7801\u56fe\u50cf\u76f8\u5bf9\u4e8e\u539f\u59cb\u56fe\u50cf\u7684\u504f\u79bb\u7a0b\u5ea6\u3002 1\uff09\u4e3b\u7ba1\u4fdd\u771f\u5ea6\u51c6\u5219 \u4e3b\u7ba1\u89c2\u6d4b\u56fe\u50cf\u7684\u8d28\u91cf\uff0c\u5e76\u5bf9\u56fe\u50cf\u505a\u51fa\u8bc4\u4ef7\uff0c\u4f8b\u5982\u4f18\u79c0\u3001\u826f\u597d\u3001\u53ef\u7528\u3001\u521a\u53ef\u770b\u3001\u5dee\u548c\u4e0d\u80fd\u7528\u3002 2\uff09\u5ba2\u89c2\u4fdd\u771f\u5ea6\u51c6\u5219 \u7528\u7f16\u7801\u8f93\u5165\u56fe\u4e0e\u89e3\u7801\u8f93\u51fa\u56fe\u7684\u67d0\u4e2a\u786e\u5b9a\u51fd\u6570\u8868\u793a\u635f\u5931\u7684\u4fe1 \u606f\u91cf\uff0c \u4fbf\u4e8e\u8ba1\u7b97\u6216\u6d4b\u91cf \u56fe\u50cf\u7f16\u7801\u6a21\u578b \u7f16\u7801\u6a21\u578b\u5206\u4e3a\u4e24\u79cd\uff1a\u4fe1\u606f\u4fdd\u5b58\u578b\u548c\u4fe1\u606f\u635f\u5931\u578b \u65e0\u5931\u771f\u4fe1\u6e90\u7f16\u7801\u5668\u4e0d\u9700\u8981\u91cf\u5316\u5668 \u56fe\u50cf\u7f16\u7801 1\uff09\u4fe1\u606f\u91cf \u6982\u7387\u4e3aP(E)\u7684\u968f\u673a\u4e8b\u4ef6E\u7684\u4fe1\u606f\u91cf\u4e3a l(E)=log\\frac{1}{P(E)}=-logP(E) l(E)=log\\frac{1}{P(E)}=-logP(E) \uff0c\u5176\u4e2dlog\u4ee52\u4e3a\u5e95\u3002 2\uff09\u7f16\u7801\u6548\u7387 \u4fe1\u606f\u71b5\u516c\u5f0f\uff1a H(u)=-\\sum^J_{j=1}p(a_i)log(P(a_i)) H(u)=-\\sum^J_{j=1}p(a_i)log(P(a_i)) \u5b9a\u4e49\u4e86\u89c2\u5bdf\u5230\u5355\u4e2a\u4fe1\u6e90\u7b26\u53f7\u8f93\u51fa\u65f6\u6240\u83b7\u5f97\u7684\u5e73\u5747\u4fe1\u606f\u91cf \u5e73\u5747\u7801\u957f\uff1a L^*_{avg}=\\sum^{J^n}_{j=1}p(a_i)*l(a_i) L^*_{avg}=\\sum^{J^n}_{j=1}p(a_i)*l(a_i) \u7f16\u7801\u6548\u7387\uff1a \\eta=\\frac{H(u)}{L^*_{avg}}*100\\% \\eta=\\frac{H(u)}{L^*_{avg}}*100\\% 3\uff09\u65e0\u635f\u7f16\u7801--\u53d8\u957f\u7f16\u7801 \u54c8\u592b\u66fc\u7f16\u7801 \u7565 \u9999\u519c-\u6cd5\u8bfa\u6bd4\u90a3\u5417 \u4e3b\u8981\u6b65\u9aa4\u4e3a\uff1a (1) \u5c06\u4fe1\u6e90\u7b26\u53f7\u4f9d\u5176\u6982\u7387\u4ece\u5927\u5230\u5c0f\u6392\u5217 (2) \u5c06\u4fe1\u6e90\u7b26\u53f7\u5206\u6210\u6982\u7387\u548c\u63a5\u8fd1\u7684\u4e24\u90e8\u5206 (3) \u5206\u522b\u7ed9\u4e24\u90e8\u5206\u7684\u4fe1\u6e90\u7b26\u53f7\u7ec4\u5408\u8d4b\u503c (4) \u5982\u679c\u4e24\u90e8\u5206\u5747\u53ea\u6709\u4e00\u4e2a\u4fe1\u6e90\u7b26\u53f7\uff0c\u7f16\u7801\u7ed3\u675f\uff0c\u5426\u5219\u8fd4\u56de(2) \u7ee7\u7eed\u8fdb\u884c \u7279\u5f81 \u4e8c\u8005\u5747\u5177\u6709\u5373\u65f6\u6027\uff0c\u6307\u5bf9\u4efb\u610f\u4e00\u4e2a\u6709\u9650\u7684\u7801\u7b26\u53f7\u4e32\uff0c\u53ef\u4ee5\u5bf9\u6bcf\u4e2a\u7801\u5b57 \u5206\u522b\u89e3\u7801\uff0c\u89e3\u7801\u65f6\u4e0d\u9700\u63a5\u6536\u540e\u9762\u7684\u6240\u6709\u7801\u5b57\u3002 \u4e8c\u8005\u5747\u5177\u6709\u552f\u4e00\u6027\uff0c\u6307\u5bf9\u4efb\u610f\u4e00\u4e2a\u6709\u9650\u957f\u7684\u7801\u7b26\u53f7\u4e32 \uff0c\u53ea\u6709\u4e00\u79cd\u5206\u89e3\u6210\u5176\u5404\u4e2a\u7801\u7b26\u53f7\u7684\u65b9\u6cd5\u3002 4\uff09\u65e0\u635f\u7f16\u7801--\u4f4d\u5e73\u9762\u7f16\u7801 \u4f4d\u5e73\u9762\u5206\u89e3 \u5c06\u591a\u7070\u5ea6\u503c\u56fe\u50cf\u5206\u89e3\u6210\u4e00\u7cfb\u5217\u4e8c\u503c\u56fe \u5bf9\u6bcf\u4e00\u5e45\u4e8c\u503c\u56fe\u518d\u7528\u4e8c\u503c\u538b\u7f29\u65b9\u6cd5\uff0c\u4e3b\u8981\u5305\u62ec\u4f4d\u5e73\u9762\u7684\u5206\u89e3\u548c\u7f16\u7801\u3002 \u4f4d\u5e73\u9762\u5206\u89e3\u662f\u6307\u5bf9\u6bcf\u4e00\u4e2a\u7070\u5ea6\u8fdb\u884c\u91cf\u5316\uff0c\u7136\u540e\u5bf9\u56fe\u7247\u8fdb\u884c\u5206\u5c42\uff0c\u5f97\u5230\u6bcf\u4e00\u5c42\u7684\u7070\u5ea6\u3002 \u5e38\u6570\u5757\u7f16\u7801 \u5e38\u6570\u5757\u7f16\u7801\u662f\u6307\u7528\u4e13\u95e8\u7684\u7801\u5b57\u8868\u8fbe\u5168\u662f0\u62161\u7684\u8fde\u901a\u533a\u57df \u5c06\u56fe\u50cf\u5206\u6210\u5168\u9ed1\uff0c\u5168\u767d\u6216\u6df7\u5408\u7684m*n\u5c3a\u5bf8\u5757\u3002 \u51fa\u73b0\u9891\u7387\u6700\u9ad8\u7684\u7c7b\u8d4b\u4e88 1 bit \u7801\u5b570\uff1b\u5176\u5b83\u4e24\u7c7b\u5206\u522b\u8d4b\u4e882 bit\u7801\u5b5710\u548c11\uff0b mn\u6bd4\u7279\u8868\u793a\u7684\u6a21\u5f0f\u3002 \u538b\u7f29\uff1a\u539f\u9700\u7528mn\u6bd4\u7279\u8868\u793a\u7684\u5e38\u6570\u5757\u4e2d\u7684\u50cf\u7d20\u73b0\u5728\u53ea \u75281 bit \u6765\u8868\u793a\u3001 1-D\u6e38\u7a0b\u7f16\u7801 5\uff09\u65e0\u635f\u7f16\u7801--\u65e0\u635f\u9884\u6d4b\u7f16\u7801 \u9884\u6d4b\u7f16\u7801\uff1a \u7a7a\u57df\u65b9\u6cd5\uff0c\u6d88\u9664\u50cf\u7d20\u95f4\u7684\u5197\u4f59\uff0c\u57fa\u672c\u601d\u60f3\u4e3a\u63d0\u53d6\u6bcf\u4e2a\u50cf\u7d20\u4e2d\u7684\u65b0\u4fe1\u606f\uff08\u5b9e\u9645\u503c\u4e0e\u9884\u6d4b\u503c\u7684\u5dee\uff09\u5e76\u5bf9\u5b83 \u4eec\u7f16\u7801\u3002 \u4e3b\u8981\u5206\u4e3a\u4e24\u79cd\uff0c\u6709\u635f\u9884\u6d4b\u7f16\u7801\u548c\u65e0\u635f\u9884\u6d4b\u7f16\u7801\u3002 \u9884\u6d4b\u7f16\u7801\u4e3b\u8981\u6d88\u9664\u4e86\u50cf\u7d20\u95f4\u5197\u4f59\u3002 6\uff09\u6709\u635f\u7f16\u7801--\u6709\u635f\u9884\u6d4b\u7f16\u7801 7\uff09\u6709\u635f\u7f16\u7801--\u53d8\u6362\u7f16\u7801 \u200b \u53d8\u6362\u7f16\u7801\u7684\u4f5c\u7528\u662f\u5c06\u7a7a\u95f4\u57df\u63cf\u8ff0\u7684\u56fe\u50cf\u4fe1\u53f7\u53d8\u6362\u5230\u9891\u7387\u57df\uff0c\u7136\u540e\u5bf9\u53d8\u6362\u540e\u7684\u7cfb\u6570\u8fdb\u884c\u7f16\u7801\u5904\u7406\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u56fe\u50cf\u5728\u7a7a\u95f4\u4e0a\u5177\u6709\u8f83\u5f3a\u7684\u76f8\u5173\u6027\uff0c\u53d8\u6362\u5230\u9891\u7387\u57df\u53ef\u4ee5\u5b9e\u73b0\u53bb\u76f8\u5173\u548c\u80fd\u91cf\u96c6\u4e2d\u3002 \u53d8\u6362\u9009\u62e9 \uff1a \u4e00\u4e2a\u80fd\u628a\u6700\u591a\u7684\u4fe1\u606f\u96c6\u4e2d\u5230\u6700\u5c11\u7684\u7cfb\u6570\u4e0a\u53bb\u7684\u53d8\u6362\u6240\u4ea7\u751f\u7684 \u91cd\u5efa\u5747\u65b9\u8bef\u5dee\u6700\u5c0f \u4e0d\u540c\u53d8\u6362\u7684\u4fe1\u606f\u96c6\u4e2d\u80fd\u529b\u4e0d\u540c \u2013 \u6b63\u5f26\u7c7b\u53d8\u6362\uff08\u5982DFT\u548cDCT\uff09\u8f83\u4f18 \u2013 \u975e\u6b63\u5f26\u7c7b\u53d8\u6362\uff08\u5982WHT: Walsh-Hadamard\uff09 \u5b9e\u73b0\u7b80\u5355 \u2013 \u5c0f\u6ce2\u53d8\u6362\u8ba1\u7b97\u5feb\u4e14\u6709\u5c40\u90e8\u6027\u8d28\uff08\u4e0d\u9700\u5206\u89e3\uff09 DCT\u662f\u8f83\u597d\u7684\uff08\u7efc\u5408\uff09\u9009\u62e9\uff0c\u96c6\u4e2d\u80fd\u529b\u5f3a\uff0c\u5e76\u4e14\u6240\u9700\u8ba1\u7b97\u91cf\u5c0f\u3002","title":"\u6570\u5b57\u56fe\u50cf\u5904\u7406"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_1","text":"","title":"\u6570\u5b57\u56fe\u50cf\u5904\u7406\u603b\u590d\u4e60"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_2","text":"\u56fe\u50cf\u548c\u6570\u5b57\u56fe\u50cf \u56fe\u50cf\u4e3a\u53ef\u4ee5\u770b\u4f5c\u662f\u5bf9\u7269\u4f53\u6216\u573a\u666f\u7684\u4e00\u79cd\u8868\u73b0\u5f62\u5f0f\uff0c\u62bd\u8c61\u5b9a\u4e49\uff1a\u4e8c\u7ef4\u51fd\u6570f(x, y) \u6570\u5b57\u56fe\u50cf\u4e3a\u79bb\u6563\u5316\u4e86\u7684\u56fe\u50cf\uff0c\u5373\u5bf9x\uff0cy \u548c f \u8fdb\u884c\u79bb\u6563\u5316 \u6570\u5b57\u56fe\u50cf\u5904\u7406\u6982\u5ff5 1.\u72ed\u4e49\uff08\u8f93\u5165\u548c\u8f93\u51fa\uff09\uff1a\u5bf9\u56fe\u50cf\u8fdb\u884c\u5404\u79cd\u52a0\u5de5\uff0c\u4ee5\u6539\u5584\u56fe\u50cf\u7684\u89c6\u89c9\u6548\u679c\u6216\u7a81\u51fa\u76ee\u6807\uff0c\u5f3a\u8c03\u56fe\u50cf\u4e4b\u95f4\u8fdb\u884c\u7684\u53d8\u6362\uff0c\u662f\u4e00\u4e2a\u4ece\u56fe\u50cf\u5230\u56fe\u50cf\u7684\u8fc7\u7a0b 2.\u5e7f\u4e49\uff1a\u4e0e\u56fe\u50cf\u76f8\u5173\u7684\u5904\u7406\uff08\u56fe\u50cf\u5206\u6790\u3001\u7406\u89e3\u548c\u673a\u5668\u89c6\u89c9\uff09 3.\u5e7f\u4e49\u4e0a\u5206\u4e3a\u4e09\u79cd\u7c7b\u578b\uff1a\u4f4e\u3001\u4e2d\u3001\u9ad8\u7ea7\u5904\u7406 \u200b 1\uff09\u4f4e\u7ea7\u5904\u7406\uff1a\u8f93\u5165\u8f93\u51fa\u90fd\u662f\u56fe\u50cf\uff08\u589e\u5f3a\uff0c\u590d\u539f\uff0c\u7f16\u7801\uff0c\u538b\u7f29\uff09 \u200b 2\uff09\u4e2d\u7ea7\u5904\u7406\uff1a\u56fe\u50cf\u5206\u5272\u53ca\u76ee\u6807\u7684\u63cf\u8ff0\uff0c\u8f93\u51fa\u662f\u76ee\u6807\u7684\u7279\u5f81\u6570\u636e \uff08\u68c0\u6d4b\uff0c\u5206\u5272\uff09 \u200b 3\uff09\u9ad8\u7ea7\u5904\u7406\uff1a\u76ee\u6807\u7269\u4f53\u53ca\u76f8\u4e92\u5173\u7cfb\u7684\u7406\u89e3\uff0c\u8f93\u51fa\u662f\u66f4\u62bd\u8c61\u7684\u6570\u636e\uff08\u5206\u7c7b\uff0c\u8bc6\u522b\uff0c\u89e3\u91ca\uff09 \u56fe\u50cf\u5904\u7406\u4e3b\u8981\u662f\u4f4e\u7ea7\u5904\u7406\u53ca\u90e8\u5206\u4e2d\u7ea7\u5904\u7406\u3002","title":"\u7b2c\u4e00\u7ae0 \u7eea\u8bba"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_3","text":"\u56fe\u50cf\u83b7\u53d6 \u4eba\u7c7b\u89c6\u89c9\u7cfb\u7edf\u3001\u5149\u548c\u7535\u78c1\u6ce2\u7406\u8bba\u662f\u6570\u5b57\u56fe\u50cf\u6765\u6e90\u7684\u57fa\u7840 \u4eae\u5ea6\u6210\u50cf\u6a21\u578b 2-D\u4eae\u5ea6\u51fd\u6570\uff1af (x, y)=r (x, y) (\u6ce8\uff1a\u53cd\u5c04\u6210\u5206) * i (x, y) (\u6ce8\uff1a\u7167\u5ea6\u6210\u5206) \u89c6\u7f51\u819c\u4e2d\u592e\u7684\u201c\u89c6\u9525\u7ec6\u80de\u89c6\u89c9\u201d\u548c\u89c6\u7f51\u819c\u8fb9\u7f18\u7684\u201c\u89c6\u6746\u7ec6\u80de\u89c6\u89c9\u201d\uff0c\u4e5f\u53eb\u505a\u660e\u89c6\u89c9\u548c\u6697\u89c6\u89c9\u3002 \u9525\u72b6\u7ec6\u80de\u8d1f\u8d23\u611f\u53d7\u989c\u8272\u4fe1\u606f\u7684\u3002 \u56fe\u50cf\u6570\u5b57\u5316 \u5c06\u4ee3\u8868\u56fe\u50cf\u7684\u8fde\u7eed(\u6a21\u62df)\u4fe1\u53f7\u8f6c\u6362\u4e3a\u79bb\u6563(\u6570\u5b57)\u4fe1\u53f7\u7684\u8fc7\u7a0b\u79f0\u4e3a\u56fe\u50cf\u6570\u5b57\u5316 \u6b65\u9aa4\uff1a\u91c7\u6837\u548c\u91cf\u5316 \u4e3b\u8981\u6280\u672f\uff1a 1) \u6210\u50cf\uff1a\u5149\u4fe1\u606f\uff0d>\u7535\u4fe1\u53f7 2) \u6a21\u6570\u8f6c\u6362\uff08A/D Converter \uff09 \u56fe\u50cf\u91c7\u6837\u548c\u91cf\u5316 \u91c7\u6837\u662f\u5747\u5300\u7684\uff0c\u91cf\u5316\u53ef\u4ee5\u5747\u5300\uff0c\u53ef\u4ee5\u975e\u5747\u5300\u3002 \u91c7\u6837\u548c\u91cf\u5316\u662f\u56fe\u50cf\u83b7\u53d6\u4e2d\u7684\u4e24\u5927\u6280\u672f\u3002 \u7a7a\u95f4\u548c\u7070\u5ea6\u5206\u8fa8\u7387\u662f\u56fe\u50cf\u7684\u57fa\u672c\u5c5e\u6027 1\uff09\u91c7\u6837 \u7a7a\u95f4\u5750\u6807\u7684\u79bb\u6563\u5316\u79f0\u4e3a\u7a7a\u95f4\u91c7\u6837\uff0c\u7b80\u79f0\u91c7\u6837\uff0c\u786e\u5b9a\u4e86\u56fe\u50cf\u7684\u7a7a\u95f4\u5206\u8fa8\u7387 \u5373\u7528\u7a7a\u95f4\u4e0a\u90e8\u5206\u70b9\u7684\u7070\u5ea6\u503c\u4ee3\u8868\u56fe\u50cf\u3002\u8fd9\u4e9b\u70b9\u79f0\u4e3a\u91c7 \u6837\u70b9 \u65b9\u5f0f\u4e3a\u70b9\u9635\u91c7\u6837\uff1a\u76f4\u63a5\u5bf9\u8868\u793a\u56fe\u50cf\u7684\u4e8c\u7ef4\u51fd\u6570\u503c\u8fdb\u884c\u91c7\u6837\uff0c \u6240\u5f97\u7684\u7ed3\u679c\u5c31\u662f\u4e00\u4e2a\u6837\u70b9\u503c\u5e8f\u5217 2\uff09\u91cf\u5316 \u5bf9\u91c7\u6837\u70b9\u4eae\u5ea6\uff08\u7070\u5ea6\uff09\u503c\u7684\u79bb\u6563\u5316\u8fc7\u7a0b\u3002\u786e\u5b9a\u4e86\u56fe\u50cf \u7684\u7070\uff08\u5e45\uff09\u5ea6\u5206\u8fa8\u7387 \u4e24\u79cd\u91cf\u5316\uff1a\u5747\u5300\u91cf\u5316\u3001\u975e\u5747\u5300\u91cf\u5316 \u5747\u5300\u91cf\u5316: \u5c06\u6837\u70b9\u7070\u5ea6\u7ea7\u503c\u7b49\u95f4\u9694\u5206\u6863\u53d6\u6574\uff0c\u79f0\u4e3a\u5747\u5300\u91cf\u5316 \u975e\u5747\u5300\u91cf\u5316: \u5c06\u6837\u70b9\u7070\u5ea6\u7ea7\u503c\u4e0d\u7b49\u95f4\u9694\u5206\u6863\u53d6\u6574 3\uff09\u91c7\u6837\u548c\u91cf\u5316\u7684\u7ea7\u6570 \u5047\u5b9a\u56fe\u50cf\u53d6M\u00d7N\u4e2a\u91c7\u6837\u70b9\uff0c\u5bf9\u6837\u672c\u70b9\u7070\u5ea6\u503c\u8fdb\u884cG\u7ea7\u5206\u6863\u53d6\u6574 \u2013 M, N, G \u4e00\u822c\u53d62\u7684\u6574\u6570\u6b21\u5e42 \u2013M= 2^m 2^m \uff1bN= 2^n 2^n \uff1bG= 2^k 2^k \u50cf\u7d20\u7a7a\u95f4\u7684\u5173\u7cfb 1\uff09\u50cf\u7d20\u7684\u90bb\u57df\u4e0e\u8fde\u63a5 \u90bb\u63a5---\u50cf\u7d20\u95f4\u7684\u7a7a\u95f4\u5173\u7cfb \u2460 \u56db\u90bb\u57df N_4(p),p(x,y)=(x+1,y),(x-1,y),(x,y+1),(x,y-1) N_4(p),p(x,y)=(x+1,y),(x-1,y),(x,y+1),(x,y-1) \u2461 \u5bf9\u89d2\u90bb\u57df N_D(p):p(x,y)=(x-1,y-1),(x+1,y-1),(x-1,y+1),(x+1,y+1) N_D(p):p(x,y)=(x-1,y-1),(x+1,y-1),(x-1,y+1),(x+1,y+1) \u2462 8-\u90bb\u57df N_8(P):p(x,y)=N_4(p)+N_D(p) N_8(P):p(x,y)=N_4(p)+N_D(p) 2\uff09\u8fde\u63a5 \u8fde\u63a5\uff1a\u7a7a\u95f4\u4e0a\u90bb\u63a5\u4e14\u50cf\u7d20\u7070\u5ea6\u503c\u76f8\u4f3c \u4e24\u4e2a\u50cf\u7d20\u662f\u5426\u8fde\u63a5\uff1a (1) \u662f\u5426\u63a5\u89e6\uff08\u90bb\u63a5\uff09 (2) \u7070\u5ea6\u503c\u662f\u5426\u6ee1\u8db3\u67d0\u4e2a\u7279\u5b9a\u7684\u76f8\u4f3c\u51c6\u5219 \u7070\u5ea6\u503c\u76f8\u7b49 \u6216 \u540c\u5728\u4e00\u4e2a\u7070\u5ea6\u503c\u96c6\u5408\u4e2d \u4e09\u79cd\u8fde\u63a5\u65b9\u5f0f\uff0c\u5047\u8bbeV\u4e3a\u7070\u5ea6\u503c\u96c6\u5408 \u2460 4-\u8fde\u63a5 2\u4e2a\u50cf\u7d20 p \u548c r \u5728V \u4e2d\u53d6\u503c \u4e14 r \u5728N4 (p)\u4e2d \u2461 8-\u8fde\u63a5 2\u4e2a\u50cf\u7d20 p \u548c r \u5728V \u4e2d\u53d6\u503c \u4e14 r \u5728N8 (p)\u4e2d \u2462 m-\u8fde\u63a5\uff08\u6df7\u5408\u8fde\u63a5\uff09 2\u4e2a\u50cf\u7d20 p \u548c r \u5728V \u4e2d\u53d6\u503c\uff0c\u4e14\u6ee1\u8db3\u4e0b\u5217\u6761\u4ef6\u4e4b\u4e00 (a) r \u5728 N_4 (p) N_4 (p) \u4e2d (b) r \u5728 N_D (p) N_D (p) \u4e2d\u4e14\u96c6\u5408 N_4 (p) \u2229 N_4 (r) N_4 (p) \u2229 N_4 (r) \u662f\u7a7a\u96c6 \uff08\u8fd9\u4e2a\u96c6\u5408\u662f\u7531 p \u548c r \u7684\u5728V\u4e2d\u53d6\u503c\u76844-\u8fde\u63a5\u50cf\u7d20\u7ec4\u6210\u7684\uff09 3\uff09\u8fde\u901a\u6027 \u50cf\u7d20\u7684\u8fde\u901a \u2013 \u53cd\u6620\u4e24\u4e2a\u50cf\u7d20\u95f4\u7684\u7a7a\u95f4\u5173\u7cfb \u901a\u8def\u548c\u8fde\u901a\uff0c\u79cd\u7c7b\u5206\u4e3a\u56db\u8fde\u901a\uff0c\u516b\u8fde\u901a\uff0cm\u8fde\u901a 4\uff09\u8ddd\u79bb\u5ea6\u91cf \u8ddd\u79bb\u51fd\u6570\u5b9a\u4e49\uff1a \u5bf9\u4e8e\u50cf\u7d20p, q\u548cz, \u5206\u522b\u5177\u6709\u5750\u6807(x, y), (s, t), (u, v), \u5982\u679c\uff1a (a) D(p, q)\u22650 [D(p, q)= 0, \u5f53\u4e14\u4ec5\u5f53 p=q] (b) D(p, q)= D(q, p) \u00a9 D(p, z) \u2264 D(p, q) + D(q, z) \u5219D\u662f\u8ddd\u79bb\u51fd\u6570\u6216\u5ea6\u91cf \u2460 \u6b27\u6c0f\u8ddd\u79bb D_e(p,q)=[(x-s)^2+(y-t)^2]^{1/2} D_e(p,q)=[(x-s)^2+(y-t)^2]^{1/2} \u2461 D4\u8ddd\u79bb\uff08\u57ce\u5e02\u8ddd\u79bb\uff09 D_4( p,q) = |x \u2212 s| + |y \u2212t| D_4( p,q) = |x \u2212 s| + |y \u2212t| \u2462 D8\u8ddd\u79bb\uff08\u68cb\u76d8\u8ddd\u79bb\uff09 D_8(p,q) = max(|x \u2212 s|,| y \u2212t|) D_8(p,q) = max(|x \u2212 s|,| y \u2212t|) \u6ce8\u610f\uff1a De\u8ddd\u79bb\u4e0e\u50cf\u7d20\u7684\u70b9\u5750\u6807\u76f8\u5173\uff0c\u4e0e\u50cf\u7d20\u95f4\u7684\u8fde\u901a\u6027\u65e0\u5173 D4\u548cD8\u8ddd\u79bb\u53ef\u4ee5\u770b\u4f5c\u662f\u901a\u8def\u4e0a\u8fde\u63a5\u7684\u6570\u76ee\u6700\u5c0f\u503c \u5bf9\u4e8eD4\u3001D8\u548cDm\uff0c\u5982\u679c\u50cf\u7d20p\u548cq\u95f4\u65e0\u8fde\u63a5\uff0c\u5219\u8ddd\u79bb\u662f\u65e0\u7a77\u5927 \u4ee5\u540e\u7684\u8ddd\u79bb\u9690\u542b\u8fde\u901a\u6027 \u56fe\u50cf\u7684\u8fd0\u7b97 \u52a0\u6cd5\uff1aC(x, y) = A(x, y) + B(x, y) \u51cf\u6cd5\uff1aC(x, y) = A(x, y) - B(x, y) \u4e58\u6cd5\uff1aC(x, y) = A(x, y) * B(x, y) \u6c42\u53cd\uff1ag(x, y) = 255 - f(x, y) \u5f02\u6216\uff1ag(x, y) = f(x, y) \u2295 h(x, y) \u6216\u8fd0\u7b97\uff1ag(x, y) = f(x, y) | h(x, y) \u4e0e\u8fd0\u7b97\uff1a g(x, y) = f(x, y) & h(x, y) \u56fe\u50cf\u5185\u63d2 \u56fe\u50cf\u5185\u63d2\uff1a\u653e\u5927\uff0c\u6536\u7f29\uff0c\u65cb\u8f6c\uff0c\u51e0\u4f55\u77eb\u6b63 \u653e\u5927\u8fc7\u7a0b\uff1a \u00bb \u539f\u6765\u56fe\u50cf\u5206\u8fa8\u7387\u4e3am\u00d7n \u00bb \u5c06\u56fe\u50cf\u653e\u59271.5\u500d\u4e4b\u540e\uff0c\u5177\u67091.5m\u00d71.5n= 2.25m\u00d7n\u4e2a\u50cf\u7d20 \u00bb \u4e0e\u539f\u6765\u56fe\u50cf\u5177\u6709\u76f8\u540c\u7684\u50cf\u7d20\uff0c\u50cf\u7d20\u6570\u91cf\u662f\u539f\u67652.25\u500d \u00bb \u5c06\u5176\u6536\u7f29\uff0c\u4e0e\u539f\u6765\u56fe\u50cf\u5339\u914d \u00bb \u50cf\u7d20\u95f4\u9694\u5c0f\u4e8e\u539f\u6765\u56fe\u50cf\u50cf\u7d20\u95f4\u9694 \u00bb \u4ece\u539f\u6765\u56fe\u50cf\u50cf\u7d20\u503c\u63d0\u53d6\u4fe1\u606f\u8d4b\u7ed9\u65b0\u56fe\u50cf\u76f8\u5e94\u50cf\u7d20 \u56fe\u50cf\u5185\u63d2\u7684\u4e3b\u8981\u65b9\u6cd5 \u6700\u8fd1\u90bb\u5185\u63d2\u6cd5 \u53cc\u7ebf\u6027\u5185\u63d2\u6cd5 \u53cc\u4e09\u6b21\u5185\u63d2\u6cd5\u3002 \u56fe\u50cf\u7cfb\u7edf \u56fe\u50cf\u5904\u7406\u7cfb\u7edf\u5177\u6709\u56fe\u50cf\u8f93\u5165\u3001\u8f93\u51fa\u3001\u5b58\u50a8\u548c\u5904\u7406\u529f\u80fd\u3002 \u56fe\u50cf\u4e4b\u95f4\u7684\u56db\u5219\u8fd0\u7b97\uff0c\u53ea\u8981\u76f4\u63a5\u8fd0\u7b97\u5c31\u884c\u3002--\u9700\u5bf9\u8d85\u51fa\u7070\u5ea6\u8303\u56f4\u7684\u50cf\u7d20\u8fdb\u884c\u5904\u7406\u3002","title":"\u7b2c\u4e8c\u7ae0 \u6570\u5b57\u56fe\u50cf\u57fa\u7840"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_4","text":"\u7a7a\u57df\u589e\u5f3a\u57fa\u7840 \ud835\udc88(\ud835\udc99, \ud835\udc9a)= \ud835\udc7b[\ud835\udc87(\ud835\udc99, y)] \ud835\udc88(\ud835\udc99, \ud835\udc9a)= \ud835\udc7b[\ud835\udc87(\ud835\udc99, y)] \u5176\u4e2d\ud835\udc87(\ud835\udc99, \ud835\udc9a) \u662f\u8f93\u5165\u56fe\u50cf\uff0c \ud835\udc88(\ud835\udc99, \ud835\udc9a) \u662f\u5904\u7406\u540e\u56fe\u50cf \ud835\udc7b\u662f\u5728\u70b9 (\ud835\udc99, \ud835\udc9a) \u90bb\u57df\u4e0a\u5b9a\u4e49\u7684\u5173\u4e8e\ud835\udc87\u7684\u589e\u5f3a\u64cd\u4f5c\u3002 \u7a7a\u57df\u589e\u5f3a\u8ba1\u7b97\u8fc7\u7a0b\uff1a-\u904d\u5386\u56fe\u50cf\u6240\u6709\u50cf\u7d20 \u2013 \u6bcf\u4e2a\u50cf\u7d20\u5904\uff0c\u7528T\u8ddf\u4ee5(x,y)\u4e3a\u4e2d\u5fc3\u7684\u90bb\u57df\u8fdb\u884c\u8ba1\u7b97 \u2013 \u8fb9\u7f18\u5904\u7406\uff1a\u586b\u96f6 \u76f4\u63a5\u7070\u5ea6\u6620\u5c04 \u5c06 f (x, y)\u4e2d\u7684\u6bcf\u4e2a\u50cf\u7d20\u7070\u5ea6\u6309\ud835\udc7b\u64cd\u4f5c\u76f4\u63a5\u53d8\u6362\u4ee5\u5f97\u5230 g(x, y) \u5178\u578b\u65b9\u6cd5\uff1a \u5bf9\u6570\u53d8\u6362 s=c*log(r+1) s=c*log(r+1) \u6307\u6570\u53d8\u6362 s=cr^{\\gamma} s=cr^{\\gamma} \u03b3>1\u4f4e\u7070\u5ea6\u538b\u7f29\uff0c\u9ad8\u7070\u5ea6\u62c9\u4f38 \u03b3<1\u4f4e\u7070\u5ea6\u62c9\u4f38\uff0c\u9ad8\u7070\u5ea6\u538b\u7f29 \u03b3=1\u5c31\u662f\u6052\u7b49\u53d8\u6362 \u76f4\u65b9\u56fe\u53d8\u6362 \u76f4\u65b9\u56fe\uff08Histogram \uff09 \u6570\u5b57\u56fe\u50cf\u4e2d\u6bcf\u4e00\u7070\u5ea6\u7ea7\uff0c\u5b83\u51fa\u73b0\u7684\u9891\u6570\u7684\u7edf\u8ba1 \u63d0\u4f9b\u4e86\u56fe\u50cf\u50cf\u7d20\u7684\u7070\u5ea6\u503c\u5206\u5e03\u60c5\u51b5 1\uff09\u76f4\u65b9\u56fe\u5747\u8861\u5316 \u76f4\u65b9\u56fe\u5747\u8861\u5316\uff1a\u6307\u56fe\u50cf\u7ecf\u7070\u5ea6\u53d8\u6362\u540e\uff0c\u4f7f\u5f97\u7070\u5ea6\u7684\u6982\u7387\u5bc6\u5ea6\u5206\u5e03\u53d8\u4e3a\u5e38 \u6570\uff0c\u5373\u5747\u5300\u5206\u5e03 \u6ce8\uff1a\u5728\u8be5\u76f4\u65b9\u56fe\u4e2d\uff0c\u5171\u67098\u949f\u7070\u5ea6\uff0c\u5373L=8\u3002 2\uff09\u76f4\u65b9\u56fe\u89c4\u5b9a\u5316 \u901a\u8fc7\u6307\u5b9a\u7684\u51fd\u6570\u5c06\u539f\u56fe\u50cf\u7684\u7070\u5ea6\u76f4\u65b9\u56fe\u53d8\u6362\u6210\u53e6\u4e00\u79cd\u5206\u5e03\u7684\u7070\u5ea6\u76f4\u65b9\u56fe\uff0c\u5373\u786e\u5b9a\u4e00\u4e2aT\u51fd\u6570\uff0c\u6839\u636e\u8fd9\u4e2a\u76f4\u65b9\u56fe\u786e\u5b9a\u4e00\u7070\u5ea6\u7ea7\u53d8\u6362 T\u00ae, \u4f7f\u7531 T\u4ea7\u751f\u7684 \u65b0\u56fe\u8c61\u7684\u76f4\u65b9\u7b26\u5408\u6307\u5b9a\u7684\u76f4\u65b9\u56fe\u3002 3\uff09\u5c40\u90e8\u76f4\u65b9\u56fe\u5904\u7406 \u6709\u65f6\u9700\u8981\u5bf9\u56fe\u50cf\u5c0f\u533a\u57df\u7ec6\u8282\u7684\u5c40\u90e8\u589e\u5f3a\u3002\u89e3\u51b3\u7684\u529e\u6cd5\u5c31\u662f\u5728\u56fe\u50cf\u4e2d\u6bcf\u4e00\u4e2a\u7d20\u7684\u90bb\u57df\u5c31\u662f\u5728\u56fe\u50cf\u4e2d\uff0c\u6839\u636e\u7070\u5ea6\u7ea7\u5206\u5e03 \u8bbe\u8ba1\u53d8\u6362\u51fd\u6570\u3002\u7136\u540e\u5229\u7528\u524d\u9762\u4ecb\u7ecd\u7684\u6280\u672f\u6765\u8fdb\u884c\u5c40\u90e8\u589e\u5f3a\u3002 \u7ebf\u6027\u6ee4\u6ce2 \u6ee4\u6ce2\u5668\u53ef\u5206\u4e3a\u7ebf\u6027\u6ee4\u6ce2\u5668\u548c\u975e\u7ebf\u6027\u6ee4\u6ce2\u5668\uff0c\u9510\u5316\u548c\u5e73\u6ed1\u3002 \u975e\u7ebf\u6027\u6ee4\u6ce2\u5668\u4f5c\u7528\uff1a\u65e2\u6d88\u9664\u566a\u58f0\u53c8\u4fdd\u6301\u7ec6\u8282\uff08\u4e0d\u6a21\u7cca\uff09 \u5e38\u89c1\u6ee4\u6ce2\u5668\uff1a \u90bb\u57df\u5e73\u5747 --\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u6a21\u7248\u7cfb\u6570\u90fd\u662f\u6b63\u7684\uff0c\u4fdd\u6301\u7070\u5ea6\u503c\u8303\u56f4\uff08\u7cfb\u6570\u4e4b\u548c\u4e3a1\uff09 z=\\frac{1}{M} \\sum ^{M-1}_{i=0} (k_i*s_i) z=\\frac{1}{M} \\sum ^{M-1}_{i=0} (k_i*s_i) M\u7684\u5927\u5c0f\u4e0d\u540c\uff0c\u5e73\u6ed1\u7684\u6548\u679c\u4e5f\u4e0d\u540c\u3002 \u6a21\u677f\u5c3a\u5bf8\u589e\u5927\u65f6\uff0c\u5bf9\u566a\u58f0\u6d88\u9664\u6548\u679c\u589e\u5f3a\uff0c\u4f46\u56fe\u50cf\u53d8\u5f97\u6a21\u7cca\uff0c\u5373\u8fb9\u7f18\u7ec6\u8282\u51cf\u5c11\u3002 \u52a0\u6743\u5e73\u5747 --\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u4e0d\u540c\u4f4d\u7f6e\u7684\u7cfb\u6570\u91c7\u7528\u4e0d\u540c\u7684\u503c\uff0c\u4e00\u822c\u8ba4\u4e3a\uff1a\u79bb\u6a21\u677f\u4e2d\u5fc3\u8fd1\u7684\u50cf\u7d20\u5bf9\u6ee4\u6ce2\u8d21\u732e\u5927\uff0c\u6240\u4ee5\u7cfb\u6570\u5927\uff1b \u800c\u5468\u56f4\u7cfb\u6570\u5c0f\u3002 \u4e2d\u503c\u6ee4\u6ce2\u5668 --\u975e\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u5c06\u6a21\u677f\u4e2d\u5fc3\u4e0e\u50cf\u7d20\u4f4d\u7f6e\u91cd\u5408\uff0c\u8bfb\u53d6\u6a21\u677f\u4e0b\u5404\u5bf9\u5e94\u50cf\u7d20\u7684\u7070\u5ea6\u503c\uff0c\u5c06\u8fd9\u4e9b\u7070\u5ea6\u503c\u4ece\u5c0f\u5230\u5927\u6392\u6210 1\u5217\uff0c\u627e\u51fa\u8fd9\u4e9b\u503c\u91cc\u6392\u5728\u4e2d\u95f4\u7684 1\u4e2a\uff0c\u5c06\u8fd9\u4e2a\u4e2d\u95f4\u503c\u8d4b\u7ed9\u6a21\u677f\u5fc3\u4f4d\u7f6e\u50cf\u7d20\u3002 \u4e2d\u503c\u6ee4\u6ce2\u5668\u7684\u6d88\u566a\u58f0\u6548\u679c\u4e0e\u6a21\u677f\u7684\u5c3a\u5bf8\u548c\u53c2\u4e0e\u8fd0\u7b97\u7684\u50cf\u7d20\u6570\u6709\u5173\u3002 \u56fe\u50cf\u4e2d\u5c3a\u5bf8\u5c0f\u4e8e\u6a21\u677f\u5c3a\u5bf8\u4e00\u534a\u7684\u8fc7\u4eae\u6216\u8fc7\u6697\u533a\u57df\u5c06\u4f1a\u5728\u6ee4\u6ce2\u540e\u4f1a\u88ab\u6d88\u9664\u6389\u3002 \u767e\u5206\u6bd4\u6ee4\u6ce2\u5668 --\u975e\u7ebf\u6027\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u6700\u5927\u503c\u6ee4\u6ce2\u5668\uff1a g_{max}(x,y)=max_{(s,t)\u2208N(x,y)}[f(s,t)] g_{max}(x,y)=max_{(s,t)\u2208N(x,y)}[f(s,t)] \u6700\u5c0f\u503c\u6ee4\u6ce2\u5668\uff1a g_{min}(x,y)=min_{(s,t)\u2208N(x,y)}[f(s,t)] g_{min}(x,y)=min_{(s,t)\u2208N(x,y)}[f(s,t)] \u4e2d\u70b9\u6ee4\u6ce2\u5668\uff1a g_{mid}(x,y)=\\frac{1}{2}(g_{max}(x,y)+g_{min}(x,y)) g_{mid}(x,y)=\\frac{1}{2}(g_{max}(x,y)+g_{min}(x,y)) \u68af\u5ea6\u6ee4\u6ce2\u5668 --\u975e\u7ebf\u6027\u9510\u5316\u6ee4\u6ce2\u5668 \u5404\u5411\u5f02\u6027\uff0c\u5728X\u548cY\u4e24\u4e2a\u65b9\u5411\u4e0d\u540c\u3002 \u200b \u68af\u5ea6\u66ff\u4ee3\u8ba1\u7b97\u65b9\u6cd5 \u62c9\u666e\u62c9\u65af\u7b97\u5b50\uff0c\u4e8c\u9636\u5bfc\u6570 --\u975e\u7ebf\u6027\u9510\u5316\u6ee4\u6ce2\u5668 \u5fae\u5206\u7b97\u5b50\uff0c\u4f7f\u7528\u540e\u589e\u5f3a\u4e86\u56fe\u50cf\u4e2d\u7070\u5ea6\u7684\u7a81\u53d8\uff0c\u4e0d\u7ea7\u7f13\u6162\u53d8\u5316\u533a\u57df \u628a\u539f\u56fe\u50cf\u4e0e laplace laplace \u56fe\u50cf\u7ebf\u6027\u7ec4\u5408\uff0c\u53ef\u4ee5\u540c\u65f6\u4fdd\u6301 laplace laplace laplace\u9510\u5316\u548c\u539f\u56fe\u50cf\u80cc\u666f\u3002 \u5982\u679c laplace \u7b97\u5b50\u4e2d\u5fc3\u7cfb\u6570\u4e3a\u6b63\uff0c\u5219\u7528\u539f\u56fe\u50cf\u52a0\u4e0a laplace \u56fe\u50cf\uff1b \u5982\u679c laplace \u7b97\u5b50\u4e2d\u5fc3\u7cfb\u6570\u4e3a\u8d1f\uff0c\u5219\u7528\u539f\u56fe\u50cf\u51cf\u53bb laplace\u56fe\u50cf\u3002 \u5c40\u90e8\u589e\u5f3a \u7a7a\u95f4\u57df\u5c40\u90e8\u589e\u5f3a-\u5c40\u90e8\u9009\u62e9\u6839\u636e\u5b9e\u9645\u95ee\u9898\u8981\u6c42\u7075\u6d3b\u8bbe\u5b9a\u3002 \u5bf9\u56fe\u50cf\u5c40\u90e8\u7ec6\u8282\u7684\u589e\u5f3a\u5904\u7406 \u56fe\u50cf\u7684\u7edf\u8ba1\u91cf\uff1a \u7070\u5ea6\u5e73\u5747\u503c m=\\sum^{L-1}_{i=0}r_i*p(r_i) m=\\sum^{L-1}_{i=0}r_i*p(r_i) \u65b9\u5dee\uff08\u4e8c\u9636\u77e9\uff09 \\mu_2(r)=\\sum^{L-1}_{i=0}(r_i-m)^2p(r_i) \\mu_2(r)=\\sum^{L-1}_{i=0}(r_i-m)^2p(r_i) r\u7684n\u9636\u77e9\uff1a \\mu_n(r)=\\sum^{L-1}_{i=0}(r_i-m)^np(r_i) \\mu_n(r)=\\sum^{L-1}_{i=0}(r_i-m)^np(r_i) \u5c40\u90e8\u589e\u5f3a\u7684\u65b9\u6cd5\uff1a g(x,y)=A(x,y)[f(x,y)-m(x,y)]+m(x,y),\u5176\u4e2dA(x,y)=\\frac{k*M}{\\sigma(x,y)} g(x,y)=A(x,y)[f(x,y)-m(x,y)]+m(x,y),\u5176\u4e2dA(x,y)=\\frac{k*M}{\\sigma(x,y)} M\u4e3af(x,y)\u7684\u5747\u503c,m(x,y)\u548c\\sigma(x,y)\u4e3a\u4ee5(x,y)\u4e3a\u4e2d\u5fc3\u90bb\u57df\u5185\u7684\u5747\u503c\u548c\u5747\u65b9\u5dee\u503c M\u4e3af(x,y)\u7684\u5747\u503c,m(x,y)\u548c\\sigma(x,y)\u4e3a\u4ee5(x,y)\u4e3a\u4e2d\u5fc3\u90bb\u57df\u5185\u7684\u5747\u503c\u548c\u5747\u65b9\u5dee\u503c \u57fa\u4e8e\u5c40\u90e8\u7edf\u8ba1\u7684\u589e\u5f3a\u65b9\u6cd5\uff1a \u4ee4 (x,y) (x,y) \u4e3a\u4e00\u50cf\u7d20\u5750\u6807\uff0c S_{xy} S_{xy} \u8868\u793a\u4e00\u786e\u5b9a\u5927\u5c0f\u7684\u90bb\u57df\uff08\u5b50\u56fe\u50cf\uff09\uff0c\u5219 S_{xy} S_{xy} \u7684\u5e73\u5747\u503c m_{xy} m_{xy} \u4e3a\uff1a m_{xy}=\\sum_{(s,t)\u2208(S_{xy}))}(r_{s,t}\u00d7p(r_{s,t})) m_{xy}=\\sum_{(s,t)\u2208(S_{xy}))}(r_{s,t}\u00d7p(r_{s,t})) S_{xy} S_{xy} \u4e2d\u50cf\u7d20\u7684\u65b9\u5dee\u4e3a\uff1a \\sigma^2_{S_{xy}}=\\sum^{(L-1)}_{(s,t)\u2208S_{xy}}\\{[r_{s,t}-m_{s_{xy}}]^2\u00d7p(s_{s,t})\\} \\sigma^2_{S_{xy}}=\\sum^{(L-1)}_{(s,t)\u2208S_{xy}}\\{[r_{s,t}-m_{s_{xy}}]^2\u00d7p(s_{s,t})\\} \u6839\u636e\u4eae\u6697\u548c\u5bf9\u6bd4\u5ea6\u6765\u5224\u65ad\u662f\u5426\u589e\u5f3a\u67d0\u4e00\u70b9\u7684\u4eae\u5ea6\uff0c\u7136\u540e\u5bf9\u5176\u8fdb\u884c\u589e\u5f3a \u4ee4\u6761\u4ef6T=m_{s_{xy}}<=k_0*M_G,k_0<=1.0\u4e14k_1D_G<=\\sigma_{S_{xy}}<=k_2D_G,k_1<=k_2 \u4ee4\u6761\u4ef6T=m_{s_{xy}}<=k_0*M_G,k_0<=1.0\u4e14k_1D_G<=\\sigma_{S_{xy}}<=k_2D_G,k_1<=k_2 g(x,y)=T?E*f(x,y):f(x,y) g(x,y)=T?E*f(x,y):f(x,y)","title":"\u7b2c\u4e09\u7ae0 \u7a7a\u57df\u589e\u5f3a\u6280\u672f"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_5","text":"\u5085\u91cc\u53f6\u53d8\u6362 \u65f6\u57df\u56fe\u50cf\u662f\u4e00\u4e2a\u5468\u671f\u4e14\u8fde\u7eed\u7684\u51fd\u6570\uff0c\u9891\u57df\u56fe\u50cf\u548c\u76f8\u4f4d\u56fe\u50cf\u662f\u4e00\u4e2a\u975e\u5468\u671f\u79bb\u6563\u7684\u51fd\u6570\u3002 \u6b27\u62c9\u516c\u5f0f\uff1a e^{ix}=cos(x)+i*sin(x) e^{ix}=cos(x)+i*sin(x) \u5085\u91cc\u53f6\u53d8\u6362\u7684\u5b9a\u4e49 1\uff09\u4e00\u7ef4\u5085\u91cc\u53f6\u53d8\u6362 \u8fde\u7eed\u51fd\u6570 \u6b63\u53d8\u6362 F\\{f(x)\\}=F(u)=\\int^{+\\infty}_{-\\infty}f(x)e^{-j2*\\pi ux}dx F\\{f(x)\\}=F(u)=\\int^{+\\infty}_{-\\infty}f(x)e^{-j2*\\pi ux}dx \u9006\uff08\u53cd\uff09\u53d8\u6362 f(x)=\\int^{+\\infty}_{-\\infty}F(u)e^{j*2\\pi ux}du f(x)=\\int^{+\\infty}_{-\\infty}F(u)e^{j*2\\pi ux}du \u79bb\u6563\u51fd\u6570 \u6b63\u53d8\u6362 F\\{f(x)\\}=F(u)=\\sum^{N-1}_{x=0}f(x)e^{-2j\\pi ux/N} F\\{f(x)\\}=F(u)=\\sum^{N-1}_{x=0}f(x)e^{-2j\\pi ux/N} \u9006\uff08\u53cd\uff09\u53d8\u6362 F^{-1}\\{f(x)\\}=f(x)=\\frac{1}{N}\\sum^{N-1}_{x=0}F(u)e^{2j\\pi ux} F^{-1}\\{f(x)\\}=f(x)=\\frac{1}{N}\\sum^{N-1}_{x=0}F(u)e^{2j\\pi ux} u=0,1,2,...,N-1 u=0,1,2,...,N-1 2\uff09\u4e8c\u7ef4\u5085\u91cc\u53f6\u53d8\u6362 \u8fde\u7eed\u51fd\u6570 \u6b63\u53d8\u6362 F\\{f(x,y)\\}=F(u,v)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} f(x,y)e^{-j2\\pi ux}dxdy F\\{f(x,y)\\}=F(u,v)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} f(x,y)e^{-j2\\pi ux}dxdy \u9006\uff08\u53cd\uff09\u53d8\u6362 F^{-1}\\{f(x,y)\\}=f(x,y)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} F(u,v)e^{j2\\pi ux}dudv F^{-1}\\{f(x,y)\\}=f(x,y)=\\int ^{+\\infty}_{-\\infty}\\int ^{+\\infty}_{-\\infty} F(u,v)e^{j2\\pi ux}dudv \u79bb\u6563\u51fd\u6570 \u6b63\u53d8\u6362 F(u,v)=\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} f(x,y) e^{-j2\\pi (ux/M+vy/N)} F(u,v)=\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} f(x,y) e^{-j2\\pi (ux/M+vy/N)} u=0,1,2,...,M-1,v=0,1,2,...,N-1 u=0,1,2,...,M-1,v=0,1,2,...,N-1 \u9006\u53d8\u6362 f(x,y)=\\frac{1}{MN}\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} F(u,v) e^{j2\\pi (ux/M+vy/N)} f(x,y)=\\frac{1}{MN}\\sum^{M-1}_{x=0} \\sum^{N-1}_{y=0} F(u,v) e^{j2\\pi (ux/M+vy/N)} x=0,1,2,...,M-1,y=0,1,2,...,N-1 x=0,1,2,...,M-1,y=0,1,2,...,N-1 3\uff09\u9891\u8c31\u57df \u5b9a\u4e49\uff1a\u7531\u5085\u7acb\u53f6\u53d8\u6362\u548c\u9891\u7387\u53d8\u91cf( u, v)\u5b9a\u4e49\u7684\u7a7a\u95f4 \u6027\u8d28\uff1a \u53d8\u6362\u6700\u6162\u7684\u9891\u7387\u6210\u5206(u=0,v=0)\u5bf9\u5e94\u4e00\u5e45\u56fe\u50cf\u7684\u5e73\u5747\u7070\u5ea6\uff0c\u8bc1\u660e\u4e3a\uff1a F(0,0)=\\sum_{x=0}^{M-1}\\sum^{N-1}_{y=0}f(x,y) F(0,0)=\\sum_{x=0}^{M-1}\\sum^{N-1}_{y=0}f(x,y) \u5373 F(0,0)=mean(f(x,y))*M*N F(0,0)=mean(f(x,y))*M*N \uff0c\u6240\u4ee5 |F(0,0)| |F(0,0)| \u662f\u9891\u8c31\u7684\u6700\u5927\u5206\u91cf\u3002 \u9891\u57df\u6709\u67d0\u4e00\u65b9\u5411\u7684\u4eae\u7ebf\u6761\uff0c\u8bf4\u660e\u56fe\u50cf\u4e2d\u4e0e\u4e4b\u5782\u76f4\u65b9\u5411\u4e0a\u6709\u8f83\u591a\u7ebf\u6761\u3002 \u5085\u91cc\u53f6\u53d8\u6362\u662f\u5171\u8f6d\u5bf9\u79f0\u7684\uff0c\u5373 F^*(u,v)=F(-u,-v) F^*(u,v)=F(-u,-v) \u6570\u5b57\u56fe\u50cf\u7684\u9891\u8c31\u662f\u5173\u4e8e\u539f\u70b9\u5076\u5bf9\u79f0\u7684\uff0c\u5373 |F(u,v)|=|F(-u,-v)| |F(u,v)|=|F(-u,-v)| \u6570\u5b57\u56fe\u50cf\u7684\u76f8\u4f4d\u89d2\u662f\u5173\u4e8e\u8fdc\u70b9\u5947\u5bf9\u79f0\u7684\uff0c\u5373 \\varphi(u,v)=-\\varphi(-u,-v) \\varphi(u,v)=-\\varphi(-u,-v) \u5e73\u79fb\u6027\u8d28 \u5085\u7acb\u53f6\u53d8\u6362\u5e73\u79fb\u6027\u8d28\uff0c\u662f\u6307\u5f53\u7a7a\u57df\u56fe\u50cf\u76ee\u6807\u4f4d\u7f6e\u53d8\u5316\u4e4b\u540e\uff0c\u5176\u9891\u8c31\u4e0d\u53d1\u751f\u6539\u53d8\u3002 \u65cb\u8f6c\u6027\u8d28 \u5c3a\u5ea6\u5b9a\u7406 \u5468\u671f\u6027 \u5e94\u7528\uff1a f(x)(-1)^x==F(u-\\frac{M}{2}) f(x)(-1)^x==F(u-\\frac{M}{2}) \u8bc1\u660e\u4e3a\uff1a \u4e8c\u7ef4\u540c\u6837\uff1a 4\uff09\u5085\u91cc\u53f6\u53d8\u6362\u76f8\u4f4d\u8c31 \u7531\u5085\u7acb\u53f6\u53d8\u6362\u7684\u76f8\u4f4d\u6784\u6210\u7684\u77e9\u9635\u3002 \u76f8\u4f4d\u5206\u91cf\u662f\u6307\u5404\u4e2a\u6b63\u5f26\u5206\u91cf\u5173\u4e8e\u539f\u70b9\u7684\u4f4d\u79fb\u7684\u5ea6\u91cf\uff0c\u51b3\u5b9a\u4e86\u56fe\u50cf\u4e2d\u53ef\u8fa8\u522b\u7269\u4f53\u5b9a\u4f4d\u4fe1\u606f\u3002 5\uff09\u5377\u79ef\u5b9a\u7406 6\uff09\u5085\u91cc\u53f6\u53d8\u6362\u65f6\u95f4\u590d\u6742\u5ea6 \u8ba1\u7b97\u4e00\u7ef4\u79bb\u6563\u5085\u91cc\u53f6\u53d8\u6362\uff08DFT\uff09\u516c\u5f0f\u5982\u4e0b\uff1a \u200b \u5176\u4e2d\uff0cN\u8868\u793a\u6570\u636e\u957f\u5ea6\u3002\u7531\u4e0a\u5f0f\u53ef\u77e5\uff0cDFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(N*N) \u4e00\u7ef4FFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(N*logN)\uff0c\u5176\u4e2dN\u8868\u793a\u6570\u636e\u957f\u5ea6 \u5bf9\u4e8e\u4e00\u4e2aM*N\u7684\u4e8c\u7ef4\u6570\u636e\uff0cFFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO( M*N*log(M*N) ) \u82e5M=N\uff0c\u5219\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u7b80\u5316\u4e3aO(N^2*logN) \u5bf9\u4e8eM\u7ef4\u7684\u6570\u636e\uff08\u6bcf\u4e00\u7ef4\u957f\u5ea6\u4e3aA\uff0cB\uff0cC\uff0c...\uff09\uff0c\u5219FFT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO( A*B*C*...* log(A*B*C*...) ) \u82e5\u6bcf\u4e00\u7ef4\u957f\u5ea6\u76f8\u540c\uff0c\u5373A=B=C=...=N\uff0c\u5219\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u7b80\u5316\u4e3aO(N^M*logN) \u79bb\u6563\u4f59\u5f26\u53d8\u6362 1\uff09\u4e8c\u7ef4\u79bb\u6563\u4f59\u5f26\u53d8\u6362\u5b9a\u4e49 \u6c83\u5c14\u4ec0\u53d8\u6362","title":"\u7b2c\u56db\u7ae0 \u9891\u57df\u5904\u7406"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_6","text":"\u9891\u7387\u57df\u589e\u5f3a\u539f\u7406 1\uff09\u5377\u79ef\u4ee5\u53ca\u5377\u79ef\u5b9a\u7406 \u8bbe\u51fd\u6570f (x, y)\u4e0e\u7b97\u5b50h(x, y)\u7684\u5377\u79ef\u7ed3\u679c\u662fg(x, y)\uff0c\u5373 g(x, y) = h(x, y) * f (x, y)\uff0c\u90a3\u4e48\u6839\u636e\u5377\u79ef\u5b9a\u7406\u5728\u9891\u57df\u6709\uff1a G(u,v) = H(u,v)F(u,v)\uff0c\u5176\u4e2dG(u, v)\uff0cH(u, v)\uff0cF(u, v)\u5206\u522b\u662fg(x, y)\uff0ch(x, y)\uff0cf (x, y)\u7684\u5085\u7acb\u53f6(\u6216\u5176\u5b83)\u53d8\u6362\uff0c\u79f0H(u, v)\u4e3a\u8f6c\u79fb\u51fd\u6570 G(u,v) = H(u,v)F(u,v) 2\uff09\u56fe\u50cf\u589e\u5f3a\u539f\u7406 \u5176\u4e2dT\u4ee3\u8868\u5085\u91cc\u53f6\u53d8\u6362 3\uff09\u56fe\u50cf\u589e\u5f3a\u5177\u4f53\u5b9e\u73b0 \u5377\u79ef\u5b9a\u7406\uff1a G(u,v)=H(u,v)F(u,v) G(u,v)=H(u,v)F(u,v) \u589e\u5f3a\u56fe\u50cf\uff1a g(x,y)=T^{-1}[H(u,v)F(u,v)] g(x,y)=T^{-1}[H(u,v)F(u,v)] \u6b65 \u9aa4\uff1a (1) \u8ba1\u7b97\u56fe\u50cf\u7684\u9891\u57df\u53d8\u6362 (2) \u5728\u9891\u57df\u6ee4\u6ce2 (3) \u53cd\u53d8\u6362\u56de\u56fe\u50cf\u7a7a\u95f4 \u9891\u57df\u6ee4\u6ce2: \u4f4e\u901a\uff0c\u9ad8\u901a\uff0c\u540c\u6001 \u9891\u7387\u57df\u5e73\u6ed1\u6ee4\u6ce2\u5668 1\uff09\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u56fe\u50cf\u4e2d\u7684\u8fb9\u7f18\u548c\u566a\u58f0\u90fd\u5bf9\u5e94\u56fe\u50cf\u5085\u7acb\u53f6\u53d8\u6362\u4e2d\u7684\u9ad8\u9891\u90e8\u5206 \uff0c\u6240\u4ee5\u5982\u8981\u5728\u9891\u57df\u4e2d\u6d88\u5f31\u5176\u5f71\u54cd\u5c31\u8981\u8bbe\u6cd5\u51cf\u5f31\u8fd9\u90e8\u5206\u9891\u7387\u7684\u5206\u91cf\u3002 2\uff09\u7406\u60f3\u4f4e\u901a\u6ee4\u6ce2\u5668 H(u,v)=1:0?D(u,v)<D_0\uff0c\u5176\u4e2dD(u,v)=(u^2+v^2)^{1/2} H(u,v)=1:0?D(u,v)<D_0\uff0c\u5176\u4e2dD(u,v)=(u^2+v^2)^{1/2} \u95ee\u9898\uff1a\u6a21\u7cca\uff0c\u632f\u94c3\u6548\u5e94\u3002 3\uff09\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668 \u51cf\u5c11\u632f\u94c3\u6548\u5e94\uff0c\u9ad8\u4f4e\u9891\u7387\u95f4\u7684\u8fc7\u6e21\u6bd4\u8f83\u5149\u6ed1\u3002 \u9636\u6570\u4e3an\u7684\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668\u516c\u5f0f\u4e3a\uff1a H(u,v)=\\frac{1}{1+D(u,v)^{2n}} H(u,v)=\\frac{1}{1+D(u,v)^{2n}} \u9636\u6570\u5bf9\u632f\u94c3\u73b0\u8c61\u7684\u5f71\u54cd\uff1a\u9636\u6570\u8d8a\u9ad8\uff0c\u8d8a\u660e\u663e\u3002 \u5f53\u9636\u6570\u8d8b\u4e8e\u65e0\u7a77\u65f6\uff0c\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u53d8\u6210\u7406\u60f3\u4f4e\u901a\u6ee4\u6ce2\u3002 4\uff09\u5e94\u7528 \u56fe\u50cf\u7531\u4e8e\u91cf\u5316\u4e0d\u8db3\u4ea7\u751f\u865a\u5047\u8f6e\u5ed3\u65f6\u5e38\u53ef\u7528\u4f4e\u901a\u6ee4\u6ce2\u8fdb\u884c\u5e73\u6ed1\u4ee5\u6539\u8fdb\u56fe\u50cf\u8d28\u91cf\u3002 5\uff09\u9ad8\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668 \u9ad8\u65af\u6ee4\u6ce2\u5668\u662f\u5b8c\u5168\u4e0d\u4f1a\u4ea7\u751f\u632f\u94c3\u6548\u5e94\u7684\u3002 H(u,v)=e^{-D^2(u,v)/2D_0)^2} H(u,v)=e^{-D^2(u,v)/2D_0)^2} 6\uff09\u5176\u4ed6\u4f4e\u901a\u6ee4\u6ce2\u5668 \u9891\u7387\u57df\u9510\u5316\u6ee4\u6ce2\u5668 1\uff09\u7406\u60f3\u9ad8\u901a\u6ee4\u6ce2\u5668 \u5f62\u72b6\u4e0e\u4f4e\u901a\u6ee4\u6ce2\u5668\u7684\u5f62\u72b6\u6b63\u597d\u76f8\u53cd H(u,v)=0:1?D(u,v)>D_0 H(u,v)=0:1?D(u,v)>D_0 2\uff09\u5df4\u7279\u6c83\u65af\u9ad8\u901a\u6ee4\u6ce2\u5668 \u5f62\u72b6\u4e0e\u5df4\u7279\u6c83\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668\u7684\u5f62\u72b6\u6b63\u597d\u76f8\u53cd H(u,v)=\\frac{1}{1+[D_0/D(u,v)]^{2n}} H(u,v)=\\frac{1}{1+[D_0/D(u,v)]^{2n}} 3\uff09\u9ad8\u65af\u9ad8\u901a\u6ee4\u6ce2\u5668 \u5f62\u72b6\u4e0e\u9ad8\u65af\u4f4e\u901a\u6ee4\u6ce2\u5668\u7684\u5f62\u72b6\u6b63\u597d\u76f8\u53cd H(u,v)=1-e^{-D^2(u,v)/2D_0)^2} H(u,v)=1-e^{-D^2(u,v)/2D_0)^2} \u9ad8\u9891\u5f3a\u8c03\u6ee4\u6ce2\u5668 \u9ad8\u901a\u6ee4\u6ce2\u7684\u7ed3\u679c\uff1a\u8fb9\u7f18\u52a0\u5f3a\uff0c\u5149\u6ed1\u533a\u57df\u53d8\u6697 \u9ad8\u901a\u6ee4\u6ce2\uff1a G(u,v)=H(u,v)F(u,v) G(u,v)=H(u,v)F(u,v) \u9ad8\u901a\u5f3a\u8c03\u8f6c\u79fb\u51fd\u6570\uff1a H_c(u,v)=k\u00d7H(u,v)+c H_c(u,v)=k\u00d7H(u,v)+c \u9ad8\u9891\u5f3a\u8c03\u8f93\u51fa\u56fe\u7684\u5085\u7acb\u53f6\u53d8\u6362\uff1a G_c(u,v)=k\u00d7G(u,v)+c\u00d7F(u,c) G_c(u,v)=k\u00d7G(u,v)+c\u00d7F(u,c) \u53cd\u53d8\u6362\u4e3a\uff1a g(x,y)=k\u00d7g(x,y)+c\u00d7f(x,y) g(x,y)=k\u00d7g(x,y)+c\u00d7f(x,y) \u9ad8\u9891\u63d0\u5347\u6ee4\u6ce2\u5668 \u7528\u539f\u59cb\u56fe\u51cf\u53bb\u4f4e\u901a\u56fe\u5f97\u5230\u9ad8\u901a\u6ee4\u6ce2\u5668\u7684\u6548\u679c\u3002 \u628a\u539f\u59cb\u56fe\u4e58\u4ee5\u4e00\u4e2a\u653e\u5927\u7cfb\u6570A\u518d\u51cf\u53bb\u4f4e\u901a\u56fe\u5c31\u53ef\u6784 \u6210\u9ad8\u9891\u63d0\u5347\uff08high-boost\uff09\u6ee4\u6ce2\u5668 G_{HB}(u,v)=A\u00d7F(u,v)-F_L(u,v)=(A-1)F(u,v)+F_H(u,v) G_{HB}(u,v)=A\u00d7F(u,v)-F_L(u,v)=(A-1)F(u,v)+F_H(u,v) A = 1 \uff1a\u9ad8\u901a\u6ee4\u6ce2\u5668 A > 1 \uff1a\u539f\u59cb\u56fe\u7684\u4e00\u90e8\u5206\u4e0e\u9ad8\u901a\u56fe\u76f8\u52a0\uff0c\u6062\u590d\u4e86\u9ad8\u901a\u6ee4\u6ce2\u65f6\u4e22\u5931\u7684\u4f4e\u9891\u5206\u91cf \u540c\u6001\u6ee4\u6ce2 \u5c06\u660e\u4eae\u5747\u8861\u5316\uff0c\u4f7f\u4eae\u5ea6\u548c\u7070\u5ea6\u5747\u8861\u5316\u3002 \u9009\u62e9\u6027\u6ee4\u6ce2 \u5206\u4e3a\u4e24\u79cd\uff1a \u5e26\u963b\u6ee4\u6ce2\u5668&\u5e26\u901a\u6ee4\u6ce2\u5668 1\uff09\u5e26\u963b\u6ee4\u6ce2\u5668 \u5e26\u963b\u6ee4\u6ce2\u5668\u4e5f\u6709\u4e09\u79cd\u7279\u6027\u3002\u7406\u60f3\u3001\u5df4\u7279\u6c83\u65af\u548c\u9ad8\u65af 2\uff09\u5e26\u901a\u6ee4\u6ce2\u5668 \u5e26\u963b\u6ee4\u6ce2\u5668\u4e5f\u6709\u4e09\u79cd\u7279\u6027\u3002\u7406\u60f3\u3001\u5df4\u7279\u6c83\u65af\u548c\u9ad8\u65af 3\uff09\u9677\u6ce2\u6ee4\u6ce2\u5668(Notch Filter) \u9677\u6ce2\u6ee4\u6ce2\u5668\u672c\u8d28\u4e0a\u662f\u591a\u4e2a\u9ad8\u901a\u6ee4\u6ce2\u5668\u8fdb\u884c\u5e73\u79fb\u540e\u518d\u76f8\u4e58\u3002 \u591a\u4e2a\u5e26\u963b\u6ee4\u6ce2\u5668\u7ecf\u8fc7\u5e73\u79fb\u83b7\u5f97\u3002 \u9891\u57df\u6280\u672f\u4e0e\u7a7a\u57df\u6280\u672f 1\uff09\u7a7a\u95f4\u5e73\u6ed1\u6ee4\u6ce2\u5668 \u6d88\u9664\u6216\u51cf\u5f31\u56fe\u50cf\u4e2d\u7070\u5ea6\u503c\u5177\u6709\u8f83\u5927\u8f83\u5feb\u53d8\u5316\u90e8\u5206\u7684\u5f71\u54cd\uff0c \u8fd9\u4e9b\u90e8\u5206\u5bf9\u5e94\u9891\u57df\u4e2d\u7684\u9ad8\u9891\u5206\u91cf\uff0c\u6240\u4ee5\u53ef\u7528\u9891\u57df\u4f4e\u901a\u6ee4\u6ce2\u6765\u5b9e\u73b0 \u9891\u57df\u8d8a\u5bbd\uff0c\u7a7a\u57df\u8d8a\u7a84\uff0c\u5e73\u6ed1\u4f5c\u7528\u8d8a\u5f31 \u9891\u57df\u8d8a\u7a84\uff0c\u7a7a\u57df\u8d8a\u5bbd\uff0c\u6a21\u7cca\u4f5c\u7528\u8d8a\u5f3a \u5e73\u6ed1\u6a21\u677f\u7cfb\u6570\u4e3a\u6b63\uff0c\u4e14\u4e2d\u90e8\u7cfb\u6570\u503c\u8f83\u5927 2\uff09\u7a7a\u95f4\u9510\u5316\u6ee4\u6ce2\u5668 \u6d88\u9664\u6216\u51cf\u5f31\u56fe\u50cf\u4e2d\u7070\u5ea6\u503c\u7f13\u6162\u53d8\u5316\u7684\u90e8\u5206\uff0c\u8fd9\u4e9b\u90e8\u5206\u5bf9\u5e94 \u9891\u57df\u4e2d\u7684\u4f4e\u9891\u5206\u91cf\uff0c\u6240\u4ee5\u53ef\u7528\u9891\u57df\u9ad8\u901a\u6ee4\u6ce2\u6765\u5b9e\u73b0 \u7a7a\u57df\u6709\u6b63\u8d1f\u503c\uff0c\u6a21\u677f\u4e2d\u5fc3\u7cfb\u6570\u503c\u8f83\u5927","title":"\u7b2c\u4e94\u7ae0 \u9891\u7387\u57df\u56fe\u50cf\u589e\u5f3a"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_7","text":"\u56fe\u50cf\u6062\u590dvs.\u56fe\u50cf\u589e\u5f3a \u76f8\u540c\u4e4b\u5904\uff1a \u6539\u8fdb\u8f93\u5165\u56fe\u50cf\u7684\u89c6\u89c9\u8d28\u91cf \u4e0d\u540c\u4e4b\u5904\uff1a \u4e0d\u8003\u8651\u56fe\u50cf\u964d\u8d28\u7684\u539f\u56e0\uff0c\u53ea\u5c06\u56fe\u50cf\u4e2d\u611f\u5174\u8da3\u7684\u7279\u5f81\u6709\u9009\u62e9\u5730 \u7a81\u51fa\uff08\u589e\u5f3a\uff09\uff0c\u800c\u8870\u51cf\u5176\u4e0d\u9700\u8981\u7684\u7279\u5f81\uff0c\u6539\u5584\u540e\u7684\u56fe\u50cf\u4e0d\u4e00\u5b9a\u8981\u53bb \u903c\u8fd1\u539f\u56fe\u50cf\u3002\u56fe\u50cf\u589e\u5f3a\u501f\u52a9\u4eba\u7684\u89c6\u89c9\u7cfb\u7edf\u7279\u6027\uff0c\u4ee5\u53d6\u5f97\u8f83\u597d\u7684\u89c6 \u89c9\u7ed3\u679c\uff08\u4e0d\u8003\u8651\u9000\u5316\u539f\u56e0\uff09 \u56fe\u50cf\u6062\u590d\u6839\u636e\u76f8\u5e94\u7684\u9000\u5316\u6a21\u578b\u548c\u77e5\u8bc6\u91cd\u5efa\u6216\u6062\u590d\u539f\u59cb\u7684\u56fe\u50cf \uff08\u8003\u8651\u9000\u5316\u539f\u56e0\uff09 \u56fe\u50cf\u9000\u5316\u793a\u4f8b \u56fe\u50cf\u9000\u5316\u6307\u7531\u573a\u666f\u5f97\u5230\u7684\u56fe\u50cf\u6ca1\u80fd\u5b8c\u5168\u5730\u53cd\u6620\u573a\u666f\u7684\u771f \u5b9e\u5185\u5bb9\uff0c\u4ea7\u751f\u4e86\u5931\u771f\u7b49\u95ee\u9898 \u539f\u56e0\uff1a\u900f\u955c\u50cf\u5dee/\u8272\u5dee\u3001\u805a\u7126\u4e0d\u51c6\uff08\u5931\u7126\uff0c\u9650\u5236\u4e86\u56fe\u50cf\u9510\u5ea6\uff09\u3001\u6a21\u7cca\uff08\u9650\u5236\u9891\u8c31\u5bbd\u5ea6\uff09\u3001\u566a\u58f0\uff08\u662f\u4e00\u4e2a\u7edf\u8ba1\u8fc7\u7a0b\uff09\u3001\u6296\u52a8\uff08\u673a\u68b0\u3001\u7535\u5b50\uff09 \u56fe\u50cf\u9000\u5316\u590d\u539f\u8fc7\u7a0b\u6a21\u578b \u9000\u5316\u8fc7\u7a0b\u662f\u4e00\u4e2a\u9000\u5316\u51fd\u6570\ud835\udc6f(\u2219) \u548c\u4e00\u4e2a\u52a0\u6027\u566a\u58f0 \ud835\udf3c (\ud835\udc99, \ud835\udc9a) \uff0c\u4f5c\u7528\u5230\u4e00\u5e45\u56fe\u50cf\ud835\udc87(\ud835\udc99, \ud835\udc9a)\u4e0a\uff0c\u4ea7\u751f\u9000\u5316\u540e\u7684 \u56fe\u50cf\ud835\udc88(\ud835\udc99, \ud835\udc9a)\u3002 \u590d\u539f\u8fc7\u7a0b\u662f\u7ed9\u5b9a\u9000\u5316\u56fe\ud835\udc88(\ud835\udc99, \ud835\udc9a)\u548c\u5173\u4e8e\u9000\u5316\u51fd\u6570\ud835\udc6f(\u2219)\u7684\u4e00\u4e9b\u77e5\u8bc6\u53ca\u5173\u4e8e\u52a0\u6027\u566a\u58f0\u9879\ud835\udf3c(\ud835\udc99, \ud835\udc9a)\u7684\u77e5\u8bc6\uff0c\u83b7\u5f97 \u539f\u59cb\u56fe\u50cf\u7684\u4e00\u4e2a\u4f30\u8ba1\ud835\udc87(x,y)\u3002 \u9000\u5316\u6a21\u578b\uff1a g(x,y)=H[f(x,y)]+\\eta(x,y)=h(x,y)*f(x,y)+\\eta(x,y),*\u4e3a\u5377\u79ef g(x,y)=H[f(x,y)]+\\eta(x,y)=h(x,y)*f(x,y)+\\eta(x,y),*\u4e3a\u5377\u79ef G(x,y)=H(x,y)F(x,y+N(x,y)) G(x,y)=H(x,y)F(x,y+N(x,y)) \u566a\u58f0\u6a21\u578b 1\uff09\u5e38\u89c1\u566a\u58f0 \u70ed\u566a\u58f0\uff1a\u4e0e\u7269\u4f53\u7684\u7edd\u5bf9\u6e29\u5ea6\u6709\u5173\u3002 \u4e5f\u79f0\uff1a \u767d\u566a\u58f0 \uff08\u9891\u7387\u8986\u76d6\u6574\u4e2a\u9891\u8c31\uff09 \u9ad8\u65af\u566a\u58f0\uff08\u5e45\u5ea6\u7b26\u5408\u9ad8\u65af\u5206\u5e03\uff09 \u95ea\u70c1\u566a\u58f0\uff1a\u7535\u6d41\u8fd0\u52a8\u4ea7\u751f\u3002 \u5177\u6709\u53cd\u6bd4\u4e8e\u9891\u7387\uff081/f\uff09\u7684\u9891\u8c31 \u4e5f\u79f0\u7c89\u8272\u566a\u58f0\uff08\u5728\u5bf9\u6570\u9891\u7387\u95f4\u9694\u5185\u6709\u76f8\u540c\u7684\u80fd\u91cf\uff09 \u53d1\u5c04\u566a\u58f0\uff1a\u9ad8\u65af\u5206\u5e03\uff08\u7535\u5b50\u8fd0\u52a8\u7684\u968f\u673a\u6027\uff09 **\u52a0\u6027\u566a\u58f0**\u4e00\u822c\u6307\u70ed\u566a\u58f0\u3001\u6563\u5f39\u566a\u58f0\u7b49\uff0c\u5b83\u4eec\u4e0e\u4fe1\u53f7\u7684\u5173\u7cfb\u662f\u76f8\u52a0\uff0c\u4e0d\u7ba1\u6709\u6ca1\u6709\u4fe1\u53f7\uff0c\u8be5\u7c7b\u566a\u58f0\u662f\u4e00\u76f4\u5b58\u5728\u7684\u3002\u4e00\u822c\u901a\u4fe1\u4e2d\u628a\u52a0\u6027\u968f\u673a\u6027\u770b\u6210\u662f\u7cfb\u7edf\u7684\u80cc\u666f\u566a\u58f0\u3002 **\u4e58\u6027\u566a\u58f0**\u4e00\u822c\u7531\u4fe1\u9053\u4e0d\u7406\u60f3\u5f15\u8d77\uff0c\u5b83\u4eec\u4e0e\u4fe1\u53f7\u7684\u5173\u7cfb\u662f\u76f8\u4e58\uff0c\u4fe1\u53f7\u5728\u5b83\u5728\uff0c\u4fe1\u53f7\u4e0d\u5728\u4ed6\u4e5f\u5c31\u4e0d\u5728\u3002\u4e58\u6027\u968f\u673a\u6027\u770b\u6210\u7cfb\u7edf\u7684\u65f6\u53d8\u6027\uff08\u5982\u8870\u843d\u6216\u8005\u591a\u666e\u52d2\uff09\u6216\u8005\u975e\u7ebf\u6027\u6240\u9020\u6210\u7684\u3002 2\uff09\u566a\u58f0\u6982\u7387\u5bc6\u5ea6\u51fd\u6570 3\uff09\u5468\u671f\u566a\u58f0 \u4e00\u5e45\u56fe\u50cf\u7684\u5468\u671f\u566a\u58f0\u662f\u5728\u56fe\u50cf\u83b7\u53d6\u671f\u95f4\u7531\u7535\u529b\u6216\u673a\u7535\u5e72\u6270\u4ea7\u751f\u7684\u3002 \u662f\u4e00\u79cd\u7a7a\u95f4\u76f8\u5173\u566a\u58f0\u3002 \u5468\u671f\u566a\u58f0\uff08\u6b63\u5f26\uff09\u5728\u5085\u91cc\u53f6\u53d8\u6362\u540e\uff0c\u662f\u4f4d\u4e8e\u6b63\u5f26\u6ce2\u5171\u8f6d\u9891\u7387\u5904\u7684\u4e00\u5bf9\u5171\u8f6d\u8109\u51b2\u3002 \u5468\u671f\u566a\u58f0\u53c2\u6570\u4f30\u8ba1\uff1a \u901a\u8fc7\u68c0\u9a8c\u5085\u91cc\u53f6\u8c31\u6765\u4f30\u8ba1\u5468\u671f\u3002 \u5468\u671f\u566a\u58f0\u901a\u5e38\u4f1a\u4ea7\u751f\u9891\u7387\u5c16\u5cf0\uff0c\u53ef\u4ee5\u8fdb\u884c\u68c0\u6d4b\u3002 \u566a\u58f0\u53c2\u6570\u4f30\u8ba1 \u566a\u58f0\u7684PDF\u53c2\u6570 \u6210\u50cf\u7cfb\u7edf\u53ef\u4f7f\u7528 \u4f7f\u7528\u6210\u50cf\u7cfb\u7edf\u83b7\u53d6\u4e00\u7ec4\u201c\u5e73\u5766\u201d\u73af\u5883\u56fe\u50cf\uff0c\u4f5c\u4e3a\u6837\u672c\uff1b\u5373\uff1a\u62cd\u6444\u5149\u7167\u5747\u5300\u7684\u7eaf\u8272\u7070\u5ea6\u56fe\u50cf \u6210\u50cf\u7cfb\u7edf\u4e0d\u53ef\u4f7f\u7528\uff0c\u53ea\u6709\u5176\u751f\u6210\u56fe\u50cf \u4ece\u56fe\u50cf\u4e2d\uff0c\u627e\u4e00\u5757\u5408\u7406\u7684\u6052\u5b9a\u7070\u5ea6\u503c\u533a\u57df\uff0c\u4f5c\u4e3a\u6837\u672c \u56fe\u50cf\u566a\u58f0\u7684\u6982\u7387\u5bc6\u5ea6\u51fd\u6570\u8868\u793a\uff0c\u5176\u81ea\u53d8\u91cf\u662f\u56fe\u50cf\u7070\u5ea6\u503c\u3002 \u53ea\u6709\u566a\u58f0\u7684\u590d\u539f-\u7a7a\u95f4\u6ee4\u6ce2 \u5bf9\u4e8e\u5468\u671f\u566a\u58f0\uff0c\u5728\u9891\u57df\u4f30\u8ba1\ud835\udc75(\ud835\udc96, \ud835\udc97) \uff0c\u76f4\u63a5\u53bb\u6389\uff0c\u53d8\u6362\u5230\u7a7a\u95f4\u57df\u3002 \u52a0\u6027\u566a\u58f0\uff0c\u7a7a\u95f4\u6ee4\u6ce2\u3002 \u5bf9\u4e8e\u56fe\u50cf\u4e2d\u7684\u52a0\u6027\u566a\u58f0\uff0c\u91c7\u7528\u7b97\u672f\u5747\u503c\u6ee4\u6ce2\u3001\u51e0\u4f55\u5747\u503c\u6ee4\u6ce2\u3001\u9006\u8c10\u6ce2\u5747\u503c\u6ee4\u6ce2\u548c\u8c10\u6ce2\u5747\u503c\u6ee4\u6ce2\u53bb\u9664\u3002 1\uff09\u5747\u503c\u6ee4\u6ce2\u5668 2\uff09\u8c10\u6ce2\u5747\u503c\u6ee4\u6ce2\u5668 3\uff09\u4fee\u6b63alpha\u5747\u503c\u6ee4\u6ce2\u5668 4\uff09\u81ea\u9002\u5e94\u6ee4\u6ce2\u5668 \u6ee4\u6ce2\u5668\u7279\u5f81\u53d8\u5316\u662f\u4ee5\ud835\udc8e \u00d7 \ud835\udc8f\u7684\u77e9\u5f62\u7a97\u53e3\ud835\udc7a\ud835\udc99\ud835\udc9a\u5b9a\u4e49\u7684\u6ee4\u6ce2\u5668\u533a\u57df\u5185\u56fe\u50cf\u7684\u7edf\u8ba1\u7279\u5f81\u4e3a\u57fa\u7840 \u81ea\u9002\u5e94\u6ee4\u6ce2\u5668\u6027\u80fd\u4f18\u4e8e\u5168\u5c40\u6ee4\u6ce2\u5668 \u8ba1\u7b97\u590d\u6742\u5ea6\u9ad8 5\uff09\u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u5168\u5c40\u4e2d\u503c\u6ee4\u6ce2\uff0c\u5728\u8109\u51b2\u566a\u58f0\u7a7a\u95f4\u5bc6\u5ea6\u4e0d\u5927\u662f\uff0c\u6027\u80fd\u5f88\u597d\uff08\u7ecf\u9a8c\uff1a\ud835\udc77\ud835\udc82 < \ud835\udfce. \ud835\udfd0\uff0c\ud835\udc77\ud835\udc83 < \ud835\udfce. \ud835\udfd0\uff09 \u2013 \u5bc6\u5ea6\u5927\uff0c\u4e0d\u597d\u7528 \u2013 \u4e0d\u80fd\u5904\u7406\u975e\u8109\u51b2\u566a\u58f0\uff0c\u540c\u65f6\u4fdd\u7559\u7ec6\u8282 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2 \u2013 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u53ef\u4ee5\u5904\u7406\u66f4\u5927\u7684\u5bc6\u5ea6 \u2013 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u80fd\u591f\u5728\u5e73\u6ed1\u975e\u8109\u51b2\u566a\u58f0\u65f6\uff0c\u4fdd\u7559\u7ec6\u8282 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u76f8\u540c\uff1a \u2013 \u6ee4\u6ce2\u5668\u4f5c\u7528\u4e8e\u5c40\u90e8\u533a\u57df\ud835\udc7a\ud835\udc99\ud835\udc9a \u533a\u522b\uff1a \u2013 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u6839\u636e\u67d0\u4e9b\u6761\u4ef6\u6539\u53d8\ud835\udc7a\ud835\udc99\ud835\udc9a\u7684\u5c3a\u5bf8 \u4f7f\u7528\uff1a \u2013 \u6ee4\u6ce2\u5668\u8f93\u51fa\u4e00\u4e2a\u5355\u503c\uff0c\u7528\u4e8e\u4ee3\u66ff\u6ee4\u6ce2\u5668\u7a97\u53e3\ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u5fc3\u5904\u50cf\u7d20 \u81ea\u9002\u5e94\u4e2d\u503c\u6ee4\u6ce2\u5668 \u7b26\u53f7\uff1a \ud835\udc9b\ud835\udc8e\ud835\udc8a\ud835\udc8f = \ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u7684\u6700\u5c0f\u7070\u5ea6\u503c \ud835\udc9b\ud835\udc8e\ud835\udc82\ud835\udc99 = \ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u7684\u6700\u5927\u7070\u5ea6\u503c \ud835\udc9b\ud835\udc8e\ud835\udc86\ud835\udc85 = \ud835\udc7a\ud835\udc99\ud835\udc9a\u4e2d\u7684\u7070\u5ea6\u503c\u4e2d\u503c \ud835\udc9b\ud835\udc99\ud835\udc9a =\u5750\u6807 \ud835\udc99, \ud835\udc9a \u5904\u7684\u7070\u5ea6\u503c \ud835\udc7a\ud835\udc8e\ud835\udc82\ud835\udc99 = \ud835\udc7a\ud835\udc99\ud835\udc9a\u5141\u8bb8\u7684\u6700\u5927\u5c3a\u5bf8 \u5468\u671f\u566a\u58f0\u6d88\u9664 \u5e26\u963b\u6ee4\u6ce2\u5668 \u5e26\u901a\u6ee4\u6ce2\u5668 \uff08\u63d0\u53d6\u566a\u58f0\u6a21\u5f0f\uff09 \u9677\u6ce2\u6ee4\u6ce2\u5668 \u7ebf\u6027\u3001\u4f4d\u7f6e\u4e0d\u53d8\u7684\u9000\u5316 1\uff09\u9000\u5316\u6a21\u578b \u9000\u5316\u6a21\u578b\u516c\u5f0f\uff1a \ud835\udc88(\ud835\udc99, \ud835\udc9a) = \ud835\udc6f[\ud835\udc87(\ud835\udc99, \ud835\udc9a)] + \ud835\udf3c(\ud835\udc99, \ud835\udc9a) \u7b80\u5316\u6a21\u578b\uff1a \ud835\udf3c(\ud835\udc99, \ud835\udc9a)=0 2\uff09\u9000\u5316\u7cfb\u7edfH\u7684\u6027\u8d28 \u4f30\u8ba1\u9000\u5316\u51fd\u6570 \u56fe\u50cf\u89c2\u5bdf\u4f30\u8ba1 \u2013 \u6761\u4ef6\uff1a\u53ea\u6709\u9000\u5316\u56fe\u50cf\uff0c\u6ca1\u6709\u5173\u4e8e\u9000\u5316\u51fd\u6570H\u7684\u4efb\u4f55\u77e5\u8bc6\u3002 \u4ece\u56fe\u50cf\u672c\u8eab\u6765\u6536\u96c6\u4fe1\u606f\uff0c\u5373\u901a\u8fc7\u89c2\u5bdf\u56fe\u50cf\uff0c\u8fdb\u884c\u5904\u7406 \u6765\u83b7\u5f97\u9000\u5316\u51fd\u6570\u4fe1\u606f\u3002 \u65b9\u6cd5\uff1a \u2013 \u4ece\u56fe\u50cf\u4e2d\u9009\u62e9\u4e00\u5c0f\u5757\u533a\u57df\uff0c\u4f5c\u4e3a\u5b50\u56fe\u50cf \u2013 \u56fe\u50cf\u4e2d\u7269\u4f53\u6216\u56fe\u50cf\u80cc\u666f\u4e00\u90e8\u5206 \u2013 \u4e3a\u964d\u4f4e\u566a\u58f0\u5f71\u54cd\uff0c\u627e\u6709\u5f88\u5f3a\u4fe1\u53f7\u7684\u533a\u57df\uff08\u9ad8\u5bf9\u6bd4\u533a\u57df\uff09 \u2013 \u624b\u5de5\u5904\u7406\u5b50\u56fe\u50cf\uff0c\u53bb\u9664\u6a21\u7cca\u3002 \u2013 \u8ba1\u7b97\u51faH(u,v) \u8bd5\u9a8c\u4f30\u8ba1 \u2013 \u6761\u4ef6\uff1a\u53ef\u4ee5\u83b7\u5f97\u4e0e\u9000\u5316\u56fe\u50cf\u8bbe\u5907\u76f8\u4f3c\u7684\u7cfb\u7edf \u2013 \u7406\u8bba\u4e0a\uff1a\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u51c6\u786e\u7684\u9000\u5316\u4f30\u8ba1 \u65b9\u6cd5\uff1a \u2013 \u901a\u8fc7\u8bbe\u7f6e\u7cfb\u7edf\uff0c\u83b7\u5f97\u4e0e\u9000\u5316\u56fe\u50cf\u63a5\u8fd1\u7684\u56fe\u50cf\uff1b \u2013 \u7528\u8be5\u7cfb\u7edf\u4e00\u5e45\u51b2\u6fc0\u6210\u50cf\uff0c\u5f97\u5230\u9000\u5316\u7684\u51b2\u6fc0\u54cd\u5e94\uff1b \u2013 \u51b2\u6fc0\u7528\u4e00\u4e2a\u5c0f\u4eae\u70b9\u6765\u6a21\u62df\uff0c\u5c3d\u53ef\u80fd\u4eae\uff1b \u2013 \ud835\udc6f(\ud835\udc96, \ud835\udc97)= \ud835\udc6e(\ud835\udc96,\ud835\udc97)/\ud835\udc68 \u200b \ud835\udc6e(\ud835\udc96, \ud835\udc97)\u662f\u51b2\u6fc0\u6210\u50cf\u56fe\u50cf\u7684\u5085\u91cc\u53f6\u53d8\u6362\uff0c\ud835\udc68\u662f\u51b2\u6fc0\u7684\u5085\u91cc\u53f6\u53d8\u6362 \u5efa\u6a21\u4f30\u8ba1 \u4ece\u5f15\u8d77\u9000\u5316\u7684\u73af\u5883\u6761\u4ef6\u8003\u8651\uff0c\u8fdb\u884c\u4f30\u8ba1 \u6e4d\u6d41\u9000\u5316\u6a21\u578b\u662f\u5927\u6c14\u6e4d\u6d41\u7269\u7406\u7279\u6027\u7684 \u901a\u7528\u5f62\u5f0f\uff1a \ud835\udc6f(\ud835\udc96, \ud835\udc97)= \ud835\udc86^{\u2212\ud835\udc8c(\ud835\udc96^\ud835\udfd0+\ud835\udc97^\ud835\udfd0)^{\ud835\udfd3/6}} \ud835\udc6f(\ud835\udc96, \ud835\udc97)= \ud835\udc86^{\u2212\ud835\udc8c(\ud835\udc96^\ud835\udfd0+\ud835\udc97^\ud835\udfd0)^{\ud835\udfd3/6}} \u5176\u4e2d\uff0c \ud835\udc8c\u662f\u4e0e\u6e4d\u6d41\u6027\u8d28\u6709\u5173\u7684\u5e38\u6570 \ud835\udc8c = \ud835\udfce. \ud835\udfce\ud835\udfce\ud835\udfd0\ud835\udfd3\u5267\u70c8\u6e4d\u6d41 \ud835\udc8c = \ud835\udfce. \ud835\udfce\ud835\udfce\ud835\udfcf\u4e2d\u7b49\u6e4d\u6d41 \ud835\udc8c = \ud835\udfce. \ud835\udfce\ud835\udfce\ud835\udfce\ud835\udfd0\ud835\udfd3\u8f7b\u5fae\u6e4d\u6d41 \u9006\u6ee4\u6ce2 --\u65e0\u7ea6\u675f\u6062\u590d \u9006\u6ee4\u6ce2\u4e2d\uff0c\u9006\u6ee4\u6ce2\u4e2d\uff0c\u6309\u7167\u79bb\u9891\u8c31\u4e2d\u5fc3\u7684\u8fdc\u8fd1\u5b9a\u4e49\u4e86\u6062\u590d\u8f6c\u79fb\u51fd\u6570\u662f\u632f\u94c3\u6548\u5e94\u51fa\u73b0\u7684\u539f\u56e0\u3002 \u6700\u5c0f\u5747\u65b9\u8bef\u5dee\u6ee4\u6ce2\uff08\u7ef4\u7eb3\u6ee4\u6ce2\uff09 --\u6709\u7ea6\u675f\u6062\u590d \u4e86\u89e3 \u6709\u7ea6\u675f\u6700\u5c0f\u4e8c\u4e58\u65b9\u6062\u590d --\u6709\u7ea6\u675f\u6062\u590d \u4e86\u89e3","title":"\u7b2c\u516d\u7ae0 \u56fe\u50cf\u6062\u590d"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_8","text":"\u5f69\u8272\u57fa\u7840 1\uff09\u989c\u8272\u7684\u672c\u8d28 \u4e0d\u540c\u989c\u8272\u7684\u5149\u5b9e\u8d28\u662f \u4e0d\u540c\u9891\u7387\u7684\u7535\u78c1\u6ce2 \u2013 \u53ef\u89c1\u5149\u8c31\u7684\u6ce2\u957f\u8303\u56f4\uff1a400\uff5e700nm 2\uff09\u4e09\u57fa\u8272 \u5927\u591a\u6570\u7684\u989c\u8272\u53ef\u4ee5\u901a \u8fc7\u7ea2\u3001\u7eff\u3001\u84dd\u4e09\u8272\u6309\u7167 \u4e0d\u540c\u7684\u6bd4\u4f8b\u5408\u6210\u4ea7\u751f 3\uff09\u8272\u5ea6 \u8272\u5ea6 \u5f69\u8272\u7684\u4e09\u79cd\u57fa\u672c\u7279\u6027\u91cf \u4eae\u5ea6\uff1a \u4e0e\u7269\u4f53\u7684\u53cd\u5c04\u7387\u6210\u6b63\u6bd4 \u8272\u8c03\uff1a \u4e0e\u5149\u8c31\u4e2d\u5149\u7684\u6ce2\u957f\u76f8\u8054\u7cfb \u9971\u548c\u5ea6\uff1a\u4e0e\u4e00\u5b9a\u8272\u8c03\u5149\u7684\u7eaf\u5ea6\u6709\u5173 \u8272\u5ea6\uff1a\u8272\u8c03\u548c\u9971\u548c\u5ea6\u5408\u79f0 \u5f69\u8272\u53ef\u7528\u4eae\u5ea6\u548c\u8272\u5ea6\u5171\u540c\u8868\u793a 4\uff09\u8272\u5ea6\u56fe \u5f69\u8272\u6253\u5370\u673a\u662f\u76f8 \u52a0\u8272\u5f69\u548c\u76f8\u51cf\u8272\u5f69\u7684\u6df7\u5408\u7684 \u7ec4\u5408\uff0c\u6240\u4ee5\u5f69\u8272\u57df\u8fb9\u754c\u4e0d\u89c4\u5219\u3002 \u5f69\u8272\u8f6c\u5316\u4e3a\u7070\u5ea6\uff0c\u9002\u5408\u663e\u793a\u5668\u548c\u6444\u50cf\u673a\uff1a Y_{709} = 0.2125R + 0.7154G + 0.0721B Y_{709} = 0.2125R + 0.7154G + 0.0721B \u5f69\u8272\u6a21\u578b \u4e3a\u4e86\u6b63\u786e\u6709\u6548\u5730\u8868\u8fbe\u5f69\u8272\u4fe1\u606f\uff0c\u9700\u8981\u5efa\u7acb\u5408\u9002\u7684\u5f69\u8272\u8868\u8fbe\u6a21\u578b\u3002 1\uff09\u5f69\u8272\u8868\u8fbe\u6a21\u578b \u5f69\u8272\u8868\u8fbe\u6a21\u578b\u5206\u4e3a\u4e24\u79cd\uff1a \u9762\u5411\u786c\u8bbe\u5907\u7684\u5f69\u8272\u6a21\u578b\uff0c\u8bf8\u5982\u5f69\u8272\u663e\u793a\u5668\u6216\u6253\u5370\u673a\u4e4b\u7c7b\u7684\u786c\u8bbe\u5907\uff0c\u4f8b\u5982RGB\uff0cCMY\u6a21\u578b\u7b49\u3002 \u9762\u5411\u89c6\u89c9\u611f\u77e5\u7684\u5f69\u8272\u6a21\u578b\uff0c\u4ee5\u5f69\u8272\u5904\u7406\u4e3a\u76ee\u7684\u7684\u5e94\u7528\uff0c\u4f8b\u5982HSI\u3001HSV\u6a21\u578b\u7b49\u3002 2\uff09RGB\u6a21\u578b \u5efa\u7acb\u5728\u7b1b\u5361\u513f\u5750\u6807\u7cfb\u7edf\u91cc\uff0c\u5176\u4e2d\u4e09 \u4e2a\u8f74\u5206\u522b\u4e3aR\uff0cG\uff0cB\uff0c \u2013 \u6a21\u578b\u7684\u7a7a\u95f4\u662f\u6b63\u65b9\u4f53\uff0c\u539f\u70b9\u5bf9\u5e94\u9ed1 \u8272\uff0c\u79bb\u539f\u70b9\u6700\u8fdc\u7684\u9876\u70b9\u5bf9\u5e94\u767d\u8272 \u2013 \u4ece\u9ed1\u5230\u767d\u7684\u7070\u5ea6\u503c\u5206\u5e03\u5728\u4ece\u539f\u70b9\u5230 \u79bb\u539f\u70b9\u6700\u8fdc\u9876\u70b9\u95f4\u7684\u8fde\u7ebf\u4e0a\uff0c\u800c\u7acb\u65b9\u4f53\u5185\u5176\u4f59\u5404\u70b9\u5bf9\u5e94\u4e0d\u540c\u7684\u989c\u8272\uff0c \u53ef\u7528\u4ece\u539f\u70b9\u5230\u8be5\u70b9\u7684\u77e2\u91cf\u8868\u793a 3\uff09CMY\u6a21\u578b \u4e09\u8865\u8272\uff1a \u84dd\u7eff(C, cyan)\uff0c\u54c1\u7ea2(M, magenta)\uff0c\u9ec4(Y, yellow) \u2013 \u4e3b\u8981\u7528\u4e8e\u5f69\u8272\u6253\u5370\uff0c\u8fd9\u4e09\u79cd\u8865\u8272\u53ef\u5206\u522b\u7531\u4ece\u767d\u5149\u4e2d\u51cf\u53bb\u4e09\u79cd\u57fa\u8272\u800c\u5f97\u5230 \u2013 \u4eceCMY\u5230RGB\u7684\u8f6c\u6362\u4e3aR =1\u2212C\uff0cG =1\u2212 M\uff0cB =1\u2212Y 4\uff09HSI\u6a21\u578b H\uff1a\u70b9s\u7684H\u4e3a\u4e09\u89d2\u5f62 \u4e2d\u5fc3\u70b9\u5230s\u7684\u77e2\u91cf\u4e0eR\u8f74\u7684\u5939\u89d2 S\uff1a\u70b9s\u7684S\u4e3a\u4e09\u89d2 \u5f62\u4e2d\u5fc3\u70b9\u5230s\u7684\u77e2\u91cf\u957f\u5ea6 I\uff1a\u79bb\u5f00\u4e2d\u95f4\u622a\u9762 \u5411\u4e0a\u53d8\u767d\uff1b\u5411\u4e0b\u53d8\u9ed1 \u8272\u8c03\u548c\u9971\u548c\u5ea6\u4e8c\u8005\u5408\u5e76\u79f0\u4e3a\u8272\u5ea6\uff0c\u4eae\u5ea6\u4e2d\u4e0d\u542b\u6709\u989c\u8272\u4fe1\u606f\u3002 H \u8868\u793a\u8272\u8c03\uff08hue\uff09 S \u8868\u793a\u9971\u548c\u5ea6\uff08saturation\uff09 I \u8868\u793a\u5bc6\u5ea6\uff08intensity\uff0c\u5bf9\u5e94\u6210\u50cf\u4eae\u5ea6\u548c\u56fe\u50cf\u7070\u5ea6\uff09 H\u548cS\u5408\u79f0\u8272\u5ea6 I \u5206\u91cf\u4e0e\u56fe\u50cf\u7684\u5f69\u8272\u4fe1\u606f\u65e0\u5173 H \u548c S \u5206\u91cf\u4e0e\u4eba\u611f\u53d7\u989c\u8272\u7684\u65b9\u5f0f\u7d27\u5bc6\u76f8\u8fde \u4f2a\u5f69\u8272\u5904\u7406 \u4eba\u773c\u5bf9\u5f69\u8272\u8272\u6bd4\u5bf9\u7070\u5ea6\u6709\u8f83\u5927\u7684\u5206\u8fa8\u80fd\u529b\u3002 \u4f2a\u5f69\u8272(pseudocolor)\u5904\u7406\u662f\u6307\u5bf9\u539f\u6765\u7070\u5ea6\u56fe\u50cf\u4e2d\u4e0d\u540c\u7070\u5ea6\u503c\u7684\u533a\u57df\u8d4b\u4e88\u4e0d\u540c\u7684\u989c\u8272\u3002 \u5178\u578b\u65b9\u6cd5 (1) \u4eae\u5ea6\u5207\u5272 (2) \u5229\u7528\u53d8\u6362\u51fd\u6570 (3) \u9891\u57df\u6ee4\u6ce2 1\uff09\u4eae\u5ea6\u5207\u5272 \u75281\u4e2a\u5e73\u884c\u4e8e\u56fe\u50cf\u5750\u6807\u5e73\u9762\u7684\u5e73\u9762\u53bb\u5207\u5272\u56fe\u50cf\u4eae\u5ea6\u51fd\u6570\uff0c\u4ece\u800c\u628a\u4eae \u5ea6\u51fd\u6570\u5206\u62102\u4e2a\u7070\u5ea6\u503c\u533a\u95f4\u3002 2\uff09\u4ece\u7070\u5ea6\u5230\u5f69\u8272\u7684\u53d8\u6362\uff08\u6620\u5c04\uff09 3\uff09\u9891\u57df\u6ee4\u6ce2 \u5bf9\u539f\u6765\u7070\u5ea6\u56fe\u50cf\u4e2d\u7684\u4e0d\u540c\u9891\u7387\u5206\u91cf\uff08\u53ef\u5206\u522b\u501f\u52a9\u4f4e\u901a\uff0c\u5e26\u901a/\u5e26\u963b\uff0c\u9ad8\u901a\u6ee4\u6ce2\u5668\u83b7\u5f97\uff09\u8d4b\u4e88\u4e0d\u540c\u7684\u989c\u8272 \u771f\u5f69\u8272\u5904\u7406 1\uff09\u5904\u7406\u65b9\u6cd5 \u5c06\u4e00\u5e45\u5f69\u8272\u56fe\u50cf\u770b\u4f5c\u4e09\u5e45\u5206\u91cf\u56fe\u50cf\u7684\u7ec4\u5408\u4f53\uff0c\u5148\u5206\u522b\u5355\u72ec\u5904\u7406\u6bcf\u4e00\u5e45\u5206\u91cf\u56fe\u50cf\uff0c\u518d\u5c06\u7ed3\u679c\u5408\u6210\u4e00\u5e45\u5904\u7406\u8fc7\u7684\u5408\u6210\u5f69\u8272\u56fe\u50cf \u5c06\u4e00\u5e45\u5f69\u8272\u56fe\u50cf\u4e2d\u7684\u6bcf\u4e2a\u50cf\u7d20\u770b\u4f5c\u5177\u6709\u4e09\u4e2a\u5c5e\u6027\u503c\uff0c\u5373\u5c5e\u6027\u73b0\u5728\u4e3a\u4e00\u4e2a\u77e2\u91cf\uff0c\u5229\u7528\u5bf9\u77e2\u91cf\u7684\u8868\u8fbe\u65b9\u6cd5\u8fdb\u884c\u5904\u7406 2\uff09\u5f69\u8272\u53d8\u6362 g(x,y)=T(f(x,y)) g(x,y)=T(f(x,y)) \u5176\u4e2d\uff0c\ud835\udc87(\ud835\udc99, \ud835\udc9a) \u662f\u5f69\u8272\u8f93\u5165\u56fe\u50cf\uff0c \ud835\udc88(\ud835\udc99, \ud835\udc9a) \u662f\u53d8\u6362\u540e\u7684\u5f69\u8272\u56fe\u50cf\uff0c \ud835\udc7b\u662f\u5728 (\ud835\udc99, \ud835\udc9a) \u7684\u7a7a\u95f4\u90bb\u57df\u4e0a\u5bf9\ud835\udc87\u7684\u4e00\u4e2a\u7b97\u5b50\u3002 \u5206\u91cf\u5f62\u5f0f\uff1a\ud835\udc94\ud835\udc8a = \ud835\udc7b\ud835\udc8a(\ud835\udc93\ud835\udfcf, \ud835\udc93\ud835\udfd0, \u22ef , \ud835\udc93\ud835\udc8f)\uff0c\ud835\udc8a = \ud835\udfcf, \ud835\udfd0, \u22ef , \ud835\udc8f \ud835\udc93\ud835\udc8a\u548c\ud835\udc94\ud835\udc8a\u662f\ud835\udc87 \ud835\udc99, \ud835\udc9a \u548c\ud835\udc88 \ud835\udc99, \ud835\udc9a \u5728\u4efb\u4f55\u70b9\u5904\u5f69\u8272\u5206\u91cf\u53d8\u91cf\uff0c\ud835\udc8f\u662f\u5f69\u8272\u5206\u91cf\u6570\uff1b \ud835\udc7b\ud835\udc8a\u662f\u5bf9\ud835\udc93\ud835\udc8a\u5904\u7406\u4ea7\u751f\ud835\udc94\ud835\udc8a\u7684\u6620\u5c04\u51fd\u6570\uff1b \ud835\udc8f = \ud835\udfd1\u65f6\u5019\uff0c\u662fRGB\u7a7a\u95f4\uff0c\ud835\udc8f = \ud835\udfd2\u65f6\u5019\uff0c\u662fCMYK\u7a7a\u95f4\uff0c 3\uff09\u5f69\u8272\u5f3a\u5ea6\u589e\u5f3a\u53d8\u6362 \u53d8\u6362\u589e\u5f3a \u5bf9\u4e8e\u5f69\u8272\u56fe\u50cf\u589e\u5f3a\u5176\u5f3a\u5ea6\u503c\uff0c\u5373intensity \u8981\u5224\u65ad\u989c\u8272\u6a21\u578b\uff0c\u7136\u540e\u5904\u7406 HSI\u6a21\u578b\uff0cI\u5355\u5206\u91cf\u8fdb\u884c\u589e\u5f3a\u7684\u6b65\u9aa4 (1) \u5c06R\uff0cG\uff0cB\u5206\u91cf\u56fe\u8f6c\u5316\u4e3aH\uff0cS\uff0cI\u5206\u91cf\u56fe (2) \u5229\u7528\u5bf9\u7070\u5ea6\u56fe\u589e\u5f3a\u7684\u65b9\u6cd5\u589e\u5f3a\u5176\u4e2d\u7684I\u5206\u91cf \ud835\udc94\ud835\udfd1 = \ud835\udc8c\ud835\udc93\ud835\udfd1 (3) \u518d\u5c06\u7ed3\u679c\u8f6c\u6362\u4e3aR\uff0cG\uff0cB\u5206\u91cf\u56fe RGB\u6a21\u578b\uff0c\u5f3a\u5ea6\u589e\u5f3a \u4e09\u4e2a\u5206\u91cf\u90fd\u53d8\u6362 \ud835\udc94\ud835\udc8a = \ud835\udc8c\ud835\udc93\ud835\udc8a\uff0c\ud835\udc8a = \ud835\udfcf, \ud835\udfd0, 3 4\uff09\u8865\u8272 \u5728\u8272\u73af\u4e0a\uff0c\u4e0e\u8272\u8c03\u76f4\u63a5\u76f8\u5bf9 \u7684\u53e6\u4e00\u7aef\u79f0\u4e3a\u8865\u8272 \u5728RGB\u7a7a\u95f4\uff0c \u76f4\u63a5\u6c42\u8865\uff1b \u5728HSI\u7a7a\u95f4\uff0c \u6ca1\u6709\u76f4\u63a5\u65b9\u6cd5\uff0c \u53ea\u80fd\u8fd1\u4f3c\u3002 5\uff09\u76f4\u65b9\u56fe\u5747\u8861\u5316 \u5355\u72ec\u5bf9RGB\u5f69\u8272\u56fe\u50cf\u5206\u91cf\u8fdb\u884c\u76f4\u65b9\u56fe\u5747\u8861 \u2013 \u4ea7\u751f\u4e0d\u6b63\u786e\u989c\u8272 \u5747\u5300\u5730\u5c55\u5f00\u8fd9\u79cd\u5f69\u8272\u7070\u5ea6\uff0c\u4fdd\u6301\u5f69\u8272\u672c\u8272\uff08\u8272\u8c03\uff09 \u4e0d\u53d8 \u2013 \u5728HSI\u4e2d\uff0c\u5747\u8861\u5316\u5f69\u8272\u5206\u91cfI\uff0c\u5f69\u8272\u672c\u8eab\uff08\u8272\u8c03\uff09\u4e0d\u53d8 6\uff09\u5f69\u8272\u5e73\u6ed1 \u5c06\u7070\u5ea6\u56fe\u50cf\u90bb\u57df\u5e73\u5747\u6269\u5c55\u5230\u5f69\u8272\u56fe\u50cf\uff0c\u4f7f\u7528\u5411\u91cf\u5e73\u6ed1\u7b97\u5b50 \u5bf9HSI\u6a21\u578b\u4e2d\u7684I\u901a\u9053\u8fdb\u884c\u5e73\u6ed1\uff0cH\u548cS\u901a\u9053\u4e0d\u5904\u7406\uff0c \u989c\u8272\u6ca1\u6709\u53d8\u5316\u3002 7\uff09\u5f69\u8272\u9510\u5316 8\uff09\u9971\u548c\u5ea6\u589e\u5f3a \u2013 \u65b9\u6cd5\uff1a\u8f6c\u5230HSI\u989c\u8272\u7a7a\u95f4\uff0c\u5bf9S\u901a\u9053\u8fdb\u884c\u589e\u5f3a \u2013 \u6548\u679c\uff1a \u2013 \u589e\u5927\u50cf\u7d20\u9971\u548c\u5ea6\u4f1a\u4f7f\u56fe\u50cf\u8272\u5f69\u66f4\u9c9c\u660e \u2013 \u51cf\u5c0f\u50cf\u7d20\u9971\u548c\u5ea6\u4f1a\u4f7f\u56fe\u50cf\u8272\u5f69\u611f\u51cf\u5c11\uff0c\u663e\u5f97\u5e73\u6de1 9\uff09\u8272\u8c03\u589e\u5f3a \u2013 \u65b9\u6cd5\uff1a\u8f6c\u6362\u5230HSI\u989c\u8272\u7a7a\u95f4\uff0c\u7136\u540e\u5bf9H\u8fdb\u884c\u589e\u5f3a \u6548\u679c\uff1a\u56e0\u4e3a\u8272\u8c03\u5bf9\u5e94\u4e00\u4e2a\u89d2\u5ea6 \u2013 \u5fae\u589e\u4e00\u4e2a\u5e38\u6570\uff0c\u4f1a\u4f7f\u989c\u8272\u5728\u8272\u8c31\u4e0a\u79fb\u52a8\u3002 \u2013 \u5e38\u6570\u8f83\u5c0f\u65f6\uff0c\u4f1a\u4f7f\u8272\u8c03\u53d8\u201c\u6696\u201d\u6216\u53d8\u201c\u51b7\u201d \u2013 \u5e38\u6570\u8f83\u5927\u65f6\uff0c\u4f1a\u4f7f\u5f69\u8272\u56fe\u50cf\u53d1\u751f\u5267\u70c8\u53d8\u6362","title":"\u7b2c\u4e03\u7ae0 \u5f69\u8272\u56fe\u50cf\u5904\u7406"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_9","text":"\u7ed3\u6784\u5143 \u5bf9\u6bcf\u4e2a\u7ed3\u6784\u5143\u7d20\uff0c\u5148\u8981\u6307\u5b9a\u4e00\u4e2a\u539f\u70b9\uff0c\u5b83\u662f\u7ed3\u6784\u5143\u7d20\u53c2\u4e0e \u5f62\u6001\u5b66\u8fd0\u7b97\u7684\u53c2\u8003\u70b9\u3002 \u6ce8\u610f\uff1a\u539f\u70b9\u53ef\u4ee5\u5305\u542b\u5728\u7ed3\u6784\u5143\u7d20\u4e2d\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u5305\u542b\u5728\u7ed3 \u6784\u5143\u7d20\u4e2d\uff08\u5373\u539f\u70b9\u5e76\u4e0d\u4e00\u5b9a\u8981\u5c5e\u4e8e\u7ed3\u6784\u5143\u7d20\uff09 \u5bf9\u56fe\u50cf\u64cd\u4f5c\u65f6\u8981\u6c42\u7ed3\u6784\u5143\u7d20\u662f\u77e9\u5f62\u9635\u5217\uff0c\u901a\u8fc7\u6dfb\u52a0\u6700\u5c11\u53ef\u80fd\u7684\u80cc\u666f\u5143\u7d20\u5b9e\u73b0\u3002 \u57fa\u672c\u5f62\u6001\u5b66\u64cd\u4f5c \u6620\u50cf\u548c\u4f4d\u79fb\u662f\u5f62\u6001\u5b66\u5904\u7406\u4e2d\u6269\u5c55\u7684\u96c6\u5408\u8fd0\u7b97\u3002 1\uff09\u81a8\u80c0 A\u2295B = \\{x|(B\u02c6) x \u2229 A \u2260 \\phi \\},\u02c6\u4e3a\u7ffb\u8f6c\u8fd0\u7b97 A\u2295B = \\{x|(B\u02c6) x \u2229 A \u2260 \\phi \\},\u02c6\u4e3a\u7ffb\u8f6c\u8fd0\u7b97 \u5148\u5bf9B\u505a==\u5173\u4e8e\u539f\u70b9\u7684\u6620\u8c61==\uff0c\u518d\u5c06\u5176\u6620\u8c61\u5e73\u79fbx\uff0c\u7ed3\u679c\u662f\u5e73\u79fb\u540e\u4e0eA\u4ea4\u96c6\u4e0d\u4e3a\u7a7a\u7684x\u96c6\u5408\u3002 \u5373\u4e3a\u7528B\u6765\u81a8\u80c0A\u5f97\u5230\u7684\u96c6\u5408\u662f \u7684\u4f4d\u79fb\u4e0eA\u81f3\u5c11\u6709\u4e00 \u4e2a\u975e\u96f6\u5143\u7d20\u5373\u76f8\u4ea4\u65f6B\u7684\u539f\u70b9\u4f4d\u7f6e\u7684\u96c6\u5408\u3002 2\uff09\u8150\u8680 A\u3280B = \\{x |(B)x \u2286 A \\} A\u3280B = \\{x |(B)x \u2286 A \\} B\u79fb\u52a8\u540e\u5b8c\u5168\u5305\u542b\u5728A\u4e2d\u65f6\uff0cB\u7684\u539f\u70b9\u4f4d\u7f6e\u7684\u96c6\u5408 \u4f5c\u7528\uff1a \u539f\u70b9\u5728\u7ed3\u6784\u5143\u7d20\uff08B\u4e2d\uff0c\u6536\u7f29\u56fe\u50cf\u3002 \u7ed3\u6784\u5143\u7d20\u4e0d\u5305\u542b\u539f\u70b9\u65f6\uff0c\u53ef\u4ee5\u7528\u4f5c\u586b\u5145\u5185\u90e8\u7a7a\u6d1e 3\uff09\u8150\u8680\u548c\u81a8\u80c0\u5bf9\u5076\u6027 (A\u3280B)^c=A^c\u2295B\u02c6 (A\u3280B)^c=A^c\u2295B\u02c6 \uff0c\u5176\u4e2dc\u4e3a\u53d6\u8865\u8fd0\u7b97 3\uff09\u5f00\u64cd\u4f5c \u5b9a\u4e49\uff1aB\u5bf9A\u8fdb\u884c\u7684\u5f00\u64cd\u4f5c\u5c31\u662f\u5148\u7528B\u5bf9A\u8150\u8680\uff0c\u7136\u540e\u7528B \u5bf9\u7ed3\u679c\u8fdb\u884c\u81a8\u80c0 \u4f5c\u7528\uff1a\u5f00\u64cd\u4f5c\u65ad\u5f00\u72ed\u7a84\u7684\u95f4\u65ad\u548c\u6d88\u9664\u7ec6\u7684\u7a81\u51fa\u7269 A\u2299B=(A\u3280B)\u2295B A\u2299B=(A\u3280B)\u2295B 4\uff09\u95ed\u64cd\u4f5c \u5b9a\u4e49\uff1aB\u5bf9A\u8fdb\u884c\u7684\u95ed\u64cd\u4f5c\u5c31\u662f\u5148\u7528B\u5bf9A\u81a8\u80c0\uff0c\u7136\u540e\u7528B \u5bf9\u7ed3\u679c\u8fdb\u884c\u8150\u8680 \u4f5c\u7528\uff1a\u95ed\u64cd\u4f5c\u6d88\u5f25\u72ed\u7a84\u7684\u95f4\u65ad\u548c\u957f\u7ec6\u7684\u9e3f\u6c9f\uff0c\u6d88\u9664\u5c0f\u7684\u5b54\u6d1e\uff0c\u5e76 \u586b\u8865\u8f6e\u5ed3\u7ebf\u4e2d\u5c0f\u7684\u65ad\u88c2 A\u2022B=(A\u2295B)\u3280B A\u2022B=(A\u2295B)\u3280B 5\uff09\u5f00\u548c\u95ed\u64cd\u4f5c\u6027\u8d28 (A\u2022B)^c=(A^c\u2299B\u02c6) (A\u2022B)^c=(A^c\u2299B\u02c6) (A\u2299B)\u2286A (A\u2299B)\u2286A A\u2286A\u2022B A\u2286A\u2022B 6\uff09\u51fb\u4e2d\u6216\u51fb\u4e0d\u4e2d\u53d8\u6362 \u57fa\u672c\u7684\u5f62\u6001\u5b66\u7b97\u6cd5 1\uff09\u8fb9\u754c\u63d0\u53d6 \u8bbe\u96c6\u5408A\u7684\u8fb9\u754c\u8868\u793a\u4e3a \u03b2(A)\uff0c\u9009\u53d6\u7ed3\u6784\u5143\u7d20B\uff0c\u5148\u8fdb\u884cB\u5bf9 A\u8150\u8680\uff0c\u800c\u540e\u7528A\u51cf\u53bb\u8150\u8680\u7684\u7ed3\u679c\u3002 2\uff09\u533a\u57df\u586b\u5145 3\uff09\u7ec6\u5316\u64cd\u4f5c \u63d0\u53d6\u56fe\u50cf\u7684\u4e3b\u8981\u6846\u67b6 4\uff09\u8054\u901a\u533a\u57df\u63d0\u53d6 \u65b9\u6cd5\uff1a X_k = (X_{k\u22121} \u2295 B)\u2229A X_k = (X_{k\u22121} \u2295 B)\u2229A \u76f4\u81f3 X_k X_k \u548c X_{k-1} X_{k-1} \u76f8\u540c 5\uff09\u51f8\u58f3 \u57fa\u672c\u7070\u5ea6\u7ea7\u56fe\u50cf\u6269\u5c55\u64cd\u4f5c 1\uff09\u81a8\u80c0 f\u2295b(s,t)=max\\{f(s-x,t-y)+b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} f\u2295b(s,t)=max\\{f(s-x,t-y)+b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} Df\u548cDb\u5206\u522b\u4e3a f \u548c b \u7684\u5b9a\u4e49\u57df\u3002 \u50cf\u7d20\u90fd\u5fc5\u987b\u5728\u5b9a\u4e49\u57df\u5185\uff0c\u4e0e\u96c6\u5408\u4ea4\u96c6\u4e00\u81f4 \u81a8\u80c0\u64cd\u4f5c\u7684\u7ed3\u679c\uff1a \uff08a\uff09\u5982\u679c\u7ed3\u6784\u5143 \u7d20\u7684\u503c\u90fd\u4e3a\u6b63\uff0c\u90a3\u4e48\u8f93\u51fa\u56fe\u50cf\u4f1a\u66f4\u4eae \uff08b\uff09\u6697\u7684\u7ec6\u8282\u90e8 \u5206\u7684\u53d8\u5316\u53d6\u51b3\u4e8e\u7ed3\u6784\u5143\u7d20\u7684\u503c\u548c\u5f62\u72b6 2\uff09\u8150\u8680 f\u3280b(s,t)=min\\{f(s-x,t-y)-b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} f\u3280b(s,t)=min\\{f(s-x,t-y)-b(x,y)|(s-x,t-y) \u2208D_f;(x,y)\u2208 D_b \\} Df\u548cDb\u5206\u522b\u4e3a f \u548c b \u7684\u5b9a\u4e49\u57df\u3002 \u50cf\u7d20\u90fd\u5fc5\u987b\u5728\u5b9a\u4e49\u57df\u5185\uff0c\u4e0e\u7ed3\u6784\u5143\u7d20\u5fc5\u987b\u5b8c\u5168\u5305\u542b\u5728\u88ab\u8150\u8680\u7684 \u96c6\u5408\u5185\u4e00\u81f4 \u8150\u8680\u64cd\u4f5c\u7684\u7ed3\u679c\uff1a \uff08a\uff09\u5982\u679c\u7ed3\u6784\u5143\u7d20\u7684 \u503c\u90fd\u4e3a\u6b63\uff0c\u90a3\u4e48\u8f93\u51fa\u56fe\u50cf\u4f1a\u66f4\u6697 \uff08b\uff09\u4eae\u7684\u7ec6\u8282\u90e8\u5206\u7684\u53d8\u5316\u53d6\u51b3\u4e8e\u7ed3\u6784\u5143\u7d20\u7684\u503c\u548c\u5f62\u72b6 3\uff09\u5f00\u64cd\u4f5c \u5f00\u64cd\u4f5c\uff1a\u5c0f\u7684\u660e\u4eae\u7ec6\u8282\u5c3a\u5bf8\u53d8\u5c0f\uff0c\u6697\u7684\u6548\u679c\u53d7\u5f71\u54cd\u8f83\u5c0f \u95ed\u64cd\u4f5c\uff1a\u5c0f\u7684\u6697\u7ec6\u8282\u7684\u5c3a\u5bf8\u7f29\u5c0f\uff0c\u660e\u4eae\u90e8\u5206\u53d7\u5f71\u54cd\u8f83\u5c0f \u57fa\u672c\u7684\u7070\u5ea6\u7ea7\u5f62\u6001\u5b66\u7b97\u6cd5 1\uff09\u5f62\u6001\u5b66\u5e73\u6ed1 \u5148\u8fdb\u884c\u5f00\u64cd\u4f5c\uff0c\u540e\u8fdb\u884c\u95ed\u64cd\u4f5c \u8ba1\u7b97\u516c\u5f0f\u4e3a\uff1a g=(f\u2299b)\u2022b g=(f\u2299b)\u2022b 2\uff09\u5f62\u6001\u5b66\u68af\u5ea6 \u5f00\u64cd\u4f5c\u51cf\u95ed\u64cd\u4f5c \u8ba1\u7b97\u516c\u5f0f\u4e3a\uff1a g=(f\u2295b)-(f\u3280b) g=(f\u2295b)-(f\u3280b) 3\uff09\u5e3d\u53d8\u6362 \u7528\u4e00\u4e2a\u7ed3\u6784\u5143\u901a\u8fc7\u5f00\u64cd\u4f5c\u6216\u95ed\u64cd\u4f5c\u4ece\u56fe\u50cf\u4e2d\u5220\u9664\u7269\u4f53\u3002 \u7136\u540e\u5dee\u64cd\u4f5c\u5f97\u5230\u4e00\u5e45\u4ec5\u4fdd\u7559\u5df2\u5220\u9664\u5206\u91cf\u7684\u56fe\u50cf\u3002 \u9876\u5e3d\u53d8\u6362 T_{hat}(f)=f-(f\u2299b) T_{hat}(f)=f-(f\u2299b) \u7070\u5ea6\u7ea7\u56fe\u50cff\u7684\u9876\u5e3d\u53d8\u6362\u662ff\u51cf\u53bb\u5176\u5f00\u64cd\u4f5c \u9876\u5e3d\u53d8\u6362\u7528\u4e8e\u5f97\u5230\u6697\u80cc\u666f\u4e0a\u7684\u4eae\u7269\u4f53\uff08\u767d\u9876\u5e3d\uff09 \u4f4e\u5e3d\u53d8\u6362 T_{hat}(f)=(f\u2022b)-f T_{hat}(f)=(f\u2022b)-f \u7070\u5ea6\u7ea7\u56fe\u50cff\u7684\u5e95\u5e3d\u53d8\u6362\u662ff\u7684\u95ed\u64cd\u4f5c\u51cf\u53bbf \u5e95\u5e3d\u53d8\u6362\u7528\u4e8e\u5f97\u5230\u4eae\u80cc\u666f\u4e0a\u7684\u6697\u7269\u4f53\uff08\u9ed1\u5e95\u5e3d\uff09 \u5e3d\u53d8\u6362\u7684\u5e94\u7528\u6709\u6821\u6b63\u4e0d\u5747\u5300\u5149\u7167\u5f71\u54cd\u3001\u7eb9\u7406\u5206\u5272\u548c\u7c92\u5ea6\u6d4b\u5b9a\uff0c\u5177\u4f53\u4f7f\u7528\u7684\u662f\u5f00\u64cd\u4f5c\uff0c\u51cf\u5c11\u4eae\u5ea6\u8f83\u9ad8\u7684\u90e8\u5206\u3002","title":"\u7b2c\u516b\u7ae0 \u5f62\u6001\u5b66\u56fe\u50cf\u5904\u7406"},{"location":"course/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/#_10","text":"\u56fe\u7247\u538b\u7f29 1\uff09\u6570\u636e\u548c\u4fe1\u606f \u6570\u636e\u662f\u4fe1\u606f\u7684\u8f7d\u4f53 \u540c\u91cf\u7684\u6570\u636e\u53ef\u8868\u8fbe\u4e0d\u4fe1\u606f\uff0c\u540c\u91cf\u7684\u4fe1\u606f\u53ef\u7528\u4e0d\u6570\u636e\u8868\u8fbe 2\uff09\u56fe\u7247\u538b\u7f29\u79cd\u7c7b \u4fe1\u606f\u4fdd\u5b58\u578b\u548c\u4fe1\u606f\u635f\u5931\u578b \u6570\u636e\u5197\u4f59 1\uff09\u5197\u4f59\u79cd\u7c7b \u5197\u4f59\u6709\u4e24\u79cd\uff0c\u5206\u522b\u4e3a\u6570\u636e\u8868\u8fbe\u4e86\u65e0\u7528\u7684\u4fe1\u606f\u548c\u6570\u636e\u8868\u8fbe\u4e86\u5df2\u8868\u8fbe\u7684\u4fe1\u606f\u3002 2\uff09\u76f8\u5bf9\u538b\u7f29\u5197\u4f59 \u76f8\u5bf9\u5197\u4f59\u516c\u5f0f\u4e3a R_D=1-\\frac{1}{C_R} R_D=1-\\frac{1}{C_R} \uff0c\u538b\u7f29\u7387\u4e3a C_R=\\frac{n_1}{n2} C_R=\\frac{n_1}{n2} \uff0c C_R C_R \u5728\u533a\u95f4 (0,+\\infty) (0,+\\infty) \u4e2d\u53d6\u503c\u3002n1\u548cn2\u4ee3\u8868\u4e24\u4e2a\u6570\u636e\u96c6\u5408\u4e2d\u7684\u4fe1\u606f\u8f7d\u4f53\u5355\u4f4d\u7684\u6570\u91cf\u3002 3\uff09\u5197\u4f59\u7684\u7c7b\u522b \u7f16\u7801\u5197\u4f59\u3001\u50cf\u7d20\u76f8\u5173\u5197\u4f59\u548c\u5fc3\u91cc\u89c6\u89c9\u5197\u4f59\u3002 \u7f16\u7801\u5197\u4f59\u548c\u4e0e\u7070\u5ea6\u5206\u5e03\u7684\u6982\u7387\u7279\u6027\u6709\u5173\u3002 \u50cf\u7d20\u76f8\u5173\u5197\u4f59\u548c\u7a7a\u95f4\u5197\u4f59\uff0c\u65f6\u95f4\u5197\u4f59\u6709\u5173\u3002 \u5fc3\u7406\u89c6\u89c9\u5197\u4f59\u548c\u4e3b\u89c2\u611f\u89c9\u6709\u5173\u3002 4\uff09\u7f16\u7801\u5197\u4f59 \u56fe\u50cf\u4e2d\u7070\u5ea6\u51fa\u73b0\u7684\u6982\u7387\uff1a p_s(s_k)=n_k/n,k=0,1,..,L-1 p_s(s_k)=n_k/n,k=0,1,..,L-1 \u5e73\u5747\u6bd4\u7279\u6570\uff1a L_{avg}=\\sum^{L-1}_{k=0}l(s_k)p_k(s_k) L_{avg}=\\sum^{L-1}_{k=0}l(s_k)p_k(s_k) \u9884\u671f\u7ed3\u679c\u4e3a\u7528\u8f83\u5c11\u7684\u6bd4\u7279\u6570\u8868\u793a\u51fa\u73b0\u6982\u7387\u8f83\u5927\u7684\u7070\u5ea6\u7ea7\uff0c\u7528\u8f83\u591a\u7684\u6bd4\u7279\u6570\u8868\u793a\u51fa\u73b0\u6982\u7387\u8f83\u5c0f\u7684\u7070\u5ea6\u7ea7 5\uff09\u50cf\u7d20\u95f4\u5197\u4f59 \u4e3b\u8981\u4f53\u73b0\u50cf\u7d20\u95f4\u76f8\u5173\u6027\uff0c\u81ea\u76f8\u5173\u7cfb\u6570\u4e3a\uff1a A(\\Delta n)=\\frac{1}{N-\\Delta n} \\sum^{N-\\Delta n-1}_{X=0}f(x,y)f(x+\\Delta n,y) A(\\Delta n)=\\frac{1}{N-\\Delta n} \\sum^{N-\\Delta n-1}_{X=0}f(x,y)f(x+\\Delta n,y) 3\uff09\u5fc3\u91cc\u89c6\u89c9\u5197\u4f59 \u4e3b\u8981\u4e0e\u4eba\u89c2\u5bdf\u56fe\u50cf\u7684\u65b9\u5f0f\u6709\u5173\uff0c\u5fc3\u7406\u89c6\u89c9\u5197\u4f59\u4e0e\u5b9e\u5728\u7684\u89c6\u89c9\u4fe1\u606f\u6709\u8054\u7cfb \u56fe\u50cf\u4fdd\u771f\u5ea6 \u63cf\u8ff0\u89e3\u7801\u56fe\u50cf\u76f8\u5bf9\u4e8e\u539f\u59cb\u56fe\u50cf\u7684\u504f\u79bb\u7a0b\u5ea6\u3002 1\uff09\u4e3b\u7ba1\u4fdd\u771f\u5ea6\u51c6\u5219 \u4e3b\u7ba1\u89c2\u6d4b\u56fe\u50cf\u7684\u8d28\u91cf\uff0c\u5e76\u5bf9\u56fe\u50cf\u505a\u51fa\u8bc4\u4ef7\uff0c\u4f8b\u5982\u4f18\u79c0\u3001\u826f\u597d\u3001\u53ef\u7528\u3001\u521a\u53ef\u770b\u3001\u5dee\u548c\u4e0d\u80fd\u7528\u3002 2\uff09\u5ba2\u89c2\u4fdd\u771f\u5ea6\u51c6\u5219 \u7528\u7f16\u7801\u8f93\u5165\u56fe\u4e0e\u89e3\u7801\u8f93\u51fa\u56fe\u7684\u67d0\u4e2a\u786e\u5b9a\u51fd\u6570\u8868\u793a\u635f\u5931\u7684\u4fe1 \u606f\u91cf\uff0c \u4fbf\u4e8e\u8ba1\u7b97\u6216\u6d4b\u91cf \u56fe\u50cf\u7f16\u7801\u6a21\u578b \u7f16\u7801\u6a21\u578b\u5206\u4e3a\u4e24\u79cd\uff1a\u4fe1\u606f\u4fdd\u5b58\u578b\u548c\u4fe1\u606f\u635f\u5931\u578b \u65e0\u5931\u771f\u4fe1\u6e90\u7f16\u7801\u5668\u4e0d\u9700\u8981\u91cf\u5316\u5668 \u56fe\u50cf\u7f16\u7801 1\uff09\u4fe1\u606f\u91cf \u6982\u7387\u4e3aP(E)\u7684\u968f\u673a\u4e8b\u4ef6E\u7684\u4fe1\u606f\u91cf\u4e3a l(E)=log\\frac{1}{P(E)}=-logP(E) l(E)=log\\frac{1}{P(E)}=-logP(E) \uff0c\u5176\u4e2dlog\u4ee52\u4e3a\u5e95\u3002 2\uff09\u7f16\u7801\u6548\u7387 \u4fe1\u606f\u71b5\u516c\u5f0f\uff1a H(u)=-\\sum^J_{j=1}p(a_i)log(P(a_i)) H(u)=-\\sum^J_{j=1}p(a_i)log(P(a_i)) \u5b9a\u4e49\u4e86\u89c2\u5bdf\u5230\u5355\u4e2a\u4fe1\u6e90\u7b26\u53f7\u8f93\u51fa\u65f6\u6240\u83b7\u5f97\u7684\u5e73\u5747\u4fe1\u606f\u91cf \u5e73\u5747\u7801\u957f\uff1a L^*_{avg}=\\sum^{J^n}_{j=1}p(a_i)*l(a_i) L^*_{avg}=\\sum^{J^n}_{j=1}p(a_i)*l(a_i) \u7f16\u7801\u6548\u7387\uff1a \\eta=\\frac{H(u)}{L^*_{avg}}*100\\% \\eta=\\frac{H(u)}{L^*_{avg}}*100\\% 3\uff09\u65e0\u635f\u7f16\u7801--\u53d8\u957f\u7f16\u7801 \u54c8\u592b\u66fc\u7f16\u7801 \u7565 \u9999\u519c-\u6cd5\u8bfa\u6bd4\u90a3\u5417 \u4e3b\u8981\u6b65\u9aa4\u4e3a\uff1a (1) \u5c06\u4fe1\u6e90\u7b26\u53f7\u4f9d\u5176\u6982\u7387\u4ece\u5927\u5230\u5c0f\u6392\u5217 (2) \u5c06\u4fe1\u6e90\u7b26\u53f7\u5206\u6210\u6982\u7387\u548c\u63a5\u8fd1\u7684\u4e24\u90e8\u5206 (3) \u5206\u522b\u7ed9\u4e24\u90e8\u5206\u7684\u4fe1\u6e90\u7b26\u53f7\u7ec4\u5408\u8d4b\u503c (4) \u5982\u679c\u4e24\u90e8\u5206\u5747\u53ea\u6709\u4e00\u4e2a\u4fe1\u6e90\u7b26\u53f7\uff0c\u7f16\u7801\u7ed3\u675f\uff0c\u5426\u5219\u8fd4\u56de(2) \u7ee7\u7eed\u8fdb\u884c \u7279\u5f81 \u4e8c\u8005\u5747\u5177\u6709\u5373\u65f6\u6027\uff0c\u6307\u5bf9\u4efb\u610f\u4e00\u4e2a\u6709\u9650\u7684\u7801\u7b26\u53f7\u4e32\uff0c\u53ef\u4ee5\u5bf9\u6bcf\u4e2a\u7801\u5b57 \u5206\u522b\u89e3\u7801\uff0c\u89e3\u7801\u65f6\u4e0d\u9700\u63a5\u6536\u540e\u9762\u7684\u6240\u6709\u7801\u5b57\u3002 \u4e8c\u8005\u5747\u5177\u6709\u552f\u4e00\u6027\uff0c\u6307\u5bf9\u4efb\u610f\u4e00\u4e2a\u6709\u9650\u957f\u7684\u7801\u7b26\u53f7\u4e32 \uff0c\u53ea\u6709\u4e00\u79cd\u5206\u89e3\u6210\u5176\u5404\u4e2a\u7801\u7b26\u53f7\u7684\u65b9\u6cd5\u3002 4\uff09\u65e0\u635f\u7f16\u7801--\u4f4d\u5e73\u9762\u7f16\u7801 \u4f4d\u5e73\u9762\u5206\u89e3 \u5c06\u591a\u7070\u5ea6\u503c\u56fe\u50cf\u5206\u89e3\u6210\u4e00\u7cfb\u5217\u4e8c\u503c\u56fe \u5bf9\u6bcf\u4e00\u5e45\u4e8c\u503c\u56fe\u518d\u7528\u4e8c\u503c\u538b\u7f29\u65b9\u6cd5\uff0c\u4e3b\u8981\u5305\u62ec\u4f4d\u5e73\u9762\u7684\u5206\u89e3\u548c\u7f16\u7801\u3002 \u4f4d\u5e73\u9762\u5206\u89e3\u662f\u6307\u5bf9\u6bcf\u4e00\u4e2a\u7070\u5ea6\u8fdb\u884c\u91cf\u5316\uff0c\u7136\u540e\u5bf9\u56fe\u7247\u8fdb\u884c\u5206\u5c42\uff0c\u5f97\u5230\u6bcf\u4e00\u5c42\u7684\u7070\u5ea6\u3002 \u5e38\u6570\u5757\u7f16\u7801 \u5e38\u6570\u5757\u7f16\u7801\u662f\u6307\u7528\u4e13\u95e8\u7684\u7801\u5b57\u8868\u8fbe\u5168\u662f0\u62161\u7684\u8fde\u901a\u533a\u57df \u5c06\u56fe\u50cf\u5206\u6210\u5168\u9ed1\uff0c\u5168\u767d\u6216\u6df7\u5408\u7684m*n\u5c3a\u5bf8\u5757\u3002 \u51fa\u73b0\u9891\u7387\u6700\u9ad8\u7684\u7c7b\u8d4b\u4e88 1 bit \u7801\u5b570\uff1b\u5176\u5b83\u4e24\u7c7b\u5206\u522b\u8d4b\u4e882 bit\u7801\u5b5710\u548c11\uff0b mn\u6bd4\u7279\u8868\u793a\u7684\u6a21\u5f0f\u3002 \u538b\u7f29\uff1a\u539f\u9700\u7528mn\u6bd4\u7279\u8868\u793a\u7684\u5e38\u6570\u5757\u4e2d\u7684\u50cf\u7d20\u73b0\u5728\u53ea \u75281 bit \u6765\u8868\u793a\u3001 1-D\u6e38\u7a0b\u7f16\u7801 5\uff09\u65e0\u635f\u7f16\u7801--\u65e0\u635f\u9884\u6d4b\u7f16\u7801 \u9884\u6d4b\u7f16\u7801\uff1a \u7a7a\u57df\u65b9\u6cd5\uff0c\u6d88\u9664\u50cf\u7d20\u95f4\u7684\u5197\u4f59\uff0c\u57fa\u672c\u601d\u60f3\u4e3a\u63d0\u53d6\u6bcf\u4e2a\u50cf\u7d20\u4e2d\u7684\u65b0\u4fe1\u606f\uff08\u5b9e\u9645\u503c\u4e0e\u9884\u6d4b\u503c\u7684\u5dee\uff09\u5e76\u5bf9\u5b83 \u4eec\u7f16\u7801\u3002 \u4e3b\u8981\u5206\u4e3a\u4e24\u79cd\uff0c\u6709\u635f\u9884\u6d4b\u7f16\u7801\u548c\u65e0\u635f\u9884\u6d4b\u7f16\u7801\u3002 \u9884\u6d4b\u7f16\u7801\u4e3b\u8981\u6d88\u9664\u4e86\u50cf\u7d20\u95f4\u5197\u4f59\u3002 6\uff09\u6709\u635f\u7f16\u7801--\u6709\u635f\u9884\u6d4b\u7f16\u7801 7\uff09\u6709\u635f\u7f16\u7801--\u53d8\u6362\u7f16\u7801 \u200b \u53d8\u6362\u7f16\u7801\u7684\u4f5c\u7528\u662f\u5c06\u7a7a\u95f4\u57df\u63cf\u8ff0\u7684\u56fe\u50cf\u4fe1\u53f7\u53d8\u6362\u5230\u9891\u7387\u57df\uff0c\u7136\u540e\u5bf9\u53d8\u6362\u540e\u7684\u7cfb\u6570\u8fdb\u884c\u7f16\u7801\u5904\u7406\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u56fe\u50cf\u5728\u7a7a\u95f4\u4e0a\u5177\u6709\u8f83\u5f3a\u7684\u76f8\u5173\u6027\uff0c\u53d8\u6362\u5230\u9891\u7387\u57df\u53ef\u4ee5\u5b9e\u73b0\u53bb\u76f8\u5173\u548c\u80fd\u91cf\u96c6\u4e2d\u3002 \u53d8\u6362\u9009\u62e9 \uff1a \u4e00\u4e2a\u80fd\u628a\u6700\u591a\u7684\u4fe1\u606f\u96c6\u4e2d\u5230\u6700\u5c11\u7684\u7cfb\u6570\u4e0a\u53bb\u7684\u53d8\u6362\u6240\u4ea7\u751f\u7684 \u91cd\u5efa\u5747\u65b9\u8bef\u5dee\u6700\u5c0f \u4e0d\u540c\u53d8\u6362\u7684\u4fe1\u606f\u96c6\u4e2d\u80fd\u529b\u4e0d\u540c \u2013 \u6b63\u5f26\u7c7b\u53d8\u6362\uff08\u5982DFT\u548cDCT\uff09\u8f83\u4f18 \u2013 \u975e\u6b63\u5f26\u7c7b\u53d8\u6362\uff08\u5982WHT: Walsh-Hadamard\uff09 \u5b9e\u73b0\u7b80\u5355 \u2013 \u5c0f\u6ce2\u53d8\u6362\u8ba1\u7b97\u5feb\u4e14\u6709\u5c40\u90e8\u6027\u8d28\uff08\u4e0d\u9700\u5206\u89e3\uff09 DCT\u662f\u8f83\u597d\u7684\uff08\u7efc\u5408\uff09\u9009\u62e9\uff0c\u96c6\u4e2d\u80fd\u529b\u5f3a\uff0c\u5e76\u4e14\u6240\u9700\u8ba1\u7b97\u91cf\u5c0f\u3002","title":"\u7b2c\u4e5d\u7ae0 \u56fe\u50cf\u7f16\u7801"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/","text":"\u53e4\u5178\u5bc6\u7801\u4f53\u5236\u7684\u8ba1\u7b97\uff1a \u00b6 \u5b57\u6bcd\u5bf9\u7167\u8868 \u00b6 \u4eff\u5c04\u53d8\u6362 \u00b6 \u52a0\u5bc6\u53d8\u6362*E* k (*m )= a + b*m mod q \u89e3\u5bc6\u53d8\u6362 *D k ( c )=( c - a )**b* -1 mod q \u5bc6\u94a5\u77ed\u8bed\u5bc6\u7801 \u00b6 \u9009\u62e9\u4e00\u4e2a\u82f1\u6587\u77ed\u8bed\u4f5c\u4e3a\u5bc6\u94a5\u5b57\u6216\u79f0\u5bc6\u94a5\u77ed\u8bed\uff0c\u5982HAPPY NEW YEAR\uff0c\u53bb\u6389\u91cd\u590d\u7684\u5b57\u6bcd\u5f97\u5230HAPYNEWR\u3002\u5c06\u5b83\u4f9d\u6b21\u5199\u5728\u660e\u6587\u5b57\u6bcd\u8868\u7684\u4e0b\u9762\uff0c\u800c\u540e\u518d\u5c06\u5b57\u6bcd\u8868\u4e2d\u672a\u5728\u77ed\u8bed\u4e2d\u51fa\u73b0\u8fc7\u7684\u5b57\u6bcd\u4f9d\u6b21\u5199\u5728\u8fd9\u4e2a\u77ed\u8bed\u540e\u9762\uff0c\u5c31\u53ef\u4ee5\u6784\u9020\u4e00\u4e2a\u4ee3\u6362\u8868\uff0c\u5982\u4e0b\u6240\u793a\uff1a \u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801 \uff08\u591a\u8868\u4ee3\u6362\uff09 \u00b6 \u8bbe\u5bc6\u94a5k=(k[0], k[1],,\u2026,k[d-1])\u5c5e\u4e8eZqd, \u4ee3\u6362\u5e8f\u5217: p=(p[0], p[1],\u2026,p[d-1]), p(x)=x+k[i] mod q. \u660e\u6587\u5e8f\u5217: m=(m[0], m[1],\u2026) \u5bc6\u6587\u5e8f\u5217: c=(m[0]+k[0])(m[1]+k[1])\u2026(m[d-1]+k[d-1]) \u200b (m[d]+k[0])(m[d+1]+k[1])\u2026\u2026 \u8bbe*q*=26, d =6, k =CIPHER=(2,8,15,7,4,17) \u660e\u6587: m =this cryptosystem is not secure \u5bc6\u6587: c =VPXZGI AXIVWP UBTTMJ PWIZIT WZT Hill\u52a0\u5bc6 \uff08\u591a\u5b57\u6bcd\u4ee3\u6362\uff09 \u00b6 \u57fa\u4e8e\u77e9\u9635\u7684\u7ebf\u6027\u53d8\u6362: Z26\u4e3a\u6a2126\u7684\u540c\u4f59\u7c7b\u96c6\u5408, K\u662f\u4e00\u4e2aL*L\u77e9\u9635,\u5728Z26\u4e0a\u53ef\u9006,\u5373\u5b58\u5728K -1 \u4f7f\u5f97: KK -1 = I (\u5728Z26\u4e0a) \u6ce8\uff1a\u660e\u6587\u4e0e\u5bc6\u6587\u90fd\u662fL\u7ef4\u7684\u5411\u91cf m=\uff08m1, m2 \u2026, mL); c=(c1,c2,\u2026,cL); \u52a0\u5bc6\uff1ac=mK mod 26; \u89e3\u5bc6\uff1am=cK -1 mod 26; \u6362\u4f4d\u5bc6\u94a5\uff08\u7efc\u5408\u6848\u4f8b\uff09 \u00b6 \u660e\u6587\uff1a m = the simplest possible transposition ciphers \u5206\u6210\u957f\u5ea6\u4e3a5\u7684\u7ec4\uff1a m = thesi | mples | tposs | iblet | ransp | ositi | oncip | hersx \u52a0\u5bc6\u53d8\u6362\uff1a\u5c06\u5404\u7ec4\u5185\u5b57\u7b26\u6309\u4f4d\u7f6e\u6807\u53f7\uff080~4\uff09\u5b9e\u65bd\u4e0b\u8ff0\u7f6e\u6362\uff08permutation) (Ek\u4e3a\u6b63\u53d8\u6362\uff0cDk\u4e3a\u9006\u53d8\u6362) \u5bc6\u94a5\uff1a c =STIEH EMSLP STSOP EITLB SRPNA TOIIS IOPCN SHXRE \u6d41\u5bc6\u7801 \u00b6 \u6e38\u7a0b\u5206\u5e03\u8ba1\u7b97 \u00b6 \u8bbe*a*= ( a [0], a [1],\u2026, a [i],\u2026)\u662f\u4e00\u4e2a\u5468\u671f\u4e3a*N*\u7684\u4e8c\u5143\u5e8f\u5217\uff0c\u5728\u4e00\u4e2a\u5468\u671f\u5185\u8fde\u7eed\u51fa\u73b0\u7684\u6700\u591a\u7684\u7b26\u53f7\u201c0\u201d\uff08\u62161\uff09\u7684\u4e32\uff0c\u79f0\u4e3a0\uff08\u62161\uff09\u7684\u4e00\u4e2a\u6e38\u7a0b\u3002\u5728\u4e00\u4e2a\u6e38\u7a0b\u4e2d\uff0c0\uff08\u62161\uff09\u7684\u4e2a\u6570\u79f0\u4e3a\u8be5\u6e38\u7a0b\u7684\u957f\u5ea6\u3002 \u5728\u5e8f\u5217 k ={*k*i}=001110100000111100\u2026\u4e2d, \u6709 \u957f\u4e3a1\u76840\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a4\u76840\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a5\u76840\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a1\u76841\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a3\u76841\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a4\u76841\u6e38\u7a0b\u4e00\u4e2a \u6ce8\u610f\u6709\u5468\u671f\uff0c\u5373{*k*i}= 001110100000111100 001110100000111100 \u2026 \u5e8f\u5217\u81ea\u76f8\u5173\u8ba1\u7b97 \u00b6 \u8bbe*a*=( a*0,*a*1,\u2026,*a [N-1])\u548c*b*=( b*0,*b*1,\u2026,*b [N-1])\u662f\u4e24\u4e2a\u5468\u671f\u4e3a*N*\u7684\u4e8c\u5143\u5468\u671f\u5e8f\u5217\uff0c\u5176\u76f8\u5173\u51fd\u6570\u5b9a\u4e49\u4e3a \u5176\u4e2di+t\u662f\u6a21N\u8fd0\u7b97 \u7279\u522b\u5730\uff0c\u5982\u679c*a*= b \uff0c\u5219*R*a*, a ( t)\u88ab\u79f0\u4e3a\u81ea\u76f8\u5173\u51fd\u6570\uff0c\u5176\u4e2d\u5f53t =0\uff0c*R*a , a(0)\u88ab\u79f0\u4e3a\u540c\u76f8\u81ea\u76f8\u5173\u51fd\u6570\uff0c\u800c\u5f53*t*\u4e0d\u7b49\u4e8e0\uff0c R*a , a ( t )\u88ab\u79f0\u4e3a\u5f02\u76f8\u81ea\u76f8\u5173\u51fd\u6570\u3002 \u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\uff08\u8f93\u51fa\u4e3aa1\uff09 \u00b6 \u8bbe\u6709\u9650\u57dfGF(2)\u4e0a\u76843\u7ea7FSR\u7684\u53cd\u9988\u51fd\u6570\u4e3a: f (*x*1, *x*2, *x*3)=*x*1\u5f02\u6216*x*2\u5f02\u6216*x*3 \u521d\u59cb\u72b6\u6001\u4e3a*s*0=(1,0,1). \u6c42FSR\u5e8f\u5217. \u89e3: \u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u5e8f\u5217: a =1011\u2026; \u5468\u671f*q*=4. \u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668 \u00b6 \u5df2\u77e5\u5982\u56fe\u6240\u793a\u76843\u7ea7LFSR. \u7279\u5f81\u591a\u9879\u5f0f\u4e3a\uff1a f ( x )=1+ x 2 + x 3 \u5373\u4e3a a[0]+a[2]+a[3]=0 LFSR\u5e8f\u5217*a*=( a [0], a [1],\u2026, a [n-1],\u2026) \u6ee1\u8db3\u9012\u63a8\u5173\u7cfb\u5f0f: a [n]= a [n-2]+ a [n-3]. \u5982\u679c\u8bbe\u521d\u59cb\u72b6\u6001\u4e3a: (0,0,1) \u5373*a*[0]=0, a [1]=0, a [2]=1,\u8f93\u51fa\u5e8f\u5217\u4e3a: 0010111, \u5468\u671f\u4e3a7. \u5206\u7ec4\u5bc6\u7801 \u00b6 DES\u7b97\u6cd5 \u00b6 DES\u7b97\u6cd5\u6d41\u7a0b \u00b6 \u5206\u7ec4\u5927\u5c0f: 2*w*=64 \u5bc6\u94a5\u5927\u5c0f: | K |=56 \u5b50\u5bc6\u94a5: |K[i]|=48 \u8f6e\u6570: h =16 \u5bf9\u660e\u6587\u4f5c\u7f6e\u6362*IP*\u540e\u5f00\u59cb\u7b2c1\u6b21\u8fed\u4ee3 \u7b2c16\u6b21\u8fed\u4ee3\u540e\uff0c\u4ea4\u6362\u5de6\u3001\u53f332bit\u6570\u636e\uff0c\u518d\u4f5c\u9006\u7f6e\u6362*IP* -1 \uff0c\u5373\u5f97\u5bc6\u6587 IP\u53d8\u6362 \u00b6 \u5c0664\u4f4d\u660e\u6587\u6253\u4e71\u91cd\u65b0\u6392\u5217. \u8bbe*x*= x*1*x*2\u2026*x*64\uff0c\u5219*IP ( x )=*x*58*x*50*x*42\u2026*x*23*x*15*x*7 \u52a0\u5bc6\u7ed3\u679c\uff1a10011000 00000111 00110001 11111101 10010110 01100101 11000010 10001110 \u521d\u59cb\u7f6e\u6362IP\u7684\u9006\u7f6e\u6362 \u5c0664\u4f4d\u5bc6\u6587\u4f4d\u7f6e\u8fd8\u539f. \u8bbe*y*= y*1*y*2\u2026*y*64\uff0c\u5219*IP-1 ( y )=*y*40*y*8*y*48\u2026*y*17*y*57*y*25 \u89e3\u5bc6\u7ed3\u679c\uff1a11011111 00101011 11010000 00100101 10101000 10011100 01000011 01101001 \u8f6e\u51fd\u6570F \u00b6 \u6269\u5c55E\u53d8\u6362\uff08\u5bf9R\u8fdb\u884c\u6269\u5c55\u53d8\u6362\uff09 \u00b6 S\u76d2\u548c\u7f6e\u6362P\u8fd0\u7b97 \uff08S\u76d2\u8f93\u51fa\u7ed3\u679c\u7f6e\u6362\uff09 \u00b6 \u8f93\u5165: b [1] b [2] b [3 ] b [4] b [5] b [6], \u752810\u8fdb\u5236\u8868\u793a: ( i )10= b [1] b [6] (0<=i<=3), ( j )10= b [2] b [3] b [4] b [5] (0<=j<=15) \u5bf9\u4e8e*S*1\uff0c\u8f93\u5165*b*=101011, \u6709*i*=11=3, j =0101=5, \u8f93\u51fa: S*1(*b )= *S*1(3,5)=9=1001. \u5b50\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u00b6 \u7f6e\u6362\u53d8\u6362\uff1aPC-1 \u00b6 64\u4f4d\u5bc6\u94a5*K*\u7684\u7b2c8, 16, 24,\u2026,64\u4f4d\u51718\u4f4d\u662f\u5947\u5076\u6821\u9a8c\u4f4d, \u5176\u4f5956\u4f4d\u4f5c\u4e3a\u5bc6\u94a5\u7528. \u9009\u62e9*K*\u7684\u7b2c57,49,\u2026\u4f4d\u517128\u4f4d\u4f5c\u4e3a\u5bc6\u94a5\u6bb5*C*0;\u9009\u62e9*K*\u7684\u7b2c63,55,\u2026\u4f4d\u517128\u4f4d\u4f5c\u4e3a\u5bc6\u94a5\u6bb5*D*0. \u5faa\u73af\u5de6\u79fbLSi \u00b6 \u5c0628\u4f4d\u7684\u5bc6\u94a5\u6bb5\u4f5c\u4e3a*C*[i], D [i]\u5faa\u73af\u5de6\u79fb1\u62162\u4f4d,\u5de6\u79fb\u4f4d\u6570\u7531\u4e0b\u8868\u786e\u5b9a. \u7f6e\u6362\u9009\u62e9 PC-2 \u00b6 \u4ece56\u4f4d\u5bc6\u94a5\u6bb5*C*[i] ||*D[i]\u4e2d\u9009\u62e948\u4f4d\u4f5c\u4e3a\u5b50\u5bc6\u94a5*K [i]. DES\u89e3\u5bc6\u7b97\u6cd5 \u00b6 \u4e0eDES\u52a0\u5bc6\u7ed3\u6784\u76f8\u540c \u5b50\u5bc6\u94a5\u4f7f\u7528\u6b21\u5e8f\u76f8\u53cd: K [16], K [15], \u2026, K [2], K [1] \u8f93\u5165\uff1a\u5bc6\u6587y; \u8f93\u51fa\uff1a\u660e\u6587*x* IDEA\u4e2d\u4e3b\u8981\u8fd0\u7b97 \u00b6 \u8fd0\u7b97\u2018+\u2019\uff1a\u4e24\u4e2a\u957f\u5ea6\u4e3a16\u7684\u6bd4\u7279\u4e32*x*\u548c*y*\u3002 x \u2018+\u2019*y*\u8868\u793a*x*\u548c*y*\u505a\u9010\u4f4d\u6a212\u52a0\u8fd0\u7b97\uff08\u9010\u6bd4\u7279\u5f02\u6216\uff09\u3002 \u8fd0\u7b97\u201c+\u201d\uff1a\u5c06\u957f\u5ea6\u4e3a16\u7684\u6bd4\u7279\u4e32*x*\u548c*y*\u770b\u4f5c\u662f\u201c\u22650\uff0c\u4e14<2 16 \u201d\u7684\u6574\u6570\u3002 x \u201c+\u201d*y*\u8868\u793a*x*\u548c*y*\u505a\u6a212 16 \u52a0\u8fd0\u7b97\u3002 \u8fd0\u7b97\u00d7\uff1a \u5c06\u957f\u5ea6\u4e3a16\u7684\u6bd4\u7279\u4e32*x*\u548c*y*\u770b\u4f5c\u662f\u201c\u22651\uff0c\u4e14<2 16 +1\u201d\u7684\u6574\u6570\u3002 \u5176\u4e2d\u5c06\u51680\u4e32\u770b\u4f5c\u662f2 16 \u3002 x \u00d7*y*\u8868\u793a*x*\u548c*y*\u505a\u6a212 16 +1\u4e58\u8fd0\u7b97\u3002\uff08\u6ce8\u610f\uff1a 2 16 +1 \u662f\u7d20\u6570\uff09 \u8f6e\u51fd\u6570 \u00b6 \u8f6e\u51fd\u6570\u6570\u636e \u00b6 \u8f6e\u51fd\u6570\u4e3a*M*= F ( m , z ), \u5176\u4e2d*m*\u662f\u660e\u6587\uff0c\u5b83\u662f\u957f\u5ea6\u4e3a64\u7684\u6bd4\u7279\u4e32\uff1b*M*\u662f\u5bc6\u6587\uff0c\u5b83\u662f\u957f\u5ea6\u4e3a64\u7684\u6bd4\u7279\u4e32\uff1b *z*\u662f\u5bc6\u94a5\uff0c\u5b83\u662f\u957f\u5ea6\u4e3a96\u7684\u6bd4\u7279\u4e32\u3002 \u5c06\u660e\u6587*m*\u5206\u4e3a4\u4e2a\u5b50\u5757\uff1a m =( m*1,*m*2,*m*3,*m*4)\uff0c\u5176\u4e2d\u6bcf\u4e2a\u5b50\u5757\u957f\u5ea6\u4e3a16\u3002\u5c06\u5bc6\u6587*M*\u5206\u4e3a4\u4e2a\u5b50\u5757: *M =( M*1,*M*2,*M*3,*M*4), \u5176\u4e2d\u6bcf\u4e2a\u5b50\u5757\u957f\u5ea6\u4e3a16\u3002\u5c06\u5bc6\u94a5*z*\u5206\u4e3a6\u4e2a\u5b50\u5757\uff1a*z =(*z*1,*z*2,*z*3,*z*4,*z*5,*z*6)\uff0c\u5176\u4e2d\u6bcf\u4e2a\u5b50\u5757\u957f\u5ea6\u4e3a16\u3002 \u4e09\u79cd\u8fd0\u7b97\u2018+\u2019\u3001\u201c+\u201d\u3001\u00d7\u5206\u522b\u4e3a\u524d\u9762\u6240\u8ff0\u3002 \u8f6e\u51fd\u6570\u8fd0\u7b97 \u00b6 \u8f6e\u51fd\u6570\u7b97\u6cd5\u63cf\u8ff0\u5982\u4e0b\uff1a \uff081\uff09( m [1], m [2], m [3], m [4])(\u00d7,\u201c+\u201d,\u201c+\u201d,\u00d7) ( z [1], z [2], z [3], z [4])=( a , b , c , d )\u3002 \uff08\u7fa4\u52a0\u5bc6\uff09 \uff082\uff09( a \u2018+\u2019 c , b \u2018+\u2019 d )=( e , f )\u3002\uff08MA\u53d8\u6362\uff09 \uff083\uff09(( e \u00d7 z [5])\u201c+\u201d f )\u00d7 z [6]= u \uff0c u \u201c+\u201d( e \u00d7 z [5])= v \u3002\uff08MA\u53d8\u6362\uff09 \uff084\uff09( a , b , c , d )(\u2018+\u2019,\u2018+\u2019,\u2018+\u2019,\u2018+\u2019) ( u , v , u , v )=( w [1], w [2], w [3], w [4])\u3002\uff08MA\u53d8\u6362\uff09 \uff085\uff09( w [1], w [3], w [2], w*0[4])=(*M [1], M [2], M [3], M [4])\u3002 \uff08\u5757\u7f6e\u6362\uff09 \u52a0\u5bc6\u987a\u5e8f \u00b6 \u5206\u7ec4\u5bc6\u7801IDEA\u7684\u5b8c\u6574\u52a0\u5bc6\u7b97\u6cd5\u662f\u8fde\u7eed8\u6b21\u4f7f\u7528\u8f6e\u51fd\u6570\uff0c\u4e0d\u8fc7\u7b2c8\u8f6e\u4e0e\u524d7\u8f6e\u6709\u6240\u4e0d\u540c\u3002\u524d7\u8f6e\u662f\u666e\u901a\u8f6e\uff0c\u8f6e\u51fd\u6570\u7684\u8fd0\u7b97\u6b65\u9aa4\u5982\u524d\u6240\u8ff0\u4e3a\uff1a \u7fa4\u52a0\u5bc6\u2192MA\u53d8\u6362\u2192\u5757\u7f6e\u6362\u3002 \u7b2c8\u8f6e\u662f\u7279\u6b8a\u8f6e\uff0c\u8f6e\u51fd\u6570\u7684\u8fd0\u7b97\u6b65\u9aa4\u4e3a\uff1a \u7fa4\u52a0\u5bc6\u2192MA\u53d8\u6362\u2192\u7fa4\u52a0\u5bc6\u3002 IDEA\u7b97\u6cd5\u89e3\u5bc6 \u00b6 \u52a0\u89e3\u5bc6\u987a\u5e8f\u4e0d\u540c\uff0c\u53ea\u4e0d\u8fc7\u5bc6\u94a5\u987a\u5e8f\u53d1\u751f\u6539\u53d8\uff1a \u52a0\u5bc6\u5bc6\u94a5(q[1],q[2],q[3],q[4],q[5],q[6])\u5219\u5bf9\u5e94\u7684\u89e3\u5bc6\u5bc6\u94a5\u4e3a( q [1] -1 , - q [3], - q [2], q [4] -1 ,q[5],q[6]) \uff08\u52a0\u4e58\u6cd5\u9006\u8fd0\u7b97\uff09 IDEA \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u00b6 IDEA\u52a0\u5bc6\u7b97\u6cd5\u4e2d\u6240\u4f7f\u7528\u7684\u5bc6\u94a5\u5171\u670952\u4e2a\u5b50\u5757\uff0c\u5373\u52a0\u5bc6\u5bc6\u94a5\u957f\u5ea6\u4e3a16\u00d752=832\uff08\u6bd4\u7279\uff09\u3002\u7528\u6237\u5bc6\u94a5\u5b9e\u9645\u4e0a\u53ea\u6709128 \uff08\u6bd4\u7279\uff09\uff0c\u56e0\u6b64\u9700\u8981\u4e00\u4e2a\u5bc6\u94a5\u6269\u5c55\u7b97\u6cd5\u3002\u5bc6\u94a5\u6269\u5c55\u7b97\u6cd5\u5982\u4e0b\u3002\u5c06128 \u6bd4\u7279\u7684\u7528\u6237\u5bc6\u94a5\u5206\u4e3a8\u4e2a\u5b50\u5757\uff0c\u4f5c\u4e3a\u52a0\u5bc6\u5bc6\u94a5\u7684\u7b2c\u4e00\u4e2a\u201c8\u4e2a\u5b50\u5757\u201d\uff1b\u5c06128 \u6bd4\u7279\u5bc6\u94a5\u5faa\u73af\u5de6\u79fb25\u4f4d\uff0c\u518d\u5206\u4e3a8\u4e2a\u5b50\u5757\uff0c\u4f5c\u4e3a\u52a0\u5bc6\u5bc6\u94a5\u7684\u7b2c\u4e8c\u4e2a\u201c8\u4e2a\u5b50\u5757\u201d\uff1b AES\u7b97\u6cd5 \u00b6 AES\u6d41\u7a0b \u00b6 AES\u7b97\u6cd5\u6a21\u591a\u9879\u5f0f m(x)= x 8 + x 4 + x 3 + x +1. \u5747\u4e3a\u5728GF(2 8 )\u4e0a\u7684\u8fd0\u7b9711 \u521d\u59cb\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0 \u7b2c\u4e00\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e8c\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e09\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u56db\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u7b2cNr-1\u8f6e\uff1a\u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2cNr\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d \u672b\u5c3e\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0 \u5b57\u8282\u4ee3\u6362 \u00b6 \u5bf9\u72b6\u6001\u7684\u6bcf\u4e2a\u5b57\u8282\u72ec\u7acb\u8fdb\u884c\u4ee3\u6362\uff0c\u662f\u5b57\u8282\u7684\u975e\u7ebf\u6027\u53d8\u6362\uff0c\u4e5f\u79f0\u4e3aS\u76d2\u53d8\u6362\u3002\u8bbe ByteSub( a*ij )= b*ij . \u884c\u4f4d\u79fb\u548c\u5217\u6df7\u5408 \u8f6e\u5bc6\u94a5\u52a0 \u89e3\u5bc6\u7b97\u6cd5 \u00b6 \u5b57\u6bcd\u4ee3\u6362 \u00b6 \u5148\u505a\u4eff\u5c04\u7684\u9006\u53d8\u6362\u7136\u540e\u518d\u6c42\u9006 \u884c\u4f4d\u79fb\u548c\u5217\u6df7\u5408 \u00b6 \u884c\u4f4d\u79fb\u9006\u56de\u5373\u53ef \u5217\u6df7\u5408\u5c06\u72b6\u6001\u77e9\u9635\u6bcf\u5217\u76844\u4e2a\u5b57\u8282\u8868\u793a\u6210\u4e00\u4e2a3\u6b21\u591a\u9879\u5f0f\uff0c\u518d\u4e0e\u591a\u9879\u5f0f*d*( x )\u76f8\u4e58. d ( x )=(0B) x 3 +(0D) x 2 +(09) x +(0E). \u89e3\u5bc6\u987a\u5e8f\uff08\u5df2\u5bf9\u5bc6\u94a5\u8fdb\u884c\u53d8\u6362\uff09 \u00b6 \u521d\u59cb\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0 \u7b2c\u4e00\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e8c\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e09\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u56db\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u7b2cNr-1\u8f6e\uff1a\u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2cNr\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d \u672b\u5c3e\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0 \u516c\u94a5\u5bc6\u7801\u4f53\u5236 \u00b6 \u8865\u5145\u6570\u5b66 \u00b6 \u6b27\u62c9\u51fd\u6570 \u00b6 (\u6b27\u62c9\u5b9a\u7406)\u5bf9\u4e8e\u4efb\u4f55\u4e92\u7d20\u7684\u4e24\u4e2a\u6574\u6570a\u548cn\uff0c\u6709 a \u03c6(n) \u2261 1 mod n \u5bf9\u4efb\u610f\u7684\u6b63\u6574\u6570k, \u6709 a k*\u03c6(n) +1\u2261 a mod n \uff0c \u6b27\u62c9\u51fd\u6570*\u03c6(n)*\u7684\u51e0\u6761\u6027\u8d28\uff1a (1) n\u4e3a\u7d20\u6570\uff0c \u03c6(n) = n \uff0d1;(2)\u82e5p\u4e3a\u7d20\u6570\uff0cn\u4e3a\u6b63\u6574\u6570\uff0c\u5219\u03c6(p n )=(p-1)p* n-1 * (3) gcd( m , n ) =1, \u03c6( mn )= \u03c6( m ) \u00d7\u03c6( n ) \u5982\u679c*m*\u662f\u4f7f*a* m \u2261 1 mod *n*\u6210\u7acb\u7684\u6700\u5c0f\u6b63\u6574\u6570\uff0c\u5219\u79f0\u5b83\u662f*a*\u5bf9\u6a21*n*\u7684\u6307\u6570\uff0c\u6216\u8005\u79f0\u4e3a*a*\u5173\u4e8e\u6a21*n*\u7684\u4e58\u6cd5\u9636\uff0c\u8bb0\u4e3aOrd n a\u3002 \u82e5Ord n a= \u03c6 ( n )\uff0c\u5219\u79f0*a*\u662f\u6a21*n*\u7684\u672c\u539f\u6839(primitive root)\uff0c\u4e5f\u79f0\u6a21*n*\u7684\u4e58\u6cd5\u751f\u6210\u5143\u3002 \u6d4b\u8bd5\u65b9\u6cd5:\u4ee4*q*1, q*2,\u2026, *q*n\u662f*p -1\u7684\u7d20\u56e0\u5b50\uff0c\u5bf9\u4e8e\u6240\u6709\u7684*q*1, q*2,\u2026, *q*n, \u8ba1\u7b97*a ( p -1)/q (mod p ) \uff0c\u5982\u679c\u5bf9\u67d0\u4e2a\u7d20\u56e0\u5b50*q*\uff0c\u5176\u7ed3\u679c\u4e3a1\uff0c\u90a3\u4e48*a* \u4e0d\u662f\u4e00\u4e2a\u672c\u539f\u6839\u3002\u5982\u679c\u5bf9\u6240\u6709\u7d20\u56e0\u5b50*q*\uff0c\u5176\u7ed3\u679c\u90fd\u4e0d\u4e3a1 \uff0c\u90a3\u4e48*a* \u662f\u4e00\u4e2a\u672c\u539f\u6839\u3002 \u5bf9\u4e8e\u4e00\u4e2a\u6574\u6570*b*\u548c\u7d20\u6570*n*\u7684\u4e00\u4e2a\u672c\u539f\u6839*a*\uff0c\u53ef\u4ee5\u627e\u5230\u552f\u4e00\u7684\u6307\u6570*x*\uff0c\u4f7f\u5f97*b* \u2261 a x mod n \uff0c\u5176\u4e2d0\u2264 x \u2264 n -1\uff0c\u6307\u6570*x*\u79f0\u4e3a*b*\u7684\u4ee5*a*\u4e3a\u57fa\u6570\u7684\u6a21*n*\u7684\u79bb\u6563\u5bf9\u6570\uff0c\u6c42\u79bb\u6563\u5bf9\u6570\u4e3a\u4e00\u4e2a\u56f0\u96be\u95ee\u9898 \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 \u4e8c\u6b21\u5269\u4f59 RSA\u7b97\u6cd5 \u00b6 \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u00b6 (1) \u9009\u53d6\u4e24\u4e2a\u5927\u7d20\u6570 p , q (2) \u8ba1\u7b97*n*= p*q, \u53d6\u03c6(n)=(p-1)*(q-1) (3) \u968f\u673a\u9009\u53d6*e*: 1< e < \u03c6 ( n )\uff0c\u4e0e*\u03c6*( n )\u4e92\u7d20 (4) \u6839\u636e\u6b27\u51e0\u91cc\u5fb7\u7b97\u6cd5\u8ba1\u7b97*e*\u7684\u9006 d = e -1 : 1< e < \u03c6 ( n )\uff0ce*d = 1 mod \u03c6 ( n ). (5) \u516c\u94a5: PK=( n , e ), \u79c1\u94a5: S*K =( p, *q , d ). \u52a0\u5bc6\u7b97\u6cd5 \u00b6 \u6d88\u606fm: 0<=m<n\uff0c\u5bc6\u6587 c=E PK (m)=m e (mod n) \u89e3\u5bc6\u7b97\u6cd5 \u00b6 \u5bc6\u6587c: 0<=c<n\uff0c\u660e\u6587 m=D SK \u00a9=c d (mod n) Rabin \u516c\u94a5\u5bc6\u7801\u4f53\u5236 \u00b6 \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u00b6 \u9009\u62e9\u4e24\u4e2a\u5927\u7684\u7d20\u6570p\u548cq\uff0c\u8981\u6c42p\u548cq\u90fd\u662f4\u7684\u500d\u6570\u52a03\u3002 \u8ba1\u7b97n=p*q\u3002Bob\u7684\u516c\u94a5\u662fn\uff0c\u5bf9\u5916\u516c\u5e03\u3002 Bob\u7684\u79c1\u94a5\u662f\uff08p\uff0cq\uff09\uff0c\u81ea\u5df1\u79c1\u85cf\u3002 \u52a0\u5bc6\u7b97\u6cd5 \u00b6 \u5c06\u660e\u6587\u901a\u8fc7\u4e00\u4e2a\u53ef\u9006\u6620\u5c04\u4e3a\u4e00\u4e2a\u5c0f\u4e8en\u4e14\u4e0en\u4e92\u7d20\u7684\u6b63\u6574\u6570m,\u5373 0<m<n \u4e14 gcd (m,n)=1\u3002 Alice\u7528Bob\u7684\u516c\u94a5n\uff0c\u8ba1\u7b97\uff1a c=m 2 (mod n)\u3002c\u4e3a\u5bc6\u6587\u3002 \u89e3\u5bc6\u7b97\u6cd5 \u00b6 Bob \u6536\u5230\u5bc6\u6587*c*\u540e\uff0c\u7528\u81ea\u5df1\u7684\u79c1\u94a5\uff08 p \uff0c q \uff09\u8ba1\u7b97 \u80cc\u5305\u516c\u94a5\u5bc6\u7801\u4f53\u5236 \u00b6 \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u00b6 \u53d6n\u4e2a\u5177\u6709\u8d85\u9012\u589e\u6027\u7684\u7269\u54c1\u91cd\u91cf\uff1aa1\uff0ca2\uff0ca3\uff0c\u2026\uff0can\u3002 \u53d6\u6b63\u6574\u6570M\uff0cU\uff0c\u6ee1\u8db3 (1) M>a1+a2+a3+\u2026+an\uff1b(2) M>U\uff1b(3) U*a1>M\uff1b M\u4e0eU\u4e92\u7d20\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u8f97\u8f6c\u76f8\u9664\u6cd5\u8ba1\u7b97\u51faU\u5173\u4e8e(modM)\u7684\u9006\u5143U -1 \u3002 \u8ba1\u7b97\uff1ab1=U*a1(mod M)\uff0cb2=Ua2(mod M) \uff0cb3=Ua3(mod M) \uff0c\u2026\uff0cbn=Uan(mod M) \u3002(\u4e0d\u5177\u6709\u8d85\u9012\u589e\u6027) \u6b64\u65f6 a1=U -1 b1(mod M)\uff0ca2=U -1 b2(mod M)\uff0ca3=U -1 b3(mod M)\uff0c \u2026\uff0can=U -1 bn(mod M) \u3002 {b1\uff0cb2\uff0cb3\uff0c\u2026\uff0cbn}\u662f\u516c\u94a5\u3002 {a1\uff0ca2\uff0ca3\uff0c\u2026\uff0can} \uff0c M\uff0cU\u90fd\u662f\u79c1\u94a5\u3002 \u52a0\u5bc6\u7b97\u6cd5 \u00b6 \u8bbe\u660e\u6587m\u4e3a\u6b63\u6574\u6570\uff0c\u5176\u4e8c\u8fdb\u5236\u5c55\u5f00\u5f0f\u4e3am=(m1,m2,m3\u2026mn) 2 \u3002\u4f7f\u7528\u516c\u94a5{b1\uff0cb2\uff0cb3\uff0c\u2026\uff0cbn}\u8ba1\u7b97\u5bc6\u6587c \uff1ac=m1*b1+m2b2+m3b3+\u2026+mnbn\u3002\u5bc6\u6587c\u662f\u4e00\u4e2a\u6b63\u6574\u6570\u3002 \u89e3\u5bc6\u7b97\u6cd5 \u00b6 \u4f7f\u7528\u79c1\u94a5{a1\uff0ca2\uff0ca3\uff0c\u2026\uff0can} \uff0c M\uff0cU\uff0c\u8ba1\u7b97\u53d8\u6362\u8bfe\u6587C\uff1a C=U -1 c(modM) =U -1 (m1b1+m2b2+m3b3+\u2026+mnbn )(modM) =m1a1+m2a2+m3a3+\u2026+mnan(modM) =m1a1+m2a2+m3a3+\u2026+mnan\u3002 Elgamal \u516c\u94a5\u5bc6\u7801\u4f53\u5236 \u00b6 \u5faa\u73af\u7fa4` \u8bbe(G,*)\u662f\u4e00\u4e2a\u6709\u9650\u7fa4, |G|= n, e\u662fG\u7684\u5355\u4f4d\u5143. \u5982\u679c\u5b58\u5728 a\u5c5e\u4e8eG\uff0c\u4f7f\u5f97a, a2,\u2026, an=e\u4e92\u4e0d\u76f8\u540c,\u5373 G={a, a2,\u2026,an}, \u5219\u79f0a\u662fG\u7684\u4e00\u4e2a\u672c\u539f\u5143\uff08\u751f\u6210\u5143\uff09. (G,*)\u79f0\u4e3a\u5faa\u73af\u7fa4\u3002 \u6709\u9650\u57df \u8bbep\u662f\u4e00\u4e2a\u7d20\u6570, Zp= {0,1,2,\u2026, p-1}. \u5728Zp \u4e2d, \u52a0\u6cd5\u4e0e\u4e58\u6cd5\u6309 mod (p) \u8fdb\u884c, \u5219Zp\u79f0\u4e3a\u4e00\u4e2a\u6709\u9650\u57df\u3002 GF(p)\u7684\u672c\u539f\u5143 \u8bbeZp*= {1,2,\u2026, p-1}, a\u5c5e\u4e8eZp*, \u5982\u679ca, a 2 ,\u2026, a p-1 =1\u4e92\u4e0d\u76f8\u540c,\u5373 Zp*={a, a2,\u2026,ap-1}, \u5219\u79f0a\u662fZp\u7684\u4e00\u4e2a\u672c\u539f\u5143. (Zp*, *)\u662f\u4e00\u4e2a\u5faa\u73af\u7fa4\u3002 \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u00b6 \u5384\u683c\u739b\u5c14(ElGamal)\u5bc6\u7801\u4f53\u5236 \u5bc6\u94a5\u4ea7\u751f: \u9009\u62e9\u7d20\u6570p\uff0c\u6574\u6570g, x\u6ee1\u8db3 0<g, x<p, \u8ba1\u7b97 y=g x mod p. \u516c\u94a5: (p, g, y) \u79c1\u94a5: x \u52a0\u5bc6\u7b97\u6cd5 \u00b6 \u8bbe\u660e\u6587\u4e3am (0<m<p), \u968f\u673a\u9009\u53d6k(0<k<p), \u8ba1\u7b97 c1=g k mod p, c2=y k m mod p. \u5bc6\u6587: c=(c1, c2) \u89e3\u5bc6\u7b97\u6cd5 \u00b6 \u8bbe\u5bc6\u6587\u4e3ac=(c1, c2), \u5219\u660e\u6587\u4e3a m=c2*(c1 x ) -1 mod p. \u692d\u5706\u66f2\u7ebf\u52a0\u89e3\u5bc6\u8fd0\u7b97 \u00b6 \u5bc6\u94a5\u9009\u53d6 \u00b6 \u786e\u5b9a\u516c\u5f00\u53c2\u6570( p , a , b , n , g ) \u9009\u62e9\u4e00\u4e2a\u7d20\u6570*p*, \u786e\u5b9a\u6709\u9650\u57dfGF( p ) \u9009\u62e9*a*, b*\u5c5e\u4e8eGF(*p ), \u786e\u5b9a\u692d\u5706\u66f2\u7ebf*E* \u9009\u62e9*E*\u7684\u4e00\u4e2a\u5faa\u73af\u5b50\u7fa4*H*, \u4f7f\u5f97| H |= n*\u662f\u4e00\u4e2a\u5927\u7d20\u6570 \u9009\u62e9*H*\u7684\u4e00\u4e2a\u672c\u539f\u5143*g . \u786e\u5b9a\u79c1\u94a5: x \u7528\u6237\u968f\u673a\u9009\u53d6*x*\u5c5e\u4e8e{0,1,2,\u2026, n -1} \u786e\u5b9a\u516c\u94a5: y = x*g. \u6709\u9650\u57df\u4e0a\u7684\u692d\u5706\u66f2\u7ebf \u692d\u5706\u66f2\u7ebf\u7fa4\u8ba1\u7b97 \u00b6 \u8bbep>=3\u662f\u7d20\u6570, Fp= {0,1,\u2026, p-1}\u662f\u6709\u9650\u57df, a, b\u5c5e\u4e8ep, \u25b3=4a 3 +27b 2 \u4e0d\u7b49\u4e8e0 mod (p), \u540c\u4f59\u65b9\u7a0b y 2 =x 3 +ax+b \u52a0\u89e3\u5bc6\u7b97\u6cd5 \u00b6 \u52a0\u5bc6\u7b97\u6cd5 \u8bbe\u660e\u6587\u4e3am, \u5c06m\u6620\u5c04\u5230\u5faa\u73af\u7fa4H\u4e0a\u7684\u70b9. \u968f\u673a\u9009\u53d6k\u5c5e\u4e8e{0,1,\u2026,n-1} \u8ba1\u7b97:c1=kg=(x1, y1) \u8ba1\u7b97:c2 =m+ky=(x2, y2) \u5bc6\u6587: c=(c1, c2) \u89e3\u5bc6\u7b97\u6cd5 \u8bbe\u5bc6\u6587\u4e3ac=(c1, c2), \u5219\u660e\u6587\u4e3a m=c2-xc1. \u52a0\u89e3\u5bc6\u4f8b\u5b50 \u00b6 Hash\u51fd\u6570 \u00b6 lHash\u51fd\u6570\u7684\u5206\u7c7b \u5355\u5411Hash\u51fd\u6570\uff08one-way\uff09\u7ed9\u5b9a\u4e00\u4e2aHash\u503c*y*\uff0c\u5982\u679c\u5bfb\u627e\u4e00\u4e2a\u6d88\u606f*x*\uff0c\u4f7f\u5f97*y*= h ( x )\u662f\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u7684\uff0c\u5219\u79f0*h*\u662f\u5355\u5411Hash\u51fd\u6570. \u5f31\u6297\u78b0\u649eHash\u51fd\u6570\uff08weakly collision-free\uff09 \u4efb\u7ed9\u4e00\u4e2a\u6d88\u606f*x*\uff0c\u5982\u679c\u5bfb\u627e\u53e6\u4e00\u4e2a\u4e0d\u540c\u7684\u6d88\u606f*x*\u2019\uff0c\u4f7f\u5f97*h*( x ) = h ( x \u2019)\u662f\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u7684\uff0c\u5219\u79f0*h*\u662f\u5f31\u6297\u78b0\u649eHash\u51fd\u6570. \u5f3a\u6297\u78b0\u649eHash\u51fd\u6570 \uff08strongly collision-free\uff09 \u5982\u679c\u5bfb\u627e\u4e24\u4e2a\u4e0d\u540c\u7684\u6d88\u606f*x*\u548c*x*\u2019\uff0c\u4f7f\u5f97*h*( x )= h ( x \u2019)\u662f\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u7684\uff0c\u5219\u79f0*h*\u662f\u5f3a\u6297\u78b0\u649eHash\u51fd\u6570. \u6570\u5b57\u7b7e\u540d \u00b6 RSA\u7b7e\u540d \u00b6 \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u00b6 \u9009\u53d6\u4e24\u4e2a\u5927\u7d20\u6570p\uff0cq\uff0c\u8ba1\u7b97 n=p*q\uff0c\u53bb\u03c6(n)=( p -1) *( q -1)\u3002 \u4efb\u9009\u6574\u6570e\uff0c\u6ee1\u8db3\uff1a 0< e <\u03c6(n)\uff0c\u4e14gcd(e ,\u03c6(n))=1\u3002 \u7528\u6269\u5c55Euclidean\u7b97\u6cd5\u6c42e\u6a21j(n)\u7684\u9006d\uff0c\u5373 e*d=1 mod \u03c6(n)\u3002 \u7b7e\u540d\u8005\u7684\u516c\u94a5: { n\uff0ce}\uff0c\u79c1\u94a5:{ p\uff0cq\uff0cd}\u3002 \u7b7e\u540d\u7b97\u6cd5 \u8bbe\u6d88\u606f\u4e3ax\uff0c\u5219x\u7684RSA\u7b7e\u540d\u4e3a y=x d mod n \u9a8c\u8bc1\u7b97\u6cd5\u5f53\u63a5\u6536\u65b9\u6536\u5230\u7b7e\u540d(x,y)\u540e\uff0c\u9a8c\u8bc1x=y e mod n Elgamal \u6570\u5b57\u7b7e\u540d \u00b6 \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u9009\u53d6\u4e00\u4e2a\u5927\u7d20\u6570p\uff0cg\u5c5e\u4e8eZp*\u662f\u4e00\u4e2a\u672c\u539f\u5143\uff0cp\u548cg\u662f\u7cfb\u7edf\u516c\u5f00\u53c2\u6570\u3002 \u4efb\u9009\u6574\u6570x\uff0c\u6ee1\u8db3\uff1a1\u2264x\u2264p-2\u3002\u8ba1\u7b97 y=g x mod p. \u7b7e\u540d\u8005\u7684\u516c\u94a5\u4e3ay\uff0c\u79c1\u94a5\u4e3ax\u3002 \u7b7e\u540d\u7b97\u6cd5 \u9a8c\u8bc1\u7b97\u6cd5 \u7f8e\u56fd\u6570\u5b57\u7b7e\u540d\u6807\u51c6 \u00b6 \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5\u7b7e\u540d\u53ca\u9a8c\u8bc1\u7b97\u6cd5 \u4fc4\u7f57\u65af\u6570\u5b57\u7b7e\u540d\u6807\u51c6 \u00b6 \u5bc6\u94a5\u751f\u6210\u51fd\u6570\u7b7e\u540d\u7b97\u6cd5\u53ca\u9a8c\u8bc1\u7b97\u6cd5 FS\u7b7e\u540d \u00b6 \u9009\u53d6\u4e24\u4e2a\u5927\u7d20\u6570*p*\u3001 q \uff0c\u4ee4*n*=p*q\u3002n\u662f\u516c\u5f00\u53c2\u6570\uff0c*p*\u548c*q*\u662f\u7ba1\u7406\u4e2d\u5fc3CA\u638c\u63e1\u7684\u5bc6\u94a5\u3002\u8bbe*h*\u662f\u4e00\u4e2a\u516c\u5f00\u7684Hash\u51fd\u6570\uff0c*k*\u662f\u4e00\u4e2a\u56fa\u5b9a\u7684\u6b63\u6574\u6570\u3002 \u7ba1\u7406\u4e2d\u5fc3CA\u4e3a\u7528\u6237A\u4ea7\u751f*k*\u4e2a\u516c\u5f00\u5bc6\u94a5\uff1a y i (i =1,2,\u2026, k ) \u662f\u6a21*n*\u7684\u5e73\u65b9\u5269\u4f59 \u518d\u4e3a\u7528\u6237A\u4ea7\u751f*k*\u4e2a\u79c1\u94a5\uff08\u4fdd\u5bc6\uff09 \u7b7e\u540d\u7b97\u6cd5 \u9a8c\u8bc1\u7b97\u6cd5","title":"\u73b0\u4ee3\u5bc6\u7801\u5b66"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_1","text":"","title":"\u53e4\u5178\u5bc6\u7801\u4f53\u5236\u7684\u8ba1\u7b97\uff1a"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_2","text":"","title":"\u5b57\u6bcd\u5bf9\u7167\u8868"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_3","text":"\u52a0\u5bc6\u53d8\u6362*E* k (*m )= a + b*m mod q \u89e3\u5bc6\u53d8\u6362 *D k ( c )=( c - a )**b* -1 mod q","title":"\u4eff\u5c04\u53d8\u6362"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_4","text":"\u9009\u62e9\u4e00\u4e2a\u82f1\u6587\u77ed\u8bed\u4f5c\u4e3a\u5bc6\u94a5\u5b57\u6216\u79f0\u5bc6\u94a5\u77ed\u8bed\uff0c\u5982HAPPY NEW YEAR\uff0c\u53bb\u6389\u91cd\u590d\u7684\u5b57\u6bcd\u5f97\u5230HAPYNEWR\u3002\u5c06\u5b83\u4f9d\u6b21\u5199\u5728\u660e\u6587\u5b57\u6bcd\u8868\u7684\u4e0b\u9762\uff0c\u800c\u540e\u518d\u5c06\u5b57\u6bcd\u8868\u4e2d\u672a\u5728\u77ed\u8bed\u4e2d\u51fa\u73b0\u8fc7\u7684\u5b57\u6bcd\u4f9d\u6b21\u5199\u5728\u8fd9\u4e2a\u77ed\u8bed\u540e\u9762\uff0c\u5c31\u53ef\u4ee5\u6784\u9020\u4e00\u4e2a\u4ee3\u6362\u8868\uff0c\u5982\u4e0b\u6240\u793a\uff1a","title":"\u5bc6\u94a5\u77ed\u8bed\u5bc6\u7801"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_5","text":"\u8bbe\u5bc6\u94a5k=(k[0], k[1],,\u2026,k[d-1])\u5c5e\u4e8eZqd, \u4ee3\u6362\u5e8f\u5217: p=(p[0], p[1],\u2026,p[d-1]), p(x)=x+k[i] mod q. \u660e\u6587\u5e8f\u5217: m=(m[0], m[1],\u2026) \u5bc6\u6587\u5e8f\u5217: c=(m[0]+k[0])(m[1]+k[1])\u2026(m[d-1]+k[d-1]) \u200b (m[d]+k[0])(m[d+1]+k[1])\u2026\u2026 \u8bbe*q*=26, d =6, k =CIPHER=(2,8,15,7,4,17) \u660e\u6587: m =this cryptosystem is not secure \u5bc6\u6587: c =VPXZGI AXIVWP UBTTMJ PWIZIT WZT","title":"\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801 \uff08\u591a\u8868\u4ee3\u6362\uff09"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#hill","text":"\u57fa\u4e8e\u77e9\u9635\u7684\u7ebf\u6027\u53d8\u6362: Z26\u4e3a\u6a2126\u7684\u540c\u4f59\u7c7b\u96c6\u5408, K\u662f\u4e00\u4e2aL*L\u77e9\u9635,\u5728Z26\u4e0a\u53ef\u9006,\u5373\u5b58\u5728K -1 \u4f7f\u5f97: KK -1 = I (\u5728Z26\u4e0a) \u6ce8\uff1a\u660e\u6587\u4e0e\u5bc6\u6587\u90fd\u662fL\u7ef4\u7684\u5411\u91cf m=\uff08m1, m2 \u2026, mL); c=(c1,c2,\u2026,cL); \u52a0\u5bc6\uff1ac=mK mod 26; \u89e3\u5bc6\uff1am=cK -1 mod 26;","title":"Hill\u52a0\u5bc6 \uff08\u591a\u5b57\u6bcd\u4ee3\u6362\uff09"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_6","text":"\u660e\u6587\uff1a m = the simplest possible transposition ciphers \u5206\u6210\u957f\u5ea6\u4e3a5\u7684\u7ec4\uff1a m = thesi | mples | tposs | iblet | ransp | ositi | oncip | hersx \u52a0\u5bc6\u53d8\u6362\uff1a\u5c06\u5404\u7ec4\u5185\u5b57\u7b26\u6309\u4f4d\u7f6e\u6807\u53f7\uff080~4\uff09\u5b9e\u65bd\u4e0b\u8ff0\u7f6e\u6362\uff08permutation) (Ek\u4e3a\u6b63\u53d8\u6362\uff0cDk\u4e3a\u9006\u53d8\u6362) \u5bc6\u94a5\uff1a c =STIEH EMSLP STSOP EITLB SRPNA TOIIS IOPCN SHXRE","title":"\u6362\u4f4d\u5bc6\u94a5\uff08\u7efc\u5408\u6848\u4f8b\uff09"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_7","text":"","title":"\u6d41\u5bc6\u7801"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_8","text":"\u8bbe*a*= ( a [0], a [1],\u2026, a [i],\u2026)\u662f\u4e00\u4e2a\u5468\u671f\u4e3a*N*\u7684\u4e8c\u5143\u5e8f\u5217\uff0c\u5728\u4e00\u4e2a\u5468\u671f\u5185\u8fde\u7eed\u51fa\u73b0\u7684\u6700\u591a\u7684\u7b26\u53f7\u201c0\u201d\uff08\u62161\uff09\u7684\u4e32\uff0c\u79f0\u4e3a0\uff08\u62161\uff09\u7684\u4e00\u4e2a\u6e38\u7a0b\u3002\u5728\u4e00\u4e2a\u6e38\u7a0b\u4e2d\uff0c0\uff08\u62161\uff09\u7684\u4e2a\u6570\u79f0\u4e3a\u8be5\u6e38\u7a0b\u7684\u957f\u5ea6\u3002 \u5728\u5e8f\u5217 k ={*k*i}=001110100000111100\u2026\u4e2d, \u6709 \u957f\u4e3a1\u76840\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a4\u76840\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a5\u76840\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a1\u76841\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a3\u76841\u6e38\u7a0b\u4e00\u4e2a; \u957f\u4e3a4\u76841\u6e38\u7a0b\u4e00\u4e2a \u6ce8\u610f\u6709\u5468\u671f\uff0c\u5373{*k*i}= 001110100000111100 001110100000111100 \u2026","title":"\u6e38\u7a0b\u5206\u5e03\u8ba1\u7b97"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_9","text":"\u8bbe*a*=( a*0,*a*1,\u2026,*a [N-1])\u548c*b*=( b*0,*b*1,\u2026,*b [N-1])\u662f\u4e24\u4e2a\u5468\u671f\u4e3a*N*\u7684\u4e8c\u5143\u5468\u671f\u5e8f\u5217\uff0c\u5176\u76f8\u5173\u51fd\u6570\u5b9a\u4e49\u4e3a \u5176\u4e2di+t\u662f\u6a21N\u8fd0\u7b97 \u7279\u522b\u5730\uff0c\u5982\u679c*a*= b \uff0c\u5219*R*a*, a ( t)\u88ab\u79f0\u4e3a\u81ea\u76f8\u5173\u51fd\u6570\uff0c\u5176\u4e2d\u5f53t =0\uff0c*R*a , a(0)\u88ab\u79f0\u4e3a\u540c\u76f8\u81ea\u76f8\u5173\u51fd\u6570\uff0c\u800c\u5f53*t*\u4e0d\u7b49\u4e8e0\uff0c R*a , a ( t )\u88ab\u79f0\u4e3a\u5f02\u76f8\u81ea\u76f8\u5173\u51fd\u6570\u3002","title":"\u5e8f\u5217\u81ea\u76f8\u5173\u8ba1\u7b97"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#a1","text":"\u8bbe\u6709\u9650\u57dfGF(2)\u4e0a\u76843\u7ea7FSR\u7684\u53cd\u9988\u51fd\u6570\u4e3a: f (*x*1, *x*2, *x*3)=*x*1\u5f02\u6216*x*2\u5f02\u6216*x*3 \u521d\u59cb\u72b6\u6001\u4e3a*s*0=(1,0,1). \u6c42FSR\u5e8f\u5217. \u89e3: \u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u5e8f\u5217: a =1011\u2026; \u5468\u671f*q*=4.","title":"\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\uff08\u8f93\u51fa\u4e3aa1\uff09"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_10","text":"\u5df2\u77e5\u5982\u56fe\u6240\u793a\u76843\u7ea7LFSR. \u7279\u5f81\u591a\u9879\u5f0f\u4e3a\uff1a f ( x )=1+ x 2 + x 3 \u5373\u4e3a a[0]+a[2]+a[3]=0 LFSR\u5e8f\u5217*a*=( a [0], a [1],\u2026, a [n-1],\u2026) \u6ee1\u8db3\u9012\u63a8\u5173\u7cfb\u5f0f: a [n]= a [n-2]+ a [n-3]. \u5982\u679c\u8bbe\u521d\u59cb\u72b6\u6001\u4e3a: (0,0,1) \u5373*a*[0]=0, a [1]=0, a [2]=1,\u8f93\u51fa\u5e8f\u5217\u4e3a: 0010111, \u5468\u671f\u4e3a7.","title":"\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_11","text":"","title":"\u5206\u7ec4\u5bc6\u7801"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#des","text":"","title":"DES\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#des_1","text":"\u5206\u7ec4\u5927\u5c0f: 2*w*=64 \u5bc6\u94a5\u5927\u5c0f: | K |=56 \u5b50\u5bc6\u94a5: |K[i]|=48 \u8f6e\u6570: h =16 \u5bf9\u660e\u6587\u4f5c\u7f6e\u6362*IP*\u540e\u5f00\u59cb\u7b2c1\u6b21\u8fed\u4ee3 \u7b2c16\u6b21\u8fed\u4ee3\u540e\uff0c\u4ea4\u6362\u5de6\u3001\u53f332bit\u6570\u636e\uff0c\u518d\u4f5c\u9006\u7f6e\u6362*IP* -1 \uff0c\u5373\u5f97\u5bc6\u6587","title":"DES\u7b97\u6cd5\u6d41\u7a0b"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#ip","text":"\u5c0664\u4f4d\u660e\u6587\u6253\u4e71\u91cd\u65b0\u6392\u5217. \u8bbe*x*= x*1*x*2\u2026*x*64\uff0c\u5219*IP ( x )=*x*58*x*50*x*42\u2026*x*23*x*15*x*7 \u52a0\u5bc6\u7ed3\u679c\uff1a10011000 00000111 00110001 11111101 10010110 01100101 11000010 10001110 \u521d\u59cb\u7f6e\u6362IP\u7684\u9006\u7f6e\u6362 \u5c0664\u4f4d\u5bc6\u6587\u4f4d\u7f6e\u8fd8\u539f. \u8bbe*y*= y*1*y*2\u2026*y*64\uff0c\u5219*IP-1 ( y )=*y*40*y*8*y*48\u2026*y*17*y*57*y*25 \u89e3\u5bc6\u7ed3\u679c\uff1a11011111 00101011 11010000 00100101 10101000 10011100 01000011 01101001","title":"IP\u53d8\u6362"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#f","text":"","title":"\u8f6e\u51fd\u6570F"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#er","text":"","title":"\u6269\u5c55E\u53d8\u6362\uff08\u5bf9R\u8fdb\u884c\u6269\u5c55\u53d8\u6362\uff09"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#sp-s","text":"\u8f93\u5165: b [1] b [2] b [3 ] b [4] b [5] b [6], \u752810\u8fdb\u5236\u8868\u793a: ( i )10= b [1] b [6] (0<=i<=3), ( j )10= b [2] b [3] b [4] b [5] (0<=j<=15) \u5bf9\u4e8e*S*1\uff0c\u8f93\u5165*b*=101011, \u6709*i*=11=3, j =0101=5, \u8f93\u51fa: S*1(*b )= *S*1(3,5)=9=1001.","title":"S\u76d2\u548c\u7f6e\u6362P\u8fd0\u7b97 \uff08S\u76d2\u8f93\u51fa\u7ed3\u679c\u7f6e\u6362\uff09"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_12","text":"","title":"\u5b50\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#pc-1","text":"64\u4f4d\u5bc6\u94a5*K*\u7684\u7b2c8, 16, 24,\u2026,64\u4f4d\u51718\u4f4d\u662f\u5947\u5076\u6821\u9a8c\u4f4d, \u5176\u4f5956\u4f4d\u4f5c\u4e3a\u5bc6\u94a5\u7528. \u9009\u62e9*K*\u7684\u7b2c57,49,\u2026\u4f4d\u517128\u4f4d\u4f5c\u4e3a\u5bc6\u94a5\u6bb5*C*0;\u9009\u62e9*K*\u7684\u7b2c63,55,\u2026\u4f4d\u517128\u4f4d\u4f5c\u4e3a\u5bc6\u94a5\u6bb5*D*0.","title":"\u7f6e\u6362\u53d8\u6362\uff1aPC-1"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#lsi","text":"\u5c0628\u4f4d\u7684\u5bc6\u94a5\u6bb5\u4f5c\u4e3a*C*[i], D [i]\u5faa\u73af\u5de6\u79fb1\u62162\u4f4d,\u5de6\u79fb\u4f4d\u6570\u7531\u4e0b\u8868\u786e\u5b9a.","title":"\u5faa\u73af\u5de6\u79fbLSi"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#pc-2","text":"\u4ece56\u4f4d\u5bc6\u94a5\u6bb5*C*[i] ||*D[i]\u4e2d\u9009\u62e948\u4f4d\u4f5c\u4e3a\u5b50\u5bc6\u94a5*K [i].","title":"\u7f6e\u6362\u9009\u62e9 PC-2"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#des_2","text":"\u4e0eDES\u52a0\u5bc6\u7ed3\u6784\u76f8\u540c \u5b50\u5bc6\u94a5\u4f7f\u7528\u6b21\u5e8f\u76f8\u53cd: K [16], K [15], \u2026, K [2], K [1] \u8f93\u5165\uff1a\u5bc6\u6587y; \u8f93\u51fa\uff1a\u660e\u6587*x*","title":"DES\u89e3\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#idea","text":"\u8fd0\u7b97\u2018+\u2019\uff1a\u4e24\u4e2a\u957f\u5ea6\u4e3a16\u7684\u6bd4\u7279\u4e32*x*\u548c*y*\u3002 x \u2018+\u2019*y*\u8868\u793a*x*\u548c*y*\u505a\u9010\u4f4d\u6a212\u52a0\u8fd0\u7b97\uff08\u9010\u6bd4\u7279\u5f02\u6216\uff09\u3002 \u8fd0\u7b97\u201c+\u201d\uff1a\u5c06\u957f\u5ea6\u4e3a16\u7684\u6bd4\u7279\u4e32*x*\u548c*y*\u770b\u4f5c\u662f\u201c\u22650\uff0c\u4e14<2 16 \u201d\u7684\u6574\u6570\u3002 x \u201c+\u201d*y*\u8868\u793a*x*\u548c*y*\u505a\u6a212 16 \u52a0\u8fd0\u7b97\u3002 \u8fd0\u7b97\u00d7\uff1a \u5c06\u957f\u5ea6\u4e3a16\u7684\u6bd4\u7279\u4e32*x*\u548c*y*\u770b\u4f5c\u662f\u201c\u22651\uff0c\u4e14<2 16 +1\u201d\u7684\u6574\u6570\u3002 \u5176\u4e2d\u5c06\u51680\u4e32\u770b\u4f5c\u662f2 16 \u3002 x \u00d7*y*\u8868\u793a*x*\u548c*y*\u505a\u6a212 16 +1\u4e58\u8fd0\u7b97\u3002\uff08\u6ce8\u610f\uff1a 2 16 +1 \u662f\u7d20\u6570\uff09","title":"IDEA\u4e2d\u4e3b\u8981\u8fd0\u7b97"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_13","text":"","title":"\u8f6e\u51fd\u6570"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_14","text":"\u8f6e\u51fd\u6570\u4e3a*M*= F ( m , z ), \u5176\u4e2d*m*\u662f\u660e\u6587\uff0c\u5b83\u662f\u957f\u5ea6\u4e3a64\u7684\u6bd4\u7279\u4e32\uff1b*M*\u662f\u5bc6\u6587\uff0c\u5b83\u662f\u957f\u5ea6\u4e3a64\u7684\u6bd4\u7279\u4e32\uff1b *z*\u662f\u5bc6\u94a5\uff0c\u5b83\u662f\u957f\u5ea6\u4e3a96\u7684\u6bd4\u7279\u4e32\u3002 \u5c06\u660e\u6587*m*\u5206\u4e3a4\u4e2a\u5b50\u5757\uff1a m =( m*1,*m*2,*m*3,*m*4)\uff0c\u5176\u4e2d\u6bcf\u4e2a\u5b50\u5757\u957f\u5ea6\u4e3a16\u3002\u5c06\u5bc6\u6587*M*\u5206\u4e3a4\u4e2a\u5b50\u5757: *M =( M*1,*M*2,*M*3,*M*4), \u5176\u4e2d\u6bcf\u4e2a\u5b50\u5757\u957f\u5ea6\u4e3a16\u3002\u5c06\u5bc6\u94a5*z*\u5206\u4e3a6\u4e2a\u5b50\u5757\uff1a*z =(*z*1,*z*2,*z*3,*z*4,*z*5,*z*6)\uff0c\u5176\u4e2d\u6bcf\u4e2a\u5b50\u5757\u957f\u5ea6\u4e3a16\u3002 \u4e09\u79cd\u8fd0\u7b97\u2018+\u2019\u3001\u201c+\u201d\u3001\u00d7\u5206\u522b\u4e3a\u524d\u9762\u6240\u8ff0\u3002","title":"\u8f6e\u51fd\u6570\u6570\u636e"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_15","text":"\u8f6e\u51fd\u6570\u7b97\u6cd5\u63cf\u8ff0\u5982\u4e0b\uff1a \uff081\uff09( m [1], m [2], m [3], m [4])(\u00d7,\u201c+\u201d,\u201c+\u201d,\u00d7) ( z [1], z [2], z [3], z [4])=( a , b , c , d )\u3002 \uff08\u7fa4\u52a0\u5bc6\uff09 \uff082\uff09( a \u2018+\u2019 c , b \u2018+\u2019 d )=( e , f )\u3002\uff08MA\u53d8\u6362\uff09 \uff083\uff09(( e \u00d7 z [5])\u201c+\u201d f )\u00d7 z [6]= u \uff0c u \u201c+\u201d( e \u00d7 z [5])= v \u3002\uff08MA\u53d8\u6362\uff09 \uff084\uff09( a , b , c , d )(\u2018+\u2019,\u2018+\u2019,\u2018+\u2019,\u2018+\u2019) ( u , v , u , v )=( w [1], w [2], w [3], w [4])\u3002\uff08MA\u53d8\u6362\uff09 \uff085\uff09( w [1], w [3], w [2], w*0[4])=(*M [1], M [2], M [3], M [4])\u3002 \uff08\u5757\u7f6e\u6362\uff09","title":"\u8f6e\u51fd\u6570\u8fd0\u7b97"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_16","text":"\u5206\u7ec4\u5bc6\u7801IDEA\u7684\u5b8c\u6574\u52a0\u5bc6\u7b97\u6cd5\u662f\u8fde\u7eed8\u6b21\u4f7f\u7528\u8f6e\u51fd\u6570\uff0c\u4e0d\u8fc7\u7b2c8\u8f6e\u4e0e\u524d7\u8f6e\u6709\u6240\u4e0d\u540c\u3002\u524d7\u8f6e\u662f\u666e\u901a\u8f6e\uff0c\u8f6e\u51fd\u6570\u7684\u8fd0\u7b97\u6b65\u9aa4\u5982\u524d\u6240\u8ff0\u4e3a\uff1a \u7fa4\u52a0\u5bc6\u2192MA\u53d8\u6362\u2192\u5757\u7f6e\u6362\u3002 \u7b2c8\u8f6e\u662f\u7279\u6b8a\u8f6e\uff0c\u8f6e\u51fd\u6570\u7684\u8fd0\u7b97\u6b65\u9aa4\u4e3a\uff1a \u7fa4\u52a0\u5bc6\u2192MA\u53d8\u6362\u2192\u7fa4\u52a0\u5bc6\u3002","title":"\u52a0\u5bc6\u987a\u5e8f"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#idea_1","text":"\u52a0\u89e3\u5bc6\u987a\u5e8f\u4e0d\u540c\uff0c\u53ea\u4e0d\u8fc7\u5bc6\u94a5\u987a\u5e8f\u53d1\u751f\u6539\u53d8\uff1a \u52a0\u5bc6\u5bc6\u94a5(q[1],q[2],q[3],q[4],q[5],q[6])\u5219\u5bf9\u5e94\u7684\u89e3\u5bc6\u5bc6\u94a5\u4e3a( q [1] -1 , - q [3], - q [2], q [4] -1 ,q[5],q[6]) \uff08\u52a0\u4e58\u6cd5\u9006\u8fd0\u7b97\uff09","title":"IDEA\u7b97\u6cd5\u89e3\u5bc6"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#idea_2","text":"IDEA\u52a0\u5bc6\u7b97\u6cd5\u4e2d\u6240\u4f7f\u7528\u7684\u5bc6\u94a5\u5171\u670952\u4e2a\u5b50\u5757\uff0c\u5373\u52a0\u5bc6\u5bc6\u94a5\u957f\u5ea6\u4e3a16\u00d752=832\uff08\u6bd4\u7279\uff09\u3002\u7528\u6237\u5bc6\u94a5\u5b9e\u9645\u4e0a\u53ea\u6709128 \uff08\u6bd4\u7279\uff09\uff0c\u56e0\u6b64\u9700\u8981\u4e00\u4e2a\u5bc6\u94a5\u6269\u5c55\u7b97\u6cd5\u3002\u5bc6\u94a5\u6269\u5c55\u7b97\u6cd5\u5982\u4e0b\u3002\u5c06128 \u6bd4\u7279\u7684\u7528\u6237\u5bc6\u94a5\u5206\u4e3a8\u4e2a\u5b50\u5757\uff0c\u4f5c\u4e3a\u52a0\u5bc6\u5bc6\u94a5\u7684\u7b2c\u4e00\u4e2a\u201c8\u4e2a\u5b50\u5757\u201d\uff1b\u5c06128 \u6bd4\u7279\u5bc6\u94a5\u5faa\u73af\u5de6\u79fb25\u4f4d\uff0c\u518d\u5206\u4e3a8\u4e2a\u5b50\u5757\uff0c\u4f5c\u4e3a\u52a0\u5bc6\u5bc6\u94a5\u7684\u7b2c\u4e8c\u4e2a\u201c8\u4e2a\u5b50\u5757\u201d\uff1b","title":"IDEA \u5bc6\u94a5\u751f\u6210\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#aes","text":"","title":"AES\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#aes_1","text":"AES\u7b97\u6cd5\u6a21\u591a\u9879\u5f0f m(x)= x 8 + x 4 + x 3 + x +1. \u5747\u4e3a\u5728GF(2 8 )\u4e0a\u7684\u8fd0\u7b9711 \u521d\u59cb\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0 \u7b2c\u4e00\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e8c\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e09\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u56db\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u7b2cNr-1\u8f6e\uff1a\u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2cNr\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d \u672b\u5c3e\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0","title":"AES\u6d41\u7a0b"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_17","text":"\u5bf9\u72b6\u6001\u7684\u6bcf\u4e2a\u5b57\u8282\u72ec\u7acb\u8fdb\u884c\u4ee3\u6362\uff0c\u662f\u5b57\u8282\u7684\u975e\u7ebf\u6027\u53d8\u6362\uff0c\u4e5f\u79f0\u4e3aS\u76d2\u53d8\u6362\u3002\u8bbe ByteSub( a*ij )= b*ij . \u884c\u4f4d\u79fb\u548c\u5217\u6df7\u5408 \u8f6e\u5bc6\u94a5\u52a0","title":"\u5b57\u8282\u4ee3\u6362"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_18","text":"","title":"\u89e3\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_19","text":"\u5148\u505a\u4eff\u5c04\u7684\u9006\u53d8\u6362\u7136\u540e\u518d\u6c42\u9006","title":"\u5b57\u6bcd\u4ee3\u6362"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_20","text":"\u884c\u4f4d\u79fb\u9006\u56de\u5373\u53ef \u5217\u6df7\u5408\u5c06\u72b6\u6001\u77e9\u9635\u6bcf\u5217\u76844\u4e2a\u5b57\u8282\u8868\u793a\u6210\u4e00\u4e2a3\u6b21\u591a\u9879\u5f0f\uff0c\u518d\u4e0e\u591a\u9879\u5f0f*d*( x )\u76f8\u4e58. d ( x )=(0B) x 3 +(0D) x 2 +(09) x +(0E).","title":"\u884c\u4f4d\u79fb\u548c\u5217\u6df7\u5408"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_21","text":"\u521d\u59cb\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0 \u7b2c\u4e00\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e8c\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u4e09\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2c\u56db\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u7b2cNr-1\u8f6e\uff1a\u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d\u2192\u5217\u6df7\u5408\u2192\u5bc6\u94a5\u52a0 \u7b2cNr\u8f6e\uff1a \u5b57\u8282\u66ff\u6362\u2192\u884c\u79fb\u4f4d \u672b\u5c3e\u53d8\u6362\u2014\u2014\u5bc6\u94a5\u52a0","title":"\u89e3\u5bc6\u987a\u5e8f\uff08\u5df2\u5bf9\u5bc6\u94a5\u8fdb\u884c\u53d8\u6362\uff09"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_22","text":"","title":"\u516c\u94a5\u5bc6\u7801\u4f53\u5236"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_23","text":"","title":"\u8865\u5145\u6570\u5b66"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_24","text":"(\u6b27\u62c9\u5b9a\u7406)\u5bf9\u4e8e\u4efb\u4f55\u4e92\u7d20\u7684\u4e24\u4e2a\u6574\u6570a\u548cn\uff0c\u6709 a \u03c6(n) \u2261 1 mod n \u5bf9\u4efb\u610f\u7684\u6b63\u6574\u6570k, \u6709 a k*\u03c6(n) +1\u2261 a mod n \uff0c \u6b27\u62c9\u51fd\u6570*\u03c6(n)*\u7684\u51e0\u6761\u6027\u8d28\uff1a (1) n\u4e3a\u7d20\u6570\uff0c \u03c6(n) = n \uff0d1;(2)\u82e5p\u4e3a\u7d20\u6570\uff0cn\u4e3a\u6b63\u6574\u6570\uff0c\u5219\u03c6(p n )=(p-1)p* n-1 * (3) gcd( m , n ) =1, \u03c6( mn )= \u03c6( m ) \u00d7\u03c6( n ) \u5982\u679c*m*\u662f\u4f7f*a* m \u2261 1 mod *n*\u6210\u7acb\u7684\u6700\u5c0f\u6b63\u6574\u6570\uff0c\u5219\u79f0\u5b83\u662f*a*\u5bf9\u6a21*n*\u7684\u6307\u6570\uff0c\u6216\u8005\u79f0\u4e3a*a*\u5173\u4e8e\u6a21*n*\u7684\u4e58\u6cd5\u9636\uff0c\u8bb0\u4e3aOrd n a\u3002 \u82e5Ord n a= \u03c6 ( n )\uff0c\u5219\u79f0*a*\u662f\u6a21*n*\u7684\u672c\u539f\u6839(primitive root)\uff0c\u4e5f\u79f0\u6a21*n*\u7684\u4e58\u6cd5\u751f\u6210\u5143\u3002 \u6d4b\u8bd5\u65b9\u6cd5:\u4ee4*q*1, q*2,\u2026, *q*n\u662f*p -1\u7684\u7d20\u56e0\u5b50\uff0c\u5bf9\u4e8e\u6240\u6709\u7684*q*1, q*2,\u2026, *q*n, \u8ba1\u7b97*a ( p -1)/q (mod p ) \uff0c\u5982\u679c\u5bf9\u67d0\u4e2a\u7d20\u56e0\u5b50*q*\uff0c\u5176\u7ed3\u679c\u4e3a1\uff0c\u90a3\u4e48*a* \u4e0d\u662f\u4e00\u4e2a\u672c\u539f\u6839\u3002\u5982\u679c\u5bf9\u6240\u6709\u7d20\u56e0\u5b50*q*\uff0c\u5176\u7ed3\u679c\u90fd\u4e0d\u4e3a1 \uff0c\u90a3\u4e48*a* \u662f\u4e00\u4e2a\u672c\u539f\u6839\u3002 \u5bf9\u4e8e\u4e00\u4e2a\u6574\u6570*b*\u548c\u7d20\u6570*n*\u7684\u4e00\u4e2a\u672c\u539f\u6839*a*\uff0c\u53ef\u4ee5\u627e\u5230\u552f\u4e00\u7684\u6307\u6570*x*\uff0c\u4f7f\u5f97*b* \u2261 a x mod n \uff0c\u5176\u4e2d0\u2264 x \u2264 n -1\uff0c\u6307\u6570*x*\u79f0\u4e3a*b*\u7684\u4ee5*a*\u4e3a\u57fa\u6570\u7684\u6a21*n*\u7684\u79bb\u6563\u5bf9\u6570\uff0c\u6c42\u79bb\u6563\u5bf9\u6570\u4e3a\u4e00\u4e2a\u56f0\u96be\u95ee\u9898 \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 \u4e8c\u6b21\u5269\u4f59","title":"\u6b27\u62c9\u51fd\u6570"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#rsa","text":"","title":"RSA\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_25","text":"(1) \u9009\u53d6\u4e24\u4e2a\u5927\u7d20\u6570 p , q (2) \u8ba1\u7b97*n*= p*q, \u53d6\u03c6(n)=(p-1)*(q-1) (3) \u968f\u673a\u9009\u53d6*e*: 1< e < \u03c6 ( n )\uff0c\u4e0e*\u03c6*( n )\u4e92\u7d20 (4) \u6839\u636e\u6b27\u51e0\u91cc\u5fb7\u7b97\u6cd5\u8ba1\u7b97*e*\u7684\u9006 d = e -1 : 1< e < \u03c6 ( n )\uff0ce*d = 1 mod \u03c6 ( n ). (5) \u516c\u94a5: PK=( n , e ), \u79c1\u94a5: S*K =( p, *q , d ).","title":"\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_26","text":"\u6d88\u606fm: 0<=m<n\uff0c\u5bc6\u6587 c=E PK (m)=m e (mod n)","title":"\u52a0\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_27","text":"\u5bc6\u6587c: 0<=c<n\uff0c\u660e\u6587 m=D SK \u00a9=c d (mod n)","title":"\u89e3\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#rabin","text":"","title":"Rabin \u516c\u94a5\u5bc6\u7801\u4f53\u5236"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_28","text":"\u9009\u62e9\u4e24\u4e2a\u5927\u7684\u7d20\u6570p\u548cq\uff0c\u8981\u6c42p\u548cq\u90fd\u662f4\u7684\u500d\u6570\u52a03\u3002 \u8ba1\u7b97n=p*q\u3002Bob\u7684\u516c\u94a5\u662fn\uff0c\u5bf9\u5916\u516c\u5e03\u3002 Bob\u7684\u79c1\u94a5\u662f\uff08p\uff0cq\uff09\uff0c\u81ea\u5df1\u79c1\u85cf\u3002","title":"\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_29","text":"\u5c06\u660e\u6587\u901a\u8fc7\u4e00\u4e2a\u53ef\u9006\u6620\u5c04\u4e3a\u4e00\u4e2a\u5c0f\u4e8en\u4e14\u4e0en\u4e92\u7d20\u7684\u6b63\u6574\u6570m,\u5373 0<m<n \u4e14 gcd (m,n)=1\u3002 Alice\u7528Bob\u7684\u516c\u94a5n\uff0c\u8ba1\u7b97\uff1a c=m 2 (mod n)\u3002c\u4e3a\u5bc6\u6587\u3002","title":"\u52a0\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_30","text":"Bob \u6536\u5230\u5bc6\u6587*c*\u540e\uff0c\u7528\u81ea\u5df1\u7684\u79c1\u94a5\uff08 p \uff0c q \uff09\u8ba1\u7b97","title":"\u89e3\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_31","text":"","title":"\u80cc\u5305\u516c\u94a5\u5bc6\u7801\u4f53\u5236"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_32","text":"\u53d6n\u4e2a\u5177\u6709\u8d85\u9012\u589e\u6027\u7684\u7269\u54c1\u91cd\u91cf\uff1aa1\uff0ca2\uff0ca3\uff0c\u2026\uff0can\u3002 \u53d6\u6b63\u6574\u6570M\uff0cU\uff0c\u6ee1\u8db3 (1) M>a1+a2+a3+\u2026+an\uff1b(2) M>U\uff1b(3) U*a1>M\uff1b M\u4e0eU\u4e92\u7d20\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u8f97\u8f6c\u76f8\u9664\u6cd5\u8ba1\u7b97\u51faU\u5173\u4e8e(modM)\u7684\u9006\u5143U -1 \u3002 \u8ba1\u7b97\uff1ab1=U*a1(mod M)\uff0cb2=Ua2(mod M) \uff0cb3=Ua3(mod M) \uff0c\u2026\uff0cbn=Uan(mod M) \u3002(\u4e0d\u5177\u6709\u8d85\u9012\u589e\u6027) \u6b64\u65f6 a1=U -1 b1(mod M)\uff0ca2=U -1 b2(mod M)\uff0ca3=U -1 b3(mod M)\uff0c \u2026\uff0can=U -1 bn(mod M) \u3002 {b1\uff0cb2\uff0cb3\uff0c\u2026\uff0cbn}\u662f\u516c\u94a5\u3002 {a1\uff0ca2\uff0ca3\uff0c\u2026\uff0can} \uff0c M\uff0cU\u90fd\u662f\u79c1\u94a5\u3002","title":"\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_33","text":"\u8bbe\u660e\u6587m\u4e3a\u6b63\u6574\u6570\uff0c\u5176\u4e8c\u8fdb\u5236\u5c55\u5f00\u5f0f\u4e3am=(m1,m2,m3\u2026mn) 2 \u3002\u4f7f\u7528\u516c\u94a5{b1\uff0cb2\uff0cb3\uff0c\u2026\uff0cbn}\u8ba1\u7b97\u5bc6\u6587c \uff1ac=m1*b1+m2b2+m3b3+\u2026+mnbn\u3002\u5bc6\u6587c\u662f\u4e00\u4e2a\u6b63\u6574\u6570\u3002","title":"\u52a0\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_34","text":"\u4f7f\u7528\u79c1\u94a5{a1\uff0ca2\uff0ca3\uff0c\u2026\uff0can} \uff0c M\uff0cU\uff0c\u8ba1\u7b97\u53d8\u6362\u8bfe\u6587C\uff1a C=U -1 c(modM) =U -1 (m1b1+m2b2+m3b3+\u2026+mnbn )(modM) =m1a1+m2a2+m3a3+\u2026+mnan(modM) =m1a1+m2a2+m3a3+\u2026+mnan\u3002","title":"\u89e3\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#elgamal","text":"\u5faa\u73af\u7fa4` \u8bbe(G,*)\u662f\u4e00\u4e2a\u6709\u9650\u7fa4, |G|= n, e\u662fG\u7684\u5355\u4f4d\u5143. \u5982\u679c\u5b58\u5728 a\u5c5e\u4e8eG\uff0c\u4f7f\u5f97a, a2,\u2026, an=e\u4e92\u4e0d\u76f8\u540c,\u5373 G={a, a2,\u2026,an}, \u5219\u79f0a\u662fG\u7684\u4e00\u4e2a\u672c\u539f\u5143\uff08\u751f\u6210\u5143\uff09. (G,*)\u79f0\u4e3a\u5faa\u73af\u7fa4\u3002 \u6709\u9650\u57df \u8bbep\u662f\u4e00\u4e2a\u7d20\u6570, Zp= {0,1,2,\u2026, p-1}. \u5728Zp \u4e2d, \u52a0\u6cd5\u4e0e\u4e58\u6cd5\u6309 mod (p) \u8fdb\u884c, \u5219Zp\u79f0\u4e3a\u4e00\u4e2a\u6709\u9650\u57df\u3002 GF(p)\u7684\u672c\u539f\u5143 \u8bbeZp*= {1,2,\u2026, p-1}, a\u5c5e\u4e8eZp*, \u5982\u679ca, a 2 ,\u2026, a p-1 =1\u4e92\u4e0d\u76f8\u540c,\u5373 Zp*={a, a2,\u2026,ap-1}, \u5219\u79f0a\u662fZp\u7684\u4e00\u4e2a\u672c\u539f\u5143. (Zp*, *)\u662f\u4e00\u4e2a\u5faa\u73af\u7fa4\u3002","title":"Elgamal \u516c\u94a5\u5bc6\u7801\u4f53\u5236"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_35","text":"\u5384\u683c\u739b\u5c14(ElGamal)\u5bc6\u7801\u4f53\u5236 \u5bc6\u94a5\u4ea7\u751f: \u9009\u62e9\u7d20\u6570p\uff0c\u6574\u6570g, x\u6ee1\u8db3 0<g, x<p, \u8ba1\u7b97 y=g x mod p. \u516c\u94a5: (p, g, y) \u79c1\u94a5: x","title":"\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_36","text":"\u8bbe\u660e\u6587\u4e3am (0<m<p), \u968f\u673a\u9009\u53d6k(0<k<p), \u8ba1\u7b97 c1=g k mod p, c2=y k m mod p. \u5bc6\u6587: c=(c1, c2)","title":"\u52a0\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_37","text":"\u8bbe\u5bc6\u6587\u4e3ac=(c1, c2), \u5219\u660e\u6587\u4e3a m=c2*(c1 x ) -1 mod p.","title":"\u89e3\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_38","text":"","title":"\u692d\u5706\u66f2\u7ebf\u52a0\u89e3\u5bc6\u8fd0\u7b97"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_39","text":"\u786e\u5b9a\u516c\u5f00\u53c2\u6570( p , a , b , n , g ) \u9009\u62e9\u4e00\u4e2a\u7d20\u6570*p*, \u786e\u5b9a\u6709\u9650\u57dfGF( p ) \u9009\u62e9*a*, b*\u5c5e\u4e8eGF(*p ), \u786e\u5b9a\u692d\u5706\u66f2\u7ebf*E* \u9009\u62e9*E*\u7684\u4e00\u4e2a\u5faa\u73af\u5b50\u7fa4*H*, \u4f7f\u5f97| H |= n*\u662f\u4e00\u4e2a\u5927\u7d20\u6570 \u9009\u62e9*H*\u7684\u4e00\u4e2a\u672c\u539f\u5143*g . \u786e\u5b9a\u79c1\u94a5: x \u7528\u6237\u968f\u673a\u9009\u53d6*x*\u5c5e\u4e8e{0,1,2,\u2026, n -1} \u786e\u5b9a\u516c\u94a5: y = x*g. \u6709\u9650\u57df\u4e0a\u7684\u692d\u5706\u66f2\u7ebf","title":"\u5bc6\u94a5\u9009\u53d6"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_40","text":"\u8bbep>=3\u662f\u7d20\u6570, Fp= {0,1,\u2026, p-1}\u662f\u6709\u9650\u57df, a, b\u5c5e\u4e8ep, \u25b3=4a 3 +27b 2 \u4e0d\u7b49\u4e8e0 mod (p), \u540c\u4f59\u65b9\u7a0b y 2 =x 3 +ax+b","title":"\u692d\u5706\u66f2\u7ebf\u7fa4\u8ba1\u7b97"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_41","text":"\u52a0\u5bc6\u7b97\u6cd5 \u8bbe\u660e\u6587\u4e3am, \u5c06m\u6620\u5c04\u5230\u5faa\u73af\u7fa4H\u4e0a\u7684\u70b9. \u968f\u673a\u9009\u53d6k\u5c5e\u4e8e{0,1,\u2026,n-1} \u8ba1\u7b97:c1=kg=(x1, y1) \u8ba1\u7b97:c2 =m+ky=(x2, y2) \u5bc6\u6587: c=(c1, c2) \u89e3\u5bc6\u7b97\u6cd5 \u8bbe\u5bc6\u6587\u4e3ac=(c1, c2), \u5219\u660e\u6587\u4e3a m=c2-xc1.","title":"\u52a0\u89e3\u5bc6\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_42","text":"","title":"\u52a0\u89e3\u5bc6\u4f8b\u5b50"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#hash","text":"lHash\u51fd\u6570\u7684\u5206\u7c7b \u5355\u5411Hash\u51fd\u6570\uff08one-way\uff09\u7ed9\u5b9a\u4e00\u4e2aHash\u503c*y*\uff0c\u5982\u679c\u5bfb\u627e\u4e00\u4e2a\u6d88\u606f*x*\uff0c\u4f7f\u5f97*y*= h ( x )\u662f\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u7684\uff0c\u5219\u79f0*h*\u662f\u5355\u5411Hash\u51fd\u6570. \u5f31\u6297\u78b0\u649eHash\u51fd\u6570\uff08weakly collision-free\uff09 \u4efb\u7ed9\u4e00\u4e2a\u6d88\u606f*x*\uff0c\u5982\u679c\u5bfb\u627e\u53e6\u4e00\u4e2a\u4e0d\u540c\u7684\u6d88\u606f*x*\u2019\uff0c\u4f7f\u5f97*h*( x ) = h ( x \u2019)\u662f\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u7684\uff0c\u5219\u79f0*h*\u662f\u5f31\u6297\u78b0\u649eHash\u51fd\u6570. \u5f3a\u6297\u78b0\u649eHash\u51fd\u6570 \uff08strongly collision-free\uff09 \u5982\u679c\u5bfb\u627e\u4e24\u4e2a\u4e0d\u540c\u7684\u6d88\u606f*x*\u548c*x*\u2019\uff0c\u4f7f\u5f97*h*( x )= h ( x \u2019)\u662f\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u7684\uff0c\u5219\u79f0*h*\u662f\u5f3a\u6297\u78b0\u649eHash\u51fd\u6570.","title":"Hash\u51fd\u6570"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_43","text":"","title":"\u6570\u5b57\u7b7e\u540d"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#rsa_1","text":"","title":"RSA\u7b7e\u540d"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_44","text":"\u9009\u53d6\u4e24\u4e2a\u5927\u7d20\u6570p\uff0cq\uff0c\u8ba1\u7b97 n=p*q\uff0c\u53bb\u03c6(n)=( p -1) *( q -1)\u3002 \u4efb\u9009\u6574\u6570e\uff0c\u6ee1\u8db3\uff1a 0< e <\u03c6(n)\uff0c\u4e14gcd(e ,\u03c6(n))=1\u3002 \u7528\u6269\u5c55Euclidean\u7b97\u6cd5\u6c42e\u6a21j(n)\u7684\u9006d\uff0c\u5373 e*d=1 mod \u03c6(n)\u3002 \u7b7e\u540d\u8005\u7684\u516c\u94a5: { n\uff0ce}\uff0c\u79c1\u94a5:{ p\uff0cq\uff0cd}\u3002 \u7b7e\u540d\u7b97\u6cd5 \u8bbe\u6d88\u606f\u4e3ax\uff0c\u5219x\u7684RSA\u7b7e\u540d\u4e3a y=x d mod n \u9a8c\u8bc1\u7b97\u6cd5\u5f53\u63a5\u6536\u65b9\u6536\u5230\u7b7e\u540d(x,y)\u540e\uff0c\u9a8c\u8bc1x=y e mod n","title":"\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#elgamal_1","text":"\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5 \u9009\u53d6\u4e00\u4e2a\u5927\u7d20\u6570p\uff0cg\u5c5e\u4e8eZp*\u662f\u4e00\u4e2a\u672c\u539f\u5143\uff0cp\u548cg\u662f\u7cfb\u7edf\u516c\u5f00\u53c2\u6570\u3002 \u4efb\u9009\u6574\u6570x\uff0c\u6ee1\u8db3\uff1a1\u2264x\u2264p-2\u3002\u8ba1\u7b97 y=g x mod p. \u7b7e\u540d\u8005\u7684\u516c\u94a5\u4e3ay\uff0c\u79c1\u94a5\u4e3ax\u3002 \u7b7e\u540d\u7b97\u6cd5 \u9a8c\u8bc1\u7b97\u6cd5","title":"Elgamal \u6570\u5b57\u7b7e\u540d"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_45","text":"\u5bc6\u94a5\u751f\u6210\u7b97\u6cd5\u7b7e\u540d\u53ca\u9a8c\u8bc1\u7b97\u6cd5","title":"\u7f8e\u56fd\u6570\u5b57\u7b7e\u540d\u6807\u51c6"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#_46","text":"\u5bc6\u94a5\u751f\u6210\u51fd\u6570\u7b7e\u540d\u7b97\u6cd5\u53ca\u9a8c\u8bc1\u7b97\u6cd5","title":"\u4fc4\u7f57\u65af\u6570\u5b57\u7b7e\u540d\u6807\u51c6"},{"location":"course/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/#fs","text":"\u9009\u53d6\u4e24\u4e2a\u5927\u7d20\u6570*p*\u3001 q \uff0c\u4ee4*n*=p*q\u3002n\u662f\u516c\u5f00\u53c2\u6570\uff0c*p*\u548c*q*\u662f\u7ba1\u7406\u4e2d\u5fc3CA\u638c\u63e1\u7684\u5bc6\u94a5\u3002\u8bbe*h*\u662f\u4e00\u4e2a\u516c\u5f00\u7684Hash\u51fd\u6570\uff0c*k*\u662f\u4e00\u4e2a\u56fa\u5b9a\u7684\u6b63\u6574\u6570\u3002 \u7ba1\u7406\u4e2d\u5fc3CA\u4e3a\u7528\u6237A\u4ea7\u751f*k*\u4e2a\u516c\u5f00\u5bc6\u94a5\uff1a y i (i =1,2,\u2026, k ) \u662f\u6a21*n*\u7684\u5e73\u65b9\u5269\u4f59 \u518d\u4e3a\u7528\u6237A\u4ea7\u751f*k*\u4e2a\u79c1\u94a5\uff08\u4fdd\u5bc6\uff09 \u7b7e\u540d\u7b97\u6cd5 \u9a8c\u8bc1\u7b97\u6cd5","title":"FS\u7b7e\u540d"},{"location":"course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/","text":"\u8ba1\u7b97\u673a\u56fe\u5f62\u5b66\u590d\u4e60 \u00b6 \u7b2c\u4e00\u7ae0 \u7eea\u8bba \u00b6 \u5b9a\u4e49 \u8ba1\u7b97\u673a\u56fe\u5f62\u5b66\u662f\u7814\u7a76\u901a\u8fc7\u8ba1\u7b97\u673a\u5c06\u6570\u636e\u8f6c\u6362\u4e3a\u56fe\u5f62\uff0c\u5e76\u5728\u4e13\u95e8\u7684\u663e\u793a\u8bbe\u5907\u4e0a\u663e\u793a\u7684\u539f\u7406\u3001\u65b9\u6cd5\u548c\u6280\u672f\u7684\u5b66\u79d1\u3002 \u8ba1\u7b97\u673a\u56fe\u5f62\u5b66\u5c31\u662f\u5e94\u7528\u8ba1\u7b97\u673a\u6280\u672f\u8fdb\u884c\u56fe\u5f62\u7684\u751f\u6210\u3001\u5904\u7406\u548c\u8f93\u51fa\u3002 \u8ba1\u7b97\u673a\u56fe\u5f62\u5b66\u4e0e\u5176\u4ed6\u5b66\u79d1\u7684\u5173\u7cfb \u56fe\u5f62\u7684\u57fa\u672c\u8981\u7d20 \u51e0\u4f55\u8981\u7d20\uff0c\u523b\u753b\u5bf9\u8c61\u7684\u8f6e\u5ed3\u3001\u5f62\u72b6\u7b49\u3002\u5982\u70b9\uff0c\u7ebf\uff0c\u591a\u8fb9\u5f62\uff0c\u591a\u9762\u4f53\u7b49\uff1b \u975e\u51e0\u4f55\u8981\u7d20\uff0c\u523b\u753b\u5bf9\u8c61\u7684\u989c\u8272\u3001\u6750\u8d28\u7b49\u3002\u5982\u989c\u8272\uff0c\u7eb9\u7406\u7b49\u3002 \u56fe\u5f62\u8868\u793a \u5b58\u50a8\u65b9\u6cd5 \u70b9\u9635\u6cd5 \u679a\u4e3e\u51fa\u56fe\u5f62\u4e2d\u6240\u6709\u7684\u70b9(\u5f3a\u8c03\u7531\u70b9<\u50cf\u7d20>\u6784\u6210\uff09\uff0c\u8fd9\u79cd\u8868\u793a\u7684\u56fe\u5f62\u79f0\u4e3a\u56fe\u50cf\u3002 \u53c2\u6570\u6cd5 \u7531\u56fe\u5f62\u7684\u5f62\u72b6\u53c2\u6570(\u65b9\u7a0b\u6216\u8868\u8fbe\u5f0f\u7684\u7cfb\u6570\uff0c\u7ebf\u6bb5\u7684\u7aef\u70b9\u5750\u6807\u7b49) + \u5c5e\u6027\u53c2\u6570(\u989c\u8272\u3001\u7ebf\u578b\u7b49) )\u6765\u8868\u793a\u56fe\u5f62\uff0c\u79f0\u4e3a\u56fe\u5f62\uff08graphics\uff09\uff0c\u5982\u5706\u53ef\u7528\u534a\u5f84\u3001\u5706\u5fc3\u5750\u6807\u548c\u989c\u8272\u8868\u793a \u8ba1\u7b97\u673a\u56fe\u5f62\u5b66\u57fa\u672c\u7814\u7a76\u5185\u5bb9 1\u3001\u56fe\u5f62\u7cfb\u7edf\uff08\u786c\u3001\u8f6f\u3001\u6807\u51c6\u5316\uff09 2\u3001\u57fa\u672c\u56fe\u5f62\u751f\u6210\uff1a\u5982\u4f55\u663e\u793a\u70b9\u3001\u7ebf\u6bb5\u3001\u591a\u8fb9\u5f62\u53ca\u5706\u7b49\u51e0\u4f55\u56fe\u5f62 3\u3001\u56fe\u5f62\u7684\u5904\u7406\uff1a\u51e0\u4f55\u53d8\u6362\uff08\u56fe\u5f62\u52a8\u8d77\u6765\uff09\uff1b\u6295\u5f71\u53d8\u6362\uff08\u5982\u4f55\u663e\u793a\u4e09\u7ef4\u56fe\u5f62\uff09\uff1b\u771f\u5b9e\u611f\u56fe\u5f62\uff08\u5149\u7167\u3001\u9634\u5f71\u3002\u3002\u3002\uff09 4\u3001\u7269\u4f53\u9020\u578b\uff1a\u5b9e\u4f53\u8868\u793a\uff1b\u66f2\u7ebf\u66f2\u9762\uff1b\u771f\u5b9e\u611f \u7b2c\u4e8c\u7ae0 \u8ba1\u7b97\u673a\u56fe\u5f62\u7cfb\u7edf\u6982\u8ff0 \u00b6 \u8ba1\u7b97\u673a\u56fe\u5f62\u7cfb\u7edf \u7ec4\u6210 \u786c\u4ef6\u4e0e\u8f6f\u4ef6\u793a\u610f\u56fe \u786c\u4ef6\uff1a\u8f93\u5165\u8bbe\u5907\u3001\u8f93\u51fa\u8bbe\u5907\u3001\u5b58\u50a8\u8bbe\u5907\u3001\u56fe\u5f62\u5904\u7406\u8bbe\u5907 \u8f6f\u4ef6\uff1a\u8f6f\u4ef6\u5305\u3001\u5e94\u7528\u7a0b\u5e8f\u3001\u5e94\u7528\u6a21\u578b \u57fa\u672c\u529f\u80fd \u8ba1\u7b97\uff1a\u56fe\u5f62\u5904\u7406\uff08\u5982\u56fe\u5f62\u53d8\u6362\u3001\u5149\u7167\u7b49\uff09 \u5b58\u50a8\uff1a\u8fdc\u7a0b\u548c\u672c\u673a \u8f93\u5165\uff1a\u4eba\u673a\u4ea4\u4e92\u53ca\u6570\u636e\u6587\u4ef6\u7b49 \u8f93\u51fa\uff1a\u663e\u793a\u5668\u3001\u6253\u5370\u673a\u7b49 \u5bf9\u8bdd\u56fe\u5f62\uff1a\u4eba\u673a\u4ea4\u4e92 \u663e\u793a\u8bbe\u5907 \u4e24\u79cd\u8bbe\u5907 \u9634\u6781\u5c04\u7ebf\u7ba1CRT (Cathode Ray Tube) \u7279\u70b9\uff1a\u4eae\u5ea6\u9ad8\u3001\u5bf9\u6bd4\u5ea6\u597d\u3001\u8272\u5f69\u9c9c\u8273 \u7f3a\u70b9\uff1a\u4f53\u79ef\u5927\uff0c\u7b28\u91cd \u5e73\u677f\u578b\u663e\u793a\u5668\uff1a\u6db2\u6676\u3001\u7b49\u79bb\u5b50 \u7279\u70b9\uff1a\u5668\u4ef6\u8584\uff0c\u9002\u5408\u4fbf\u643a \u7f3a\u70b9\uff1a\u4eae\u5ea6\u548c\u5bf9\u6bd4\u5ea6\u76f8\u5bf9\u8f83\u4f4e\u3001\u8272\u5f69\u4e0d\u591f\u9c9c\u8273\uff0c\u4ef7\u683c\u504f\u9ad8 CRT \u57fa\u672c\u539f\u7406 \u4e00\u79cd\u771f\u7a7a\u5668\u4ef6\uff0c\u5b83\u5229\u7528\u7535\u78c1\u573a\u4ea7\u751f\u9ad8\u901f\u7684\u3001\u7ecf\u8fc7\u805a\u7126\u7684\u7535\u5b50\u675f\uff0c\u504f\u8f6c\u5230\u5c4f\u5e55\u7684\u4e0d\u540c\u4f4d\u7f6e\uff0c\u8f70\u51fb\u5c4f\u5e55\u8868\u9762\u7684\u8367\u5149\u6750\u6599\uff0c\u4ece\u800c\u4ea7\u751f\u53ef\u89c1\u7684\u56fe\u5f62 \u7ec4\u6210 \u7535\u5b50\u67aa\u3001\u805a\u7126\u7cfb\u7edf\u3001\u52a0\u901f\u7535\u6781\u3001\u504f\u8f6c\u7cfb\u7edf\u3001\u8367\u5149\u5c4f \u7535\u5b50\u67aa \u7535\u706f\u4e1d\uff0c\u9634\u6781\u548c\u63a7\u5236\u6805\u7ec4\u6210 \u706f\u4e1d\uff1a\u4ea7\u751f\u70ed\u91cf \u9634\u6781\uff1a\u7531\u706f\u4e1d\u52a0\u70ed\u53d1\u51fa\u7535\u5b50\u675f \u63a7\u5236\u6805\uff1a\u52a0\u4e0a\u8d1f\u7535\u538b\u540e\uff0c\u80fd\u591f\u63a7\u5236\u901a\u8fc7\u5176\u4e2d\u5c0f\u5b54\u7684\u5e26\u8d1f\u7535\u7684\u7535\u5b50\u675f\u7684\u5f3a\u5f31\u3002\u901a\u8fc7\u8c03\u8282\u8d1f\u7535\u538b\u9ad8\u4f4e\u6765\u63a7\u5236\u7535\u5b50\u6570\u91cf\uff0c\u5373\u63a7\u5236\u8367\u5149\u5c4f\u4e0a\u76f8\u5e94\u70b9\u7684\u4eae\u5ea6 \u7535\u5b50\u67aa \u7535\u706f\u4e1d\uff0c\u9634\u6781\u548c\u63a7\u5236\u6805\u7ec4\u6210 \u706f\u4e1d\uff1a\u4ea7\u751f\u70ed\u91cf \u9634\u6781\uff1a\u7531\u706f\u4e1d\u52a0\u70ed\u53d1\u51fa\u7535\u5b50\u675f \u63a7\u5236\u6805 \u52a0\u4e0a\u8d1f\u7535\u538b\u540e\uff0c\u80fd\u591f\u63a7\u5236\u901a\u8fc7\u5176\u4e2d\u5c0f\u5b54\u7684\u5e26\u8d1f\u7535\u7684\u7535\u5b50\u675f\u7684\u5f3a\u5f31\u3002\u901a\u8fc7\u8c03\u8282\u8d1f\u7535\u538b\u9ad8\u4f4e\u6765\u63a7\u5236\u7535\u5b50\u6570\u91cf\uff0c\u5373\u63a7\u5236\u8367\u5149\u5c4f\u4e0a\u76f8\u5e94\u70b9\u7684\u4eae\u5ea6 \u52a0\u901f\u7535\u6781 \u52a0\u6b63\u7684\u9ad8\u538b\u7535\uff08\u51e0\u4e07\u4f0f\uff09 \u4f7f\u7535\u5b50\u675f\u9ad8\u901f\u8fd0\u52a8 \u504f\u8f6c\u7cfb\u7edf \u63a7\u5236\u7535\u5b50\u675f\uff0c\u9759\u7535\u573a\u6216\u78c1\u573a\uff0c\u4ea7\u751f\u504f\u8f6c \u6700\u5927\u504f\u8f6c\u89d2\u662f\u8861\u91cf\u7cfb\u7edf\u6027\u80fd\u7684\u6700\u91cd\u8981\u7684\u6307\u6807\uff0c\u663e\u793a\u5668\u957f\u77ed\u4e0e\u6b64\u6709\u5173 \u8367\u5149\u5c4f \u8367\u5149\u7269\u8d28\uff1a\u5438\u6536\u7535\u5b50\u675f\u800c\u53d1\u5149 \u6301\u7eed\u53d1\u5149\u65f6\u95f4\uff1a\u7535\u5b50\u675f\u79bb\u5f00\u67d0\u70b9\u540e\uff0c\u8be5\u70b9\u7684\u4eae\u5ea6\u503c\u8870\u51cf\u5230\u521d\u59cb\u503c1/10 \u6240\u9700\u7684\u65f6\u95f4 \u5237\u65b0(Refresh)\uff1a\u4e3a\u4e86\u8ba9\u8367\u5149\u7269\u8d28\u4fdd\u6301\u4e00\u4e2a\u7a33\u5b9a\u7684\u4eae\u5ea6\u503c \u5237\u65b0\u9891\u7387\uff1a\u6bcf\u79d2\u949f\u91cd\u7ed8\u5c4f\u5e55\u7684\u6b21\u6570 CRT\u4ea7\u751f\u7a33\u5b9a\u56fe\u50cf\u6240\u9700\u8981\u7684\u6700\u5c0f\u5237\u65b0\u9891\u7387=1\u79d2/\u8367\u5149\u7269\u8d28\u7684\u6301\u7eed\u53d1\u5149\u65f6\u95f4 \u4f8b\uff1a\u8367\u5149\u7269\u8d28\u7684\u6301\u7eed\u53d1\u5149\u65f6\u95f440\u6beb\u79d2\uff0c\u5237\u65b0\u9891\u7387\u5c31\u662f 1000/40=25Hz \u5f69\u8272CRT \u5c04\u7ebf\u7a7f\u900f\u6cd5 \u539f\u7406\uff1a\u4e24\u5c42\u8367\u5149\u6d82\u5c42\uff0c\u7ea2\u8272\u5149\u548c\u7eff\u8272\u5149\u4e24\u79cd\u53d1\u5149\u7269\u8d28\uff0c\u7535\u5b50\u675f\u8f70\u51fb\u7a7f\u900f\u8367\u5149\u5c42\u7684\u6df1\u6d45\uff0c\u51b3\u5b9a\u6240\u4ea7\u751f\u7684\u989c\u8272 \u5e94\u7528\uff1a\u4e3b\u8981\u7528\u4e8e\u753b\u7ebf\u663e\u793a\u5668 \u7279\u70b9\uff1a\u4f18\u70b9\u662f\u6210\u672c\u4f4e\uff1b\u7f3a\u70b9\u662f\u53ea\u80fd\u4ea7\u751f\u6709\u9650\u51e0\u79cd\u989c\u8272 \u5f71\u5b54\u677f\u6cd5 \u5e94\u7528\uff1a\u4e3b\u8981\u7528\u4e8e\u5149\u6805\u626b\u63cf\u663e\u793a\u5668 \u7ed3\u6784\uff1a\u5916\u5c42\u73bb\u7483\u3001\u8367\u5149\u6d82\u5c42\u548c\u5f71\u5b54\u677f\uff0c\u5f71\u5b54\u677f\u88ab\u5b89\u88c5\u5728\u8367\u5149\u5c4f\u7684\u5185\u8868\u9762\uff0c\u7528\u4e8e\u7cbe\u786e\u5b9a\u4f4d\u50cf\u7d20\u7684\u4f4d\u7f6e \u5de5\u4f5c\u539f\u7406\uff1a\u6bcf\u4e2a\u50cf\u7d20\u5904\u67093\u4e2a\u8367\u5149\u70b9\uff0c\u5448\u4e09\u89d2\u5f62\u6392\u5217\u3002\u4e09\u652f\u7535\u5b50\u67aa\u5bf9\u5e94\u7ea2\u3001\u7eff\u3001\u84dd\u4e09\u57fa\u8272\u3002\u7535\u5b50\u67aa\u3001\u5f71\u5b54\u677f\u4e2d\u7684\u4e00\u4e2a\u5c0f\u5b54\u548c\u8367\u5149\u70b9\u5448\u4e00\u76f4\u7ebf\uff1b\u6bcf\u4e2a\u5c0f\u5b54\u4e0e\u4e00\u4e2a\u50cf\u7d20\uff08\u5373\u4e09\u4e2a\u8367\u5149\u70b9\uff09\u5bf9\u5e94\u3002 \u4eae\u5ea6\u8c03\u8282\uff1a\u5404\u7535\u5b50\u67aa\u53d1\u751f\u7684\u7535\u5b50\u6570\u76ee\uff0c\u53ef\u63a7\u5236\u5404\u8272\u5149\u70b9\u4eae\u5ea6 \u6db2\u6676\u663e\u793a\u5668LCD \u5728\u6db2\u6676\u5206\u5b50\u4e24\u7aef\u6240\u52a0\u7535\u538b\u7684\u4e0d\u540c\uff0c\u6db2\u6676\u5206\u5b50\u7684\u7ffb\u8f6c\u7a0b \u5ea6\u4e0d\u540c\uff0c\u6839\u636e\u6db2\u6676\u89d2\u5ea6\u7684\u4e0d\u540c\u900f\u8fc7\u5149\u7684\u504f\u632f\u6027\u4e5f\u4e0d\u540c\uff1b \u6db2\u6676\u53ef\u4ee5\u88ab\u5149\u7a7f\u900f\uff0c\u5e76\u5f71\u54cd\u5149\u7684\u504f\u632f\u6027\uff1b \u6db2\u6676\u7684\u7535\u5149\u6548\u5e94\uff1a\u5f53\u6db2\u6676\u5206\u5b50\u7684\u67d0\u79cd\u6392\u5217\u72b6\u6001\u5728\u7535\u573a\u4f5c\u7528\u4e0b\u53d8\u4e3a\u53e6\u4e00\u79cd\u6392\u5217\u72b6\u6001\u65f6\uff0c\u6db2\u6676\u7684\u5149\u5b66\u6027\u8d28\u968f\u4e4b\u6539\u53d8\u3002 \u6db2\u6676\u663e\u793a\u7684\u673a\u7406\uff1a\u901a\u8fc7\u80fd\u963b\u585e\u6216\u4f20\u9012\u5149\u7684\u6db2\u6676\u6750\u6599\uff0c\u4f20\u9012\u6765\u81ea\u5468\u56f4\u7684\u6216\u5185\u90e8\u5149\u6e90\u7684\u504f\u632f\u5149 \u7ec4\u6210\uff1a\u5149\u6e90\u3001\u5782\u76f4\u504f\u5149\u677f\u3001\u73bb\u7483\u7535\u6781\u3001\u6db2\u6676\u3001\u73bb\u7483\u7535\u6781\u3001\u6c34\u5e73\u504f\u5149\u677f \u6bd4\u8f83 \u5171\u540c\u7279\u70b9 \u90fd\u662f\u901a\u8fc7\u5355\u4e2a\u53d1\u5149\u5143\u7d20\uff08\u70b9\uff0c\u50cf\u7d20\uff09\u6765\u663e\u793a\u56fe\u5f62\u6216\u6587\u5b57\u3002 \u4e0d\u540c\u70b9 \uff081\uff09LCD\u4f53\u79ef\u5c0f\uff0c\u539a\u5ea6\u8584\uff0c\u91cd\u91cf\u8f7b\uff0c\u8017\u80fd\u5c11\uff0c\u8f90\u5c04\u5f88\u5c11\u3002\uff082\uff09CRT\u663e\u793a\u4eae\u5ea6\u9ad8\uff0c\u8272\u5f69\u9c9c\u8273\uff0c\u5206\u8fa8\u7387\u9ad8\u3002 \u6027\u80fd\u6307\u6807 \u50cf\u7d20(Pixel: Picture Cell)\uff1a\u6784\u6210\u5c4f\u5e55\uff08\u56fe\u50cf\uff09\u7684\u6700\u5c0f\u5143\u7d20 \u5206\u8fa8\u7387(Resolution)\uff1aCRT\u5728\u6c34\u5e73\u6216\u7ad6\u76f4\u65b9\u5411\u5355\u4f4d\u957f\u5ea6\u4e0a\u80fd\u8bc6\u522b\u7684\u6700\u5927\u50cf\u7d20\u4e2a\u6570\uff0c\u5355\u4f4d\u901a\u5e38\u4e3adpi\uff08dots per inch) \u5206\u8fa8\u7387\u8d8a\u9ad8\u663e\u793a\u7684\u56fe\u5f62\u5c31\u8d8a\u7cbe\u7ec6 \u663e\u793a\u7cfb\u7edf \u4e3b\u8981\u7ec4\u6210 \u663e\u793a\u8bbe\u5907\uff1a\u663e\u793a\u5668 \u89c6\u9891\u63a7\u5236\u5668\uff1a\u63a7\u5236\u663e\u793a\u8bbe\u5907\uff08\u6709\u7684\u542b\u56fe\u5f62\u52a0\u901f\u5904\u7406\u5668\uff09\uff0c\u901a\u8fc7\u8bbf\u95ee\u5e27\u7f13\u5b58\u6765\u5237\u65b0\u5c4f\u5e55 \u663e\u793a\u7f13\u51b2\u5b58\u50a8\u5668\uff08\u5e27\u7f13\u5b58\uff09\uff1a\u53ef\u4ee5\u5728\u5185\u5b58\u6216\u663e\u793a\u63a7\u5236\u5668\u4e2d \u663e\u793a\u7cfb\u7edf \u968f\u673a\u626b\u63cf\uff08random scan\uff09\uff1a\u7535\u5b50\u675f\u53ef\u4ee5\u4efb\u610f\u79fb\u52a8\u3002\u753b\u7ebf\u8bbe\u5907 \u7279\u70b9\uff1a\u7535\u5b50\u675f\u53ef\u968f\u610f\u79fb\u52a8\uff0c\u53ea\u626b\u63cf\u8367\u5c4f\u4e0a\u8981\u663e\u793a\u7684\u90e8\u5206\u50cf\u7d20\u3001\u5bf9\u5e94\u7684\u663e\u793a\u5668\u4e3a\u753b\u7ebf\u8bbe\u5907 \u903b\u8f91\u90e8\u4ef6\uff1a\u5237\u65b0\u5b58\u50a8\u5668(Refreshing Buffer)\u3001\u663e\u793a\u5904\u7406\u5668\uff08DPU: Display Processing Unit\u3001CRT \u5149\u6805\u626b\u63cf\uff08raster scan\uff09\uff1a\u7535\u5b50\u675f\u6309\u56fa\u5b9a\u626b\u63cf\u7ebf\u548c\u6b21\u5e8f\u8fdb\u884c\u3002\u753b\u70b9\u8bbe\u5907 \u57fa\u672c\u6982\u5ff5 \u57fa\u672c\u539f\u7406\uff1a\u7535\u5b50\u675f\u6309\u56fa\u5b9a\u7684\u626b\u63cf\u7ebf\u548c\u626b\u63cf\u987a\u5e8f\u4ece\u5de6\u5230\u53f3\u3001\u81ea\u4e0a\u800c\u4e0b\u8fdb\u884c\u626b\u63cf\u3002 \u57fa\u672c\u6982\u5ff5\uff1a\u626b\u63cf\u7ebf\uff1a\u4e00\u6761\u6c34\u5e73\u7ebf \u5e27\uff08frame\uff09\uff1a1\u6b21\u626b\u63cf\u751f\u6210\u7684\u56fe\u50cf \u6c34\u5e73\u56de\u626b\u671f\uff1a\u6c34\u5e73\u7ebf\u95f4\u7684\u56de\u626b\u671f \u5782\u76f4\u56de\u626b\u671f\uff1a\u5e27\u95f4\u7684\u56de\u626b\u671f \u7ec4\u6210 \u5e27\u7f13\u51b2\u5b58\u50a8\u5668\uff08Frame Buffer)--\u5e27\u7f13\u5b58 \u89c6\u9891\u63a7\u5236\u5668\uff08Video Controller) \u663e\u793a\u5904\u7406\u5668\uff08Display Processor\uff09 \u663e\u793a\u5668\uff1aCRT\u3001\u6db2\u6676 \u5e27\u7f13\u5b58 \u4f5c\u7528\uff1a\u5b58\u50a8\u5c4f\u5e55\u4e0a\u50cf\u7d20\u7684\u989c\u8272\u503c \u5e27\u7f13\u5b58\u4e2d\u5355\u5143\u6570\u76ee\u4e0e\u663e\u793a\u5668\u4e0a\u50cf\u7d20\u7684\u6570\u76ee\u76f8\u540c\uff0c\u5355\u5143\u4e0e\u50cf\u7d20\u4e00\u4e00\u5bf9\u5e94\uff0c\u5404\u5355\u5143\u7684\u6570\u503c\u51b3\u5b9a\u4e86\u5176\u5bf9\u5e94\u50cf\u7d20\u7684\u989c\u8272\u3002 \u663e\u793a\u989c\u8272\u7684\u79cd\u7c7b\u4e0e\u5e27\u7f13\u5b58\u4e2d\u6bcf\u4e2a\u5355\u5143\u7684\u4f4d\u6570\u6709\u5173\u3002\u5982\uff1a\u9ed1\u767d\u663e\u793a\u7cfb\u7edf\u7684\u5e27\u7f13\u51b2\u5668\u7684\u6bcf\u4e2a\u5355\u5143\u53ea\u9700\u4e00\u4f4d\u3002 \u5e27\u7f13\u5b58\u5bb9\u91cf\uff1a\u5206\u8fa8\u7387M*N\u3001\u989c\u8272\u4e2a\u6570K \u4e0e\u7f13\u5b58\u5927\u5c0fV \u7684\u5173\u7cfb $V \\geq M*N* \\lceil log_2 K \\rceil $ \u76ee\u524d\u6709\u7684PC\u673a\u7684\u663e\u5b58\u5bb9\u91cf\u8fbe512M\u4ee5\u4e0a\uff0c\u6709\u5fc5\u8981\uff1f \u539f\u56e0\uff1a\u663e\u5b58\u8fd8\u5305\u62ec\u6df1\u5ea6\u7f13\u5b58\u3001\u7eb9\u7406\u5185\u5b58\u7b49 \u989c\u8272\u6a21\u578b \u4e09\u57fa\u8272 RGB\u4e09\u57fa\u8272\uff1a\u9762\u5411\u786c\u4ef6\u8bbe\u5907\uff08\u6444\u50cf\u673a\u3001\u626b\u63cf\u4eea\u548c\u6295\u5f71\u4eea\u7b49\uff09 CMY\u4e09\u57fa\u8272\uff1a\u4e09\u8865\u8272\uff1a \u84dd\u7eff(C, cyan)\uff0c\u54c1\u7ea2(M, magenta)\uff0c\u9ec4(Y, yellow) \u7528\u4e8e\u5f69\u8272\u6253\u5370 CMY\u4e0eRGB\u5173\u7cfb\uff1aR=1-C\u3001G=1-M\u3001B=1-Y \u89c6\u9891\u63a7\u5236\u5668 \u663e\u793a\u5904\u7406\u5668 \u4f5c\u7528\uff1a\u4ee3\u66ffCPU\u5b8c\u6210\u90e8\u5206\u56fe\u5f62\u5904\u7406\u529f\u80fd\uff0c\u626b\u63cf\u8f6c\u6362\u3001\u51e0\u4f55\u53d8\u6362\u3001\u88c1\u526a\u3001\u5149\u6805\u64cd\u4f5c\u3001\u7eb9\u7406\u6620\u5c04\u7b49\u7b49 \u5177\u6709\u4e13\u7528\u663e\u793a\u5904\u7406\u5668\u7684\u5149\u6805\u663e\u793a\u7cfb\u7edf\u7684\u7ed3\u6784 \u56fe\u5f62\u52a0\u901f\u5361 = \u89c6\u9891\u63a7\u5236\u5668 + \u663e\u5b58 + \u663e\u793a\u5904\u7406\u5668 \u663e\u5361=\u663e\u793a\u5904\u7406\u5668\u7684\u4e13\u7528\u5b58\u50a8\u5668+\u5e27\u7f13\u51b2\u5668+\u89c6\u9891\u63a7\u5236\u5668+\u663e\u793a\u5904\u7406\u5668 \u7279\u70b9 \u4f18\u70b9\uff1a\u6210\u672c\u4f4e\u3001\u6613\u4e8e\u7ed8\u5236\u586b\u5145\u56fe\u5f62\u3001\u8272\u5f69\u4e30\u5bcc\u3001\u5237\u65b0\u9891\u7387\u4e00\u5b9a\u3001\u4e0e\u56fe\u5f62\u7684\u590d\u6742\u7a0b\u5ea6\u65e0\u5173\u3001\u6613\u4e8e\u4fee\u6539\u56fe\u5f62 \u7f3a\u70b9\uff1a\u9700\u8981\u626b\u63cf\u8f6c\u6362\uff0c\u590d\u6742\u56fe\u5f62\u8ba1\u7b97\u91cf\u5927\u3001\u4f1a\u4ea7\u751f\u6df7\u6dc6\uff08\u8d70\u6837\uff09 \u8f6f\u4ef6\u7cfb\u7edf \u7b2c\u4e00\u5c42\u6b21\uff1a\u9762\u5411\u786c\u4ef6\u7cfb\u7edf \u89e3\u51b3\u56fe\u5f62\u8bbe\u5907\u4e0e\u8ba1\u7b97\u673a\u7684\u901a\u8baf\u63a5\u53e3\u7b49\u95ee\u9898\uff0c\u79f0\u4e3a\u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f \u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f\u73b0\u5728\u5df2\u88ab\u4f5c\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u4e00\u90e8\u5206\uff0c\u7531\u64cd\u4f5c\u7cfb\u7edf\u6216\u8bbe\u5907\u786c\u4ef6\u5382\u5546\u5f00\u53d1\uff1b \u7b2c\u4e8c\u5c42\u6b21\uff1a\u5efa\u7acb\u5728\u9a71\u52a8\u7a0b\u5e8f\u4e4b\u4e0a \u5b8c\u6210\u56fe\u5143\u7684\u751f\u6210\u3001\u8bbe\u5907\u7684\u7ba1\u7406\u7b49\u529f\u80fd \u8fd9\u4e2a\u5c42\u6b21\u4e0a\u7684\u56fe\u5f62\u652f\u6491\u8f6f\u4ef6\u5df2\u7ecf\u6807\u51c6\u5316\uff0c\u5982GKS\u3001PHIGS\u3001CGI\u7b49\uff1b \u7b2c\u4e09\u5c42\u6b21\uff1a\u9762\u5411\u7528\u6237 \u4e3b\u8981\u4efb\u52a1\u662f\u5efa\u7acb\u56fe\u5f62\u6570\u636e\u7ed3\u6784\uff0c\u5b9a\u4e49\u3001\u4fee\u6539\u548c\u8f93\u51fa\u56fe\u5f62 \u5177\u6709\u8f83\u5f3a\u7684\u4ea4\u4e92\u529f\u80fd\uff0c\u4f7f\u7528\u65b9\u4fbf\uff0c\u5bb9\u6613\u9605\u8bfb\uff0c\u4fbf\u4e8e\u7ef4\u62a4\u548c\u79fb\u690d OpenGL\u3001Direct3D\u5c5e\u4e8e\u8fd9\u4e00\u5c42\u6b21 \u7b2c\u4e09\u7ae0 \u57fa\u672c\u5149\u6805\u56fe\u5f62\u751f\u6210\u6280\u672f \u00b6 \u5149\u6805\u56fe\u5f62\u5b66 \u56fe\u5143\u7684\u751f\u6210 \u662f\u6307\u5b8c\u6210\u56fe\u5143\u7684\u53c2\u6570\u8868\u793a\u5f62\u5f0f\u5230\u70b9\u9635\u8868\u793a\u5f62\u5f0f\u7684\u8f6c\u6362\u3002\u901a\u5e38\u4e5f\u79f0\u626b\u63cf\u8f6c\u6362\u56fe\u5143(Scan Converter) \u53c2\u6570\u8868\u793a\u5f62\u5f0f\u7531\u4e0d\u540c\u79cd\u7c7b\u56fe\u5f62\u7684\u6027\u8d28\u51b3\u5b9a\uff0c\u70b9\u9635\u8868\u793a\u5f62\u5f0f\u662f\u5149\u6805\u663e\u793a\u7cfb\u7edf\u5237\u65b0\u65f6\u6240\u9700\u7684\u8868\u793a\u5f62\u5f0f\u3002 openGL\u76f8\u5173\u51fd\u6570 //\u521d\u59cb\u5316\u989c\u8272 glClearColor ( 0 , 1 , 0 , 1 ); //\u6e05\u9664\u5e27\u7f13\u5b58\uff0c\u5e76\u5c06\u6bcf\u4e2a\u50cf\u7d20\u5bf9\u5e94\u5355\u5143\u8d4b\u4e3a\u80cc\u666f\u989c\u8272\u503c glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT ); //\u8868\u793a\u7ed3\u675f\u7ed8\u56fe\u547d\u4ee4\uff0c\u4f7f\u7528\u5355\u7f13\u5b58\u65f6\u5fc5\u987b\u8981\u3002\u53cc\u7f13\u51b2\u65f6\u53ef\u4ee5\u4e0d\u8981 glFinish (); //\u53cc\u7f13\u5b58\u65f6\u4f7f\u7528\u3002\u4ea4\u6362\u7f13\u5b58\u547d\u4ee4\uff0c\u8868\u793a\u5f53\u524d\u663e\u793a\u5e27\u548c\u4e0b\u5e27\u7684\u5e27\u7f13\u5b58\u4ea4\u6362 glutSwapBuffers (); \u5355\u7f13\u5b58\u4e0e\u53cc\u7f13\u5b58\u673a\u5236 \u5355\u7f13\u5b58\uff1a\u626b\u63cf\u4e0e\u751f\u6210\u70b9\u9635\u4e32\u884c\u8fdb\u884c \u53cc\u7f13\u5b58\uff1a\u626b\u63cf\u4e0e\u751f\u6210\u70b9\u9635\u540c\u65f6\uff08\u5e76\u884c\uff09\u8fdb\u884c \u57fa\u672c\u7ebf\u753b\u56fe\u5143\u751f\u6210 \u626b\u63cf\u8f6c\u6362\u76f4\u7ebf\u6bb5 \u6982\u5ff5\uff1a\u6c42\u4e0e\u76f4\u7ebf\u6bb5\u5145\u5206\u63a5\u8fd1\u7684\u50cf\u7d20\u96c6\uff0c\u5e76\u4ee5\u6b64\u50cf\u7d20\u96c6\u66ff\u4ee3\u539f\u8fde\u7eed\u76f4\u7ebf\u6bb5\u5728\u5c4f\u5e55\u4e0a\u663e\u793a\u3002 \u7ea6\u675f\u6761\u4ef6\uff1a \u5c4f\u5e55\u5750\u6807\u7cfb\u662f\u6574\u578b\u5750\u6807\u7cfb\u3001\u50cf\u7d20\u95f4\u6a2a\u5411\u548c\u7eb5\u5411\u8ddd\u79bb\u76f8\u7b49\u3001\u76f4\u7ebf\u6bb5\u4e3a P_0(x_0,y_0)\uff0cp_1(x_1,y_1\u4e14 x_0<x_1\u4e14\u5747\u4e3a\u6574\u6570) P_0(x_0,y_0)\uff0cp_1(x_1,y_1\u4e14 x_0<x_1\u4e14\u5747\u4e3a\u6574\u6570) \u3001\u76f4\u7ebf\u6bb5\u7684\u5bbd\u5ea6\uff08\u7ebf\u5bbd\uff09\u4e3a1\u3010\u6a2a\u5411\u6216\u7eb5\u5411\u50cf\u7d20\u76f8\u90bb\u3011\u3001 \u76f4\u7ebf\u6bb5\u7684\u659c\u7387 0 \\leq k \\leq 1 0 \\leq k \\leq 1 \u3001\u76f8\u90bb\u50cf\u7d20\u95f4\u5750\u6807\u5206\u91cf\u5dee\u4e3a-1\uff0c0\u62161 \u4e3b\u8981\u7b97\u6cd5 \u76f4\u7ebf\u65b9\u7a0b\u6cd5 \u57fa\u672c\u601d\u60f3 \u6839\u636e\u76f4\u7ebf\u7684\u51e0\u4f55\u65b9\u7a0b\u786e\u5b9a\u7ebf\u6bb5\u8def\u5f84\u4e0a\u7684\u50cf\u7d20\u4f4d\u7f6e\u3002 \u65b9\u6cd5 \u5212\u5206\u533a\u95f4 [x_0, x_1] [x_0, x_1] : t_0, t_1,\u2026, t_n, t_{i+1}=x_{i+1} t_0, t_1,\u2026, t_n, t_{i+1}=x_{i+1} , \u5176\u4e2d t_{i+1}=t_i+1,t_0 = x_0,t_n=x_1 t_{i+1}=t_i+1,t_0 = x_0,t_n=x_1 \u8ba1\u7b97\u7eb5\u5750\u6807y\uff1a y_i = k*t_i + b y_i = k*t_i + b \u53d6\u6574\uff1a\u56db\u820d\u4e94\u5165\uff0c\u5373 y_{i,r}=round(y_i)=(int)(y_i+0.5) y_{i,r}=round(y_i)=(int)(y_i+0.5) \u4e3b\u8981\u8fd0\u7b97\uff1a\u4e58\u6cd5+\u52a0\u6cd5+\u53d6\u6574+\u6d6e\u70b9\u8fd0\u7b97 \u6570\u503c\u5fae\u5206DDA\u7b97\u6cd5\u3001 \u65b9\u6cd5\uff1a y_{i+1}=k*x_{i+1}+b=k*(x_i+1)+b=y_i+k y_{i+1}=k*x_{i+1}+b=k*(x_i+1)+b=y_i+k \u4e3b\u8981\u8fd0\u7b97\uff1a\u52a0\u6cd5+\u53d6\u6574+\u6d6e\u70b9\u8fd0\u7b97 \u4e2d\u70b9\u7b97\u6cd5 \u76ee\u6807\uff1a\u6d88\u9664\u6d6e\u70b9\u8fd0\u7b97 \u65b9\u6cd5 \u76f4\u7ebf\u9690\u5f0f\u65b9\u7a0b F(x,y)=a*x+b*y+c=0 F(x,y)=a*x+b*y+c=0 \u53ef\u6839\u636e F(x,y) F(x,y) \u7684\u5927\u5c0f\u6765\u5224\u65ad\u70b9\u662f\u5426\u5728\u76f4\u7ebf\u548c\u70b9\u7684\u5173\u7cfb\uff1a F(x,y)>0 F(x,y)>0 \u76f4\u7ebf\u4e0a\u65b9\uff0c F(x,y)=0 F(x,y)=0 \u76f4\u7ebf\u4e0a\uff0c F(x,y)<0 F(x,y)<0 \u76f4\u7ebf\u4e0b\u65b9 \u5224\u65ad\u4e0b\u4e00\u4e2a\u50cf\u7d20\u70b9\u7684\u5750\u6807 \u5df2\u8ba1\u7b97\u51fa\u67d0\u4e00\u70b9\u7684\u5750\u6807 (x_i,y_{i,r}) (x_i,y_{i,r}) \uff0c\u5219\u53ef\u6784\u9020\u5224\u522b\u5f0f d=F(M)=F(x_{i+1},y_{i,r}+0.5) d=F(M)=F(x_{i+1},y_{i,r}+0.5) \uff0c\u901a\u8fc7d\u7684\u6b63\u8d1f\u6765\u5224\u65ad\u4e0b\u4e00\u70b9\u7684\u5750\u6807\uff0c\u82e5d<0\uff0c\u5219\u9009\u62e9 (x_{i+1},y_{i,r}+1) (x_{i+1},y_{i,r}+1) \uff0c\u53cd\u4e4b\uff0c\u9009\u62e9 (x_{i+1},y_{i,r}) (x_{i+1},y_{i,r}) \u3002 \u5224\u65ad\u518d\u4e0b\u4e00\u4e2a\u50cf\u7d20\u70b9\u7684\u5750\u6807 \u82e5 d \\geq 0 \uff0c\u5219\u53d6\u53f3\u4fa7\u50cf\u7d20 \uff0c\u5219\u53d6\u53f3\u4fa7\u50cf\u7d20 (x_{i+1},y_{i,r})(x_{i+1},y_{i,r}) d \\geq 0 <span class=\"arithmatex\"><span class=\"MathJax_Preview\">\uff0c\u5219\u53d6\u53f3\u4fa7\u50cf\u7d20</span><script type=\"math/tex\">\uff0c\u5219\u53d6\u53f3\u4fa7\u50cf\u7d20 (x_{i+1},y_{i,r})(x_{i+1},y_{i,r}) \uff0c\u5219\u518d\u4e0b\u4e00\u4e2a\u50cf\u7d20 d=F(x_{i+2},y_{i,r}+0.5)=a*(x_i+2)+b*(y_{i,r}+0.5)+c=d+a d=F(x_{i+2},y_{i,r}+0.5)=a*(x_i+2)+b*(y_{i,r}+0.5)+c=d+a \u6b64\u65f6d\u7684\u589e\u91cf\u4e3aa \u82e5 d<0 d<0 \uff0c\u5219\u53d6\u53f3\u4e0a\u4fa7\u7684\u50cf\u7d20 (x_{i+1},y_{i,r}+1) (x_{i+1},y_{i,r}+1) \uff0c\u5219\u518d\u4e0b\u4e00\u4e2a\u50cf\u7d20 d=F(x_{i+2},y_{i,r}+1.5)=a*(x_i+2)+b*(y_{i,r}+1.5)+c=d+a+b d=F(x_{i+2},y_{i,r}+1.5)=a*(x_i+2)+b*(y_{i,r}+1.5)+c=d+a+b \u6b64\u65f6d\u7684\u589e\u91cf\u4e3aa+b d\u7684\u521d\u59cb\u503c\uff1a d_0=F(x_0+1, y_0+0.5)=F(x_0, y_0)+a+0.5*b d_0=F(x_0+1, y_0+0.5)=F(x_0, y_0)+a+0.5*b \uff0c\u56e0(x0, y0)\u5728\u76f4\u7ebf\u4e0a\uff0cF(x0, y0)=0, \u6240\u4ee5\uff0c d_0 = a + 0.5*b d_0 = a + 0.5*b \u589e\u91cfd\u7684\u9012\u63a8\u516c\u5f0f \u6ce8\u610f\u659c\u7387\u5927\u4e8e1\u548c\u8d1f\u6570\u7684\u60c5\u51b5\u3002 \u626b\u63cf\u8f6c\u6362\u5706\u5f27 \u5e73\u79fb\u5706\u5fc3\u5230\u539f\u70b9\uff0c\u626b\u63cf\u8f6c\u6362\u540e\u518d\u5e73\u79fb\u5230\u539f\u4f4d\u7f6e \u5706\u7684\u516b\u5bf9\u79f0\u6027\uff1a\u7531\u516b\u5206\u4e4b\u4e00\u5706\u5f27\u4e0a\u7684\u70b9\u53ef\u8ba1\u7b97\u5176\u5b83\u5404\u5206\u6bb5\u5f27\u4e0a\u7684\u70b9\uff0c\u53ea\u9700\u8981\u626b\u63cf\u8f6c\u6362\u516b\u5206\u4e4b\u4e00\u5706\u5f27\u5373\u53ef \u4e3b\u8981\u65b9\u6cd5\uff1a\u65b9\u7a0b\u6cd5\u3001\u4e2d\u70b9\u7b97\u6cd5\u548c\u903c\u8fd1\u6cd5 \u4e3b\u8981\u7b97\u6cd5 \u65b9\u7a0b\u6cd5 \u79bb\u6563\u70b9\uff1a x^2+y^2=R^2 x^2+y^2=R^2 \uff0c\u5219 x_i,y_i=\\sqrt{R^2-x_i^2} x_i,y_i=\\sqrt{R^2-x_i^2} \u53d6\u6574\u5f97\u5230 (x_i,y_i) (x_i,y_i) \u79bb\u6563\u89d2\u5ea6\uff1a\u5229\u7528\u53c2\u6570\u65b9\u7a0b\uff1a x=R*cos \\theta.y=R*sin\\theta x=R*cos \\theta.y=R*sin\\theta \u4e2d\u70b9\u7b97\u6cd5 \u5706\u5f27\u7684\u6b63\u8d1f\u5212\u5206\u6027 \u5706\u5f27\u5916\u7684\u70b9\uff1a F(x,y)>0 F(x,y)>0 \uff1b\u5706\u5f27\u4e0a\u7684\u70b9\uff1a F(x,y)=0 F(x,y)=0 \uff1b\u5706\u5f27\u5185\u7684\u70b9\uff1a F(x,y)<0 F(x,y)<0 \u516b\u5206\u5706\u7684\u9009\u62e9 \u7b2c\u4e00\u8c61\u9650\u7684\u516b\u5206\u4e4b\u4e00\u5706\u5f27\u4e2dx \u7684\u53d8\u5316\u5927\u4e8e y \u7684\u53d8\u5316\uff0c\u5373\u5706\u5f27\u4e0a\u7684\u5207\u77e2\u91cf\u659c\u7387\u57280 ... -1\u95f4\u3002 \u56e0\u6b64\u53ef\u4ee5\u4f7f x \u4ece0 \u589e\u52a0\u5230 R/(21/2)\uff0c\u8ba1\u7b97 y \u7684\u503c\u3002 \u78ba\u5b9a\u4e0b\u4e00\u50cf\u7d20\u70b9 \u70b9 p(x_i, y_{i,r}) p(x_i, y_{i,r}) \u4e0b\u4e00\u70b9\u6240\u53d6\u53ef\u80fd\u70b9\u95f4\u7ebf\u6bb5\u7684\u4e2d\u70b9\uff0c M = (x_{i+1}, y_{i,r} - 0.5) M = (x_{i+1}, y_{i,r} - 0.5) \u5f53F(M)\u22640\u65f6\uff0cM\u5728\u5706\u5185\uff0c\u8bf4\u660eE\u8ddd\u79bb\u5706\u5f27\u66f4\u8fd1\uff0c\u53d6 (x_{i+1},y_{i,r}) (x_{i+1},y_{i,r}) \u5f53F(M)\uff1e0\u65f6\uff0c M\u5728\u5706\u5916\uff0c \u53d6 (x_{i+1},y_{i,r}-1) (x_{i+1},y_{i,r}-1) \u6784\u9020\u5224\u522b\u5f0f d_i = F(M) = F(x_i+1, y_{i,r}-0.5) = (x_i+1)^2+(y_i-0.5)^2-R^2 d_i = F(M) = F(x_i+1, y_{i,r}-0.5) = (x_i+1)^2+(y_i-0.5)^2-R^2 \u82e5 d \\leq 0 d \\leq 0 \uff0c\u5219\u518d\u4e0b\u4e00\u4e2a\u50cf\u7d20\u70b9\u5224\u5b9a\u5f0f d_{i+1}=F(x_i+2,y_{i,r}-0.5)=d+2x_i+3 d_{i+1}=F(x_i+2,y_{i,r}-0.5)=d+2x_i+3 \u82e5 d>0 d>0 \uff0c\u5219\u518d\u4e0b\u4e00\u4e2a\u50cf\u7d20\u70b9\u5224\u5b9a\u5f0f d_{i+1}=F(x_i+2,y_{i,r}-1.5)=d+(2x_i+3)+(-2y_{i,r}+2) d_{i+1}=F(x_i+2,y_{i,r}-1.5)=d+(2x_i+3)+(-2y_{i,r}+2) d\u7684\u521d\u59cb\u503c d_0=F(1,R-0.5)=1.25-R d_0=F(1,R-0.5)=1.25-R \u9012\u63a8\u516c\u5f0f \u6d88\u9664\u4e58\u6cd5\u8fd0\u7b97 \u903c\u8fd1\u6cd5 \u4e24\u79cd\u65b9\u6cd5\uff1a\u6b63\u5185\u63a5\u591a\u8fb9\u5f62\u8feb\u8fd1\u6cd5\u3001\u7b49\u9762\u79ef\u6b63\u591a\u8fb9\u5f62\u8feb\u8fd1\u6cd5 \u7279\u70b9\uff1a\u591a\u8fb9\u5f62\u8fb9\u6570\u8db3\u591f\u591a\u65f6\u63a5\u8fd1\u5706\u3001\u8bef\u5dee\u63a7\u5236\u8fb9\u6570\uff1a\u8fb9\u8d8a\u591a\u7cbe\u5ea6\u8d8a\u9ad8\uff0c\u4f46\u8ba1\u7b97\u5f00\u9500\u5927\u3001\u591a\u8fb9\u5f62\u7684\u8fb9\u53ef\u7528\u76f4\u7ebf\u6bb5\u7684\u4e2d\u70b9\u7b97\u6cd5\u6765\u751f\u6210 \u6b63\u5185\u63a5\u591a\u8fb9\u5f62\u8feb\u8fd1\u6cd5 \u200b \u586b\u5145\u56fe\u5143\u751f\u6210 \u4e24\u79cd\u65b9\u6cd5\u626b\u63cf\u8f6c\u6362: \u53c2\u6570\uff0d>\u70b9\u9635\u3001\u586b\u5145\uff08Filling\uff09 : \u70b9\u9635\uff0d>\u70b9\u9635 \u5171\u4eab\u8fb9\u754c\uff1a\u5de6\u95ed\u53f3\u5f00\uff0c\u4e0b\u95ed\u4e0a\u5f00 \u626b\u63cf\u8f6c\u6362\u591a\u8fb9\u5f62 \u4e24\u79cd\u65b9\u6cd5\uff1a\u9010\u70b9\u5224\u65ad\u6cd5\uff1b\u626b\u63cf\u7ebf\u7b97\u6cd5\uff1b \u591a\u8fb9\u5f62\u5206\u7c7b \u51f8\u591a\u8fb9\u5f62(convex)\uff1a\u5185\u89d2\u5c0f\u4e8e180\u5ea6 \u51f9\u591a\u8fb9\u5f62(concave)\uff1a\u5b58\u5728\u5185\u89d2\u5927\u4e8e180\u5ea6 \u53ea\u8003\u8651\uff1a\u7b80\u5355\u591a\u8fb9\u5f62\uff0c\u5373\u591a\u8fb9\u5f62\u8fb9\u4e0d\u81ea\u76f8\u4ea4 \u9010\u70b9\u5224\u65ad\u53d1\uff0c\u5373\u4e3a\u5224\u65ad\u6bcf\u4e2a\u70b9\u548c\u591a\u8fb9\u5f62\u7684\u5185\u5916\u5173\u7cfb--\u5c04\u7ebf\u6cd5 \u6b65\u9aa4 \uff081\uff09\u4ece\u5f85\u5224\u522b\u70b9 v \u53d1\u51fa\u5c04\u7ebf\uff08\u4efb\u610f\u65b9\u5411\uff0c\u4e00\u822c\u6c34\u5e73\u65b9\u5411\uff09 \uff082\uff09\u6c42\u4e0e\u591a\u8fb9\u5f62\u4ea4\u70b9\u4e2a\u6570 k \uff083\uff09k \u7684\u5947\u5076\u6027\u51b3\u5b9a\u4e86\u70b9\u4e0e\u591a\u8fb9\u5f62\u7684\u5185\u5916\u5173\u7cfb \u5076\u6570\uff1a\u5916 \u5947\u6570\uff1a\u5185 \u5947\u5f02\u60c5\u51b5 \u5c04\u7ebf\u5728\u8fb9\u4e0a\uff1a\u65e0\u6570\u4e2a\u70b9 ---\u5224\u65ad\u5c04\u7ebf\u662f\u5426\u4e0e\u8fb9\u540c\u7ebf \u4ea4\u70b9\u4e3a\u9876\u70b9\uff1a\u5f02\u4fa7\uff1a1\u4e2a\u3001\u540c\u4fa7\uff1a0\u62162\u4e2a \u626b\u63cf\u7ebf\u7b97\u6cd5 \u76ee\u6807\uff1a\u5229\u7528\u76f8\u90bb\u50cf\u7d20\u4e4b\u95f4\u7684\u8fde\u8d2f\u6027\uff0c\u63d0\u9ad8\u7b97\u6cd5\u6548\u7387 \u5904\u7406\u5bf9\u8c61\uff1a\u7b80\u5355\u591a\u8fb9\u5f62 \u975e\u81ea\u4ea4\u591a\u8fb9\u5f62 \uff08\u8fb9\u4e0e\u8fb9\u4e4b\u95f4\u9664\u4e86\u9876\u70b9\u5916\u65e0\u5176\u5b83\u4ea4\u70b9\uff09 \u6b65\u9aa4\uff08\u5bf9\u4e8e\u6bcf\u4e00\u6761\u626b\u63cf\u7ebf\uff09 \u8ba1\u7b97\u626b\u63cf\u7ebf\u4e0e\u8fb9\u7684\u4ea4\u70b9 \u4ea4\u70b9\u6309x\u5750\u6807\u4ece\u5c0f\u5230\u5927\u6392\u5e8f \u4ea4\u70b9\u4e24\u4e24\u914d\u5bf9\uff0c\u586b\u5145\u533a\u95f4 \u57fa\u672c\u65b9\u6cd5 \u5c06\u6574\u4e2a\u7ed8\u56fe\u7a97\u53e3\u5185\u626b\u63cf\u591a\u8fb9\u5f62\u7684\u95ee\u9898\u5206\u89e3\u4e3a\u4e00\u6761\u6761\u626b\u63cf\u7ebf\u8ba1\u7b97\u4e0e\u591a\u8fb9\u5f62\u7684\u76f8\u4ea4\u533a\u95f4\uff0c\u53ea\u8981\u5b8c\u6210\u6bcf\u6761\u626b\u63cf\u7ebf\u7684\u751f\u6210\u5c31\u5b9e\u73b0\u4e86\u591a\u8fb9\u5f62\u7684\u626b\u63cf\u8f6c\u6362 \u4e00\u6761\u626b\u63cf\u7ebf\u4e0e\u591a\u8fb9\u5f62\u7684\u8fb9\u6709\u5076\u6570\u4e2a\u4ea4\u70b9\uff0c\u6bcf2\u4e2a\u70b9\u5f62\u6210\u4e00\u533a\u95f4\uff0c\u533a\u95f4\u5185\u7684\u50cf\u7d20\u4f4d\u4e8e\u591a\u8fb9\u5f62\u5185 \u8fde\u8d2f\u6027(Coherence) \u8fb9\u7684\u8fde\u8d2f\u6027(Edge Coherence)\u2014\u4f18\u5316\u4ea4\u70b9\u8ba1\u7b97 \u67d0\u6761\u8fb9\u4e0e\u5f53\u524d\u626b\u63cf\u7ebf\u76f8\u4ea4\uff0c\u4e5f\u53ef\u80fd\u4e0e\u4e0b\u4e00\u6761\u626b\u63cf\u7ebf\u76f8\u4ea4 \u626b\u63cf\u7ebf\u7684\u8fde\u8d2f\u6027(Scan-line Coherence) )\u2014\u4f18\u5316\u4ea4\u70b9\u6392\u5e8f \u5f53\u524d\u626b\u63cf\u7ebf\u4e0e\u5404\u8fb9\u7684\u4ea4\u70b9\u987a\u5e8f\u4e0e \u4e0b\u4e00\u6761\u626b\u63cf\u7ebf\u4e0e\u5404\u8fb9\u7684\u4ea4\u70b9\u987a\u5e8f\u53ef\u80fd\u76f8\u540c\u6216\u7c7b\u4f3c \u533a\u95f4\u7684\u8fde\u8d2f\u6027(Span Coherence) \u540c\u4e00\u533a\u95f4\u4e0a\u7684\u50cf\u7d20\u53d6\u540c\u4e00\u989c\u8272\u5c5e\u6027 \u4ea4\u70b9 \u7b2c\u4e00\u7c7b\u4ea4\u70b9\uff1a\u4f4d\u4e8e\u540c\u4e00\u6761\u8fb9\u4e0a\u7684\u540e\u7ee7\u4ea4\u70b9\uff0c\u7531\u626b\u63cf\u7ebfy\uff1de\u4e0e\u591a\u8fb9\u5f62\u7684\u4ea4\u70b9\u9012\u63a8\u8ba1\u7b97\u626b\u63cf\u7ebf y\uff1de\uff0b1\u7684\u4ea4\u70b9\uff0cx\u2019\uff1dx\uff0b1/m \u7b2c\u4e8c\u7c7b\u4ea4\u70b9\uff1a\u8fb9\u4e0e\u626b\u63cf\u7ebf\u7684\u7b2c\u4e00\u4e2a\u4ea4\u70b9\uff0c\u8fb9\u7684\u4e0b\u7aef\u70b9\u5373\u4e3a\u4ea4\u70b9\u3002 \u4ea4\u70b9\u53d6\u6574\u89c4\u5219 \u4f7f\u751f\u6210\u7684\u50cf\u7d20\u5168\u90e8\u4f4d\u4e8e\u591a\u8fb9\u5f62\u4e4b\u5185\uff0c\u4e14\u6ee1\u8db3\u5171\u4eab\u8fb9\u754c\u539f\u5219\u3002 \uff081\uff09\u4ea4\u70b9\u5750\u6807\u4e0d\u80fd\u91c7\u7528\u201c\u56db\u820d\u4e94\u5165\u201d\u539f\u5219\uff0c\u5426\u5219\u4f1a\u5bfc\u81f4\u90e8\u5206\u50cf\u7d20\u4f4d\u4e8e\u591a\u8fb9\u5f62\u4e4b\u5916 \uff082\uff09\u5171\u4eab\u8fb9\u754c\u539f\u5219\uff1a\u5de6\u95ed\u53f3\u5f00\uff0c\u4e0b\u95ed\u4e0a\u5f00 \u4ea4\u70b9\u6a2a\u5750\u6807x\u4e3a\u5c0f\u6570\uff0c\u5373\u4ea4\u70b9\u843d\u4e8e\u626b\u63cf\u7ebf\u4e0a\u4e24\u4e2a\u76f8\u90bb\u50cf\u7d20\u4e4b\u95f4 \uff08a\uff09\u4ea4\u70b9\u4f4d\u4e8e\u5de6\u8fb9\u4e0a\uff0c\u5411\u53f3\u53d6\u6574\uff0c(int)x + 1 \uff08b\uff09\u4ea4\u70b9\u4f4d\u4e8e\u53f3\u8fb9\u4e0a\uff0c\u5411\u5de6\u53d6\u6574\uff0c(int)x \u4ea4\u70b9\u6a2a\u5750\u6807x\u4e3a\u6574\u6570\uff0c\u843d\u5728\u53f3\u3001\u4e0a\u8fb9\u754c\u7684\u50cf\u7d20\u4e0d\u4e88\u586b\u5145\u3002\u843d\u5728\u5de6\u3001\u4e0b\u8fb9\u754c\u7684\u50cf\u7d20\u9700\u8981\u586b\u5145\u3002 \u4ea4\u70b9\u662f\u9876\u70b9\uff0c\u626b\u63cf\u7ebf\u4e0e\u591a\u8fb9\u5f62\u7684\u9876\u70b9\u76f8\u4ea4\u65f6\uff0c\u91c7\u7528\u4e0a\u5f00\u4e0b\u95ed\u53ca\u53f3\u5f00\u5de6\u95ed\u53d6\u4ea4\u70b9\uff0c\u4fdd\u8bc1\u4ea4\u70b9\u6b63\u786e\u914d\u5bf9\u3002 \u68c0\u67e5\u4e24\u76f8\u90bb\u8fb9\u5728\u626b\u63cf\u7ebf\u7684\u54ea\u4e00\u4fa7\u3002\u53ea\u8981\u68c0\u67e5\u76f8\u4ea4\u7684\u4e24\u6761\u8fb9\u7684\u53e6\u5916\u4e24\u4e2a\u7aef\u70b9\u7684Y\u503c\uff0c\u4e24\u4e2a\u7aef\u70b9Y\u4e2d\u503c\u5927\u4e8e\u4ea4\u70b9Y\u503c\u7684\u4e2a\u6570\u662f0\uff0c1\uff0c2\uff0c\u6765\u51b3\u5b9a\u53d60\uff0c1\uff0c2\u4e2a\u4ea4\u70b9\u3002 \u5206\u522b\u5bf9\u5e94\u4ea4\u70b9\u4e2a\u6570\u4e3a1\u4e2a\u30011\u4e2a\u30012\u4e2a\u548c0\u4e2a\u3002 \u6c34\u5e73\u8fb9\uff0c\u4e0d\u53c2\u4e0e\u8ba1\u7b97\u4ea4\u70b9 \u6392\u5e8f\uff0c\u5229\u7528\u626b\u63cf\u7ebf\u8fde\u8d2f\u6027\uff0c\u91c7\u7528\u63d2\u5165\u6392\u5e8f\u3002 \u4ea4\u70b9\u4e24\u4e24\u914d\u5bf9\u4e0e\u533a\u95f4\u7ed8\u5236\uff0c\u533a\u95f4\u8fde\u7eed\u6027\uff0c\u8fde\u7eed\u7ed8\u5236\u533a\u95f4\u4e0a\u7684\u50cf\u7d20\u3002 \u7b97\u6cd5\u5b9e\u73b0 \u8fb9\u7684\u5206\u7c7b\u8868ET \uff08Edge Table\uff09\uff08\u53c8\u79f0\u65b0\u8fb9\u8868NET\uff09 \u6309\u7167\u8fb9\u7684\u4e0b\u7aef\u70b9 y \u5750\u6807\uff0c\u5bf9\u975e\u6c34\u5e73\u8fb9\u8fdb\u884c\u5206\u7c7b\u7684\u94fe\u8868 \u4e0b\u7aef\u70b9 y \u5750\u6807\u503c\u7b49\u4e8ei \u7684\u8fb9\u5c5e\u4e8e\u7b2ci\u7c7b\uff0c\u540c\u7c7b\u4e2d\u6709\u591a\u6761\u8fb9\u65f6\u6309x\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff08x\u4e5f\u4e00\u6837\u65f6\u6309\u8fb9\u4e0a\u7aef\u70b9\u7684x\u503c\uff09 \u4f5c\u7528\uff1a\u907f\u514d\u76f2\u76ee\u6c42\u4ea4\uff1b\u8ba1\u7b97\u7b2c\u4e8c\u7c7b\u4ea4\u70b9\u5750\u6807 ET\u7684\u7ed3\u70b9\u4fe1\u606f\uff1a ymax: \u8fb9\u7684\u4e0a\u7aef\u70b9\u7684 y \u5750\u6807\u503c x\uff1a\u8fb9\u7684\u4e0b\u7aef\u70b9\u7684 x \u5750\u6807 deltax\uff1a\u8fb9\u7684\u659c\u7387\u7684\u5012\u6570 nextEdge: \u4e0b\u4e00\u6761\u8fb9\u7684\u6307\u9488 \u5f53\u626b\u63cf\u7ebf y = e + 1 == ymax\uff0c\u8bf4\u660e\u4e0b\u4e00\u6761\u626b\u63cf\u7ebf\u4e0e\u6b64\u8fb9\u4e0d\u76f8\u4ea4\u3002 \u6d3b\u6027\u8fb9\u8868AEL(Active Edge List) \u5b58\u653e\u6d3b\u6027\u8fb9\u7684\u987a\u5e8f\u94fe\u8868\uff0c\u4e14\u6309\u4ea4\u70b9 x \u7684\u503c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f \u6d3b\u6027\u8fb9\uff1a\u4e0e\u5f53\u524d\u626b\u63cf\u7ebf\u76f8\u4ea4\u7684\u8fb9 \u8fb9\u7ed3\u6784\u5b9a\u4e49\uff1a\u4e0eET\u8868\u4e2d\u7ed3\u70b9\u7ed3\u6784\u76f8\u540c\u3002 typedef struct { int ymax ; float x , deltax ; Edge * nextEdge ; } Edge ; AEL \u7684\u7ed3\u70b9\u4fe1\u606f\uff1a ymax: \u6240\u4ea4\u8fb9\u7684\u6700\u5927 y \u503c x\uff1a\u5f53\u524d\u626b\u63cf\u7ebf\u4e0e\u8fb9\u7684\u4ea4\u70b9\u7684x\u5750\u6807 deltax\uff1a\u8fb9\u7684\u659c\u7387\u7684\u5012\u6570 nextEdge: \u4e0b\u4e00\u6761\u8fb9\u7684\u6307\u9488 \u4f5c\u7528\uff1a\u5b58\u50a8\u4e0e\u5f53\u524d\u626b\u63cf\u7ebf\u7684\u4ea4\u70b9\uff0c\u540c\u65f6\u5feb\u901f\u8ba1\u7b97\u4e0b\u4e00\u6761\u626b\u63cf\u7ebf\u4e0e\u591a\u8fb9\u5f62\u76f8\u4ea4\u7684\u70b9\uff0c\u4e14\u53ef\u5224\u65ad\u8fb9\u662f\u5426\u4e0e\u4e0b\u4e00\u6761\u626b\u63cf\u7ebf\u76f8\u4ea4 \u79cd\u5b50\u586b\u5145\u7b97\u6cd5 \u533a\u57df\uff1a\u70b9\u9635\u8868\u793a\u7684\u56fe\u5f62\uff0c\u50cf\u7d20\u96c6\u5408 \u8868\u793a\u65b9\u6cd5\uff1a\u5185\u70b9\u8868\u793a\u3001\u8fb9\u754c\u8868\u793a \u5185\u70b9\u8868\u793a \u679a\u4e3e\u51fa\u533a\u57df\u5185\u90e8\u7684\u6240\u6709\u50cf\u7d20\u3001\u5185\u90e8\u7684\u6240\u6709\u50cf\u7d20\u4e3a\u540c\u4e00\u4e2a\u989c\u8272\u3001\u8fb9\u754c\u50cf\u7d20\u4e0e\u5185\u90e8\u50cf\u7d20\u7684\u989c\u8272\u4e0d\u540c \u8fb9\u754c\u8868\u793a \u679a\u4e3e\u51fa\u8fb9\u754c\u4e0a\u6240\u6709\u7684\u50cf\u7d20\u3001\u8fb9\u754c\u4e0a\u7684\u6240\u6709\u50cf\u7d20\u4e3a\u540c\u4e00\u989c\u8272\u3001\u5185\u90e8\u50cf\u7d20\u4e0e\u8fb9\u754c\u50cf\u7d20\u7684\u989c\u8272\u4e0d\u540c \u533a\u57df\u586b\u5145\u7b97\u6cd5\u8981\u6c42\u533a\u57df\u662f\u8fde\u901a\u7684\u3002 \u8fde\u901a\u6027 \uff081\uff094\u8fde\u901a\u533a\u57df\uff1a\u533a\u57df\u4e2d\u4efb\u610f\u6ee1\u8db3\u76f8\u4f3c\u6761\u4ef6\u4e24\u70b9\uff08\u50cf\u7d20\uff09\u53ef\u901a\u8fc7\u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u65b9\u5411\u4e92\u76f8\u5230\u8fbe \uff082\uff098\u8fde\u901a\u533a\u57df\uff1a\u533a\u57df\u4e2d\u4efb\u610f\u6ee1\u8db3\u76f8\u4f3c\u6761\u4ef6\u4e24\u70b9\uff08\u50cf\u7d20\uff09\u53ef\u901a\u8fc7\u4e0a\u4e0b\u5de6\u53f3\u548c\u5bf9\u89d2\u7ebf\u516b \u4e2a\u65b9\u5411\u4e92\u76f8\u5230\u8fbe 4\u8fde\u901a\u533a\u57df\uff0c\u8fb9\u754c\u53ea\u89818\u8fde\u901a\u5373\u53ef\uff0c8\u8fde\u901a\u533a\u57df\uff0c\u8fb9\u754c\u5fc5\u987b\u662f4\u8fde\u901a\u3002 \u7b97\u6cd5\u5b9e\u73b0\uff1a \uff081\uff09\u5185\u70b9\u8868\u793a\u76844\u8fde\u901a\u533a\u57df \u79cd\u5b50s(x,y)\uff0c\u539f\u8272oldColor\uff0c\u65b0\u989c\u8272newColor \u65b9\u6cd5\uff1a\u5148\u5224\u65ads(x, y)\u7684\u989c\u8272\uff0c\u82e5\u5176\u503c\u4e0d\u7b49\u4e8eoldColor\uff0c\u8bf4\u660e\u8be5\u50cf\u7d20\u4f4d\u4e8e\u533a\u57df\u5916\u6216\u5df2\u8bbe\u7f6e\u4e3a\u586b\u5145\u8272newColor \u7b97\u6cd5\u7ed3\u675f\uff1b \u5426\u5219\uff0c\u7f6e\u50cf\u7d20\u989c\u8272\u4e3anewColor\uff0c\u518d\u5bf9\u5176\u76f8\u90bb\u7684\u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u50cf\u7d20\u5206\u522b\u4f5c\u4e3a\u79cd\u5b50\u4f5c\u4e0a\u8ff0\u9012\u5f52\u5904\u7406\u3002 \u591a\u8fb9\u5f62\u626b\u63cf\u8f6c\u6362\u4e0e\u533a\u57df\u586b\u5145\u65b9\u6cd5\u6bd4\u8f83 \u57fa\u672c\u601d\u60f3\u4e0d\u540c \u524d\u8005\uff1a\u9876\u70b9\u8868\u793a\u8f6c\u6362\u6210\u70b9\u9635\u8868\u793a \u540e\u8005\uff1a\u53ea\u6539\u53d8\u533a\u57df\u5185\u586b\u5145\u989c\u8272\uff0c\u6ca1\u6709\u6539\u53d8\u8868\u793a\u65b9\u6cd5 \u5bf9\u8fb9\u754c\u7684\u8981\u6c42\u4e0d\u540c \u524d\u8005\uff1a\u626b\u63cf\u7ebf\u4e0e\u591a\u8fb9\u5f62\u8fb9\u754c\u4ea4\u70b9\u4e2a\u6570\u4e3a\u5076\u6570 \u540e\u8005\uff1a\u533a\u57df\u5c01\u95ed\uff0c\u9632\u6b62\u9012\u5f52\u586b\u5145\u8de8\u754c \u57fa\u672c\u7684\u6761\u4ef6\u4e0d\u540c \u524d\u8005\uff1a\u4ece\u8fb9\u754c\u9876\u70b9\u4fe1\u606f\u51fa\u53d1 \u540e\u8005\uff1a\u4ece\u533a\u57df\u5185\u79cd\u5b50\u70b9\u51fa\u53d1 \u533a\u57df\u56fe\u50cf\u586b\u5145 \u5b57\u7b26\u7684\u751f\u6210 \u70b9\u9635\u5b57\u4f53 \u5b58\u50a8\uff1a\uff08\u538b\u7f29\u4e0e\u975e\u538b\u7f29\uff09 \u663e\u793a\uff1a\u6839\u636e\u7f16\u7801\u68c0\u7d22\u70b9\u9635\u6570\u636e\uff0c\u63a5\u7740\u5199\u5e27\u7f13\u5b58 \u77e2\u91cf\u5b57\u4f53 \u8868\u793a\uff1a\u7b14\u753b\u7528\u66f2\u7ebf\uff08\u53c2\u6570\uff09\u8868\u793a \u626b\u63cf\u8f6c\u6362\uff1a\u53c2\u6570\u5230\u70b9\u9635 \u663e\u793a\uff1a1\u3001\u7531\u7f16\u7801\u68c0\u7d22\uff1b2\u3001\u626b\u63cf\u8f6c\u6362\uff1b3\u3001\u5199\u5e27\u7f13\u5b58 \u5b58\u50a8\uff1a\u7a7a\u95f4\u5c11 OpenGL\u76f8\u5173\u51fd\u6570 //\u56fe\u5143\u7ed8\u5236 glBegin ( type ); glVertex * (); //\u6307\u5b9a\u9876\u70b9\u5750\u68071 glVertex * (); //\u6307\u5b9a\u9876\u70b9\u5750\u68072 glEnd () \uff1b //\u70b9\u7684\u5c5e\u6027 glEnable ( GL_LINE_STIPPLE ); ( 1 ) glColor ( 3 | 4 )( b | d | f | i | s | ub | ui | us )( TYPE r , TYPE g , TYPE b ) ( 2 ) glColor ( 3 | 4 )( b | d | f | i | s | ub | ui | us ) v ( TYPE * rgb ) glPointSize \uff08 GLfloat size ) //\u70b9\u5927\u5c0f //\u753b\u7ebf glBegin\u4e2d\u7684\u53c2\u6570\u4e3a \uff1a GL_LINES \u3001 GL_LINE_STRIP \u3001 GL_LINE_LOOP GL_LINES \uff1a \u4e00\u7ec4\u76f4\u7ebf\u6bb5 \uff1b GL_LINE_STRIP \uff1a \u6298\u7ebf GL_LINE_LOOP \uff1a \u5c01\u95ed\u6298\u7ebf //\u7ebf\u7684\u5c5e\u6027 glLineWidth \uff08 GLfloat width ) //\u5bbd\u5ea6 glLineStipple ( GLint factor , GLushort pattern ); //\u7ebf\u5f62 glEnable ( GL_LINE_STIPPLE ); //\u4f7f\u7528\u524d\u9700\u8981\u6fc0\u6d3b //\u586b\u5145\u56fe\u5143\u51fd\u6570 glRect [ i | s | f | d ]{ v }() //\u77e9\u5f62\u51fd\u6570 glBegin () \u4e2d\u7684\u53c2\u6570GL_POLYGON \u3001 GL_TRIANGLES \u3001 GL_TRIANGLE_STRIP \u3001 GL_TRIANGLE_FAN //\u7ebf\u6846\u56fe\u4e0e\u586b\u5145\u56fe glPloygonMode ( face \uff0c displayMode ) //face\uff1a\u6307\u5b9a\u524d\u540e\u9762\u3002\u53ef\u9009\u503c\uff1aGL_FRONT\u3001GL_BACK\u548cGL_FRONT_AND_BACK\u3010\u6b63\u53cd\u9762\u4e00\u6837\u5904\u7406\u3011 //displayMode\uff1aGL_FILL\uff08\u586b\u5145\uff09\u548cGL_LINE\uff08\u7ebf\u6846\uff09 //\u989c\u8272\u63d2\u503c\u6a21\u5f0f \u51fd\u6570 \uff1a glShadeModel ( mode ) Mode : GL_FLAT\u548cGL_SMOOTH \u56fe\u5143\u7ed8\u5236 \u56fe\u5143\u7c7b\u578b \u7c7b\u578b \u8bf4\u660e GL_POINTS \u5355\u4e2a\u9876\u70b9\u96c6 GL_LINES \u591a\u7ec4\u53cc\u9876\u70b9\u7ebf\u6bb5 GL_POLYGON \u5355\u4e2a\u7b80\u5355\u586b\u5145\u51f8\u591a\u8fb9\u5f62 GL_TRIANGLES \u591a\u7ec4\u72ec\u7acb\u586b\u5145\u4e09\u89d2\u5f62 GL_QUADS \u591a\u7ec4\u72ec\u7acb\u586b\u5145\u56db\u8fb9\u5f62 GL_LINE_STRIP \u4e0d\u95ed\u5408\u6298\u7ebf GL_LINE_LOOP \u95ed\u5408\u6298\u7ebf GL_TRIANGLE_STRIP \u7ebf\u578b\u8fde\u7eed\u586b\u5145\u4e09\u89d2\u5f62\u4e32 GL_TRIANGLE_FAN \u6247\u5f62\u8fde\u7eed\u586b\u5145\u4e09\u89d2\u5f62\u4e32 GL_QUAD_STRIP \u8fde\u7eed\u586b\u5145\u56db\u8fb9\u5f62\u4e32 \u7b2c\u56db\u7ae0 \u51e0\u4f55\u53d8\u6362 \u00b6 \u9f50\u6b21\u5750\u6807 \u5b9a\u4e49 \u5b9a\u4e49\uff1a(x\uff0cy)\u70b9\u5bf9\u5e94\u7684\u9f50\u6b21\u5750\u6807\u5b9a\u4e49\u4e3a (x_h,y_h,h),x_h=h*x,y_h=y*h,z_h=h (x_h,y_h,h),x_h=h*x,y_h=y*h,z_h=h \u6807\u51c6\u5176\u6b21\u5750\u6807\uff1a (x,y,1) (x,y,1) h\uff1d0\u8868\u793a\u65e0\u7a77\u8fdc\u70b9 \u4e8c\u7ef4\u53d8\u6362 \u4e8c\u7ef4\u53d8\u6362\u7684\u77e9\u9635\u8868\u793a \u5e73\u79fb\u53d8\u6362 \u65cb\u8f6c\u53d8\u6362 \u7ed5\u5750\u6807\u539f\u70b9\uff08\u79f0\u4e3a\u53c2\u7167\u70b9\uff0c\u57fa\u51c6\u70b9\uff09\u65cb\u8f6c\u89d2\u5ea6\u03b8 \uff08\u9006\u65f6\u9488\u4e3a\u6b63\uff0c\u987a\u65f6\u9488\u4e3a\u8d1f\uff09 \u653e\u7f29\u53d8\u6362 \u53c2\u7167\u70b9\u4e3a\u5750\u6807\u539f\u70b9 \u53d8\u6362\u5177\u6709\u7edf\u4e00\u8868\u793a\u5f62\u5f0f\u7684\u4f18\u70b9 1. \u4fbf\u4e8e\u53d8\u6362\u5408\u6210 \u8fde\u7eed\u53d8\u6362\u65f6\uff0c\u53ef\u4ee5\u5148\u5f97\u5230\u53d8\u6362\u7684\u77e9\u9635 2. \u4fbf\u4e8e\u786c\u4ef6\u5b9e\u73b0 \u53ea\u9700\u5b9e\u73b0\u77e9\u9635\u4e58\u6cd5 \u53d8\u6362\u7684\u6027\u8d28 \u5e73\u79fb\u548c\u65cb\u8f6c\u53d8\u6362\u5177\u6709\u53ef\u52a0\u6027 \u653e\u7f29\u53d8\u6362\u5177\u6709\u53ef\u4e58\u6027 \u53d8\u6362\u5408\u6210 \u65b9\u6cd5\uff1a\u8fde\u7eed\u53d8\u6362\u65f6\uff0c\u5148\u8ba1\u7b97\u53d8\u6362\u77e9\u9635\uff0c\u518d\u8ba1\u7b97\u5750\u6807 \u4f18\u70b9\uff1a\u63d0\u9ad8\u4e86\u5bf9\u56fe\u5f62\u4f9d\u6b21\u8ba1\u7b97\u591a\u6b21\u53d8\u6362\u7684\u8fd0\u7b97\u6548\u7387\u3001\u63d0\u4f9b\u8ba1\u7b97\u590d\u6742\u53d8\u6362\u7684\u65b9\u6cd5 \u590d\u5408\u53d8\u6362 \u77e9\u9635\u4e58\u6cd5 \u5148\u4f5c\u7528\u7684\u653e\u5728\u53d8\u6362\u77e9\u9635\u8fde\u4e58\u5f0f\u7684\u53f3\u7aef\uff0c\u540e\u4f5c\u7528\u7684\u653e\u5728\u8fde\u4e58\u5f0f\u7684\u5de6\u7aef p\u2018=M_n*...*M_2*M_1 p\u2018=M_n*...*M_2*M_1 \u5bf9\u79f0\u53d8\u6362 \u4eff\u5c04\u53d8\u6362 \u4e8c\u7ef4\u7ebf\u6027\u53d8\u6362\u7684\u4e00\u822c\u5f62\u5f0f \u5e73\u79fb\uff0c\u65cb\u8f6c\uff0c\u653e\u7f29\uff0c\u5bf9\u79f0\u548c\u9519\u5207\u662f\u7279\u4f8b \u4fdd\u6301\u5e73\u884c\u7ebf\u95f4\u7684\u5e73\u884c\u5173\u7cfb \u4e09\u7ef4\u51e0\u4f55\u53d8\u6362 \u4e09\u7ef4\u9f50\u6b21\u5750\u6807 (x, y, z)\u70b9\u5bf9\u5e94\u7684\u9f50\u6b21\u5750\u6807\u4e3a (x_h,y_h,z_h,h) (x_h,y_h,z_h,h) \uff0c\u6807\u51c6\u9f50\u6b21\u5750\u6807 (x,y,z,1) (x,y,z,1) \u53f3\u624b\u5750\u6807\u7cfb \u65cb\u8f6c\u65b9\u5411\uff0c\u5f53\u62c7\u6307\u4e0e\u5750\u6807\u8f74\u540c\u5411\u65f6\uff0c\u56db\u6307\u6240\u6307\u65b9\u5411\u4e3a\u7ed5\u8be5\u8f74\u7684\u6b63\u65cb\u8f6c\u65b9\u5411\u3002 \u5e73\u79fb\u53d8\u6362 \u653e\u7f29\u53d8\u6362 \u53c2\u7167\u70b9\u4e3a\u5750\u6807\u539f\u70b9 \u65cb\u8f6c\u53d8\u6362 3. \u7ed5Z\u8f74 <img src=\"https://pic.tim-wcx.ltd//img/20211208224303.png\" alt=\"image-20211208224303864\" style=\"zoom:67%;\" /> \u5bf9\u79f0\u53d8\u6362 \u5173\u4e8e\u5750\u6807\u5e73\u9762 xy \u7684\u5bf9\u79f0\u53d8\u6362 \u4e09\u7ef4\u51e0\u4f55\u53d8\u6362\u7684\u4e00\u822c\u5f62\u5f0f \uff081\uff09\u524d\u4e09\u884c\u548c\u524d\u4e09\u5217\u5bf9\u5e94\u65cb\u8f6c\u548c\u653e\u7f29\u53d8\u6362 \uff082\uff09\u7b2c\u56db\u5217\u7684\u524d\u4e09\u4e2a\u5143\u7d20\u5bf9\u5e94\u5e73\u79fb\u53d8\u6362 \uff083\uff09\u7b2c\u56db\u884c\u524d\u4e09\u4e2a\u5143\u7d20\u5bf9\u5e94\u6295\u5f71\u53d8\u6362 \u56fe\u5f62\u5bf9\u8c61\u7684\u51e0\u4f55\u53d8\u6362 \u56fe\u5f62\u5bf9\u8c61 \u70b9\uff0c\u7ebf\u6bb5\uff0c\u591a\u8fb9\u5f62\uff0c\u5706\uff0c\u5b57\u7b26 \u65b9\u6cd5 \u5148\u751f\u6210\u70b9\u96c6\uff0c\u518d\u5bf9\u5176\u4e2d\u7684\u70b9\u8fdb\u884c\u53d8\u6362 \u8fd0\u7b97\u91cf\u5927\uff0c\u53d8\u6362\u524d\u540e\u5b58\u5728\u70b9\u96c6\u4e0d\u4e00\u81f4\u60c5\u51b5 \u5bf9\u51e0\u4f55\u53c2\u6570\u53d8\u6362 \u57fa\u672c\u56fe\u5f62\uff1a\u7ebf\u6bb5\uff0c\u4e24\u4e2a\u7aef\u70b9\uff1b\u591a\u8fb9\u5f62\uff0c\u591a\u4e2a\u9876\u70b9\uff1b\u5706\uff0c\u5706\u5fc3\u548c\u534a\u5f84\uff08\u653e\u7f29\u53d8\u6362\u8981\u6c42 x \u548c y \u653e\u7f29\u500d\u6570\u76f8\u540c\uff09 \u524d\u63d0\uff1a\u56fe\u5f62\u5bf9\u8c61\u7684\u51e0\u4f55\u6027\u8d28\u4e0d\u968f\u5750\u6807\u53d8\u6362\u800c\u53d1\u751f\u53d8\u5316\u3002\u8fd9\u79cd\u6027\u8d28\u79f0\u4e3a\u4eff\u5c04\u4e0d\u53d8\u6027\u3002 OpenGL\u51e0\u4f55\u53d8\u6362\u51fd\u6570 glTranslate{fd}(tx, ty, tz) //\u5e73\u79fb\u51fd\u6570 glRotate{fd}(theta, vx, vy, vz) //\u65cb\u8f6c\u51fd\u6570 glScale{fd}(sx, sy, sz) //\u653e\u7f29\u51fd\u6570 glLoadIdentity() //\u91cd\u7f6e\u4e3a\u5355\u4f4d\u77e9\u9635 glMatrixMode(GL_MODELVIEW) //\u6a21\u578b\u89c2\u5bdf\u77e9\u9635 glPushMatrix() //\u538b\u6808 glPopMatrix() //\u51fa\u6808 glutInitDisplayMode (GLUT_SINGLE|GLUT_RGBA); //\u5355\u7f13\u51b2 glutInitDisplayMode (GLUT_DOUBLE|GLUT_RGBA); //\u53cc\u7f13\u51b2 glFinish();//\u5f3a\u5236\u4e4b\u524d\u7684\u7ed8\u56fe\u51fd\u6570\u6267\u884c\uff0c\u53cc\u7f13\u51b2\u53ef\u4e0d\u8c03\u7528 glutSwapBuffers(); //\u53cc\u7f13\u51b2\u5fc5\u987b\u8c03\u7528 \u6ce8\u610f\uff1a (1)\u7cfb\u7edf\u51e0\u4f55\u53d8\u6362\u77e9\u9635\u53ea\u67091\u4e2a (2)\u5750\u6807\u91c7\u7528\u5217\u5411\u91cf\u8868\u793a (3)\u65cb\u8f6c\u89d2\u5927\u5c0f\u7528\u5ea6\u8868\u793a\uff0c\u4e0d\u662f\u5f27\u5ea6 (4)\u7ed8\u56fe\u65f6\uff0c\u7528\u7cfb\u7edf\u7684\u51e0\u4f55\u53d8\u6362\u77e9\u9635\u4e0e\u9876\u70b9\u5750\u6807\u76f8\u4e58\u5f97\u5230\u5750\u6807\u8fdb\u884c\u7ed8\u56fe (5) \u53ea\u9700\u8981\u8fde\u7eed\u8c03\u7528\u53d8\u6362\u51fd\u6570\uff0c\u5148\u53d8\u6362\u7684\u51fd\u6570\u540e\u8c03\u7528\uff0c\u6700\u540e\u7ed8\u5236\u8be5\u56fe\u5f62\u3002 \u7b2c\u4e94\u7ae0 \u4e8c\u7ef4\u56fe\u5f62\u7684\u663e\u793a \u00b6 \u4e8c\u7ef4\u663e\u793a\u6d41\u6c34\u7ebf \u57fa\u672c\u6982\u5ff5 \u88c1\u526a\u7a97\u53e3(Clipping Window) \uff1a\u9700\u8981\u663e\u793a\u7684\u573a\u666f\u533a\u57df \u53c8\u79f0\u4e3a\u4e16\u754c\u7a97\u53e3\u6216\u89c2\u5bdf\u7a97\u53e3\uff0c\u7b80\u79f0\u7a97\u53e3 \u5728\u4e16\u754c\u5750\u6807\u7cfb\uff08\u53c8\u79f0\u7528\u6237\u5750\u6807\u7cfb\uff09\u5185\u5b9a\u4e49 \u89c6\u53e3(Viewport)\uff1a\u6307\u663e\u793a\u8bbe\u5907\u4e0a\u7528\u6765\u663e\u793a\u56fe\u5f62\u7684\u533a\u57df \u53c8\u79f0\u89c6\u533a\uff0c\u5728\u8bbe\u5907\uff08\u5c4f\u5e55\uff09\u5750\u6807\u7cfb\u5185\u5b9a\u4e49 \u88c1\u526a(Clip)\uff1a\u4ece\u573a\u666f\u4e2d\u786e\u5b9a\u4f4d\u4e8e\u7a97\u53e3\u5185\u7684\u56fe\u5f62 \u88c1\u526a\u7a97\u53e3\u548c\u89c6\u533a\u7684\u5173\u7cfb \u6539\u53d8\u89c6\u53e3\u4f4d\u7f6e\u53ef\u4ee5\u5728\u8f93\u51fa\u8bbe\u5907\u7684\u4e0d\u540c\u4f4d\u7f6e\u4e0a\u89c2\u5bdf\u7269\u4f53 \u4f7f\u7528\u591a\u4e2a\u89c6\u53e3\u53ef\u4ee5\u5728\u5c4f\u5e55\u4e0d\u540c\u7684\u4f4d\u7f6e\u89c2\u5bdf\u573a\u666f\u7684\u4e0d\u540c\u90e8\u5206 \u6539\u53d8\u7a97\u53e3\u7684\u5c3a\u5bf8\u8fbe\u5230\u6539\u53d8\u89c6\u53e3\u5185\u663e\u793a\u5bf9\u8c61\u7684\u591a\u5c11 \u6539\u53d8\u89c6\u53e3\uff08\u6216\u7a97\u53e3\uff09\u7684\u5c3a\u5bf8\u5b9e\u73b0\u56fe\u5f62\u5bf9\u8c61\u653e\u7f29 \u4e8c\u7ef4\u663e\u793a\u53d8\u6362 \u4e8c\u7ef4\u56fe\u5f62\u7684\u4e16\u754c\u5750\u6807\u7cfb\u5230\u8bbe\u5907\u5750\u6807\u7cfb\u7684\u6620\u5c04 \u53c8\u79f0\u4e3a\u7a97\u53e3\u5230\u89c6\u533a\u7684\u53d8\u6362\u6216\u7a97\u53e3\u53d8\u6362 \u4e8c\u7ef4\u56fe\u5f62\u7684\u663e\u793a\u6d41\u6c34\u7ebf \u7a97\u53e3\u5230\u89c6\u533a\u7684\u53d8\u6362 \u6b65\u9aa4 \u5728\u4e16\u754c\u5750\u6807\u7cfb\u4e2d\uff0c\u5e73\u79fb\u7a97\u53e3\u4f7f(xmin, ymin)\u81f3\u5750\u6807\u539f\u70b9\uff0c\u53d8\u6362\u4e3aT (\uff0dxmin, \uff0dymin) \u653e\u7f29\u4f7f\u7a97\u53e3\u7684\u5927\u5c0f\u4e0e\u89c6\u533a\u76f8\u7b49\uff0c\u53d8\u6362\u4e3aS(Eu/Ex, Ev/Ey) \u5728\u8bbe\u5907\u5750\u6807\u7cfb\u4e2d\uff0c\u5e73\u79fb\u4f7f\u7a97\u53e3\u4e0e\u89c6\u533a\u91cd\u5408\uff0c\u53d8\u6362\u4e3aT (umin, vmin) OpenGL\u89c6\u533a\u51fd\u6570 glViewport(xvmin,yvmin,vpwidth,vpheight); GLU\u88c1\u526a\u7a97\u53e3\u51fd\u6570 gluOrtho2D(left,right,bottom,top); \u529f\u80fd\uff1a\u5c06\u56fe\u5f62\u6570\u636e\u6620\u5c04\u5230\u5c4f\u5e55\u7684\u6b63\u4ea4\u6295\u5f71\uff0c\u5728\u4e8c\u7ef4\u56fe\u5f62\u4e2d\u53ef\u4ee5\u770b\u505a\u8bbe\u5b9ax\uff0cy\u6700\u5927\u6700\u5c0f\u503c\u3002 \u9ed8\u8ba4\u5927\u5c0f\u4e3a\uff08\uff0d1\uff0c1\uff0c\uff0d1\uff0c1\uff09 \u88c1\u526a \u5b9a\u4e49 \u5224\u65ad\u56fe\u5f62\u5143\u7d20\u662f\u5426\u843d\u5728\u88c1\u526a\u7a97\u53e3\u4e4b\u5185\u5e76\u627e\u51fa\u5176\u4f4d\u4e8e\u5185\u90e8\u7684\u90e8\u5206\u3002 \u88c1\u526a\u7684\u6b21\u5e8f \uff081\uff09\u626b\u63cf\u8f6c\u6362\u540e\u88c1\u526a\uff1a\u8bbe\u5907\u5750\u6807\u7cfb\uff0c\u70b9\u9635\u8868\u793a\u56fe\u5f62 \u7b97\u6cd5\u7b80\u5355\uff08\u5224\u65ad\u50cf\u7d20\u662f\u5426\u843d\u5728\u89c6\u533a\u4e2d\uff09\uff0c\u6240\u6709\u56fe\u5f62\u90fd\u8981\u5148\u626b\u63cf\u8f6c\u6362\uff0c\u901f\u5ea6\u6162\u3002 \uff082\uff09\u88c1\u526a\u540e\u626b\u63cf\u8f6c\u6362\uff1a\u4e16\u754c\u5750\u6807\u7cfb\uff0c\u53c2\u6570\u8868\u793a\u56fe\u5f62 \u6700\u5e38\u7528\uff0c\u8282\u7ea6\u8ba1\u7b97\u65f6\u95f4\uff08\u5148\u5bf9\u53c2\u6570\u8868\u793a\u7684\u56fe\u5f62\u88c1\u526a\uff09\uff0c\u7b97\u6cd5\u590d\u6742 \u5047\u5b9a\u6761\u4ef6 \u77e9\u5f62\u88c1\u526a\u7a97\u53e3\uff1a[xmin, ymin]\uff0d[xmax, ymax] \u88ab\u88c1\u526a\u5bf9\u8c61\uff1a\u7ebf\u6bb5\u3001\u591a\u8fb9\u5f62 \u76f4\u7ebf\u6bb5\u88c1\u526a \u5f85\u88c1\u526a\u7ebf\u6bb5\u548c\u7a97\u53e3\u7684\u5173\u7cfb (1) \u5b8c\u5168\u53ef\u89c1\uff1a\u7aef\u70b9\u4f4d\u4e8e\u7a97\u53e3\u5185AB (2) \u663e\u7136\u4e0d\u53ef\u89c1 \uff1a\u7aef\u70b9\u4f4d\u4e8e\u540c\u8fb9\u754c\u5916\u4fa7EF (3) \u7ebf\u6bb5\u81f3\u5c11\u6709\u4e00\u7aef\u70b9\u5728\u7a97\u53e3\u4e4b\u5916\uff0c\u4f46\u975e\u663e\u7136\u4e0d\u53ef\u89c1 \u76f4\u7ebf\u6bb5\u76f4\u63a5\u6c42\u4ea4\u7b97\u6cd5 \u7aef\u70b9\u4e0e\u7a97\u53e3\u4f4d\u7f6e\u5173\u7cfb (1) \u90fd\u5728\u7a97\u53e3\u5185\uff08\u5b8c\u5168\u53ef\u89c1\uff09 (2) 1\u4e2a\u5728\u7a97\u53e3\u5185\uff0c\u53e6\u4e00\u4e2a\u5728\u5916 (\u67091\u4e2a\u4ea4\u70b9) (3) 2\u4e2a\u90fd\u4e0d\u5728\u7a97\u53e3\u5185 \u663e\u7136\u4e0d\u53ef\u89c1\uff1f\u3001\u53ef\u80fd\u76f8\u4ea4\uff0c2\u4e2a\u4ea4\u70b9\u8fde\u63a5\u7ebf\u6bb5\u3001\u53ef\u80fd\u4e0d\u76f8\u4ea4 \u8ba1\u7b97\u4ea4\u70b9\u65b9\u6cd5 \u7ebf\u6bb5\u4e0e\u7a97\u53e3\u7684\u8fb9\u6c42\u4ea4\u70b9\uff0c\u76f4\u7ebf\u4e0e\u7a97\u53e3\u8fb9\u90fd\u5199\u6210\u53c2\u6570\u5f62\u5f0f\uff0c\u6c42\u53c2\u6570\u503c \u7b97\u6cd5\u6d41\u7a0b \u7279\u70b9 \u65b9\u6cd5\u76f4\u63a5\uff0c\u6613\u61c2\u3002\u4e0d\u80fd\u5feb\u901f\u5224\u65ad\u663e\u7136\u4e0d\u53ef\u89c1\u7684\u7ebf\u6bb5\u3002 \u7f16\u7801\u7b97\u6cd5 \u7b97\u6cd5\u6b65\u9aa4 \u7b2c\u4e00\u6b65 \u5224\u522b\u7ebf\u6bb5\u4e24\u7aef\u70b9\u662f\u5426\u90fd\u843d\u5728\u7a97\u53e3\u5185\uff0c\u5982\u679c\u662f\uff0c\u5219\u7ebf\u6bb5\u5b8c\u5168\u53ef\u89c1\uff1b\u5426\u5219\u8fdb\u5165\u7b2c\u4e8c\u6b65\uff1b \u7b2c\u4e8c\u6b65 \u5224\u522b\u7ebf\u6bb5\u662f\u5426\u4e3a\u663e\u7136\u4e0d\u53ef\u89c1\uff0c\u5982\u679c\u662f\uff0c\u5219\u88c1\u526a\u7ed3\u675f\uff1b\u5426\u5219\u8fdb\u884c\u7b2c\u4e09\u6b65 \uff1b \u7b2c\u4e09\u6b65 \u6c42\u7ebf\u6bb5\u4e0e\u7a97\u53e3\u8fb9\u5ef6\u957f\u7ebf\u7684\u4ea4\u70b9\uff0c\u8fd9\u4e2a\u4ea4\u70b9\u5c06\u7ebf\u6bb5\u5206\u4e3a\u4e24\u6bb5\uff0c\u5176\u4e2d\u4e00\u6bb5\u663e\u7136\u4e0d\u53ef\u89c1\uff0c\u4e22\u5f03\u3002 \u5bf9\u4f59\u4e0b\u7684\u53e6\u4e00\u6bb5\u91cd\u65b0\u8fdb\u884c\u7b2c\u4e00\u6b65\uff0c \u7b2c\u4e8c\u6b65\uff0c\u7b2c\u4e09\u6b65\u5904\u7406\uff0c \u76f4\u81f3\u7ed3\u675f\u3002 \u533a\u57df\u7f16\u7801 \u7531\u7a97\u53e3\u56db\u6761\u8fb9\u6240\u5728\u76f4\u7ebf\u628a\u4e8c\u7ef4\u5e73\u9762\u5206\u62109\u4e2a\u5b50\u533a\u57df\uff0c\u6bcf\u4e2a\u5b50\u533a\u57df\u8d4b\u4e88\u4e00\u4e2a\u56db\u4f4d\u7f16\u7801\uff0c C_tC_bC_rC_l C_tC_bC_rC_l \uff0c\u4e0a\u4e0b\u53f3\u5de6\u3002 \u6839\u636e\u9876\u70b9\u7f16\u7801\u5224\u65ad\u7ebf\u6bb5\u4e0e\u591a\u8fb9\u5f62\u7684\u5173\u7cfb \u5f53\u4e24\u4e2a\u7aef\u70b9\u7684\u7f16\u7801\u5168\u4e3a0\u65f6\uff0c\u7ebf\u6bb5\u5b8c\u5168\u53ef\u89c1\u3002 \u5f53\u7ebf\u6bb5\u7684\u4e24\u4e2a\u7aef\u70b9\u7684\u7f16\u7801\u7684\u903b\u8f91\u201c\u4e0e\u201d\u975e\u96f6\u65f6 \uff0c\u7ebf\u6bb5\u4e3a\u663e\u7136\u4e0d\u53ef\u89c1\u7684\u3002 \uff081\uff09\u6c42\u4ea4\u524d\u5148\u6d4b\u8bd5\u4e0e\u7a97\u53e3\u54ea\u6761\u8fb9\u6240\u5728\u76f4\u7ebf\u6709\u4ea4\uff1f \u89c4\u5219\uff1a\u5224\u65ad\u7aef\u70b9\u7f16\u7801\u4e2d\u5404\u4f4d\u7684\u503c C_tC_bC_rC_l C_tC_bC_rC_l \uff0c\u5206\u522b\u5bf9\u5e94\uff1a\u4e0a\u3001\u4e0b\u3001\u53f3\u548c\u5de6\u8fb9 \u7aef\u70b9\u7801\u503c\u4f4d\u503c\u4e0d\u540c\u65f6\uff0c\u8bf4\u660e\u7ebf\u6bb5\u4e0e\u5bf9\u5e94\u7a97\u53e3\u8fb9\u76f8\u4ea4 \u6b21\u5e8f\uff1a\u4e0a\u3001\u4e0b\u3001\u53f3\u548c\u5de6\u8fb9 \uff082\uff09\u4ee5\u4ea4\u70b9\u4e3a\u754c\uff0c\u4e22\u5f03\u5916\u4fa7\u7ebf\u6bb5\uff0c \u4ee5\u4ea4\u70b9\u4e3a\u65b0\u7aef\u70b9\u5224\u65ad\u53e6\u4e00\u7ebf\u6bb5\uff0c\u91cd\u590d\u7b97\u6cd5\u7684\u6b65\u9aa4 \u7279\u70b9 (1) \u5bf9\u5b8c\u5168\u53ef\u89c1\u548c\u663e\u7136\u4e0d\u53ef\u89c1\u7ebf\u6bb5\u7684\u5feb\u901f\u5224\u522b (2) \u4e8c\u79cd\u573a\u5408\u6548\u7387\u9ad8 \u200b \u5927\u88c1\u526a\u7a97\u53e3\u4ee5\u53ca\u88c1\u526a\u7a97\u53e3\u7279\u522b\u5c0f (\u5982, \u5149\u6807\u62fe\u53d6\u56fe\u5f62\u65f6\uff0c\u5149\u6807\u770b\u4f5c\u5c0f\u7684\u88c1\u526a\u7a97\u53e3\uff09 (3) \u88c1\u526a\u7a97\u53e3\u7684\u62d3\u5c55\u6027 \u200b \u53ef\u4ee5\u5ef6\u4f38\u4e3a\u51f8\u591a\u8fb9\u5f62\uff0c\u4f46\u968f\u7740\u8fb9\u6570\u7684\u589e\u52a0\uff0c\u7f16\u7801\u53d8\u590d\u6742 Liang-Barsky\u88c1\u526a\u7b97\u6cd5 \u57fa\u672c\u601d\u60f3 \u5c06\u4e8c\u7ef4\u88c1\u526a\u5316\u4e3a\u4e00\u7ef4\u88c1\u526a\uff0c\u5411X\uff08\u6216Y\uff09\u65b9\u5411\u6295\u5f71\u4ee5\u51b3\u5b9a\u53ef\u89c1\u7ebf\u6bb5 \u524d\u63d0 \u5e73\u884c\u4e8eX\u6216Y\u8f74\u7684\u7ebf\u6bb5\u8f83\u5bb9\u6613\uff0c\u8fd9\u91cc\u4e0d\u4f5c\u8003\u8651 \u5047\u8bbeP0P1\u6216\u5176\u5ef6\u957f\u7ebf\u5206\u522b\u4e0e\u7a97\u53e3\u5de6\u3001\u4e0b\u3001\u53f3\u548c\u4e0a\u8fb9\uff08\u6216\u5176\u5ef6\u957f\u7ebf\uff09\u4ea4\u4e8eL\uff0cB\uff0cR\uff0cT \u65b9\u6cd5 \u200b \uff084\uff09\u4ee3\u5165\u76f4\u7ebf\u65b9\u7a0b\u5f97\u5230\u4ea4\u70b9\u5750\u6807\u3002 L-B\u7b97\u6cd5\u7684\u6539\u8fdb\uff0c\u51cf\u5c11\u6c42\u4ea4\u70b9\u7684\u6b21\u6570 LL = max(xmin, min(x0, x1)) \uff0cRR = min(xmax, max(x0, x1)) \u7b97\u6cd5 (1)\u5148\u6d4b\u8bd5 LL\u2264RR\uff1f\u4e0d\u6210\u7acb\uff0c\u4e0d\u5b58\u5728\u53ef\u89c1\u7ebf\u6bb5\uff0c\u9000\u51fa\uff1b\u5426\u5219\uff0c\u6267\u884c\uff082\uff09 (2)\u7ebf\u6bb5P1P2\u7684\u659c\u7387K>0? \u4e0d\u662f\u6267\u884c\uff083\uff09\uff0c\u5426\u5219\u6267\u884c\u3002 \u8ba1\u7b97xT, \u6d4b\u8bd5 LL \u2264xT\uff1f\u82e5\u6210\u7acb\uff0c\u8ba1\u7b97xB\uff0c\u6d4b\u8bd5 xB \u2264RR\uff1f\u82e5\u6210\u7acb\uff0c\u6709\u53ef\u89c1\u7ebf\u6bb5\uff1a x\u03b1 = max(LL\uff0cxB); x\u03b2 = min(RR\uff0cxT) (3)K<0:\u8ba1\u7b97xB,\u6d4b\u8bd5 LL \u2264xB\uff1f\u82e5\u6210\u7acb\uff0c\u8ba1\u7b97xT\uff0c\u6d4b\u8bd5 xT \u2264R\uff1f\u82e5\u6210\u7acb\uff0c\u6709\u53ef\u89c1\u7ebf\u6bb5\uff1a x\u03b1 = max(LL ,xT); x\u03b2 = min(RR, xB) \u7279\u70b9 \uff081\uff09\u4e8c\u7ef4\u8f6c\u5316\u4e3a\u4e00\u7ef4\uff082\uff09\u6309\u9700\u6c42\u4ea4\u70b9\uff0c\u63d0\u9ad8\u6548\u7387 \u591a\u8fb9\u5f62\u88c1\u526a S-H\uff08\u9010\u8fb9\uff09\u88c1\u526a\u7b97\u6cd5\u57fa\u672c\u601d\u60f3 \u8f93\u5165\u8f93\u51fa\uff1a\u9876\u70b9\u5e8f\u5217 V_0V_1V_2V_3V_4 \u2026. V_0V_1V_2V_3V_4 \u2026. \u5b9a\u4e49\uff1a \u88c1\u526a\u7ebf\uff1a\u7a97\u53e3\u8fb9\u4ee5\u53ca\u5176\u5ef6\u957f\u7ebf \u5185\u4fa7\u7a7a\u95f4\u4e0e\u5916\u4fa7\u7a7a\u95f4\uff1a\u5305\u542b\u88c1\u526a\u7a97\u53e3\u7684\u534a\u7a7a\u95f4\u4e3a\u5185\u4fa7\u7a7a\u95f4\uff0c\u5426\u5219\u4e3a\u5916\u4fa7\u7a7a\u95f4\u3002 \u591a\u8fb9\u5f62\u4e0e\u7a97\u53e3\u88c1\u526a\u7ebf\u7684\u88c1\u526a \u5316\u89e3\u4e3a\u591a\u8fb9\u5f62\u6bcf\u6761\u8fb9\u4e0e\u88c1\u526a\u7ebf\u88c1\u526a\u3002 \u8fb9\u4e0e\u88c1\u526a\u7ebf\u7684\u88c1\u526a\u65b9\u6cd5\uff1a\u4f9d\u636e\u591a\u8fb9\u5f62\u7684\u8fb9SP\uff08S\u662f\u8d77\u70b9\uff09\u4e0e\u534a\u7a7a\u95f4\uff08\u5185\u5916\u4fa7\uff09\u7684\u5173\u7cfb \u60c5\u51b51\uff1a\u540c\u5728\u5185\u4fa7\uff0c\u88c1\u526a\u540e\u8f93\u51faP \u60c5\u51b52\uff1aS \u5728\u5185\u4fa7\uff0cP \u5728\u5916\u4fa7\uff0c\u88c1\u526a\u540e\u8f93\u51fa\u4ea4\u70b9 i \u60c5\u51b53\uff1a\u540c\u5728\u5916\u4fa7\uff0c\u88c1\u526a\u540e\u4e0d\u8f93\u51fa \u60c5\u51b54\uff1aS \u5728\u5916\u4fa7\uff0c P \u5728\u5185\u4fa7\uff0c\u88c1\u526a\u540e\u8f93\u51fa\u4ea4\u70b9 i \u548c P \u7b97\u6cd5 \u5c06\u9876\u70b9\u5e8f\u5217P1P2\u2026Pn\u4f5c\u4e3a\u8f93\u5165 \u4f9d\u6b21\u5bf9\u7a97\u53e3\u7684\u6bcf\u6761\u88c1\u526a\u7ebf\u4f5c\u4e0b\u5217\u5904\u7406 \u8f93\u5165\u9876\u70b9\u5e8f\u5217 \u4f9d\u6b21\u9876\u70b9\u5e8f\u5217\u4e2d\u76f8\u90bb\u9876\u70b9\u6784\u6210\u7684\u8fb9PiPi+1\u8fdb\u884c\u88c1\u526a\u5904\u7406 \u8f93\u51fa\u9876\u70b9\u5e8f\u5217\uff08\u4e0b\u6761\u88c1\u526a\u7ebf\u7684\u8f93\u5165\uff09 SH\u626b\u63cf\u987a\u5e8f\uff1a\u5de6\u4e0a\u53f3\u4e0b \u7279\u70b9 \u88c1\u526a\u7b97\u6cd5\u91c7\u7528\u6d41\u6c34\u7ebf\u65b9\u5f0f\uff0c\u7b97\u6cd5\u7b80\u5355 \u63a8\u5e7f\u5230\u4efb\u610f\u51f8\u591a\u8fb9\u5f62\u88c1\u526a\u7a97\u53e3 \u539f\u56e0\u662f\uff1a\u51f8\u591a\u8fb9\u5f62\u7684\u8fb9\u80fd\u5c06\u5e73\u9762\u7a7a\u95f4\u5206\u62102\u90e8\u5206\uff0c\u5176\u4e2d\u4e00\u90e8\u5206\u542b\u88c1\u526a\u7a97\u53e3 Weiler-Athenton\u7b97\u6cd5 \u9002\u7528\u4e8e\u88c1\u526a\u7a97\u53e3\u4e3a\u4efb\u610f\u591a\u8fb9\u5f62\uff08\u51f8\u3001\u51f9\u3001\u5e26\u5185\u73af\uff09\u7684\u60c5\u51b5 \u5185\u88c1\u526a\u7279\u70b9 \u88c1\u526a\u7ed3\u679c\u533a\u57df\u7684\u8fb9\u754c\u7531A\u7684\u90e8\u5206\u8fb9\u754c\u548cB\u7684\u90e8\u5206\u8fb9\u754c\u4e24\u90e8\u5206\u6784\u6210\uff0c\u5e76\u4e14\u5728\u4ea4\u70b9\u5904\u8fb9\u754c\u53d1\u751f\u4ea4\u66ff\uff0c\u5373\u7531A\u7684\u8fb9\u754c\u8f6c\u81f3B\u7684\u8fb9\u754c\uff0c\u6216\u7531B\u7684\u8fb9\u754c\u8f6c\u81f3A\u7684\u8fb9\u754c\u3002 \u4ea4\u70b9 \u51fa\u70b9\uff1a\u4e3b\u591a\u8fb9\u5f62\u8fb9\u754c\u7531\u6b64\u79bb\u5f00\u88c1\u526a\u591a\u8fb9\u5f62\u533a\u57df\u3002 \u8fdb\u70b9\uff1a\u4e3b\u591a\u8fb9\u5f62\u8fb9\u754c\u7531\u6b64\u8fdb\u5165\u88c1\u526a\u591a\u8fb9\u5f62\u5185\u3002 \u5b57\u7b26\u88c1\u526a \u57fa\u4e8e\u5b57\u7b26\u4e32 \u6574\u4e2a\u5b57\u7b26\u4e32\u5b8c\u5168\u843d\u5728\u7a97\u53e3\u4e4b\u5185\u65f6\u663e\u793a\uff0c\u5426\u5219\u4e0d\u663e\u793a\u3002 \u5b57\u7b26\u4e32\u7684\u77e9\u5f62\u5305\u56f4\u76d2\u6d4b\u8bd5\u3002 \u57fa\u4e8e\u5b57\u7b26 \u4e00\u4e2a\u5b57\u7b26\u5b8c\u5168\u843d\u5728\u7a97\u53e3\u4e4b\u5185\u65f6\u663e\u793a\uff0c\u5426\u5219\u4e0d\u663e\u793a\u3002 \u5b57\u7b26\u7684\u77e9\u5f62\u5305\u56f4\u76d2\u6d4b\u8bd5\u3002 \u57fa\u4e8e\u6784\u6210\u5b57\u7b26\u7684\u6700\u5c0f\u5143\u7d20 \u70b9\u9635\u5b57\u7b26\uff1a\u70b9\u88c1\u526a \u77e2\u91cf\u5b57\u7b26\uff1a\u7ebf\u88c1\u526a \u7b2c\u516d\u7ae0 \u4e09\u7ef4\u56fe\u5f62\u7684\u663e\u793a \u00b6 \u4e09\u7ef4\u56fe\u50cf\u7b80\u4ecb \u4e09\u7ef4\u6210\u50cf\u57fa\u672c\u6b65\u9aa4 \uff081\uff09\u9009\u5b9a\u6295\u5f71\u7c7b\u578b \u2014\u2014 \u5e73\u884c\u3001\u900f\u89c6 \uff082\uff09\u8bbe\u7f6e\u6295\u5f71\u53c2\u6570\u2014\u2014 \u62cd\u6444\u65b9\u5411\u3001\u8ddd\u79bb\u7b49 \uff083\uff09\u4e09\u7ef4\u88c1\u526a \u2014\u2014\u53d6\u666f \uff084\uff09\u6295\u5f71\u548c\u663e\u793a\u2014\u2014\u6210\u50cf \u7b80\u5355\u7684\u4e09\u7ef4\u56fe\u5f62\u663e\u793a\u6d41\u7a0b\u56fe \u5e73\u9762\u51e0\u4f55\u6295\u5f71\u5206\u7c7b \u5e73\u884c\u6295\u5f71(parallel projection)\u6295\u5f71\u4e2d\u5fc3\u4e0e\u6295\u5f71\u5e73\u9762\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e3a\u65e0\u9650 \u900f\u89c6\u6295\u5f71(perspective projection)\u6295\u5f71\u4e2d\u5fc3\u4e0e\u6295\u5f71\u5e73\u9762\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e3a\u6709\u9650 \u900f\u89c6\u6295\u5f71 \u5b9a\u4e49\uff1a\u6295\u5f71\u4e2d\u5fc3\u4e0e\u6295\u5f71\u5e73\u9762\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e3a\u6709\u9650 \u706d\u70b9\uff08vanishing point\uff09 \u4e0d\u5e73\u884c\u4e8e\u6295\u5f71\u5e73\u9762\u7684\u5e73\u884c\u7ebf\uff0c\u7ecf\u8fc7\u900f\u89c6\u6295\u5f71\u4e4b\u540e\u6536\u655b\u4e8e\u4e00\u70b9\uff0c\u79f0\u4e3a\u706d\u70b9\u3002\u706d\u70b9\u7684\u4e2a\u6570\u65e0\u9650 \u4e3b\u706d\u70b9:\u5e73\u884c\u4e8e\u5750\u6807\u8f74\u7684\u5e73\u884c\u7ebf\u7684\u706d\u70b9\u3002 \u4e00\u70b9\u900f\u89c6\uff1a1\u4e2a\u706d\u70b9 \u4e24\u70b9\u900f\u89c6\uff1a2\u4e2a\u706d\u70b9 \u4e09\u70b9\u900f\u89c6\uff1a3\u4e2a\u706d\u70b9 \u7279\u70b9 \u4ea7\u751f\u8fd1\u5927\u8fdc\u5c0f\u7684\u89c6\u89c9\u6548\u679c\uff0c\u7531\u5b83\u4ea7\u751f\u7684\u56fe\u5f62\u6df1\u5ea6\u611f\u5f3a\uff0c\u770b\u8d77\u6765\u66f4\u52a0\u771f\u5b9e\u3002 \u5e73\u884c\u6295\u5f71 \u6295\u5f71\u4e2d\u5fc3\u4e0e\u6295\u5f71\u5e73\u9762\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e3a\u65e0\u9650\uff0c\u662f\u900f\u89c6\u6295\u5f71\u7684\u6781\u9650\u72b6\u6001 \u6b63\u6295\u5f71\u4e0e\u659c\u6295\u5f71 \u6b63\u6295\u5f71(orthogonal projection)\uff1a\u6295\u5f71\u7ebf\u5782\u76f4\u4e8e\u6295\u5f71\u5e73\u9762 \u659c\u6295\u5f71\uff1a\u6295\u5f71\u7ebf\u4e0d\u5782\u76f4\u4e8e\u6295\u5f71\u5e73\u9762 \u4e09\u89c6\u56fe\uff1a\u6b63\u89c6\u56fe\u3001\u4fa7\u89c6\u56fe\u548c\u4fef\u89c6\u56fe\uff0c\u5747\u4e3a\u6b63\u6295\u5f71\u3002 \u89c2\u5bdf\u5750\u6807\u7cfb \u5b9a\u4e49 \u4f9d\u8d56\u4e8e\u6295\u5f71\u5e73\u9762\u5efa\u7acb\u7684\u4e09\u7ef4\u5750\u6807\u7cfbuvn\u3002\u5982\u7167\u76f8\u673a\u6240\u5728\u7684\u5750\u6807\u7cfb\u3002 \u89c2\u5bdf\u5750\u6807\u7cfb\u7684\u5efa\u7acb \u5efa\u7acb\u89c2\u5bdf\u5750\u6807\u7cfb 1. \u5750\u6807\u539f\u70b9----\u6295\u5f71\u5e73\u9762\uff08\u5982\u5e95\u7247\uff09\u4e0a\u7684\u4e00\u70b9\uff0c\u79f0\u4e3a\u89c2\u5bdf\u53c2\u8003\u70b9VRP\uff08View Reference Point) 2. n\u8f74(VPN)----\u7167\u76f8\u673a\u955c\u5934\u53cd\u65b9\u5411\uff08\u6295\u5f71\u5e73\u9762\u7684\u6cd5\u5411\uff09 3. v\u8f74----\u6807\u5fd7\u7269\u4f53\u7684\u671d\u5411\uff0c\u7c7b\u4f3c\u7167\u76f8\u673a\u5411\u4e0a\u7684\u65b9\u5411\uff08\u89c2\u5bdf\u6b63\u5411VUP\u5728\u6295\u5f71\u5e73\u9762\u4e0a\u7684\u6295\u5f71\uff09 4. u\u8f74, u=n \\times v u=n \\times v \u89c2\u5bdf\u5750\u6807\u7cfb\u4e2d\u7684\u6295\u5f71\u53c2\u6570 \u7b80\u5316\u6295\u5f71\u53d8\u6362 \u6295\u5f71\u5e73\u9762 ---- n = 0\uff0c\u6295\u5f71\u4e2d\u5fc3 ---- (0 \uff0c0\uff0cd ) \u6295\u5f71\u524d\u9700\u8981\u5c06\u56fe\u5f62\u5750\u6807\u4ece\u4e16\u754c\uff08\u7528\u6237\uff09\u5750\u6807\u7cfb\u8f6c\u6362\u5230\u89c2\u5bdf\u5750\u6807\u7cfb\u3002 \u89c6\u89c1\u4f53 \u89c6\u89c1\u4f53\u662f\u4e09\u7ef4\u88c1\u526a\u7a97\u53e3\uff0c\u786e\u5b9a\u53ef\u89c1\u7a7a\u95f4 \u5efa\u7acb\u6b65\u9aa4 1 \u5b9a\u4e49\u7a97\u53e3\uff08\u6295\u5f71\u5e73\u9762\u4e0a\uff09 2 \u5f62\u6210\u89c2\u5bdf\u7a7a\u95f4\uff08\u53d1\u51fa\u5c04\u7ebf\uff09 3 \u5f62\u6210\u89c6\u89c1\u4f53\uff08\u524d\u540e\u88c1\u526a\u9762\uff09 \u5efa\u7acb\u7a97\u53e3 \u5728\u6295\u5f71\u5e73\u9762uv\u4e0a \u6307\u5b9a\u53c2\u6570\uff08umin\uff0cvmin\uff09\uff08umax\uff0cvmax) \u7a97\u53e3\u4e2d\u5fc3CW\u4e0d\u4e00\u5b9a\u843d\u5728\u89c2\u5bdf\u53c2\u8003\u70b9VRP\u4e0a \u53ea\u6709\u5728\u7a97\u53e3\u5185\u7684\u56fe\u5f62\u624d\u80fd\u5728\u89c6\u533a\u4e2d\u663e\u793a \u751f\u6210\u89c2\u5bdf\u7a7a\u95f4 \u5b9a\u4e49\u6295\u5f71\u53c2\u8003\u70b9PRP: Projection Reference Point \u4f5c\u7528\uff1a\u786e\u5b9a\u6295\u5f71\u4e2d\u5fc3\uff08\u900f\u89c6\u6295\u5f71\uff09\u6216\u6295\u5f71\u65b9\u5411\uff08\u5e73\u884c\u6295\u5f71\uff09 \u900f\u89c6\u6295\u5f71\uff1aCOP = PRP\uff0c\u89c2\u5bdf\u7a7a\u95f4\u662f\u56db\u68f1\u9525\u3002 \u5e73\u884c\u6295\u5f71\uff1a\u6295\u5f71\u65b9\u5411DOP = \u7a97\u53e3\u4e2d\u5fc3CW - PRP\uff0c\u89c2\u5bdf\u7a7a\u95f4\u662f\u56db\u68f1\u67f1\u3002 \u5f62\u6210\u89c6\u89c1\u4f53 \u89c6\u89c1\u4f53\uff1a\u5b9a\u4e49\u524d\u540e\u88c1\u526a\u9762\uff0c\u5f62\u6210\u6709\u9650\u7684\u89c2\u5bdf\u7a7a\u95f4 \u900f\u89c6\u6295\u5f71\u89c6\u89c1\u4f53\u662f\u56db\u68f1\u53f0\uff1b\u5e73\u884c\u6295\u5f71\u89c6\u89c1\u4f53\u662f\u957f\u65b9\u4f53 \u53c8\u79f0\u4e3a\u88c1\u526a\u7a7a\u95f4 \u5b9a\u4e49\u4e00\u4e2a\u89c6\u89c1\u4f53\u6240\u9700\u8981\u7684\u53c2\u6570 \u53c2\u6570 \u4f5c\u7528 \u6295\u5f71\u7c7b\u578b \u5b9a\u4e49\u6295\u5f71\u662f\u5e73\u884c\u6295\u5f71\u8fd8\u662f\u900f\u89c6\u6295\u5f71 \u89c2\u5bdf\u53c2\u8003\u70b9VRP \u5728\u4e16\u754c\u5750\u6807\u7cfb\u4e2d\u6307\u5b9a\uff0c\u4e3a\u89c2\u5bdf\u5750\u6807\u7cfb\u539f\u70b9 \u89c2\u5bdf\u5e73\u9762\u6cd5\u5411VPN \u5728\u4e16\u754c\u5750\u6807\u7cfb\u4e2d\u6307\u5b9a\uff0c\u4e3a\u89c2\u5bdf\u5750\u6807\u7684n\u8f74 \u89c2\u5bdf\u6b63\u5411VUP \u5728\u4e16\u754c\u5750\u6807\u7cfb\u4e2d\u6307\u5b9a\uff0c\u786e\u5b9a\u89c2\u5bdf\u5750\u6807\u7cfb\u7684v \u6295\u5f71\u53c2\u8003\u70b9PRP \u5728\u89c2\u5bdf\u5750\u6807\u7cfb\u4e2d\u6307\u5b9a\u786e\u5b9a\u6295\u5f71\u4e2d\u5fc3\u6216\u6295\u5f71\u65b9\u5411 \u524d\u88c1\u526a\u9762\u88c1\u8dddF \u5728\u89c2\u5bdf\u5750\u6807\u7cfb\u4e2d\u6307\u5b9a\uff0cn\uff1dF\u4e3a\u524d\u88c1\u526a\u9762 \u540e\u88c1\u526a\u9762\u88c1\u8dddB \u5728\u89c2\u5bdf\u5750\u6807\u7cfb\u4e2d\u6307\u5b9a\uff0cn\uff1dB\u4e3a\u540e\u88c1\u526a\u9762 \u7a97\u53e3umin\uff0cumax\u3001vmin\u3001vmax \u5728\u89c2\u5bdf\u5750\u6807\u7cfb\u7684uv\u5e73\u9762\u4e0a\u6307\u5b9a\uff0c\u786e\u5b9a\u7a97\u53e3\u4e0e\u89c6\u89c1\u4f53 \u6295\u5f71\u53d8\u6362 \u900f\u89c6\u6295\u5f71 \u5728uvn\u4e2d\uff0c\u6295\u5f71\u5e73\u9762\u4e3an = 0\uff0c\u6295\u5f71\u4e2d\u5fc3\u4e3a(0\uff0c0\uff0cd )\uff0c\u6295\u5f71\u53d8\u6362\u77e9\u9635\u4e3a\uff1a \u5e73\u884c\u6295\u5f71 \u4ece\u4e16\u754c\u5750\u6807\u7cfb\u5230\u89c2\u5bdf\u5750\u6807\u7cfb\u7684\u53d8\u6362 \u4e09\u7ef4\u56fe\u5f62\u7684\u663e\u793a\u6d41\u7a0b\u56fe \u6a21\u578b\u53d8\u6362: \u4ece\u5c40\u90e8\uff08\u6a21\u578b\uff09\u5750\u6807\u7cfb\u5230\u4e16\u754c\u5750\u6807\u7cfb\u7684\u53d8\u6362 \u89c2\u5bdf\u53d8\u6362: \u4ece\u4e16\u754c\u5750\u6807\u7cfb\u5230\u89c2\u5bdf\u5750\u6807\u7cfb\u7684\u53d8\u6362 \u6295\u5f71\u53d8\u6362 : \u4e09\u7ef4\u5230\u4e8c\u7ef4\u7684\u8f6c\u6362 \u6a21\u578b\u53d8\u6362 \u5c06\u7269\u4f53\u4ece\u81ea\u8eab\u7684\u6a21\u578b\u5750\u6807\u7cfb\u53d8\u6362\u5230\u4e0a\u5c42\u7269\u4f53\u7684\u6a21\u578b\u5750\u6807\u7cfb\uff08\u6216\u4e16\u754c\u5750\u6807\u7cfb\uff09\u7684\u51e0\u4f55\u53d8\u6362\u3002 \u6a21\u578b\u53d8\u6362\u662f\u6784\u9020\u590d\u6742\u7269\u4f53\u7684\u65b9\u6cd5\uff0c\u901a\u8fc7\u57fa\u672c\u51e0\u4f55\u53d8\u6362\u6784\u9020\u590d\u6742\u7269\u4f53\u3002 \u88c1\u526a \u5148\u6295\u5f71\u540e\u88c1\u526a \u4f18\u70b9\uff1a\u4e8c\u7ef4\u88c1\u526a\u76f8\u5bf9\u5bb9\u6613 \u7f3a\u70b9\uff1a\u9700\u8981\u5bf9\u6240\u6709\u7684\u7269\u4f53\u8fdb\u884c\u6295\u5f71\u53d8\u6362 \u5148\u88c1\u526a\u540e\u6295\u5f71 \u539f\u56e0\u6709\uff1a (1) \u4e09\u7ef4\u7269\u4f53\u7684\u8868\u9762\u901a\u5e38\u88ab\u79bb\u6563\u8868\u793a\u6210\u591a\u8fb9\u5f62\u6216\u6298\u7ebf\uff0c\u800c\u5bf9\u8fd9\u7c7b\u7b80\u5355\u56fe\u5143\uff0c\u4e09\u7ef4\u88c1\u526a\u540c\u6837\u6bd4\u8f83\u7b80\u5355; (2) \u4e09\u7ef4\u56fe\u5f62\u5728\u663e\u793a\u8fc7\u7a0b\u4e2d\u9700\u8981\u88ab\u6d88\u9690\uff0c\u6d88\u9690\u8981\u6709\u56fe\u5f62\u7684\u6df1\u5ea6\u4fe1\u606f\uff0c\u6240\u4ee5\u5fc5\u987b\u5728\u6295\u5f71\u4e4b\u524d\u5b8c\u6210 \u3002 \u6d88\u9690\u5f88\u8d39\u65f6\uff0c\u5982\u679c\u5728\u6b64\u4e4b\u524d\u88c1\u526a\uff08\u6216\u90e8\u5206\u88c1\u526a\uff09\u6389\u4e0d\u53ef\u89c1\u7684\u56fe\u5f62\uff0c\u53ef\u4f7f\u9700\u8981\u6d88\u9690\u7684\u56fe\u5f62\u51cf\u81f3\u6700\u5c0f\u3002\u4e24\u7c7b\u6295\u5f71\u7684\u89c6\u89c1\u4f53\u4e0d\u4e00\u6837\uff0c\u5982\u4f55\u65b9\u4fbf\u88c1\u526a\uff1f\u89c4\u8303\u5316\u5230\u957f\u65b9\u4f53 \u4e09\u7ef4\u88c1\u526a\u7684\u4e24\u79cd\u65b9\u6cd5 \u5728\u4e09\u7ef4\u7a7a\u95f4\u5173\u4e8e\u89c6\u89c1\u4f53\u88c1\u526a\uff0c\u9700\u8981\u5c06\u9f50\u6b21\u5750\u6807\u8f6c\u6362\u4e3a\u4e09\u7ef4\u5750\u6807 \u4f18\u70b9\uff1a\u4e09\u7ef4\u88c1\u526a\u76f8\u5bf9\u5bb9\u6613 \u7f3a\u70b9\uff1a\u9700\u8981\u5c06\u9f50\u6b21\u5750\u6807\u8f6c\u6362\u4e3a\u4e09\u7ef4\u5750\u6807 \u76f4\u63a5\u5728\u56db\u7ef4\u9f50\u6b21\u5750\u6807\u7a7a\u95f4\u4e2d\u8fdb\u884c\u88c1\u526a \u4f18\u70b9\uff1a \u4e0d\u9700\u8981\u5c06\u9f50\u6b21\u5750\u6807\u8f6c\u6362\u4e3a\u4e09\u7ef4\u5750\u6807 \u6709\u7406\u66f2\u7ebf\u66f2\u9762\u53ef\u80fd\u76f4\u63a5\u7528\u9f50\u6b21\u5750\u6807\u6765\u8868\u793a\uff0c\u5bf9\u5b83\u4eec\u7684\u88c1\u526a\u53ea\u80fd\u5728\u9f50\u6b21\u5750\u6807\u7a7a\u95f4\u4e2d\u8fdb\u884c \u7f3a\u70b9\uff1a\u56db\u7ef4\u88c1\u526a\u76f8\u5bf9\u590d\u6742 \u76f4\u7ebf\u6bb5\u88c1\u526a Cohen_Sutherland\u7b97\u6cd5 \u89c6\u89c1\u4f53\u662f\u957f\u65b9\u4f53\uff0c6\u4e2a\u9762\u5206\u7a7a\u95f427\u4e2a\u533a\u57df \u7f16\u7801\uff1a6\u4f4d\uff0cC1C2C3C4C5C6 \u7b97\u6cd5\u8fc7\u7a0b\uff1a \u7c7b\u4f3c\u4e8c\u7ef4\u88c1\u526a Linang_Barskey\u7b97\u6cd5\u7684\u76f4\u63a5\u63a8\u5e7f \uff0d\u4e09\u7ef4\u6295\u5f71\u5230\u4e00\u7ef4 \u8bf1\u5bfc\u7a97\u53e3\u662f3\u6761\u7ebf\u6bb5\u7684\u4ea4\u96c6\u3002 \u591a\u8fb9\u5f62\u88c1\u526a\uff1a\u9010\u9762\u88c1\u526a\u7b97\u6cd5 \u662f\u4e8c\u7ef4\u591a\u8fb9\u5f62Sutherland_Hodgman\u9010\u8fb9\u88c1\u526a\u7b97\u6cd5\u63a8\u5e7f\u3002 \u591a\u8fb9\u5f62\u8fb9\u4e0e\u88c1\u526a\u7ebf\u88c1\u526a\u6269\u5c55\u4e3a\u591a\u8fb9\u5f62\u8fb9\u4e0e\u88c1\u526a\u9762\u88c1\u526a\u3002\u8fb9\u4e0e\u88c1\u526a\u9762\u88c1\u526a\u65f6\u7684\u8f93\u51fa\u89c4\u5219\u4e0e\u4e8c\u7ef4\u7c7b\u4f3c\u3002 \u4e3b\u8981\u8fd0\u7b97\uff1a \u6c42\u7ebf\u6bb5\u4e0e\u5e73\u9762\u7684\u4ea4\u70b9 OpenGL\u76f8\u5173\u51fd\u6570 //\u5efa\u6a21\u89c2\u5bdf\u6a21\u5f0f glMatrixMode \uff08 GL_MODELVIEW \uff09 gluLookAt \uff08 eyex , eyey , eyez , atx , aty , atz , upx , upy , upz \uff09 //\u6307\u5b9a\u89c2\u5bdf\u53c2\u6570 //\u9ed8\u8ba4\u53c2\u6570\uff1a\uff081\uff09eye\uff1d\uff080\uff0c0\uff0c0\uff09\uff082\uff09at\uff1d\uff080\uff0c0\uff0c\uff0d1\uff09\uff083\uff09up\uff1d\uff080\uff0c1\uff0c0\uff09 //\u5efa\u7acb\u6295\u5f71\u53d8\u6362\u77e9\u9635\uff0c\u8bbe\u5b9a\u5f53\u524d\u6295\u5f71\u77e9\u9635 glMatrixMode \uff08 GL_PROJECTION \uff09 //\u6b63\uff08\u5e73\u884c\uff09\u6295\u5f71\u51fd\u6570 glOrtho ( xmin , xmax , ymin , ymax , near , far ) \u6216 glOrtho ( left , right , bottom , top , near , far ) ( 1 ) \u5f62\u6210\u89c6\u89c1\u4f53 ( 2 ) near\u548cfar\u4e3a\u4ece\u89c2\u5bdf\u5750\u6807\u7cfb\u539f\u70b9\u6cbf\u8d1fZ\u8f74\u65b9\u5411\u7684\u8ddd\u79bb \u9ed8\u8ba4\u53c2\u6570 \uff1a glOrtho ( -1.0 , 1.0 , -1.0 , 1.0 , -1.0 , 1.0 ) \u662f\u4e00\u5bf9\u79f0\u89c4\u8303\u5316\u5bf9\u79f0\u6b63\u65b9\u4f53 \u5bf9\u4e8c\u7ef4\u800c\u8a00 \uff0c glOrtho2D\u5efa\u7acb\u88c1\u526a\u7a97\u53e3 \u5982\u4e0d\u6307\u5b9a\u6295\u5f71\u51fd\u6570 \uff0c \u9ed8\u8ba4\u6b63\u6295\u5f71\u6765\u663e\u793a\u573a\u666f //\u900f\u89c6\u6295\u5f71\u51fd\u6570\u5b9a\u4e49\u89c6\u89c1\u4f53 glFrustum ( left , right , bottom , top , near , far ) \u5b9a\u4e49\u89c6\u89c1\u4f53 \u524d\u56db\u4e2a\u53c2\u6570\u8bbe\u5b9a\u6295\u5f71\u5e73\u9762\u4e0a \u88c1\u526a\u7a97\u53e3\u7684\u5750\u6807 \uff08 OpenGL\u6295\u5f71\u5e73\u9762\u4e3a\u8fd1\u88c1\u526a\u9762 \uff09 gluPerspective \uff08 fovy \uff0c aspect \uff0c near \uff0c far \uff09 fovy \uff1a \u4e0a\u4e0b\u88c1\u526a\u9762\u95f4\u7684\u5939\u89d2 \uff08 0 \uff5e 180 \uff09 aspect \uff1a \u88c1\u526a\u7a97\u53e3\u7eb5\u6a2a\u6bd4 \uff08 \u5bbd\u5ea6 / \u9ad8\u5ea6 \uff09 near \uff1a \u8fd1\u88c1\u526a\u9762 far \uff1a \u8fdc\u526a\u9762 \u7b2c\u516b\u7ae0 \u771f\u5b9e\u611f\u56fe\u5f62\u751f\u6210 \u00b6 \u6d88\u9690\u6280\u672f \u5b9a\u4e49\uff1a\u6d88\u9664\u88ab\u906e\u6321\u7684\u4e0d\u53ef\u89c1\u7684\u7ebf\u6216\u9762\u79f0\u4f5c\u6d88\u9664\u9690\u85cf\u7ebf\u548c\u9690\u85cf\u9762\uff0c\u7b80\u79f0\u4e3a\u6d88\u9690\u3002 \u6d88\u9690\u7684\u5bf9\u8c61\uff1a\u4e09\u7ef4\u7269\u4f53\uff0c\u4e09\u7ef4\u4f53\u7684\u8868\u793a\u4e3b\u8981\u91c7\u7528\u8fb9\u754c\uff08\u591a\u8fb9\u5f62\uff09\u8868\u793a\u3002 \u6d88\u9690\u7ed3\u679c\uff1a\u4e0e\u89c2\u5bdf\u7269\u4f53\u6709\u5173\uff0c\u4e5f\u4e0e\u89c6\u70b9\u4f4d\u7f6e\u548c\u65b9\u5411\u6709\u5173\u3002 \u753b\u5bb6\u7b97\u6cd5 \u5b9a\u4e49\uff1a\u8fdc\u8fd1\u6392\u5e8f\uff0c\u4e4b\u540e\u6309\u8fdc\u8fd1\u987a\u5e8f\u6295\u5f71\u3002 \u95ee\u9898\uff1a\u4e0d\u80fd\u5904\u7406\u591a\u8fb9\u5f62\u5faa\u73af\u906e\u6321\u548c\u591a\u8fb9\u5f62\u76f8\u4e92\u7a7f\u900f\u3002 Z \uff08\u6df1\u5ea6\uff09\u7f13\u51b2\u5668\u7b97\u6cd5 \u7ec4\u6210 \u5e27\u7f13\u51b2\u5668 -- \u4fdd\u5b58\u5404\u50cf\u7d20\u989c\u8272\u503c\uff0cZ \u7f13\u51b2\u5668 -- \u4fdd\u5b58\u5404\u50cf\u7d20\u5904\u7269\u4f53\u6df1\u5ea6\u503c Z \u7f13\u51b2\u5668\u4e2d\u7684\u5355\u5143\u4e0e\u5e27\u7f13\u51b2\u5668\u4e2d\u7684\u5355\u5143\u4e00\u4e00\u5bf9\u5e94 \u7b97\u6cd5\u6b65\u9aa4 (1) \u5148\u5c06 Z \u7f13\u51b2\u5668\u4e2d\u4e2a\u5355\u5143\u7684\u521d\u59cb\u503c\u7f6e\u4e3a\u6700\u5c0f\u503c\u3002 (2)\u591a\u8fb9\u5f62\u6295\u5f71\u540e\uff0c\u626b\u63cf\u8f6c\u6362\u5199\u5e27\u7f13\u5b58\u65f6\uff0c\u5f53\u8981\u6539\u53d8\u67d0\u4e2a\u50cf\u7d20\u7684\u989c\u8272\u503c\u65f6\uff0c\u9996\u5148\u68c0\u67e5\u8be5\u50cf\u7d20\u5bf9\u5e94\u5f53\u524d\u591a\u8fb9\u5f62\u4e0a\u70b9\u7684\u6df1\u5ea6\u503c\u662f\u5426\u5927\u4e8e\u8be5\u50cf\u7d20\u539f\u6765\u7684\u6df1\u5ea6\u503c\uff08\u4fdd\u5b58\u5728\u8be5\u50cf\u7d20\u6240\u5bf9\u5e94\u7684Z\u7f13\u51b2\u5668\u7684\u5355\u5143\u4e2d\uff09\uff0c \u5982\u679c\u5927\u4e8e\uff0c\u8bf4\u660e\u5f53\u524d\u591a\u8fb9\u5f62\u66f4\u9760\u8fd1\u89c2\u5bdf\u70b9\uff0c\u7528\u5b83\u7684\u989c\u8272\u66ff\u6362\u50cf\u7d20\u539f\u6765\u7684\u989c\u8272\uff1b\u540c\u65f6\u4fdd\u5b58\u6df1\u5ea6\u503c; \u5426\u5219\u8bf4\u660e\u5728\u5f53\u524d\u50cf\u7d20\u5904\uff0c\u5f53\u524d\u591a\u8fb9\u5f62\u88ab\u524d\u9762\u6240\u7ed8\u5236\u7684\u591a\u8fb9\u5f62\u906e\u6321\u4e86\uff0c\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\u50cf\u7d20\u7684\u989c\u8272\u503c\u4e0d\u6539\u53d8\u3002 \u7279\u70b9 (1) Z \u7f13\u51b2\u5668\u7b97\u6cd5\u662f\u6240\u6709\u56fe\u50cf\u7a7a\u95f4\u7b97\u6cd5\u4e2d\u6700\u7b80\u5355\u7684\u4e00\u79cd\u9690\u85cf\u9762\u6d88\u9664\u7b97\u6cd5\u3002\u5728\u50cf\u7d20\u7ea7\u4e0a\u4ee5\u8fd1\u7269\u53d6\u4ee3\u8fdc\u7269\uff0c\u4e0e\u5f62\u4f53\u5728\u5c4f\u5e55\u4e0a\u7684\u51fa\u73b0\u987a\u5e8f\u65e0\u5173\u3002 (2) \u4f18\u70b9 \u7b80\u5355\u7a33\u5b9a\uff0c\u5229\u4e8e\u786c\u4ef6\u5b9e\u73b0\u3001\u4e0d\u9700\u8981\u6574\u4e2a\u573a\u666f\u7684\u51e0\u4f55\u6570\u636e (3) \u7f3a\u70b9 \u9700\u8981\u4e00\u4e2a\u989d\u5916\u7684 Z \u7f13\u51b2\u5668\u3001\u6bcf\u4e2a\u591a\u8fb9\u5f62\u5360\u636e\u7684\u6bcf\u4e2a\u50cf\u7d20\u5904\u90fd\u8981\u8ba1\u7b97\u6df1\u5ea6\u503c\uff0c\u8ba1\u7b97\u91cf\u5927 OpenGL\u76f8\u5173\u51fd\u6570 glClear ( GL_DEPTH_BUFFER_BIT ) //\u6df1\u5ea6\u7f13\u5b58\u521d\u59cb\u5316 \uff08 1 \uff09 \u5728\u6bcf\u663e\u793a\u65b0\u7684\u4e00\u5e27\u524d\u6e05\u9664 \uff08 2 \uff09 \u8bbe\u7f6e\u7684\u9ed8\u8ba4\u503c\u4e3a1 \uff08 3 \uff09 \u8bbe\u7f6e\u521d\u59cb\u503c \uff1a glClearDepth \uff08 maxDepth \uff09 \uff08 4 \uff09 OpenGL\u5141\u8bb8\u6bcf\u4e2a\u50cf\u7d20\u7684\u6df1\u5ea6\u8303\u56f4\u662f0 . .1 \uff0c \u6700\u5927\u503c\u4e3a1\u4e3a\u6700\u8fdc\u70b9 \uff0c \u524d\u9762\u7269\u4f53\u6df1\u5ea6\u503c\u5c0f \u3002 glEnable ( GL_DEPTH_TEST ); //\u6fc0\u6d3b\u51fd\u6570(\u9ed8\u8ba4\u4e3a\u4e0d\u6fc0\u6d3b\uff09 \u6df1\u5ea6\u6d4b\u8bd5\u6bd4\u8f83 \uff1a glDepthFunc ( mode ) \uff0c mode\u53d6GL_LESS \u65f6 \uff0c \u6df1\u5ea6\u503c\u5c0f \uff08 \u8fd1\u5904 \uff09 \u7684\u663e\u793a \uff1b \u53d6GL_GREATER \u65f6 \uff0c \u6df1\u5ea6\u503c\u5927 \uff08 \u8fdc\u5904 \uff09 \u7684\u663e\u793a \u3002 \u7b80\u5355\u5149\u7167\u6a21\u578b \u5f15\u8a00 \u5149\u4f5c\u7528\uff1a\u53cd\u5c04\u3001\u900f\u5c04\uff08\u900f\u660e\u7269\u4f53\uff09\u3001\u88ab\u7269\u4f53\u5438\u6536\u8f6c\u5316\u4e3a\u70ed\u80fd \u5047\u8bbe\uff1a\u7269\u4f53\u4e0d\u900f\u660e\uff0c\u5373\u6ca1\u6709\u900f\u5c04\u5149 \u5149\u79cd\u7c7b\uff1a\u73af\u5883\u5149\u3001\u6f2b\u53cd\u5c04\u5149\u548c\u955c\u9762\u53cd\u5c04\u5149 \u73af\u5883\u5149 \u5728\u7269\u4f53\u548c\u5468\u56f4\u73af\u5883\u4e4b\u95f4\u591a\u6b21\u53cd\u5c04\u540e\uff0c\u6700\u7ec8\u8fbe\u5230\u5e73\u8861\u65f6\u7684\u4e00\u79cd\u5149\uff0c\u53c8\u79f0\u4e3a\u80cc\u666f\u5149 \u5149\u5f3a\uff08\u5ea6\uff09\uff1a\u7a7a\u95f4\u4e0a\u5206\u5e03\u5747\u5300\uff0c\u5373\u4efb\u4f55\u4f4d\u7f6e\u548c\u65b9\u5411\u5149\u5f3a\u5ea6\u4e00\u6837\uff0c\u4eae\u5ea6\u503c\u8bb0\u4e3a I_a I_a \u53cd\u5c04\u7cfb\u6570\uff1a\u4e0e\u7269\u4f53\u8868\u9762\u6027\u8d28\u6709\u5173\uff0c\u51b3\u5b9a\u7269\u4f53\u8868\u9762\u5448\u73b0\u7684\u4eae\u5ea6\uff0c\u8bb0\u4e3a K_a K_a \u5149\u7167\u6a21\u578b\u65b9\u7a0b I_e = K_\u03b1*I_\u03b1 I_e = K_\u03b1*I_\u03b1 \uff0c I_e I_e \u4e3a\u7269\u4f53\u8868\u9762\u5448\u73b0\u7684\u4eae\u5ea6\u3002 ( I_a I_a \u53ef\u4ee5\u770b\u7740\u662f\u989c\u8272\u7684\u5206\u91cf\uff1b K_a K_a \u4e3a\u5bf9\u5e94\u7684\u5206\u91cf\u53cd\u5c04\u7cfb\u6570\uff09 \u6f2b\u53cd\u5c04 \u70b9\u5149\u6e90\uff1a\u5411\u5468\u56f4\u6240\u6709\u65b9\u5411\u53d1\u5c04\u7b49\u5f3a\u5ea6\u7684\u5149\u3002 \u6f2b\u53cd\u5c04\u5149\u662f\u7531\u7269\u4f53\u8868\u9762\u7684\u7c97\u7cd9\u4e0d\u5e73\u5f15\u8d77\u7684\uff0c\u5b83\u5747\u5300\u5730\u5411\u5404\u4e2a\u65b9\u5411\u4f20\u64ad\uff0c\u4e0e\u89c6\u70b9\u4f4d\u7f6e\u65e0\u5173\u3002 \u6f2b\u53cd\u5c04\u5149\u5728\u7a7a\u95f4\u5747\u5300\u5206\u5e03\uff0c\u53cd\u5c04\u5149\u5f3a I \u4e0e\u5165\u5c04\u5149\u7684\u5165\u5c04\u89d2\u03b8 \u7684\u4f59\u5f26\u6210\u6b63\u6bd4\uff0c\u5373\uff1a I_d=K_d*I_p*cos \\theta I_d=K_d*I_p*cos \\theta \u5176\u4e2d\uff0cKd \u662f\u6f2b\u53cd\u5c04\u7cfb\u6570\uff080\uff5e1\u4e4b\u95f4\u7684\u5e38\u6570\uff09\uff0c\u4e0e\u7269\u4f53\u8868\u9762\u6027\u8d28\u6709\u5173\uff1bIp \u662f\u5149\u6e90\u7684\u5149\u5f3a\uff1b\u03b8\u662f\u5165\u5c04\u5149\u7684\u5165\u5c04\u89d2\uff0c\u5373\u5165\u5c04\u5149\u4e0e\u7269\u4f53\u8868\u9762\u6cd5\u5411\u91cf\u4e4b\u95f4\u7684\u5939\u89d2\u3002 \u5411\u91cf\u8ba1\u7b97 \u8bbe\u7269\u4f53\u8868\u9762\u5728\u7167\u5c04\u70b9 P \u5904\u7684\u5355\u4f4d\u6cd5\u5411\u91cf\u4e3aN\uff0cP \u5230\u70b9\u5149\u6e90\u7684\u5355\u4f4d\u5411\u91cf\u4e3aL\uff0c\u5219\u4e0a\u5f0f\u53ef\u8868\u8fbe\u4e3a\u5982\u4e0b\u7684\u5411\u91cf\u5f62\u5f0f\uff1a I_d=K_d*I_p*(N\\cdot L) I_d=K_d*I_p*(N\\cdot L) \u591a\u4e2a\u5149\u6e90 \u628a\u5404\u4e2a\u5149\u6e90\u7684\u6f2b\u53cd\u5c04\u5149\u7167\u6548\u679c\u8fdb\u884c\u53e0\u52a0\uff1a I_d=K_d*\\sum_{i=1}^mI_{pi}*(N \\cdot L_i) I_d=K_d*\\sum_{i=1}^mI_{pi}*(N \\cdot L_i) \u6f2b\u53cd\u5c04\u5149\u548c\u73af\u5883\u5149\u76f8\u7ed3\u5408 I=I_e+I_d=I_\u03b1 I_\u03b1+I_p I_d (L\u2219N) I=I_e+I_d=I_\u03b1 I_\u03b1+I_p I_d (L\u2219N) \u955c\u9762\u53cd\u5c04\u5149\u548c\u51af\uff08Phong\uff09\u53cd\u5c04\u6a21\u578b \u9ad8\u5149\uff08high light\uff09\uff1a\u5149\u6ed1\u7269\u4f53\u8868\u9762\u5728\u70b9\u5149\u6e90\u7684\u7167\u5c04\u4e0b\u5f62\u6210\u4e00\u5757\u7279\u522b\u4eae\u7684\u533a\u57df \u955c\u9762\u53cd\u5c04\uff08Specular Reflection\uff09 \u7269\u4f53\u8868\u9762\u5bf9\u5165\u5c04\u5149\u7684\u53cd\u5c04 \u9075\u5faa\u53cd\u5c04\u5b9a\u5f8b \uff081\uff09\u53cd\u5c04\u5149\u4e0e\u5165\u5c04\u5149\u4f4d\u4e8e\u8868\u9762\u6cd5\u5411\u4e24\u4fa7 \uff082\uff09\u7406\u60f3\u53cd\u5c04\u9762\u800c\u8a00\uff1a\u5165\u5c04\u89d2\uff1d\u53cd\u5c04\u89d2 \u89c2\u5bdf\u8005\u5728\u53cd\u5c04\u65b9\u5411\u4e0a\u770b\u5230\u53cd\u5c04\u5149\u6700\u5f3a Phong\u6a21\u578b \u8ba1\u7b97\u516c\u5f0f\uff1a I_s=I_p K_s cos ^n \\alpha =I_P K_s (N \\cdot R) ^n I_s=I_p K_s cos ^n \\alpha =I_P K_s (N \\cdot R) ^n Ks\u662f\u7269\u4f53\u8868\u9762\u955c\u9762\u53cd\u5c04\u7cfb\u6570\uff0c\u5b83\u4e0e\u7269\u4f53\u5c5e\u6027\u6709\u5173\uff1b \u03b1 \u662f\u89c6\u7ebf\u4e0e\u53cd\u5c04\u65b9\u5411\u7684\u5939\u89d2\uff1b n \u4e3a\u955c\u9762\u9ad8\u5149\u7cfb\u6570\uff0c\u7528\u6765\u6a21\u62df\u955c\u9762\u53cd\u5c04\u5149\u5728\u7a7a\u95f4\u4e2d\u7684\u6c47\u805a\u7a0b\u5ea6\uff0c\u5b83\u662f\u4e00\u4e2a\u53cd\u6620\u7269\u4f53\u8868\u9762\u5149\u6cfd\u5ea6\u7684\u5e38\u6570\uff1b $cos^n \\alpha $\u8fd1\u4f3c\u5730\u63cf\u8ff0\u4e86\u955c\u9762\u53cd\u5c04\u5149\u7684\u7a7a\u95f4\u5206\u5e03\u3002 n\u8d8a\u5927\uff0c\u9ad8\u5149\u533a\u57df\u8870\u51cf\u8d8a\u5feb\uff0c\u9ad8\u5149\u533a\u57df\u8d8a\u5c0f\uff0c\u5e38\u89c4\u53d6\u503c 5-20\u3002 \u7b80\u5316Phong\u6a21\u578b \u5c40\u90e8\u5149\u7167\u65b9\u7a0b I=I_{\\alpha}+I_d+I_s=K_{\\alpha}I_{\\alpha}+I_p[K_d(N \\cdot L)+K_s(H \\cdot N) ^n] I=I_{\\alpha}+I_d+I_s=K_{\\alpha}I_{\\alpha}+I_p[K_d(N \\cdot L)+K_s(H \\cdot N) ^n] \u5f53\u5149\u6e90\u548c\u89c6\u70b9\u65e0\u7a77\u8fdc\u65f6\uff0c\u5bf9\u8868\u9762\u4e0a\u4efb\u610f\u4e00\u70b9\u800c\u8a00\uff0cL\u548cV\u56fa\u5b9a\u4e0d\u53d8\uff0cH\u53ea\u9700\u8ba1\u7b97\u4e00\u6b21\u3002 \u4ea7\u751f\u989c\u8272 \u524d\u9762\u7684\u5149\u7167\u6a21\u578b\u4ec5\u7528\u4e8e\u767d\u5149\uff0c\u53ea\u80fd\u4ea7\u751f\u7070\u5ea6 \u5f69\u8272\u6a21\u578b\u8ba1\u7b97 \u9009\u62e9\u5408\u9002\u6a21\u578b\uff08\u5982RGB\u3001HSV\u7b49\uff09\uff0c\u4e3a\u989c\u8272\u7684\u4e09\u4e2a\u5206\u91cf\u5206\u522b\u5efa\u7acb\u5149\u7167\u65b9\u7a0b\u3002 RGB\u6a21\u578b \u5149\u6e90\u7684\u989c\u8272 [I_{pR}, I_{pG}, I_{pB}] [I_{pR}, I_{pG}, I_{pB}] \uff0c\u73af\u5883\u5149\u7684\u989c\u8272 [I_{aR}, I_{aG}, I_{aB}] [I_{aR}, I_{aG}, I_{aB}] \u8868\u9762\u53cd\u5c04\u7cfb\u6570 \uff081\uff09\u73af\u5883\u53cd\u5c04\uff1a [KaR, KaG, KaB] \uff082\uff09\u6f2b\u53cd\u5c04\uff1a [KdR, KdG, KdB] \uff083\uff09\u955c\u9762\u53cd\u5c04\uff1a [KsR, KsG, KsB] \u5f69\u8272\u5149\u7167\u65b9\u7a0b\uff08\u6a21\u578b\uff09 f(d)\u4e3a\u5149\u7684\u8870\u51cf \u591a\u4e2a\u5149\u6e90 \u5982\u679c\u573a\u666f\u4e2d\u6709m\u4e2a\u5149\u6e90\uff0c\u90a3\u4e48\u7269\u4f53\u4e0a\u4efb\u4e00\u70b9\u7684\u4eae\u5ea6\u5e94\u8be5\u4e3am\u4e2a\u5149\u6e90\u7684\u8d21\u732e\u4e4b\u548c\u3002 \u5728RGB\u5f69\u8272\u6a21\u578b\u4e2d\uff0c\u03bb\u5206\u522b\u4e3aR\u3001G\u548cB\u3002 \u200b \u6ce8\u610f\uff1aI\u03bb\u53ef\u80fd\u4f1a\u8d85\u51fa\u7cfb\u7edf\u5141\u8bb8\u7684\u6700\u5927\u4eae\u5ea6\u503c\uff0c\u5904\u7406\u65b9\u6cd5 \u200b \uff081\uff09\u622a\u53bb\u8d85\u51fa\u90e8\u5206\uff0c\u8bbe\u7f6e\u4e3a\u6700\u5927\u503c \u200b \uff082\uff09\u9996\u5148\u8ba1\u7b97\u51fa\u6240\u6709\u4eae\u5ea6\u503c\uff0c\u518d\u8fdb\u884c\u53d8\u6362\uff08\u5982\u7f29\u653e\u53d8\u6362\uff09\u4f7f\u5176\u843d\u5728\u7cfb\u7edf\u89c4\u5b9a\u8303\u56f4\u4e4b\u5185 OpenGL\u76f8\u5173\u51fd\u6570 void glLight { if }[ v ]( GLenum light , GLenum pname , TYPE param ); //\u521b\u5efa\u5149\u6e90 void glMaterial { if }[ v ]( GLenum face , GLenum pname , TYPE param ); //\u8bbe\u7f6e\u6750\u8d28 glEnable ( GL_LIGHTING ); //\u5f00\u542f\u5149\u6e90 glEnable ( GL_LIGHT0 ); //\u5f00\u542f\u5149\u6e90 \u591a\u8fb9\u5f62\u7ed8\u5236\u65b9\u6cd5 \u5f53\u7ed8\u5236\u591a\u8fb9\u5f62\u65f6\u5165\u5c04\u5149\u77e2\u91cf\u53ca\u53cd\u5c04\u5149\u4e0e\u89c6\u7ebf\u5939\u89d2\u4e0d\u540c\uff0c\u6240\u4ee5\u989c\u8272\u4e0d\u540c\u3002 \u591a\u8fb9\u5f62\u5747\u5300\u7740\u8272 \u65b9\u6cd5 \u4efb\u53d6\u591a\u8fb9\u5f62\u4e0a\u4e00\u70b9\uff0c\u5229\u7528\u5149\u7167\u660e\u65b9\u7a0b\u8ba1\u7b97\u51fa\u5b83\u7684\u989c\u8272 \u7528\u8fd9\u4e2a\u989c\u8272\u586b\u5145\u6574\u4e2a\u591a\u8fb9\u5f62 \u9002\u5408\u4e8e\u5982\u4e0b\u60c5\u51b5 \u5149\u6e90\u5728\u65e0\u7a77\u8fdc\u5904\uff0cL\u00b7N \u76f8\u7b49 \u89c6\u70b9\u5728\u65e0\u7a77\u8fdc\u5904\uff0cH\u00b7N \u76f8\u7b49 \u591a\u8fb9\u5f62\u662f\u7269\u4f53\u8868\u9762\u7684\u7cbe\u786e\u8868\u793a\uff08\u591a\u8fb9\u5f62\u9762\u79ef\u8db3\u591f\u5c0f\uff09 \u7279\u70b9 \u4f18\u70b9\uff1a\u6bcf\u4e2a\u591a\u8fb9\u5f62\u53ea\u9700\u8ba1\u7b97\u4e00\u6b21\u5149\u7167\u660e\u65b9\u7a0b\uff0c\u901f\u5ea6\u5feb \u7f3a\u70b9\uff1a\u76f8\u90bb\u591a\u8fb9\u5f62\u989c\u8272\u8fc7\u6e21\u4e0d\u5149\u6ed1 Gouraud \u7740\u8272\u65b9\u6cd5\uff08\u989c\u8272\u63d2\u503c\u65b9\u6cd5\uff09 \u4e3b\u8981\u6b65\u9aa4 \uff081\uff09\u8ba1\u7b97\u591a\u8fb9\u5f62\u7684\u5355\u4f4d\u6cd5\u5411\u91cf \uff082\uff09\u8ba1\u7b97\u591a\u8fb9\u5f62\u9876\u70b9\u7684\u5355\u4f4d\u6cd5\u5411\u91cf\uff08\u5171\u4eab\u9876\u70b9\u7684\u591a\u8fb9\u5f62\u6cd5\u5411\u91cf\u7684\u5e73\u5747\u503c\uff09 \uff083\uff09\u5229\u7528\u5149\u7167\u660e\u65b9\u7a0b\u8ba1\u7b97\u9876\u70b9\u989c\u8272 \uff084\uff09\u5bf9\u591a\u8fb9\u5f62\u9876\u70b9\u989c\u8272\u8fdb\u884c\u53cc\u7ebf\u6027\u63d2\u503c\uff0c\u83b7\u5f97\u591a\u8fb9\u5f62\u5185\u90e8\u5404\u70b9\u7684\u989c\u8272 1. \u8ba1\u7b97\u591a\u8fb9\u5f62\u5355\u4f4d\u6cd5\u5411\u91cf <img src=\"https://pic.tim-wcx.ltd//img/20211210151447.png\" alt=\"image-20211210151447383\" style=\"zoom:67%;\" /> \u5185\u90e8\u70b9\u989c\u8272\u8ba1\u7b97\uff1a\u53cc\u7ebf\u6027\u63d2\u503c \u589e\u91cf\u6cd5\u4f18\u5316 Phong \u7740\u8272\u65b9\u6cd5\uff08\u6cd5\u5411\u63d2\u503c\u7740\u8272\u65b9\u6cd5\uff09 \u65b9\u6cd5\uff1a\u901a\u8fc7\u5bf9\u591a\u8fb9\u5f62\u9876\u70b9\u6cd5\u5411\u91cf\u8fdb\u884c\u63d2\u503c\uff0c\u83b7\u5f97\u591a\u8fb9\u5f62\u5185 \u90e8\u5404\u70b9\u7684\u6cd5\u5411\u91cf\uff0c\u518d\u5229\u7528\u5149\u7167\u65b9\u7a0b\u8ba1\u7b97\u5404\u70b9\u7684\u4eae\u5ea6 \u4e3b\u8981\u6b65\u9aa4\uff1a \uff081\uff09\u8ba1\u7b97\u591a\u8fb9\u5f62\u5355\u4f4d\u6cd5\u5411\u91cf \uff082\uff09\u8ba1\u7b97\u591a\u8fb9\u5f62\u9876\u70b9\u5355\u4f4d\u6cd5\u5411\u91cf\uff08\u4ee5\u4e0a\u4e24\u6b65\u540cGouraud\u7740\u8272\u65b9\u6cd5\uff09 \uff083\uff09\u5bf9\u591a\u8fb9\u5f62\u9876\u70b9\u6cd5\u5411\u91cf\u8fdb\u884c\u53cc\u7ebf\u6027\u63d2\u503c\uff0c\u83b7\u5f97\u5185\u90e8\u5404\u70b9\u7684\u6cd5\u5411\u91cf \uff084\uff09\u5229\u7528\u5149\u7167\u660e\u65b9\u7a0b\u8ba1\u7b97\u591a\u8fb9\u5f62\u5185\u90e8\u5404\u70b9\u989c\u8272 Phong\u63d2\u503c\u4f18\u5316\u540c\u9ad8\u6d1b\u5fb7\uff0c\u53ea\u662f\u5c06\u989c\u8272\u63d2\u503c\u66ff\u6362\u4e3a\u5411\u91cf\u63d2\u503c\uff0c\u626b\u63cf\u7ebf\u4f18\u5316\u540c\uff0c\u5728\u6b64\u7701\u7565\uff0c \u5747\u5300\u7740\u8272\u3001Gouraud \u548cPhong\u65b9\u6cd5\u6bd4\u8f83 \uff081\uff09\u5747\u5300\u7740\u8272\uff08Flat\uff09\u5757\u72b6\u73b0\u8c61\u660e\u663e\uff0c\u8ba1\u7b97\u5f00\u9500\u5c0f \uff082\uff09 Gouraud\u65b9\u6cd5\u5149\u53d8\u5316\u8fc7\u6e21\u4e0d\u8fde\u7eed\uff0c\u8ba1\u7b97\u5f00\u9500\u8f83\u5927 \uff083\uff09Phong\u65b9\u6cd5\u5149\u53d8\u5316\u8fc7\u6e21\u8fde\u7eed\uff0c\u8ba1\u7b97\u5f00\u9500\u5927 \u7eb9\u7406\u6620\u5c04 \u5f15\u8a00 \u5149\u7167\u6a21\u578b\u53ea\u80fd\u751f\u6210\u5149\u6ed1\u7684\u7269\u4f53\u8868\u9762 \u81ea\u7136\u754c\u4e2d\u7684\u7269\u4f53\u8868\u9762\u5177\u6709\u4e30\u5bcc\u7684\u7ec6\u8282\uff0c\u5982\u6728\u7eb9\u3001\u6854\u5b50\u51f9\u51f8\u8868\u9762\u3001\u6c99\u783e\u8def\u9762 \u4e30\u5bcc\u7684\u8868\u9762\u7ec6\u8282\u96be\u4ee5\u7528\u8ba1\u7b97\u673a\u56fe\u5f62\u65b9\u6cd5\u751f\u6210 \u91c7\u7528\u5c06\u56fe\u7247\u8d34\u5230\u7269\u4f53\u8868\u9762\u4e0a\u7684\u65b9\u6cd5\u7ed8\u5236 \u4ec0\u4e48\u662f\u7eb9\u7406\uff1f \u662f\u7269\u4f53\u8868\u9762\u7684\u7ec6\u5c0f\u7ed3\u6784\uff0c\u5b83\u53ef\u4ee5\u662f\u5149\u6ed1\u8868\u9762\u7684\u82b1\u7eb9\u3001\u56fe\u6848\uff0c\u5373\u989c\u8272\u7eb9\u7406(2D)\u3002 \u7eb9\u7406\u4e5f\u53ef\u4ee5\u662f\u7269\u4f53\u8868\u9762\u7684\u4e09\u7ef4\u7ed3\u6784 \u7eb9\u7406\u8fd8\u53ef\u4ee5\u662f\u7c97\u7cd9\u7684\u8868\u9762(\u5982\u6854\u5b50\u8868\u9762\u7684\u76b1\u7eb9)\uff0c\u79f0\u4e3a\u51e0\u4f55\u7eb9\u7406\uff0c\u662f\u57fa\u4e8e\u7269\u4f53\u8868\u9762\u7684\u5fae\u89c2\u51e0\u4f55\u5f62\u72b6\u7684\u8868\u9762\u7eb9\u7406\u3002 \u7eb9\u7406\u7a7a\u95f4\uff1a\u7eb9\u7406\u56fe\u6848\u6240\u5728\u7a7a\u95f4\uff0c\u8bb0\u4e3ast\u5750\u6807\u7cfb\uff08\u4e00\u822c\u662f\u5e73\u9762\uff09 \u7eb9\u7d20\uff08texel\uff09\uff1a\u7eb9\u7406\u6700\u5c0f\u5355\u5143\uff0c\u4f4d\u7f6e\u7531\u7eb9\u7406\u5750\u6807\uff08s\uff0ct\uff09\u6807\u8bc6 \u7eb9\u7406\u5750\u6807s\uff0ct\uff1a0\u52301\u95f4\u53d6\u503c \u56fe\u50cf\u50cf\u7d20\u5750\u6807\u89c4\u8303\u5316\u5230[0\u20261]\u533a\u95f4\u3002\u89c4\u8303\u5316\u540e\u65b9\u4fbf\u4f7f\u7528\u7eb9\u7406\u5750\u6807\u3002 \u7eb9\u7406\u6765\u6e90 \u6570\u5b57\u56fe\u50cf\uff0c\u7528\u4e8c\u7ef4\u6570\u7ec4\u8868\u793a \u6570\u5b66\u516c\u5f0f\u5b9a\u4e49\u7eb9\u7406 \u7eb9\u7406\u6620\u5c04\uff08Texture Mapping\uff09 \u5b9a\u4e49\uff1a\u5c06\u7eb9\u7406\u56fe\u6848\u6620\u5c04\u5230\u7269\u4f53\u8868\u9762\u4e0a\uff0c\u4ea7\u751f\u7269\u4f53\u8868\u9762\u7ec6\u8282\u7684\u8fc7\u7a0b \u989c\u8272\u8ba1\u7b97\u65b9\u6cd5 (1) \u7528\u8868\u9762\u4e0a\u70b9\u5bf9\u5e94\u7684\u7eb9\u7d20\u503c\u4ee3\u66ff\u8be5\u70b9\u7684\u6f2b\u53cd\u5c04\u7cfb\u6570 (2) \u7528\u8868\u9762\u4e0a\u70b9\u5bf9\u5e94\u7684\u7eb9\u7d20\u503c\u4ee3\u66ff\u8be5\u70b9\u7684\u989c\u8272\u503c \u7eb9\u7406\u5750\u6807\uff1a\u786e\u5b9a\u7eb9\u7406\u4e0e\u7269\u4f53\u8868\u9762\u7684\u5bf9\u5e94\u5173\u7cfb\uff08\u7eb9\u7d20\u4e0e\u9876\u70b9\uff09\uff0c\u53d8\u5316\u8303\u56f4[0,1]\u3002\u591a\u8fb9\u5f62\u6bcf\u4e2a\u9876\u70b9\u5bf9\u5e94\u4e00\u4e2a\u7eb9\u7d20\uff0c\u5185\u90e8\u70b9\u63d2\u503c\u8ba1\u7b97\u5bf9\u5e94\u7eb9\u7d20\u3002 \u5706\u67f1\u66f2\u9762\u7eb9\u7406\u6620\u5c04 P(\\theta,y)=(r cos \\theta,r sin \\theta),-\\frac{h}{2}\\leq y \\leq \\frac{h}{2} P(\\theta,y)=(r cos \\theta,r sin \\theta),-\\frac{h}{2}\\leq y \\leq \\frac{h}{2} \u5bf9\u5e94\u7684\u7eb9\u7406\u5750\u6807\uff1a s=\\frac{\\theta}{360},t=\\frac{y+\\frac{h}{2}}{h} s=\\frac{\\theta}{360},t=\\frac{y+\\frac{h}{2}}{h} \u7403\u9762\u66f2\u9762\u7eb9\u7406\u6620\u5c04 p(\\theta,\\phi)=(rcos\\theta cos\\phi,rsin \\phi,rsin\\theta cos\\phi) p(\\theta,\\phi)=(rcos\\theta cos\\phi,rsin \\phi,rsin\\theta cos\\phi) \u03b8\u548c\u03c6\u53d8\u5316\u8303\u56f4\u5206\u522b[0,360]\u548c[-90,90] \u5bf9\u5e94\u7684\u7eb9\u7406\u5750\u6807\uff1a s=\\frac{\\theta }{360},t=\\frac{\\phi}{180}+\\frac{1}{2} s=\\frac{\\theta }{360},t=\\frac{\\phi}{180}+\\frac{1}{2} s=\\frac{\\theta }{360},t=\\frac{sin \\phi }{2}+\\frac{1}{2} s=\\frac{\\theta }{360},t=\\frac{sin \\phi }{2}+\\frac{1}{2} \u5706\u73af\u9762 OpenGL\u51fd\u6570 \u7b80\u4ecb \u7eb9\u7406\u6620\u5c04\u662f\u4e00\u4e2a\u76f8\u5f53\u590d\u6742\u7684\u8fc7\u7a0b\uff0c\u6700\u57fa\u672c\u7684\u6267\u884c\u7eb9\u7406\u6620\u5c04\u6240\u9700\u7684\u6b65\u9aa4\u3002\u57fa\u672c\u6b65\u9aa4\u5982\u4e0b\uff1a \uff081\uff09\u5b9a\u4e49\u7eb9\u7406\uff1b\u7ed9\u7eb9\u7406\u6570\u636e \uff082\uff09\u63a7\u5236\u6ee4\u6ce2\uff1b\u91cd\u91c7\u6837\u65b9\u5f0f \uff083\uff09\u8bf4\u660e\u6620\u5c04\u65b9\u5f0f\uff1b \uff084\uff09\u6fc0\u6d3b\u7eb9\u7406\uff1b \uff085\uff09\u7ed8\u5236\u56fe\u5f62\u65f6\u9700\u8fdb\u884c\u7eb9\u7406\u6620\u5c04\uff0c\u5373\u7ed9\u51fa\u9876\u70b9\u7684\u7eb9\u7406\u5750\u6807\u548c\u51e0\u4f55\u5750\u6807\u3002 \u200b \u6ce8\u610f\uff1a\u7eb9\u7406\u6620\u5c04\u53ea\u80fd\u5728RGBA\u65b9\u5f0f\u4e0b\u6267\u884c\uff0c\u4e0d\u80fd\u8fd0\u7528\u4e8e\u989c\u8272\u8868\u65b9\u5f0f\u3002 ( 1 ) \u5b9a\u4e49\u7eb9\u7406 glGenTextures ( 1 , & uiTexture ); // GLuint uiTexture void glTexImage2D ( GLenum target , GLint level , Glint components , GLsizei width , glsizei height , GLint border , GLenum format , GLenum type , const GLvoid * pixels ); ( 2 ) \u7ed1\u5b9a\u56fe\u7247 gluBuild2DMipmaps ( GLenum target , Glint components , GLsizei width , glsizei height , GLenum format , GLenum type , const GLvoid * pixels ); ( 3 ) \u63a7\u5236\u6ee4\u6ce2 void glTexParameter { if }[ v ]( GLenum target , GLenum pname , TYPE param ); ( 4 ) \u8bbe\u7f6e\u7eb9\u7406\u6620\u5c04\u65b9\u5f0f void glTexEnv { if }[ v ]( GLenum target , GLenum pname , TYPE param ); ( 5 ) \u6fc0\u6d3b\u7eb9\u7406 glEnable ( GL_TEXTURE_2D ); ( 6 ) \u5b9a\u4e49\u7eb9\u7406\u5750\u6807 void glTexCoord { 1234 }{ sifd }[ v ]( TYPE coords ); \u6ce8\u610f \uff1a \u4f7f\u7528\u591a\u4e2a\u7eb9\u7406\u65f6 \uff0c \u9700\u8981\u5728\u5b9a\u4e49\u70b9\u7eb9\u7406\u5750\u6807\u4e4b\u524d \uff0c \u6307\u5b9a\u6240\u7528\u7eb9\u7406 \u3002 glBindTexture ( GL_TEXTURE_2D , id ); \u9634\u5f71 \u9634\u5f71\uff08Shadow\uff09 \u5149\u6e90\u4e0d\u80fd\u76f4\u63a5\u7167\u5c04\u5230\u7684\u533a\u57df \u7279\u70b9 \u4f4d\u4e8e\u9634\u5f71\u533a\u57df\u4e2d\u7684\u7269\u4f53\u8868\u9762\u88ab\u4f4d\u4e8e\u5b83\u548c\u5149\u6e90\u95f4\u7684\u7269\u4f53\u6240\u906e\u6321 \u5bf9\u5149\u6e90\u800c\u8a00\uff0c\u4f4d\u4e8e\u9634\u5f71\u4e2d\u7684\u7269\u4f53\u8868\u9762\u5373\u662f\u4e0d\u53ef\u89c1\u9762 \u751f\u6210\u7b97\u6cd5\uff1a\u4e0e\u6d88\u9690\u7b97\u6cd5\u672c\u8d28\u4e0a\u4e00\u81f4 \u5177\u6709\u9634\u5f71\u6548\u679c\u7684\u5149\u7167\u6a21\u578b \u5149\u6e90\u5bf9\u4f4d\u4e8e\u9634\u5f71\u4e2d\u7684\u70b9\u7684\u4eae\u5ea6\uff08\u989c\u8272\uff09\u6ca1\u6709\u8d21\u732e \uff081\uff09\u591a\u5149\u6e90\uff082\uff09\u989c\u8272\u5206\u91cf Z\u7f13\u51b2\u5668\u9634\u5f71\u7b97\u6cd5 \u6b65\u9aa4 \uff081\uff09\u5c06\u56fe\u5f62\u53d8\u6362\u5230\u4ee5\u5149\u6e90\u4e3a\u539f\u70b9\u7684\u5750\u6807\u7cfb\uff0c\u5229\u7528Z\u7f13\u51b2\u5668\u6d88\u9690\u7b97\u6cd5\uff0c\u6309\u5149\u7ebf\u65b9\u5411\u5bf9\u56fe\u5f62\u6d88\u9690\uff0c\u628a\u8ddd\u5149\u6e90\u6700\u8fd1\u7684\u7269\u4f53\u8868\u9762\u4e0a\u70b9\u7684\u6df1\u5ea6\u503c\u4fdd\u5b58\u5728Z\u7f13\u51b2\u5668\u4e2d\uff08\u79f0\u4e3a\u9634\u5f71\u7f13\u51b2\u5668\uff09 \uff082\uff09\u5229\u7528Z\u7f13\u51b2\u5668\u6d88\u9690\u7b97\u6cd5\u6309\u89c6\u7ebf\u65b9\u5411\u5bf9\u56fe\u5f62\u6d88\u9690\uff0c\u5c06\u5f97\u5230\u7684\u6bcf\u4e2a\u53ef\u89c1\u70b9\u53d8\u6362\u5230\u7b2c i \u4e2a\u5149\u6e90\u7684\u5750\u6807\u7cfb\u4e2d\uff0c\u82e5\u5b83\u5728\u5149\u6e90\u5750\u6807\u7cfb\u4e2d\u7684\u6df1\u5ea6\u503c\u5c0f\u4e8e\u9634\u5f71\u7f13\u51b2\u5668\u4e2d\u76f8\u5e94\u5355\u5143\u7684\u503c\uff0c\u5219\u8be5\u53ef\u89c1\u70b9\u4f4d\u4e8e\u9634\u5f71\u4e2d\uff08Si\uff1d0\uff09\uff0c\u5426\u5219\uff08 Si \uff1d1\uff09\uff0c\u518d\u7528\u5149\u7167\u6a21\u578b\u8ba1\u7b97\u989c\u8272\u3002 \u7279\u70b9\uff1a\u7b97\u6cd5\u7b80\u5355\uff0c\u8ba1\u7b97\u91cf\u5c0f\uff0c\u80fd\u5904\u7406\u590d\u6742\u666f\u7269\uff1b \u7f3a\u70b9\u662f\u6bcf\u4e2a\u5149\u6e90\u9700\u89811\u4e2aZ\u7f13\u51b2\u5668\uff0c\u9700\u8981\u7684\u5b58\u50a8\u7a7a\u95f4\u5927 \u63d0\u9ad8\u6d88\u9690\u7b97\u6cd5\u6548\u7387\u7684\u5e38\u7528\u65b9\u6cd5\uff1a\u8fde\u8d2f\u6027\u3001\u5305\u56f4\u76d2\u6280\u672f\u3001\u80cc\u9762\u5254\u9664\u3001\u533a\u57df\u5206\u5272\u6280\u672f\u3001\u7269\u4f53\u5206\u5c42\u8868\u793a\u7b49\u3002 \u7b2c\u4e5d\u7ae0 \u66f2\u7ebf\u4e0e\u66f2\u9762 \u00b6 \u53c2\u6570\u66f2\u7ebf\u57fa\u7840 \u66f2\u7ebf\u7684\u8868\u793a\u5f62\u5f0f \u4e3b\u8981\u6709\uff1a\u975e\u53c2\u6570\u8868\u793a\u548c\u53c2\u6570\u8868\u793a \u975e\u53c2\u6570\u8868\u793a \uff081\uff09\u663e\u5f0f\u8868\u793a \u5750\u6807\u95f4\u5efa\u7acb\u51fd\u6570\u5173\u7cfb \u4e0d\u80fd\u5efa\u7acb\u591a\u503c\u66f2\u7ebf y=f(x),z=g(x) y=f(x),z=g(x) \uff082\uff09\u9690\u5f0f\u8868\u793a \u770b\u505a\u662f\u4e24\u66f2\u9762\u7684\u4ea4 \u53ef\u4ee5\u5efa\u7acb\u591a\u503c\u66f2\u7ebf \u5750\u6807\u8ba1\u7b97\u76f8\u5bf9\u8f83\u590d\u6742 x^2+y^2=9,z=0 x^2+y^2=9,z=0 f(x,y,z)=0,g(x,y,z)=0 f(x,y,z)=0,g(x,y,z)=0 \u53c2\u6570\u8868\u793a \u53c2\u6570\u65b9\u7a0b\uff1a x=x(t),y=y(t),z=z(t),t \\in [a,b] x=x(t),y=y(t),z=z(t),t \\in [a,b] \u53c2\u6570\u8868\u793a\u7684\u4f18\u70b9 \u5bb9\u6613\u786e\u5b9a\u66f2\u7ebf\u8fb9\u754c\u3002\u7531\u53c2\u6570\u533a\u95f4\u786e\u5b9a \u8868\u793a\u5f62\u5f0f\u4e0d\u53d8\u6027\u3002\u4e0d\u4f9d\u8d56\u4e8e\u5750\u6807\u7cfb\u7684\u9009\u53d6 \u8868\u793a\u80fd\u529b\u5f3a\u3002\u5229\u4e8e\u63a7\u5236\u70b9\u6765\u63a7\u5236\u66f2\u7ebf\u5f62\u72b6\uff0c\u5982\u540e\u9762\u5c06\u8981\u5b66\u5230\u7684Bezier\u66f2\u7ebf \u53c2\u6570\u8868\u793a\u7684\u4f18\u70b9 \u5bb9\u6613\u786e\u5b9a\u66f2\u7ebf\u8fb9\u754c\u3002\u7531\u53c2\u6570\u533a\u95f4\u786e\u5b9a \u8868\u793a\u5f62\u5f0f\u4e0d\u53d8\u6027\u3002\u4e0d\u4f9d\u8d56\u4e8e\u5750\u6807\u7cfb\u7684\u9009\u53d6 \u8868\u793a\u80fd\u529b\u5f3a\u3002\u5229\u4e8e\u63a7\u5236\u70b9\u6765\u63a7\u5236\u66f2\u7ebf\u5f62\u72b6\uff0c\u5982\u540e\u9762\u5c06\u8981\u5b66\u5230\u7684Bezier\u66f2\u7ebf \u5207\u77e2\u91cf\u3001\u6cd5\u77e2\u91cf\u3001\u66f2\u7387 \u53c2\u6570\u8fde\u7eed\u6027 \u4f20\u7edf\u7684\u3001\u4e25\u683c\u7684\u8fde\u7eed\u6027 \u66f2\u7ebf P = P(t) \u5728 t\uff1dt0 \u5904n\u9636\u53c2\u6570\u8fde\u7eed\uff0c\u5982\u679c\u5b83\u5728 t0 \u5904n\u9636\u5de6\u53f3\u5bfc\u6570\u5b58\u5728\uff0c\u5e76\u4e14\u6ee1\u8db3 \u8bb0\u4e3aCn\uff08\u66f2\u7ebfn\u9636\u53c2\u6570\u8fde\u7eed\uff09 \u51e0\u4f55\u8fde\u7eed\u6027 \u3001 0\u9636\u51e0\u4f55\u8fde\u7eed \u79f0\u66f2\u7ebfP=P( t ) \u5728 t=t0 \u59040\u9636\u51e0\u4f55\u8fde\u7eed\uff0c\u5982\u679c\u5b83\u5728 t0 \u5904\u4f4d\u7f6e\u8fde\u7eed\uff0c\u5373 \u8bb0\u4e3a\uff1aGC0 1\u9636\u51e0\u4f55\u8fde\u7eed \u79f0\u66f2\u7ebf P=P(t) \u5728 t = t0 \u59041\u9636\u51e0\u4f55\u8fde\u7eed\uff0c\u5982\u679c\u5b83\u5728 t0\u5904 GC0 \uff0c\u5e76\u4e14\u5207\u77e2\u91cf\u65b9\u5411\u8fde\u7eed\uff0c\u5373 \u8bb0\u4e3a\uff1a GC1 \u53c2\u6570\u591a\u9879\u5f0f\u66f2\u7ebf n\u6b21\u591a\u9879\u5f0f\u66f2\u7ebf \u77e9\u9635\u8868\u793a \u52a0\u6743\u548c\u5f62\u5f0f \u7f3a\u70b9 Pi \u6ca1\u6709\u660e\u663e\u7684\u51e0\u4f55\u610f\u4e49\u3002Pi \u4e0e\u66f2\u7ebf\u7684\u5173\u7cfb\u4e0d\u660e\u786e\uff0c\u5bfc\u81f4\u66f2\u7ebf\u7684\u5f62\u72b6\u63a7\u5236\u56f0\u96be \u57fa\u77e9\u9635\u8868\u793a \u77e9\u9635\u5206\u89e3 C=G \\cdot M C=G \\cdot M P(t)=G \\cdot M \\cdot T, t \\in [0,1] P(t)=G \\cdot M \\cdot T, t \\in [0,1] \u51e0\u4f55\u77e9\u9635 $G = [G_0.G_1 \u2026 G_n]$ \u63a7\u5236\u9876\u70b9 Gi \u57fa\u77e9\u9635M\uff1aMT \u786e\u5b9a\u4e86\u4e00\u7ec4\u57fa\u51fd\u6570 \u57fa\u77e9\u9635\u51b3\u5b9a\u4e86\u591a\u9879\u5f0f\u66f2\u7ebf\u7684\u6027\u8d28 \u7ed8\u5236\u65b9\u6cd5 Bezier\u57fa\u51fd\u6570 \u5b9a\u4e49 \u6027\u8d28 \u6b63\u6027\uff1a BEZ_{i,n}(t) \\geq 0 ,t \\in [0,1] BEZ_{i,n}(t) \\geq 0 ,t \\in [0,1] \u6743\u6027\uff1a \\sum _{i=0}^n BEZ_{i,n}(t)=1,t \\in [0,1 ] \\sum _{i=0}^n BEZ_{i,n}(t)=1,t \\in [0,1 ] \u5bf9\u79f0\u6027\uff1a \u964d\u9636\u516c\u5f0f\uff1a \u5347\u9636\u516c\u5f0f BEZier\u66f2\u7ebf \u5b9a\u4e49 \u5982\u4e0b\u5f62\u5f0f\u7684 n \u6b21\u591a\u9879\u5f0f\u79f0\u4e3a n \u6b21 Bezier\u66f2\u7ebf\uff1a \u63a7\u5236\u9876\u70b9\uff1aPi\uff08i\uff1d0\uff0c1\uff0c\u2026 \uff0c n\uff09 \u63a7\u5236\u591a\u8fb9\u5f62\uff1a P0P1 \u2026 Pn\uff0c\u66f2\u7ebf\u662f\u63a7\u5236\u9876\u70b9\u7684\u52a0\u6743\u548c \uff08\u6743\u662f\u57fa\u51fd\u6570\u7684\u503c\uff09 \u6027\u8d28 \u7aef\u70b9\u6027\u8d28 \u7aef\u70b9\u5207\u77e2\u91cf \u5bfc\u6570\u66f2\u7ebf n\u6b21Bezier\u66f2\u7ebf P(t) \u7684\u5bfc\u6570\u66f2\u7ebf P\u2019(t) \u662f n\uff0d1\u6b21Bezier\u66f2\u7ebf \u4eff\u5c04\u4e0d\u53d8\u6027 \u51e0\u4f55\u6027\u8d28\u4e0d\u968f\u5750\u6807\u51e0\u4f55\u53d8\u6362\u800c\u53d8\u6362\uff08\u5f62\u72b6\u3001\u66f2\u7387\u7b49\uff09\u4eff\u5c04\u53d8\u6362\u4e0d\u6539\u53d8\u66f2\u7ebf\u7684\u8868\u793a\u5f62\u5f0f\u3002 \u5bf9Bezier\u66f2\u7ebf\u7684\u51e0\u4f55\u53d8\u6362\u53ea\u8981\u4f5c\u7528\u4e8e\u63a7\u5236\u9876\u70b9\u5373\u53ef\u3002 \u51f8\u5305\u6027 \u51f8\u96c6\uff1a {Pi}\u7684\u51f8\u96c6\u662f\u6307\u5305\u542b\u8fd9\u4e9b\u70b9\u7684\u51f8\u591a\u8fb9\u5f62 \u51f8\u5305\uff1a {Pi}\u7684\u51f8\u5305\u662f\u6307\u5305\u542b\u8fd9\u4e9b\u70b9\u7684\u6700\u5c0f\u51f8\u96c6 Bezier\u66f2\u7ebf\u4f4d\u4e8e\u5176\u63a7\u5236\u9876\u70b9\u7684\u51f8\u5305\u4e4b\u5185 \u5e73\u9762\u66f2\u7ebf\u7684\u4fdd\u578b\u6027 \u4fdd\u51f8\u6027\uff1a\u5982\u679c\u591a\u8fb9\u5f62\u662f\u51f8\u7684\uff0c\u90a3\u4e48Bezier\u66f2\u7ebf\u4e5f\u662f\u51f8\u7684 \u53d8\u5dee\u7f29\u51cf\u6027\uff1a\u5e73\u9762\u5185\u4efb\u4e00\u76f4\u7ebf\u4e0eBezier\u66f2\u7ebf\u7684\u4ea4\u70b9\u4e2a\u6570\u4e0d\u591a\u4e8e\u8be5\u76f4\u7ebf\u4e0e\u63a7\u5236\u591a\u8fb9\u5f62\u7684\u4ea4\u70b9\u4e2a\u6570\u3002\u8bf4\u660eBezier\u66f2\u7ebf\u6bd4\u63a7\u5236\u591a\u8fb9\u5f62\u7684\u6ce2\u52a8\u5c0f\uff0c\u66f4\u5149\u987a \u62df\u5c40\u90e8\u6027 \u5c40\u90e8\u6027\u6307\u79fb\u52a8\u63a7\u4e00\u4e2a\u5236\u9876\u70b9\u65f6\uff0c\u53ea\u5f71\u54cd\u66f2\u7ebf\u7684\u5c40\u90e8\u3002 \u79fb\u52a8\u63a7\u5236\u9876\u70b9Pi \u65f6\uff0c\u5bf9\u5e94\u53c2\u6570 t\uff1di /n \u7684\u66f2\u7ebf\u4e0a\u7684\u70b9\u53d8\u52a8\u6700\u5927\uff0c\u8fdc\u79bb i/n \u7684\u66f2\u7ebf\u4e0a\u7684\u70b9\u53d8\u52a8\u8d8a\u6765\u8d8a\u5c0f \u4e00\u6b21Bezier\u66f2\u7ebf n = 1\u65f6\uff0c\u6709\u4e24\u4e2a\u63a7\u5236\u70b9 P0 \u548c P1 \uff0cBezier\u591a\u9879\u5f0f\u662f\u4e00\u6b21\u591a\u9879\u5f0f\uff1a \u4e00\u6b21Bezier\u66f2\u7ebf\u662f\u8fde\u63a5\u8d77\u70b9P0\u548c\u7ec8\u70b9P1\u7684\u76f4\u7ebf\u6bb5 \u4e8c\u6b21Bezier\u66f2\u7ebf n=2\u65f6\uff0c\u67093\u4e2a\u63a7\u5236\u70b9P0\u3001P1\u548cP2\uff0cBezier\u591a\u9879\u5f0f\u662f\u4e8c\u6b21\u591a\u9879\u5f0f\uff1a \u4e09\u6b21Bezier\u66f2\u7ebf \u4e09\u6b21Hermite(\u5384\u5bc6\u591a)\u66f2\u7ebf \u7ed9\u5b9a4\u4e2a\u77e2\u91cfP0, P1, R0, R1 \uff0c\u79f0\u6ee1\u8db3\u4e0b\u5217\u6761\u4ef6\u7684\u4e09\u6b21\u591a\u9879\u5f0f\u66f2\u7ebf P(t) \u4e3aHermite \u66f2\u7ebf Bezier\u66f2\u7ebf\u7684\u79bb\u6563\u751f\u6210\u7b97\u6cd5 Horner\u7b97\u6cd5 \u53ea\u9002\u5b9c\u4f4e\u6b21Bezier\u66f2\u7ebf\uff08\u5982\u4e09\u6b21Bezier\u66f2\u7ebf\uff09 de Casteljau(\u5fb7 \u00b7 \u5361\u65af\u7279\u91cc\u5965)\u7b97\u6cd5 \u53ef\u7528Bezier\u964d\u9636\u516c\u5f0f\u8bc1\u660e Bezier\u66f2\u9762 \u5b9a\u4e49\uff1a\u5229\u7528\u4e24\u7ec4\u6b63\u4ea4\u7684 Bezier \u66f2\u7ebf\u903c\u8fd1\u7531\u63a7\u5236\u70b9\u7f51\u683c\u63cf\u8ff0\u7684\u66f2\u9762 \u5176\u4e2d pj, k \u662f\u7ed9\u5b9a\u7684 (m+1)\u00d7(n+1) \u4e2a\u63a7\u5236\u70b9\u7684\u4f4d\u7f6e Bezier \u66f2\u9762\u4e0e Bezier \u66f2\u7ebf\u6709\u76f8\u540c\u7684\u6027\u8d28","title":"\u8ba1\u7b97\u673a\u56fe\u5f62\u5b66"},{"location":"course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/#_1","text":"","title":"\u8ba1\u7b97\u673a\u56fe\u5f62\u5b66\u590d\u4e60"},{"location":"course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/#_2","text":"\u5b9a\u4e49 \u8ba1\u7b97\u673a\u56fe\u5f62\u5b66\u662f\u7814\u7a76\u901a\u8fc7\u8ba1\u7b97\u673a\u5c06\u6570\u636e\u8f6c\u6362\u4e3a\u56fe\u5f62\uff0c\u5e76\u5728\u4e13\u95e8\u7684\u663e\u793a\u8bbe\u5907\u4e0a\u663e\u793a\u7684\u539f\u7406\u3001\u65b9\u6cd5\u548c\u6280\u672f\u7684\u5b66\u79d1\u3002 \u8ba1\u7b97\u673a\u56fe\u5f62\u5b66\u5c31\u662f\u5e94\u7528\u8ba1\u7b97\u673a\u6280\u672f\u8fdb\u884c\u56fe\u5f62\u7684\u751f\u6210\u3001\u5904\u7406\u548c\u8f93\u51fa\u3002 \u8ba1\u7b97\u673a\u56fe\u5f62\u5b66\u4e0e\u5176\u4ed6\u5b66\u79d1\u7684\u5173\u7cfb \u56fe\u5f62\u7684\u57fa\u672c\u8981\u7d20 \u51e0\u4f55\u8981\u7d20\uff0c\u523b\u753b\u5bf9\u8c61\u7684\u8f6e\u5ed3\u3001\u5f62\u72b6\u7b49\u3002\u5982\u70b9\uff0c\u7ebf\uff0c\u591a\u8fb9\u5f62\uff0c\u591a\u9762\u4f53\u7b49\uff1b \u975e\u51e0\u4f55\u8981\u7d20\uff0c\u523b\u753b\u5bf9\u8c61\u7684\u989c\u8272\u3001\u6750\u8d28\u7b49\u3002\u5982\u989c\u8272\uff0c\u7eb9\u7406\u7b49\u3002 \u56fe\u5f62\u8868\u793a \u5b58\u50a8\u65b9\u6cd5 \u70b9\u9635\u6cd5 \u679a\u4e3e\u51fa\u56fe\u5f62\u4e2d\u6240\u6709\u7684\u70b9(\u5f3a\u8c03\u7531\u70b9<\u50cf\u7d20>\u6784\u6210\uff09\uff0c\u8fd9\u79cd\u8868\u793a\u7684\u56fe\u5f62\u79f0\u4e3a\u56fe\u50cf\u3002 \u53c2\u6570\u6cd5 \u7531\u56fe\u5f62\u7684\u5f62\u72b6\u53c2\u6570(\u65b9\u7a0b\u6216\u8868\u8fbe\u5f0f\u7684\u7cfb\u6570\uff0c\u7ebf\u6bb5\u7684\u7aef\u70b9\u5750\u6807\u7b49) + \u5c5e\u6027\u53c2\u6570(\u989c\u8272\u3001\u7ebf\u578b\u7b49) )\u6765\u8868\u793a\u56fe\u5f62\uff0c\u79f0\u4e3a\u56fe\u5f62\uff08graphics\uff09\uff0c\u5982\u5706\u53ef\u7528\u534a\u5f84\u3001\u5706\u5fc3\u5750\u6807\u548c\u989c\u8272\u8868\u793a \u8ba1\u7b97\u673a\u56fe\u5f62\u5b66\u57fa\u672c\u7814\u7a76\u5185\u5bb9 1\u3001\u56fe\u5f62\u7cfb\u7edf\uff08\u786c\u3001\u8f6f\u3001\u6807\u51c6\u5316\uff09 2\u3001\u57fa\u672c\u56fe\u5f62\u751f\u6210\uff1a\u5982\u4f55\u663e\u793a\u70b9\u3001\u7ebf\u6bb5\u3001\u591a\u8fb9\u5f62\u53ca\u5706\u7b49\u51e0\u4f55\u56fe\u5f62 3\u3001\u56fe\u5f62\u7684\u5904\u7406\uff1a\u51e0\u4f55\u53d8\u6362\uff08\u56fe\u5f62\u52a8\u8d77\u6765\uff09\uff1b\u6295\u5f71\u53d8\u6362\uff08\u5982\u4f55\u663e\u793a\u4e09\u7ef4\u56fe\u5f62\uff09\uff1b\u771f\u5b9e\u611f\u56fe\u5f62\uff08\u5149\u7167\u3001\u9634\u5f71\u3002\u3002\u3002\uff09 4\u3001\u7269\u4f53\u9020\u578b\uff1a\u5b9e\u4f53\u8868\u793a\uff1b\u66f2\u7ebf\u66f2\u9762\uff1b\u771f\u5b9e\u611f","title":"\u7b2c\u4e00\u7ae0 \u7eea\u8bba"},{"location":"course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/#_3","text":"\u8ba1\u7b97\u673a\u56fe\u5f62\u7cfb\u7edf \u7ec4\u6210 \u786c\u4ef6\u4e0e\u8f6f\u4ef6\u793a\u610f\u56fe \u786c\u4ef6\uff1a\u8f93\u5165\u8bbe\u5907\u3001\u8f93\u51fa\u8bbe\u5907\u3001\u5b58\u50a8\u8bbe\u5907\u3001\u56fe\u5f62\u5904\u7406\u8bbe\u5907 \u8f6f\u4ef6\uff1a\u8f6f\u4ef6\u5305\u3001\u5e94\u7528\u7a0b\u5e8f\u3001\u5e94\u7528\u6a21\u578b \u57fa\u672c\u529f\u80fd \u8ba1\u7b97\uff1a\u56fe\u5f62\u5904\u7406\uff08\u5982\u56fe\u5f62\u53d8\u6362\u3001\u5149\u7167\u7b49\uff09 \u5b58\u50a8\uff1a\u8fdc\u7a0b\u548c\u672c\u673a \u8f93\u5165\uff1a\u4eba\u673a\u4ea4\u4e92\u53ca\u6570\u636e\u6587\u4ef6\u7b49 \u8f93\u51fa\uff1a\u663e\u793a\u5668\u3001\u6253\u5370\u673a\u7b49 \u5bf9\u8bdd\u56fe\u5f62\uff1a\u4eba\u673a\u4ea4\u4e92 \u663e\u793a\u8bbe\u5907 \u4e24\u79cd\u8bbe\u5907 \u9634\u6781\u5c04\u7ebf\u7ba1CRT (Cathode Ray Tube) \u7279\u70b9\uff1a\u4eae\u5ea6\u9ad8\u3001\u5bf9\u6bd4\u5ea6\u597d\u3001\u8272\u5f69\u9c9c\u8273 \u7f3a\u70b9\uff1a\u4f53\u79ef\u5927\uff0c\u7b28\u91cd \u5e73\u677f\u578b\u663e\u793a\u5668\uff1a\u6db2\u6676\u3001\u7b49\u79bb\u5b50 \u7279\u70b9\uff1a\u5668\u4ef6\u8584\uff0c\u9002\u5408\u4fbf\u643a \u7f3a\u70b9\uff1a\u4eae\u5ea6\u548c\u5bf9\u6bd4\u5ea6\u76f8\u5bf9\u8f83\u4f4e\u3001\u8272\u5f69\u4e0d\u591f\u9c9c\u8273\uff0c\u4ef7\u683c\u504f\u9ad8 CRT \u57fa\u672c\u539f\u7406 \u4e00\u79cd\u771f\u7a7a\u5668\u4ef6\uff0c\u5b83\u5229\u7528\u7535\u78c1\u573a\u4ea7\u751f\u9ad8\u901f\u7684\u3001\u7ecf\u8fc7\u805a\u7126\u7684\u7535\u5b50\u675f\uff0c\u504f\u8f6c\u5230\u5c4f\u5e55\u7684\u4e0d\u540c\u4f4d\u7f6e\uff0c\u8f70\u51fb\u5c4f\u5e55\u8868\u9762\u7684\u8367\u5149\u6750\u6599\uff0c\u4ece\u800c\u4ea7\u751f\u53ef\u89c1\u7684\u56fe\u5f62 \u7ec4\u6210 \u7535\u5b50\u67aa\u3001\u805a\u7126\u7cfb\u7edf\u3001\u52a0\u901f\u7535\u6781\u3001\u504f\u8f6c\u7cfb\u7edf\u3001\u8367\u5149\u5c4f \u7535\u5b50\u67aa \u7535\u706f\u4e1d\uff0c\u9634\u6781\u548c\u63a7\u5236\u6805\u7ec4\u6210 \u706f\u4e1d\uff1a\u4ea7\u751f\u70ed\u91cf \u9634\u6781\uff1a\u7531\u706f\u4e1d\u52a0\u70ed\u53d1\u51fa\u7535\u5b50\u675f \u63a7\u5236\u6805\uff1a\u52a0\u4e0a\u8d1f\u7535\u538b\u540e\uff0c\u80fd\u591f\u63a7\u5236\u901a\u8fc7\u5176\u4e2d\u5c0f\u5b54\u7684\u5e26\u8d1f\u7535\u7684\u7535\u5b50\u675f\u7684\u5f3a\u5f31\u3002\u901a\u8fc7\u8c03\u8282\u8d1f\u7535\u538b\u9ad8\u4f4e\u6765\u63a7\u5236\u7535\u5b50\u6570\u91cf\uff0c\u5373\u63a7\u5236\u8367\u5149\u5c4f\u4e0a\u76f8\u5e94\u70b9\u7684\u4eae\u5ea6 \u7535\u5b50\u67aa \u7535\u706f\u4e1d\uff0c\u9634\u6781\u548c\u63a7\u5236\u6805\u7ec4\u6210 \u706f\u4e1d\uff1a\u4ea7\u751f\u70ed\u91cf \u9634\u6781\uff1a\u7531\u706f\u4e1d\u52a0\u70ed\u53d1\u51fa\u7535\u5b50\u675f \u63a7\u5236\u6805 \u52a0\u4e0a\u8d1f\u7535\u538b\u540e\uff0c\u80fd\u591f\u63a7\u5236\u901a\u8fc7\u5176\u4e2d\u5c0f\u5b54\u7684\u5e26\u8d1f\u7535\u7684\u7535\u5b50\u675f\u7684\u5f3a\u5f31\u3002\u901a\u8fc7\u8c03\u8282\u8d1f\u7535\u538b\u9ad8\u4f4e\u6765\u63a7\u5236\u7535\u5b50\u6570\u91cf\uff0c\u5373\u63a7\u5236\u8367\u5149\u5c4f\u4e0a\u76f8\u5e94\u70b9\u7684\u4eae\u5ea6 \u52a0\u901f\u7535\u6781 \u52a0\u6b63\u7684\u9ad8\u538b\u7535\uff08\u51e0\u4e07\u4f0f\uff09 \u4f7f\u7535\u5b50\u675f\u9ad8\u901f\u8fd0\u52a8 \u504f\u8f6c\u7cfb\u7edf \u63a7\u5236\u7535\u5b50\u675f\uff0c\u9759\u7535\u573a\u6216\u78c1\u573a\uff0c\u4ea7\u751f\u504f\u8f6c \u6700\u5927\u504f\u8f6c\u89d2\u662f\u8861\u91cf\u7cfb\u7edf\u6027\u80fd\u7684\u6700\u91cd\u8981\u7684\u6307\u6807\uff0c\u663e\u793a\u5668\u957f\u77ed\u4e0e\u6b64\u6709\u5173 \u8367\u5149\u5c4f \u8367\u5149\u7269\u8d28\uff1a\u5438\u6536\u7535\u5b50\u675f\u800c\u53d1\u5149 \u6301\u7eed\u53d1\u5149\u65f6\u95f4\uff1a\u7535\u5b50\u675f\u79bb\u5f00\u67d0\u70b9\u540e\uff0c\u8be5\u70b9\u7684\u4eae\u5ea6\u503c\u8870\u51cf\u5230\u521d\u59cb\u503c1/10 \u6240\u9700\u7684\u65f6\u95f4 \u5237\u65b0(Refresh)\uff1a\u4e3a\u4e86\u8ba9\u8367\u5149\u7269\u8d28\u4fdd\u6301\u4e00\u4e2a\u7a33\u5b9a\u7684\u4eae\u5ea6\u503c \u5237\u65b0\u9891\u7387\uff1a\u6bcf\u79d2\u949f\u91cd\u7ed8\u5c4f\u5e55\u7684\u6b21\u6570 CRT\u4ea7\u751f\u7a33\u5b9a\u56fe\u50cf\u6240\u9700\u8981\u7684\u6700\u5c0f\u5237\u65b0\u9891\u7387=1\u79d2/\u8367\u5149\u7269\u8d28\u7684\u6301\u7eed\u53d1\u5149\u65f6\u95f4 \u4f8b\uff1a\u8367\u5149\u7269\u8d28\u7684\u6301\u7eed\u53d1\u5149\u65f6\u95f440\u6beb\u79d2\uff0c\u5237\u65b0\u9891\u7387\u5c31\u662f 1000/40=25Hz \u5f69\u8272CRT \u5c04\u7ebf\u7a7f\u900f\u6cd5 \u539f\u7406\uff1a\u4e24\u5c42\u8367\u5149\u6d82\u5c42\uff0c\u7ea2\u8272\u5149\u548c\u7eff\u8272\u5149\u4e24\u79cd\u53d1\u5149\u7269\u8d28\uff0c\u7535\u5b50\u675f\u8f70\u51fb\u7a7f\u900f\u8367\u5149\u5c42\u7684\u6df1\u6d45\uff0c\u51b3\u5b9a\u6240\u4ea7\u751f\u7684\u989c\u8272 \u5e94\u7528\uff1a\u4e3b\u8981\u7528\u4e8e\u753b\u7ebf\u663e\u793a\u5668 \u7279\u70b9\uff1a\u4f18\u70b9\u662f\u6210\u672c\u4f4e\uff1b\u7f3a\u70b9\u662f\u53ea\u80fd\u4ea7\u751f\u6709\u9650\u51e0\u79cd\u989c\u8272 \u5f71\u5b54\u677f\u6cd5 \u5e94\u7528\uff1a\u4e3b\u8981\u7528\u4e8e\u5149\u6805\u626b\u63cf\u663e\u793a\u5668 \u7ed3\u6784\uff1a\u5916\u5c42\u73bb\u7483\u3001\u8367\u5149\u6d82\u5c42\u548c\u5f71\u5b54\u677f\uff0c\u5f71\u5b54\u677f\u88ab\u5b89\u88c5\u5728\u8367\u5149\u5c4f\u7684\u5185\u8868\u9762\uff0c\u7528\u4e8e\u7cbe\u786e\u5b9a\u4f4d\u50cf\u7d20\u7684\u4f4d\u7f6e \u5de5\u4f5c\u539f\u7406\uff1a\u6bcf\u4e2a\u50cf\u7d20\u5904\u67093\u4e2a\u8367\u5149\u70b9\uff0c\u5448\u4e09\u89d2\u5f62\u6392\u5217\u3002\u4e09\u652f\u7535\u5b50\u67aa\u5bf9\u5e94\u7ea2\u3001\u7eff\u3001\u84dd\u4e09\u57fa\u8272\u3002\u7535\u5b50\u67aa\u3001\u5f71\u5b54\u677f\u4e2d\u7684\u4e00\u4e2a\u5c0f\u5b54\u548c\u8367\u5149\u70b9\u5448\u4e00\u76f4\u7ebf\uff1b\u6bcf\u4e2a\u5c0f\u5b54\u4e0e\u4e00\u4e2a\u50cf\u7d20\uff08\u5373\u4e09\u4e2a\u8367\u5149\u70b9\uff09\u5bf9\u5e94\u3002 \u4eae\u5ea6\u8c03\u8282\uff1a\u5404\u7535\u5b50\u67aa\u53d1\u751f\u7684\u7535\u5b50\u6570\u76ee\uff0c\u53ef\u63a7\u5236\u5404\u8272\u5149\u70b9\u4eae\u5ea6 \u6db2\u6676\u663e\u793a\u5668LCD \u5728\u6db2\u6676\u5206\u5b50\u4e24\u7aef\u6240\u52a0\u7535\u538b\u7684\u4e0d\u540c\uff0c\u6db2\u6676\u5206\u5b50\u7684\u7ffb\u8f6c\u7a0b \u5ea6\u4e0d\u540c\uff0c\u6839\u636e\u6db2\u6676\u89d2\u5ea6\u7684\u4e0d\u540c\u900f\u8fc7\u5149\u7684\u504f\u632f\u6027\u4e5f\u4e0d\u540c\uff1b \u6db2\u6676\u53ef\u4ee5\u88ab\u5149\u7a7f\u900f\uff0c\u5e76\u5f71\u54cd\u5149\u7684\u504f\u632f\u6027\uff1b \u6db2\u6676\u7684\u7535\u5149\u6548\u5e94\uff1a\u5f53\u6db2\u6676\u5206\u5b50\u7684\u67d0\u79cd\u6392\u5217\u72b6\u6001\u5728\u7535\u573a\u4f5c\u7528\u4e0b\u53d8\u4e3a\u53e6\u4e00\u79cd\u6392\u5217\u72b6\u6001\u65f6\uff0c\u6db2\u6676\u7684\u5149\u5b66\u6027\u8d28\u968f\u4e4b\u6539\u53d8\u3002 \u6db2\u6676\u663e\u793a\u7684\u673a\u7406\uff1a\u901a\u8fc7\u80fd\u963b\u585e\u6216\u4f20\u9012\u5149\u7684\u6db2\u6676\u6750\u6599\uff0c\u4f20\u9012\u6765\u81ea\u5468\u56f4\u7684\u6216\u5185\u90e8\u5149\u6e90\u7684\u504f\u632f\u5149 \u7ec4\u6210\uff1a\u5149\u6e90\u3001\u5782\u76f4\u504f\u5149\u677f\u3001\u73bb\u7483\u7535\u6781\u3001\u6db2\u6676\u3001\u73bb\u7483\u7535\u6781\u3001\u6c34\u5e73\u504f\u5149\u677f \u6bd4\u8f83 \u5171\u540c\u7279\u70b9 \u90fd\u662f\u901a\u8fc7\u5355\u4e2a\u53d1\u5149\u5143\u7d20\uff08\u70b9\uff0c\u50cf\u7d20\uff09\u6765\u663e\u793a\u56fe\u5f62\u6216\u6587\u5b57\u3002 \u4e0d\u540c\u70b9 \uff081\uff09LCD\u4f53\u79ef\u5c0f\uff0c\u539a\u5ea6\u8584\uff0c\u91cd\u91cf\u8f7b\uff0c\u8017\u80fd\u5c11\uff0c\u8f90\u5c04\u5f88\u5c11\u3002\uff082\uff09CRT\u663e\u793a\u4eae\u5ea6\u9ad8\uff0c\u8272\u5f69\u9c9c\u8273\uff0c\u5206\u8fa8\u7387\u9ad8\u3002 \u6027\u80fd\u6307\u6807 \u50cf\u7d20(Pixel: Picture Cell)\uff1a\u6784\u6210\u5c4f\u5e55\uff08\u56fe\u50cf\uff09\u7684\u6700\u5c0f\u5143\u7d20 \u5206\u8fa8\u7387(Resolution)\uff1aCRT\u5728\u6c34\u5e73\u6216\u7ad6\u76f4\u65b9\u5411\u5355\u4f4d\u957f\u5ea6\u4e0a\u80fd\u8bc6\u522b\u7684\u6700\u5927\u50cf\u7d20\u4e2a\u6570\uff0c\u5355\u4f4d\u901a\u5e38\u4e3adpi\uff08dots per inch) \u5206\u8fa8\u7387\u8d8a\u9ad8\u663e\u793a\u7684\u56fe\u5f62\u5c31\u8d8a\u7cbe\u7ec6 \u663e\u793a\u7cfb\u7edf \u4e3b\u8981\u7ec4\u6210 \u663e\u793a\u8bbe\u5907\uff1a\u663e\u793a\u5668 \u89c6\u9891\u63a7\u5236\u5668\uff1a\u63a7\u5236\u663e\u793a\u8bbe\u5907\uff08\u6709\u7684\u542b\u56fe\u5f62\u52a0\u901f\u5904\u7406\u5668\uff09\uff0c\u901a\u8fc7\u8bbf\u95ee\u5e27\u7f13\u5b58\u6765\u5237\u65b0\u5c4f\u5e55 \u663e\u793a\u7f13\u51b2\u5b58\u50a8\u5668\uff08\u5e27\u7f13\u5b58\uff09\uff1a\u53ef\u4ee5\u5728\u5185\u5b58\u6216\u663e\u793a\u63a7\u5236\u5668\u4e2d \u663e\u793a\u7cfb\u7edf \u968f\u673a\u626b\u63cf\uff08random scan\uff09\uff1a\u7535\u5b50\u675f\u53ef\u4ee5\u4efb\u610f\u79fb\u52a8\u3002\u753b\u7ebf\u8bbe\u5907 \u7279\u70b9\uff1a\u7535\u5b50\u675f\u53ef\u968f\u610f\u79fb\u52a8\uff0c\u53ea\u626b\u63cf\u8367\u5c4f\u4e0a\u8981\u663e\u793a\u7684\u90e8\u5206\u50cf\u7d20\u3001\u5bf9\u5e94\u7684\u663e\u793a\u5668\u4e3a\u753b\u7ebf\u8bbe\u5907 \u903b\u8f91\u90e8\u4ef6\uff1a\u5237\u65b0\u5b58\u50a8\u5668(Refreshing Buffer)\u3001\u663e\u793a\u5904\u7406\u5668\uff08DPU: Display Processing Unit\u3001CRT \u5149\u6805\u626b\u63cf\uff08raster scan\uff09\uff1a\u7535\u5b50\u675f\u6309\u56fa\u5b9a\u626b\u63cf\u7ebf\u548c\u6b21\u5e8f\u8fdb\u884c\u3002\u753b\u70b9\u8bbe\u5907 \u57fa\u672c\u6982\u5ff5 \u57fa\u672c\u539f\u7406\uff1a\u7535\u5b50\u675f\u6309\u56fa\u5b9a\u7684\u626b\u63cf\u7ebf\u548c\u626b\u63cf\u987a\u5e8f\u4ece\u5de6\u5230\u53f3\u3001\u81ea\u4e0a\u800c\u4e0b\u8fdb\u884c\u626b\u63cf\u3002 \u57fa\u672c\u6982\u5ff5\uff1a\u626b\u63cf\u7ebf\uff1a\u4e00\u6761\u6c34\u5e73\u7ebf \u5e27\uff08frame\uff09\uff1a1\u6b21\u626b\u63cf\u751f\u6210\u7684\u56fe\u50cf \u6c34\u5e73\u56de\u626b\u671f\uff1a\u6c34\u5e73\u7ebf\u95f4\u7684\u56de\u626b\u671f \u5782\u76f4\u56de\u626b\u671f\uff1a\u5e27\u95f4\u7684\u56de\u626b\u671f \u7ec4\u6210 \u5e27\u7f13\u51b2\u5b58\u50a8\u5668\uff08Frame Buffer)--\u5e27\u7f13\u5b58 \u89c6\u9891\u63a7\u5236\u5668\uff08Video Controller) \u663e\u793a\u5904\u7406\u5668\uff08Display Processor\uff09 \u663e\u793a\u5668\uff1aCRT\u3001\u6db2\u6676 \u5e27\u7f13\u5b58 \u4f5c\u7528\uff1a\u5b58\u50a8\u5c4f\u5e55\u4e0a\u50cf\u7d20\u7684\u989c\u8272\u503c \u5e27\u7f13\u5b58\u4e2d\u5355\u5143\u6570\u76ee\u4e0e\u663e\u793a\u5668\u4e0a\u50cf\u7d20\u7684\u6570\u76ee\u76f8\u540c\uff0c\u5355\u5143\u4e0e\u50cf\u7d20\u4e00\u4e00\u5bf9\u5e94\uff0c\u5404\u5355\u5143\u7684\u6570\u503c\u51b3\u5b9a\u4e86\u5176\u5bf9\u5e94\u50cf\u7d20\u7684\u989c\u8272\u3002 \u663e\u793a\u989c\u8272\u7684\u79cd\u7c7b\u4e0e\u5e27\u7f13\u5b58\u4e2d\u6bcf\u4e2a\u5355\u5143\u7684\u4f4d\u6570\u6709\u5173\u3002\u5982\uff1a\u9ed1\u767d\u663e\u793a\u7cfb\u7edf\u7684\u5e27\u7f13\u51b2\u5668\u7684\u6bcf\u4e2a\u5355\u5143\u53ea\u9700\u4e00\u4f4d\u3002 \u5e27\u7f13\u5b58\u5bb9\u91cf\uff1a\u5206\u8fa8\u7387M*N\u3001\u989c\u8272\u4e2a\u6570K \u4e0e\u7f13\u5b58\u5927\u5c0fV \u7684\u5173\u7cfb $V \\geq M*N* \\lceil log_2 K \\rceil $ \u76ee\u524d\u6709\u7684PC\u673a\u7684\u663e\u5b58\u5bb9\u91cf\u8fbe512M\u4ee5\u4e0a\uff0c\u6709\u5fc5\u8981\uff1f \u539f\u56e0\uff1a\u663e\u5b58\u8fd8\u5305\u62ec\u6df1\u5ea6\u7f13\u5b58\u3001\u7eb9\u7406\u5185\u5b58\u7b49 \u989c\u8272\u6a21\u578b \u4e09\u57fa\u8272 RGB\u4e09\u57fa\u8272\uff1a\u9762\u5411\u786c\u4ef6\u8bbe\u5907\uff08\u6444\u50cf\u673a\u3001\u626b\u63cf\u4eea\u548c\u6295\u5f71\u4eea\u7b49\uff09 CMY\u4e09\u57fa\u8272\uff1a\u4e09\u8865\u8272\uff1a \u84dd\u7eff(C, cyan)\uff0c\u54c1\u7ea2(M, magenta)\uff0c\u9ec4(Y, yellow) \u7528\u4e8e\u5f69\u8272\u6253\u5370 CMY\u4e0eRGB\u5173\u7cfb\uff1aR=1-C\u3001G=1-M\u3001B=1-Y \u89c6\u9891\u63a7\u5236\u5668 \u663e\u793a\u5904\u7406\u5668 \u4f5c\u7528\uff1a\u4ee3\u66ffCPU\u5b8c\u6210\u90e8\u5206\u56fe\u5f62\u5904\u7406\u529f\u80fd\uff0c\u626b\u63cf\u8f6c\u6362\u3001\u51e0\u4f55\u53d8\u6362\u3001\u88c1\u526a\u3001\u5149\u6805\u64cd\u4f5c\u3001\u7eb9\u7406\u6620\u5c04\u7b49\u7b49 \u5177\u6709\u4e13\u7528\u663e\u793a\u5904\u7406\u5668\u7684\u5149\u6805\u663e\u793a\u7cfb\u7edf\u7684\u7ed3\u6784 \u56fe\u5f62\u52a0\u901f\u5361 = \u89c6\u9891\u63a7\u5236\u5668 + \u663e\u5b58 + \u663e\u793a\u5904\u7406\u5668 \u663e\u5361=\u663e\u793a\u5904\u7406\u5668\u7684\u4e13\u7528\u5b58\u50a8\u5668+\u5e27\u7f13\u51b2\u5668+\u89c6\u9891\u63a7\u5236\u5668+\u663e\u793a\u5904\u7406\u5668 \u7279\u70b9 \u4f18\u70b9\uff1a\u6210\u672c\u4f4e\u3001\u6613\u4e8e\u7ed8\u5236\u586b\u5145\u56fe\u5f62\u3001\u8272\u5f69\u4e30\u5bcc\u3001\u5237\u65b0\u9891\u7387\u4e00\u5b9a\u3001\u4e0e\u56fe\u5f62\u7684\u590d\u6742\u7a0b\u5ea6\u65e0\u5173\u3001\u6613\u4e8e\u4fee\u6539\u56fe\u5f62 \u7f3a\u70b9\uff1a\u9700\u8981\u626b\u63cf\u8f6c\u6362\uff0c\u590d\u6742\u56fe\u5f62\u8ba1\u7b97\u91cf\u5927\u3001\u4f1a\u4ea7\u751f\u6df7\u6dc6\uff08\u8d70\u6837\uff09 \u8f6f\u4ef6\u7cfb\u7edf \u7b2c\u4e00\u5c42\u6b21\uff1a\u9762\u5411\u786c\u4ef6\u7cfb\u7edf \u89e3\u51b3\u56fe\u5f62\u8bbe\u5907\u4e0e\u8ba1\u7b97\u673a\u7684\u901a\u8baf\u63a5\u53e3\u7b49\u95ee\u9898\uff0c\u79f0\u4e3a\u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f \u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f\u73b0\u5728\u5df2\u88ab\u4f5c\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u4e00\u90e8\u5206\uff0c\u7531\u64cd\u4f5c\u7cfb\u7edf\u6216\u8bbe\u5907\u786c\u4ef6\u5382\u5546\u5f00\u53d1\uff1b \u7b2c\u4e8c\u5c42\u6b21\uff1a\u5efa\u7acb\u5728\u9a71\u52a8\u7a0b\u5e8f\u4e4b\u4e0a \u5b8c\u6210\u56fe\u5143\u7684\u751f\u6210\u3001\u8bbe\u5907\u7684\u7ba1\u7406\u7b49\u529f\u80fd \u8fd9\u4e2a\u5c42\u6b21\u4e0a\u7684\u56fe\u5f62\u652f\u6491\u8f6f\u4ef6\u5df2\u7ecf\u6807\u51c6\u5316\uff0c\u5982GKS\u3001PHIGS\u3001CGI\u7b49\uff1b \u7b2c\u4e09\u5c42\u6b21\uff1a\u9762\u5411\u7528\u6237 \u4e3b\u8981\u4efb\u52a1\u662f\u5efa\u7acb\u56fe\u5f62\u6570\u636e\u7ed3\u6784\uff0c\u5b9a\u4e49\u3001\u4fee\u6539\u548c\u8f93\u51fa\u56fe\u5f62 \u5177\u6709\u8f83\u5f3a\u7684\u4ea4\u4e92\u529f\u80fd\uff0c\u4f7f\u7528\u65b9\u4fbf\uff0c\u5bb9\u6613\u9605\u8bfb\uff0c\u4fbf\u4e8e\u7ef4\u62a4\u548c\u79fb\u690d OpenGL\u3001Direct3D\u5c5e\u4e8e\u8fd9\u4e00\u5c42\u6b21","title":"\u7b2c\u4e8c\u7ae0 \u8ba1\u7b97\u673a\u56fe\u5f62\u7cfb\u7edf\u6982\u8ff0"},{"location":"course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/#_4","text":"\u5149\u6805\u56fe\u5f62\u5b66 \u56fe\u5143\u7684\u751f\u6210 \u662f\u6307\u5b8c\u6210\u56fe\u5143\u7684\u53c2\u6570\u8868\u793a\u5f62\u5f0f\u5230\u70b9\u9635\u8868\u793a\u5f62\u5f0f\u7684\u8f6c\u6362\u3002\u901a\u5e38\u4e5f\u79f0\u626b\u63cf\u8f6c\u6362\u56fe\u5143(Scan Converter) \u53c2\u6570\u8868\u793a\u5f62\u5f0f\u7531\u4e0d\u540c\u79cd\u7c7b\u56fe\u5f62\u7684\u6027\u8d28\u51b3\u5b9a\uff0c\u70b9\u9635\u8868\u793a\u5f62\u5f0f\u662f\u5149\u6805\u663e\u793a\u7cfb\u7edf\u5237\u65b0\u65f6\u6240\u9700\u7684\u8868\u793a\u5f62\u5f0f\u3002 openGL\u76f8\u5173\u51fd\u6570 //\u521d\u59cb\u5316\u989c\u8272 glClearColor ( 0 , 1 , 0 , 1 ); //\u6e05\u9664\u5e27\u7f13\u5b58\uff0c\u5e76\u5c06\u6bcf\u4e2a\u50cf\u7d20\u5bf9\u5e94\u5355\u5143\u8d4b\u4e3a\u80cc\u666f\u989c\u8272\u503c glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT ); //\u8868\u793a\u7ed3\u675f\u7ed8\u56fe\u547d\u4ee4\uff0c\u4f7f\u7528\u5355\u7f13\u5b58\u65f6\u5fc5\u987b\u8981\u3002\u53cc\u7f13\u51b2\u65f6\u53ef\u4ee5\u4e0d\u8981 glFinish (); //\u53cc\u7f13\u5b58\u65f6\u4f7f\u7528\u3002\u4ea4\u6362\u7f13\u5b58\u547d\u4ee4\uff0c\u8868\u793a\u5f53\u524d\u663e\u793a\u5e27\u548c\u4e0b\u5e27\u7684\u5e27\u7f13\u5b58\u4ea4\u6362 glutSwapBuffers (); \u5355\u7f13\u5b58\u4e0e\u53cc\u7f13\u5b58\u673a\u5236 \u5355\u7f13\u5b58\uff1a\u626b\u63cf\u4e0e\u751f\u6210\u70b9\u9635\u4e32\u884c\u8fdb\u884c \u53cc\u7f13\u5b58\uff1a\u626b\u63cf\u4e0e\u751f\u6210\u70b9\u9635\u540c\u65f6\uff08\u5e76\u884c\uff09\u8fdb\u884c \u57fa\u672c\u7ebf\u753b\u56fe\u5143\u751f\u6210 \u626b\u63cf\u8f6c\u6362\u76f4\u7ebf\u6bb5 \u6982\u5ff5\uff1a\u6c42\u4e0e\u76f4\u7ebf\u6bb5\u5145\u5206\u63a5\u8fd1\u7684\u50cf\u7d20\u96c6\uff0c\u5e76\u4ee5\u6b64\u50cf\u7d20\u96c6\u66ff\u4ee3\u539f\u8fde\u7eed\u76f4\u7ebf\u6bb5\u5728\u5c4f\u5e55\u4e0a\u663e\u793a\u3002 \u7ea6\u675f\u6761\u4ef6\uff1a \u5c4f\u5e55\u5750\u6807\u7cfb\u662f\u6574\u578b\u5750\u6807\u7cfb\u3001\u50cf\u7d20\u95f4\u6a2a\u5411\u548c\u7eb5\u5411\u8ddd\u79bb\u76f8\u7b49\u3001\u76f4\u7ebf\u6bb5\u4e3a P_0(x_0,y_0)\uff0cp_1(x_1,y_1\u4e14 x_0<x_1\u4e14\u5747\u4e3a\u6574\u6570) P_0(x_0,y_0)\uff0cp_1(x_1,y_1\u4e14 x_0<x_1\u4e14\u5747\u4e3a\u6574\u6570) \u3001\u76f4\u7ebf\u6bb5\u7684\u5bbd\u5ea6\uff08\u7ebf\u5bbd\uff09\u4e3a1\u3010\u6a2a\u5411\u6216\u7eb5\u5411\u50cf\u7d20\u76f8\u90bb\u3011\u3001 \u76f4\u7ebf\u6bb5\u7684\u659c\u7387 0 \\leq k \\leq 1 0 \\leq k \\leq 1 \u3001\u76f8\u90bb\u50cf\u7d20\u95f4\u5750\u6807\u5206\u91cf\u5dee\u4e3a-1\uff0c0\u62161 \u4e3b\u8981\u7b97\u6cd5 \u76f4\u7ebf\u65b9\u7a0b\u6cd5 \u57fa\u672c\u601d\u60f3 \u6839\u636e\u76f4\u7ebf\u7684\u51e0\u4f55\u65b9\u7a0b\u786e\u5b9a\u7ebf\u6bb5\u8def\u5f84\u4e0a\u7684\u50cf\u7d20\u4f4d\u7f6e\u3002 \u65b9\u6cd5 \u5212\u5206\u533a\u95f4 [x_0, x_1] [x_0, x_1] : t_0, t_1,\u2026, t_n, t_{i+1}=x_{i+1} t_0, t_1,\u2026, t_n, t_{i+1}=x_{i+1} , \u5176\u4e2d t_{i+1}=t_i+1,t_0 = x_0,t_n=x_1 t_{i+1}=t_i+1,t_0 = x_0,t_n=x_1 \u8ba1\u7b97\u7eb5\u5750\u6807y\uff1a y_i = k*t_i + b y_i = k*t_i + b \u53d6\u6574\uff1a\u56db\u820d\u4e94\u5165\uff0c\u5373 y_{i,r}=round(y_i)=(int)(y_i+0.5) y_{i,r}=round(y_i)=(int)(y_i+0.5) \u4e3b\u8981\u8fd0\u7b97\uff1a\u4e58\u6cd5+\u52a0\u6cd5+\u53d6\u6574+\u6d6e\u70b9\u8fd0\u7b97 \u6570\u503c\u5fae\u5206DDA\u7b97\u6cd5\u3001 \u65b9\u6cd5\uff1a y_{i+1}=k*x_{i+1}+b=k*(x_i+1)+b=y_i+k y_{i+1}=k*x_{i+1}+b=k*(x_i+1)+b=y_i+k \u4e3b\u8981\u8fd0\u7b97\uff1a\u52a0\u6cd5+\u53d6\u6574+\u6d6e\u70b9\u8fd0\u7b97 \u4e2d\u70b9\u7b97\u6cd5 \u76ee\u6807\uff1a\u6d88\u9664\u6d6e\u70b9\u8fd0\u7b97 \u65b9\u6cd5 \u76f4\u7ebf\u9690\u5f0f\u65b9\u7a0b F(x,y)=a*x+b*y+c=0 F(x,y)=a*x+b*y+c=0 \u53ef\u6839\u636e F(x,y) F(x,y) \u7684\u5927\u5c0f\u6765\u5224\u65ad\u70b9\u662f\u5426\u5728\u76f4\u7ebf\u548c\u70b9\u7684\u5173\u7cfb\uff1a F(x,y)>0 F(x,y)>0 \u76f4\u7ebf\u4e0a\u65b9\uff0c F(x,y)=0 F(x,y)=0 \u76f4\u7ebf\u4e0a\uff0c F(x,y)<0 F(x,y)<0 \u76f4\u7ebf\u4e0b\u65b9 \u5224\u65ad\u4e0b\u4e00\u4e2a\u50cf\u7d20\u70b9\u7684\u5750\u6807 \u5df2\u8ba1\u7b97\u51fa\u67d0\u4e00\u70b9\u7684\u5750\u6807 (x_i,y_{i,r}) (x_i,y_{i,r}) \uff0c\u5219\u53ef\u6784\u9020\u5224\u522b\u5f0f d=F(M)=F(x_{i+1},y_{i,r}+0.5) d=F(M)=F(x_{i+1},y_{i,r}+0.5) \uff0c\u901a\u8fc7d\u7684\u6b63\u8d1f\u6765\u5224\u65ad\u4e0b\u4e00\u70b9\u7684\u5750\u6807\uff0c\u82e5d<0\uff0c\u5219\u9009\u62e9 (x_{i+1},y_{i,r}+1) (x_{i+1},y_{i,r}+1) \uff0c\u53cd\u4e4b\uff0c\u9009\u62e9 (x_{i+1},y_{i,r}) (x_{i+1},y_{i,r}) \u3002 \u5224\u65ad\u518d\u4e0b\u4e00\u4e2a\u50cf\u7d20\u70b9\u7684\u5750\u6807 \u82e5 d \\geq 0 \uff0c\u5219\u53d6\u53f3\u4fa7\u50cf\u7d20 \uff0c\u5219\u53d6\u53f3\u4fa7\u50cf\u7d20 (x_{i+1},y_{i,r})(x_{i+1},y_{i,r}) d \\geq 0 <span class=\"arithmatex\"><span class=\"MathJax_Preview\">\uff0c\u5219\u53d6\u53f3\u4fa7\u50cf\u7d20</span><script type=\"math/tex\">\uff0c\u5219\u53d6\u53f3\u4fa7\u50cf\u7d20 (x_{i+1},y_{i,r})(x_{i+1},y_{i,r}) \uff0c\u5219\u518d\u4e0b\u4e00\u4e2a\u50cf\u7d20 d=F(x_{i+2},y_{i,r}+0.5)=a*(x_i+2)+b*(y_{i,r}+0.5)+c=d+a d=F(x_{i+2},y_{i,r}+0.5)=a*(x_i+2)+b*(y_{i,r}+0.5)+c=d+a \u6b64\u65f6d\u7684\u589e\u91cf\u4e3aa \u82e5 d<0 d<0 \uff0c\u5219\u53d6\u53f3\u4e0a\u4fa7\u7684\u50cf\u7d20 (x_{i+1},y_{i,r}+1) (x_{i+1},y_{i,r}+1) \uff0c\u5219\u518d\u4e0b\u4e00\u4e2a\u50cf\u7d20 d=F(x_{i+2},y_{i,r}+1.5)=a*(x_i+2)+b*(y_{i,r}+1.5)+c=d+a+b d=F(x_{i+2},y_{i,r}+1.5)=a*(x_i+2)+b*(y_{i,r}+1.5)+c=d+a+b \u6b64\u65f6d\u7684\u589e\u91cf\u4e3aa+b d\u7684\u521d\u59cb\u503c\uff1a d_0=F(x_0+1, y_0+0.5)=F(x_0, y_0)+a+0.5*b d_0=F(x_0+1, y_0+0.5)=F(x_0, y_0)+a+0.5*b \uff0c\u56e0(x0, y0)\u5728\u76f4\u7ebf\u4e0a\uff0cF(x0, y0)=0, \u6240\u4ee5\uff0c d_0 = a + 0.5*b d_0 = a + 0.5*b \u589e\u91cfd\u7684\u9012\u63a8\u516c\u5f0f \u6ce8\u610f\u659c\u7387\u5927\u4e8e1\u548c\u8d1f\u6570\u7684\u60c5\u51b5\u3002 \u626b\u63cf\u8f6c\u6362\u5706\u5f27 \u5e73\u79fb\u5706\u5fc3\u5230\u539f\u70b9\uff0c\u626b\u63cf\u8f6c\u6362\u540e\u518d\u5e73\u79fb\u5230\u539f\u4f4d\u7f6e \u5706\u7684\u516b\u5bf9\u79f0\u6027\uff1a\u7531\u516b\u5206\u4e4b\u4e00\u5706\u5f27\u4e0a\u7684\u70b9\u53ef\u8ba1\u7b97\u5176\u5b83\u5404\u5206\u6bb5\u5f27\u4e0a\u7684\u70b9\uff0c\u53ea\u9700\u8981\u626b\u63cf\u8f6c\u6362\u516b\u5206\u4e4b\u4e00\u5706\u5f27\u5373\u53ef \u4e3b\u8981\u65b9\u6cd5\uff1a\u65b9\u7a0b\u6cd5\u3001\u4e2d\u70b9\u7b97\u6cd5\u548c\u903c\u8fd1\u6cd5 \u4e3b\u8981\u7b97\u6cd5 \u65b9\u7a0b\u6cd5 \u79bb\u6563\u70b9\uff1a x^2+y^2=R^2 x^2+y^2=R^2 \uff0c\u5219 x_i,y_i=\\sqrt{R^2-x_i^2} x_i,y_i=\\sqrt{R^2-x_i^2} \u53d6\u6574\u5f97\u5230 (x_i,y_i) (x_i,y_i) \u79bb\u6563\u89d2\u5ea6\uff1a\u5229\u7528\u53c2\u6570\u65b9\u7a0b\uff1a x=R*cos \\theta.y=R*sin\\theta x=R*cos \\theta.y=R*sin\\theta \u4e2d\u70b9\u7b97\u6cd5 \u5706\u5f27\u7684\u6b63\u8d1f\u5212\u5206\u6027 \u5706\u5f27\u5916\u7684\u70b9\uff1a F(x,y)>0 F(x,y)>0 \uff1b\u5706\u5f27\u4e0a\u7684\u70b9\uff1a F(x,y)=0 F(x,y)=0 \uff1b\u5706\u5f27\u5185\u7684\u70b9\uff1a F(x,y)<0 F(x,y)<0 \u516b\u5206\u5706\u7684\u9009\u62e9 \u7b2c\u4e00\u8c61\u9650\u7684\u516b\u5206\u4e4b\u4e00\u5706\u5f27\u4e2dx \u7684\u53d8\u5316\u5927\u4e8e y \u7684\u53d8\u5316\uff0c\u5373\u5706\u5f27\u4e0a\u7684\u5207\u77e2\u91cf\u659c\u7387\u57280 ... -1\u95f4\u3002 \u56e0\u6b64\u53ef\u4ee5\u4f7f x \u4ece0 \u589e\u52a0\u5230 R/(21/2)\uff0c\u8ba1\u7b97 y \u7684\u503c\u3002 \u78ba\u5b9a\u4e0b\u4e00\u50cf\u7d20\u70b9 \u70b9 p(x_i, y_{i,r}) p(x_i, y_{i,r}) \u4e0b\u4e00\u70b9\u6240\u53d6\u53ef\u80fd\u70b9\u95f4\u7ebf\u6bb5\u7684\u4e2d\u70b9\uff0c M = (x_{i+1}, y_{i,r} - 0.5) M = (x_{i+1}, y_{i,r} - 0.5) \u5f53F(M)\u22640\u65f6\uff0cM\u5728\u5706\u5185\uff0c\u8bf4\u660eE\u8ddd\u79bb\u5706\u5f27\u66f4\u8fd1\uff0c\u53d6 (x_{i+1},y_{i,r}) (x_{i+1},y_{i,r}) \u5f53F(M)\uff1e0\u65f6\uff0c M\u5728\u5706\u5916\uff0c \u53d6 (x_{i+1},y_{i,r}-1) (x_{i+1},y_{i,r}-1) \u6784\u9020\u5224\u522b\u5f0f d_i = F(M) = F(x_i+1, y_{i,r}-0.5) = (x_i+1)^2+(y_i-0.5)^2-R^2 d_i = F(M) = F(x_i+1, y_{i,r}-0.5) = (x_i+1)^2+(y_i-0.5)^2-R^2 \u82e5 d \\leq 0 d \\leq 0 \uff0c\u5219\u518d\u4e0b\u4e00\u4e2a\u50cf\u7d20\u70b9\u5224\u5b9a\u5f0f d_{i+1}=F(x_i+2,y_{i,r}-0.5)=d+2x_i+3 d_{i+1}=F(x_i+2,y_{i,r}-0.5)=d+2x_i+3 \u82e5 d>0 d>0 \uff0c\u5219\u518d\u4e0b\u4e00\u4e2a\u50cf\u7d20\u70b9\u5224\u5b9a\u5f0f d_{i+1}=F(x_i+2,y_{i,r}-1.5)=d+(2x_i+3)+(-2y_{i,r}+2) d_{i+1}=F(x_i+2,y_{i,r}-1.5)=d+(2x_i+3)+(-2y_{i,r}+2) d\u7684\u521d\u59cb\u503c d_0=F(1,R-0.5)=1.25-R d_0=F(1,R-0.5)=1.25-R \u9012\u63a8\u516c\u5f0f \u6d88\u9664\u4e58\u6cd5\u8fd0\u7b97 \u903c\u8fd1\u6cd5 \u4e24\u79cd\u65b9\u6cd5\uff1a\u6b63\u5185\u63a5\u591a\u8fb9\u5f62\u8feb\u8fd1\u6cd5\u3001\u7b49\u9762\u79ef\u6b63\u591a\u8fb9\u5f62\u8feb\u8fd1\u6cd5 \u7279\u70b9\uff1a\u591a\u8fb9\u5f62\u8fb9\u6570\u8db3\u591f\u591a\u65f6\u63a5\u8fd1\u5706\u3001\u8bef\u5dee\u63a7\u5236\u8fb9\u6570\uff1a\u8fb9\u8d8a\u591a\u7cbe\u5ea6\u8d8a\u9ad8\uff0c\u4f46\u8ba1\u7b97\u5f00\u9500\u5927\u3001\u591a\u8fb9\u5f62\u7684\u8fb9\u53ef\u7528\u76f4\u7ebf\u6bb5\u7684\u4e2d\u70b9\u7b97\u6cd5\u6765\u751f\u6210 \u6b63\u5185\u63a5\u591a\u8fb9\u5f62\u8feb\u8fd1\u6cd5 \u200b \u586b\u5145\u56fe\u5143\u751f\u6210 \u4e24\u79cd\u65b9\u6cd5\u626b\u63cf\u8f6c\u6362: \u53c2\u6570\uff0d>\u70b9\u9635\u3001\u586b\u5145\uff08Filling\uff09 : \u70b9\u9635\uff0d>\u70b9\u9635 \u5171\u4eab\u8fb9\u754c\uff1a\u5de6\u95ed\u53f3\u5f00\uff0c\u4e0b\u95ed\u4e0a\u5f00 \u626b\u63cf\u8f6c\u6362\u591a\u8fb9\u5f62 \u4e24\u79cd\u65b9\u6cd5\uff1a\u9010\u70b9\u5224\u65ad\u6cd5\uff1b\u626b\u63cf\u7ebf\u7b97\u6cd5\uff1b \u591a\u8fb9\u5f62\u5206\u7c7b \u51f8\u591a\u8fb9\u5f62(convex)\uff1a\u5185\u89d2\u5c0f\u4e8e180\u5ea6 \u51f9\u591a\u8fb9\u5f62(concave)\uff1a\u5b58\u5728\u5185\u89d2\u5927\u4e8e180\u5ea6 \u53ea\u8003\u8651\uff1a\u7b80\u5355\u591a\u8fb9\u5f62\uff0c\u5373\u591a\u8fb9\u5f62\u8fb9\u4e0d\u81ea\u76f8\u4ea4 \u9010\u70b9\u5224\u65ad\u53d1\uff0c\u5373\u4e3a\u5224\u65ad\u6bcf\u4e2a\u70b9\u548c\u591a\u8fb9\u5f62\u7684\u5185\u5916\u5173\u7cfb--\u5c04\u7ebf\u6cd5 \u6b65\u9aa4 \uff081\uff09\u4ece\u5f85\u5224\u522b\u70b9 v \u53d1\u51fa\u5c04\u7ebf\uff08\u4efb\u610f\u65b9\u5411\uff0c\u4e00\u822c\u6c34\u5e73\u65b9\u5411\uff09 \uff082\uff09\u6c42\u4e0e\u591a\u8fb9\u5f62\u4ea4\u70b9\u4e2a\u6570 k \uff083\uff09k \u7684\u5947\u5076\u6027\u51b3\u5b9a\u4e86\u70b9\u4e0e\u591a\u8fb9\u5f62\u7684\u5185\u5916\u5173\u7cfb \u5076\u6570\uff1a\u5916 \u5947\u6570\uff1a\u5185 \u5947\u5f02\u60c5\u51b5 \u5c04\u7ebf\u5728\u8fb9\u4e0a\uff1a\u65e0\u6570\u4e2a\u70b9 ---\u5224\u65ad\u5c04\u7ebf\u662f\u5426\u4e0e\u8fb9\u540c\u7ebf \u4ea4\u70b9\u4e3a\u9876\u70b9\uff1a\u5f02\u4fa7\uff1a1\u4e2a\u3001\u540c\u4fa7\uff1a0\u62162\u4e2a \u626b\u63cf\u7ebf\u7b97\u6cd5 \u76ee\u6807\uff1a\u5229\u7528\u76f8\u90bb\u50cf\u7d20\u4e4b\u95f4\u7684\u8fde\u8d2f\u6027\uff0c\u63d0\u9ad8\u7b97\u6cd5\u6548\u7387 \u5904\u7406\u5bf9\u8c61\uff1a\u7b80\u5355\u591a\u8fb9\u5f62 \u975e\u81ea\u4ea4\u591a\u8fb9\u5f62 \uff08\u8fb9\u4e0e\u8fb9\u4e4b\u95f4\u9664\u4e86\u9876\u70b9\u5916\u65e0\u5176\u5b83\u4ea4\u70b9\uff09 \u6b65\u9aa4\uff08\u5bf9\u4e8e\u6bcf\u4e00\u6761\u626b\u63cf\u7ebf\uff09 \u8ba1\u7b97\u626b\u63cf\u7ebf\u4e0e\u8fb9\u7684\u4ea4\u70b9 \u4ea4\u70b9\u6309x\u5750\u6807\u4ece\u5c0f\u5230\u5927\u6392\u5e8f \u4ea4\u70b9\u4e24\u4e24\u914d\u5bf9\uff0c\u586b\u5145\u533a\u95f4 \u57fa\u672c\u65b9\u6cd5 \u5c06\u6574\u4e2a\u7ed8\u56fe\u7a97\u53e3\u5185\u626b\u63cf\u591a\u8fb9\u5f62\u7684\u95ee\u9898\u5206\u89e3\u4e3a\u4e00\u6761\u6761\u626b\u63cf\u7ebf\u8ba1\u7b97\u4e0e\u591a\u8fb9\u5f62\u7684\u76f8\u4ea4\u533a\u95f4\uff0c\u53ea\u8981\u5b8c\u6210\u6bcf\u6761\u626b\u63cf\u7ebf\u7684\u751f\u6210\u5c31\u5b9e\u73b0\u4e86\u591a\u8fb9\u5f62\u7684\u626b\u63cf\u8f6c\u6362 \u4e00\u6761\u626b\u63cf\u7ebf\u4e0e\u591a\u8fb9\u5f62\u7684\u8fb9\u6709\u5076\u6570\u4e2a\u4ea4\u70b9\uff0c\u6bcf2\u4e2a\u70b9\u5f62\u6210\u4e00\u533a\u95f4\uff0c\u533a\u95f4\u5185\u7684\u50cf\u7d20\u4f4d\u4e8e\u591a\u8fb9\u5f62\u5185 \u8fde\u8d2f\u6027(Coherence) \u8fb9\u7684\u8fde\u8d2f\u6027(Edge Coherence)\u2014\u4f18\u5316\u4ea4\u70b9\u8ba1\u7b97 \u67d0\u6761\u8fb9\u4e0e\u5f53\u524d\u626b\u63cf\u7ebf\u76f8\u4ea4\uff0c\u4e5f\u53ef\u80fd\u4e0e\u4e0b\u4e00\u6761\u626b\u63cf\u7ebf\u76f8\u4ea4 \u626b\u63cf\u7ebf\u7684\u8fde\u8d2f\u6027(Scan-line Coherence) )\u2014\u4f18\u5316\u4ea4\u70b9\u6392\u5e8f \u5f53\u524d\u626b\u63cf\u7ebf\u4e0e\u5404\u8fb9\u7684\u4ea4\u70b9\u987a\u5e8f\u4e0e \u4e0b\u4e00\u6761\u626b\u63cf\u7ebf\u4e0e\u5404\u8fb9\u7684\u4ea4\u70b9\u987a\u5e8f\u53ef\u80fd\u76f8\u540c\u6216\u7c7b\u4f3c \u533a\u95f4\u7684\u8fde\u8d2f\u6027(Span Coherence) \u540c\u4e00\u533a\u95f4\u4e0a\u7684\u50cf\u7d20\u53d6\u540c\u4e00\u989c\u8272\u5c5e\u6027 \u4ea4\u70b9 \u7b2c\u4e00\u7c7b\u4ea4\u70b9\uff1a\u4f4d\u4e8e\u540c\u4e00\u6761\u8fb9\u4e0a\u7684\u540e\u7ee7\u4ea4\u70b9\uff0c\u7531\u626b\u63cf\u7ebfy\uff1de\u4e0e\u591a\u8fb9\u5f62\u7684\u4ea4\u70b9\u9012\u63a8\u8ba1\u7b97\u626b\u63cf\u7ebf y\uff1de\uff0b1\u7684\u4ea4\u70b9\uff0cx\u2019\uff1dx\uff0b1/m \u7b2c\u4e8c\u7c7b\u4ea4\u70b9\uff1a\u8fb9\u4e0e\u626b\u63cf\u7ebf\u7684\u7b2c\u4e00\u4e2a\u4ea4\u70b9\uff0c\u8fb9\u7684\u4e0b\u7aef\u70b9\u5373\u4e3a\u4ea4\u70b9\u3002 \u4ea4\u70b9\u53d6\u6574\u89c4\u5219 \u4f7f\u751f\u6210\u7684\u50cf\u7d20\u5168\u90e8\u4f4d\u4e8e\u591a\u8fb9\u5f62\u4e4b\u5185\uff0c\u4e14\u6ee1\u8db3\u5171\u4eab\u8fb9\u754c\u539f\u5219\u3002 \uff081\uff09\u4ea4\u70b9\u5750\u6807\u4e0d\u80fd\u91c7\u7528\u201c\u56db\u820d\u4e94\u5165\u201d\u539f\u5219\uff0c\u5426\u5219\u4f1a\u5bfc\u81f4\u90e8\u5206\u50cf\u7d20\u4f4d\u4e8e\u591a\u8fb9\u5f62\u4e4b\u5916 \uff082\uff09\u5171\u4eab\u8fb9\u754c\u539f\u5219\uff1a\u5de6\u95ed\u53f3\u5f00\uff0c\u4e0b\u95ed\u4e0a\u5f00 \u4ea4\u70b9\u6a2a\u5750\u6807x\u4e3a\u5c0f\u6570\uff0c\u5373\u4ea4\u70b9\u843d\u4e8e\u626b\u63cf\u7ebf\u4e0a\u4e24\u4e2a\u76f8\u90bb\u50cf\u7d20\u4e4b\u95f4 \uff08a\uff09\u4ea4\u70b9\u4f4d\u4e8e\u5de6\u8fb9\u4e0a\uff0c\u5411\u53f3\u53d6\u6574\uff0c(int)x + 1 \uff08b\uff09\u4ea4\u70b9\u4f4d\u4e8e\u53f3\u8fb9\u4e0a\uff0c\u5411\u5de6\u53d6\u6574\uff0c(int)x \u4ea4\u70b9\u6a2a\u5750\u6807x\u4e3a\u6574\u6570\uff0c\u843d\u5728\u53f3\u3001\u4e0a\u8fb9\u754c\u7684\u50cf\u7d20\u4e0d\u4e88\u586b\u5145\u3002\u843d\u5728\u5de6\u3001\u4e0b\u8fb9\u754c\u7684\u50cf\u7d20\u9700\u8981\u586b\u5145\u3002 \u4ea4\u70b9\u662f\u9876\u70b9\uff0c\u626b\u63cf\u7ebf\u4e0e\u591a\u8fb9\u5f62\u7684\u9876\u70b9\u76f8\u4ea4\u65f6\uff0c\u91c7\u7528\u4e0a\u5f00\u4e0b\u95ed\u53ca\u53f3\u5f00\u5de6\u95ed\u53d6\u4ea4\u70b9\uff0c\u4fdd\u8bc1\u4ea4\u70b9\u6b63\u786e\u914d\u5bf9\u3002 \u68c0\u67e5\u4e24\u76f8\u90bb\u8fb9\u5728\u626b\u63cf\u7ebf\u7684\u54ea\u4e00\u4fa7\u3002\u53ea\u8981\u68c0\u67e5\u76f8\u4ea4\u7684\u4e24\u6761\u8fb9\u7684\u53e6\u5916\u4e24\u4e2a\u7aef\u70b9\u7684Y\u503c\uff0c\u4e24\u4e2a\u7aef\u70b9Y\u4e2d\u503c\u5927\u4e8e\u4ea4\u70b9Y\u503c\u7684\u4e2a\u6570\u662f0\uff0c1\uff0c2\uff0c\u6765\u51b3\u5b9a\u53d60\uff0c1\uff0c2\u4e2a\u4ea4\u70b9\u3002 \u5206\u522b\u5bf9\u5e94\u4ea4\u70b9\u4e2a\u6570\u4e3a1\u4e2a\u30011\u4e2a\u30012\u4e2a\u548c0\u4e2a\u3002 \u6c34\u5e73\u8fb9\uff0c\u4e0d\u53c2\u4e0e\u8ba1\u7b97\u4ea4\u70b9 \u6392\u5e8f\uff0c\u5229\u7528\u626b\u63cf\u7ebf\u8fde\u8d2f\u6027\uff0c\u91c7\u7528\u63d2\u5165\u6392\u5e8f\u3002 \u4ea4\u70b9\u4e24\u4e24\u914d\u5bf9\u4e0e\u533a\u95f4\u7ed8\u5236\uff0c\u533a\u95f4\u8fde\u7eed\u6027\uff0c\u8fde\u7eed\u7ed8\u5236\u533a\u95f4\u4e0a\u7684\u50cf\u7d20\u3002 \u7b97\u6cd5\u5b9e\u73b0 \u8fb9\u7684\u5206\u7c7b\u8868ET \uff08Edge Table\uff09\uff08\u53c8\u79f0\u65b0\u8fb9\u8868NET\uff09 \u6309\u7167\u8fb9\u7684\u4e0b\u7aef\u70b9 y \u5750\u6807\uff0c\u5bf9\u975e\u6c34\u5e73\u8fb9\u8fdb\u884c\u5206\u7c7b\u7684\u94fe\u8868 \u4e0b\u7aef\u70b9 y \u5750\u6807\u503c\u7b49\u4e8ei \u7684\u8fb9\u5c5e\u4e8e\u7b2ci\u7c7b\uff0c\u540c\u7c7b\u4e2d\u6709\u591a\u6761\u8fb9\u65f6\u6309x\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff08x\u4e5f\u4e00\u6837\u65f6\u6309\u8fb9\u4e0a\u7aef\u70b9\u7684x\u503c\uff09 \u4f5c\u7528\uff1a\u907f\u514d\u76f2\u76ee\u6c42\u4ea4\uff1b\u8ba1\u7b97\u7b2c\u4e8c\u7c7b\u4ea4\u70b9\u5750\u6807 ET\u7684\u7ed3\u70b9\u4fe1\u606f\uff1a ymax: \u8fb9\u7684\u4e0a\u7aef\u70b9\u7684 y \u5750\u6807\u503c x\uff1a\u8fb9\u7684\u4e0b\u7aef\u70b9\u7684 x \u5750\u6807 deltax\uff1a\u8fb9\u7684\u659c\u7387\u7684\u5012\u6570 nextEdge: \u4e0b\u4e00\u6761\u8fb9\u7684\u6307\u9488 \u5f53\u626b\u63cf\u7ebf y = e + 1 == ymax\uff0c\u8bf4\u660e\u4e0b\u4e00\u6761\u626b\u63cf\u7ebf\u4e0e\u6b64\u8fb9\u4e0d\u76f8\u4ea4\u3002 \u6d3b\u6027\u8fb9\u8868AEL(Active Edge List) \u5b58\u653e\u6d3b\u6027\u8fb9\u7684\u987a\u5e8f\u94fe\u8868\uff0c\u4e14\u6309\u4ea4\u70b9 x \u7684\u503c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f \u6d3b\u6027\u8fb9\uff1a\u4e0e\u5f53\u524d\u626b\u63cf\u7ebf\u76f8\u4ea4\u7684\u8fb9 \u8fb9\u7ed3\u6784\u5b9a\u4e49\uff1a\u4e0eET\u8868\u4e2d\u7ed3\u70b9\u7ed3\u6784\u76f8\u540c\u3002 typedef struct { int ymax ; float x , deltax ; Edge * nextEdge ; } Edge ; AEL \u7684\u7ed3\u70b9\u4fe1\u606f\uff1a ymax: \u6240\u4ea4\u8fb9\u7684\u6700\u5927 y \u503c x\uff1a\u5f53\u524d\u626b\u63cf\u7ebf\u4e0e\u8fb9\u7684\u4ea4\u70b9\u7684x\u5750\u6807 deltax\uff1a\u8fb9\u7684\u659c\u7387\u7684\u5012\u6570 nextEdge: \u4e0b\u4e00\u6761\u8fb9\u7684\u6307\u9488 \u4f5c\u7528\uff1a\u5b58\u50a8\u4e0e\u5f53\u524d\u626b\u63cf\u7ebf\u7684\u4ea4\u70b9\uff0c\u540c\u65f6\u5feb\u901f\u8ba1\u7b97\u4e0b\u4e00\u6761\u626b\u63cf\u7ebf\u4e0e\u591a\u8fb9\u5f62\u76f8\u4ea4\u7684\u70b9\uff0c\u4e14\u53ef\u5224\u65ad\u8fb9\u662f\u5426\u4e0e\u4e0b\u4e00\u6761\u626b\u63cf\u7ebf\u76f8\u4ea4 \u79cd\u5b50\u586b\u5145\u7b97\u6cd5 \u533a\u57df\uff1a\u70b9\u9635\u8868\u793a\u7684\u56fe\u5f62\uff0c\u50cf\u7d20\u96c6\u5408 \u8868\u793a\u65b9\u6cd5\uff1a\u5185\u70b9\u8868\u793a\u3001\u8fb9\u754c\u8868\u793a \u5185\u70b9\u8868\u793a \u679a\u4e3e\u51fa\u533a\u57df\u5185\u90e8\u7684\u6240\u6709\u50cf\u7d20\u3001\u5185\u90e8\u7684\u6240\u6709\u50cf\u7d20\u4e3a\u540c\u4e00\u4e2a\u989c\u8272\u3001\u8fb9\u754c\u50cf\u7d20\u4e0e\u5185\u90e8\u50cf\u7d20\u7684\u989c\u8272\u4e0d\u540c \u8fb9\u754c\u8868\u793a \u679a\u4e3e\u51fa\u8fb9\u754c\u4e0a\u6240\u6709\u7684\u50cf\u7d20\u3001\u8fb9\u754c\u4e0a\u7684\u6240\u6709\u50cf\u7d20\u4e3a\u540c\u4e00\u989c\u8272\u3001\u5185\u90e8\u50cf\u7d20\u4e0e\u8fb9\u754c\u50cf\u7d20\u7684\u989c\u8272\u4e0d\u540c \u533a\u57df\u586b\u5145\u7b97\u6cd5\u8981\u6c42\u533a\u57df\u662f\u8fde\u901a\u7684\u3002 \u8fde\u901a\u6027 \uff081\uff094\u8fde\u901a\u533a\u57df\uff1a\u533a\u57df\u4e2d\u4efb\u610f\u6ee1\u8db3\u76f8\u4f3c\u6761\u4ef6\u4e24\u70b9\uff08\u50cf\u7d20\uff09\u53ef\u901a\u8fc7\u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u65b9\u5411\u4e92\u76f8\u5230\u8fbe \uff082\uff098\u8fde\u901a\u533a\u57df\uff1a\u533a\u57df\u4e2d\u4efb\u610f\u6ee1\u8db3\u76f8\u4f3c\u6761\u4ef6\u4e24\u70b9\uff08\u50cf\u7d20\uff09\u53ef\u901a\u8fc7\u4e0a\u4e0b\u5de6\u53f3\u548c\u5bf9\u89d2\u7ebf\u516b \u4e2a\u65b9\u5411\u4e92\u76f8\u5230\u8fbe 4\u8fde\u901a\u533a\u57df\uff0c\u8fb9\u754c\u53ea\u89818\u8fde\u901a\u5373\u53ef\uff0c8\u8fde\u901a\u533a\u57df\uff0c\u8fb9\u754c\u5fc5\u987b\u662f4\u8fde\u901a\u3002 \u7b97\u6cd5\u5b9e\u73b0\uff1a \uff081\uff09\u5185\u70b9\u8868\u793a\u76844\u8fde\u901a\u533a\u57df \u79cd\u5b50s(x,y)\uff0c\u539f\u8272oldColor\uff0c\u65b0\u989c\u8272newColor \u65b9\u6cd5\uff1a\u5148\u5224\u65ads(x, y)\u7684\u989c\u8272\uff0c\u82e5\u5176\u503c\u4e0d\u7b49\u4e8eoldColor\uff0c\u8bf4\u660e\u8be5\u50cf\u7d20\u4f4d\u4e8e\u533a\u57df\u5916\u6216\u5df2\u8bbe\u7f6e\u4e3a\u586b\u5145\u8272newColor \u7b97\u6cd5\u7ed3\u675f\uff1b \u5426\u5219\uff0c\u7f6e\u50cf\u7d20\u989c\u8272\u4e3anewColor\uff0c\u518d\u5bf9\u5176\u76f8\u90bb\u7684\u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u50cf\u7d20\u5206\u522b\u4f5c\u4e3a\u79cd\u5b50\u4f5c\u4e0a\u8ff0\u9012\u5f52\u5904\u7406\u3002 \u591a\u8fb9\u5f62\u626b\u63cf\u8f6c\u6362\u4e0e\u533a\u57df\u586b\u5145\u65b9\u6cd5\u6bd4\u8f83 \u57fa\u672c\u601d\u60f3\u4e0d\u540c \u524d\u8005\uff1a\u9876\u70b9\u8868\u793a\u8f6c\u6362\u6210\u70b9\u9635\u8868\u793a \u540e\u8005\uff1a\u53ea\u6539\u53d8\u533a\u57df\u5185\u586b\u5145\u989c\u8272\uff0c\u6ca1\u6709\u6539\u53d8\u8868\u793a\u65b9\u6cd5 \u5bf9\u8fb9\u754c\u7684\u8981\u6c42\u4e0d\u540c \u524d\u8005\uff1a\u626b\u63cf\u7ebf\u4e0e\u591a\u8fb9\u5f62\u8fb9\u754c\u4ea4\u70b9\u4e2a\u6570\u4e3a\u5076\u6570 \u540e\u8005\uff1a\u533a\u57df\u5c01\u95ed\uff0c\u9632\u6b62\u9012\u5f52\u586b\u5145\u8de8\u754c \u57fa\u672c\u7684\u6761\u4ef6\u4e0d\u540c \u524d\u8005\uff1a\u4ece\u8fb9\u754c\u9876\u70b9\u4fe1\u606f\u51fa\u53d1 \u540e\u8005\uff1a\u4ece\u533a\u57df\u5185\u79cd\u5b50\u70b9\u51fa\u53d1 \u533a\u57df\u56fe\u50cf\u586b\u5145 \u5b57\u7b26\u7684\u751f\u6210 \u70b9\u9635\u5b57\u4f53 \u5b58\u50a8\uff1a\uff08\u538b\u7f29\u4e0e\u975e\u538b\u7f29\uff09 \u663e\u793a\uff1a\u6839\u636e\u7f16\u7801\u68c0\u7d22\u70b9\u9635\u6570\u636e\uff0c\u63a5\u7740\u5199\u5e27\u7f13\u5b58 \u77e2\u91cf\u5b57\u4f53 \u8868\u793a\uff1a\u7b14\u753b\u7528\u66f2\u7ebf\uff08\u53c2\u6570\uff09\u8868\u793a \u626b\u63cf\u8f6c\u6362\uff1a\u53c2\u6570\u5230\u70b9\u9635 \u663e\u793a\uff1a1\u3001\u7531\u7f16\u7801\u68c0\u7d22\uff1b2\u3001\u626b\u63cf\u8f6c\u6362\uff1b3\u3001\u5199\u5e27\u7f13\u5b58 \u5b58\u50a8\uff1a\u7a7a\u95f4\u5c11 OpenGL\u76f8\u5173\u51fd\u6570 //\u56fe\u5143\u7ed8\u5236 glBegin ( type ); glVertex * (); //\u6307\u5b9a\u9876\u70b9\u5750\u68071 glVertex * (); //\u6307\u5b9a\u9876\u70b9\u5750\u68072 glEnd () \uff1b //\u70b9\u7684\u5c5e\u6027 glEnable ( GL_LINE_STIPPLE ); ( 1 ) glColor ( 3 | 4 )( b | d | f | i | s | ub | ui | us )( TYPE r , TYPE g , TYPE b ) ( 2 ) glColor ( 3 | 4 )( b | d | f | i | s | ub | ui | us ) v ( TYPE * rgb ) glPointSize \uff08 GLfloat size ) //\u70b9\u5927\u5c0f //\u753b\u7ebf glBegin\u4e2d\u7684\u53c2\u6570\u4e3a \uff1a GL_LINES \u3001 GL_LINE_STRIP \u3001 GL_LINE_LOOP GL_LINES \uff1a \u4e00\u7ec4\u76f4\u7ebf\u6bb5 \uff1b GL_LINE_STRIP \uff1a \u6298\u7ebf GL_LINE_LOOP \uff1a \u5c01\u95ed\u6298\u7ebf //\u7ebf\u7684\u5c5e\u6027 glLineWidth \uff08 GLfloat width ) //\u5bbd\u5ea6 glLineStipple ( GLint factor , GLushort pattern ); //\u7ebf\u5f62 glEnable ( GL_LINE_STIPPLE ); //\u4f7f\u7528\u524d\u9700\u8981\u6fc0\u6d3b //\u586b\u5145\u56fe\u5143\u51fd\u6570 glRect [ i | s | f | d ]{ v }() //\u77e9\u5f62\u51fd\u6570 glBegin () \u4e2d\u7684\u53c2\u6570GL_POLYGON \u3001 GL_TRIANGLES \u3001 GL_TRIANGLE_STRIP \u3001 GL_TRIANGLE_FAN //\u7ebf\u6846\u56fe\u4e0e\u586b\u5145\u56fe glPloygonMode ( face \uff0c displayMode ) //face\uff1a\u6307\u5b9a\u524d\u540e\u9762\u3002\u53ef\u9009\u503c\uff1aGL_FRONT\u3001GL_BACK\u548cGL_FRONT_AND_BACK\u3010\u6b63\u53cd\u9762\u4e00\u6837\u5904\u7406\u3011 //displayMode\uff1aGL_FILL\uff08\u586b\u5145\uff09\u548cGL_LINE\uff08\u7ebf\u6846\uff09 //\u989c\u8272\u63d2\u503c\u6a21\u5f0f \u51fd\u6570 \uff1a glShadeModel ( mode ) Mode : GL_FLAT\u548cGL_SMOOTH \u56fe\u5143\u7ed8\u5236 \u56fe\u5143\u7c7b\u578b \u7c7b\u578b \u8bf4\u660e GL_POINTS \u5355\u4e2a\u9876\u70b9\u96c6 GL_LINES \u591a\u7ec4\u53cc\u9876\u70b9\u7ebf\u6bb5 GL_POLYGON \u5355\u4e2a\u7b80\u5355\u586b\u5145\u51f8\u591a\u8fb9\u5f62 GL_TRIANGLES \u591a\u7ec4\u72ec\u7acb\u586b\u5145\u4e09\u89d2\u5f62 GL_QUADS \u591a\u7ec4\u72ec\u7acb\u586b\u5145\u56db\u8fb9\u5f62 GL_LINE_STRIP \u4e0d\u95ed\u5408\u6298\u7ebf GL_LINE_LOOP \u95ed\u5408\u6298\u7ebf GL_TRIANGLE_STRIP \u7ebf\u578b\u8fde\u7eed\u586b\u5145\u4e09\u89d2\u5f62\u4e32 GL_TRIANGLE_FAN \u6247\u5f62\u8fde\u7eed\u586b\u5145\u4e09\u89d2\u5f62\u4e32 GL_QUAD_STRIP \u8fde\u7eed\u586b\u5145\u56db\u8fb9\u5f62\u4e32","title":"\u7b2c\u4e09\u7ae0  \u57fa\u672c\u5149\u6805\u56fe\u5f62\u751f\u6210\u6280\u672f"},{"location":"course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/#_5","text":"\u9f50\u6b21\u5750\u6807 \u5b9a\u4e49 \u5b9a\u4e49\uff1a(x\uff0cy)\u70b9\u5bf9\u5e94\u7684\u9f50\u6b21\u5750\u6807\u5b9a\u4e49\u4e3a (x_h,y_h,h),x_h=h*x,y_h=y*h,z_h=h (x_h,y_h,h),x_h=h*x,y_h=y*h,z_h=h \u6807\u51c6\u5176\u6b21\u5750\u6807\uff1a (x,y,1) (x,y,1) h\uff1d0\u8868\u793a\u65e0\u7a77\u8fdc\u70b9 \u4e8c\u7ef4\u53d8\u6362 \u4e8c\u7ef4\u53d8\u6362\u7684\u77e9\u9635\u8868\u793a \u5e73\u79fb\u53d8\u6362 \u65cb\u8f6c\u53d8\u6362 \u7ed5\u5750\u6807\u539f\u70b9\uff08\u79f0\u4e3a\u53c2\u7167\u70b9\uff0c\u57fa\u51c6\u70b9\uff09\u65cb\u8f6c\u89d2\u5ea6\u03b8 \uff08\u9006\u65f6\u9488\u4e3a\u6b63\uff0c\u987a\u65f6\u9488\u4e3a\u8d1f\uff09 \u653e\u7f29\u53d8\u6362 \u53c2\u7167\u70b9\u4e3a\u5750\u6807\u539f\u70b9 \u53d8\u6362\u5177\u6709\u7edf\u4e00\u8868\u793a\u5f62\u5f0f\u7684\u4f18\u70b9 1. \u4fbf\u4e8e\u53d8\u6362\u5408\u6210 \u8fde\u7eed\u53d8\u6362\u65f6\uff0c\u53ef\u4ee5\u5148\u5f97\u5230\u53d8\u6362\u7684\u77e9\u9635 2. \u4fbf\u4e8e\u786c\u4ef6\u5b9e\u73b0 \u53ea\u9700\u5b9e\u73b0\u77e9\u9635\u4e58\u6cd5 \u53d8\u6362\u7684\u6027\u8d28 \u5e73\u79fb\u548c\u65cb\u8f6c\u53d8\u6362\u5177\u6709\u53ef\u52a0\u6027 \u653e\u7f29\u53d8\u6362\u5177\u6709\u53ef\u4e58\u6027 \u53d8\u6362\u5408\u6210 \u65b9\u6cd5\uff1a\u8fde\u7eed\u53d8\u6362\u65f6\uff0c\u5148\u8ba1\u7b97\u53d8\u6362\u77e9\u9635\uff0c\u518d\u8ba1\u7b97\u5750\u6807 \u4f18\u70b9\uff1a\u63d0\u9ad8\u4e86\u5bf9\u56fe\u5f62\u4f9d\u6b21\u8ba1\u7b97\u591a\u6b21\u53d8\u6362\u7684\u8fd0\u7b97\u6548\u7387\u3001\u63d0\u4f9b\u8ba1\u7b97\u590d\u6742\u53d8\u6362\u7684\u65b9\u6cd5 \u590d\u5408\u53d8\u6362 \u77e9\u9635\u4e58\u6cd5 \u5148\u4f5c\u7528\u7684\u653e\u5728\u53d8\u6362\u77e9\u9635\u8fde\u4e58\u5f0f\u7684\u53f3\u7aef\uff0c\u540e\u4f5c\u7528\u7684\u653e\u5728\u8fde\u4e58\u5f0f\u7684\u5de6\u7aef p\u2018=M_n*...*M_2*M_1 p\u2018=M_n*...*M_2*M_1 \u5bf9\u79f0\u53d8\u6362 \u4eff\u5c04\u53d8\u6362 \u4e8c\u7ef4\u7ebf\u6027\u53d8\u6362\u7684\u4e00\u822c\u5f62\u5f0f \u5e73\u79fb\uff0c\u65cb\u8f6c\uff0c\u653e\u7f29\uff0c\u5bf9\u79f0\u548c\u9519\u5207\u662f\u7279\u4f8b \u4fdd\u6301\u5e73\u884c\u7ebf\u95f4\u7684\u5e73\u884c\u5173\u7cfb \u4e09\u7ef4\u51e0\u4f55\u53d8\u6362 \u4e09\u7ef4\u9f50\u6b21\u5750\u6807 (x, y, z)\u70b9\u5bf9\u5e94\u7684\u9f50\u6b21\u5750\u6807\u4e3a (x_h,y_h,z_h,h) (x_h,y_h,z_h,h) \uff0c\u6807\u51c6\u9f50\u6b21\u5750\u6807 (x,y,z,1) (x,y,z,1) \u53f3\u624b\u5750\u6807\u7cfb \u65cb\u8f6c\u65b9\u5411\uff0c\u5f53\u62c7\u6307\u4e0e\u5750\u6807\u8f74\u540c\u5411\u65f6\uff0c\u56db\u6307\u6240\u6307\u65b9\u5411\u4e3a\u7ed5\u8be5\u8f74\u7684\u6b63\u65cb\u8f6c\u65b9\u5411\u3002 \u5e73\u79fb\u53d8\u6362 \u653e\u7f29\u53d8\u6362 \u53c2\u7167\u70b9\u4e3a\u5750\u6807\u539f\u70b9 \u65cb\u8f6c\u53d8\u6362 3. \u7ed5Z\u8f74 <img src=\"https://pic.tim-wcx.ltd//img/20211208224303.png\" alt=\"image-20211208224303864\" style=\"zoom:67%;\" /> \u5bf9\u79f0\u53d8\u6362 \u5173\u4e8e\u5750\u6807\u5e73\u9762 xy \u7684\u5bf9\u79f0\u53d8\u6362 \u4e09\u7ef4\u51e0\u4f55\u53d8\u6362\u7684\u4e00\u822c\u5f62\u5f0f \uff081\uff09\u524d\u4e09\u884c\u548c\u524d\u4e09\u5217\u5bf9\u5e94\u65cb\u8f6c\u548c\u653e\u7f29\u53d8\u6362 \uff082\uff09\u7b2c\u56db\u5217\u7684\u524d\u4e09\u4e2a\u5143\u7d20\u5bf9\u5e94\u5e73\u79fb\u53d8\u6362 \uff083\uff09\u7b2c\u56db\u884c\u524d\u4e09\u4e2a\u5143\u7d20\u5bf9\u5e94\u6295\u5f71\u53d8\u6362 \u56fe\u5f62\u5bf9\u8c61\u7684\u51e0\u4f55\u53d8\u6362 \u56fe\u5f62\u5bf9\u8c61 \u70b9\uff0c\u7ebf\u6bb5\uff0c\u591a\u8fb9\u5f62\uff0c\u5706\uff0c\u5b57\u7b26 \u65b9\u6cd5 \u5148\u751f\u6210\u70b9\u96c6\uff0c\u518d\u5bf9\u5176\u4e2d\u7684\u70b9\u8fdb\u884c\u53d8\u6362 \u8fd0\u7b97\u91cf\u5927\uff0c\u53d8\u6362\u524d\u540e\u5b58\u5728\u70b9\u96c6\u4e0d\u4e00\u81f4\u60c5\u51b5 \u5bf9\u51e0\u4f55\u53c2\u6570\u53d8\u6362 \u57fa\u672c\u56fe\u5f62\uff1a\u7ebf\u6bb5\uff0c\u4e24\u4e2a\u7aef\u70b9\uff1b\u591a\u8fb9\u5f62\uff0c\u591a\u4e2a\u9876\u70b9\uff1b\u5706\uff0c\u5706\u5fc3\u548c\u534a\u5f84\uff08\u653e\u7f29\u53d8\u6362\u8981\u6c42 x \u548c y \u653e\u7f29\u500d\u6570\u76f8\u540c\uff09 \u524d\u63d0\uff1a\u56fe\u5f62\u5bf9\u8c61\u7684\u51e0\u4f55\u6027\u8d28\u4e0d\u968f\u5750\u6807\u53d8\u6362\u800c\u53d1\u751f\u53d8\u5316\u3002\u8fd9\u79cd\u6027\u8d28\u79f0\u4e3a\u4eff\u5c04\u4e0d\u53d8\u6027\u3002 OpenGL\u51e0\u4f55\u53d8\u6362\u51fd\u6570 glTranslate{fd}(tx, ty, tz) //\u5e73\u79fb\u51fd\u6570 glRotate{fd}(theta, vx, vy, vz) //\u65cb\u8f6c\u51fd\u6570 glScale{fd}(sx, sy, sz) //\u653e\u7f29\u51fd\u6570 glLoadIdentity() //\u91cd\u7f6e\u4e3a\u5355\u4f4d\u77e9\u9635 glMatrixMode(GL_MODELVIEW) //\u6a21\u578b\u89c2\u5bdf\u77e9\u9635 glPushMatrix() //\u538b\u6808 glPopMatrix() //\u51fa\u6808 glutInitDisplayMode (GLUT_SINGLE|GLUT_RGBA); //\u5355\u7f13\u51b2 glutInitDisplayMode (GLUT_DOUBLE|GLUT_RGBA); //\u53cc\u7f13\u51b2 glFinish();//\u5f3a\u5236\u4e4b\u524d\u7684\u7ed8\u56fe\u51fd\u6570\u6267\u884c\uff0c\u53cc\u7f13\u51b2\u53ef\u4e0d\u8c03\u7528 glutSwapBuffers(); //\u53cc\u7f13\u51b2\u5fc5\u987b\u8c03\u7528 \u6ce8\u610f\uff1a (1)\u7cfb\u7edf\u51e0\u4f55\u53d8\u6362\u77e9\u9635\u53ea\u67091\u4e2a (2)\u5750\u6807\u91c7\u7528\u5217\u5411\u91cf\u8868\u793a (3)\u65cb\u8f6c\u89d2\u5927\u5c0f\u7528\u5ea6\u8868\u793a\uff0c\u4e0d\u662f\u5f27\u5ea6 (4)\u7ed8\u56fe\u65f6\uff0c\u7528\u7cfb\u7edf\u7684\u51e0\u4f55\u53d8\u6362\u77e9\u9635\u4e0e\u9876\u70b9\u5750\u6807\u76f8\u4e58\u5f97\u5230\u5750\u6807\u8fdb\u884c\u7ed8\u56fe (5) \u53ea\u9700\u8981\u8fde\u7eed\u8c03\u7528\u53d8\u6362\u51fd\u6570\uff0c\u5148\u53d8\u6362\u7684\u51fd\u6570\u540e\u8c03\u7528\uff0c\u6700\u540e\u7ed8\u5236\u8be5\u56fe\u5f62\u3002","title":"\u7b2c\u56db\u7ae0 \u51e0\u4f55\u53d8\u6362"},{"location":"course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/#_6","text":"\u4e8c\u7ef4\u663e\u793a\u6d41\u6c34\u7ebf \u57fa\u672c\u6982\u5ff5 \u88c1\u526a\u7a97\u53e3(Clipping Window) \uff1a\u9700\u8981\u663e\u793a\u7684\u573a\u666f\u533a\u57df \u53c8\u79f0\u4e3a\u4e16\u754c\u7a97\u53e3\u6216\u89c2\u5bdf\u7a97\u53e3\uff0c\u7b80\u79f0\u7a97\u53e3 \u5728\u4e16\u754c\u5750\u6807\u7cfb\uff08\u53c8\u79f0\u7528\u6237\u5750\u6807\u7cfb\uff09\u5185\u5b9a\u4e49 \u89c6\u53e3(Viewport)\uff1a\u6307\u663e\u793a\u8bbe\u5907\u4e0a\u7528\u6765\u663e\u793a\u56fe\u5f62\u7684\u533a\u57df \u53c8\u79f0\u89c6\u533a\uff0c\u5728\u8bbe\u5907\uff08\u5c4f\u5e55\uff09\u5750\u6807\u7cfb\u5185\u5b9a\u4e49 \u88c1\u526a(Clip)\uff1a\u4ece\u573a\u666f\u4e2d\u786e\u5b9a\u4f4d\u4e8e\u7a97\u53e3\u5185\u7684\u56fe\u5f62 \u88c1\u526a\u7a97\u53e3\u548c\u89c6\u533a\u7684\u5173\u7cfb \u6539\u53d8\u89c6\u53e3\u4f4d\u7f6e\u53ef\u4ee5\u5728\u8f93\u51fa\u8bbe\u5907\u7684\u4e0d\u540c\u4f4d\u7f6e\u4e0a\u89c2\u5bdf\u7269\u4f53 \u4f7f\u7528\u591a\u4e2a\u89c6\u53e3\u53ef\u4ee5\u5728\u5c4f\u5e55\u4e0d\u540c\u7684\u4f4d\u7f6e\u89c2\u5bdf\u573a\u666f\u7684\u4e0d\u540c\u90e8\u5206 \u6539\u53d8\u7a97\u53e3\u7684\u5c3a\u5bf8\u8fbe\u5230\u6539\u53d8\u89c6\u53e3\u5185\u663e\u793a\u5bf9\u8c61\u7684\u591a\u5c11 \u6539\u53d8\u89c6\u53e3\uff08\u6216\u7a97\u53e3\uff09\u7684\u5c3a\u5bf8\u5b9e\u73b0\u56fe\u5f62\u5bf9\u8c61\u653e\u7f29 \u4e8c\u7ef4\u663e\u793a\u53d8\u6362 \u4e8c\u7ef4\u56fe\u5f62\u7684\u4e16\u754c\u5750\u6807\u7cfb\u5230\u8bbe\u5907\u5750\u6807\u7cfb\u7684\u6620\u5c04 \u53c8\u79f0\u4e3a\u7a97\u53e3\u5230\u89c6\u533a\u7684\u53d8\u6362\u6216\u7a97\u53e3\u53d8\u6362 \u4e8c\u7ef4\u56fe\u5f62\u7684\u663e\u793a\u6d41\u6c34\u7ebf \u7a97\u53e3\u5230\u89c6\u533a\u7684\u53d8\u6362 \u6b65\u9aa4 \u5728\u4e16\u754c\u5750\u6807\u7cfb\u4e2d\uff0c\u5e73\u79fb\u7a97\u53e3\u4f7f(xmin, ymin)\u81f3\u5750\u6807\u539f\u70b9\uff0c\u53d8\u6362\u4e3aT (\uff0dxmin, \uff0dymin) \u653e\u7f29\u4f7f\u7a97\u53e3\u7684\u5927\u5c0f\u4e0e\u89c6\u533a\u76f8\u7b49\uff0c\u53d8\u6362\u4e3aS(Eu/Ex, Ev/Ey) \u5728\u8bbe\u5907\u5750\u6807\u7cfb\u4e2d\uff0c\u5e73\u79fb\u4f7f\u7a97\u53e3\u4e0e\u89c6\u533a\u91cd\u5408\uff0c\u53d8\u6362\u4e3aT (umin, vmin) OpenGL\u89c6\u533a\u51fd\u6570 glViewport(xvmin,yvmin,vpwidth,vpheight); GLU\u88c1\u526a\u7a97\u53e3\u51fd\u6570 gluOrtho2D(left,right,bottom,top); \u529f\u80fd\uff1a\u5c06\u56fe\u5f62\u6570\u636e\u6620\u5c04\u5230\u5c4f\u5e55\u7684\u6b63\u4ea4\u6295\u5f71\uff0c\u5728\u4e8c\u7ef4\u56fe\u5f62\u4e2d\u53ef\u4ee5\u770b\u505a\u8bbe\u5b9ax\uff0cy\u6700\u5927\u6700\u5c0f\u503c\u3002 \u9ed8\u8ba4\u5927\u5c0f\u4e3a\uff08\uff0d1\uff0c1\uff0c\uff0d1\uff0c1\uff09 \u88c1\u526a \u5b9a\u4e49 \u5224\u65ad\u56fe\u5f62\u5143\u7d20\u662f\u5426\u843d\u5728\u88c1\u526a\u7a97\u53e3\u4e4b\u5185\u5e76\u627e\u51fa\u5176\u4f4d\u4e8e\u5185\u90e8\u7684\u90e8\u5206\u3002 \u88c1\u526a\u7684\u6b21\u5e8f \uff081\uff09\u626b\u63cf\u8f6c\u6362\u540e\u88c1\u526a\uff1a\u8bbe\u5907\u5750\u6807\u7cfb\uff0c\u70b9\u9635\u8868\u793a\u56fe\u5f62 \u7b97\u6cd5\u7b80\u5355\uff08\u5224\u65ad\u50cf\u7d20\u662f\u5426\u843d\u5728\u89c6\u533a\u4e2d\uff09\uff0c\u6240\u6709\u56fe\u5f62\u90fd\u8981\u5148\u626b\u63cf\u8f6c\u6362\uff0c\u901f\u5ea6\u6162\u3002 \uff082\uff09\u88c1\u526a\u540e\u626b\u63cf\u8f6c\u6362\uff1a\u4e16\u754c\u5750\u6807\u7cfb\uff0c\u53c2\u6570\u8868\u793a\u56fe\u5f62 \u6700\u5e38\u7528\uff0c\u8282\u7ea6\u8ba1\u7b97\u65f6\u95f4\uff08\u5148\u5bf9\u53c2\u6570\u8868\u793a\u7684\u56fe\u5f62\u88c1\u526a\uff09\uff0c\u7b97\u6cd5\u590d\u6742 \u5047\u5b9a\u6761\u4ef6 \u77e9\u5f62\u88c1\u526a\u7a97\u53e3\uff1a[xmin, ymin]\uff0d[xmax, ymax] \u88ab\u88c1\u526a\u5bf9\u8c61\uff1a\u7ebf\u6bb5\u3001\u591a\u8fb9\u5f62 \u76f4\u7ebf\u6bb5\u88c1\u526a \u5f85\u88c1\u526a\u7ebf\u6bb5\u548c\u7a97\u53e3\u7684\u5173\u7cfb (1) \u5b8c\u5168\u53ef\u89c1\uff1a\u7aef\u70b9\u4f4d\u4e8e\u7a97\u53e3\u5185AB (2) \u663e\u7136\u4e0d\u53ef\u89c1 \uff1a\u7aef\u70b9\u4f4d\u4e8e\u540c\u8fb9\u754c\u5916\u4fa7EF (3) \u7ebf\u6bb5\u81f3\u5c11\u6709\u4e00\u7aef\u70b9\u5728\u7a97\u53e3\u4e4b\u5916\uff0c\u4f46\u975e\u663e\u7136\u4e0d\u53ef\u89c1 \u76f4\u7ebf\u6bb5\u76f4\u63a5\u6c42\u4ea4\u7b97\u6cd5 \u7aef\u70b9\u4e0e\u7a97\u53e3\u4f4d\u7f6e\u5173\u7cfb (1) \u90fd\u5728\u7a97\u53e3\u5185\uff08\u5b8c\u5168\u53ef\u89c1\uff09 (2) 1\u4e2a\u5728\u7a97\u53e3\u5185\uff0c\u53e6\u4e00\u4e2a\u5728\u5916 (\u67091\u4e2a\u4ea4\u70b9) (3) 2\u4e2a\u90fd\u4e0d\u5728\u7a97\u53e3\u5185 \u663e\u7136\u4e0d\u53ef\u89c1\uff1f\u3001\u53ef\u80fd\u76f8\u4ea4\uff0c2\u4e2a\u4ea4\u70b9\u8fde\u63a5\u7ebf\u6bb5\u3001\u53ef\u80fd\u4e0d\u76f8\u4ea4 \u8ba1\u7b97\u4ea4\u70b9\u65b9\u6cd5 \u7ebf\u6bb5\u4e0e\u7a97\u53e3\u7684\u8fb9\u6c42\u4ea4\u70b9\uff0c\u76f4\u7ebf\u4e0e\u7a97\u53e3\u8fb9\u90fd\u5199\u6210\u53c2\u6570\u5f62\u5f0f\uff0c\u6c42\u53c2\u6570\u503c \u7b97\u6cd5\u6d41\u7a0b \u7279\u70b9 \u65b9\u6cd5\u76f4\u63a5\uff0c\u6613\u61c2\u3002\u4e0d\u80fd\u5feb\u901f\u5224\u65ad\u663e\u7136\u4e0d\u53ef\u89c1\u7684\u7ebf\u6bb5\u3002 \u7f16\u7801\u7b97\u6cd5 \u7b97\u6cd5\u6b65\u9aa4 \u7b2c\u4e00\u6b65 \u5224\u522b\u7ebf\u6bb5\u4e24\u7aef\u70b9\u662f\u5426\u90fd\u843d\u5728\u7a97\u53e3\u5185\uff0c\u5982\u679c\u662f\uff0c\u5219\u7ebf\u6bb5\u5b8c\u5168\u53ef\u89c1\uff1b\u5426\u5219\u8fdb\u5165\u7b2c\u4e8c\u6b65\uff1b \u7b2c\u4e8c\u6b65 \u5224\u522b\u7ebf\u6bb5\u662f\u5426\u4e3a\u663e\u7136\u4e0d\u53ef\u89c1\uff0c\u5982\u679c\u662f\uff0c\u5219\u88c1\u526a\u7ed3\u675f\uff1b\u5426\u5219\u8fdb\u884c\u7b2c\u4e09\u6b65 \uff1b \u7b2c\u4e09\u6b65 \u6c42\u7ebf\u6bb5\u4e0e\u7a97\u53e3\u8fb9\u5ef6\u957f\u7ebf\u7684\u4ea4\u70b9\uff0c\u8fd9\u4e2a\u4ea4\u70b9\u5c06\u7ebf\u6bb5\u5206\u4e3a\u4e24\u6bb5\uff0c\u5176\u4e2d\u4e00\u6bb5\u663e\u7136\u4e0d\u53ef\u89c1\uff0c\u4e22\u5f03\u3002 \u5bf9\u4f59\u4e0b\u7684\u53e6\u4e00\u6bb5\u91cd\u65b0\u8fdb\u884c\u7b2c\u4e00\u6b65\uff0c \u7b2c\u4e8c\u6b65\uff0c\u7b2c\u4e09\u6b65\u5904\u7406\uff0c \u76f4\u81f3\u7ed3\u675f\u3002 \u533a\u57df\u7f16\u7801 \u7531\u7a97\u53e3\u56db\u6761\u8fb9\u6240\u5728\u76f4\u7ebf\u628a\u4e8c\u7ef4\u5e73\u9762\u5206\u62109\u4e2a\u5b50\u533a\u57df\uff0c\u6bcf\u4e2a\u5b50\u533a\u57df\u8d4b\u4e88\u4e00\u4e2a\u56db\u4f4d\u7f16\u7801\uff0c C_tC_bC_rC_l C_tC_bC_rC_l \uff0c\u4e0a\u4e0b\u53f3\u5de6\u3002 \u6839\u636e\u9876\u70b9\u7f16\u7801\u5224\u65ad\u7ebf\u6bb5\u4e0e\u591a\u8fb9\u5f62\u7684\u5173\u7cfb \u5f53\u4e24\u4e2a\u7aef\u70b9\u7684\u7f16\u7801\u5168\u4e3a0\u65f6\uff0c\u7ebf\u6bb5\u5b8c\u5168\u53ef\u89c1\u3002 \u5f53\u7ebf\u6bb5\u7684\u4e24\u4e2a\u7aef\u70b9\u7684\u7f16\u7801\u7684\u903b\u8f91\u201c\u4e0e\u201d\u975e\u96f6\u65f6 \uff0c\u7ebf\u6bb5\u4e3a\u663e\u7136\u4e0d\u53ef\u89c1\u7684\u3002 \uff081\uff09\u6c42\u4ea4\u524d\u5148\u6d4b\u8bd5\u4e0e\u7a97\u53e3\u54ea\u6761\u8fb9\u6240\u5728\u76f4\u7ebf\u6709\u4ea4\uff1f \u89c4\u5219\uff1a\u5224\u65ad\u7aef\u70b9\u7f16\u7801\u4e2d\u5404\u4f4d\u7684\u503c C_tC_bC_rC_l C_tC_bC_rC_l \uff0c\u5206\u522b\u5bf9\u5e94\uff1a\u4e0a\u3001\u4e0b\u3001\u53f3\u548c\u5de6\u8fb9 \u7aef\u70b9\u7801\u503c\u4f4d\u503c\u4e0d\u540c\u65f6\uff0c\u8bf4\u660e\u7ebf\u6bb5\u4e0e\u5bf9\u5e94\u7a97\u53e3\u8fb9\u76f8\u4ea4 \u6b21\u5e8f\uff1a\u4e0a\u3001\u4e0b\u3001\u53f3\u548c\u5de6\u8fb9 \uff082\uff09\u4ee5\u4ea4\u70b9\u4e3a\u754c\uff0c\u4e22\u5f03\u5916\u4fa7\u7ebf\u6bb5\uff0c \u4ee5\u4ea4\u70b9\u4e3a\u65b0\u7aef\u70b9\u5224\u65ad\u53e6\u4e00\u7ebf\u6bb5\uff0c\u91cd\u590d\u7b97\u6cd5\u7684\u6b65\u9aa4 \u7279\u70b9 (1) \u5bf9\u5b8c\u5168\u53ef\u89c1\u548c\u663e\u7136\u4e0d\u53ef\u89c1\u7ebf\u6bb5\u7684\u5feb\u901f\u5224\u522b (2) \u4e8c\u79cd\u573a\u5408\u6548\u7387\u9ad8 \u200b \u5927\u88c1\u526a\u7a97\u53e3\u4ee5\u53ca\u88c1\u526a\u7a97\u53e3\u7279\u522b\u5c0f (\u5982, \u5149\u6807\u62fe\u53d6\u56fe\u5f62\u65f6\uff0c\u5149\u6807\u770b\u4f5c\u5c0f\u7684\u88c1\u526a\u7a97\u53e3\uff09 (3) \u88c1\u526a\u7a97\u53e3\u7684\u62d3\u5c55\u6027 \u200b \u53ef\u4ee5\u5ef6\u4f38\u4e3a\u51f8\u591a\u8fb9\u5f62\uff0c\u4f46\u968f\u7740\u8fb9\u6570\u7684\u589e\u52a0\uff0c\u7f16\u7801\u53d8\u590d\u6742 Liang-Barsky\u88c1\u526a\u7b97\u6cd5 \u57fa\u672c\u601d\u60f3 \u5c06\u4e8c\u7ef4\u88c1\u526a\u5316\u4e3a\u4e00\u7ef4\u88c1\u526a\uff0c\u5411X\uff08\u6216Y\uff09\u65b9\u5411\u6295\u5f71\u4ee5\u51b3\u5b9a\u53ef\u89c1\u7ebf\u6bb5 \u524d\u63d0 \u5e73\u884c\u4e8eX\u6216Y\u8f74\u7684\u7ebf\u6bb5\u8f83\u5bb9\u6613\uff0c\u8fd9\u91cc\u4e0d\u4f5c\u8003\u8651 \u5047\u8bbeP0P1\u6216\u5176\u5ef6\u957f\u7ebf\u5206\u522b\u4e0e\u7a97\u53e3\u5de6\u3001\u4e0b\u3001\u53f3\u548c\u4e0a\u8fb9\uff08\u6216\u5176\u5ef6\u957f\u7ebf\uff09\u4ea4\u4e8eL\uff0cB\uff0cR\uff0cT \u65b9\u6cd5 \u200b \uff084\uff09\u4ee3\u5165\u76f4\u7ebf\u65b9\u7a0b\u5f97\u5230\u4ea4\u70b9\u5750\u6807\u3002 L-B\u7b97\u6cd5\u7684\u6539\u8fdb\uff0c\u51cf\u5c11\u6c42\u4ea4\u70b9\u7684\u6b21\u6570 LL = max(xmin, min(x0, x1)) \uff0cRR = min(xmax, max(x0, x1)) \u7b97\u6cd5 (1)\u5148\u6d4b\u8bd5 LL\u2264RR\uff1f\u4e0d\u6210\u7acb\uff0c\u4e0d\u5b58\u5728\u53ef\u89c1\u7ebf\u6bb5\uff0c\u9000\u51fa\uff1b\u5426\u5219\uff0c\u6267\u884c\uff082\uff09 (2)\u7ebf\u6bb5P1P2\u7684\u659c\u7387K>0? \u4e0d\u662f\u6267\u884c\uff083\uff09\uff0c\u5426\u5219\u6267\u884c\u3002 \u8ba1\u7b97xT, \u6d4b\u8bd5 LL \u2264xT\uff1f\u82e5\u6210\u7acb\uff0c\u8ba1\u7b97xB\uff0c\u6d4b\u8bd5 xB \u2264RR\uff1f\u82e5\u6210\u7acb\uff0c\u6709\u53ef\u89c1\u7ebf\u6bb5\uff1a x\u03b1 = max(LL\uff0cxB); x\u03b2 = min(RR\uff0cxT) (3)K<0:\u8ba1\u7b97xB,\u6d4b\u8bd5 LL \u2264xB\uff1f\u82e5\u6210\u7acb\uff0c\u8ba1\u7b97xT\uff0c\u6d4b\u8bd5 xT \u2264R\uff1f\u82e5\u6210\u7acb\uff0c\u6709\u53ef\u89c1\u7ebf\u6bb5\uff1a x\u03b1 = max(LL ,xT); x\u03b2 = min(RR, xB) \u7279\u70b9 \uff081\uff09\u4e8c\u7ef4\u8f6c\u5316\u4e3a\u4e00\u7ef4\uff082\uff09\u6309\u9700\u6c42\u4ea4\u70b9\uff0c\u63d0\u9ad8\u6548\u7387 \u591a\u8fb9\u5f62\u88c1\u526a S-H\uff08\u9010\u8fb9\uff09\u88c1\u526a\u7b97\u6cd5\u57fa\u672c\u601d\u60f3 \u8f93\u5165\u8f93\u51fa\uff1a\u9876\u70b9\u5e8f\u5217 V_0V_1V_2V_3V_4 \u2026. V_0V_1V_2V_3V_4 \u2026. \u5b9a\u4e49\uff1a \u88c1\u526a\u7ebf\uff1a\u7a97\u53e3\u8fb9\u4ee5\u53ca\u5176\u5ef6\u957f\u7ebf \u5185\u4fa7\u7a7a\u95f4\u4e0e\u5916\u4fa7\u7a7a\u95f4\uff1a\u5305\u542b\u88c1\u526a\u7a97\u53e3\u7684\u534a\u7a7a\u95f4\u4e3a\u5185\u4fa7\u7a7a\u95f4\uff0c\u5426\u5219\u4e3a\u5916\u4fa7\u7a7a\u95f4\u3002 \u591a\u8fb9\u5f62\u4e0e\u7a97\u53e3\u88c1\u526a\u7ebf\u7684\u88c1\u526a \u5316\u89e3\u4e3a\u591a\u8fb9\u5f62\u6bcf\u6761\u8fb9\u4e0e\u88c1\u526a\u7ebf\u88c1\u526a\u3002 \u8fb9\u4e0e\u88c1\u526a\u7ebf\u7684\u88c1\u526a\u65b9\u6cd5\uff1a\u4f9d\u636e\u591a\u8fb9\u5f62\u7684\u8fb9SP\uff08S\u662f\u8d77\u70b9\uff09\u4e0e\u534a\u7a7a\u95f4\uff08\u5185\u5916\u4fa7\uff09\u7684\u5173\u7cfb \u60c5\u51b51\uff1a\u540c\u5728\u5185\u4fa7\uff0c\u88c1\u526a\u540e\u8f93\u51faP \u60c5\u51b52\uff1aS \u5728\u5185\u4fa7\uff0cP \u5728\u5916\u4fa7\uff0c\u88c1\u526a\u540e\u8f93\u51fa\u4ea4\u70b9 i \u60c5\u51b53\uff1a\u540c\u5728\u5916\u4fa7\uff0c\u88c1\u526a\u540e\u4e0d\u8f93\u51fa \u60c5\u51b54\uff1aS \u5728\u5916\u4fa7\uff0c P \u5728\u5185\u4fa7\uff0c\u88c1\u526a\u540e\u8f93\u51fa\u4ea4\u70b9 i \u548c P \u7b97\u6cd5 \u5c06\u9876\u70b9\u5e8f\u5217P1P2\u2026Pn\u4f5c\u4e3a\u8f93\u5165 \u4f9d\u6b21\u5bf9\u7a97\u53e3\u7684\u6bcf\u6761\u88c1\u526a\u7ebf\u4f5c\u4e0b\u5217\u5904\u7406 \u8f93\u5165\u9876\u70b9\u5e8f\u5217 \u4f9d\u6b21\u9876\u70b9\u5e8f\u5217\u4e2d\u76f8\u90bb\u9876\u70b9\u6784\u6210\u7684\u8fb9PiPi+1\u8fdb\u884c\u88c1\u526a\u5904\u7406 \u8f93\u51fa\u9876\u70b9\u5e8f\u5217\uff08\u4e0b\u6761\u88c1\u526a\u7ebf\u7684\u8f93\u5165\uff09 SH\u626b\u63cf\u987a\u5e8f\uff1a\u5de6\u4e0a\u53f3\u4e0b \u7279\u70b9 \u88c1\u526a\u7b97\u6cd5\u91c7\u7528\u6d41\u6c34\u7ebf\u65b9\u5f0f\uff0c\u7b97\u6cd5\u7b80\u5355 \u63a8\u5e7f\u5230\u4efb\u610f\u51f8\u591a\u8fb9\u5f62\u88c1\u526a\u7a97\u53e3 \u539f\u56e0\u662f\uff1a\u51f8\u591a\u8fb9\u5f62\u7684\u8fb9\u80fd\u5c06\u5e73\u9762\u7a7a\u95f4\u5206\u62102\u90e8\u5206\uff0c\u5176\u4e2d\u4e00\u90e8\u5206\u542b\u88c1\u526a\u7a97\u53e3 Weiler-Athenton\u7b97\u6cd5 \u9002\u7528\u4e8e\u88c1\u526a\u7a97\u53e3\u4e3a\u4efb\u610f\u591a\u8fb9\u5f62\uff08\u51f8\u3001\u51f9\u3001\u5e26\u5185\u73af\uff09\u7684\u60c5\u51b5 \u5185\u88c1\u526a\u7279\u70b9 \u88c1\u526a\u7ed3\u679c\u533a\u57df\u7684\u8fb9\u754c\u7531A\u7684\u90e8\u5206\u8fb9\u754c\u548cB\u7684\u90e8\u5206\u8fb9\u754c\u4e24\u90e8\u5206\u6784\u6210\uff0c\u5e76\u4e14\u5728\u4ea4\u70b9\u5904\u8fb9\u754c\u53d1\u751f\u4ea4\u66ff\uff0c\u5373\u7531A\u7684\u8fb9\u754c\u8f6c\u81f3B\u7684\u8fb9\u754c\uff0c\u6216\u7531B\u7684\u8fb9\u754c\u8f6c\u81f3A\u7684\u8fb9\u754c\u3002 \u4ea4\u70b9 \u51fa\u70b9\uff1a\u4e3b\u591a\u8fb9\u5f62\u8fb9\u754c\u7531\u6b64\u79bb\u5f00\u88c1\u526a\u591a\u8fb9\u5f62\u533a\u57df\u3002 \u8fdb\u70b9\uff1a\u4e3b\u591a\u8fb9\u5f62\u8fb9\u754c\u7531\u6b64\u8fdb\u5165\u88c1\u526a\u591a\u8fb9\u5f62\u5185\u3002 \u5b57\u7b26\u88c1\u526a \u57fa\u4e8e\u5b57\u7b26\u4e32 \u6574\u4e2a\u5b57\u7b26\u4e32\u5b8c\u5168\u843d\u5728\u7a97\u53e3\u4e4b\u5185\u65f6\u663e\u793a\uff0c\u5426\u5219\u4e0d\u663e\u793a\u3002 \u5b57\u7b26\u4e32\u7684\u77e9\u5f62\u5305\u56f4\u76d2\u6d4b\u8bd5\u3002 \u57fa\u4e8e\u5b57\u7b26 \u4e00\u4e2a\u5b57\u7b26\u5b8c\u5168\u843d\u5728\u7a97\u53e3\u4e4b\u5185\u65f6\u663e\u793a\uff0c\u5426\u5219\u4e0d\u663e\u793a\u3002 \u5b57\u7b26\u7684\u77e9\u5f62\u5305\u56f4\u76d2\u6d4b\u8bd5\u3002 \u57fa\u4e8e\u6784\u6210\u5b57\u7b26\u7684\u6700\u5c0f\u5143\u7d20 \u70b9\u9635\u5b57\u7b26\uff1a\u70b9\u88c1\u526a \u77e2\u91cf\u5b57\u7b26\uff1a\u7ebf\u88c1\u526a","title":"\u7b2c\u4e94\u7ae0 \u4e8c\u7ef4\u56fe\u5f62\u7684\u663e\u793a"},{"location":"course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/#_7","text":"\u4e09\u7ef4\u56fe\u50cf\u7b80\u4ecb \u4e09\u7ef4\u6210\u50cf\u57fa\u672c\u6b65\u9aa4 \uff081\uff09\u9009\u5b9a\u6295\u5f71\u7c7b\u578b \u2014\u2014 \u5e73\u884c\u3001\u900f\u89c6 \uff082\uff09\u8bbe\u7f6e\u6295\u5f71\u53c2\u6570\u2014\u2014 \u62cd\u6444\u65b9\u5411\u3001\u8ddd\u79bb\u7b49 \uff083\uff09\u4e09\u7ef4\u88c1\u526a \u2014\u2014\u53d6\u666f \uff084\uff09\u6295\u5f71\u548c\u663e\u793a\u2014\u2014\u6210\u50cf \u7b80\u5355\u7684\u4e09\u7ef4\u56fe\u5f62\u663e\u793a\u6d41\u7a0b\u56fe \u5e73\u9762\u51e0\u4f55\u6295\u5f71\u5206\u7c7b \u5e73\u884c\u6295\u5f71(parallel projection)\u6295\u5f71\u4e2d\u5fc3\u4e0e\u6295\u5f71\u5e73\u9762\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e3a\u65e0\u9650 \u900f\u89c6\u6295\u5f71(perspective projection)\u6295\u5f71\u4e2d\u5fc3\u4e0e\u6295\u5f71\u5e73\u9762\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e3a\u6709\u9650 \u900f\u89c6\u6295\u5f71 \u5b9a\u4e49\uff1a\u6295\u5f71\u4e2d\u5fc3\u4e0e\u6295\u5f71\u5e73\u9762\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e3a\u6709\u9650 \u706d\u70b9\uff08vanishing point\uff09 \u4e0d\u5e73\u884c\u4e8e\u6295\u5f71\u5e73\u9762\u7684\u5e73\u884c\u7ebf\uff0c\u7ecf\u8fc7\u900f\u89c6\u6295\u5f71\u4e4b\u540e\u6536\u655b\u4e8e\u4e00\u70b9\uff0c\u79f0\u4e3a\u706d\u70b9\u3002\u706d\u70b9\u7684\u4e2a\u6570\u65e0\u9650 \u4e3b\u706d\u70b9:\u5e73\u884c\u4e8e\u5750\u6807\u8f74\u7684\u5e73\u884c\u7ebf\u7684\u706d\u70b9\u3002 \u4e00\u70b9\u900f\u89c6\uff1a1\u4e2a\u706d\u70b9 \u4e24\u70b9\u900f\u89c6\uff1a2\u4e2a\u706d\u70b9 \u4e09\u70b9\u900f\u89c6\uff1a3\u4e2a\u706d\u70b9 \u7279\u70b9 \u4ea7\u751f\u8fd1\u5927\u8fdc\u5c0f\u7684\u89c6\u89c9\u6548\u679c\uff0c\u7531\u5b83\u4ea7\u751f\u7684\u56fe\u5f62\u6df1\u5ea6\u611f\u5f3a\uff0c\u770b\u8d77\u6765\u66f4\u52a0\u771f\u5b9e\u3002 \u5e73\u884c\u6295\u5f71 \u6295\u5f71\u4e2d\u5fc3\u4e0e\u6295\u5f71\u5e73\u9762\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e3a\u65e0\u9650\uff0c\u662f\u900f\u89c6\u6295\u5f71\u7684\u6781\u9650\u72b6\u6001 \u6b63\u6295\u5f71\u4e0e\u659c\u6295\u5f71 \u6b63\u6295\u5f71(orthogonal projection)\uff1a\u6295\u5f71\u7ebf\u5782\u76f4\u4e8e\u6295\u5f71\u5e73\u9762 \u659c\u6295\u5f71\uff1a\u6295\u5f71\u7ebf\u4e0d\u5782\u76f4\u4e8e\u6295\u5f71\u5e73\u9762 \u4e09\u89c6\u56fe\uff1a\u6b63\u89c6\u56fe\u3001\u4fa7\u89c6\u56fe\u548c\u4fef\u89c6\u56fe\uff0c\u5747\u4e3a\u6b63\u6295\u5f71\u3002 \u89c2\u5bdf\u5750\u6807\u7cfb \u5b9a\u4e49 \u4f9d\u8d56\u4e8e\u6295\u5f71\u5e73\u9762\u5efa\u7acb\u7684\u4e09\u7ef4\u5750\u6807\u7cfbuvn\u3002\u5982\u7167\u76f8\u673a\u6240\u5728\u7684\u5750\u6807\u7cfb\u3002 \u89c2\u5bdf\u5750\u6807\u7cfb\u7684\u5efa\u7acb \u5efa\u7acb\u89c2\u5bdf\u5750\u6807\u7cfb 1. \u5750\u6807\u539f\u70b9----\u6295\u5f71\u5e73\u9762\uff08\u5982\u5e95\u7247\uff09\u4e0a\u7684\u4e00\u70b9\uff0c\u79f0\u4e3a\u89c2\u5bdf\u53c2\u8003\u70b9VRP\uff08View Reference Point) 2. n\u8f74(VPN)----\u7167\u76f8\u673a\u955c\u5934\u53cd\u65b9\u5411\uff08\u6295\u5f71\u5e73\u9762\u7684\u6cd5\u5411\uff09 3. v\u8f74----\u6807\u5fd7\u7269\u4f53\u7684\u671d\u5411\uff0c\u7c7b\u4f3c\u7167\u76f8\u673a\u5411\u4e0a\u7684\u65b9\u5411\uff08\u89c2\u5bdf\u6b63\u5411VUP\u5728\u6295\u5f71\u5e73\u9762\u4e0a\u7684\u6295\u5f71\uff09 4. u\u8f74, u=n \\times v u=n \\times v \u89c2\u5bdf\u5750\u6807\u7cfb\u4e2d\u7684\u6295\u5f71\u53c2\u6570 \u7b80\u5316\u6295\u5f71\u53d8\u6362 \u6295\u5f71\u5e73\u9762 ---- n = 0\uff0c\u6295\u5f71\u4e2d\u5fc3 ---- (0 \uff0c0\uff0cd ) \u6295\u5f71\u524d\u9700\u8981\u5c06\u56fe\u5f62\u5750\u6807\u4ece\u4e16\u754c\uff08\u7528\u6237\uff09\u5750\u6807\u7cfb\u8f6c\u6362\u5230\u89c2\u5bdf\u5750\u6807\u7cfb\u3002 \u89c6\u89c1\u4f53 \u89c6\u89c1\u4f53\u662f\u4e09\u7ef4\u88c1\u526a\u7a97\u53e3\uff0c\u786e\u5b9a\u53ef\u89c1\u7a7a\u95f4 \u5efa\u7acb\u6b65\u9aa4 1 \u5b9a\u4e49\u7a97\u53e3\uff08\u6295\u5f71\u5e73\u9762\u4e0a\uff09 2 \u5f62\u6210\u89c2\u5bdf\u7a7a\u95f4\uff08\u53d1\u51fa\u5c04\u7ebf\uff09 3 \u5f62\u6210\u89c6\u89c1\u4f53\uff08\u524d\u540e\u88c1\u526a\u9762\uff09 \u5efa\u7acb\u7a97\u53e3 \u5728\u6295\u5f71\u5e73\u9762uv\u4e0a \u6307\u5b9a\u53c2\u6570\uff08umin\uff0cvmin\uff09\uff08umax\uff0cvmax) \u7a97\u53e3\u4e2d\u5fc3CW\u4e0d\u4e00\u5b9a\u843d\u5728\u89c2\u5bdf\u53c2\u8003\u70b9VRP\u4e0a \u53ea\u6709\u5728\u7a97\u53e3\u5185\u7684\u56fe\u5f62\u624d\u80fd\u5728\u89c6\u533a\u4e2d\u663e\u793a \u751f\u6210\u89c2\u5bdf\u7a7a\u95f4 \u5b9a\u4e49\u6295\u5f71\u53c2\u8003\u70b9PRP: Projection Reference Point \u4f5c\u7528\uff1a\u786e\u5b9a\u6295\u5f71\u4e2d\u5fc3\uff08\u900f\u89c6\u6295\u5f71\uff09\u6216\u6295\u5f71\u65b9\u5411\uff08\u5e73\u884c\u6295\u5f71\uff09 \u900f\u89c6\u6295\u5f71\uff1aCOP = PRP\uff0c\u89c2\u5bdf\u7a7a\u95f4\u662f\u56db\u68f1\u9525\u3002 \u5e73\u884c\u6295\u5f71\uff1a\u6295\u5f71\u65b9\u5411DOP = \u7a97\u53e3\u4e2d\u5fc3CW - PRP\uff0c\u89c2\u5bdf\u7a7a\u95f4\u662f\u56db\u68f1\u67f1\u3002 \u5f62\u6210\u89c6\u89c1\u4f53 \u89c6\u89c1\u4f53\uff1a\u5b9a\u4e49\u524d\u540e\u88c1\u526a\u9762\uff0c\u5f62\u6210\u6709\u9650\u7684\u89c2\u5bdf\u7a7a\u95f4 \u900f\u89c6\u6295\u5f71\u89c6\u89c1\u4f53\u662f\u56db\u68f1\u53f0\uff1b\u5e73\u884c\u6295\u5f71\u89c6\u89c1\u4f53\u662f\u957f\u65b9\u4f53 \u53c8\u79f0\u4e3a\u88c1\u526a\u7a7a\u95f4 \u5b9a\u4e49\u4e00\u4e2a\u89c6\u89c1\u4f53\u6240\u9700\u8981\u7684\u53c2\u6570 \u53c2\u6570 \u4f5c\u7528 \u6295\u5f71\u7c7b\u578b \u5b9a\u4e49\u6295\u5f71\u662f\u5e73\u884c\u6295\u5f71\u8fd8\u662f\u900f\u89c6\u6295\u5f71 \u89c2\u5bdf\u53c2\u8003\u70b9VRP \u5728\u4e16\u754c\u5750\u6807\u7cfb\u4e2d\u6307\u5b9a\uff0c\u4e3a\u89c2\u5bdf\u5750\u6807\u7cfb\u539f\u70b9 \u89c2\u5bdf\u5e73\u9762\u6cd5\u5411VPN \u5728\u4e16\u754c\u5750\u6807\u7cfb\u4e2d\u6307\u5b9a\uff0c\u4e3a\u89c2\u5bdf\u5750\u6807\u7684n\u8f74 \u89c2\u5bdf\u6b63\u5411VUP \u5728\u4e16\u754c\u5750\u6807\u7cfb\u4e2d\u6307\u5b9a\uff0c\u786e\u5b9a\u89c2\u5bdf\u5750\u6807\u7cfb\u7684v \u6295\u5f71\u53c2\u8003\u70b9PRP \u5728\u89c2\u5bdf\u5750\u6807\u7cfb\u4e2d\u6307\u5b9a\u786e\u5b9a\u6295\u5f71\u4e2d\u5fc3\u6216\u6295\u5f71\u65b9\u5411 \u524d\u88c1\u526a\u9762\u88c1\u8dddF \u5728\u89c2\u5bdf\u5750\u6807\u7cfb\u4e2d\u6307\u5b9a\uff0cn\uff1dF\u4e3a\u524d\u88c1\u526a\u9762 \u540e\u88c1\u526a\u9762\u88c1\u8dddB \u5728\u89c2\u5bdf\u5750\u6807\u7cfb\u4e2d\u6307\u5b9a\uff0cn\uff1dB\u4e3a\u540e\u88c1\u526a\u9762 \u7a97\u53e3umin\uff0cumax\u3001vmin\u3001vmax \u5728\u89c2\u5bdf\u5750\u6807\u7cfb\u7684uv\u5e73\u9762\u4e0a\u6307\u5b9a\uff0c\u786e\u5b9a\u7a97\u53e3\u4e0e\u89c6\u89c1\u4f53 \u6295\u5f71\u53d8\u6362 \u900f\u89c6\u6295\u5f71 \u5728uvn\u4e2d\uff0c\u6295\u5f71\u5e73\u9762\u4e3an = 0\uff0c\u6295\u5f71\u4e2d\u5fc3\u4e3a(0\uff0c0\uff0cd )\uff0c\u6295\u5f71\u53d8\u6362\u77e9\u9635\u4e3a\uff1a \u5e73\u884c\u6295\u5f71 \u4ece\u4e16\u754c\u5750\u6807\u7cfb\u5230\u89c2\u5bdf\u5750\u6807\u7cfb\u7684\u53d8\u6362 \u4e09\u7ef4\u56fe\u5f62\u7684\u663e\u793a\u6d41\u7a0b\u56fe \u6a21\u578b\u53d8\u6362: \u4ece\u5c40\u90e8\uff08\u6a21\u578b\uff09\u5750\u6807\u7cfb\u5230\u4e16\u754c\u5750\u6807\u7cfb\u7684\u53d8\u6362 \u89c2\u5bdf\u53d8\u6362: \u4ece\u4e16\u754c\u5750\u6807\u7cfb\u5230\u89c2\u5bdf\u5750\u6807\u7cfb\u7684\u53d8\u6362 \u6295\u5f71\u53d8\u6362 : \u4e09\u7ef4\u5230\u4e8c\u7ef4\u7684\u8f6c\u6362 \u6a21\u578b\u53d8\u6362 \u5c06\u7269\u4f53\u4ece\u81ea\u8eab\u7684\u6a21\u578b\u5750\u6807\u7cfb\u53d8\u6362\u5230\u4e0a\u5c42\u7269\u4f53\u7684\u6a21\u578b\u5750\u6807\u7cfb\uff08\u6216\u4e16\u754c\u5750\u6807\u7cfb\uff09\u7684\u51e0\u4f55\u53d8\u6362\u3002 \u6a21\u578b\u53d8\u6362\u662f\u6784\u9020\u590d\u6742\u7269\u4f53\u7684\u65b9\u6cd5\uff0c\u901a\u8fc7\u57fa\u672c\u51e0\u4f55\u53d8\u6362\u6784\u9020\u590d\u6742\u7269\u4f53\u3002 \u88c1\u526a \u5148\u6295\u5f71\u540e\u88c1\u526a \u4f18\u70b9\uff1a\u4e8c\u7ef4\u88c1\u526a\u76f8\u5bf9\u5bb9\u6613 \u7f3a\u70b9\uff1a\u9700\u8981\u5bf9\u6240\u6709\u7684\u7269\u4f53\u8fdb\u884c\u6295\u5f71\u53d8\u6362 \u5148\u88c1\u526a\u540e\u6295\u5f71 \u539f\u56e0\u6709\uff1a (1) \u4e09\u7ef4\u7269\u4f53\u7684\u8868\u9762\u901a\u5e38\u88ab\u79bb\u6563\u8868\u793a\u6210\u591a\u8fb9\u5f62\u6216\u6298\u7ebf\uff0c\u800c\u5bf9\u8fd9\u7c7b\u7b80\u5355\u56fe\u5143\uff0c\u4e09\u7ef4\u88c1\u526a\u540c\u6837\u6bd4\u8f83\u7b80\u5355; (2) \u4e09\u7ef4\u56fe\u5f62\u5728\u663e\u793a\u8fc7\u7a0b\u4e2d\u9700\u8981\u88ab\u6d88\u9690\uff0c\u6d88\u9690\u8981\u6709\u56fe\u5f62\u7684\u6df1\u5ea6\u4fe1\u606f\uff0c\u6240\u4ee5\u5fc5\u987b\u5728\u6295\u5f71\u4e4b\u524d\u5b8c\u6210 \u3002 \u6d88\u9690\u5f88\u8d39\u65f6\uff0c\u5982\u679c\u5728\u6b64\u4e4b\u524d\u88c1\u526a\uff08\u6216\u90e8\u5206\u88c1\u526a\uff09\u6389\u4e0d\u53ef\u89c1\u7684\u56fe\u5f62\uff0c\u53ef\u4f7f\u9700\u8981\u6d88\u9690\u7684\u56fe\u5f62\u51cf\u81f3\u6700\u5c0f\u3002\u4e24\u7c7b\u6295\u5f71\u7684\u89c6\u89c1\u4f53\u4e0d\u4e00\u6837\uff0c\u5982\u4f55\u65b9\u4fbf\u88c1\u526a\uff1f\u89c4\u8303\u5316\u5230\u957f\u65b9\u4f53 \u4e09\u7ef4\u88c1\u526a\u7684\u4e24\u79cd\u65b9\u6cd5 \u5728\u4e09\u7ef4\u7a7a\u95f4\u5173\u4e8e\u89c6\u89c1\u4f53\u88c1\u526a\uff0c\u9700\u8981\u5c06\u9f50\u6b21\u5750\u6807\u8f6c\u6362\u4e3a\u4e09\u7ef4\u5750\u6807 \u4f18\u70b9\uff1a\u4e09\u7ef4\u88c1\u526a\u76f8\u5bf9\u5bb9\u6613 \u7f3a\u70b9\uff1a\u9700\u8981\u5c06\u9f50\u6b21\u5750\u6807\u8f6c\u6362\u4e3a\u4e09\u7ef4\u5750\u6807 \u76f4\u63a5\u5728\u56db\u7ef4\u9f50\u6b21\u5750\u6807\u7a7a\u95f4\u4e2d\u8fdb\u884c\u88c1\u526a \u4f18\u70b9\uff1a \u4e0d\u9700\u8981\u5c06\u9f50\u6b21\u5750\u6807\u8f6c\u6362\u4e3a\u4e09\u7ef4\u5750\u6807 \u6709\u7406\u66f2\u7ebf\u66f2\u9762\u53ef\u80fd\u76f4\u63a5\u7528\u9f50\u6b21\u5750\u6807\u6765\u8868\u793a\uff0c\u5bf9\u5b83\u4eec\u7684\u88c1\u526a\u53ea\u80fd\u5728\u9f50\u6b21\u5750\u6807\u7a7a\u95f4\u4e2d\u8fdb\u884c \u7f3a\u70b9\uff1a\u56db\u7ef4\u88c1\u526a\u76f8\u5bf9\u590d\u6742 \u76f4\u7ebf\u6bb5\u88c1\u526a Cohen_Sutherland\u7b97\u6cd5 \u89c6\u89c1\u4f53\u662f\u957f\u65b9\u4f53\uff0c6\u4e2a\u9762\u5206\u7a7a\u95f427\u4e2a\u533a\u57df \u7f16\u7801\uff1a6\u4f4d\uff0cC1C2C3C4C5C6 \u7b97\u6cd5\u8fc7\u7a0b\uff1a \u7c7b\u4f3c\u4e8c\u7ef4\u88c1\u526a Linang_Barskey\u7b97\u6cd5\u7684\u76f4\u63a5\u63a8\u5e7f \uff0d\u4e09\u7ef4\u6295\u5f71\u5230\u4e00\u7ef4 \u8bf1\u5bfc\u7a97\u53e3\u662f3\u6761\u7ebf\u6bb5\u7684\u4ea4\u96c6\u3002 \u591a\u8fb9\u5f62\u88c1\u526a\uff1a\u9010\u9762\u88c1\u526a\u7b97\u6cd5 \u662f\u4e8c\u7ef4\u591a\u8fb9\u5f62Sutherland_Hodgman\u9010\u8fb9\u88c1\u526a\u7b97\u6cd5\u63a8\u5e7f\u3002 \u591a\u8fb9\u5f62\u8fb9\u4e0e\u88c1\u526a\u7ebf\u88c1\u526a\u6269\u5c55\u4e3a\u591a\u8fb9\u5f62\u8fb9\u4e0e\u88c1\u526a\u9762\u88c1\u526a\u3002\u8fb9\u4e0e\u88c1\u526a\u9762\u88c1\u526a\u65f6\u7684\u8f93\u51fa\u89c4\u5219\u4e0e\u4e8c\u7ef4\u7c7b\u4f3c\u3002 \u4e3b\u8981\u8fd0\u7b97\uff1a \u6c42\u7ebf\u6bb5\u4e0e\u5e73\u9762\u7684\u4ea4\u70b9 OpenGL\u76f8\u5173\u51fd\u6570 //\u5efa\u6a21\u89c2\u5bdf\u6a21\u5f0f glMatrixMode \uff08 GL_MODELVIEW \uff09 gluLookAt \uff08 eyex , eyey , eyez , atx , aty , atz , upx , upy , upz \uff09 //\u6307\u5b9a\u89c2\u5bdf\u53c2\u6570 //\u9ed8\u8ba4\u53c2\u6570\uff1a\uff081\uff09eye\uff1d\uff080\uff0c0\uff0c0\uff09\uff082\uff09at\uff1d\uff080\uff0c0\uff0c\uff0d1\uff09\uff083\uff09up\uff1d\uff080\uff0c1\uff0c0\uff09 //\u5efa\u7acb\u6295\u5f71\u53d8\u6362\u77e9\u9635\uff0c\u8bbe\u5b9a\u5f53\u524d\u6295\u5f71\u77e9\u9635 glMatrixMode \uff08 GL_PROJECTION \uff09 //\u6b63\uff08\u5e73\u884c\uff09\u6295\u5f71\u51fd\u6570 glOrtho ( xmin , xmax , ymin , ymax , near , far ) \u6216 glOrtho ( left , right , bottom , top , near , far ) ( 1 ) \u5f62\u6210\u89c6\u89c1\u4f53 ( 2 ) near\u548cfar\u4e3a\u4ece\u89c2\u5bdf\u5750\u6807\u7cfb\u539f\u70b9\u6cbf\u8d1fZ\u8f74\u65b9\u5411\u7684\u8ddd\u79bb \u9ed8\u8ba4\u53c2\u6570 \uff1a glOrtho ( -1.0 , 1.0 , -1.0 , 1.0 , -1.0 , 1.0 ) \u662f\u4e00\u5bf9\u79f0\u89c4\u8303\u5316\u5bf9\u79f0\u6b63\u65b9\u4f53 \u5bf9\u4e8c\u7ef4\u800c\u8a00 \uff0c glOrtho2D\u5efa\u7acb\u88c1\u526a\u7a97\u53e3 \u5982\u4e0d\u6307\u5b9a\u6295\u5f71\u51fd\u6570 \uff0c \u9ed8\u8ba4\u6b63\u6295\u5f71\u6765\u663e\u793a\u573a\u666f //\u900f\u89c6\u6295\u5f71\u51fd\u6570\u5b9a\u4e49\u89c6\u89c1\u4f53 glFrustum ( left , right , bottom , top , near , far ) \u5b9a\u4e49\u89c6\u89c1\u4f53 \u524d\u56db\u4e2a\u53c2\u6570\u8bbe\u5b9a\u6295\u5f71\u5e73\u9762\u4e0a \u88c1\u526a\u7a97\u53e3\u7684\u5750\u6807 \uff08 OpenGL\u6295\u5f71\u5e73\u9762\u4e3a\u8fd1\u88c1\u526a\u9762 \uff09 gluPerspective \uff08 fovy \uff0c aspect \uff0c near \uff0c far \uff09 fovy \uff1a \u4e0a\u4e0b\u88c1\u526a\u9762\u95f4\u7684\u5939\u89d2 \uff08 0 \uff5e 180 \uff09 aspect \uff1a \u88c1\u526a\u7a97\u53e3\u7eb5\u6a2a\u6bd4 \uff08 \u5bbd\u5ea6 / \u9ad8\u5ea6 \uff09 near \uff1a \u8fd1\u88c1\u526a\u9762 far \uff1a \u8fdc\u526a\u9762","title":"\u7b2c\u516d\u7ae0 \u4e09\u7ef4\u56fe\u5f62\u7684\u663e\u793a"},{"location":"course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/#_8","text":"\u6d88\u9690\u6280\u672f \u5b9a\u4e49\uff1a\u6d88\u9664\u88ab\u906e\u6321\u7684\u4e0d\u53ef\u89c1\u7684\u7ebf\u6216\u9762\u79f0\u4f5c\u6d88\u9664\u9690\u85cf\u7ebf\u548c\u9690\u85cf\u9762\uff0c\u7b80\u79f0\u4e3a\u6d88\u9690\u3002 \u6d88\u9690\u7684\u5bf9\u8c61\uff1a\u4e09\u7ef4\u7269\u4f53\uff0c\u4e09\u7ef4\u4f53\u7684\u8868\u793a\u4e3b\u8981\u91c7\u7528\u8fb9\u754c\uff08\u591a\u8fb9\u5f62\uff09\u8868\u793a\u3002 \u6d88\u9690\u7ed3\u679c\uff1a\u4e0e\u89c2\u5bdf\u7269\u4f53\u6709\u5173\uff0c\u4e5f\u4e0e\u89c6\u70b9\u4f4d\u7f6e\u548c\u65b9\u5411\u6709\u5173\u3002 \u753b\u5bb6\u7b97\u6cd5 \u5b9a\u4e49\uff1a\u8fdc\u8fd1\u6392\u5e8f\uff0c\u4e4b\u540e\u6309\u8fdc\u8fd1\u987a\u5e8f\u6295\u5f71\u3002 \u95ee\u9898\uff1a\u4e0d\u80fd\u5904\u7406\u591a\u8fb9\u5f62\u5faa\u73af\u906e\u6321\u548c\u591a\u8fb9\u5f62\u76f8\u4e92\u7a7f\u900f\u3002 Z \uff08\u6df1\u5ea6\uff09\u7f13\u51b2\u5668\u7b97\u6cd5 \u7ec4\u6210 \u5e27\u7f13\u51b2\u5668 -- \u4fdd\u5b58\u5404\u50cf\u7d20\u989c\u8272\u503c\uff0cZ \u7f13\u51b2\u5668 -- \u4fdd\u5b58\u5404\u50cf\u7d20\u5904\u7269\u4f53\u6df1\u5ea6\u503c Z \u7f13\u51b2\u5668\u4e2d\u7684\u5355\u5143\u4e0e\u5e27\u7f13\u51b2\u5668\u4e2d\u7684\u5355\u5143\u4e00\u4e00\u5bf9\u5e94 \u7b97\u6cd5\u6b65\u9aa4 (1) \u5148\u5c06 Z \u7f13\u51b2\u5668\u4e2d\u4e2a\u5355\u5143\u7684\u521d\u59cb\u503c\u7f6e\u4e3a\u6700\u5c0f\u503c\u3002 (2)\u591a\u8fb9\u5f62\u6295\u5f71\u540e\uff0c\u626b\u63cf\u8f6c\u6362\u5199\u5e27\u7f13\u5b58\u65f6\uff0c\u5f53\u8981\u6539\u53d8\u67d0\u4e2a\u50cf\u7d20\u7684\u989c\u8272\u503c\u65f6\uff0c\u9996\u5148\u68c0\u67e5\u8be5\u50cf\u7d20\u5bf9\u5e94\u5f53\u524d\u591a\u8fb9\u5f62\u4e0a\u70b9\u7684\u6df1\u5ea6\u503c\u662f\u5426\u5927\u4e8e\u8be5\u50cf\u7d20\u539f\u6765\u7684\u6df1\u5ea6\u503c\uff08\u4fdd\u5b58\u5728\u8be5\u50cf\u7d20\u6240\u5bf9\u5e94\u7684Z\u7f13\u51b2\u5668\u7684\u5355\u5143\u4e2d\uff09\uff0c \u5982\u679c\u5927\u4e8e\uff0c\u8bf4\u660e\u5f53\u524d\u591a\u8fb9\u5f62\u66f4\u9760\u8fd1\u89c2\u5bdf\u70b9\uff0c\u7528\u5b83\u7684\u989c\u8272\u66ff\u6362\u50cf\u7d20\u539f\u6765\u7684\u989c\u8272\uff1b\u540c\u65f6\u4fdd\u5b58\u6df1\u5ea6\u503c; \u5426\u5219\u8bf4\u660e\u5728\u5f53\u524d\u50cf\u7d20\u5904\uff0c\u5f53\u524d\u591a\u8fb9\u5f62\u88ab\u524d\u9762\u6240\u7ed8\u5236\u7684\u591a\u8fb9\u5f62\u906e\u6321\u4e86\uff0c\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\u50cf\u7d20\u7684\u989c\u8272\u503c\u4e0d\u6539\u53d8\u3002 \u7279\u70b9 (1) Z \u7f13\u51b2\u5668\u7b97\u6cd5\u662f\u6240\u6709\u56fe\u50cf\u7a7a\u95f4\u7b97\u6cd5\u4e2d\u6700\u7b80\u5355\u7684\u4e00\u79cd\u9690\u85cf\u9762\u6d88\u9664\u7b97\u6cd5\u3002\u5728\u50cf\u7d20\u7ea7\u4e0a\u4ee5\u8fd1\u7269\u53d6\u4ee3\u8fdc\u7269\uff0c\u4e0e\u5f62\u4f53\u5728\u5c4f\u5e55\u4e0a\u7684\u51fa\u73b0\u987a\u5e8f\u65e0\u5173\u3002 (2) \u4f18\u70b9 \u7b80\u5355\u7a33\u5b9a\uff0c\u5229\u4e8e\u786c\u4ef6\u5b9e\u73b0\u3001\u4e0d\u9700\u8981\u6574\u4e2a\u573a\u666f\u7684\u51e0\u4f55\u6570\u636e (3) \u7f3a\u70b9 \u9700\u8981\u4e00\u4e2a\u989d\u5916\u7684 Z \u7f13\u51b2\u5668\u3001\u6bcf\u4e2a\u591a\u8fb9\u5f62\u5360\u636e\u7684\u6bcf\u4e2a\u50cf\u7d20\u5904\u90fd\u8981\u8ba1\u7b97\u6df1\u5ea6\u503c\uff0c\u8ba1\u7b97\u91cf\u5927 OpenGL\u76f8\u5173\u51fd\u6570 glClear ( GL_DEPTH_BUFFER_BIT ) //\u6df1\u5ea6\u7f13\u5b58\u521d\u59cb\u5316 \uff08 1 \uff09 \u5728\u6bcf\u663e\u793a\u65b0\u7684\u4e00\u5e27\u524d\u6e05\u9664 \uff08 2 \uff09 \u8bbe\u7f6e\u7684\u9ed8\u8ba4\u503c\u4e3a1 \uff08 3 \uff09 \u8bbe\u7f6e\u521d\u59cb\u503c \uff1a glClearDepth \uff08 maxDepth \uff09 \uff08 4 \uff09 OpenGL\u5141\u8bb8\u6bcf\u4e2a\u50cf\u7d20\u7684\u6df1\u5ea6\u8303\u56f4\u662f0 . .1 \uff0c \u6700\u5927\u503c\u4e3a1\u4e3a\u6700\u8fdc\u70b9 \uff0c \u524d\u9762\u7269\u4f53\u6df1\u5ea6\u503c\u5c0f \u3002 glEnable ( GL_DEPTH_TEST ); //\u6fc0\u6d3b\u51fd\u6570(\u9ed8\u8ba4\u4e3a\u4e0d\u6fc0\u6d3b\uff09 \u6df1\u5ea6\u6d4b\u8bd5\u6bd4\u8f83 \uff1a glDepthFunc ( mode ) \uff0c mode\u53d6GL_LESS \u65f6 \uff0c \u6df1\u5ea6\u503c\u5c0f \uff08 \u8fd1\u5904 \uff09 \u7684\u663e\u793a \uff1b \u53d6GL_GREATER \u65f6 \uff0c \u6df1\u5ea6\u503c\u5927 \uff08 \u8fdc\u5904 \uff09 \u7684\u663e\u793a \u3002 \u7b80\u5355\u5149\u7167\u6a21\u578b \u5f15\u8a00 \u5149\u4f5c\u7528\uff1a\u53cd\u5c04\u3001\u900f\u5c04\uff08\u900f\u660e\u7269\u4f53\uff09\u3001\u88ab\u7269\u4f53\u5438\u6536\u8f6c\u5316\u4e3a\u70ed\u80fd \u5047\u8bbe\uff1a\u7269\u4f53\u4e0d\u900f\u660e\uff0c\u5373\u6ca1\u6709\u900f\u5c04\u5149 \u5149\u79cd\u7c7b\uff1a\u73af\u5883\u5149\u3001\u6f2b\u53cd\u5c04\u5149\u548c\u955c\u9762\u53cd\u5c04\u5149 \u73af\u5883\u5149 \u5728\u7269\u4f53\u548c\u5468\u56f4\u73af\u5883\u4e4b\u95f4\u591a\u6b21\u53cd\u5c04\u540e\uff0c\u6700\u7ec8\u8fbe\u5230\u5e73\u8861\u65f6\u7684\u4e00\u79cd\u5149\uff0c\u53c8\u79f0\u4e3a\u80cc\u666f\u5149 \u5149\u5f3a\uff08\u5ea6\uff09\uff1a\u7a7a\u95f4\u4e0a\u5206\u5e03\u5747\u5300\uff0c\u5373\u4efb\u4f55\u4f4d\u7f6e\u548c\u65b9\u5411\u5149\u5f3a\u5ea6\u4e00\u6837\uff0c\u4eae\u5ea6\u503c\u8bb0\u4e3a I_a I_a \u53cd\u5c04\u7cfb\u6570\uff1a\u4e0e\u7269\u4f53\u8868\u9762\u6027\u8d28\u6709\u5173\uff0c\u51b3\u5b9a\u7269\u4f53\u8868\u9762\u5448\u73b0\u7684\u4eae\u5ea6\uff0c\u8bb0\u4e3a K_a K_a \u5149\u7167\u6a21\u578b\u65b9\u7a0b I_e = K_\u03b1*I_\u03b1 I_e = K_\u03b1*I_\u03b1 \uff0c I_e I_e \u4e3a\u7269\u4f53\u8868\u9762\u5448\u73b0\u7684\u4eae\u5ea6\u3002 ( I_a I_a \u53ef\u4ee5\u770b\u7740\u662f\u989c\u8272\u7684\u5206\u91cf\uff1b K_a K_a \u4e3a\u5bf9\u5e94\u7684\u5206\u91cf\u53cd\u5c04\u7cfb\u6570\uff09 \u6f2b\u53cd\u5c04 \u70b9\u5149\u6e90\uff1a\u5411\u5468\u56f4\u6240\u6709\u65b9\u5411\u53d1\u5c04\u7b49\u5f3a\u5ea6\u7684\u5149\u3002 \u6f2b\u53cd\u5c04\u5149\u662f\u7531\u7269\u4f53\u8868\u9762\u7684\u7c97\u7cd9\u4e0d\u5e73\u5f15\u8d77\u7684\uff0c\u5b83\u5747\u5300\u5730\u5411\u5404\u4e2a\u65b9\u5411\u4f20\u64ad\uff0c\u4e0e\u89c6\u70b9\u4f4d\u7f6e\u65e0\u5173\u3002 \u6f2b\u53cd\u5c04\u5149\u5728\u7a7a\u95f4\u5747\u5300\u5206\u5e03\uff0c\u53cd\u5c04\u5149\u5f3a I \u4e0e\u5165\u5c04\u5149\u7684\u5165\u5c04\u89d2\u03b8 \u7684\u4f59\u5f26\u6210\u6b63\u6bd4\uff0c\u5373\uff1a I_d=K_d*I_p*cos \\theta I_d=K_d*I_p*cos \\theta \u5176\u4e2d\uff0cKd \u662f\u6f2b\u53cd\u5c04\u7cfb\u6570\uff080\uff5e1\u4e4b\u95f4\u7684\u5e38\u6570\uff09\uff0c\u4e0e\u7269\u4f53\u8868\u9762\u6027\u8d28\u6709\u5173\uff1bIp \u662f\u5149\u6e90\u7684\u5149\u5f3a\uff1b\u03b8\u662f\u5165\u5c04\u5149\u7684\u5165\u5c04\u89d2\uff0c\u5373\u5165\u5c04\u5149\u4e0e\u7269\u4f53\u8868\u9762\u6cd5\u5411\u91cf\u4e4b\u95f4\u7684\u5939\u89d2\u3002 \u5411\u91cf\u8ba1\u7b97 \u8bbe\u7269\u4f53\u8868\u9762\u5728\u7167\u5c04\u70b9 P \u5904\u7684\u5355\u4f4d\u6cd5\u5411\u91cf\u4e3aN\uff0cP \u5230\u70b9\u5149\u6e90\u7684\u5355\u4f4d\u5411\u91cf\u4e3aL\uff0c\u5219\u4e0a\u5f0f\u53ef\u8868\u8fbe\u4e3a\u5982\u4e0b\u7684\u5411\u91cf\u5f62\u5f0f\uff1a I_d=K_d*I_p*(N\\cdot L) I_d=K_d*I_p*(N\\cdot L) \u591a\u4e2a\u5149\u6e90 \u628a\u5404\u4e2a\u5149\u6e90\u7684\u6f2b\u53cd\u5c04\u5149\u7167\u6548\u679c\u8fdb\u884c\u53e0\u52a0\uff1a I_d=K_d*\\sum_{i=1}^mI_{pi}*(N \\cdot L_i) I_d=K_d*\\sum_{i=1}^mI_{pi}*(N \\cdot L_i) \u6f2b\u53cd\u5c04\u5149\u548c\u73af\u5883\u5149\u76f8\u7ed3\u5408 I=I_e+I_d=I_\u03b1 I_\u03b1+I_p I_d (L\u2219N) I=I_e+I_d=I_\u03b1 I_\u03b1+I_p I_d (L\u2219N) \u955c\u9762\u53cd\u5c04\u5149\u548c\u51af\uff08Phong\uff09\u53cd\u5c04\u6a21\u578b \u9ad8\u5149\uff08high light\uff09\uff1a\u5149\u6ed1\u7269\u4f53\u8868\u9762\u5728\u70b9\u5149\u6e90\u7684\u7167\u5c04\u4e0b\u5f62\u6210\u4e00\u5757\u7279\u522b\u4eae\u7684\u533a\u57df \u955c\u9762\u53cd\u5c04\uff08Specular Reflection\uff09 \u7269\u4f53\u8868\u9762\u5bf9\u5165\u5c04\u5149\u7684\u53cd\u5c04 \u9075\u5faa\u53cd\u5c04\u5b9a\u5f8b \uff081\uff09\u53cd\u5c04\u5149\u4e0e\u5165\u5c04\u5149\u4f4d\u4e8e\u8868\u9762\u6cd5\u5411\u4e24\u4fa7 \uff082\uff09\u7406\u60f3\u53cd\u5c04\u9762\u800c\u8a00\uff1a\u5165\u5c04\u89d2\uff1d\u53cd\u5c04\u89d2 \u89c2\u5bdf\u8005\u5728\u53cd\u5c04\u65b9\u5411\u4e0a\u770b\u5230\u53cd\u5c04\u5149\u6700\u5f3a Phong\u6a21\u578b \u8ba1\u7b97\u516c\u5f0f\uff1a I_s=I_p K_s cos ^n \\alpha =I_P K_s (N \\cdot R) ^n I_s=I_p K_s cos ^n \\alpha =I_P K_s (N \\cdot R) ^n Ks\u662f\u7269\u4f53\u8868\u9762\u955c\u9762\u53cd\u5c04\u7cfb\u6570\uff0c\u5b83\u4e0e\u7269\u4f53\u5c5e\u6027\u6709\u5173\uff1b \u03b1 \u662f\u89c6\u7ebf\u4e0e\u53cd\u5c04\u65b9\u5411\u7684\u5939\u89d2\uff1b n \u4e3a\u955c\u9762\u9ad8\u5149\u7cfb\u6570\uff0c\u7528\u6765\u6a21\u62df\u955c\u9762\u53cd\u5c04\u5149\u5728\u7a7a\u95f4\u4e2d\u7684\u6c47\u805a\u7a0b\u5ea6\uff0c\u5b83\u662f\u4e00\u4e2a\u53cd\u6620\u7269\u4f53\u8868\u9762\u5149\u6cfd\u5ea6\u7684\u5e38\u6570\uff1b $cos^n \\alpha $\u8fd1\u4f3c\u5730\u63cf\u8ff0\u4e86\u955c\u9762\u53cd\u5c04\u5149\u7684\u7a7a\u95f4\u5206\u5e03\u3002 n\u8d8a\u5927\uff0c\u9ad8\u5149\u533a\u57df\u8870\u51cf\u8d8a\u5feb\uff0c\u9ad8\u5149\u533a\u57df\u8d8a\u5c0f\uff0c\u5e38\u89c4\u53d6\u503c 5-20\u3002 \u7b80\u5316Phong\u6a21\u578b \u5c40\u90e8\u5149\u7167\u65b9\u7a0b I=I_{\\alpha}+I_d+I_s=K_{\\alpha}I_{\\alpha}+I_p[K_d(N \\cdot L)+K_s(H \\cdot N) ^n] I=I_{\\alpha}+I_d+I_s=K_{\\alpha}I_{\\alpha}+I_p[K_d(N \\cdot L)+K_s(H \\cdot N) ^n] \u5f53\u5149\u6e90\u548c\u89c6\u70b9\u65e0\u7a77\u8fdc\u65f6\uff0c\u5bf9\u8868\u9762\u4e0a\u4efb\u610f\u4e00\u70b9\u800c\u8a00\uff0cL\u548cV\u56fa\u5b9a\u4e0d\u53d8\uff0cH\u53ea\u9700\u8ba1\u7b97\u4e00\u6b21\u3002 \u4ea7\u751f\u989c\u8272 \u524d\u9762\u7684\u5149\u7167\u6a21\u578b\u4ec5\u7528\u4e8e\u767d\u5149\uff0c\u53ea\u80fd\u4ea7\u751f\u7070\u5ea6 \u5f69\u8272\u6a21\u578b\u8ba1\u7b97 \u9009\u62e9\u5408\u9002\u6a21\u578b\uff08\u5982RGB\u3001HSV\u7b49\uff09\uff0c\u4e3a\u989c\u8272\u7684\u4e09\u4e2a\u5206\u91cf\u5206\u522b\u5efa\u7acb\u5149\u7167\u65b9\u7a0b\u3002 RGB\u6a21\u578b \u5149\u6e90\u7684\u989c\u8272 [I_{pR}, I_{pG}, I_{pB}] [I_{pR}, I_{pG}, I_{pB}] \uff0c\u73af\u5883\u5149\u7684\u989c\u8272 [I_{aR}, I_{aG}, I_{aB}] [I_{aR}, I_{aG}, I_{aB}] \u8868\u9762\u53cd\u5c04\u7cfb\u6570 \uff081\uff09\u73af\u5883\u53cd\u5c04\uff1a [KaR, KaG, KaB] \uff082\uff09\u6f2b\u53cd\u5c04\uff1a [KdR, KdG, KdB] \uff083\uff09\u955c\u9762\u53cd\u5c04\uff1a [KsR, KsG, KsB] \u5f69\u8272\u5149\u7167\u65b9\u7a0b\uff08\u6a21\u578b\uff09 f(d)\u4e3a\u5149\u7684\u8870\u51cf \u591a\u4e2a\u5149\u6e90 \u5982\u679c\u573a\u666f\u4e2d\u6709m\u4e2a\u5149\u6e90\uff0c\u90a3\u4e48\u7269\u4f53\u4e0a\u4efb\u4e00\u70b9\u7684\u4eae\u5ea6\u5e94\u8be5\u4e3am\u4e2a\u5149\u6e90\u7684\u8d21\u732e\u4e4b\u548c\u3002 \u5728RGB\u5f69\u8272\u6a21\u578b\u4e2d\uff0c\u03bb\u5206\u522b\u4e3aR\u3001G\u548cB\u3002 \u200b \u6ce8\u610f\uff1aI\u03bb\u53ef\u80fd\u4f1a\u8d85\u51fa\u7cfb\u7edf\u5141\u8bb8\u7684\u6700\u5927\u4eae\u5ea6\u503c\uff0c\u5904\u7406\u65b9\u6cd5 \u200b \uff081\uff09\u622a\u53bb\u8d85\u51fa\u90e8\u5206\uff0c\u8bbe\u7f6e\u4e3a\u6700\u5927\u503c \u200b \uff082\uff09\u9996\u5148\u8ba1\u7b97\u51fa\u6240\u6709\u4eae\u5ea6\u503c\uff0c\u518d\u8fdb\u884c\u53d8\u6362\uff08\u5982\u7f29\u653e\u53d8\u6362\uff09\u4f7f\u5176\u843d\u5728\u7cfb\u7edf\u89c4\u5b9a\u8303\u56f4\u4e4b\u5185 OpenGL\u76f8\u5173\u51fd\u6570 void glLight { if }[ v ]( GLenum light , GLenum pname , TYPE param ); //\u521b\u5efa\u5149\u6e90 void glMaterial { if }[ v ]( GLenum face , GLenum pname , TYPE param ); //\u8bbe\u7f6e\u6750\u8d28 glEnable ( GL_LIGHTING ); //\u5f00\u542f\u5149\u6e90 glEnable ( GL_LIGHT0 ); //\u5f00\u542f\u5149\u6e90 \u591a\u8fb9\u5f62\u7ed8\u5236\u65b9\u6cd5 \u5f53\u7ed8\u5236\u591a\u8fb9\u5f62\u65f6\u5165\u5c04\u5149\u77e2\u91cf\u53ca\u53cd\u5c04\u5149\u4e0e\u89c6\u7ebf\u5939\u89d2\u4e0d\u540c\uff0c\u6240\u4ee5\u989c\u8272\u4e0d\u540c\u3002 \u591a\u8fb9\u5f62\u5747\u5300\u7740\u8272 \u65b9\u6cd5 \u4efb\u53d6\u591a\u8fb9\u5f62\u4e0a\u4e00\u70b9\uff0c\u5229\u7528\u5149\u7167\u660e\u65b9\u7a0b\u8ba1\u7b97\u51fa\u5b83\u7684\u989c\u8272 \u7528\u8fd9\u4e2a\u989c\u8272\u586b\u5145\u6574\u4e2a\u591a\u8fb9\u5f62 \u9002\u5408\u4e8e\u5982\u4e0b\u60c5\u51b5 \u5149\u6e90\u5728\u65e0\u7a77\u8fdc\u5904\uff0cL\u00b7N \u76f8\u7b49 \u89c6\u70b9\u5728\u65e0\u7a77\u8fdc\u5904\uff0cH\u00b7N \u76f8\u7b49 \u591a\u8fb9\u5f62\u662f\u7269\u4f53\u8868\u9762\u7684\u7cbe\u786e\u8868\u793a\uff08\u591a\u8fb9\u5f62\u9762\u79ef\u8db3\u591f\u5c0f\uff09 \u7279\u70b9 \u4f18\u70b9\uff1a\u6bcf\u4e2a\u591a\u8fb9\u5f62\u53ea\u9700\u8ba1\u7b97\u4e00\u6b21\u5149\u7167\u660e\u65b9\u7a0b\uff0c\u901f\u5ea6\u5feb \u7f3a\u70b9\uff1a\u76f8\u90bb\u591a\u8fb9\u5f62\u989c\u8272\u8fc7\u6e21\u4e0d\u5149\u6ed1 Gouraud \u7740\u8272\u65b9\u6cd5\uff08\u989c\u8272\u63d2\u503c\u65b9\u6cd5\uff09 \u4e3b\u8981\u6b65\u9aa4 \uff081\uff09\u8ba1\u7b97\u591a\u8fb9\u5f62\u7684\u5355\u4f4d\u6cd5\u5411\u91cf \uff082\uff09\u8ba1\u7b97\u591a\u8fb9\u5f62\u9876\u70b9\u7684\u5355\u4f4d\u6cd5\u5411\u91cf\uff08\u5171\u4eab\u9876\u70b9\u7684\u591a\u8fb9\u5f62\u6cd5\u5411\u91cf\u7684\u5e73\u5747\u503c\uff09 \uff083\uff09\u5229\u7528\u5149\u7167\u660e\u65b9\u7a0b\u8ba1\u7b97\u9876\u70b9\u989c\u8272 \uff084\uff09\u5bf9\u591a\u8fb9\u5f62\u9876\u70b9\u989c\u8272\u8fdb\u884c\u53cc\u7ebf\u6027\u63d2\u503c\uff0c\u83b7\u5f97\u591a\u8fb9\u5f62\u5185\u90e8\u5404\u70b9\u7684\u989c\u8272 1. \u8ba1\u7b97\u591a\u8fb9\u5f62\u5355\u4f4d\u6cd5\u5411\u91cf <img src=\"https://pic.tim-wcx.ltd//img/20211210151447.png\" alt=\"image-20211210151447383\" style=\"zoom:67%;\" /> \u5185\u90e8\u70b9\u989c\u8272\u8ba1\u7b97\uff1a\u53cc\u7ebf\u6027\u63d2\u503c \u589e\u91cf\u6cd5\u4f18\u5316 Phong \u7740\u8272\u65b9\u6cd5\uff08\u6cd5\u5411\u63d2\u503c\u7740\u8272\u65b9\u6cd5\uff09 \u65b9\u6cd5\uff1a\u901a\u8fc7\u5bf9\u591a\u8fb9\u5f62\u9876\u70b9\u6cd5\u5411\u91cf\u8fdb\u884c\u63d2\u503c\uff0c\u83b7\u5f97\u591a\u8fb9\u5f62\u5185 \u90e8\u5404\u70b9\u7684\u6cd5\u5411\u91cf\uff0c\u518d\u5229\u7528\u5149\u7167\u65b9\u7a0b\u8ba1\u7b97\u5404\u70b9\u7684\u4eae\u5ea6 \u4e3b\u8981\u6b65\u9aa4\uff1a \uff081\uff09\u8ba1\u7b97\u591a\u8fb9\u5f62\u5355\u4f4d\u6cd5\u5411\u91cf \uff082\uff09\u8ba1\u7b97\u591a\u8fb9\u5f62\u9876\u70b9\u5355\u4f4d\u6cd5\u5411\u91cf\uff08\u4ee5\u4e0a\u4e24\u6b65\u540cGouraud\u7740\u8272\u65b9\u6cd5\uff09 \uff083\uff09\u5bf9\u591a\u8fb9\u5f62\u9876\u70b9\u6cd5\u5411\u91cf\u8fdb\u884c\u53cc\u7ebf\u6027\u63d2\u503c\uff0c\u83b7\u5f97\u5185\u90e8\u5404\u70b9\u7684\u6cd5\u5411\u91cf \uff084\uff09\u5229\u7528\u5149\u7167\u660e\u65b9\u7a0b\u8ba1\u7b97\u591a\u8fb9\u5f62\u5185\u90e8\u5404\u70b9\u989c\u8272 Phong\u63d2\u503c\u4f18\u5316\u540c\u9ad8\u6d1b\u5fb7\uff0c\u53ea\u662f\u5c06\u989c\u8272\u63d2\u503c\u66ff\u6362\u4e3a\u5411\u91cf\u63d2\u503c\uff0c\u626b\u63cf\u7ebf\u4f18\u5316\u540c\uff0c\u5728\u6b64\u7701\u7565\uff0c \u5747\u5300\u7740\u8272\u3001Gouraud \u548cPhong\u65b9\u6cd5\u6bd4\u8f83 \uff081\uff09\u5747\u5300\u7740\u8272\uff08Flat\uff09\u5757\u72b6\u73b0\u8c61\u660e\u663e\uff0c\u8ba1\u7b97\u5f00\u9500\u5c0f \uff082\uff09 Gouraud\u65b9\u6cd5\u5149\u53d8\u5316\u8fc7\u6e21\u4e0d\u8fde\u7eed\uff0c\u8ba1\u7b97\u5f00\u9500\u8f83\u5927 \uff083\uff09Phong\u65b9\u6cd5\u5149\u53d8\u5316\u8fc7\u6e21\u8fde\u7eed\uff0c\u8ba1\u7b97\u5f00\u9500\u5927 \u7eb9\u7406\u6620\u5c04 \u5f15\u8a00 \u5149\u7167\u6a21\u578b\u53ea\u80fd\u751f\u6210\u5149\u6ed1\u7684\u7269\u4f53\u8868\u9762 \u81ea\u7136\u754c\u4e2d\u7684\u7269\u4f53\u8868\u9762\u5177\u6709\u4e30\u5bcc\u7684\u7ec6\u8282\uff0c\u5982\u6728\u7eb9\u3001\u6854\u5b50\u51f9\u51f8\u8868\u9762\u3001\u6c99\u783e\u8def\u9762 \u4e30\u5bcc\u7684\u8868\u9762\u7ec6\u8282\u96be\u4ee5\u7528\u8ba1\u7b97\u673a\u56fe\u5f62\u65b9\u6cd5\u751f\u6210 \u91c7\u7528\u5c06\u56fe\u7247\u8d34\u5230\u7269\u4f53\u8868\u9762\u4e0a\u7684\u65b9\u6cd5\u7ed8\u5236 \u4ec0\u4e48\u662f\u7eb9\u7406\uff1f \u662f\u7269\u4f53\u8868\u9762\u7684\u7ec6\u5c0f\u7ed3\u6784\uff0c\u5b83\u53ef\u4ee5\u662f\u5149\u6ed1\u8868\u9762\u7684\u82b1\u7eb9\u3001\u56fe\u6848\uff0c\u5373\u989c\u8272\u7eb9\u7406(2D)\u3002 \u7eb9\u7406\u4e5f\u53ef\u4ee5\u662f\u7269\u4f53\u8868\u9762\u7684\u4e09\u7ef4\u7ed3\u6784 \u7eb9\u7406\u8fd8\u53ef\u4ee5\u662f\u7c97\u7cd9\u7684\u8868\u9762(\u5982\u6854\u5b50\u8868\u9762\u7684\u76b1\u7eb9)\uff0c\u79f0\u4e3a\u51e0\u4f55\u7eb9\u7406\uff0c\u662f\u57fa\u4e8e\u7269\u4f53\u8868\u9762\u7684\u5fae\u89c2\u51e0\u4f55\u5f62\u72b6\u7684\u8868\u9762\u7eb9\u7406\u3002 \u7eb9\u7406\u7a7a\u95f4\uff1a\u7eb9\u7406\u56fe\u6848\u6240\u5728\u7a7a\u95f4\uff0c\u8bb0\u4e3ast\u5750\u6807\u7cfb\uff08\u4e00\u822c\u662f\u5e73\u9762\uff09 \u7eb9\u7d20\uff08texel\uff09\uff1a\u7eb9\u7406\u6700\u5c0f\u5355\u5143\uff0c\u4f4d\u7f6e\u7531\u7eb9\u7406\u5750\u6807\uff08s\uff0ct\uff09\u6807\u8bc6 \u7eb9\u7406\u5750\u6807s\uff0ct\uff1a0\u52301\u95f4\u53d6\u503c \u56fe\u50cf\u50cf\u7d20\u5750\u6807\u89c4\u8303\u5316\u5230[0\u20261]\u533a\u95f4\u3002\u89c4\u8303\u5316\u540e\u65b9\u4fbf\u4f7f\u7528\u7eb9\u7406\u5750\u6807\u3002 \u7eb9\u7406\u6765\u6e90 \u6570\u5b57\u56fe\u50cf\uff0c\u7528\u4e8c\u7ef4\u6570\u7ec4\u8868\u793a \u6570\u5b66\u516c\u5f0f\u5b9a\u4e49\u7eb9\u7406 \u7eb9\u7406\u6620\u5c04\uff08Texture Mapping\uff09 \u5b9a\u4e49\uff1a\u5c06\u7eb9\u7406\u56fe\u6848\u6620\u5c04\u5230\u7269\u4f53\u8868\u9762\u4e0a\uff0c\u4ea7\u751f\u7269\u4f53\u8868\u9762\u7ec6\u8282\u7684\u8fc7\u7a0b \u989c\u8272\u8ba1\u7b97\u65b9\u6cd5 (1) \u7528\u8868\u9762\u4e0a\u70b9\u5bf9\u5e94\u7684\u7eb9\u7d20\u503c\u4ee3\u66ff\u8be5\u70b9\u7684\u6f2b\u53cd\u5c04\u7cfb\u6570 (2) \u7528\u8868\u9762\u4e0a\u70b9\u5bf9\u5e94\u7684\u7eb9\u7d20\u503c\u4ee3\u66ff\u8be5\u70b9\u7684\u989c\u8272\u503c \u7eb9\u7406\u5750\u6807\uff1a\u786e\u5b9a\u7eb9\u7406\u4e0e\u7269\u4f53\u8868\u9762\u7684\u5bf9\u5e94\u5173\u7cfb\uff08\u7eb9\u7d20\u4e0e\u9876\u70b9\uff09\uff0c\u53d8\u5316\u8303\u56f4[0,1]\u3002\u591a\u8fb9\u5f62\u6bcf\u4e2a\u9876\u70b9\u5bf9\u5e94\u4e00\u4e2a\u7eb9\u7d20\uff0c\u5185\u90e8\u70b9\u63d2\u503c\u8ba1\u7b97\u5bf9\u5e94\u7eb9\u7d20\u3002 \u5706\u67f1\u66f2\u9762\u7eb9\u7406\u6620\u5c04 P(\\theta,y)=(r cos \\theta,r sin \\theta),-\\frac{h}{2}\\leq y \\leq \\frac{h}{2} P(\\theta,y)=(r cos \\theta,r sin \\theta),-\\frac{h}{2}\\leq y \\leq \\frac{h}{2} \u5bf9\u5e94\u7684\u7eb9\u7406\u5750\u6807\uff1a s=\\frac{\\theta}{360},t=\\frac{y+\\frac{h}{2}}{h} s=\\frac{\\theta}{360},t=\\frac{y+\\frac{h}{2}}{h} \u7403\u9762\u66f2\u9762\u7eb9\u7406\u6620\u5c04 p(\\theta,\\phi)=(rcos\\theta cos\\phi,rsin \\phi,rsin\\theta cos\\phi) p(\\theta,\\phi)=(rcos\\theta cos\\phi,rsin \\phi,rsin\\theta cos\\phi) \u03b8\u548c\u03c6\u53d8\u5316\u8303\u56f4\u5206\u522b[0,360]\u548c[-90,90] \u5bf9\u5e94\u7684\u7eb9\u7406\u5750\u6807\uff1a s=\\frac{\\theta }{360},t=\\frac{\\phi}{180}+\\frac{1}{2} s=\\frac{\\theta }{360},t=\\frac{\\phi}{180}+\\frac{1}{2} s=\\frac{\\theta }{360},t=\\frac{sin \\phi }{2}+\\frac{1}{2} s=\\frac{\\theta }{360},t=\\frac{sin \\phi }{2}+\\frac{1}{2} \u5706\u73af\u9762 OpenGL\u51fd\u6570 \u7b80\u4ecb \u7eb9\u7406\u6620\u5c04\u662f\u4e00\u4e2a\u76f8\u5f53\u590d\u6742\u7684\u8fc7\u7a0b\uff0c\u6700\u57fa\u672c\u7684\u6267\u884c\u7eb9\u7406\u6620\u5c04\u6240\u9700\u7684\u6b65\u9aa4\u3002\u57fa\u672c\u6b65\u9aa4\u5982\u4e0b\uff1a \uff081\uff09\u5b9a\u4e49\u7eb9\u7406\uff1b\u7ed9\u7eb9\u7406\u6570\u636e \uff082\uff09\u63a7\u5236\u6ee4\u6ce2\uff1b\u91cd\u91c7\u6837\u65b9\u5f0f \uff083\uff09\u8bf4\u660e\u6620\u5c04\u65b9\u5f0f\uff1b \uff084\uff09\u6fc0\u6d3b\u7eb9\u7406\uff1b \uff085\uff09\u7ed8\u5236\u56fe\u5f62\u65f6\u9700\u8fdb\u884c\u7eb9\u7406\u6620\u5c04\uff0c\u5373\u7ed9\u51fa\u9876\u70b9\u7684\u7eb9\u7406\u5750\u6807\u548c\u51e0\u4f55\u5750\u6807\u3002 \u200b \u6ce8\u610f\uff1a\u7eb9\u7406\u6620\u5c04\u53ea\u80fd\u5728RGBA\u65b9\u5f0f\u4e0b\u6267\u884c\uff0c\u4e0d\u80fd\u8fd0\u7528\u4e8e\u989c\u8272\u8868\u65b9\u5f0f\u3002 ( 1 ) \u5b9a\u4e49\u7eb9\u7406 glGenTextures ( 1 , & uiTexture ); // GLuint uiTexture void glTexImage2D ( GLenum target , GLint level , Glint components , GLsizei width , glsizei height , GLint border , GLenum format , GLenum type , const GLvoid * pixels ); ( 2 ) \u7ed1\u5b9a\u56fe\u7247 gluBuild2DMipmaps ( GLenum target , Glint components , GLsizei width , glsizei height , GLenum format , GLenum type , const GLvoid * pixels ); ( 3 ) \u63a7\u5236\u6ee4\u6ce2 void glTexParameter { if }[ v ]( GLenum target , GLenum pname , TYPE param ); ( 4 ) \u8bbe\u7f6e\u7eb9\u7406\u6620\u5c04\u65b9\u5f0f void glTexEnv { if }[ v ]( GLenum target , GLenum pname , TYPE param ); ( 5 ) \u6fc0\u6d3b\u7eb9\u7406 glEnable ( GL_TEXTURE_2D ); ( 6 ) \u5b9a\u4e49\u7eb9\u7406\u5750\u6807 void glTexCoord { 1234 }{ sifd }[ v ]( TYPE coords ); \u6ce8\u610f \uff1a \u4f7f\u7528\u591a\u4e2a\u7eb9\u7406\u65f6 \uff0c \u9700\u8981\u5728\u5b9a\u4e49\u70b9\u7eb9\u7406\u5750\u6807\u4e4b\u524d \uff0c \u6307\u5b9a\u6240\u7528\u7eb9\u7406 \u3002 glBindTexture ( GL_TEXTURE_2D , id ); \u9634\u5f71 \u9634\u5f71\uff08Shadow\uff09 \u5149\u6e90\u4e0d\u80fd\u76f4\u63a5\u7167\u5c04\u5230\u7684\u533a\u57df \u7279\u70b9 \u4f4d\u4e8e\u9634\u5f71\u533a\u57df\u4e2d\u7684\u7269\u4f53\u8868\u9762\u88ab\u4f4d\u4e8e\u5b83\u548c\u5149\u6e90\u95f4\u7684\u7269\u4f53\u6240\u906e\u6321 \u5bf9\u5149\u6e90\u800c\u8a00\uff0c\u4f4d\u4e8e\u9634\u5f71\u4e2d\u7684\u7269\u4f53\u8868\u9762\u5373\u662f\u4e0d\u53ef\u89c1\u9762 \u751f\u6210\u7b97\u6cd5\uff1a\u4e0e\u6d88\u9690\u7b97\u6cd5\u672c\u8d28\u4e0a\u4e00\u81f4 \u5177\u6709\u9634\u5f71\u6548\u679c\u7684\u5149\u7167\u6a21\u578b \u5149\u6e90\u5bf9\u4f4d\u4e8e\u9634\u5f71\u4e2d\u7684\u70b9\u7684\u4eae\u5ea6\uff08\u989c\u8272\uff09\u6ca1\u6709\u8d21\u732e \uff081\uff09\u591a\u5149\u6e90\uff082\uff09\u989c\u8272\u5206\u91cf Z\u7f13\u51b2\u5668\u9634\u5f71\u7b97\u6cd5 \u6b65\u9aa4 \uff081\uff09\u5c06\u56fe\u5f62\u53d8\u6362\u5230\u4ee5\u5149\u6e90\u4e3a\u539f\u70b9\u7684\u5750\u6807\u7cfb\uff0c\u5229\u7528Z\u7f13\u51b2\u5668\u6d88\u9690\u7b97\u6cd5\uff0c\u6309\u5149\u7ebf\u65b9\u5411\u5bf9\u56fe\u5f62\u6d88\u9690\uff0c\u628a\u8ddd\u5149\u6e90\u6700\u8fd1\u7684\u7269\u4f53\u8868\u9762\u4e0a\u70b9\u7684\u6df1\u5ea6\u503c\u4fdd\u5b58\u5728Z\u7f13\u51b2\u5668\u4e2d\uff08\u79f0\u4e3a\u9634\u5f71\u7f13\u51b2\u5668\uff09 \uff082\uff09\u5229\u7528Z\u7f13\u51b2\u5668\u6d88\u9690\u7b97\u6cd5\u6309\u89c6\u7ebf\u65b9\u5411\u5bf9\u56fe\u5f62\u6d88\u9690\uff0c\u5c06\u5f97\u5230\u7684\u6bcf\u4e2a\u53ef\u89c1\u70b9\u53d8\u6362\u5230\u7b2c i \u4e2a\u5149\u6e90\u7684\u5750\u6807\u7cfb\u4e2d\uff0c\u82e5\u5b83\u5728\u5149\u6e90\u5750\u6807\u7cfb\u4e2d\u7684\u6df1\u5ea6\u503c\u5c0f\u4e8e\u9634\u5f71\u7f13\u51b2\u5668\u4e2d\u76f8\u5e94\u5355\u5143\u7684\u503c\uff0c\u5219\u8be5\u53ef\u89c1\u70b9\u4f4d\u4e8e\u9634\u5f71\u4e2d\uff08Si\uff1d0\uff09\uff0c\u5426\u5219\uff08 Si \uff1d1\uff09\uff0c\u518d\u7528\u5149\u7167\u6a21\u578b\u8ba1\u7b97\u989c\u8272\u3002 \u7279\u70b9\uff1a\u7b97\u6cd5\u7b80\u5355\uff0c\u8ba1\u7b97\u91cf\u5c0f\uff0c\u80fd\u5904\u7406\u590d\u6742\u666f\u7269\uff1b \u7f3a\u70b9\u662f\u6bcf\u4e2a\u5149\u6e90\u9700\u89811\u4e2aZ\u7f13\u51b2\u5668\uff0c\u9700\u8981\u7684\u5b58\u50a8\u7a7a\u95f4\u5927 \u63d0\u9ad8\u6d88\u9690\u7b97\u6cd5\u6548\u7387\u7684\u5e38\u7528\u65b9\u6cd5\uff1a\u8fde\u8d2f\u6027\u3001\u5305\u56f4\u76d2\u6280\u672f\u3001\u80cc\u9762\u5254\u9664\u3001\u533a\u57df\u5206\u5272\u6280\u672f\u3001\u7269\u4f53\u5206\u5c42\u8868\u793a\u7b49\u3002","title":"\u7b2c\u516b\u7ae0   \u771f\u5b9e\u611f\u56fe\u5f62\u751f\u6210"},{"location":"course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/#_9","text":"\u53c2\u6570\u66f2\u7ebf\u57fa\u7840 \u66f2\u7ebf\u7684\u8868\u793a\u5f62\u5f0f \u4e3b\u8981\u6709\uff1a\u975e\u53c2\u6570\u8868\u793a\u548c\u53c2\u6570\u8868\u793a \u975e\u53c2\u6570\u8868\u793a \uff081\uff09\u663e\u5f0f\u8868\u793a \u5750\u6807\u95f4\u5efa\u7acb\u51fd\u6570\u5173\u7cfb \u4e0d\u80fd\u5efa\u7acb\u591a\u503c\u66f2\u7ebf y=f(x),z=g(x) y=f(x),z=g(x) \uff082\uff09\u9690\u5f0f\u8868\u793a \u770b\u505a\u662f\u4e24\u66f2\u9762\u7684\u4ea4 \u53ef\u4ee5\u5efa\u7acb\u591a\u503c\u66f2\u7ebf \u5750\u6807\u8ba1\u7b97\u76f8\u5bf9\u8f83\u590d\u6742 x^2+y^2=9,z=0 x^2+y^2=9,z=0 f(x,y,z)=0,g(x,y,z)=0 f(x,y,z)=0,g(x,y,z)=0 \u53c2\u6570\u8868\u793a \u53c2\u6570\u65b9\u7a0b\uff1a x=x(t),y=y(t),z=z(t),t \\in [a,b] x=x(t),y=y(t),z=z(t),t \\in [a,b] \u53c2\u6570\u8868\u793a\u7684\u4f18\u70b9 \u5bb9\u6613\u786e\u5b9a\u66f2\u7ebf\u8fb9\u754c\u3002\u7531\u53c2\u6570\u533a\u95f4\u786e\u5b9a \u8868\u793a\u5f62\u5f0f\u4e0d\u53d8\u6027\u3002\u4e0d\u4f9d\u8d56\u4e8e\u5750\u6807\u7cfb\u7684\u9009\u53d6 \u8868\u793a\u80fd\u529b\u5f3a\u3002\u5229\u4e8e\u63a7\u5236\u70b9\u6765\u63a7\u5236\u66f2\u7ebf\u5f62\u72b6\uff0c\u5982\u540e\u9762\u5c06\u8981\u5b66\u5230\u7684Bezier\u66f2\u7ebf \u53c2\u6570\u8868\u793a\u7684\u4f18\u70b9 \u5bb9\u6613\u786e\u5b9a\u66f2\u7ebf\u8fb9\u754c\u3002\u7531\u53c2\u6570\u533a\u95f4\u786e\u5b9a \u8868\u793a\u5f62\u5f0f\u4e0d\u53d8\u6027\u3002\u4e0d\u4f9d\u8d56\u4e8e\u5750\u6807\u7cfb\u7684\u9009\u53d6 \u8868\u793a\u80fd\u529b\u5f3a\u3002\u5229\u4e8e\u63a7\u5236\u70b9\u6765\u63a7\u5236\u66f2\u7ebf\u5f62\u72b6\uff0c\u5982\u540e\u9762\u5c06\u8981\u5b66\u5230\u7684Bezier\u66f2\u7ebf \u5207\u77e2\u91cf\u3001\u6cd5\u77e2\u91cf\u3001\u66f2\u7387 \u53c2\u6570\u8fde\u7eed\u6027 \u4f20\u7edf\u7684\u3001\u4e25\u683c\u7684\u8fde\u7eed\u6027 \u66f2\u7ebf P = P(t) \u5728 t\uff1dt0 \u5904n\u9636\u53c2\u6570\u8fde\u7eed\uff0c\u5982\u679c\u5b83\u5728 t0 \u5904n\u9636\u5de6\u53f3\u5bfc\u6570\u5b58\u5728\uff0c\u5e76\u4e14\u6ee1\u8db3 \u8bb0\u4e3aCn\uff08\u66f2\u7ebfn\u9636\u53c2\u6570\u8fde\u7eed\uff09 \u51e0\u4f55\u8fde\u7eed\u6027 \u3001 0\u9636\u51e0\u4f55\u8fde\u7eed \u79f0\u66f2\u7ebfP=P( t ) \u5728 t=t0 \u59040\u9636\u51e0\u4f55\u8fde\u7eed\uff0c\u5982\u679c\u5b83\u5728 t0 \u5904\u4f4d\u7f6e\u8fde\u7eed\uff0c\u5373 \u8bb0\u4e3a\uff1aGC0 1\u9636\u51e0\u4f55\u8fde\u7eed \u79f0\u66f2\u7ebf P=P(t) \u5728 t = t0 \u59041\u9636\u51e0\u4f55\u8fde\u7eed\uff0c\u5982\u679c\u5b83\u5728 t0\u5904 GC0 \uff0c\u5e76\u4e14\u5207\u77e2\u91cf\u65b9\u5411\u8fde\u7eed\uff0c\u5373 \u8bb0\u4e3a\uff1a GC1 \u53c2\u6570\u591a\u9879\u5f0f\u66f2\u7ebf n\u6b21\u591a\u9879\u5f0f\u66f2\u7ebf \u77e9\u9635\u8868\u793a \u52a0\u6743\u548c\u5f62\u5f0f \u7f3a\u70b9 Pi \u6ca1\u6709\u660e\u663e\u7684\u51e0\u4f55\u610f\u4e49\u3002Pi \u4e0e\u66f2\u7ebf\u7684\u5173\u7cfb\u4e0d\u660e\u786e\uff0c\u5bfc\u81f4\u66f2\u7ebf\u7684\u5f62\u72b6\u63a7\u5236\u56f0\u96be \u57fa\u77e9\u9635\u8868\u793a \u77e9\u9635\u5206\u89e3 C=G \\cdot M C=G \\cdot M P(t)=G \\cdot M \\cdot T, t \\in [0,1] P(t)=G \\cdot M \\cdot T, t \\in [0,1] \u51e0\u4f55\u77e9\u9635 $G = [G_0.G_1 \u2026 G_n]$ \u63a7\u5236\u9876\u70b9 Gi \u57fa\u77e9\u9635M\uff1aMT \u786e\u5b9a\u4e86\u4e00\u7ec4\u57fa\u51fd\u6570 \u57fa\u77e9\u9635\u51b3\u5b9a\u4e86\u591a\u9879\u5f0f\u66f2\u7ebf\u7684\u6027\u8d28 \u7ed8\u5236\u65b9\u6cd5 Bezier\u57fa\u51fd\u6570 \u5b9a\u4e49 \u6027\u8d28 \u6b63\u6027\uff1a BEZ_{i,n}(t) \\geq 0 ,t \\in [0,1] BEZ_{i,n}(t) \\geq 0 ,t \\in [0,1] \u6743\u6027\uff1a \\sum _{i=0}^n BEZ_{i,n}(t)=1,t \\in [0,1 ] \\sum _{i=0}^n BEZ_{i,n}(t)=1,t \\in [0,1 ] \u5bf9\u79f0\u6027\uff1a \u964d\u9636\u516c\u5f0f\uff1a \u5347\u9636\u516c\u5f0f BEZier\u66f2\u7ebf \u5b9a\u4e49 \u5982\u4e0b\u5f62\u5f0f\u7684 n \u6b21\u591a\u9879\u5f0f\u79f0\u4e3a n \u6b21 Bezier\u66f2\u7ebf\uff1a \u63a7\u5236\u9876\u70b9\uff1aPi\uff08i\uff1d0\uff0c1\uff0c\u2026 \uff0c n\uff09 \u63a7\u5236\u591a\u8fb9\u5f62\uff1a P0P1 \u2026 Pn\uff0c\u66f2\u7ebf\u662f\u63a7\u5236\u9876\u70b9\u7684\u52a0\u6743\u548c \uff08\u6743\u662f\u57fa\u51fd\u6570\u7684\u503c\uff09 \u6027\u8d28 \u7aef\u70b9\u6027\u8d28 \u7aef\u70b9\u5207\u77e2\u91cf \u5bfc\u6570\u66f2\u7ebf n\u6b21Bezier\u66f2\u7ebf P(t) \u7684\u5bfc\u6570\u66f2\u7ebf P\u2019(t) \u662f n\uff0d1\u6b21Bezier\u66f2\u7ebf \u4eff\u5c04\u4e0d\u53d8\u6027 \u51e0\u4f55\u6027\u8d28\u4e0d\u968f\u5750\u6807\u51e0\u4f55\u53d8\u6362\u800c\u53d8\u6362\uff08\u5f62\u72b6\u3001\u66f2\u7387\u7b49\uff09\u4eff\u5c04\u53d8\u6362\u4e0d\u6539\u53d8\u66f2\u7ebf\u7684\u8868\u793a\u5f62\u5f0f\u3002 \u5bf9Bezier\u66f2\u7ebf\u7684\u51e0\u4f55\u53d8\u6362\u53ea\u8981\u4f5c\u7528\u4e8e\u63a7\u5236\u9876\u70b9\u5373\u53ef\u3002 \u51f8\u5305\u6027 \u51f8\u96c6\uff1a {Pi}\u7684\u51f8\u96c6\u662f\u6307\u5305\u542b\u8fd9\u4e9b\u70b9\u7684\u51f8\u591a\u8fb9\u5f62 \u51f8\u5305\uff1a {Pi}\u7684\u51f8\u5305\u662f\u6307\u5305\u542b\u8fd9\u4e9b\u70b9\u7684\u6700\u5c0f\u51f8\u96c6 Bezier\u66f2\u7ebf\u4f4d\u4e8e\u5176\u63a7\u5236\u9876\u70b9\u7684\u51f8\u5305\u4e4b\u5185 \u5e73\u9762\u66f2\u7ebf\u7684\u4fdd\u578b\u6027 \u4fdd\u51f8\u6027\uff1a\u5982\u679c\u591a\u8fb9\u5f62\u662f\u51f8\u7684\uff0c\u90a3\u4e48Bezier\u66f2\u7ebf\u4e5f\u662f\u51f8\u7684 \u53d8\u5dee\u7f29\u51cf\u6027\uff1a\u5e73\u9762\u5185\u4efb\u4e00\u76f4\u7ebf\u4e0eBezier\u66f2\u7ebf\u7684\u4ea4\u70b9\u4e2a\u6570\u4e0d\u591a\u4e8e\u8be5\u76f4\u7ebf\u4e0e\u63a7\u5236\u591a\u8fb9\u5f62\u7684\u4ea4\u70b9\u4e2a\u6570\u3002\u8bf4\u660eBezier\u66f2\u7ebf\u6bd4\u63a7\u5236\u591a\u8fb9\u5f62\u7684\u6ce2\u52a8\u5c0f\uff0c\u66f4\u5149\u987a \u62df\u5c40\u90e8\u6027 \u5c40\u90e8\u6027\u6307\u79fb\u52a8\u63a7\u4e00\u4e2a\u5236\u9876\u70b9\u65f6\uff0c\u53ea\u5f71\u54cd\u66f2\u7ebf\u7684\u5c40\u90e8\u3002 \u79fb\u52a8\u63a7\u5236\u9876\u70b9Pi \u65f6\uff0c\u5bf9\u5e94\u53c2\u6570 t\uff1di /n \u7684\u66f2\u7ebf\u4e0a\u7684\u70b9\u53d8\u52a8\u6700\u5927\uff0c\u8fdc\u79bb i/n \u7684\u66f2\u7ebf\u4e0a\u7684\u70b9\u53d8\u52a8\u8d8a\u6765\u8d8a\u5c0f \u4e00\u6b21Bezier\u66f2\u7ebf n = 1\u65f6\uff0c\u6709\u4e24\u4e2a\u63a7\u5236\u70b9 P0 \u548c P1 \uff0cBezier\u591a\u9879\u5f0f\u662f\u4e00\u6b21\u591a\u9879\u5f0f\uff1a \u4e00\u6b21Bezier\u66f2\u7ebf\u662f\u8fde\u63a5\u8d77\u70b9P0\u548c\u7ec8\u70b9P1\u7684\u76f4\u7ebf\u6bb5 \u4e8c\u6b21Bezier\u66f2\u7ebf n=2\u65f6\uff0c\u67093\u4e2a\u63a7\u5236\u70b9P0\u3001P1\u548cP2\uff0cBezier\u591a\u9879\u5f0f\u662f\u4e8c\u6b21\u591a\u9879\u5f0f\uff1a \u4e09\u6b21Bezier\u66f2\u7ebf \u4e09\u6b21Hermite(\u5384\u5bc6\u591a)\u66f2\u7ebf \u7ed9\u5b9a4\u4e2a\u77e2\u91cfP0, P1, R0, R1 \uff0c\u79f0\u6ee1\u8db3\u4e0b\u5217\u6761\u4ef6\u7684\u4e09\u6b21\u591a\u9879\u5f0f\u66f2\u7ebf P(t) \u4e3aHermite \u66f2\u7ebf Bezier\u66f2\u7ebf\u7684\u79bb\u6563\u751f\u6210\u7b97\u6cd5 Horner\u7b97\u6cd5 \u53ea\u9002\u5b9c\u4f4e\u6b21Bezier\u66f2\u7ebf\uff08\u5982\u4e09\u6b21Bezier\u66f2\u7ebf\uff09 de Casteljau(\u5fb7 \u00b7 \u5361\u65af\u7279\u91cc\u5965)\u7b97\u6cd5 \u53ef\u7528Bezier\u964d\u9636\u516c\u5f0f\u8bc1\u660e Bezier\u66f2\u9762 \u5b9a\u4e49\uff1a\u5229\u7528\u4e24\u7ec4\u6b63\u4ea4\u7684 Bezier \u66f2\u7ebf\u903c\u8fd1\u7531\u63a7\u5236\u70b9\u7f51\u683c\u63cf\u8ff0\u7684\u66f2\u9762 \u5176\u4e2d pj, k \u662f\u7ed9\u5b9a\u7684 (m+1)\u00d7(n+1) \u4e2a\u63a7\u5236\u70b9\u7684\u4f4d\u7f6e Bezier \u66f2\u9762\u4e0e Bezier \u66f2\u7ebf\u6709\u76f8\u540c\u7684\u6027\u8d28","title":"\u7b2c\u4e5d\u7ae0  \u66f2\u7ebf\u4e0e\u66f2\u9762"},{"location":"course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","text":"\u8ba1\u7b97\u673a\u64cd\u4f5c\u7cfb\u7edf \u00b6 \u7b2c\u4e00\u7ae0 \u64cd\u4f5c\u7cfb\u7edf\u6982\u8ff0 \u00b6 1.1 \u4ec0\u4e48\u662f\u64cd\u4f5c\u7cfb\u7edf 1.1.1 \u64cd\u4f5c\u7cfb\u7edf\u662f\u7528\u6237\u4e0e\u8ba1\u7b97\u673a\u786c\u4ef6\u4e4b\u95f4\u7684\u63a5\u53e3 \u5c4f\u853d\u63a7\u5236\u786c\u4ef6\u7684\u7ec6\u8282\uff0c\u4f7f\u5e94\u7528\u7a0b\u5e8f\u7684\u5f00\u53d1\u66f4\u7b80\u5355\u3001\u9ad8\u6548 1.1.1.2 \u63a5\u53e3\u5f62\u5f0f\uff1a\u547d\u4ee4\u884c\u63a5\u53e3\u3001\u56fe\u5f62\u7528\u6237\u63a5\u53e3\u3001\u7cfb\u7edf\u8c03\u7528 1.1.1.3 \u6587\u4ef6\u7684\u5b58\u653e 1.1.1.3.1 \u903b\u8f91\u5730\u5740\u548c\u7269\u7406\u5730\u5740 \u903b\u8f91\u5730\u5740\uff1a\u7c07\u53f7\u6216\u6247\u533a\u7684\u903b\u8f91\u7f16\u53f7\u3002 \u7269\u7406\u5730\u5740\uff1a\u67f1\u9762\u53f7\u3001\u78c1\u5934\u53f7\uff08\u78c1\u9053\u53f7\uff09\u3001\u6247\u533a\u53f7\u3002 1.1.1.3.2 \u78c1\u76d8\u8bfb\u6587\u4ef6\u7684\u8fc7\u7a0b 1\uff09\u7528\u6237\u7ed9\u51fa\u6587\u4ef6\u540d\uff0c\u63d0\u51fa\u8bbf\u95ee\u6587\u4ef6\u7684\u8bf7\u6c42 2\uff09\u6587\u4ef6\u7cfb\u7edf\u901a\u8fc7\u6309\u540d\u8bbf\u95ee\u673a\u5236\u83b7\u53d6\u6587\u4ef6\u7684\u903b\u8f91\u5730\u5740\uff08\u78c1\u76d8\u5757\u53f7\u6216\u6247\u533a\u7f16\u53f7\uff09 3\uff09\u78c1\u76d8\u9a71\u52a8\u7a0b\u5e8f\u5c06\u903b\u8f91\u5730\u5740\u8f6c\u6362\u4e3a\u7269\u7406\u5730\u5740\u3001\u53d1\u9001\u78c1\u76d8\u64cd\u4f5c\u6307\u4ee4 1.1.2 \u64cd\u4f5c\u7cfb\u7edf\u662f\u8ba1\u7b97\u673a\u8d44\u6e90\u7684\u7ba1\u7406\u8005 \u7ba1\u7406\uff1a\u5904\u7406\u673a\u3001\u5185\u5b58\u3001\u8bbe\u5907\u3001\u6587\u4ef6\u3001\u7f51\u7edc\u7b49\u3002 1.1.2.1 \u64cd\u4f5c\u7cfb\u7edf\u7684\u8bbe\u8ba1\u8ffd\u6c42\u7684\u4e3b\u8981\u76ee\u6807 1\uff09\u65b9\u4fbf\u7528\u6237\uff08\u6700\u7ec8\u7528\u6237\u548c\u7a0b\u5e8f\u5458\uff09 2\uff09\u63d0\u9ad8\u7cfb\u7edf\u6027\u80fd\uff1a\u7a7a\u95f4\u6027\u80fd\u3001\u65f6\u95f4\u6027\u80fd\u3001\u8d44\u6e90\u5229\u7528\u7387 1.2 \u64cd\u4f5c\u7cfb\u7edf\u7684\u53d1\u5c55 1.2.1 \u65e0\u64cd\u4f5c\u7cfb\u7edf \u5b9a\u4e49\uff1a\u7b2c\u4e00\u4ee3\u8ba1\u7b97\u673a\uff081945-1955\uff09\u4f7f\u7528\u7535\u5b50\u7ba1\u4f5c\u4e3a\u4e3b\u8981\u7684\u7535\u5b50\u5668\u4ef6\uff0c\u7528\u63d2\u4ef6\u677f\u4e0a\u7684\u786c\u8fde\u7ebf\u6216\u7a7f\u5b54\u5361\u8868\u793a\u7a0b\u5e8f\uff0c\u6ca1\u6709\u5b58\u50a8\u7a0b\u5e8f\u7684\u5185\u5b58\uff0c\u65e0\u64cd\u4f5c\u7cfb\u7edf\u3002 1.2.2 \u5355\u9053\u6279\u5904\u7406\u7cfb\u7edf \u5b9a\u4e49\uff1a\u5355\u9053\u6279\u5904\u7406\u7cfb\u7edf\u5185\u5b58\u4e2d\u53ea\u6709\u4e00\u9053\u4f5c\u4e1a\uff0c\u53ef\u4ee5\u6210\u6279\u5904\u7406\u4f5c\u4e1a\u3002\u514b\u670dCPU\u56e0\u7b49\u5f85\u4eba\u5de5\u64cd\u4f5c\u9020\u6210\u7684\u8d44\u6e90\u6d6a\u8d39\u95ee\u9898 \u7279\u70b9\uff1a\u2460\u81ea\u52a8\u6027 \u2461\u987a\u5e8f\u6027 \u2462\u5355\u9053\u6027 \u4f18\u70b9\uff1a\u51cf\u5c11\u7b49\u5f85\u4eba\u5de5\u64cd\u4f5c\u7684\u65f6\u95f4 \u7f3a\u70b9\uff1a \u2460\u4f5c\u4e1a\u72ec\u5360CPU \u2461CPU\u7b49\u5f85I/O\u4f7f\u5f97CPU\u5229\u7528\u7387\u4f4e\uff08\u76f8\u5bf9\u4e8e\u591a\u9053\u7a0b\u5e8f\u7cfb\u7edf\u800c\u8a00\uff09 1.2.3 \u591a\u9053\u7a0b\u5e8f\u7cfb\u7edf 1.2.3.1 \u591a\u9053\u6279\u5904\u7406\u7cfb\u7edf \u7279\u70b9\uff1a\u2460\u591a\u9053\u6027 \u2461\u65e0\u5e8f\u6027 \u2462\u8c03\u5ea6\u6027 \u2463\u590d\u6742\u6027 \u4f18\u70b9\uff1a\u2460\u63d0\u9ad8CPU\u5229\u7528\u7387 \u2461\u63d0\u9ad8\u5185\u5b58\u548cI/O\u5229\u7528\u7387 \u2462\u589e\u52a0\u7cfb\u7edf\u541e\u5410\u91cf \u7f3a\u70b9\uff1a \u2460\u5e73\u5747\u5468\u8f6c\u65f6\u95f4 \u2461\u7f3a\u4e4f\u4ea4\u4e92\u80fd\u529b 1.2.3.2 \u5206\u65f6\u7cfb\u7edf \u5b9a\u4e49\uff1a\u2460\u4eba\u673a\u4ea4\u4e92 \u2461\u5171\u4eab\u4e3b\u673a \u2462\u4fbf\u4e8e\u7528\u6237\u4e0a\u673a \u7279\u70b9\uff1a\u2460\u591a\u8def\u6027 \u2461\u72ec\u7acb\u6027 \u2462\u53ca\u65f6\u6027 \u2463\u4ea4\u4e92\u6027 \u4f18\u70b9\uff1a\u2460\u63d0\u4f9b\u4eba\u673a\u4ea4\u4e92 \u2461\u591a\u7ec8\u7aef\u5171\u4eab\u4e3b\u673a \u5206\u65f6\u7cfb\u7edf\u5b9e\u73b0\u4e2d\u7684\u5173\u952e\u95ee\u9898\uff1a \u2460\u53ca\u65f6\u63a5\u6536\uff1a\u53ca\u65f6\u63a5\u6536\u7528\u6237\u7684\u547d\u4ee4\u6216\u6570\u636e \u2461\u53ca\u65f6\u5904\u7406\uff1a\u53ca\u65f6\u5904\u7406\u7528\u6237\u547d\u4ee4\u3002\u5e94\u8be5\u4f7f\u6240\u6709\u7684\u7528\u6237\u4f5c\u4e1a\u90fd\u76f4\u63a5\u8fdb\u5165\u5185\u5b58\uff1b\u5728\u5f88\u77ed\u7684\u65f6\u95f4\u5185\u4f7f\u6bcf\u4e2a\u4f5c\u4e1a\u90fd\u5f97\u5230\u8fd0\u884c\u3002 1.2.4 \u5fae\u673a\u64cd\u4f5c\u7cfb\u7edf 1.2.5 \u5b9e\u65f6\u64cd\u4f5c\u7cfb\u7edf \u5b9a\u4e49\uff1a\u5b9e\u65f6\u7cfb\u7edf\u662f\u652f\u6301\u5b9e\u65f6\u8ba1\u7b97\u7684\u7cfb\u7edf\u3002\u5b9e\u65f6\u8ba1\u7b97\u53ef\u4ee5\u5b9a\u4e49\u6210\u8fd9\u6837\u4e00\u7c7b\u8ba1\u7b97\uff0c\u65e2\u7cfb\u7edf\u7684\u6b63\u786e\u6027\u4e0d\u4ec5\u53d6\u51b3\u4e8e\u8ba1\u7b97\u7684\u903b\u8f91\u7ed3\u679c\uff0c\u800c\u4e14\u8fd8\u4f9d\u8d56\u4e8e\u4ea7\u751f\u7ed3\u679c\u7684\u65f6\u95f4\u3002 \u5b9e\u65f6\u4efb\u52a1\u7684\u7c7b\u578b \u2460\u5468\u671f\u6027\u5b9e\u65f6\u4efb\u52a1 \u2461\u975e\u5468\u671f\u6027\u5b9e\u65f6\u4efb\u52a1 \u2462\u786c\u5b9e\u65f6\u4efb\u52a1 \u2463\u8f6f\u5b9e\u65f6\u4efb\u52a1\u3002 \u6ce8\uff1a\u4e00\u4e2a\u5b9e\u9645\u7684OS\u53ef\u4ee5\u540c\u65f6\u5177\u6709\u6279\u5904\u7406\u3001\u5206\u65f6\u548c\u5b9e\u65f6\u7684\u7279\u70b9\uff0c\u5982Windows NT\u3002 1.3 \u64cd\u4f5c\u7cfb\u7edf\u7684\u7279\u5f81 \u5e76\u53d1\uff1a\u4e24\u4e2a\u6216\u591a\u4e2a\u4e8b\u4ef6\u5728\u540c\u4e00\u65f6\u95f4\u95f4\u9694\u5185\u53d1\u751f\u3002\u5e76\u53d1\u5f3a\u8c03\u201c\u540c\u4e00\u65f6\u95f4\u95f4\u9694\u201d\uff0c\u4e0e\u5e76\u884c\u662f\u4e0d\u540c\u7684\u4e24\u4e2a\u6982\u5ff5\uff0c\u5e76\u884c\u662f\u6307\u591a\u4e2a\u4e8b\u4ef6\u540c\u65f6\u53d1\u751f\u3002 \u5171\u4eab\uff1a\u7cfb\u7edf\u4e2d\u7684\u8d44\u6e90\u53ef\u4f9b\u5185\u5b58\u4e2d\u591a\u4e2a\u5e76\u53d1\u6267\u884c\u7684\u8fdb\u7a0b\u5171\u540c\u4f7f\u7528\u3002 \u8d44\u6e90\u5171\u4eab\u6709\u4e24\u79cd\u65b9\u5f0f\uff0c\u5373\uff1a\u4e92\u65a5\u5171\u4eab\u548c\u540c\u65f6\u5171\u4eab\u3002 \u865a\u62df\uff1a\u901a\u8fc7\u67d0\u79cd\u6280\u672f\u628a\u4e00\u4e2a\u7269\u7406\u5b9e\u4f53\u53d8\u6210\u82e5\u5e72\u903b\u8f91\u4e0a\u7684\u5bf9\u5e94\u7269\u3002 \u5f02\u6b65\uff1a\u8fdb\u7a0b\u4ee5\u4e0d\u53ef\u9884\u77e5\u7684\u987a\u5e8f\u3001\u8fdb\u5ea6\u8fd0\u884c\uff0c\u7cfb\u7edf\u80fd\u5904\u7406\u968f\u673a\u53d1\u751f\u7684\u4e8b\u4ef6\u3002 1.4 \u64cd\u4f5c\u7cfb\u7edf\u7684\u529f\u80fd \u5185\u5b58\u7ba1\u7406\u529f\u80fd\u3001\u8fdb\u7a0b\u7ba1\u7406\u529f\u80fd\u3001\u8bbe\u5907\u7ba1\u7406\u529f\u80fd\u3001\u6587\u4ef6\u7ba1\u7406\u529f\u80fd\u3001\u7528\u6237\u63a5\u53e3 1.4.1 \u5185\u5b58\u7ba1\u7406\u529f\u80fd \u5185\u5b58\u5206\u914d; \u5185\u5b58\u4fdd\u62a4: \u786e\u4fdd\u6bcf\u9053\u7528\u6237\u7a0b\u5e8f\u90fd\u5728\u81ea\u5df1\u7684\u5185\u5b58\u7a7a\u95f4\u4e2d\u8fd0\u884c\uff0c\u4e92\u4e0d\u5e72\u6270\u3002 \u5730\u5740\u6620\u5c04; \u2460\u903b\u8f91\u5730\u5740\u548c\u7269\u7406\u5730\u5740 \u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7ecf\u7f16\u8bd1\u540e\uff0c\u901a\u5e38\u4f1a\u5f62\u6210\u82e5\u5e72\u4e2a\u76ee\u6807\u7a0b\u5e8f\uff0c\u8fd9\u4e9b\u76ee\u6807\u7a0b\u5e8f\u518d\u7ecf\u8fc7\u94fe\u63a5\u800c\u5f62\u6210\u53ef\u88c5\u5165\u7a0b\u5e8f\u3002\u8fd9\u4e9b\u7a0b\u5e8f\u7684\u5730\u5740\u90fd\u662f\u4ece\u67d0\u4e00\u8d77\u59cb\u5730\u5740\u5f00\u59cb\u7684\uff0c\u7a0b\u5e8f\u4e2d\u7684\u5176\u5b83\u5730\u5740\u90fd\u662f\u76f8\u5bf9\u4e8e\u8d77\u59cb\u5730\u5740\u8ba1\u7b97\u7684\uff1b\u7531\u8fd9\u4e9b\u5730\u5740\u6240\u5f62\u6210\u7684\u5730\u5740\u8303\u56f4\u79f0\u201c\u5730\u5740\u7a7a\u95f4\u201d\uff0c\u5176\u4e2d\u7684\u5730\u5740\u79f0\u4e3a\u201c\u903b\u8f91\u5730\u5740\u201d\u3002 \u7531\u5185\u5b58\u4e2d\u7684\u4e00\u7cfb\u5217\u5355\u5143\u6240\u9650\u5b9a\u7684\u5730\u5740\u8303\u56f4\u79f0\u4e3a\u201c\u5185\u5b58\u7a7a\u95f4\u201d\uff0c\u5176\u4e2d\u7684\u5730\u5740\u79f0\u4e3a\u201c\u7269\u7406\u5730\u5740\u201d\u3002 \u2461\u5730\u5740\u6620\u5c04 \u5185\u5b58\u6269\u5145\uff1b\u865a\u62df\u5185\u5b58\u3002 \u5185\u5b58\u56de\u6536\uff1a\u7a0b\u5e8f\u6267\u884c\u5b8c\u6bd5\u6216\u6587\u4ef6\u88ab\u5173\u95ed\uff0c\u7cfb\u7edf\u5c06\u7a0b\u5e8f\u3001\u6587\u4ef6\u5360\u7528\u7684\u5185\u5b58\u7a7a\u95f4\u6807\u8bb0\u4e3a\u7a7a\u95f2\u72b6\u6001\u3002 1.4.2 \u8fdb\u7a0b\u7ba1\u7406\u529f\u80fd \u8fdb\u7a0b\u63a7\u5236 \u8fdb\u7a0b\u540c\u6b65 \u8fdb\u7a0b\u901a\u4fe1 \u8fdb\u7a0b\u8c03\u5ea6 1.4.3 \u8bbe\u5907\u7ba1\u7406\u529f\u80fd \u7f13\u51b2\u7ba1\u7406\uff1a\u7ba1\u7406\u5404\u79cd\u7f13\u51b2\u533a\u3002 \u8bbe\u5907\u5206\u914d\uff1a\u5206\u914d\u7528\u6237I/O \u6240\u9700\u8981\u7684\u8bbe\u5907\u3002 \u8bbe\u5907\u5904\u7406\uff1a\u7531\u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f\u6765\u5b9e\u73b0CPU\u4e0e\u8bbe\u5907\u63a7\u5236\u5668\u4e4b\u95f4\u7684\u901a\u4fe1\u3002 \u8bbe\u5907\u72ec\u7acb\u6027\uff1a\u5e94\u7528\u7a0b\u5e8f\u4e0e\u5177\u4f53\u7684\u7269\u7406\u8bbe\u5907\u65e0\u5173\u3002 \u865a\u62df\u8bbe\u5907\uff1a\u591a\u4e2a\u7528\u6237\u3001\u591a\u4e2a\u8fdb\u7a0b\u8bfe\u5171\u4eab\u540c\u4e00\u4e2a\u7269\u7406\u8bbe\u5907\u3002 1.4.4 \u6587\u4ef6\u7ba1\u7406\u529f\u80fd \u6587\u4ef6\u7684\u6309\u540d\u8bbf\u95ee \u6587\u4ef6\u7684\u5b58\u50a8 1.4.5 \u63d0\u4f9b\u7528\u6237\u63a5\u53e3 \u547d\u4ee4\u63a5\u53e3 \u56fe\u5f62\u63a5\u53e3:\u91c7\u7528\u56fe\u5f62\u5316\u7684\u64cd\u4f5c\u754c\u9762\u3002 \u7a0b\u5e8f\u63a5\u53e3\uff1a\u7531\u4e00\u7ec4\u7cfb\u7edf\u8c03\u7528\u7ec4\u6210\u3002 1.5 \u6307\u4ee4\u7684\u6267\u884c 1.5.1 \u53d6\u6307\u4ee4\u4e0e\u6267\u884c\u6307\u4ee4 1.5.1.1 \u53d6\u6307\u4ee4 \u5728\u6bcf\u4e2a\u6307\u4ee4\u5468\u671f\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u5904\u7406\u5668\u4ece\u5b58\u50a8\u5668\u4e2d\u53d6\u4e00\u6761\u6307\u4ee4\uff0c\u5728\u5178\u578b\u7684\u5904\u7406\u5668\u4e2d\uff0c\u7a0b\u5e8f\u8ba1\u6570\u5668\uff08PC\uff09\u4fdd\u5b58\u6709\u4e0b\u4e00\u6b21\u8981\u53d6\u7684\u6307\u4ee4\u7684\u5730\u5740\u3002\u9664\u975e\u63a5\u6536\u5230\u522b\u7684\u6307\u793a\uff08\u5982\u6267\u884c\u8df3\u8f6c\u6307\u4ee4\uff09\uff0c\u5426\u5219\u5904\u7406\u5668\u5728\u6bcf\u6b21\u5b8c\u6210\u53d6\u6307\u4ee4\u540e\u603b\u662f\u5bf9PC\u9012\u589e\uff0c\u4f7f\u5b83\u80fd\u591f\u6309\u987a\u5e8f\u53d6\u5f97\u4e0b\u4e00\u6761\u6307\u4ee4\u3002\uff08\u5373\u4f4d\u4e8e\u4e0b\u4e00\u4e2a\u9ad8\u7aef\u5b58\u50a8\u5668\u5730\u5740\u7684\u6307\u4ee4\uff09\u3002 1.5.1.2 \u6267\u884c\u6307\u4ee4 \u53d6\u5230\u7684\u6307\u4ee4\u88ab\u653e\u7f6e\u5728\u5904\u7406\u5668\u4e2d\u7684\u6307\u4ee4\u5bc4\u5b58\u5668\uff08IR\u4e2d\u3002\u6307\u4ee4\u4e2d\u5305\u542b\u786e\u5b9a\u5904\u7406\u5668\u5c06\u8981\u91c7\u53d6\u52a8\u4f5c\u7684\u4f4d\uff0c\u5904\u7406\u5668\u89e3\u91ca\u6307\u4ee4\u5e76\u6267\u884c\u8981\u6c42\u7684\u64cd\u4f5c\uff0c\u8fd9\u4e9b\u64cd\u4f5c\u53ef\u5206\u4e3a4\u7c7b\uff1a \u2460\u5904\u7406\u5668-\u5b58\u50a8\u5668:\u6570\u636e\u5728\u5b58\u50a8\u5668\u548c\u5904\u7406\u5668\u4e4b\u95f4\u4f20\u9001\uff1b \u2461\u5904\u7406\u5668-I/O\uff1a\u6570\u636e\u5728I/O\u8bbe\u5907\u548c\u5904\u7406\u5668\u4e4b\u95f4\u4f20\u9001\uff1b \u2462\u6570\u636e\u5904\u7406\uff1a\u7b97\u672f\u64cd\u4f5c\u6216\u903b\u8f91\u64cd\u4f5c\uff1b \u2463\u63a7\u5236\uff1a\u4fee\u6539\u6307\u4ee4\u7684\u6267\u884c\u987a\u5e8f\u3002 1.5.2 \u5185\u90e8CPU\u5bc4\u5b58\u5668 \u7a0b\u5e8f\u8ba1\u6570\u5668\uff08PC\uff09----\u5b58\u6307\u4ee4\u5730\u5740 \u6307\u4ee4\u5bc4\u5b58\u5668\uff08IR) ----\u5b58\u6b63\u5728\u6267\u884c\u7684\u6307\u4ee4 \u7d2f\u52a0\u5668\uff08AC) ----\u4e34\u65f6\u5b58\u50a8\u4f53\u548c\u7d2f\u52a0\u64cd\u4f5c 1.6 \u5c0f\u7ed3 1.\u7a0b\u5e8f\u6267\u884c\u7684\u8fc7\u7a0b\u662f\u53cd\u590d\u53d6\u6307\u4ee4\u548c\u6267\u884c\u6307\u4ee4\u7684\u8fc7\u7a0b\uff1b 2.PC\u59cb\u7ec8\u5b58\u6709\u4e0b\u4e00\u6761\u5f85\u53d6\u6307\u4ee4\u7684\u5730\u5740\uff1b 3.\u6307\u4ee4\u6267\u884c\u7684\u7ed3\u679c\u5c31\u662f\u4f7f\u5bc4\u5b58\u5668\u6216\u5185\u5b58\u5355\u5143\u7684\u503c\u53d1\u751f\u53d8\u5316\u3002\u6307\u4ee4\u6267\u884c\u7684\u8fc7\u7a0b\u4e5f\u5c31\u662f\u5b58\u50a8\u4f53\u5185\u5bb9\u4e0d\u65ad\u53d8\u5316\u7684\u8fc7\u7a0b\u3002 4.\u53d6\u6307\u4ee4\u548c\u6267\u884c\u6307\u4ee4\u662f\u7531\u786c\u4ef6\u5b8c\u6210\u7684\u3002 5.\u4e0d\u540c\u786c\u4ef6\u7684\u4f53\u7cfb\u7ed3\u6784\u652f\u6301\u4e0d\u540c\u7684\u6307\u4ee4\u96c6\u5408\uff0c\u4e3a\u67d0\u79cd\u786c\u4ef6\u5e73\u53f0\u5f00\u53d1\u7684\u64cd\u4f5c\u7cfb\u7edf\u4e0d\u80fd\u76f4\u63a5\u5728\u53e6\u4e00\u79cd\u4f53\u7cfb\u7ed3\u6784\u7684\u786c\u4ef6\u4e0a\u8fd0\u884c\u3002 6.\u4efb\u4f55\u9ad8\u7ea7\u8bed\u8a00\u7a0b\u5e8f\u88ab\u7f16\u8bd1\u6210\u6307\u4ee4\u96c6\u5408\uff0c\u5176\u4e2d\u7684\u6bcf\u4e00\u6761\u6307\u4ee4\u5c5e\u4e8e\u673a\u5668\u4f53\u7cfb\u7ed3\u6784\u6307\u4ee4\u96c6\u3002CPU\u6267\u884c\u7684\u6700\u5c0f\u7a0b\u5e8f\u5355\u4f4d\u662f\u6307\u4ee4\u800c\u4e0d\u662f\u9ad8\u7ea7\u8bed\u8a00\u7a0b\u5e8f\u7684\u8bed\u53e5\u3002 \u7b2c\u4e8c\u7ae0 \u8fdb\u7a0b\u7684\u63cf\u8ff0\u4e0e\u63a7\u5236 \u00b6 2.1 \u7a0b\u5e8f\u7684\u5e76\u53d1\u8fd0\u884c 2.1.1 \u6982\u5ff5 \u5728\u540c\u4e00\u65f6\u95f4\u95f4\u9694\u5185\u8fd0\u884c\u591a\u4e2a\u7a0b\u5e8f\uff0c\u4e00\u4e2a\u7a0b\u5e8f\u8fd8\u6ca1\u6709\u6267\u884c\u5b8c\uff0c\u53ef\u4ee5\u8fd0\u884c\u5176\u5b83\u7684\u7a0b\u5e8f\uff0c\u5bf9\u7528\u6237\u800c\u8a00\uff0c\u770b\u5230\u7684\u662f\u8ba1\u7b97\u673a\u540c\u65f6\u8fd0\u884c\u591a\u4e2a\u7a0b\u5e8f\u3002 \u7a0b\u5e8f\u5e76\u53d1\u6267\u884c\u7684\u65b9\u5f0f\u53ef\u4ee5\u662f\u591a\u4e2a\u7a0b\u5e8f\u5206\u65f6\u4f7f\u7528\u591aCPU\u6216\u5355CPU\u3002 2.1.2 \u7279\u70b9 \u2460\u95f4\u65ad\u6027 \u2461\u591a\u4e2a\u7a0b\u5e8f\u5171\u4eab\u7cfb\u7edf\u8d44\u6e90\uff08\u5931\u53bb\u5c01\u95ed\u6027\uff09\u2462\u4e0d\u53ef\u518d\u73b0\u6027 2.2 \u8fdb\u7a0b\u7684\u63cf\u8ff0 \u8fdb\u7a0b\u6982\u5ff5\u7684\u5f15\u5165\u662f\u4e3a\u4e86\u8ddf\u8e2a\u5e76\u63cf\u8ff0\u7a0b\u5e8f\u7684\u5e76\u53d1\u6267\u884c\u3002\u5f53\u5141\u8bb8\u7a0b\u5e8f\u5e76\u53d1\u6267\u884c\u65f6\uff0c\u5e76\u53d1\u6267\u884c\u7684\u7a0b\u5e8f\u53ef\u80fd\u662f\u540c\u4e00\u4e2a\u7a0b\u5e8f\u5728\u4e0d\u540c\u6570\u636e\u96c6\u5408\u4e0a\u7684\u6267\u884c\uff0c\u4e5f\u53ef\u80fd\u662f\u4e0d\u540c\u7684\u7a0b\u5e8f\u5728\u4e0d\u540c\u6570\u636e\u96c6\u5408\u4e0a\u7684\u6267\u884c\uff0c\u5b83\u4eec\u5171\u4eab\u7cfb\u7edf\u8d44\u6e90\uff0c\u7528\u7a0b\u5e8f\u5df2\u4e0d\u80fd\u65b9\u4fbf\u5730\u63cf\u8ff0\u7a0b\u5e8f\u7684\u5e76\u53d1\u6267\u884c\uff0c\u6240\u4ee5\u5f15\u5165\u4e86\u8fdb\u7a0b\u7684\u6982\u5ff5 \u3002 2.2.1 \u8fdb\u7a0b\u7684\u5b9a\u4e49 \u5b9a\u4e491\uff1a\u8fdb\u7a0b\u662f\u5141\u8bb8\u5e76\u53d1\u6267\u884c\u7684\u7a0b\u5e8f\u5728\u67d0\u4e2a\u6570\u636e\u96c6\u5408\u4e0a\u7684\u6267\u884c\u8fc7\u7a0b\u3002 \u5b9a\u4e492\uff1a\u8fdb\u7a0b\u662f\u7531\u7528\u6237\u6570\u636e\u3001\u7cfb\u7edf\u6570\u636e\u548c\u7a0b\u5e8f\u6784\u6210\u7684\u5b9e\u4f53\u3002 2.2.2 \u8fdb\u7a0b\u7684\u7279\u5f81 \u5e76\u53d1\u6027\uff1a\u591a\u4e2a\u8fdb\u7a0b\u5b9e\u4f53\uff0c\u540c\u5b58\u4e8e\u5185\u5b58\u4e2d\uff0c\u80fd\u5728\u4e00 \u6bb5\u65f6\u95f4\u5185\u540c\u65f6\u8fd0\u884c\u3002 \u52a8\u6001\u6027\uff1a\u8fdb\u7a0b\u662f\u8fdb\u7a0b\u5b9e\u4f53\u7684\u6267\u884c\u8fc7\u7a0b\uff0c\u5bf9\u5e94\u4e86\u5b58\u50a8\u4f53\u7684\u4e0d\u65ad\u53d8\u5316\uff1b\u6709\u521b\u5efa\u3001\u6267\u884c\u3001\u72b6\u6001\u53d8\u5316\u548c\u8fd0\u884c\u7ec8\u6b62\u88ab\u64a4\u6d88\u7684\u8fc7\u7a0b \u72ec\u7acb\u6027\uff1a\u72ec\u7acb\u8fd0\u884c\u548c\u8d44\u6e90\u8c03\u5ea6\u7684\u57fa\u672c\u5355\u4f4d\u3002 \u5f02\u6b65\u6027\uff1a\u4ee5\u4e0d\u540c\u7684\u3001\u4e0d\u53ef\u9884\u77e5\u7684\u901f\u5ea6\u5411\u524d\u63a8\u8fdb\u3002 \u7ed3\u6784\u7279\u5f81\uff1a\u8fdb\u7a0b\u5305\u62ec\u7528\u6237\u6570\u636e\u3001\u7a0b\u5e8f\u3001\u7cfb\u7edf\u6570\u636e\u3002 2.2.3 \u8fdb\u7a0b\u4e0e\u7a0b\u5e8f\u7684\u6bd4\u8f83 \u533a\u522b \uff1a \u2460\u7a0b\u5e8f\u662f\u9759\u6001\u7684\u6982\u5ff5\uff0c\u8fdb\u7a0b\u662f\u52a8\u6001\u7684\u6982\u5ff5 \u2461\u7a0b\u5e8f\u662f\u6c38\u4e45\u7684\uff0c\u8fdb\u7a0b\u662f\u6682\u65f6\u5b58\u5728\u7684 \u2462\u7a0b\u5e8f\u4e0e\u8fdb\u7a0b\u7684\u5b58\u5728\u5b9e\u4f53\u4e0d\u540c \u8054\u7cfb \uff1a \u2460\u8fdb\u7a0b\u662f\u7a0b\u5e8f\u7684\u4e00\u6b21\u6267\u884c\uff0c\u8fdb\u7a0b\u603b\u662f\u5bf9\u5e94\u4e00\u4e2a\u7279\u5b9a\u7684\u7a0b\u5e8f\uff0c\u6267\u884c\u7a0b\u5e8f\u7684\u4ee3\u7801\uff0c\u4e00\u4e2a\u8fdb\u7a0b\u5fc5\u7136\u5bf9\u5e94\u81f3\u5c11\u4e00\u6bb5\u7a0b\u5e8f\u3002 \u2461\u4e00\u4e2a\u7a0b\u5e8f\u53ef\u4ee5\u5bf9\u5e94\u591a\u4e2a\u8fdb\u7a0b\u3002\u540c\u4e00\u4e2a\u7a0b\u5e8f\u6bb5\u53ef\u4ee5\u5728\u4e0d\u540c\u7684\u6570\u636e\u96c6\u5408\u4e0a\u8fd0\u884c\uff0c\u56e0\u800c\u6784\u6210\u82e5\u5e72\u4e2a\u4e0d\u540c\u7684\u8fdb\u7a0b\u3002 2.2.4 \u7a0b\u5e8f\u63a7\u5236\u5757 \u8fdb\u7a0b\u63a7\u5236\u5757\u662f\u8fdb\u7a0b\u5b9e\u4f53\u7684\u4e00\u90e8\u5206\uff0c\u662f\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u6700\u91cd\u8981\u7684\u8bb0\u5f55\u578b\u6570\u636e\u7ed3\u6784\uff0cPCB\u4e2d\u8bb0\u5f55\u4e86\u64cd\u4f5c\u7cfb\u7edf\u6240\u9700\u8981\u7684\u7528\u4e8e\u63cf\u8ff0\u8fdb\u7a0b\u60c5\u51b5\u53ca\u63a7\u5236\u8fdb\u7a0b\u8fd0\u884c\u6240\u9700\u7684\u5168\u90e8\u4fe1\u606f\u3002 2.2.4.1 \u8fdb\u7a0b\u63a7\u5236\u5757\u4e2d\u7684\u4fe1\u606f 1\uff09 \u8fdb\u7a0b\u6807\u8bc6\u7b26\u4fe1\u606f \u2460 \u5916\u90e8\u6807\u8bc6\u7b26 \u2461 \u5185\u90e8\u6807\u8bc6\u7b26 \u2462 \u7236\u8fdb\u7a0b\u6807\u8bc6\u7b26 \u2463\u5b50\u8fdb\u7a0b\u6807\u8bc6\u7b26 2\uff09\u5904\u7406\u673a\u72b6\u6001\u4fe1\u606f \u2460\u901a\u7528\u5bc4\u5b58\u5668 \u2461\u6307\u4ee4\u8ba1\u6570\u5668 \u2462\u7a0b\u5e8f\u72b6\u6001\u5b57PSW \u2463\u7528\u6237\u6808\u6307\u9488 3\uff09\u8fdb\u7a0b\u8c03\u5ea6\u4fe1\u606f \u2460\u8fdb\u7a0b\u72b6\u6001\u4fe1\u606f \u2461\u8fdb\u7a0b\u4f18\u5148\u7ea7 \u2462\u8fdb\u7a0b\u8c03\u5ea6\u6240\u9700\u8981\u7684\u5176\u4ed6\u4fe1\u606f \u2463\u4e8b\u4ef6 4\uff09\u8fdb\u7a0b\u63a7\u5236\u4fe1\u606f \u2460\u7a0b\u5e8f\u548c\u6570\u636e\u7684\u5730\u5740 \u2461\u8fdb\u7a0b\u540c\u6b65\u548c\u901a\u4fe1\u673a\u5236 \u2462\u8d44\u6e90\u6e05\u5355 \u2463\u94fe\u63a5\u6307\u9488","title":"\u8ba1\u7b97\u673a\u64cd\u4f5c\u7cfb\u7edf"},{"location":"course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#_1","text":"","title":"\u8ba1\u7b97\u673a\u64cd\u4f5c\u7cfb\u7edf"},{"location":"course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#_2","text":"1.1 \u4ec0\u4e48\u662f\u64cd\u4f5c\u7cfb\u7edf 1.1.1 \u64cd\u4f5c\u7cfb\u7edf\u662f\u7528\u6237\u4e0e\u8ba1\u7b97\u673a\u786c\u4ef6\u4e4b\u95f4\u7684\u63a5\u53e3 \u5c4f\u853d\u63a7\u5236\u786c\u4ef6\u7684\u7ec6\u8282\uff0c\u4f7f\u5e94\u7528\u7a0b\u5e8f\u7684\u5f00\u53d1\u66f4\u7b80\u5355\u3001\u9ad8\u6548 1.1.1.2 \u63a5\u53e3\u5f62\u5f0f\uff1a\u547d\u4ee4\u884c\u63a5\u53e3\u3001\u56fe\u5f62\u7528\u6237\u63a5\u53e3\u3001\u7cfb\u7edf\u8c03\u7528 1.1.1.3 \u6587\u4ef6\u7684\u5b58\u653e 1.1.1.3.1 \u903b\u8f91\u5730\u5740\u548c\u7269\u7406\u5730\u5740 \u903b\u8f91\u5730\u5740\uff1a\u7c07\u53f7\u6216\u6247\u533a\u7684\u903b\u8f91\u7f16\u53f7\u3002 \u7269\u7406\u5730\u5740\uff1a\u67f1\u9762\u53f7\u3001\u78c1\u5934\u53f7\uff08\u78c1\u9053\u53f7\uff09\u3001\u6247\u533a\u53f7\u3002 1.1.1.3.2 \u78c1\u76d8\u8bfb\u6587\u4ef6\u7684\u8fc7\u7a0b 1\uff09\u7528\u6237\u7ed9\u51fa\u6587\u4ef6\u540d\uff0c\u63d0\u51fa\u8bbf\u95ee\u6587\u4ef6\u7684\u8bf7\u6c42 2\uff09\u6587\u4ef6\u7cfb\u7edf\u901a\u8fc7\u6309\u540d\u8bbf\u95ee\u673a\u5236\u83b7\u53d6\u6587\u4ef6\u7684\u903b\u8f91\u5730\u5740\uff08\u78c1\u76d8\u5757\u53f7\u6216\u6247\u533a\u7f16\u53f7\uff09 3\uff09\u78c1\u76d8\u9a71\u52a8\u7a0b\u5e8f\u5c06\u903b\u8f91\u5730\u5740\u8f6c\u6362\u4e3a\u7269\u7406\u5730\u5740\u3001\u53d1\u9001\u78c1\u76d8\u64cd\u4f5c\u6307\u4ee4 1.1.2 \u64cd\u4f5c\u7cfb\u7edf\u662f\u8ba1\u7b97\u673a\u8d44\u6e90\u7684\u7ba1\u7406\u8005 \u7ba1\u7406\uff1a\u5904\u7406\u673a\u3001\u5185\u5b58\u3001\u8bbe\u5907\u3001\u6587\u4ef6\u3001\u7f51\u7edc\u7b49\u3002 1.1.2.1 \u64cd\u4f5c\u7cfb\u7edf\u7684\u8bbe\u8ba1\u8ffd\u6c42\u7684\u4e3b\u8981\u76ee\u6807 1\uff09\u65b9\u4fbf\u7528\u6237\uff08\u6700\u7ec8\u7528\u6237\u548c\u7a0b\u5e8f\u5458\uff09 2\uff09\u63d0\u9ad8\u7cfb\u7edf\u6027\u80fd\uff1a\u7a7a\u95f4\u6027\u80fd\u3001\u65f6\u95f4\u6027\u80fd\u3001\u8d44\u6e90\u5229\u7528\u7387 1.2 \u64cd\u4f5c\u7cfb\u7edf\u7684\u53d1\u5c55 1.2.1 \u65e0\u64cd\u4f5c\u7cfb\u7edf \u5b9a\u4e49\uff1a\u7b2c\u4e00\u4ee3\u8ba1\u7b97\u673a\uff081945-1955\uff09\u4f7f\u7528\u7535\u5b50\u7ba1\u4f5c\u4e3a\u4e3b\u8981\u7684\u7535\u5b50\u5668\u4ef6\uff0c\u7528\u63d2\u4ef6\u677f\u4e0a\u7684\u786c\u8fde\u7ebf\u6216\u7a7f\u5b54\u5361\u8868\u793a\u7a0b\u5e8f\uff0c\u6ca1\u6709\u5b58\u50a8\u7a0b\u5e8f\u7684\u5185\u5b58\uff0c\u65e0\u64cd\u4f5c\u7cfb\u7edf\u3002 1.2.2 \u5355\u9053\u6279\u5904\u7406\u7cfb\u7edf \u5b9a\u4e49\uff1a\u5355\u9053\u6279\u5904\u7406\u7cfb\u7edf\u5185\u5b58\u4e2d\u53ea\u6709\u4e00\u9053\u4f5c\u4e1a\uff0c\u53ef\u4ee5\u6210\u6279\u5904\u7406\u4f5c\u4e1a\u3002\u514b\u670dCPU\u56e0\u7b49\u5f85\u4eba\u5de5\u64cd\u4f5c\u9020\u6210\u7684\u8d44\u6e90\u6d6a\u8d39\u95ee\u9898 \u7279\u70b9\uff1a\u2460\u81ea\u52a8\u6027 \u2461\u987a\u5e8f\u6027 \u2462\u5355\u9053\u6027 \u4f18\u70b9\uff1a\u51cf\u5c11\u7b49\u5f85\u4eba\u5de5\u64cd\u4f5c\u7684\u65f6\u95f4 \u7f3a\u70b9\uff1a \u2460\u4f5c\u4e1a\u72ec\u5360CPU \u2461CPU\u7b49\u5f85I/O\u4f7f\u5f97CPU\u5229\u7528\u7387\u4f4e\uff08\u76f8\u5bf9\u4e8e\u591a\u9053\u7a0b\u5e8f\u7cfb\u7edf\u800c\u8a00\uff09 1.2.3 \u591a\u9053\u7a0b\u5e8f\u7cfb\u7edf 1.2.3.1 \u591a\u9053\u6279\u5904\u7406\u7cfb\u7edf \u7279\u70b9\uff1a\u2460\u591a\u9053\u6027 \u2461\u65e0\u5e8f\u6027 \u2462\u8c03\u5ea6\u6027 \u2463\u590d\u6742\u6027 \u4f18\u70b9\uff1a\u2460\u63d0\u9ad8CPU\u5229\u7528\u7387 \u2461\u63d0\u9ad8\u5185\u5b58\u548cI/O\u5229\u7528\u7387 \u2462\u589e\u52a0\u7cfb\u7edf\u541e\u5410\u91cf \u7f3a\u70b9\uff1a \u2460\u5e73\u5747\u5468\u8f6c\u65f6\u95f4 \u2461\u7f3a\u4e4f\u4ea4\u4e92\u80fd\u529b 1.2.3.2 \u5206\u65f6\u7cfb\u7edf \u5b9a\u4e49\uff1a\u2460\u4eba\u673a\u4ea4\u4e92 \u2461\u5171\u4eab\u4e3b\u673a \u2462\u4fbf\u4e8e\u7528\u6237\u4e0a\u673a \u7279\u70b9\uff1a\u2460\u591a\u8def\u6027 \u2461\u72ec\u7acb\u6027 \u2462\u53ca\u65f6\u6027 \u2463\u4ea4\u4e92\u6027 \u4f18\u70b9\uff1a\u2460\u63d0\u4f9b\u4eba\u673a\u4ea4\u4e92 \u2461\u591a\u7ec8\u7aef\u5171\u4eab\u4e3b\u673a \u5206\u65f6\u7cfb\u7edf\u5b9e\u73b0\u4e2d\u7684\u5173\u952e\u95ee\u9898\uff1a \u2460\u53ca\u65f6\u63a5\u6536\uff1a\u53ca\u65f6\u63a5\u6536\u7528\u6237\u7684\u547d\u4ee4\u6216\u6570\u636e \u2461\u53ca\u65f6\u5904\u7406\uff1a\u53ca\u65f6\u5904\u7406\u7528\u6237\u547d\u4ee4\u3002\u5e94\u8be5\u4f7f\u6240\u6709\u7684\u7528\u6237\u4f5c\u4e1a\u90fd\u76f4\u63a5\u8fdb\u5165\u5185\u5b58\uff1b\u5728\u5f88\u77ed\u7684\u65f6\u95f4\u5185\u4f7f\u6bcf\u4e2a\u4f5c\u4e1a\u90fd\u5f97\u5230\u8fd0\u884c\u3002 1.2.4 \u5fae\u673a\u64cd\u4f5c\u7cfb\u7edf 1.2.5 \u5b9e\u65f6\u64cd\u4f5c\u7cfb\u7edf \u5b9a\u4e49\uff1a\u5b9e\u65f6\u7cfb\u7edf\u662f\u652f\u6301\u5b9e\u65f6\u8ba1\u7b97\u7684\u7cfb\u7edf\u3002\u5b9e\u65f6\u8ba1\u7b97\u53ef\u4ee5\u5b9a\u4e49\u6210\u8fd9\u6837\u4e00\u7c7b\u8ba1\u7b97\uff0c\u65e2\u7cfb\u7edf\u7684\u6b63\u786e\u6027\u4e0d\u4ec5\u53d6\u51b3\u4e8e\u8ba1\u7b97\u7684\u903b\u8f91\u7ed3\u679c\uff0c\u800c\u4e14\u8fd8\u4f9d\u8d56\u4e8e\u4ea7\u751f\u7ed3\u679c\u7684\u65f6\u95f4\u3002 \u5b9e\u65f6\u4efb\u52a1\u7684\u7c7b\u578b \u2460\u5468\u671f\u6027\u5b9e\u65f6\u4efb\u52a1 \u2461\u975e\u5468\u671f\u6027\u5b9e\u65f6\u4efb\u52a1 \u2462\u786c\u5b9e\u65f6\u4efb\u52a1 \u2463\u8f6f\u5b9e\u65f6\u4efb\u52a1\u3002 \u6ce8\uff1a\u4e00\u4e2a\u5b9e\u9645\u7684OS\u53ef\u4ee5\u540c\u65f6\u5177\u6709\u6279\u5904\u7406\u3001\u5206\u65f6\u548c\u5b9e\u65f6\u7684\u7279\u70b9\uff0c\u5982Windows NT\u3002 1.3 \u64cd\u4f5c\u7cfb\u7edf\u7684\u7279\u5f81 \u5e76\u53d1\uff1a\u4e24\u4e2a\u6216\u591a\u4e2a\u4e8b\u4ef6\u5728\u540c\u4e00\u65f6\u95f4\u95f4\u9694\u5185\u53d1\u751f\u3002\u5e76\u53d1\u5f3a\u8c03\u201c\u540c\u4e00\u65f6\u95f4\u95f4\u9694\u201d\uff0c\u4e0e\u5e76\u884c\u662f\u4e0d\u540c\u7684\u4e24\u4e2a\u6982\u5ff5\uff0c\u5e76\u884c\u662f\u6307\u591a\u4e2a\u4e8b\u4ef6\u540c\u65f6\u53d1\u751f\u3002 \u5171\u4eab\uff1a\u7cfb\u7edf\u4e2d\u7684\u8d44\u6e90\u53ef\u4f9b\u5185\u5b58\u4e2d\u591a\u4e2a\u5e76\u53d1\u6267\u884c\u7684\u8fdb\u7a0b\u5171\u540c\u4f7f\u7528\u3002 \u8d44\u6e90\u5171\u4eab\u6709\u4e24\u79cd\u65b9\u5f0f\uff0c\u5373\uff1a\u4e92\u65a5\u5171\u4eab\u548c\u540c\u65f6\u5171\u4eab\u3002 \u865a\u62df\uff1a\u901a\u8fc7\u67d0\u79cd\u6280\u672f\u628a\u4e00\u4e2a\u7269\u7406\u5b9e\u4f53\u53d8\u6210\u82e5\u5e72\u903b\u8f91\u4e0a\u7684\u5bf9\u5e94\u7269\u3002 \u5f02\u6b65\uff1a\u8fdb\u7a0b\u4ee5\u4e0d\u53ef\u9884\u77e5\u7684\u987a\u5e8f\u3001\u8fdb\u5ea6\u8fd0\u884c\uff0c\u7cfb\u7edf\u80fd\u5904\u7406\u968f\u673a\u53d1\u751f\u7684\u4e8b\u4ef6\u3002 1.4 \u64cd\u4f5c\u7cfb\u7edf\u7684\u529f\u80fd \u5185\u5b58\u7ba1\u7406\u529f\u80fd\u3001\u8fdb\u7a0b\u7ba1\u7406\u529f\u80fd\u3001\u8bbe\u5907\u7ba1\u7406\u529f\u80fd\u3001\u6587\u4ef6\u7ba1\u7406\u529f\u80fd\u3001\u7528\u6237\u63a5\u53e3 1.4.1 \u5185\u5b58\u7ba1\u7406\u529f\u80fd \u5185\u5b58\u5206\u914d; \u5185\u5b58\u4fdd\u62a4: \u786e\u4fdd\u6bcf\u9053\u7528\u6237\u7a0b\u5e8f\u90fd\u5728\u81ea\u5df1\u7684\u5185\u5b58\u7a7a\u95f4\u4e2d\u8fd0\u884c\uff0c\u4e92\u4e0d\u5e72\u6270\u3002 \u5730\u5740\u6620\u5c04; \u2460\u903b\u8f91\u5730\u5740\u548c\u7269\u7406\u5730\u5740 \u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7ecf\u7f16\u8bd1\u540e\uff0c\u901a\u5e38\u4f1a\u5f62\u6210\u82e5\u5e72\u4e2a\u76ee\u6807\u7a0b\u5e8f\uff0c\u8fd9\u4e9b\u76ee\u6807\u7a0b\u5e8f\u518d\u7ecf\u8fc7\u94fe\u63a5\u800c\u5f62\u6210\u53ef\u88c5\u5165\u7a0b\u5e8f\u3002\u8fd9\u4e9b\u7a0b\u5e8f\u7684\u5730\u5740\u90fd\u662f\u4ece\u67d0\u4e00\u8d77\u59cb\u5730\u5740\u5f00\u59cb\u7684\uff0c\u7a0b\u5e8f\u4e2d\u7684\u5176\u5b83\u5730\u5740\u90fd\u662f\u76f8\u5bf9\u4e8e\u8d77\u59cb\u5730\u5740\u8ba1\u7b97\u7684\uff1b\u7531\u8fd9\u4e9b\u5730\u5740\u6240\u5f62\u6210\u7684\u5730\u5740\u8303\u56f4\u79f0\u201c\u5730\u5740\u7a7a\u95f4\u201d\uff0c\u5176\u4e2d\u7684\u5730\u5740\u79f0\u4e3a\u201c\u903b\u8f91\u5730\u5740\u201d\u3002 \u7531\u5185\u5b58\u4e2d\u7684\u4e00\u7cfb\u5217\u5355\u5143\u6240\u9650\u5b9a\u7684\u5730\u5740\u8303\u56f4\u79f0\u4e3a\u201c\u5185\u5b58\u7a7a\u95f4\u201d\uff0c\u5176\u4e2d\u7684\u5730\u5740\u79f0\u4e3a\u201c\u7269\u7406\u5730\u5740\u201d\u3002 \u2461\u5730\u5740\u6620\u5c04 \u5185\u5b58\u6269\u5145\uff1b\u865a\u62df\u5185\u5b58\u3002 \u5185\u5b58\u56de\u6536\uff1a\u7a0b\u5e8f\u6267\u884c\u5b8c\u6bd5\u6216\u6587\u4ef6\u88ab\u5173\u95ed\uff0c\u7cfb\u7edf\u5c06\u7a0b\u5e8f\u3001\u6587\u4ef6\u5360\u7528\u7684\u5185\u5b58\u7a7a\u95f4\u6807\u8bb0\u4e3a\u7a7a\u95f2\u72b6\u6001\u3002 1.4.2 \u8fdb\u7a0b\u7ba1\u7406\u529f\u80fd \u8fdb\u7a0b\u63a7\u5236 \u8fdb\u7a0b\u540c\u6b65 \u8fdb\u7a0b\u901a\u4fe1 \u8fdb\u7a0b\u8c03\u5ea6 1.4.3 \u8bbe\u5907\u7ba1\u7406\u529f\u80fd \u7f13\u51b2\u7ba1\u7406\uff1a\u7ba1\u7406\u5404\u79cd\u7f13\u51b2\u533a\u3002 \u8bbe\u5907\u5206\u914d\uff1a\u5206\u914d\u7528\u6237I/O \u6240\u9700\u8981\u7684\u8bbe\u5907\u3002 \u8bbe\u5907\u5904\u7406\uff1a\u7531\u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f\u6765\u5b9e\u73b0CPU\u4e0e\u8bbe\u5907\u63a7\u5236\u5668\u4e4b\u95f4\u7684\u901a\u4fe1\u3002 \u8bbe\u5907\u72ec\u7acb\u6027\uff1a\u5e94\u7528\u7a0b\u5e8f\u4e0e\u5177\u4f53\u7684\u7269\u7406\u8bbe\u5907\u65e0\u5173\u3002 \u865a\u62df\u8bbe\u5907\uff1a\u591a\u4e2a\u7528\u6237\u3001\u591a\u4e2a\u8fdb\u7a0b\u8bfe\u5171\u4eab\u540c\u4e00\u4e2a\u7269\u7406\u8bbe\u5907\u3002 1.4.4 \u6587\u4ef6\u7ba1\u7406\u529f\u80fd \u6587\u4ef6\u7684\u6309\u540d\u8bbf\u95ee \u6587\u4ef6\u7684\u5b58\u50a8 1.4.5 \u63d0\u4f9b\u7528\u6237\u63a5\u53e3 \u547d\u4ee4\u63a5\u53e3 \u56fe\u5f62\u63a5\u53e3:\u91c7\u7528\u56fe\u5f62\u5316\u7684\u64cd\u4f5c\u754c\u9762\u3002 \u7a0b\u5e8f\u63a5\u53e3\uff1a\u7531\u4e00\u7ec4\u7cfb\u7edf\u8c03\u7528\u7ec4\u6210\u3002 1.5 \u6307\u4ee4\u7684\u6267\u884c 1.5.1 \u53d6\u6307\u4ee4\u4e0e\u6267\u884c\u6307\u4ee4 1.5.1.1 \u53d6\u6307\u4ee4 \u5728\u6bcf\u4e2a\u6307\u4ee4\u5468\u671f\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u5904\u7406\u5668\u4ece\u5b58\u50a8\u5668\u4e2d\u53d6\u4e00\u6761\u6307\u4ee4\uff0c\u5728\u5178\u578b\u7684\u5904\u7406\u5668\u4e2d\uff0c\u7a0b\u5e8f\u8ba1\u6570\u5668\uff08PC\uff09\u4fdd\u5b58\u6709\u4e0b\u4e00\u6b21\u8981\u53d6\u7684\u6307\u4ee4\u7684\u5730\u5740\u3002\u9664\u975e\u63a5\u6536\u5230\u522b\u7684\u6307\u793a\uff08\u5982\u6267\u884c\u8df3\u8f6c\u6307\u4ee4\uff09\uff0c\u5426\u5219\u5904\u7406\u5668\u5728\u6bcf\u6b21\u5b8c\u6210\u53d6\u6307\u4ee4\u540e\u603b\u662f\u5bf9PC\u9012\u589e\uff0c\u4f7f\u5b83\u80fd\u591f\u6309\u987a\u5e8f\u53d6\u5f97\u4e0b\u4e00\u6761\u6307\u4ee4\u3002\uff08\u5373\u4f4d\u4e8e\u4e0b\u4e00\u4e2a\u9ad8\u7aef\u5b58\u50a8\u5668\u5730\u5740\u7684\u6307\u4ee4\uff09\u3002 1.5.1.2 \u6267\u884c\u6307\u4ee4 \u53d6\u5230\u7684\u6307\u4ee4\u88ab\u653e\u7f6e\u5728\u5904\u7406\u5668\u4e2d\u7684\u6307\u4ee4\u5bc4\u5b58\u5668\uff08IR\u4e2d\u3002\u6307\u4ee4\u4e2d\u5305\u542b\u786e\u5b9a\u5904\u7406\u5668\u5c06\u8981\u91c7\u53d6\u52a8\u4f5c\u7684\u4f4d\uff0c\u5904\u7406\u5668\u89e3\u91ca\u6307\u4ee4\u5e76\u6267\u884c\u8981\u6c42\u7684\u64cd\u4f5c\uff0c\u8fd9\u4e9b\u64cd\u4f5c\u53ef\u5206\u4e3a4\u7c7b\uff1a \u2460\u5904\u7406\u5668-\u5b58\u50a8\u5668:\u6570\u636e\u5728\u5b58\u50a8\u5668\u548c\u5904\u7406\u5668\u4e4b\u95f4\u4f20\u9001\uff1b \u2461\u5904\u7406\u5668-I/O\uff1a\u6570\u636e\u5728I/O\u8bbe\u5907\u548c\u5904\u7406\u5668\u4e4b\u95f4\u4f20\u9001\uff1b \u2462\u6570\u636e\u5904\u7406\uff1a\u7b97\u672f\u64cd\u4f5c\u6216\u903b\u8f91\u64cd\u4f5c\uff1b \u2463\u63a7\u5236\uff1a\u4fee\u6539\u6307\u4ee4\u7684\u6267\u884c\u987a\u5e8f\u3002 1.5.2 \u5185\u90e8CPU\u5bc4\u5b58\u5668 \u7a0b\u5e8f\u8ba1\u6570\u5668\uff08PC\uff09----\u5b58\u6307\u4ee4\u5730\u5740 \u6307\u4ee4\u5bc4\u5b58\u5668\uff08IR) ----\u5b58\u6b63\u5728\u6267\u884c\u7684\u6307\u4ee4 \u7d2f\u52a0\u5668\uff08AC) ----\u4e34\u65f6\u5b58\u50a8\u4f53\u548c\u7d2f\u52a0\u64cd\u4f5c 1.6 \u5c0f\u7ed3 1.\u7a0b\u5e8f\u6267\u884c\u7684\u8fc7\u7a0b\u662f\u53cd\u590d\u53d6\u6307\u4ee4\u548c\u6267\u884c\u6307\u4ee4\u7684\u8fc7\u7a0b\uff1b 2.PC\u59cb\u7ec8\u5b58\u6709\u4e0b\u4e00\u6761\u5f85\u53d6\u6307\u4ee4\u7684\u5730\u5740\uff1b 3.\u6307\u4ee4\u6267\u884c\u7684\u7ed3\u679c\u5c31\u662f\u4f7f\u5bc4\u5b58\u5668\u6216\u5185\u5b58\u5355\u5143\u7684\u503c\u53d1\u751f\u53d8\u5316\u3002\u6307\u4ee4\u6267\u884c\u7684\u8fc7\u7a0b\u4e5f\u5c31\u662f\u5b58\u50a8\u4f53\u5185\u5bb9\u4e0d\u65ad\u53d8\u5316\u7684\u8fc7\u7a0b\u3002 4.\u53d6\u6307\u4ee4\u548c\u6267\u884c\u6307\u4ee4\u662f\u7531\u786c\u4ef6\u5b8c\u6210\u7684\u3002 5.\u4e0d\u540c\u786c\u4ef6\u7684\u4f53\u7cfb\u7ed3\u6784\u652f\u6301\u4e0d\u540c\u7684\u6307\u4ee4\u96c6\u5408\uff0c\u4e3a\u67d0\u79cd\u786c\u4ef6\u5e73\u53f0\u5f00\u53d1\u7684\u64cd\u4f5c\u7cfb\u7edf\u4e0d\u80fd\u76f4\u63a5\u5728\u53e6\u4e00\u79cd\u4f53\u7cfb\u7ed3\u6784\u7684\u786c\u4ef6\u4e0a\u8fd0\u884c\u3002 6.\u4efb\u4f55\u9ad8\u7ea7\u8bed\u8a00\u7a0b\u5e8f\u88ab\u7f16\u8bd1\u6210\u6307\u4ee4\u96c6\u5408\uff0c\u5176\u4e2d\u7684\u6bcf\u4e00\u6761\u6307\u4ee4\u5c5e\u4e8e\u673a\u5668\u4f53\u7cfb\u7ed3\u6784\u6307\u4ee4\u96c6\u3002CPU\u6267\u884c\u7684\u6700\u5c0f\u7a0b\u5e8f\u5355\u4f4d\u662f\u6307\u4ee4\u800c\u4e0d\u662f\u9ad8\u7ea7\u8bed\u8a00\u7a0b\u5e8f\u7684\u8bed\u53e5\u3002","title":"\u7b2c\u4e00\u7ae0 \u64cd\u4f5c\u7cfb\u7edf\u6982\u8ff0"},{"location":"course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#_3","text":"2.1 \u7a0b\u5e8f\u7684\u5e76\u53d1\u8fd0\u884c 2.1.1 \u6982\u5ff5 \u5728\u540c\u4e00\u65f6\u95f4\u95f4\u9694\u5185\u8fd0\u884c\u591a\u4e2a\u7a0b\u5e8f\uff0c\u4e00\u4e2a\u7a0b\u5e8f\u8fd8\u6ca1\u6709\u6267\u884c\u5b8c\uff0c\u53ef\u4ee5\u8fd0\u884c\u5176\u5b83\u7684\u7a0b\u5e8f\uff0c\u5bf9\u7528\u6237\u800c\u8a00\uff0c\u770b\u5230\u7684\u662f\u8ba1\u7b97\u673a\u540c\u65f6\u8fd0\u884c\u591a\u4e2a\u7a0b\u5e8f\u3002 \u7a0b\u5e8f\u5e76\u53d1\u6267\u884c\u7684\u65b9\u5f0f\u53ef\u4ee5\u662f\u591a\u4e2a\u7a0b\u5e8f\u5206\u65f6\u4f7f\u7528\u591aCPU\u6216\u5355CPU\u3002 2.1.2 \u7279\u70b9 \u2460\u95f4\u65ad\u6027 \u2461\u591a\u4e2a\u7a0b\u5e8f\u5171\u4eab\u7cfb\u7edf\u8d44\u6e90\uff08\u5931\u53bb\u5c01\u95ed\u6027\uff09\u2462\u4e0d\u53ef\u518d\u73b0\u6027 2.2 \u8fdb\u7a0b\u7684\u63cf\u8ff0 \u8fdb\u7a0b\u6982\u5ff5\u7684\u5f15\u5165\u662f\u4e3a\u4e86\u8ddf\u8e2a\u5e76\u63cf\u8ff0\u7a0b\u5e8f\u7684\u5e76\u53d1\u6267\u884c\u3002\u5f53\u5141\u8bb8\u7a0b\u5e8f\u5e76\u53d1\u6267\u884c\u65f6\uff0c\u5e76\u53d1\u6267\u884c\u7684\u7a0b\u5e8f\u53ef\u80fd\u662f\u540c\u4e00\u4e2a\u7a0b\u5e8f\u5728\u4e0d\u540c\u6570\u636e\u96c6\u5408\u4e0a\u7684\u6267\u884c\uff0c\u4e5f\u53ef\u80fd\u662f\u4e0d\u540c\u7684\u7a0b\u5e8f\u5728\u4e0d\u540c\u6570\u636e\u96c6\u5408\u4e0a\u7684\u6267\u884c\uff0c\u5b83\u4eec\u5171\u4eab\u7cfb\u7edf\u8d44\u6e90\uff0c\u7528\u7a0b\u5e8f\u5df2\u4e0d\u80fd\u65b9\u4fbf\u5730\u63cf\u8ff0\u7a0b\u5e8f\u7684\u5e76\u53d1\u6267\u884c\uff0c\u6240\u4ee5\u5f15\u5165\u4e86\u8fdb\u7a0b\u7684\u6982\u5ff5 \u3002 2.2.1 \u8fdb\u7a0b\u7684\u5b9a\u4e49 \u5b9a\u4e491\uff1a\u8fdb\u7a0b\u662f\u5141\u8bb8\u5e76\u53d1\u6267\u884c\u7684\u7a0b\u5e8f\u5728\u67d0\u4e2a\u6570\u636e\u96c6\u5408\u4e0a\u7684\u6267\u884c\u8fc7\u7a0b\u3002 \u5b9a\u4e492\uff1a\u8fdb\u7a0b\u662f\u7531\u7528\u6237\u6570\u636e\u3001\u7cfb\u7edf\u6570\u636e\u548c\u7a0b\u5e8f\u6784\u6210\u7684\u5b9e\u4f53\u3002 2.2.2 \u8fdb\u7a0b\u7684\u7279\u5f81 \u5e76\u53d1\u6027\uff1a\u591a\u4e2a\u8fdb\u7a0b\u5b9e\u4f53\uff0c\u540c\u5b58\u4e8e\u5185\u5b58\u4e2d\uff0c\u80fd\u5728\u4e00 \u6bb5\u65f6\u95f4\u5185\u540c\u65f6\u8fd0\u884c\u3002 \u52a8\u6001\u6027\uff1a\u8fdb\u7a0b\u662f\u8fdb\u7a0b\u5b9e\u4f53\u7684\u6267\u884c\u8fc7\u7a0b\uff0c\u5bf9\u5e94\u4e86\u5b58\u50a8\u4f53\u7684\u4e0d\u65ad\u53d8\u5316\uff1b\u6709\u521b\u5efa\u3001\u6267\u884c\u3001\u72b6\u6001\u53d8\u5316\u548c\u8fd0\u884c\u7ec8\u6b62\u88ab\u64a4\u6d88\u7684\u8fc7\u7a0b \u72ec\u7acb\u6027\uff1a\u72ec\u7acb\u8fd0\u884c\u548c\u8d44\u6e90\u8c03\u5ea6\u7684\u57fa\u672c\u5355\u4f4d\u3002 \u5f02\u6b65\u6027\uff1a\u4ee5\u4e0d\u540c\u7684\u3001\u4e0d\u53ef\u9884\u77e5\u7684\u901f\u5ea6\u5411\u524d\u63a8\u8fdb\u3002 \u7ed3\u6784\u7279\u5f81\uff1a\u8fdb\u7a0b\u5305\u62ec\u7528\u6237\u6570\u636e\u3001\u7a0b\u5e8f\u3001\u7cfb\u7edf\u6570\u636e\u3002 2.2.3 \u8fdb\u7a0b\u4e0e\u7a0b\u5e8f\u7684\u6bd4\u8f83 \u533a\u522b \uff1a \u2460\u7a0b\u5e8f\u662f\u9759\u6001\u7684\u6982\u5ff5\uff0c\u8fdb\u7a0b\u662f\u52a8\u6001\u7684\u6982\u5ff5 \u2461\u7a0b\u5e8f\u662f\u6c38\u4e45\u7684\uff0c\u8fdb\u7a0b\u662f\u6682\u65f6\u5b58\u5728\u7684 \u2462\u7a0b\u5e8f\u4e0e\u8fdb\u7a0b\u7684\u5b58\u5728\u5b9e\u4f53\u4e0d\u540c \u8054\u7cfb \uff1a \u2460\u8fdb\u7a0b\u662f\u7a0b\u5e8f\u7684\u4e00\u6b21\u6267\u884c\uff0c\u8fdb\u7a0b\u603b\u662f\u5bf9\u5e94\u4e00\u4e2a\u7279\u5b9a\u7684\u7a0b\u5e8f\uff0c\u6267\u884c\u7a0b\u5e8f\u7684\u4ee3\u7801\uff0c\u4e00\u4e2a\u8fdb\u7a0b\u5fc5\u7136\u5bf9\u5e94\u81f3\u5c11\u4e00\u6bb5\u7a0b\u5e8f\u3002 \u2461\u4e00\u4e2a\u7a0b\u5e8f\u53ef\u4ee5\u5bf9\u5e94\u591a\u4e2a\u8fdb\u7a0b\u3002\u540c\u4e00\u4e2a\u7a0b\u5e8f\u6bb5\u53ef\u4ee5\u5728\u4e0d\u540c\u7684\u6570\u636e\u96c6\u5408\u4e0a\u8fd0\u884c\uff0c\u56e0\u800c\u6784\u6210\u82e5\u5e72\u4e2a\u4e0d\u540c\u7684\u8fdb\u7a0b\u3002 2.2.4 \u7a0b\u5e8f\u63a7\u5236\u5757 \u8fdb\u7a0b\u63a7\u5236\u5757\u662f\u8fdb\u7a0b\u5b9e\u4f53\u7684\u4e00\u90e8\u5206\uff0c\u662f\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u6700\u91cd\u8981\u7684\u8bb0\u5f55\u578b\u6570\u636e\u7ed3\u6784\uff0cPCB\u4e2d\u8bb0\u5f55\u4e86\u64cd\u4f5c\u7cfb\u7edf\u6240\u9700\u8981\u7684\u7528\u4e8e\u63cf\u8ff0\u8fdb\u7a0b\u60c5\u51b5\u53ca\u63a7\u5236\u8fdb\u7a0b\u8fd0\u884c\u6240\u9700\u7684\u5168\u90e8\u4fe1\u606f\u3002 2.2.4.1 \u8fdb\u7a0b\u63a7\u5236\u5757\u4e2d\u7684\u4fe1\u606f 1\uff09 \u8fdb\u7a0b\u6807\u8bc6\u7b26\u4fe1\u606f \u2460 \u5916\u90e8\u6807\u8bc6\u7b26 \u2461 \u5185\u90e8\u6807\u8bc6\u7b26 \u2462 \u7236\u8fdb\u7a0b\u6807\u8bc6\u7b26 \u2463\u5b50\u8fdb\u7a0b\u6807\u8bc6\u7b26 2\uff09\u5904\u7406\u673a\u72b6\u6001\u4fe1\u606f \u2460\u901a\u7528\u5bc4\u5b58\u5668 \u2461\u6307\u4ee4\u8ba1\u6570\u5668 \u2462\u7a0b\u5e8f\u72b6\u6001\u5b57PSW \u2463\u7528\u6237\u6808\u6307\u9488 3\uff09\u8fdb\u7a0b\u8c03\u5ea6\u4fe1\u606f \u2460\u8fdb\u7a0b\u72b6\u6001\u4fe1\u606f \u2461\u8fdb\u7a0b\u4f18\u5148\u7ea7 \u2462\u8fdb\u7a0b\u8c03\u5ea6\u6240\u9700\u8981\u7684\u5176\u4ed6\u4fe1\u606f \u2463\u4e8b\u4ef6 4\uff09\u8fdb\u7a0b\u63a7\u5236\u4fe1\u606f \u2460\u7a0b\u5e8f\u548c\u6570\u636e\u7684\u5730\u5740 \u2461\u8fdb\u7a0b\u540c\u6b65\u548c\u901a\u4fe1\u673a\u5236 \u2462\u8d44\u6e90\u6e05\u5355 \u2463\u94fe\u63a5\u6307\u9488","title":"\u7b2c\u4e8c\u7ae0 \u8fdb\u7a0b\u7684\u63cf\u8ff0\u4e0e\u63a7\u5236"},{"location":"course/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","text":"\u8f6f\u4ef6\u5de5\u7a0b\u590d\u4e60 \u00b6 \u7b2c\u4e00\u7ae0 \u8f6f\u4ef6\u5de5\u7a0b\u5b66\u6982\u8ff0 \u00b6 \u8f6f\u4ef6\u5b9a\u4e49 Software = Program + Data + Document \u8f6f\u4ef6(software)\u662f\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d\u4e0e\u786c\u4ef6(hardware)\u76f8\u4e92\u4f9d\u5b58\u7684\uff0c\u53e6\u4e00\u90e8\u5206\uff0c\u5b83\u5305\u62ec\u7a0b\u5e8f(program)\u3001\u76f8\u5173\u6570\u636e(data)\u53ca\u5176\u8bf4\u660e\u6587\u6863 (document)\u3002 \u7a0b\u5e8f\uff1a\u662f\u6309\u4e8b\u5148\u8bbe\u8ba1\u7684\u529f\u80fd\u548c\u6027\u80fd\u8981\u6c42\u6267\u884c\u7684\u6307\u4ee4\u5e8f\u5217\uff1b \u6570\u636e\uff1a\u662f\u4f7f\u7a0b\u5e8f\u80fd\u6b63\u5e38\u64cd\u7eb5\u4fe1\u606f\u7684\u6570\u636e\u7ed3\u6784\uff1b \u6587\u6863\uff1a\u662f\u4e0e\u7a0b\u5e8f\u5f00\u53d1\u3001\u7ef4\u62a4\u548c\u4f7f\u7528\u6709\u5173\u7684\u56fe\u6587\u6750\u6599\u3002 \u8f6f\u4ef6\u7684\u7279\u70b9 \u8f6f\u4ef6\u662f\u4e00\u79cd\u903b\u8f91\u5b9e\u4f53\uff0c\u5177\u6709\u62bd\u8c61\u6027\uff1b \u8f6f\u4ef6\u662f\u5f00\u53d1\u7684\uff0c\u800c\u4e0d\u662f\u5236\u9020\u7684\uff1b \u5728\u8f6f\u4ef6\u7684\u8fd0\u884c\u548c\u4f7f\u7528\u671f\u95f4\uff0c\u6ca1\u6709\u786c\u4ef6\u90a3\u6837\u7684\u673a\u68b0\u78e8\u635f\uff0c\u8001\u5316\u95ee\u9898; \u8f6f\u4ef6\u7684\u5f00\u53d1\u81f3\u4eca\u5c1a\u672a\u5b8c\u5168\u6446\u8131\u624b\u5de5\u4f5c\u574a\u5f0f\u7684\u5f00\u53d1\u65b9\u5f0f\uff0c\u751f\u4ea7\u6548\u7387\u4f4e\uff1b \u8f6f\u4ef6\u5177\u6709\u590d\u6742\u6027\uff1b \u8f6f\u4ef6\u7684\u6210\u672c\u76f8\u5f53\u6602\u8d35\uff1b \u8f6f\u4ef6\u5bf9\u786c\u4ef6\u548c\u73af\u5883\u6709\u7740\u4e0d\u540c\u7a0b\u5ea6\u7684\u4f9d\u8d56\u6027\uff1b \u8f6f\u4ef6\u5de5\u4f5c\u7275\u6d89\u5230\u5f88\u591a\u793e\u4f1a\u56e0\u7d20\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u4e09\u8981\u7d20 \u8f6f\u4ef6\u5de5\u7a0b\u7684\u65b9\u6cd5\uff1a\u4e3a\u8f6f\u4ef6\u5f00\u53d1\u63d0\u4f9b\u201c\u5982\u4f55\u505a\u201d\u7684\u6280\u672f\uff0c\u5f53\u524d\u6709\u4f20\u7edf\u7684\u8f6f\u4ef6\u5f00\u53d1\u65b9\u6cd5\u548c\u9762\u5411\u5bf9\u8c61\u7684\u8f6f\u4ef6\u5f00 \u53d1\u65b9\u6cd5\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u7684\u8fc7\u7a0b\uff1a\u662f\u7ba1\u7406\u548c\u63a7\u5236\u4ea7\u54c1\u8d28\u91cf\u7684\u5173\u952e\uff0c\u5b9e\u73b0\u5728\u89c4\u5b9a\u7684\u65f6\u95f4\u548c\u9884\u7b97\u5185\u5f00\u53d1\u9ad8\u8d28\u91cf\u8f6f\u4ef6\u7684\u76ee\u6807\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u7684\u5de5\u5177\uff1a\u4e3a\u8f6f\u4ef6\u5de5\u7a0b\u65b9\u6cd5 \u63d0\u4f9b\u4e86\u81ea\u52a8\u7684\u6216\u534a\u81ea\u52a8\u7684\u8f6f\u4ef6\u652f\u6491 \u73af\u5883\uff0c\u8f85\u52a9\u8f6f\u4ef6\u5f00\u53d1\u4efb\u52a1\u7684\u5b8c\u6210\u3002 CASE \u8f6f\u4ef6\u5de5\u7a0b\u5c42\u6b21\uff1a\u8d28\u91cf\u7126\u70b9>\u8fc7\u7a0b>\u65b9\u6cd5>\u5de5\u5177 \u55b7\u6cc9\u6a21\u578b \u55b7\u6cc9\u6a21\u578b\u662f\u4e00\u79cd\u4ee5\u7528\u6237\u9700\u6c42\u4e3a\u52a8\u529b\uff0c \u4ee5\u5bf9\u8c61\u4e3a\u9a71\u52a8\u7684\u6a21\u578b\uff0c\u4e3b\u8981\u7528\u4e8e\u63cf\u8ff0\u9762\u5411\u5bf9\u8c61\u7684\u8f6f\u4ef6\u5f00\u53d1\u8fc7\u7a0b\u3002 \u8f6f\u4ef6\u5f00\u53d1\u8fc7\u7a0b\u81ea\u4e0b\u800c\u4e0a\u5468\u671f\u7684\u5404\u9636\u6bb5\u662f\u76f8\u4e92\u91cd\u53e0\u548c\u591a\u6b21\u53cd\u590d\u7684\uff0c\u5c31\u50cf\u6c34\u55b7\u4e0a\u53bb\u53c8\u53ef\u4ee5\u843d\u4e0b\u6765\uff0c\u7c7b\u4f3c\u4e00\u4e2a\u55b7\u6cc9\u3002 \u5404\u4e2a\u5f00\u53d1\u9636\u6bb5\u6ca1\u6709\u7279\u5b9a\u7684\u6b21\u5e8f\u8981\u6c42\uff0c\u5e76\u4e14\u53ef\u4ee5\u4ea4\u4e92\u8fdb\u884c\uff0c\u53ef\u4ee5\u5728\u67d0\u4e2a\u5f00\u53d1\u9636\u6bb5\u4e2d\u968f\u65f6\u8865\u5145\u5176\u4ed6\u4efb\u4f55\u5f00\u53d1\u9636\u6bb5\u4e2d\u7684\u9057\u6f0f\u3002 \u4f18\u70b9: \u8be5\u6a21\u578b\u7684\u5404\u4e2a\u9636\u6bb5\u6ca1\u6709\u660e\u663e\u7684\u754c\u9650\uff0c\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u540c\u6b65\u8fdb\u884c\u5f00 \u53d1\uff0c\u53ef\u4ee5\u63d0\u9ad8\u8f6f\u4ef6\u9879\u76ee\u5f00\u53d1\u6548\u7387\uff0c\u8282\u7701\u5f00\u53d1\u65f6\u95f4\uff0c\u9002\u5e94\u4e8e\u9762\u5411\u5bf9\u8c61 \u7684\u8f6f\u4ef6\u5f00\u53d1\u8fc7\u7a0b\u3002 \u7f3a\u70b9\uff1a \u7531\u4e8e\u8be5\u6a21\u578b\u5728\u5404\u4e2a\u5f00\u53d1\u9636\u6bb5\u662f\u91cd\u53e0\u7684\uff0c\u5728\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u9700\u8981\u5927\u91cf \u7684\u5f00\u53d1\u4eba\u5458\uff0c\u56e0\u6b64\u4e0d\u5229\u4e8e\u9879\u76ee\u7684\u7ba1\u7406\u3002 \u8be5\u6a21\u578b\u8981\u6c42\u4e25\u683c\u7ba1\u7406\u6587\u6863\uff0c\u4f7f\u5f97\u5ba1\u6838\u7684\u96be\u5ea6\u52a0\u5927\uff0c\u5c24\u5176\u662f\u9762\u5bf9 \u53ef\u80fd\u968f\u65f6\u52a0\u5165\u5404\u79cd\u4fe1\u606f\u3001\u9700\u6c42\u4e0e\u8d44\u6599\u7684\u60c5\u51b5\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u4e0e\u4e00\u822c\u5de5\u7a0b\u7684\u5dee\u5f02 \u8f6f\u4ef6\u662f\u903b\u8f91\u4ea7\u54c1\u800c\u4e0d\u662f\u5b9e\u7269\u4ea7\u54c1 \u3001\u8f6f\u4ef6\u7684\u529f\u80fd\u4f9d\u8d56\u4e8e\u786c\u4ef6\u548c\u8f6f\u4ef6\u7684\u8fd0\u884c\u73af\u5883\u4ee5 \u53ca\u4eba\u4eec\u5bf9\u5b83\u7684\u64cd\u4f5c\u3001\u8f6f\u4ef6\u8bbe\u8ba1\u7684\u590d\u6742\u6027\u3001\u8f6f\u4ef6\u7279\u5f81\uff1a \u529f\u80fd\u7684\u591a\u6837\u6027 \u5b9e\u73b0\u7684\u591a\u6837\u6027 \u80fd\u89c1\u5ea6\u4f4e \u8f6f\u4ef6\u7ed3\u6784\u5408\u7406\u6027\u5dee \u3001\u667a\u529b\u5bc6\u96c6\u53ca\u77e5\u8bc6\u4ea7\u6743\u4fdd\u62a4 \u7b2c\u4e8c\u7ae0 \u53ef\u884c\u6027\u7814\u7a76 \u00b6 \u6570\u636e\u6d41\u56fe\u7684\u5c42\u6b21\u7ed3\u6784 \u4e3a\u4e86\u8868\u8fbe\u6570\u636e\u5904\u7406\u8fc7\u7a0b\u7684\u6570\u636e\u52a0\u5de5\u60c5\u51b5\uff0c\u9700\u8981\u91c7\u7528\u5c42\u6b21\u7ed3\u6784\u7684\u6570\u636e\u6d41\u56fe\u3002\u6309\u7167\u7cfb\u7edf\u7684\u5c42\u6b21\u7ed3\u6784\u8fdb\u884c\u9010\u6b65\u5206\u89e3\uff0c\u5e76\u4ee5\u5206\u5c42\u7684\u6570\u636e \u6d41\u56fe\u53cd\u6620\u8fd9\u79cd\u7ed3\u6784\u5173\u7cfb\uff0c\u80fd\u6e05\u695a\u5730\u8868\u8fbe\u548c\u5bb9\u6613\u7406\u89e3\u6574\u4e2a\u7cfb\u7edf\u3002 \u5728\u591a\u5c42\u6570\u636e\u6d41\u56fe\u4e2d\uff0c\u9876\u5c42\u6d41\u56fe\u4ec5\u5305\u542b\u4e00\u4e2a\u52a0\u5de5\uff0c\u5b83\u4ee3\u8868\u88ab\u5f00\u53d1\u7cfb\u7edf\u3002\u5b83\u7684\u8f93\u5165\u6d41\u662f\u8be5\u7cfb\u7edf\u7684\u8f93\u5165\u6570\u636e\uff0c\u8f93\u51fa\u6d41\u662f\u7cfb\u7edf\u6240\u8f93\u51fa\u6570\u636e\u3002\u9876\u5c42\u6570\u636e\u6d41\u56fe\u7684\u4f5c\u7528\u5728\u4e8e\u8868\u660e\u88ab\u5f00\u53d1\u7cfb\u7edf\u7684\u8303\u56f4\u4ee5\u53ca\u5b83\u548c\u5468\u56f4\u73af\u5883\u7684\u6570\u636e\u4ea4\u6362\u5173\u7cfb\u3002\u5bf9\u4e8e\u9876\u5c42\u6570\u636e\u6d41\u56fe\u901a\u5e38\u53ef\u4ee5\u4e0d\u8003\u8651\u6570\u636e \u5b58\u50a8\u3002 \u5e95\u5c42\u6d41\u56fe\u662f\u6307\u5176\u52a0\u5de5\u4e0d\u9700\u518d\u505a\u5206\u89e3\u7684\u6570\u636e\u6d41\u56fe\uff0c\u5b83\u5904\u5728\u6700\u5e95\u5c42\u3002 \u4e2d\u95f4\u5c42\u6d41\u56fe\u5219\u8868\u793a\u5bf9\u5176\u4e0a\u5c42\u7236\u56fe\u7684\u7ec6\u5316\u3002\u5b83\u7684\u6bcf\u4e00\u52a0\u5de5\u53ef\u80fd\u7ee7\u7eed\u7ec6\u5316\uff0c\u5f62\u6210\u5b50\u56fe\u3002 \u6570\u636e\u5b57\u5178\u5b9e\u4f8b \u6570\u636e\u6d41\u56fe\u5b9e\u4f8b \u7b2c\u56db\u7ae0 \u603b\u4f53\u8bbe\u8ba1 \u00b6 \u7406\u60f3\u6a21\u5757\u7684\u7279\u70b9\uff1a \u6bcf\u4e2a\u7406\u60f3\u6a21\u5757\u53ea\u89e3\u51b3\u4e00\u95ee\u9898\uff1b \u6bcf\u4e2a\u7406\u60f3\u6a21\u5757\u7684\u529f\u80fd\u90fd\u5e94\u8be5\u660e\u786e\uff0c\u4f7f\u4eba\u5bb9\u6613\u89e3\uff1b \u7406\u60f3\u6a21\u5757\u4e4b\u95f4\u7684\u8054\u7ed3\u5173\u7cfb\u7b80\u5355\uff0c\u5177\u6709\u72ec\u7acb\u6027\uff1b \u7531\u7406\u60f3\u6a21\u5757\u6784\u6210\u7684\u7cfb\u7edf\uff0c\u5bb9\u6613\u4f7f\u4eba\u89e3\u4e8e\u7f16\u7a0b\u6d4b \u8bd5\uff0c\u6613\u4e8e\u4fee\u6539\u548c\u7ef4\u62a4\u3002 \u975e\u76f4\u63a5\u8026\u5408 \u4e24\u4e2a\u6a21\u5757\u4e4b\u95f4\u6ca1\u6709\u76f4\u63a5\u5173\u7cfb\uff0c\u5b83\u4eec\u4e4b\u95f4\u7684\u8054\u7cfb\u5b8c\u5168\u662f\u901a\u8fc7\u4e3b \u6a21\u5757\u7684\u63a7\u5236\u548c\u8c03\u7528\u6765\u5b9e\u73b0\u7684\u3002 \u975e\u76f4\u63a5\u8026\u5408\u7684\u6a21\u5757\u72ec\u7acb\u6027\u6700\u5f3a\u3002 \u5916\u90e8\u8026\u5408 \u4e00\u7ec4\u6a21\u5757\u90fd\u8bbf\u95ee\u540c\u4e00\u5168\u5c40\u7b80\u5355\u53d8\u91cf\u800c\u4e0d\u662f\u540c\u4e00\u5168\u5c40\u6570\u636e\u7ed3\u6784\uff0c \u800c\u4e14\u4e0d\u662f\u901a\u8fc7\u53c2\u6570\u8868\u4f20\u9012\u8be5\u5168\u5c40\u53d8\u91cf\u7684\u4fe1\u606f\uff0c\u5219\u79f0\u4e4b\u4e3a\u5916\u90e8 \u8026\u5408\u3002 \u4f8b\u5982\uff1aC\u8bed\u8a00\u7a0b\u5e8f\u4e2d\u5404\u4e2a\u6a21\u5757\u90fd\u8bbf\u95ee\u88ab\u8bf4\u660e\u4e3aextern\u7c7b\u578b\u7684 \u5916\u90e8\u53d8\u91cf\u3002 \u63a7\u5236\u8026\u5408 \u63a7\u5236\u8026\u5408\u589e\u52a0\u4e86\u7406\u89e3\u548c\u7f16\u7a0b\u7684\u590d\u6742\u6027\uff0c\u8c03\u7528\u6a21\u5757\u5fc5\u987b\u77e5\u9053\u88ab \u8c03\u6a21\u5757\u7684\u5185\u90e8\u903b\u8f91\uff0c\u589e\u52a0\u4e86\u76f8\u4e92\u4f9d\u8d56\u3002\u53bb\u9664\u6a21\u5757\u95f4\u63a7\u5236\u8026\u5408\u7684\u65b9\u6cd5\uff1a\u5c06\u88ab\u8c03\u7528\u6a21\u5757\u5185\u7684\u5224\u5b9a\u4e0a\u79fb\u5230\u8c03\u7528\u6a21\u5757\u4e2d\u8fdb\u884c\uff1b\u88ab\u8c03\u7528\u6a21\u5757\u5206\u89e3\u6210\u82e5\u5e72\u5355\u4e00\u529f\u80fd\u6a21\u5757\u3002 \u516c\u5171\u8026\u5408 \u516c\u5171\u8026\u5408\u7684\u590d\u6742\u7a0b\u5ea6\u968f\u8026\u5408\u6a21\u5757\u7684\u4e2a\u6570\u589e\u52a0\u800c\u663e\u8457\u589e\u52a0\u3002\u82e5\u53ea \u662f\u4e24\u6a21\u5757\u95f4\u6709\u516c\u5171\u6570\u636e\u73af\u5883\uff0c\u5219\u516c\u5171\u8026\u5408\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u5373\u677e\u6563\u516c \u5171\u8026\u5408\u548c\u7d27\u5bc6\u516c\u5171\u8026\u5408\u3002 \u516c\u5171\u8026\u5408\u4f1a\u5f15\u8d77\u4e0b\u5217\u95ee\u9898\uff1a \u6240\u6709\u516c\u5171\u8026\u5408\u6a21\u5757\u90fd\u4e0e\u67d0\u4e00\u4e2a\u516c\u5171\u6570\u636e\u73af\u5883\u5185\u90e8\u5404\u9879\u7684\u7269\u7406\u5b89 \u6392\u6709\u5173\uff0c\u82e5\u4fee\u6539\u67d0\u4e2a\u6570\u636e\u7684\u5927\u5c0f\uff0c\u5c06\u4f1a\u5f71\u54cd\u5230\u6240\u6709\u7684\u6a21\u5757\uff1b \u65e0\u6cd5\u63a7\u5236\u5404\u4e2a\u6a21\u5757\u5bf9\u516c\u5171\u6570\u636e\u7684\u5b58\u53d6\uff0c\u4e25\u91cd\u5f71\u54cd\u8f6f\u4ef6\u6a21\u5757\u7684\u53ef\u9760\u6027\u548c\u9002\u5e94\u6027\uff1b \u516c\u5171\u6570\u636e\u540d\u7684\u4f7f\u7528\uff0c\u660e\u663e\u964d\u4f4e\u4e86\u7a0b\u5e8f\u7684\u53ef\u8bfb\u6027\u3002 \u6a21\u5757\u7684\u4f5c\u7528\u57df\u5e94\u8be5\u5728\u63a7\u5236\u57df\u4e4b\u5185\u8bbe\u8ba1\u539f\u5219 \u8bfe\u672c P100 A.\u5bf9\u4e8e\u4efb\u4f55\u4e00\u4e2a\u5185\u90e8\u5b58\u5728\u5224\u65ad\u8c03\u7528\u7684\u6a21\u5757\uff0c\u5b83\u7684\u5224\u65ad\u4f5c\u7528\u7684\u8303 \u56f4\u5e94\u8be5\u662f\u5176\u63a7\u5236\u8303\u56f4\u7684\u4e00\u4e2a\u5b50\u96c6\uff1b B.\u5b58\u5728\u5224\u65ad\u8c03\u7528\u7684\u6a21\u5757\uff0c\u6240\u5728\u5c42\u6b21\u4e0d\u8981\u4e0e\u90a3\u4e9b\u5c5e\u4e8e\u5224\u65ad\u4f5c\u7528\u8303 \u56f4\u7684\u6a21\u5757\u6240\u5728\u7684\u5c42\u6b21\u76f8\u9694\u592a\u8fdc\u3002 \u6570\u636e\u6d41\u56fe\u8f6c\u8f6f\u4ef6\u7ed3\u6784\u7b2c\u4e8c\u7ea7\u5206\u89e3\u7684\u65b9\u6cd5\u4e3e\u4f8b \u6570\u636e\u6d41\u7a0b\u56fe\u7684\u5212\u5206 \u8bfe\u672cP109 \u9762\u5411\u6570\u636e\u6d41\u8bbe\u8ba1\u5c0f\u7ed3 \u5bf9\u4e8e\u4e00\u4e2a\u5927\u7cfb\u7edf\uff0c\u5e38\u5e38\u628a\u53d8\u6362\u5206\u6790\u548c\u4e8b\u52a1\u5206\u6790\u5e94\u7528\u5230\u540c\u4e00\u4e2a\u6570 \u636e\u6d41\u56fe\u7684\u4e0d\u540c\u90e8\u5206\uff0c\u7531\u6b64\u5f97\u5230\u7684\u5b50\u7ed3\u6784\u5f62\u6210\u201c\u6784\u4ef6\u201d \uff0c\u53ef\u4ee5\u5229\u7528 \u5b83\u4eec\u6784\u9020\u5b8c\u6574\u7684\u8f6f\u4ef6\u7ed3\u6784\uff1b \u5e94\u8be5\u7075\u6d3b\u8fd0\u7528\uff0c\u5408\u5e76\u4e0d\u5fc5\u8981\u7684\u63a7\u5236\u6a21\u5757\uff0c\u5206\u89e3\u529f\u80fd\u8fc7\u5206\u590d\u6742\u7684 \u63a7\u5236\u6a21\u5757\u3002 \u7531\u4e8e\u4efb\u4f55\u8f6f\u4ef6\u7cfb\u7edf\u90fd\u53ef\u4ee5\u7528\u6570\u636e\u6d41\u56fe\u8868\u793a\uff0c\u56e0\u6b64\uff0c\u9762\u5411\u6570\u636e\u6d41 \u7684\u8bbe\u8ba1\u65b9\u6cd5\u7406\u8bba\u4e0a\u53ef\u4ee5\u8bbe\u8ba1\u4efb\u4f55\u8f6f\u4ef6\u7684\u7ed3\u6784\u3002\u901a\u5e38\u6240\u8bf4\u7684\u7ed3\u6784\u5316\u8bbe\u8ba1\u65b9\u6cd5\uff08\u7b80\u79f0SD\u65b9\u6cd5\uff09\u4e5f\u662f\u57fa\u4e8e\u6570\u636e\u6d41\u7684\u8bbe\u8ba1\u65b9\u6cd5\u3002 \u7b2c\u4e94\u7ae0 \u8be6\u7ec6\u8bbe\u8ba1 \u00b6 \u8be6\u7ec6\u8bbe\u8ba1\u9636\u6bb5\u7684\u4e3b\u8981\u4efb\u52a1 \u4e3a\u6bcf\u4e00\u6a21\u5757\u786e\u5b9a\u7b97\u6cd5\u3001\u786e\u5b9a\u6bcf\u4e00\u6a21\u5757\u4f7f\u7528\u7684\u6570\u636e\u7ed3\u6784\u3001\u786e\u5b9a\u6a21\u5757\u7684\u5916\u90e8\u63a5\u53e3\u548c\u7528\u6237\u754c\u9762\u3001\u4e3a\u6bcf\u4e00\u6a21\u5757\u8bbe\u8ba1\u4e00\u7ec4\u6d4b\u8bd5\u7528\u4f8b \u4eba\u673a\u754c\u9762\u8bbe\u8ba1\u8fc7\u7a0b \u7a0b\u5e8f\u6d41\u7a0b\u56fe\u4f7f\u7528\u4e94\u79cd\u57fa\u672c\u63a7\u5236\u7ed3\u6784 \u5411\u6570\u636e\u7ed3\u6784\u7684\u8bbe\u8ba1\u65b9\u6cd5 \u8be5\u65b9\u6cd5\u7684\u57fa\u672c\u601d\u60f3\u662f\u4f7f\u7a0b\u5e8f\u7ed3\u6784\u4e0e\u95ee\u9898\u7ed3\u6784\u76f8\u5bf9\u5e94\uff0c\u5373\u4e0e\u6570\u636e\u7ed3\u6784\u76f8\u5bf9\u5e94\u3002\u56e0\u6b64\u5b83\u6309\u8f93\u5165\u8f93\u51fa\u4ee5\u53ca\u5185\u90e8\u5b58\u50a8\u4fe1\u606f\u7684\u6570\u636e\u7ed3\u6784\u8fdb\u884c\u8bbe\u8ba1\uff0c\u628a\u6570\u636e\u7ed3\u6784\u7684\u63cf\u8ff0\u53d8\u6362\u4e3a\u5bf9\u7a0b\u5e8f\u7ed3\u6784\u7684\u63cf\u8ff0\u3002 Jackson\u65b9\u6cd5\u8bbe\u8ba1\u5b9e\u4f8b \u95ee\u9898\u63cf\u8ff0 \u67d0\u4ed3\u5e93\u5b58\u653e\u591a\u79cd\u96f6\u4ef6\uff08\u5982P1\uff0cP2\uff0c \u2026\u2026\uff09\uff0c\u6bcf\u4e2a\u96f6\u4ef6\u7684\u6bcf\u6b21 \u8fdb\u8d27\u3001\u53d1\u8d27\u90fd\u6709\u4e00\u5f20\u5361\u7247\u4f5c\u51fa\u8bb0\u5f55\uff0c\u6bcf\u6708\u6839\u636e\u8fd9\u6837\u4e00\u53e0\u5361\u7247\u6253\u5370 \u4e00\u5f20\u6708\u62a5\u8868\u3002\u62a5\u8868\u6bcf\u884c\u5217\u51fa\u67d0\u79cd\u96f6\u4ef6\u672c\u6708\u5e93\u5b58\u91cf\u7684\u51c0\u53d8\u5316\u3002\u7528JSD \u65b9\u6cd5\u5bf9\u8be5\u95ee\u9898\u8fdb\u884c\u8bbe\u8ba1\u3002 \uff083\uff09\u5bfc\u51fa\u7a0b\u5e8f\u7ed3\u6784 \u627e\u51fa\u5bf9\u5e94\u5173\u7cfb\u540e\uff0c\u6839\u636e\u4ee5\u4e0b\u89c4\u5219\u5bfc\u51fa\u7a0b\u5e8f\u7ed3\u6784\uff1a\u5bf9\u4e8e\u8f93\u5165\u6570\u636e \u7ed3\u6784\u4e0e\u8f93\u51fa\u6570\u636e\u7ed3\u6784\u4e2d\u7684\u6570\u636e\u5355\u5143\uff0c\u6bcf\u5bf9\u6709\u5bf9\u5e94 \u5173\u7cfb\u7684\u6570\u636e\u5355\u5143 \u6309\u7167\u5b83\u4eec\u6240\u5728\u7684\u5c42\u6b21\uff0c\u5728\u7a0b\u5e8f\u7ed3\u6784\u56fe\u9002\u5f53\u4f4d\u7f6e\u753b\u4e00\u4e2a\u5904\u7406\u6846\uff0c\u65e0\u5bf9\u5e94\u5173\u7cfb\u7684\u6570\u636e\u5355\u5143\uff0c\u5404\u753b\u4e00 \u4e2a\u5904\u7406\u6846\u3002 \u6839\u636e\u4ee5\u4e0a\u89c4\u5219\uff0c\u753b\u51fa\u7684\u7a0b\u5e8f\u7ed3\u6784\u56fe\u5982\u56fe\u6240\u793a\u3002 \u5728\u5206\u914d\u64cd\u4f5c\u65f6\u6ce8\u610f\uff1a\u4e3a\u4e86\u80fd\u83b7\u5f97\u91cd\u590d\u548c\u9009\u62e9\u7684\u6761\u4ef6\uff0cJackson \u5efa\u8bae\u81f3\u5c11\u8d85\u524d\u8bfb\u4e00\u4e2a\u8bb0\u5f55\uff0c\u4ee5\u4fbf\u4f7f\u5f97\u7a0b\u5e8f\u4e0d\u8bba\u5728\u4ec0\u4e48\u65f6\u5019\u5224\u5b9a\uff0c \u603b\u6709\u6570\u636e\u5df2\u7ecf\u8bfb\u5165\uff0c\u5e76\u505a\u597d\u4f7f\u7528\u51c6\u5907\u3002\u56e0\u6b64\u5728\u56fe\u4e2d\uff0c\u5c06\u64cd\u4f5cE\uff08\u8bfb \u4e00\u5f20\u5361\uff09\u653e\u5728\u6253\u5f00\u6587\u4ef6\u4e4b\u540e\uff0c\u540c\u65f6\u5728\u5904\u7406\u5b8c\u4e00\u5f20\u5361\u7247\u540e\u518d\u8bfb\u4e00\u6b21\u3002 (5) \u7528\u4f2a\u7801\u5199\u51fa\u7a0b\u5e8f Jackson\u65b9\u6cd5\u4e2d\u7684\u4f2a\u7801\u4e0eJackson\u6240\u793a\u7684\u7a0b\u5e8f\u7ed3\u6784\u56fe\u5b8c\u5168\u5bf9\u5e94\uff0c\u7528 \u4f2a\u7801\u5199\u51fa\u7a0b\u5e8f\u7684\u8fc7\u7a0b\uff0c\u5b9e\u9645\u4e0a\u5c31\u662f\u81ea\u9876\u5411\u4e0b\u7528\u8fd9\u4e9b\u4f2a\u7801\u66ff\u6362 Jackson\u56fe\u4e2d\u6bcf\u4e2a\u5904\u7406\u6846\u7684\u8fc7\u7a0b\uff0c\u6bcf\u4e2a\u5904\u7406\u6846\u90fd\u770b\u4f5c\u662f\u4e0b\u5c42\u5904\u7406\u6846 \u53ca\u5206\u914d\u5728\u4e0a\u9762\u7684\u64cd\u4f5c\u7ec4\u6210\u3002 Jackson\u65b9\u6cd5\u5c0f\u7ed3 \u4f18\u70b9\uff1a\u7b80\u5355\uff0c\u9002\u5408\u4e8e\u89c4\u6a21\u4e0d\u5927\u7684\u7cfb\u7edf\uff0c\u5efa\u7acb\u4e86\u95ee\u9898\u7684\u6570\u636e\u7ed3\u6784 \u4e4b\u540e\uff0c\u53ef\u76f4\u63a5\u63a8\u5bfc\u51fa\u76f8\u5e94\u7684\u7a0b\u5e8f\u7ed3\u6784\u3002 \u5c40\u9650\u6027\uff1a\u5f53\u8f93\u5165\u6570\u636e\u7ed3\u6784\u4e0e\u8f93\u51fa\u6570\u636e\u7ed3\u6784\u4e0d\u76f8\u540c\u4e14\u65e0\u5bf9\u5e94\u5173\u7cfb \u65f6\uff0c\u96be\u4e8e\u5e94\u7528\u3002\u5f53\u6570\u636e\u7ed3\u6784\u53d1\u751f\u53d8\u5316\u65f6\uff0c\u7a0b\u5e8f\u7ed3\u6784\u4e5f\u53d1\u751f\u53d8\u5316\uff0c\u4e00 \u822c\u662f\u603b\u4f53\u4e0a\u7528SD\u65b9\u6cd5\uff0c\u5c40\u90e8\u8303\u56f4\u7528JSD\u65b9\u6cd5\u3002 SD\u65b9\u6cd5\u548cJSD\u65b9\u6cd5\u7684\u5f02\u540c\uff1a\u9762\u5411\u6570\u636e\u6d41\u7684\u8bbe\u8ba1\uff08SD\u65b9\u6cd5\uff09\u548c\u9762\u5411\u6570\u636e\u7ed3\u6784\u7684\u8bbe\u8ba1\uff08JSD\u65b9\u6cd5\uff09 \u7684\u5171\u540c\u70b9\u90fd\u662f\u6570\u636e\u4fe1\u606f\u9a71\u52a8\u7684\uff0c\u90fd\u8bd5\u56fe\u5c06\u6570\u636e\u8868\u793a\u8f6c\u6362\u6210\u8f6f\u4ef6\u8868\u793a\uff1b \u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u9762\u5411\u6570\u636e\u7ed3\u6784\u7684\u8bbe\u8ba1\u4e0d\u5229\u7528\u6570\u636e\u6d41\u56fe\uff0c\u800c\u6839\u636e\u6570\u636e\u7ed3 \u6784\u7684\u8868\u793a\u6765\u8bbe\u8ba1\u3002 Halstead\u4f30\u8ba1\u590d\u6742\u5ea6\u65b9\u6cd5 \u8bfe\u672c P139 \u5728\u5b9a\u4e49\u4e2d\uff0c\u8fd0\u7b97\u7b26\u5305\u62ec\uff1a \u7b97\u672f\u8fd0\u7b97\u7b26\u3001\u8d4b\u503c\u7b26(=\u6216:=)\u3001\u903b\u8f91\u8fd0\u7b97\u7b26\u3001\u5206\u754c\u7b26(\uff0c\u6216\uff1b\u6216:) \u3001\u5173\u7cfb\u8fd0\u7b97\u7b26\u3001 \u62ec\u53f7\u8fd0\u7b97\u7b26\u3001\u5b50\u7a0b\u5e8f\u8c03\u7528\u7b26\u3001\u6570\u7ec4\u64cd\u4f5c\u7b26\u3001\u5faa\u73af\u64cd\u4f5c\u7b26\u7b49\uff1b \u7279\u522b\u5730\uff0c\u6210\u5bf9\u7684\u8fd0\u7b97\u7b26\uff0c\u4f8b\u5982 begin\u2026end\u3001if\u2026then\u2026else\u3001for\u2026to\u3001repeat \u2026until\u3001while\u2026do\u3001\uff08\u2026\uff09\u7b49 \u90fd\u5f53\u505a\u5355\u4e00\u8fd0\u7b97\u7b26\u3002 \u8fd0\u7b97\u5bf9\u8c61\u5305\u62ec\u53d8\u91cf\u540d\u548c\u5e38\u6570\u3002 \u7b2c\u516d\u7ae0 \u7cfb\u7edf\u5b9e\u73b0 \u00b6 \u8f6f\u4ef6\u6d4b\u8bd5\u7684\u57fa\u672c\u539f\u5219 \u5c3d\u91cf\u4e0d\u7531\u7a0b\u5e8f\u8bbe\u8ba1\u8005\u8fdb\u884c\u6d4b\u8bd5 \u5173\u952e\u662f\u6ce8\u91cd\u6d4b\u8bd5\u7528\u4f8b\u7684\u9009\u62e9 \u8f93\u5165\u6570\u636e\u7684\u7ec4\u6210\uff08\u8f93\u5165\u6570\u636e\u3001\u9884\u671f\u7684\u8f93\u51fa\u7ed3\u679c\uff09\u3001\u65e2\u6709\u5408\u7406\u8f93\u5165\u6570\u636e\uff0c\u4e5f\u6709\u4e0d\u5408\u7406\u7684\u8f93\u5165\u6570\u636e\u3001\u7528\u4f8b\u65e2\u80fd\u68c0\u67e5\u5e94\u5b8c\u6210\u7684\u4efb\u52a1\uff0c\u4e5f\u80fd\u591f\u68c0\u67e5\u4e0d\u5e94\u8be5\u5b8c\u6210\u7684\u4efb \u52a1\u3001\u957f\u671f\u4fdd\u5b58\u6d4b\u8bd5\u7528\u4f8b\u3002 \u6240\u6709\u7684\u6d4b\u8bd5\u90fd\u5e94\u5f53\u8ffd\u6eaf\u5230\u7528\u6237\u8981\u6c42\uff0c\u5bfc\u81f4\u7a0b\u5e8f\u4e0d\u80fd\u6ee1\u8db3\u7528\u6237 \u8981\u6c42\u7684\u9519\u8bef\u662f\u4e25\u91cd\u9519\u8bef \u5145\u5206\u6ce8\u610f\u6d4b\u8bd5\u4e2d\u7684\u7fa4\u96c6\u73b0\u8c61 \u6d4b\u8bd5\u53d1\u73b0\u7684\u9519\u8bef\u4e2d\u768480%\u5f88\u53ef\u80fd\u51fa\u81ea20%\u7684\u6a21\u5757 \u59a5\u5584\u4fdd\u5b58\u6d4b\u8bd5\u8ba1\u5212\u3001\u6d4b\u8bd5\u7528\u4f8b\u3001\u51fa\u9519\u7edf\u8ba1\u548c\u6700\u7ec8\u5206\u6790\u62a5\u544a\uff0c \u4e3a\u7ef4\u62a4\u63d0\u4f9b\u65b9\u4fbf \u8f6f\u4ef6\u6d4b\u8bd5\u6b65\u9aa4\u53ca\u7b56\u7565 \u786e\u8ba4\u6d4b\u8bd5 \u786e\u8ba4\u6d4b\u8bd5\u6b65\u9aa4 \u6709\u6548\u6027\u6d4b\u8bd5 \u5236\u5b9a\u6d4b\u8bd5\u8ba1\u5212\u548c\u6d4b\u8bd5\u8fc7\u7a0b\uff0c\u8fd0\u7528\u9ed1\u76d2\u6cd5\uff0c\u9a8c\u8bc1\u8f6f\u4ef6\u7279\u6027\u662f\u5426\u4e0e \u9700\u6c42\u7b26\u5408\u3002 \u8f6f\u4ef6\u914d\u7f6e\u590d\u67e5 \u8f6f\u4ef6\u914d\u7f6e\u662f\u6307\u8f6f\u4ef6\u5de5\u7a0b\u8fc7\u7a0b\u4e2d\u6240\u4ea7\u751f\u7684\u6240\u6709\u4fe1\u606f\u9879:\u6587\u6863\u3001\u62a5\u544a\u3001 \u7a0b\u5e8f\u3001\u8868\u683c\u3001\u6570\u636e\u3002\u968f\u7740\u8f6f\u4ef6\u5de5\u7a0b\u8fc7\u7a0b\u7684\u8fdb\u5c55\u8f6f\u4ef6\u914d\u7f6e\u9879\u5feb\u901f\u589e \u52a0\u548c\u53d8\u5316\uff0c\u5e94\u590d\u67e5\u8f6f\u4ef6\u914d\u7f6e\u9879\u662f\u5426\u9f50\u5168\u3001\u4e00\u81f4\u3002 \u8f6f\u4ef6\u6d4b\u8bd5\u5e73\u884c\u8fd0\u884c \u6240\u8c13\u5e73\u884c\u8fd0\u884c\u5c31\u662f\u540c\u65f6\u8fd0\u884c\u65b0\u5f00\u53d1\u51fa\u6765\u7684\u7cfb\u7edf\u548c\u5c06\u88ab\u5b83\u53d6\u4ee3\u7684 \u65e7\u7cfb\u7edf\uff0c\u4ee5\u4fbf\u6bd4\u8f83\u65b0\u65e7\u4e24\u4e2a\u7cfb\u7edf\u7684\u5904\u7406\u7ed3\u679c\u3002\u8fd9\u6837\u505a\u7684\u5177\u4f53\u76ee\u7684 \u6709\u5982\u4e0b\u51e0\u70b9\uff1a \u53ef\u4ee5\u5728\u51c6\u751f\u4ea7\u73af\u5883\u4e2d\u8fd0\u884c\u65b0\u7cfb\u7edf\u800c\u53c8\u4e0d\u5192\u98ce\u9669\uff1b \u7528\u6237\u80fd\u6709\u4e00\u6bb5\u719f\u6089\u65b0\u7cfb\u7edf\u7684\u65f6\u95f4\uff1b \u53ef\u4ee5\u9a8c\u8bc1\u7528\u6237\u6307\u5357\u548c\u4f7f\u7528\u624b\u518c\u4e4b\u7c7b\u7684\u6587\u6863\uff1b \u80fd\u591f\u4ee5\u51c6\u751f\u4ea7\u6a21\u5f0f\u5bf9\u65b0\u7cfb\u7edf\u8fdb\u884c\u5168\u8d1f\u8377\u6d4b\u8bd5\uff0c\u53ef\u4ee5\u7528\u6d4b\u8bd5\u7ed3\u679c\u9a8c\u8bc1\u6027\u80fd\u6307\u6807\u3002 \u5982\u4f55\u6d4b\u8bd5 \u5173\u952e ---- \u8bbe\u8ba1\u6d4b\u8bd5\u65b9\u6848\u3002 \u6d4b\u8bd5\u65b9\u6848 ---- \u5305\u62ec\uff1a\u5177\u4f53\u7684\u6d4b\u8bd5\u76ee\u7684\uff0c\u5e94\u8be5\u8f93\u5165\u7684\u6d4b\u8bd5\u6570\u636e\u548c\u9884\u671f\u7684\u7ed3\u679c\u3002 \u901a\u5e38\u53c8\u628a\u6d4b\u8bd5\u6570\u636e\u548c\u9884\u671f\u7684\u8f93\u51fa\u7ed3\u679c\u79f0\u4e3a\u6d4b\u8bd5\u7528\u4f8b\u3002\u5176\u4e2d\u6700\u56f0\u96be\u7684\u95ee\u9898\u662f\u8bbe\u8ba1\u6d4b\u8bd5\u7528\u7684\u8f93\u5165\u6570\u636e\u3002 \u4e0d\u540c\u7684\u6d4b\u8bd5\u6570\u636e\u53d1\u73b0\u7a0b\u5e8f\u9519\u8bef\u7684\u80fd\u529b\u5dee\u522b\u5f88\u5927\uff0c\u4e3a\u4e86\u63d0\u9ad8\u6d4b\u8bd5\u6548\u7387\u964d\u4f4e\u6d4b\u8bd5\u6210\u672c\uff0c\u5e94\u8be5\u9009\u7528\u9ad8\u6548\u7684\u6d4b\u8bd5\u6570\u636e\u3002 \u767d\u76d2\u6d4b\u8bd5\u6b65\u9aa4 \u9009\u62e9\u903b\u8f91\u8986\u76d6\u6807\u51c6\uff1b\u6309\u7167\u8986\u76d6\u6807\u51c6\u5217\u51fa\u6240\u6709\u60c5\u51b5\uff1b \u9009\u62e9\u786e\u5b9a\u6d4b\u8bd5\u7528\u4f8b\uff1b \u9a8c\u8bc1\u5206\u6790\u8fd0\u884c\u7ed3\u679c\u4e0e\u9884\u671f\u7ed3\u679c\u3002 \u5b9e\u9645\u6d4b\u8bd5\u7b56\u7565 \u9ed1\u76d2+\u767d\u76d2\u6d4b\u8bd5 \uf06c \u5728\u4efb\u4f55\u60c5\u51b5\u4e0b\uff0c\u90fd\u5e94\u4f7f\u7528\u8fb9\u754c\u503c\u5206\u6790\u65b9\u6cd5\uff1b \uf06c \u5fc5\u8981\u65f6\u7528\u7b49\u4ef7\u5212\u5206\u6cd5\u8865\u5145\u6d4b\u8bd5\u7528\u4f8b\uff1b \uf06c \u5fc5\u8981\u65f6\u518d\u7528\u9519\u8bef\u63a8\u6d4b\u6cd5\u8865\u5145\u6d4b\u8bd5\u7528\u4f8b\uff1b \uf06c \u5bf9\u7167\u7ec4\u4ef6\u7684\u903b\u8f91\uff0c\u68c0\u67e5\u5df2\u8bbe\u8ba1\u51fa\u7684\u6d4b\u8bd5\u7528\u4f8b\u3002 \u767d\u76d2\u6d4b\u8bd5\u4e0e\u9ed1\u76d2\u6d4b\u8bd5\u5bf9\u6bd4 \u8f6f\u4ef6\u8c03\u8bd5\u539f\u5219 1.\u6ce8\u610f\u9519\u8bef\u7684\u201c\u7fa4\u96c6\u73b0\u8c61\u201d\uff1b 2.\u4e0d\u80fd\u53ea\u4fee\u6539\u9519\u8bef\u7684\u5f81\u5146\u3001\u8868\u73b0\u3002\u8fd8\u5e94\u8be5\u4fee\u6539\u9519\u8bef\u7684\u672c\u8d28\uff1b 3.\u6ce8\u610f\u5728\u4fee\u6539\u4e00\u4e2a\u9519\u8bef\u7684\u540c\u65f6\uff0c\u4e0d\u8981\u5f15\u5165\u65b0\u7684\u9519\u8bef\u3002 \u8f6f\u4ef6\u53ef\u9760\u6027\u8ba1\u7b97\u4f8b\u9898 MTTF \u7b2c\u4e03\u7ae0 \u8f6f\u4ef6\u7ef4\u62a4 \u00b6 \u63d0\u9ad8\u53ef\u7ef4\u62a4\u6027\u7684\u65b9\u6cd5 \u5efa\u7acb\u660e\u786e\u7684\u8f6f\u4ef6\u8d28\u91cf\u76ee\u6807\u548c\u4f18\u5148\u7ea7 \u4f7f\u7528\u63d0\u9ad8\u8f6f\u4ef6\u8d28\u91cf\u7684\u6280\u672f\u548c\u5de5\u5177 \u8fdb\u884c\u660e\u786e\u7684\u8d28\u91cf\u4fdd\u8bc1\u5ba1\u67e5 \u9009\u62e9\u53ef\u7ef4\u62a4\u7684\u7a0b\u5e8f\u8bbe\u8ba1\u8bed\u8a00 \u6539\u8fdb\u7a0b\u5e8f\u7684\u6587\u6863 \u8f6f\u4ef6\u518d\u5de5\u7a0b \u8f6f\u4ef6\u518d\u5de5\u7a0b\u662f\u4e00\u7c7b\u8f6f \u4ef6\u5de5\u7a0b\u6d3b\u52a8\uff0c\u662f\u4e00\u4e2a \u5de5\u7a0b\u8fc7\u7a0b, \u5b83\u5c06\u9006\u5411 \u5de5\u7a0b\u3001\u91cd\u6784\u548c\u6b63\u5411\u5de5 \u7a0b\u7ec4\u5408\u8d77\u6765,\u5c06\u73b0\u5b58\u7cfb \u7edf\u91cd\u65b0\u6784\u9020\u4e3a\u65b0\u7684\u5f62 \u5f0f\u3002 \u7b2c\u4e5d\u7ae0 \u9762\u5411\u5bf9\u8c61\u5206\u6790\u8bbe\u8ba1\u4e0e\u5b9e\u73b0 \u00b6 \u8f6f\u4ef6\u751f\u5b58\u671f\u5404\u9636\u6bb5\u6240\u4f7f\u7528\u7684\u65b9\u6cd5\u3001\u6280\u672f\u5177\u6709\u9ad8\u5ea6\u7684\u8fde\u7eed\u6027\uff0c\u7528 \u7b26\u5408\u4eba\u7c7b\u8ba4\u8bc6\u4e16\u754c\u7684\u601d\u7ef4\u65b9\u5f0f\u6765\u5206\u6790\u3001\u89e3\u51b3\u95ee\u9898\u3002\u5c06OOA\u3001OOD\u3001 OOP\u6709\u673a\u5730\u96c6\u6210\u5728\u4e00\u8d77\u3002 \u9762\u5411\u5bf9\u8c61\u7684\u5206\u6790\uff08Object-Oriented Analysis\uff0cOOA \uff09 \u5f3a\u8c03\u7684\u662f\u5bf9\u4e00\u4e2a\u7cfb\u7edf\u4e2d\u7684\u5bf9\u8c61\u7279\u5f81\u548c\u884c\u4e3a\u7684\u5b9a\u4e49\u3002\u5efa\u7acb\u7cfb\u7edf\u7684 \u4e09\u7c7b\u6a21\u578b\u3002 \u9762\u5411\u5bf9\u8c61\u7684\u8bbe\u8ba1\uff08Object-Oriented Design\uff0cOOD\uff09 \u4e0eOOA\u5bc6\u5207\u914d\u5408\uff0c\u987a\u5e8f\u5b9e\u73b0\u5bf9\u73b0\u5b9e\u4e16\u754c\u7684\u8fdb\u4e00\u6b65\u5efa\u6a21\u3002 \u9762\u5411\u5bf9\u8c61\u7684\u7f16\u7a0b\uff08Object-Oriented Program\uff0cOOP \uff09 \u662f\u9762\u5411\u5bf9\u8c61\u7684\u6280\u672f\u4e2d\u53d1\u5c55\u6700\u5feb\u7684\uff0c\u4f7f\u7528\u9762\u5411\u5bf9\u8c61\u7684\u7a0b\u5e8f\u8bbe\u8ba1\u8bed \u8a00\uff0c\u8fdb\u884c\u7f16\u7801\u3002 \u7b2c\u5341\u7ae0 \u8f6f\u4ef6\u9879\u76ee\u7ba1\u7406 \u00b6 \u9879\u76ee\u5177\u6709\u7684\u57fa\u672c\u7279\u6027 \u9879\u76ee\u7684\u4e00\u6b21\u6027 \u9879\u76ee\u7684\u7ec4\u7ec7\u6027 \u9879\u76ee\u7684\u751f\u547d\u671f \u9879\u76ee\u7684\u8d44\u6e90\u6d88\u8017\u6027 \u9879\u76ee\u540e\u679c\u7684\u4e0d\u786e\u5b9a\u6027 \u9879\u76ee\u7684\u76ee\u6807\u51b2\u7a81\u6027 \u9879\u76ee\u7ba1\u7406 \u5728\u9879\u76ee\u6d3b\u52a8\u4e2d\u8fd0\u7528\u4e00\u7cfb\u5217\u7684\u77e5\u8bc6\u3001\u6280\u80fd\u3001\u5de5\u5177\u548c\u6280\u672f\uff0c\u4ee5\u6ee1\u8db3 \u6216\u8d85\u8fc7\u76f8\u5173\u5229\u76ca\u8005\u5bf9\u9879\u76ee\u7684\u8981\u6c42\u3002\uff08PMI\uff09 \u8f6f\u4ef6\u9879\u76ee\u7ba1\u7406 \u8f6f\u4ef6\u9879\u76ee\u662f\u6307\u5bf9\u8f6f\u4ef6\u7cfb\u7edf\u8fdb\u884c\u5f00\u53d1\u3001\u96c6\u6210\u548c\u670d\u52a1\u4e3a\u4e3b\u8981\u76ee\u7684\u7684 \u9879\u76ee\u3002\u8f6f\u4ef6\u9879\u76ee\u7ba1\u7406\u548c\u5176\u4ed6\u9879\u76ee\u7ba1\u7406\u76f8\u6bd4\uff0c\u5177\u6709\u5f88\u5927\u7684\u72ec\u7279\u6027\uff1a \u8f6f\u4ef6\u9879\u76ee\u7ba1\u7406\u5c1a\u4e0d\u89c4\u8303\uff0c\u7ecf\u9a8c\u6210\u5206\u660e\u663e\uff1b \u8fc7\u7a0b\u6ca1\u6709\u660e\u663e\u7684\u5212\u5206\uff1b \u5927\u90fd\u662f\u201c\u4e00\u6b21\u6027\u201d\u7684\u4eba\u529b\u6d88\u8017\u578b\u9879\u76ee \u7518\u7279\u56fe \u7518\u7279\u56fe\u4e5f\u79f0\u4e3a\u6761\u578b\u56fe\uff0c\u6216\u6a2a\u9053\u56fe\u3002\u5b83\u4ee5\u6a2a\u5750\u6807\u8868\u793a\u65f6\u95f4\uff0c\u5de5\u7a0b \u6d3b\u52a8\u5728\u56fe\u7684\u5de6\u4fa7\u7eb5\u5411\u6392\u5217\uff0c\u4ee5\u6d3b\u52a8\u6240\u5bf9\u5e94\u7684\u6a2a\u9053\u4f4d\u7f6e\u8868\u793a\u6d3b\u52a8\u7684 \u8d77\u59cb\u65f6\u95f4\uff0c\u6a2a\u9053\u7684\u957f\u77ed\u8868\u793a\u6301\u7eed\u65f6\u95f4\u7684\u957f\u77ed\u3002\u5b83\u662f\u4e00\u79cd\u6bd4\u8f83\u7b80\u4fbf \u7684\u5de5\u671f\u8ba1\u5212\u548c\u8fdb\u5ea6\u5b89\u6392\u5de5\u5177\u3002 \u5173\u952e\u8def\u5f84\u6cd5 \u5bf9\u5173\u952e\u8def\u5f84\u7684\u8ba1\u7b97\u4e0e\u8c03\u6574\u4f18\u5316 \u6e05\u9192\u7684\u8ba4\u8bc6\uff1a\u5173\u952e\u8def\u5f84\u662f\u7f51\u7edc\u56fe\u4e2d\u6700\u957f\u7684\u7ebf\u8def\uff0c\u5b83\u51b3\u5b9a\u4e86\u9879 \u76ee\u7684\u603b\u8017\u65f6\u3002 \u5fc5\u987b\u628a\u6ce8\u610f\u529b\u96c6\u4e2d\u4e8e\u90a3\u4e9b\u4f18\u5148\u7b49\u5f85\u5b8c\u6210\u7684\u4efb\u52a1\uff0c\u786e\u4fdd\u5b83\u4eec\u51c6 \u65f6\u5b8c\u6210\u3002\u5173\u952e\u8def\u5f84\u4e0a\u7684\u63a8\u8fdf\u5373\u662f\u6574\u4e2a\u9879\u76ee\u63a8\u8fdf\u3002 \u5411\u5173\u952e\u8def\u5f84\u8981\u65f6\u95f4\uff0c\u5411\u975e\u5173\u952e\u8def\u5f84\u8981\u8d44\u6e90\u3002 \u8c03\u6574\u8fdb\u5ea6\uff0c\u5e73\u8861\u8d44\u6e90\u3002 \u80fd\u529b\u6210\u719f\u5ea6\u6a21\u578b \u26ab \u521d\u59cb\u7ea7 \u2713 \u7ec4\u7ec7\uff1a\u7ec4\u7ec7\u901a\u5e38\u6ca1\u6709\u63d0\u4f9b\u5f00\u53d1\u548c\u7ef4\u62a4\u8f6f\u4ef6\u7684\u7a33\u5b9a\u7684\u73af\u5883\u3002 \u2713 \u9879\u76ee\uff1a\u5f53\u53d1\u751f\u5371\u673a\u65f6\uff0c\u9879\u76ee\u901a\u5e38\u653e\u5f03\u8ba1\u5212\u7684\u8fc7\u7a0b\uff0c\u56de\u590d\u5230\u7f16\u7801\u548c\u6d4b\u8bd5\u3002 \u2713 \u8fc7\u7a0b\u80fd\u529b\uff1a\u4e0d\u53ef\u9884\u6d4b\u3002(unpredictable) \u26ab \u53ef\u91cd\u590d\u7ea7 \u2713 \u7ec4\u7ec7\uff1a\u5c06\u8f6f\u4ef6\u9879\u76ee\u7684\u6709\u6548\u7ba1\u7406\u8fc7\u7a0b\u5236\u5ea6\u5316\uff0c\u8fd9\u4f7f\u5f97\u7ec4\u7ec7\u80fd\u591f\u91cd\u590d\u4ee5\u524d\u9879 \u76ee\u4e2d\u7684\u6210\u529f\u5b9e\u8df5\u3002 \u2713 \u9879\u76ee\uff1a\u914d\u5907\u4e86\u57fa\u672c\u7684\u8f6f\u4ef6\u7ba1\u7406\u63a7\u5236\u3002 \u2713 \u8fc7\u7a0b\u80fd\u529b\uff1a\u4e25\u683c\u7684\u3002(disciplined) \u26ab \u5df2\u5b9a\u4e49\u7ea7 \u2713 \u7ec4\u7ec7\uff1a\u5728\u7ec4\u7ec7\u8303\u56f4\u5185\u5f00\u53d1\u548c\u7ef4\u62a4\u8f6f\u4ef6\u7684\u6807\u51c6\u8fc7\u7a0b\u88ab\u6587\u6863\u5316\uff0c\u5176\u4e2d\u5305\u62ec\u8f6f \u4ef6\u5de5\u7a0b\u8fc7\u7a0b\u548c\u7ba1\u7406\u8fc7\u7a0b\uff0c\u5b83\u4eec\u96c6\u6210\u4e3a\u4e00\u4e2a\u4e00\u81f4\u7684\u6574\u4f53\u3002 \u2713 \u9879\u76ee\uff1a\u5bf9\u7ec4\u7ec7\u7684\u6807\u51c6\u8f6f\u4ef6\u8fc7\u7a0b\u8fdb\u884c\u88c1\u526a\uff0c\u6765\u5f00\u53d1\u5b83\u4eec\u81ea\u5df1\u7684\u5b9a\u4e49\u8f6f\u4ef6\u8fc7 \u7a0b\u3002 \u2713 \u8fc7\u7a0b\u80fd\u529b\uff1a\u6807\u51c6\u7684\u548c\u4e00\u81f4\u7684\u3002(standard and consistent) \u26ab \u5df2\u7ba1\u7406\u7ea7 \u2713 \u7ec4\u7ec7\uff1a\u4e3a\u8f6f\u4ef6\u4ea7\u54c1\u548c\u8fc7\u7a0b\u90fd\u8bbe\u5b9a\u4e86\u91cf\u5316\u7684\u8d28\u91cf\u76ee\u6807\u3002 \u2713 \u9879\u76ee\uff1a\u9879\u76ee\u51cf\u5c0f\u8fc7\u7a0b\u6027\u80fd\u7684\u53d8\u5316\u6027\uff0c\u4f7f\u5176\u8fdb\u5165\u53ef\u63a5\u6536\u7684\u91cf\u5316\u8fb9\u754c\uff0c\u4ece\u800c \u8fbe\u5230\u5bf9\u4ea7\u54c1\u548c\u8fc7\u7a0b\u7684\u63a7\u5236\u3002 \u2713 \u8fc7\u7a0b\u80fd\u529b\uff1a\u53ef\u9884\u8a00\u7684\u3002(predictable) \u26ab \u6301\u7eed\u4f18\u5316\u7ea7 \u2713 \u7ec4\u7ec7\uff1a\u5173\u6ce8\u4e8e\u6301\u7eed\u7684\u8fc7\u7a0b\u6539\u8fdb\u3002 \u2713 \u9879\u76ee\uff1a\u8f6f\u4ef6\u8fc7\u7a0b\u88ab\u8bc4\u4ef7\uff0c\u4ee5\u9632\u6b62\u8fc7\u5931\u91cd\u590d\u53d1\u751f\uff0c\u4ece\u4e2d\u83b7\u5f97\u7684\u6559\u8bad\u6563\u5e03\u7ed9 \u5176\u5b83\u9879\u76ee\u3002 \u2713 \u8fc7\u7a0b\u80fd\u529b\uff1a\u6301\u7eed\u7684\u6539\u5584\u3002(continuously improving)","title":"\u8f6f\u4ef6\u5de5\u7a0b"},{"location":"course/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#_1","text":"","title":"\u8f6f\u4ef6\u5de5\u7a0b\u590d\u4e60"},{"location":"course/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#_2","text":"\u8f6f\u4ef6\u5b9a\u4e49 Software = Program + Data + Document \u8f6f\u4ef6(software)\u662f\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d\u4e0e\u786c\u4ef6(hardware)\u76f8\u4e92\u4f9d\u5b58\u7684\uff0c\u53e6\u4e00\u90e8\u5206\uff0c\u5b83\u5305\u62ec\u7a0b\u5e8f(program)\u3001\u76f8\u5173\u6570\u636e(data)\u53ca\u5176\u8bf4\u660e\u6587\u6863 (document)\u3002 \u7a0b\u5e8f\uff1a\u662f\u6309\u4e8b\u5148\u8bbe\u8ba1\u7684\u529f\u80fd\u548c\u6027\u80fd\u8981\u6c42\u6267\u884c\u7684\u6307\u4ee4\u5e8f\u5217\uff1b \u6570\u636e\uff1a\u662f\u4f7f\u7a0b\u5e8f\u80fd\u6b63\u5e38\u64cd\u7eb5\u4fe1\u606f\u7684\u6570\u636e\u7ed3\u6784\uff1b \u6587\u6863\uff1a\u662f\u4e0e\u7a0b\u5e8f\u5f00\u53d1\u3001\u7ef4\u62a4\u548c\u4f7f\u7528\u6709\u5173\u7684\u56fe\u6587\u6750\u6599\u3002 \u8f6f\u4ef6\u7684\u7279\u70b9 \u8f6f\u4ef6\u662f\u4e00\u79cd\u903b\u8f91\u5b9e\u4f53\uff0c\u5177\u6709\u62bd\u8c61\u6027\uff1b \u8f6f\u4ef6\u662f\u5f00\u53d1\u7684\uff0c\u800c\u4e0d\u662f\u5236\u9020\u7684\uff1b \u5728\u8f6f\u4ef6\u7684\u8fd0\u884c\u548c\u4f7f\u7528\u671f\u95f4\uff0c\u6ca1\u6709\u786c\u4ef6\u90a3\u6837\u7684\u673a\u68b0\u78e8\u635f\uff0c\u8001\u5316\u95ee\u9898; \u8f6f\u4ef6\u7684\u5f00\u53d1\u81f3\u4eca\u5c1a\u672a\u5b8c\u5168\u6446\u8131\u624b\u5de5\u4f5c\u574a\u5f0f\u7684\u5f00\u53d1\u65b9\u5f0f\uff0c\u751f\u4ea7\u6548\u7387\u4f4e\uff1b \u8f6f\u4ef6\u5177\u6709\u590d\u6742\u6027\uff1b \u8f6f\u4ef6\u7684\u6210\u672c\u76f8\u5f53\u6602\u8d35\uff1b \u8f6f\u4ef6\u5bf9\u786c\u4ef6\u548c\u73af\u5883\u6709\u7740\u4e0d\u540c\u7a0b\u5ea6\u7684\u4f9d\u8d56\u6027\uff1b \u8f6f\u4ef6\u5de5\u4f5c\u7275\u6d89\u5230\u5f88\u591a\u793e\u4f1a\u56e0\u7d20\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u4e09\u8981\u7d20 \u8f6f\u4ef6\u5de5\u7a0b\u7684\u65b9\u6cd5\uff1a\u4e3a\u8f6f\u4ef6\u5f00\u53d1\u63d0\u4f9b\u201c\u5982\u4f55\u505a\u201d\u7684\u6280\u672f\uff0c\u5f53\u524d\u6709\u4f20\u7edf\u7684\u8f6f\u4ef6\u5f00\u53d1\u65b9\u6cd5\u548c\u9762\u5411\u5bf9\u8c61\u7684\u8f6f\u4ef6\u5f00 \u53d1\u65b9\u6cd5\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u7684\u8fc7\u7a0b\uff1a\u662f\u7ba1\u7406\u548c\u63a7\u5236\u4ea7\u54c1\u8d28\u91cf\u7684\u5173\u952e\uff0c\u5b9e\u73b0\u5728\u89c4\u5b9a\u7684\u65f6\u95f4\u548c\u9884\u7b97\u5185\u5f00\u53d1\u9ad8\u8d28\u91cf\u8f6f\u4ef6\u7684\u76ee\u6807\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u7684\u5de5\u5177\uff1a\u4e3a\u8f6f\u4ef6\u5de5\u7a0b\u65b9\u6cd5 \u63d0\u4f9b\u4e86\u81ea\u52a8\u7684\u6216\u534a\u81ea\u52a8\u7684\u8f6f\u4ef6\u652f\u6491 \u73af\u5883\uff0c\u8f85\u52a9\u8f6f\u4ef6\u5f00\u53d1\u4efb\u52a1\u7684\u5b8c\u6210\u3002 CASE \u8f6f\u4ef6\u5de5\u7a0b\u5c42\u6b21\uff1a\u8d28\u91cf\u7126\u70b9>\u8fc7\u7a0b>\u65b9\u6cd5>\u5de5\u5177 \u55b7\u6cc9\u6a21\u578b \u55b7\u6cc9\u6a21\u578b\u662f\u4e00\u79cd\u4ee5\u7528\u6237\u9700\u6c42\u4e3a\u52a8\u529b\uff0c \u4ee5\u5bf9\u8c61\u4e3a\u9a71\u52a8\u7684\u6a21\u578b\uff0c\u4e3b\u8981\u7528\u4e8e\u63cf\u8ff0\u9762\u5411\u5bf9\u8c61\u7684\u8f6f\u4ef6\u5f00\u53d1\u8fc7\u7a0b\u3002 \u8f6f\u4ef6\u5f00\u53d1\u8fc7\u7a0b\u81ea\u4e0b\u800c\u4e0a\u5468\u671f\u7684\u5404\u9636\u6bb5\u662f\u76f8\u4e92\u91cd\u53e0\u548c\u591a\u6b21\u53cd\u590d\u7684\uff0c\u5c31\u50cf\u6c34\u55b7\u4e0a\u53bb\u53c8\u53ef\u4ee5\u843d\u4e0b\u6765\uff0c\u7c7b\u4f3c\u4e00\u4e2a\u55b7\u6cc9\u3002 \u5404\u4e2a\u5f00\u53d1\u9636\u6bb5\u6ca1\u6709\u7279\u5b9a\u7684\u6b21\u5e8f\u8981\u6c42\uff0c\u5e76\u4e14\u53ef\u4ee5\u4ea4\u4e92\u8fdb\u884c\uff0c\u53ef\u4ee5\u5728\u67d0\u4e2a\u5f00\u53d1\u9636\u6bb5\u4e2d\u968f\u65f6\u8865\u5145\u5176\u4ed6\u4efb\u4f55\u5f00\u53d1\u9636\u6bb5\u4e2d\u7684\u9057\u6f0f\u3002 \u4f18\u70b9: \u8be5\u6a21\u578b\u7684\u5404\u4e2a\u9636\u6bb5\u6ca1\u6709\u660e\u663e\u7684\u754c\u9650\uff0c\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u540c\u6b65\u8fdb\u884c\u5f00 \u53d1\uff0c\u53ef\u4ee5\u63d0\u9ad8\u8f6f\u4ef6\u9879\u76ee\u5f00\u53d1\u6548\u7387\uff0c\u8282\u7701\u5f00\u53d1\u65f6\u95f4\uff0c\u9002\u5e94\u4e8e\u9762\u5411\u5bf9\u8c61 \u7684\u8f6f\u4ef6\u5f00\u53d1\u8fc7\u7a0b\u3002 \u7f3a\u70b9\uff1a \u7531\u4e8e\u8be5\u6a21\u578b\u5728\u5404\u4e2a\u5f00\u53d1\u9636\u6bb5\u662f\u91cd\u53e0\u7684\uff0c\u5728\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u9700\u8981\u5927\u91cf \u7684\u5f00\u53d1\u4eba\u5458\uff0c\u56e0\u6b64\u4e0d\u5229\u4e8e\u9879\u76ee\u7684\u7ba1\u7406\u3002 \u8be5\u6a21\u578b\u8981\u6c42\u4e25\u683c\u7ba1\u7406\u6587\u6863\uff0c\u4f7f\u5f97\u5ba1\u6838\u7684\u96be\u5ea6\u52a0\u5927\uff0c\u5c24\u5176\u662f\u9762\u5bf9 \u53ef\u80fd\u968f\u65f6\u52a0\u5165\u5404\u79cd\u4fe1\u606f\u3001\u9700\u6c42\u4e0e\u8d44\u6599\u7684\u60c5\u51b5\u3002 \u8f6f\u4ef6\u5de5\u7a0b\u4e0e\u4e00\u822c\u5de5\u7a0b\u7684\u5dee\u5f02 \u8f6f\u4ef6\u662f\u903b\u8f91\u4ea7\u54c1\u800c\u4e0d\u662f\u5b9e\u7269\u4ea7\u54c1 \u3001\u8f6f\u4ef6\u7684\u529f\u80fd\u4f9d\u8d56\u4e8e\u786c\u4ef6\u548c\u8f6f\u4ef6\u7684\u8fd0\u884c\u73af\u5883\u4ee5 \u53ca\u4eba\u4eec\u5bf9\u5b83\u7684\u64cd\u4f5c\u3001\u8f6f\u4ef6\u8bbe\u8ba1\u7684\u590d\u6742\u6027\u3001\u8f6f\u4ef6\u7279\u5f81\uff1a \u529f\u80fd\u7684\u591a\u6837\u6027 \u5b9e\u73b0\u7684\u591a\u6837\u6027 \u80fd\u89c1\u5ea6\u4f4e \u8f6f\u4ef6\u7ed3\u6784\u5408\u7406\u6027\u5dee \u3001\u667a\u529b\u5bc6\u96c6\u53ca\u77e5\u8bc6\u4ea7\u6743\u4fdd\u62a4","title":"\u7b2c\u4e00\u7ae0 \u8f6f\u4ef6\u5de5\u7a0b\u5b66\u6982\u8ff0"},{"location":"course/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#_3","text":"\u6570\u636e\u6d41\u56fe\u7684\u5c42\u6b21\u7ed3\u6784 \u4e3a\u4e86\u8868\u8fbe\u6570\u636e\u5904\u7406\u8fc7\u7a0b\u7684\u6570\u636e\u52a0\u5de5\u60c5\u51b5\uff0c\u9700\u8981\u91c7\u7528\u5c42\u6b21\u7ed3\u6784\u7684\u6570\u636e\u6d41\u56fe\u3002\u6309\u7167\u7cfb\u7edf\u7684\u5c42\u6b21\u7ed3\u6784\u8fdb\u884c\u9010\u6b65\u5206\u89e3\uff0c\u5e76\u4ee5\u5206\u5c42\u7684\u6570\u636e \u6d41\u56fe\u53cd\u6620\u8fd9\u79cd\u7ed3\u6784\u5173\u7cfb\uff0c\u80fd\u6e05\u695a\u5730\u8868\u8fbe\u548c\u5bb9\u6613\u7406\u89e3\u6574\u4e2a\u7cfb\u7edf\u3002 \u5728\u591a\u5c42\u6570\u636e\u6d41\u56fe\u4e2d\uff0c\u9876\u5c42\u6d41\u56fe\u4ec5\u5305\u542b\u4e00\u4e2a\u52a0\u5de5\uff0c\u5b83\u4ee3\u8868\u88ab\u5f00\u53d1\u7cfb\u7edf\u3002\u5b83\u7684\u8f93\u5165\u6d41\u662f\u8be5\u7cfb\u7edf\u7684\u8f93\u5165\u6570\u636e\uff0c\u8f93\u51fa\u6d41\u662f\u7cfb\u7edf\u6240\u8f93\u51fa\u6570\u636e\u3002\u9876\u5c42\u6570\u636e\u6d41\u56fe\u7684\u4f5c\u7528\u5728\u4e8e\u8868\u660e\u88ab\u5f00\u53d1\u7cfb\u7edf\u7684\u8303\u56f4\u4ee5\u53ca\u5b83\u548c\u5468\u56f4\u73af\u5883\u7684\u6570\u636e\u4ea4\u6362\u5173\u7cfb\u3002\u5bf9\u4e8e\u9876\u5c42\u6570\u636e\u6d41\u56fe\u901a\u5e38\u53ef\u4ee5\u4e0d\u8003\u8651\u6570\u636e \u5b58\u50a8\u3002 \u5e95\u5c42\u6d41\u56fe\u662f\u6307\u5176\u52a0\u5de5\u4e0d\u9700\u518d\u505a\u5206\u89e3\u7684\u6570\u636e\u6d41\u56fe\uff0c\u5b83\u5904\u5728\u6700\u5e95\u5c42\u3002 \u4e2d\u95f4\u5c42\u6d41\u56fe\u5219\u8868\u793a\u5bf9\u5176\u4e0a\u5c42\u7236\u56fe\u7684\u7ec6\u5316\u3002\u5b83\u7684\u6bcf\u4e00\u52a0\u5de5\u53ef\u80fd\u7ee7\u7eed\u7ec6\u5316\uff0c\u5f62\u6210\u5b50\u56fe\u3002 \u6570\u636e\u5b57\u5178\u5b9e\u4f8b \u6570\u636e\u6d41\u56fe\u5b9e\u4f8b","title":"\u7b2c\u4e8c\u7ae0 \u53ef\u884c\u6027\u7814\u7a76"},{"location":"course/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#_4","text":"\u7406\u60f3\u6a21\u5757\u7684\u7279\u70b9\uff1a \u6bcf\u4e2a\u7406\u60f3\u6a21\u5757\u53ea\u89e3\u51b3\u4e00\u95ee\u9898\uff1b \u6bcf\u4e2a\u7406\u60f3\u6a21\u5757\u7684\u529f\u80fd\u90fd\u5e94\u8be5\u660e\u786e\uff0c\u4f7f\u4eba\u5bb9\u6613\u89e3\uff1b \u7406\u60f3\u6a21\u5757\u4e4b\u95f4\u7684\u8054\u7ed3\u5173\u7cfb\u7b80\u5355\uff0c\u5177\u6709\u72ec\u7acb\u6027\uff1b \u7531\u7406\u60f3\u6a21\u5757\u6784\u6210\u7684\u7cfb\u7edf\uff0c\u5bb9\u6613\u4f7f\u4eba\u89e3\u4e8e\u7f16\u7a0b\u6d4b \u8bd5\uff0c\u6613\u4e8e\u4fee\u6539\u548c\u7ef4\u62a4\u3002 \u975e\u76f4\u63a5\u8026\u5408 \u4e24\u4e2a\u6a21\u5757\u4e4b\u95f4\u6ca1\u6709\u76f4\u63a5\u5173\u7cfb\uff0c\u5b83\u4eec\u4e4b\u95f4\u7684\u8054\u7cfb\u5b8c\u5168\u662f\u901a\u8fc7\u4e3b \u6a21\u5757\u7684\u63a7\u5236\u548c\u8c03\u7528\u6765\u5b9e\u73b0\u7684\u3002 \u975e\u76f4\u63a5\u8026\u5408\u7684\u6a21\u5757\u72ec\u7acb\u6027\u6700\u5f3a\u3002 \u5916\u90e8\u8026\u5408 \u4e00\u7ec4\u6a21\u5757\u90fd\u8bbf\u95ee\u540c\u4e00\u5168\u5c40\u7b80\u5355\u53d8\u91cf\u800c\u4e0d\u662f\u540c\u4e00\u5168\u5c40\u6570\u636e\u7ed3\u6784\uff0c \u800c\u4e14\u4e0d\u662f\u901a\u8fc7\u53c2\u6570\u8868\u4f20\u9012\u8be5\u5168\u5c40\u53d8\u91cf\u7684\u4fe1\u606f\uff0c\u5219\u79f0\u4e4b\u4e3a\u5916\u90e8 \u8026\u5408\u3002 \u4f8b\u5982\uff1aC\u8bed\u8a00\u7a0b\u5e8f\u4e2d\u5404\u4e2a\u6a21\u5757\u90fd\u8bbf\u95ee\u88ab\u8bf4\u660e\u4e3aextern\u7c7b\u578b\u7684 \u5916\u90e8\u53d8\u91cf\u3002 \u63a7\u5236\u8026\u5408 \u63a7\u5236\u8026\u5408\u589e\u52a0\u4e86\u7406\u89e3\u548c\u7f16\u7a0b\u7684\u590d\u6742\u6027\uff0c\u8c03\u7528\u6a21\u5757\u5fc5\u987b\u77e5\u9053\u88ab \u8c03\u6a21\u5757\u7684\u5185\u90e8\u903b\u8f91\uff0c\u589e\u52a0\u4e86\u76f8\u4e92\u4f9d\u8d56\u3002\u53bb\u9664\u6a21\u5757\u95f4\u63a7\u5236\u8026\u5408\u7684\u65b9\u6cd5\uff1a\u5c06\u88ab\u8c03\u7528\u6a21\u5757\u5185\u7684\u5224\u5b9a\u4e0a\u79fb\u5230\u8c03\u7528\u6a21\u5757\u4e2d\u8fdb\u884c\uff1b\u88ab\u8c03\u7528\u6a21\u5757\u5206\u89e3\u6210\u82e5\u5e72\u5355\u4e00\u529f\u80fd\u6a21\u5757\u3002 \u516c\u5171\u8026\u5408 \u516c\u5171\u8026\u5408\u7684\u590d\u6742\u7a0b\u5ea6\u968f\u8026\u5408\u6a21\u5757\u7684\u4e2a\u6570\u589e\u52a0\u800c\u663e\u8457\u589e\u52a0\u3002\u82e5\u53ea \u662f\u4e24\u6a21\u5757\u95f4\u6709\u516c\u5171\u6570\u636e\u73af\u5883\uff0c\u5219\u516c\u5171\u8026\u5408\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u5373\u677e\u6563\u516c \u5171\u8026\u5408\u548c\u7d27\u5bc6\u516c\u5171\u8026\u5408\u3002 \u516c\u5171\u8026\u5408\u4f1a\u5f15\u8d77\u4e0b\u5217\u95ee\u9898\uff1a \u6240\u6709\u516c\u5171\u8026\u5408\u6a21\u5757\u90fd\u4e0e\u67d0\u4e00\u4e2a\u516c\u5171\u6570\u636e\u73af\u5883\u5185\u90e8\u5404\u9879\u7684\u7269\u7406\u5b89 \u6392\u6709\u5173\uff0c\u82e5\u4fee\u6539\u67d0\u4e2a\u6570\u636e\u7684\u5927\u5c0f\uff0c\u5c06\u4f1a\u5f71\u54cd\u5230\u6240\u6709\u7684\u6a21\u5757\uff1b \u65e0\u6cd5\u63a7\u5236\u5404\u4e2a\u6a21\u5757\u5bf9\u516c\u5171\u6570\u636e\u7684\u5b58\u53d6\uff0c\u4e25\u91cd\u5f71\u54cd\u8f6f\u4ef6\u6a21\u5757\u7684\u53ef\u9760\u6027\u548c\u9002\u5e94\u6027\uff1b \u516c\u5171\u6570\u636e\u540d\u7684\u4f7f\u7528\uff0c\u660e\u663e\u964d\u4f4e\u4e86\u7a0b\u5e8f\u7684\u53ef\u8bfb\u6027\u3002 \u6a21\u5757\u7684\u4f5c\u7528\u57df\u5e94\u8be5\u5728\u63a7\u5236\u57df\u4e4b\u5185\u8bbe\u8ba1\u539f\u5219 \u8bfe\u672c P100 A.\u5bf9\u4e8e\u4efb\u4f55\u4e00\u4e2a\u5185\u90e8\u5b58\u5728\u5224\u65ad\u8c03\u7528\u7684\u6a21\u5757\uff0c\u5b83\u7684\u5224\u65ad\u4f5c\u7528\u7684\u8303 \u56f4\u5e94\u8be5\u662f\u5176\u63a7\u5236\u8303\u56f4\u7684\u4e00\u4e2a\u5b50\u96c6\uff1b B.\u5b58\u5728\u5224\u65ad\u8c03\u7528\u7684\u6a21\u5757\uff0c\u6240\u5728\u5c42\u6b21\u4e0d\u8981\u4e0e\u90a3\u4e9b\u5c5e\u4e8e\u5224\u65ad\u4f5c\u7528\u8303 \u56f4\u7684\u6a21\u5757\u6240\u5728\u7684\u5c42\u6b21\u76f8\u9694\u592a\u8fdc\u3002 \u6570\u636e\u6d41\u56fe\u8f6c\u8f6f\u4ef6\u7ed3\u6784\u7b2c\u4e8c\u7ea7\u5206\u89e3\u7684\u65b9\u6cd5\u4e3e\u4f8b \u6570\u636e\u6d41\u7a0b\u56fe\u7684\u5212\u5206 \u8bfe\u672cP109 \u9762\u5411\u6570\u636e\u6d41\u8bbe\u8ba1\u5c0f\u7ed3 \u5bf9\u4e8e\u4e00\u4e2a\u5927\u7cfb\u7edf\uff0c\u5e38\u5e38\u628a\u53d8\u6362\u5206\u6790\u548c\u4e8b\u52a1\u5206\u6790\u5e94\u7528\u5230\u540c\u4e00\u4e2a\u6570 \u636e\u6d41\u56fe\u7684\u4e0d\u540c\u90e8\u5206\uff0c\u7531\u6b64\u5f97\u5230\u7684\u5b50\u7ed3\u6784\u5f62\u6210\u201c\u6784\u4ef6\u201d \uff0c\u53ef\u4ee5\u5229\u7528 \u5b83\u4eec\u6784\u9020\u5b8c\u6574\u7684\u8f6f\u4ef6\u7ed3\u6784\uff1b \u5e94\u8be5\u7075\u6d3b\u8fd0\u7528\uff0c\u5408\u5e76\u4e0d\u5fc5\u8981\u7684\u63a7\u5236\u6a21\u5757\uff0c\u5206\u89e3\u529f\u80fd\u8fc7\u5206\u590d\u6742\u7684 \u63a7\u5236\u6a21\u5757\u3002 \u7531\u4e8e\u4efb\u4f55\u8f6f\u4ef6\u7cfb\u7edf\u90fd\u53ef\u4ee5\u7528\u6570\u636e\u6d41\u56fe\u8868\u793a\uff0c\u56e0\u6b64\uff0c\u9762\u5411\u6570\u636e\u6d41 \u7684\u8bbe\u8ba1\u65b9\u6cd5\u7406\u8bba\u4e0a\u53ef\u4ee5\u8bbe\u8ba1\u4efb\u4f55\u8f6f\u4ef6\u7684\u7ed3\u6784\u3002\u901a\u5e38\u6240\u8bf4\u7684\u7ed3\u6784\u5316\u8bbe\u8ba1\u65b9\u6cd5\uff08\u7b80\u79f0SD\u65b9\u6cd5\uff09\u4e5f\u662f\u57fa\u4e8e\u6570\u636e\u6d41\u7684\u8bbe\u8ba1\u65b9\u6cd5\u3002","title":"\u7b2c\u56db\u7ae0 \u603b\u4f53\u8bbe\u8ba1"},{"location":"course/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#_5","text":"\u8be6\u7ec6\u8bbe\u8ba1\u9636\u6bb5\u7684\u4e3b\u8981\u4efb\u52a1 \u4e3a\u6bcf\u4e00\u6a21\u5757\u786e\u5b9a\u7b97\u6cd5\u3001\u786e\u5b9a\u6bcf\u4e00\u6a21\u5757\u4f7f\u7528\u7684\u6570\u636e\u7ed3\u6784\u3001\u786e\u5b9a\u6a21\u5757\u7684\u5916\u90e8\u63a5\u53e3\u548c\u7528\u6237\u754c\u9762\u3001\u4e3a\u6bcf\u4e00\u6a21\u5757\u8bbe\u8ba1\u4e00\u7ec4\u6d4b\u8bd5\u7528\u4f8b \u4eba\u673a\u754c\u9762\u8bbe\u8ba1\u8fc7\u7a0b \u7a0b\u5e8f\u6d41\u7a0b\u56fe\u4f7f\u7528\u4e94\u79cd\u57fa\u672c\u63a7\u5236\u7ed3\u6784 \u5411\u6570\u636e\u7ed3\u6784\u7684\u8bbe\u8ba1\u65b9\u6cd5 \u8be5\u65b9\u6cd5\u7684\u57fa\u672c\u601d\u60f3\u662f\u4f7f\u7a0b\u5e8f\u7ed3\u6784\u4e0e\u95ee\u9898\u7ed3\u6784\u76f8\u5bf9\u5e94\uff0c\u5373\u4e0e\u6570\u636e\u7ed3\u6784\u76f8\u5bf9\u5e94\u3002\u56e0\u6b64\u5b83\u6309\u8f93\u5165\u8f93\u51fa\u4ee5\u53ca\u5185\u90e8\u5b58\u50a8\u4fe1\u606f\u7684\u6570\u636e\u7ed3\u6784\u8fdb\u884c\u8bbe\u8ba1\uff0c\u628a\u6570\u636e\u7ed3\u6784\u7684\u63cf\u8ff0\u53d8\u6362\u4e3a\u5bf9\u7a0b\u5e8f\u7ed3\u6784\u7684\u63cf\u8ff0\u3002 Jackson\u65b9\u6cd5\u8bbe\u8ba1\u5b9e\u4f8b \u95ee\u9898\u63cf\u8ff0 \u67d0\u4ed3\u5e93\u5b58\u653e\u591a\u79cd\u96f6\u4ef6\uff08\u5982P1\uff0cP2\uff0c \u2026\u2026\uff09\uff0c\u6bcf\u4e2a\u96f6\u4ef6\u7684\u6bcf\u6b21 \u8fdb\u8d27\u3001\u53d1\u8d27\u90fd\u6709\u4e00\u5f20\u5361\u7247\u4f5c\u51fa\u8bb0\u5f55\uff0c\u6bcf\u6708\u6839\u636e\u8fd9\u6837\u4e00\u53e0\u5361\u7247\u6253\u5370 \u4e00\u5f20\u6708\u62a5\u8868\u3002\u62a5\u8868\u6bcf\u884c\u5217\u51fa\u67d0\u79cd\u96f6\u4ef6\u672c\u6708\u5e93\u5b58\u91cf\u7684\u51c0\u53d8\u5316\u3002\u7528JSD \u65b9\u6cd5\u5bf9\u8be5\u95ee\u9898\u8fdb\u884c\u8bbe\u8ba1\u3002 \uff083\uff09\u5bfc\u51fa\u7a0b\u5e8f\u7ed3\u6784 \u627e\u51fa\u5bf9\u5e94\u5173\u7cfb\u540e\uff0c\u6839\u636e\u4ee5\u4e0b\u89c4\u5219\u5bfc\u51fa\u7a0b\u5e8f\u7ed3\u6784\uff1a\u5bf9\u4e8e\u8f93\u5165\u6570\u636e \u7ed3\u6784\u4e0e\u8f93\u51fa\u6570\u636e\u7ed3\u6784\u4e2d\u7684\u6570\u636e\u5355\u5143\uff0c\u6bcf\u5bf9\u6709\u5bf9\u5e94 \u5173\u7cfb\u7684\u6570\u636e\u5355\u5143 \u6309\u7167\u5b83\u4eec\u6240\u5728\u7684\u5c42\u6b21\uff0c\u5728\u7a0b\u5e8f\u7ed3\u6784\u56fe\u9002\u5f53\u4f4d\u7f6e\u753b\u4e00\u4e2a\u5904\u7406\u6846\uff0c\u65e0\u5bf9\u5e94\u5173\u7cfb\u7684\u6570\u636e\u5355\u5143\uff0c\u5404\u753b\u4e00 \u4e2a\u5904\u7406\u6846\u3002 \u6839\u636e\u4ee5\u4e0a\u89c4\u5219\uff0c\u753b\u51fa\u7684\u7a0b\u5e8f\u7ed3\u6784\u56fe\u5982\u56fe\u6240\u793a\u3002 \u5728\u5206\u914d\u64cd\u4f5c\u65f6\u6ce8\u610f\uff1a\u4e3a\u4e86\u80fd\u83b7\u5f97\u91cd\u590d\u548c\u9009\u62e9\u7684\u6761\u4ef6\uff0cJackson \u5efa\u8bae\u81f3\u5c11\u8d85\u524d\u8bfb\u4e00\u4e2a\u8bb0\u5f55\uff0c\u4ee5\u4fbf\u4f7f\u5f97\u7a0b\u5e8f\u4e0d\u8bba\u5728\u4ec0\u4e48\u65f6\u5019\u5224\u5b9a\uff0c \u603b\u6709\u6570\u636e\u5df2\u7ecf\u8bfb\u5165\uff0c\u5e76\u505a\u597d\u4f7f\u7528\u51c6\u5907\u3002\u56e0\u6b64\u5728\u56fe\u4e2d\uff0c\u5c06\u64cd\u4f5cE\uff08\u8bfb \u4e00\u5f20\u5361\uff09\u653e\u5728\u6253\u5f00\u6587\u4ef6\u4e4b\u540e\uff0c\u540c\u65f6\u5728\u5904\u7406\u5b8c\u4e00\u5f20\u5361\u7247\u540e\u518d\u8bfb\u4e00\u6b21\u3002 (5) \u7528\u4f2a\u7801\u5199\u51fa\u7a0b\u5e8f Jackson\u65b9\u6cd5\u4e2d\u7684\u4f2a\u7801\u4e0eJackson\u6240\u793a\u7684\u7a0b\u5e8f\u7ed3\u6784\u56fe\u5b8c\u5168\u5bf9\u5e94\uff0c\u7528 \u4f2a\u7801\u5199\u51fa\u7a0b\u5e8f\u7684\u8fc7\u7a0b\uff0c\u5b9e\u9645\u4e0a\u5c31\u662f\u81ea\u9876\u5411\u4e0b\u7528\u8fd9\u4e9b\u4f2a\u7801\u66ff\u6362 Jackson\u56fe\u4e2d\u6bcf\u4e2a\u5904\u7406\u6846\u7684\u8fc7\u7a0b\uff0c\u6bcf\u4e2a\u5904\u7406\u6846\u90fd\u770b\u4f5c\u662f\u4e0b\u5c42\u5904\u7406\u6846 \u53ca\u5206\u914d\u5728\u4e0a\u9762\u7684\u64cd\u4f5c\u7ec4\u6210\u3002 Jackson\u65b9\u6cd5\u5c0f\u7ed3 \u4f18\u70b9\uff1a\u7b80\u5355\uff0c\u9002\u5408\u4e8e\u89c4\u6a21\u4e0d\u5927\u7684\u7cfb\u7edf\uff0c\u5efa\u7acb\u4e86\u95ee\u9898\u7684\u6570\u636e\u7ed3\u6784 \u4e4b\u540e\uff0c\u53ef\u76f4\u63a5\u63a8\u5bfc\u51fa\u76f8\u5e94\u7684\u7a0b\u5e8f\u7ed3\u6784\u3002 \u5c40\u9650\u6027\uff1a\u5f53\u8f93\u5165\u6570\u636e\u7ed3\u6784\u4e0e\u8f93\u51fa\u6570\u636e\u7ed3\u6784\u4e0d\u76f8\u540c\u4e14\u65e0\u5bf9\u5e94\u5173\u7cfb \u65f6\uff0c\u96be\u4e8e\u5e94\u7528\u3002\u5f53\u6570\u636e\u7ed3\u6784\u53d1\u751f\u53d8\u5316\u65f6\uff0c\u7a0b\u5e8f\u7ed3\u6784\u4e5f\u53d1\u751f\u53d8\u5316\uff0c\u4e00 \u822c\u662f\u603b\u4f53\u4e0a\u7528SD\u65b9\u6cd5\uff0c\u5c40\u90e8\u8303\u56f4\u7528JSD\u65b9\u6cd5\u3002 SD\u65b9\u6cd5\u548cJSD\u65b9\u6cd5\u7684\u5f02\u540c\uff1a\u9762\u5411\u6570\u636e\u6d41\u7684\u8bbe\u8ba1\uff08SD\u65b9\u6cd5\uff09\u548c\u9762\u5411\u6570\u636e\u7ed3\u6784\u7684\u8bbe\u8ba1\uff08JSD\u65b9\u6cd5\uff09 \u7684\u5171\u540c\u70b9\u90fd\u662f\u6570\u636e\u4fe1\u606f\u9a71\u52a8\u7684\uff0c\u90fd\u8bd5\u56fe\u5c06\u6570\u636e\u8868\u793a\u8f6c\u6362\u6210\u8f6f\u4ef6\u8868\u793a\uff1b \u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u9762\u5411\u6570\u636e\u7ed3\u6784\u7684\u8bbe\u8ba1\u4e0d\u5229\u7528\u6570\u636e\u6d41\u56fe\uff0c\u800c\u6839\u636e\u6570\u636e\u7ed3 \u6784\u7684\u8868\u793a\u6765\u8bbe\u8ba1\u3002 Halstead\u4f30\u8ba1\u590d\u6742\u5ea6\u65b9\u6cd5 \u8bfe\u672c P139 \u5728\u5b9a\u4e49\u4e2d\uff0c\u8fd0\u7b97\u7b26\u5305\u62ec\uff1a \u7b97\u672f\u8fd0\u7b97\u7b26\u3001\u8d4b\u503c\u7b26(=\u6216:=)\u3001\u903b\u8f91\u8fd0\u7b97\u7b26\u3001\u5206\u754c\u7b26(\uff0c\u6216\uff1b\u6216:) \u3001\u5173\u7cfb\u8fd0\u7b97\u7b26\u3001 \u62ec\u53f7\u8fd0\u7b97\u7b26\u3001\u5b50\u7a0b\u5e8f\u8c03\u7528\u7b26\u3001\u6570\u7ec4\u64cd\u4f5c\u7b26\u3001\u5faa\u73af\u64cd\u4f5c\u7b26\u7b49\uff1b \u7279\u522b\u5730\uff0c\u6210\u5bf9\u7684\u8fd0\u7b97\u7b26\uff0c\u4f8b\u5982 begin\u2026end\u3001if\u2026then\u2026else\u3001for\u2026to\u3001repeat \u2026until\u3001while\u2026do\u3001\uff08\u2026\uff09\u7b49 \u90fd\u5f53\u505a\u5355\u4e00\u8fd0\u7b97\u7b26\u3002 \u8fd0\u7b97\u5bf9\u8c61\u5305\u62ec\u53d8\u91cf\u540d\u548c\u5e38\u6570\u3002","title":"\u7b2c\u4e94\u7ae0 \u8be6\u7ec6\u8bbe\u8ba1"},{"location":"course/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#_6","text":"\u8f6f\u4ef6\u6d4b\u8bd5\u7684\u57fa\u672c\u539f\u5219 \u5c3d\u91cf\u4e0d\u7531\u7a0b\u5e8f\u8bbe\u8ba1\u8005\u8fdb\u884c\u6d4b\u8bd5 \u5173\u952e\u662f\u6ce8\u91cd\u6d4b\u8bd5\u7528\u4f8b\u7684\u9009\u62e9 \u8f93\u5165\u6570\u636e\u7684\u7ec4\u6210\uff08\u8f93\u5165\u6570\u636e\u3001\u9884\u671f\u7684\u8f93\u51fa\u7ed3\u679c\uff09\u3001\u65e2\u6709\u5408\u7406\u8f93\u5165\u6570\u636e\uff0c\u4e5f\u6709\u4e0d\u5408\u7406\u7684\u8f93\u5165\u6570\u636e\u3001\u7528\u4f8b\u65e2\u80fd\u68c0\u67e5\u5e94\u5b8c\u6210\u7684\u4efb\u52a1\uff0c\u4e5f\u80fd\u591f\u68c0\u67e5\u4e0d\u5e94\u8be5\u5b8c\u6210\u7684\u4efb \u52a1\u3001\u957f\u671f\u4fdd\u5b58\u6d4b\u8bd5\u7528\u4f8b\u3002 \u6240\u6709\u7684\u6d4b\u8bd5\u90fd\u5e94\u5f53\u8ffd\u6eaf\u5230\u7528\u6237\u8981\u6c42\uff0c\u5bfc\u81f4\u7a0b\u5e8f\u4e0d\u80fd\u6ee1\u8db3\u7528\u6237 \u8981\u6c42\u7684\u9519\u8bef\u662f\u4e25\u91cd\u9519\u8bef \u5145\u5206\u6ce8\u610f\u6d4b\u8bd5\u4e2d\u7684\u7fa4\u96c6\u73b0\u8c61 \u6d4b\u8bd5\u53d1\u73b0\u7684\u9519\u8bef\u4e2d\u768480%\u5f88\u53ef\u80fd\u51fa\u81ea20%\u7684\u6a21\u5757 \u59a5\u5584\u4fdd\u5b58\u6d4b\u8bd5\u8ba1\u5212\u3001\u6d4b\u8bd5\u7528\u4f8b\u3001\u51fa\u9519\u7edf\u8ba1\u548c\u6700\u7ec8\u5206\u6790\u62a5\u544a\uff0c \u4e3a\u7ef4\u62a4\u63d0\u4f9b\u65b9\u4fbf \u8f6f\u4ef6\u6d4b\u8bd5\u6b65\u9aa4\u53ca\u7b56\u7565 \u786e\u8ba4\u6d4b\u8bd5 \u786e\u8ba4\u6d4b\u8bd5\u6b65\u9aa4 \u6709\u6548\u6027\u6d4b\u8bd5 \u5236\u5b9a\u6d4b\u8bd5\u8ba1\u5212\u548c\u6d4b\u8bd5\u8fc7\u7a0b\uff0c\u8fd0\u7528\u9ed1\u76d2\u6cd5\uff0c\u9a8c\u8bc1\u8f6f\u4ef6\u7279\u6027\u662f\u5426\u4e0e \u9700\u6c42\u7b26\u5408\u3002 \u8f6f\u4ef6\u914d\u7f6e\u590d\u67e5 \u8f6f\u4ef6\u914d\u7f6e\u662f\u6307\u8f6f\u4ef6\u5de5\u7a0b\u8fc7\u7a0b\u4e2d\u6240\u4ea7\u751f\u7684\u6240\u6709\u4fe1\u606f\u9879:\u6587\u6863\u3001\u62a5\u544a\u3001 \u7a0b\u5e8f\u3001\u8868\u683c\u3001\u6570\u636e\u3002\u968f\u7740\u8f6f\u4ef6\u5de5\u7a0b\u8fc7\u7a0b\u7684\u8fdb\u5c55\u8f6f\u4ef6\u914d\u7f6e\u9879\u5feb\u901f\u589e \u52a0\u548c\u53d8\u5316\uff0c\u5e94\u590d\u67e5\u8f6f\u4ef6\u914d\u7f6e\u9879\u662f\u5426\u9f50\u5168\u3001\u4e00\u81f4\u3002 \u8f6f\u4ef6\u6d4b\u8bd5\u5e73\u884c\u8fd0\u884c \u6240\u8c13\u5e73\u884c\u8fd0\u884c\u5c31\u662f\u540c\u65f6\u8fd0\u884c\u65b0\u5f00\u53d1\u51fa\u6765\u7684\u7cfb\u7edf\u548c\u5c06\u88ab\u5b83\u53d6\u4ee3\u7684 \u65e7\u7cfb\u7edf\uff0c\u4ee5\u4fbf\u6bd4\u8f83\u65b0\u65e7\u4e24\u4e2a\u7cfb\u7edf\u7684\u5904\u7406\u7ed3\u679c\u3002\u8fd9\u6837\u505a\u7684\u5177\u4f53\u76ee\u7684 \u6709\u5982\u4e0b\u51e0\u70b9\uff1a \u53ef\u4ee5\u5728\u51c6\u751f\u4ea7\u73af\u5883\u4e2d\u8fd0\u884c\u65b0\u7cfb\u7edf\u800c\u53c8\u4e0d\u5192\u98ce\u9669\uff1b \u7528\u6237\u80fd\u6709\u4e00\u6bb5\u719f\u6089\u65b0\u7cfb\u7edf\u7684\u65f6\u95f4\uff1b \u53ef\u4ee5\u9a8c\u8bc1\u7528\u6237\u6307\u5357\u548c\u4f7f\u7528\u624b\u518c\u4e4b\u7c7b\u7684\u6587\u6863\uff1b \u80fd\u591f\u4ee5\u51c6\u751f\u4ea7\u6a21\u5f0f\u5bf9\u65b0\u7cfb\u7edf\u8fdb\u884c\u5168\u8d1f\u8377\u6d4b\u8bd5\uff0c\u53ef\u4ee5\u7528\u6d4b\u8bd5\u7ed3\u679c\u9a8c\u8bc1\u6027\u80fd\u6307\u6807\u3002 \u5982\u4f55\u6d4b\u8bd5 \u5173\u952e ---- \u8bbe\u8ba1\u6d4b\u8bd5\u65b9\u6848\u3002 \u6d4b\u8bd5\u65b9\u6848 ---- \u5305\u62ec\uff1a\u5177\u4f53\u7684\u6d4b\u8bd5\u76ee\u7684\uff0c\u5e94\u8be5\u8f93\u5165\u7684\u6d4b\u8bd5\u6570\u636e\u548c\u9884\u671f\u7684\u7ed3\u679c\u3002 \u901a\u5e38\u53c8\u628a\u6d4b\u8bd5\u6570\u636e\u548c\u9884\u671f\u7684\u8f93\u51fa\u7ed3\u679c\u79f0\u4e3a\u6d4b\u8bd5\u7528\u4f8b\u3002\u5176\u4e2d\u6700\u56f0\u96be\u7684\u95ee\u9898\u662f\u8bbe\u8ba1\u6d4b\u8bd5\u7528\u7684\u8f93\u5165\u6570\u636e\u3002 \u4e0d\u540c\u7684\u6d4b\u8bd5\u6570\u636e\u53d1\u73b0\u7a0b\u5e8f\u9519\u8bef\u7684\u80fd\u529b\u5dee\u522b\u5f88\u5927\uff0c\u4e3a\u4e86\u63d0\u9ad8\u6d4b\u8bd5\u6548\u7387\u964d\u4f4e\u6d4b\u8bd5\u6210\u672c\uff0c\u5e94\u8be5\u9009\u7528\u9ad8\u6548\u7684\u6d4b\u8bd5\u6570\u636e\u3002 \u767d\u76d2\u6d4b\u8bd5\u6b65\u9aa4 \u9009\u62e9\u903b\u8f91\u8986\u76d6\u6807\u51c6\uff1b\u6309\u7167\u8986\u76d6\u6807\u51c6\u5217\u51fa\u6240\u6709\u60c5\u51b5\uff1b \u9009\u62e9\u786e\u5b9a\u6d4b\u8bd5\u7528\u4f8b\uff1b \u9a8c\u8bc1\u5206\u6790\u8fd0\u884c\u7ed3\u679c\u4e0e\u9884\u671f\u7ed3\u679c\u3002 \u5b9e\u9645\u6d4b\u8bd5\u7b56\u7565 \u9ed1\u76d2+\u767d\u76d2\u6d4b\u8bd5 \uf06c \u5728\u4efb\u4f55\u60c5\u51b5\u4e0b\uff0c\u90fd\u5e94\u4f7f\u7528\u8fb9\u754c\u503c\u5206\u6790\u65b9\u6cd5\uff1b \uf06c \u5fc5\u8981\u65f6\u7528\u7b49\u4ef7\u5212\u5206\u6cd5\u8865\u5145\u6d4b\u8bd5\u7528\u4f8b\uff1b \uf06c \u5fc5\u8981\u65f6\u518d\u7528\u9519\u8bef\u63a8\u6d4b\u6cd5\u8865\u5145\u6d4b\u8bd5\u7528\u4f8b\uff1b \uf06c \u5bf9\u7167\u7ec4\u4ef6\u7684\u903b\u8f91\uff0c\u68c0\u67e5\u5df2\u8bbe\u8ba1\u51fa\u7684\u6d4b\u8bd5\u7528\u4f8b\u3002 \u767d\u76d2\u6d4b\u8bd5\u4e0e\u9ed1\u76d2\u6d4b\u8bd5\u5bf9\u6bd4 \u8f6f\u4ef6\u8c03\u8bd5\u539f\u5219 1.\u6ce8\u610f\u9519\u8bef\u7684\u201c\u7fa4\u96c6\u73b0\u8c61\u201d\uff1b 2.\u4e0d\u80fd\u53ea\u4fee\u6539\u9519\u8bef\u7684\u5f81\u5146\u3001\u8868\u73b0\u3002\u8fd8\u5e94\u8be5\u4fee\u6539\u9519\u8bef\u7684\u672c\u8d28\uff1b 3.\u6ce8\u610f\u5728\u4fee\u6539\u4e00\u4e2a\u9519\u8bef\u7684\u540c\u65f6\uff0c\u4e0d\u8981\u5f15\u5165\u65b0\u7684\u9519\u8bef\u3002 \u8f6f\u4ef6\u53ef\u9760\u6027\u8ba1\u7b97\u4f8b\u9898 MTTF","title":"\u7b2c\u516d\u7ae0 \u7cfb\u7edf\u5b9e\u73b0"},{"location":"course/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#_7","text":"\u63d0\u9ad8\u53ef\u7ef4\u62a4\u6027\u7684\u65b9\u6cd5 \u5efa\u7acb\u660e\u786e\u7684\u8f6f\u4ef6\u8d28\u91cf\u76ee\u6807\u548c\u4f18\u5148\u7ea7 \u4f7f\u7528\u63d0\u9ad8\u8f6f\u4ef6\u8d28\u91cf\u7684\u6280\u672f\u548c\u5de5\u5177 \u8fdb\u884c\u660e\u786e\u7684\u8d28\u91cf\u4fdd\u8bc1\u5ba1\u67e5 \u9009\u62e9\u53ef\u7ef4\u62a4\u7684\u7a0b\u5e8f\u8bbe\u8ba1\u8bed\u8a00 \u6539\u8fdb\u7a0b\u5e8f\u7684\u6587\u6863 \u8f6f\u4ef6\u518d\u5de5\u7a0b \u8f6f\u4ef6\u518d\u5de5\u7a0b\u662f\u4e00\u7c7b\u8f6f \u4ef6\u5de5\u7a0b\u6d3b\u52a8\uff0c\u662f\u4e00\u4e2a \u5de5\u7a0b\u8fc7\u7a0b, \u5b83\u5c06\u9006\u5411 \u5de5\u7a0b\u3001\u91cd\u6784\u548c\u6b63\u5411\u5de5 \u7a0b\u7ec4\u5408\u8d77\u6765,\u5c06\u73b0\u5b58\u7cfb \u7edf\u91cd\u65b0\u6784\u9020\u4e3a\u65b0\u7684\u5f62 \u5f0f\u3002","title":"\u7b2c\u4e03\u7ae0 \u8f6f\u4ef6\u7ef4\u62a4"},{"location":"course/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#_8","text":"\u8f6f\u4ef6\u751f\u5b58\u671f\u5404\u9636\u6bb5\u6240\u4f7f\u7528\u7684\u65b9\u6cd5\u3001\u6280\u672f\u5177\u6709\u9ad8\u5ea6\u7684\u8fde\u7eed\u6027\uff0c\u7528 \u7b26\u5408\u4eba\u7c7b\u8ba4\u8bc6\u4e16\u754c\u7684\u601d\u7ef4\u65b9\u5f0f\u6765\u5206\u6790\u3001\u89e3\u51b3\u95ee\u9898\u3002\u5c06OOA\u3001OOD\u3001 OOP\u6709\u673a\u5730\u96c6\u6210\u5728\u4e00\u8d77\u3002 \u9762\u5411\u5bf9\u8c61\u7684\u5206\u6790\uff08Object-Oriented Analysis\uff0cOOA \uff09 \u5f3a\u8c03\u7684\u662f\u5bf9\u4e00\u4e2a\u7cfb\u7edf\u4e2d\u7684\u5bf9\u8c61\u7279\u5f81\u548c\u884c\u4e3a\u7684\u5b9a\u4e49\u3002\u5efa\u7acb\u7cfb\u7edf\u7684 \u4e09\u7c7b\u6a21\u578b\u3002 \u9762\u5411\u5bf9\u8c61\u7684\u8bbe\u8ba1\uff08Object-Oriented Design\uff0cOOD\uff09 \u4e0eOOA\u5bc6\u5207\u914d\u5408\uff0c\u987a\u5e8f\u5b9e\u73b0\u5bf9\u73b0\u5b9e\u4e16\u754c\u7684\u8fdb\u4e00\u6b65\u5efa\u6a21\u3002 \u9762\u5411\u5bf9\u8c61\u7684\u7f16\u7a0b\uff08Object-Oriented Program\uff0cOOP \uff09 \u662f\u9762\u5411\u5bf9\u8c61\u7684\u6280\u672f\u4e2d\u53d1\u5c55\u6700\u5feb\u7684\uff0c\u4f7f\u7528\u9762\u5411\u5bf9\u8c61\u7684\u7a0b\u5e8f\u8bbe\u8ba1\u8bed \u8a00\uff0c\u8fdb\u884c\u7f16\u7801\u3002","title":"\u7b2c\u4e5d\u7ae0 \u9762\u5411\u5bf9\u8c61\u5206\u6790\u8bbe\u8ba1\u4e0e\u5b9e\u73b0"},{"location":"course/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#_9","text":"\u9879\u76ee\u5177\u6709\u7684\u57fa\u672c\u7279\u6027 \u9879\u76ee\u7684\u4e00\u6b21\u6027 \u9879\u76ee\u7684\u7ec4\u7ec7\u6027 \u9879\u76ee\u7684\u751f\u547d\u671f \u9879\u76ee\u7684\u8d44\u6e90\u6d88\u8017\u6027 \u9879\u76ee\u540e\u679c\u7684\u4e0d\u786e\u5b9a\u6027 \u9879\u76ee\u7684\u76ee\u6807\u51b2\u7a81\u6027 \u9879\u76ee\u7ba1\u7406 \u5728\u9879\u76ee\u6d3b\u52a8\u4e2d\u8fd0\u7528\u4e00\u7cfb\u5217\u7684\u77e5\u8bc6\u3001\u6280\u80fd\u3001\u5de5\u5177\u548c\u6280\u672f\uff0c\u4ee5\u6ee1\u8db3 \u6216\u8d85\u8fc7\u76f8\u5173\u5229\u76ca\u8005\u5bf9\u9879\u76ee\u7684\u8981\u6c42\u3002\uff08PMI\uff09 \u8f6f\u4ef6\u9879\u76ee\u7ba1\u7406 \u8f6f\u4ef6\u9879\u76ee\u662f\u6307\u5bf9\u8f6f\u4ef6\u7cfb\u7edf\u8fdb\u884c\u5f00\u53d1\u3001\u96c6\u6210\u548c\u670d\u52a1\u4e3a\u4e3b\u8981\u76ee\u7684\u7684 \u9879\u76ee\u3002\u8f6f\u4ef6\u9879\u76ee\u7ba1\u7406\u548c\u5176\u4ed6\u9879\u76ee\u7ba1\u7406\u76f8\u6bd4\uff0c\u5177\u6709\u5f88\u5927\u7684\u72ec\u7279\u6027\uff1a \u8f6f\u4ef6\u9879\u76ee\u7ba1\u7406\u5c1a\u4e0d\u89c4\u8303\uff0c\u7ecf\u9a8c\u6210\u5206\u660e\u663e\uff1b \u8fc7\u7a0b\u6ca1\u6709\u660e\u663e\u7684\u5212\u5206\uff1b \u5927\u90fd\u662f\u201c\u4e00\u6b21\u6027\u201d\u7684\u4eba\u529b\u6d88\u8017\u578b\u9879\u76ee \u7518\u7279\u56fe \u7518\u7279\u56fe\u4e5f\u79f0\u4e3a\u6761\u578b\u56fe\uff0c\u6216\u6a2a\u9053\u56fe\u3002\u5b83\u4ee5\u6a2a\u5750\u6807\u8868\u793a\u65f6\u95f4\uff0c\u5de5\u7a0b \u6d3b\u52a8\u5728\u56fe\u7684\u5de6\u4fa7\u7eb5\u5411\u6392\u5217\uff0c\u4ee5\u6d3b\u52a8\u6240\u5bf9\u5e94\u7684\u6a2a\u9053\u4f4d\u7f6e\u8868\u793a\u6d3b\u52a8\u7684 \u8d77\u59cb\u65f6\u95f4\uff0c\u6a2a\u9053\u7684\u957f\u77ed\u8868\u793a\u6301\u7eed\u65f6\u95f4\u7684\u957f\u77ed\u3002\u5b83\u662f\u4e00\u79cd\u6bd4\u8f83\u7b80\u4fbf \u7684\u5de5\u671f\u8ba1\u5212\u548c\u8fdb\u5ea6\u5b89\u6392\u5de5\u5177\u3002 \u5173\u952e\u8def\u5f84\u6cd5 \u5bf9\u5173\u952e\u8def\u5f84\u7684\u8ba1\u7b97\u4e0e\u8c03\u6574\u4f18\u5316 \u6e05\u9192\u7684\u8ba4\u8bc6\uff1a\u5173\u952e\u8def\u5f84\u662f\u7f51\u7edc\u56fe\u4e2d\u6700\u957f\u7684\u7ebf\u8def\uff0c\u5b83\u51b3\u5b9a\u4e86\u9879 \u76ee\u7684\u603b\u8017\u65f6\u3002 \u5fc5\u987b\u628a\u6ce8\u610f\u529b\u96c6\u4e2d\u4e8e\u90a3\u4e9b\u4f18\u5148\u7b49\u5f85\u5b8c\u6210\u7684\u4efb\u52a1\uff0c\u786e\u4fdd\u5b83\u4eec\u51c6 \u65f6\u5b8c\u6210\u3002\u5173\u952e\u8def\u5f84\u4e0a\u7684\u63a8\u8fdf\u5373\u662f\u6574\u4e2a\u9879\u76ee\u63a8\u8fdf\u3002 \u5411\u5173\u952e\u8def\u5f84\u8981\u65f6\u95f4\uff0c\u5411\u975e\u5173\u952e\u8def\u5f84\u8981\u8d44\u6e90\u3002 \u8c03\u6574\u8fdb\u5ea6\uff0c\u5e73\u8861\u8d44\u6e90\u3002 \u80fd\u529b\u6210\u719f\u5ea6\u6a21\u578b \u26ab \u521d\u59cb\u7ea7 \u2713 \u7ec4\u7ec7\uff1a\u7ec4\u7ec7\u901a\u5e38\u6ca1\u6709\u63d0\u4f9b\u5f00\u53d1\u548c\u7ef4\u62a4\u8f6f\u4ef6\u7684\u7a33\u5b9a\u7684\u73af\u5883\u3002 \u2713 \u9879\u76ee\uff1a\u5f53\u53d1\u751f\u5371\u673a\u65f6\uff0c\u9879\u76ee\u901a\u5e38\u653e\u5f03\u8ba1\u5212\u7684\u8fc7\u7a0b\uff0c\u56de\u590d\u5230\u7f16\u7801\u548c\u6d4b\u8bd5\u3002 \u2713 \u8fc7\u7a0b\u80fd\u529b\uff1a\u4e0d\u53ef\u9884\u6d4b\u3002(unpredictable) \u26ab \u53ef\u91cd\u590d\u7ea7 \u2713 \u7ec4\u7ec7\uff1a\u5c06\u8f6f\u4ef6\u9879\u76ee\u7684\u6709\u6548\u7ba1\u7406\u8fc7\u7a0b\u5236\u5ea6\u5316\uff0c\u8fd9\u4f7f\u5f97\u7ec4\u7ec7\u80fd\u591f\u91cd\u590d\u4ee5\u524d\u9879 \u76ee\u4e2d\u7684\u6210\u529f\u5b9e\u8df5\u3002 \u2713 \u9879\u76ee\uff1a\u914d\u5907\u4e86\u57fa\u672c\u7684\u8f6f\u4ef6\u7ba1\u7406\u63a7\u5236\u3002 \u2713 \u8fc7\u7a0b\u80fd\u529b\uff1a\u4e25\u683c\u7684\u3002(disciplined) \u26ab \u5df2\u5b9a\u4e49\u7ea7 \u2713 \u7ec4\u7ec7\uff1a\u5728\u7ec4\u7ec7\u8303\u56f4\u5185\u5f00\u53d1\u548c\u7ef4\u62a4\u8f6f\u4ef6\u7684\u6807\u51c6\u8fc7\u7a0b\u88ab\u6587\u6863\u5316\uff0c\u5176\u4e2d\u5305\u62ec\u8f6f \u4ef6\u5de5\u7a0b\u8fc7\u7a0b\u548c\u7ba1\u7406\u8fc7\u7a0b\uff0c\u5b83\u4eec\u96c6\u6210\u4e3a\u4e00\u4e2a\u4e00\u81f4\u7684\u6574\u4f53\u3002 \u2713 \u9879\u76ee\uff1a\u5bf9\u7ec4\u7ec7\u7684\u6807\u51c6\u8f6f\u4ef6\u8fc7\u7a0b\u8fdb\u884c\u88c1\u526a\uff0c\u6765\u5f00\u53d1\u5b83\u4eec\u81ea\u5df1\u7684\u5b9a\u4e49\u8f6f\u4ef6\u8fc7 \u7a0b\u3002 \u2713 \u8fc7\u7a0b\u80fd\u529b\uff1a\u6807\u51c6\u7684\u548c\u4e00\u81f4\u7684\u3002(standard and consistent) \u26ab \u5df2\u7ba1\u7406\u7ea7 \u2713 \u7ec4\u7ec7\uff1a\u4e3a\u8f6f\u4ef6\u4ea7\u54c1\u548c\u8fc7\u7a0b\u90fd\u8bbe\u5b9a\u4e86\u91cf\u5316\u7684\u8d28\u91cf\u76ee\u6807\u3002 \u2713 \u9879\u76ee\uff1a\u9879\u76ee\u51cf\u5c0f\u8fc7\u7a0b\u6027\u80fd\u7684\u53d8\u5316\u6027\uff0c\u4f7f\u5176\u8fdb\u5165\u53ef\u63a5\u6536\u7684\u91cf\u5316\u8fb9\u754c\uff0c\u4ece\u800c \u8fbe\u5230\u5bf9\u4ea7\u54c1\u548c\u8fc7\u7a0b\u7684\u63a7\u5236\u3002 \u2713 \u8fc7\u7a0b\u80fd\u529b\uff1a\u53ef\u9884\u8a00\u7684\u3002(predictable) \u26ab \u6301\u7eed\u4f18\u5316\u7ea7 \u2713 \u7ec4\u7ec7\uff1a\u5173\u6ce8\u4e8e\u6301\u7eed\u7684\u8fc7\u7a0b\u6539\u8fdb\u3002 \u2713 \u9879\u76ee\uff1a\u8f6f\u4ef6\u8fc7\u7a0b\u88ab\u8bc4\u4ef7\uff0c\u4ee5\u9632\u6b62\u8fc7\u5931\u91cd\u590d\u53d1\u751f\uff0c\u4ece\u4e2d\u83b7\u5f97\u7684\u6559\u8bad\u6563\u5e03\u7ed9 \u5176\u5b83\u9879\u76ee\u3002 \u2713 \u8fc7\u7a0b\u80fd\u529b\uff1a\u6301\u7eed\u7684\u6539\u5584\u3002(continuously improving)","title":"\u7b2c\u5341\u7ae0 \u8f6f\u4ef6\u9879\u76ee\u7ba1\u7406"},{"location":"csdn/","text":"\u8bfe\u7a0b\u590d\u4e60\u7cfb\u5217","title":"Index"},{"location":"csdn/2020-08-01/","text":"http://icpc.upc.edu.cn/problem.php?cid=1459&pid=4 \u9898\u76ee\u63cf\u8ff0 \u00b6 Three friends like to play the following game. The first friend chooses a string S. Then the second friend constructs a new string T that consists of two copies of the string S. finally, the third friend inserts one letter at the beginning, the end or somewhere inside the string T, thereby creating a string U. You are given the string U and your task is to reconstruct the original string S. \u8f93\u5165 \u00b6 The first line of the input contains N\uff082 \u2264 N \u2264 2000001\uff09, the length of the final string U. The string U itself is given on the second line. It consists of N uppercase English letters (A, B, C, . . . , Z). \u8f93\u51fa \u00b6 Your program should print the original string S. However, there are two exceptions: 1.If the final string U could not have been created using the above procedure, you should print NOT POSSIBLE. 2.If the original string S is not unique, you should print NOT UNIQUE. \u6837\u4f8b\u8f93\u5165 \u00b6 7 ABXCABC \u6837\u4f8b\u8f93\u51fa \u00b6 ABC \u89e3\u6790 \u00b6 \u5b57\u7b26\u4e32\u54c8\u5e0c\u7684\u5e94\u7528\uff0c\u6bd4\u8f83\u53bb\u9664\u4e00\u4e2a\u5b57\u6bcd\u540e\u524d\u534a\u90e8\u5206\u7684\u54c8\u5e0c\u503c\u548c\u540e\u534a\u90e8\u5206\u54c8\u5e0c\u503c\u662f\u5426\u76f8\u540c #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef unsigned long long ull ; const int N = 2e6 + 500 ; char a [ N ] = \"\" ; int base = 131 ; ull p [ N ] = { 0 }; ull h [ N ] = { 0 }; ull get ( ull l , ull r ) { return h [ r ] - h [ l -1 ] * p [ r - l + 1 ]; } int main () { int n ; scanf ( \"%d\" , & n ); if ( n % 2 == 0 ) { printf ( \"NOT POSSIBLE \\n \" ); return 0 ; } scanf ( \"%s\" , a + 1 ); p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = p [ i -1 ] * base ; for ( int i = 1 ; i <= n ; i ++ ) h [ i ] = h [ i -1 ] * base + a [ i ] - 'A' ; ull flag = 0 , ans , pos ; ///\u6ce8\u610f\u7528ull\uff0cans\u6570\u636e\u6bd4\u8f83\u5927 for ( int i = 1 ; i <= n ; i ++ ) { ull s1 , s2 ; if ( i <= n / 2 ) { s1 = h [ i -1 ] * p [ n / 2 - i + 1 ] + get ( i + 1 , n / 2 + 1 ); } else { s1 = h [ n / 2 ]; } if ( i <= n / 2 + 1 ) { s2 = get ( n - n / 2 + 1 , n ); } else { s2 = get ( n / 2 + 1 , i -1 ) * p [ n - i ] + get ( i + 1 , n ); } if ( s1 == s2 ) { if ( flag && ans != s1 ) { printf ( \"NOT UNIQUE \\n \" ); return 0 ; } ans = s1 ; pos = i ; flag = 1 ; } } if ( flag ) { for ( int i = 1 , j = 0 ; j < n / 2 ; i ++ ) { if ( i == pos ) continue ; else printf ( \"%c\" , a [ i ]), j ++ ; } printf ( \" \\n \" ); } else { printf ( \"NOT POSSIBLE \\n \" ); } } http://icpc.upc.edu.cn/problem.php?cid=1459&pid=10 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u4e00\u5757\u82b1\u5e03\u6761\uff0c\u91cc\u9762\u6709\u4e9b\u56fe\u6848\uff0c\u53e6\u6709\u4e00\u5757\u76f4\u63a5\u53ef\u7528\u7684\u5c0f\u9970\u6761\uff0c\u91cc\u9762\u4e5f\u6709\u4e00\u4e9b\u56fe\u6848\u3002\u5bf9\u4e8e\u7ed9\u5b9a\u7684\u82b1\u5e03\u6761\u548c\u5c0f\u9970\u6761\uff0c\u8ba1\u7b97\u4e00\u4e0b\u80fd\u4ece\u82b1\u5e03\u6761\u4e2d\u5c3d\u53ef\u80fd\u526a\u51fa\u51e0\u5757\u5c0f\u9970\u6761\u6765\u5462\uff1f \u8f93\u5165 \u00b6 \u8f93\u5165\u4e2d\u542b\u6709\u4e00\u4e9b\u6570\u636e\uff0c\u5206\u522b\u662f\u6210\u5bf9\u51fa\u73b0\u7684\u82b1\u5e03\u6761\u548c\u5c0f\u9970\u6761\uff0c\u5176\u5e03\u6761\u90fd\u662f\u7528\u53ef\u89c1ASCII\u5b57\u7b26\u8868\u793a\u7684\uff0c\u53ef\u89c1\u7684ASCII\u5b57\u7b26\u6709\u591a\u5c11\u4e2a\uff0c\u5e03\u6761\u7684\u82b1\u7eb9\u4e5f\u6709\u591a\u5c11\u79cd\u82b1\u6837\u3002\u82b1\u7eb9\u6761\u548c\u5c0f\u9970\u6761\u4e0d\u4f1a\u8d85\u8fc71000\u4e2a\u5b57\u7b26\u957f\u3002\u5982\u679c\u9047\u89c1#\u5b57\u7b26\uff0c\u5219\u4e0d\u518d\u8fdb\u884c\u5de5\u4f5c\u3002 \u8f93\u51fa \u00b6 \u8f93\u51fa\u80fd\u4ece\u82b1\u7eb9\u5e03\u4e2d\u526a\u51fa\u7684\u6700\u591a\u5c0f\u9970\u6761\u4e2a\u6570\uff0c\u5982\u679c\u4e00\u5757\u90fd\u6ca1\u6709\uff0c\u90a3\u5c31\u8001\u8001\u5b9e\u5b9e\u8f93\u51fa0\uff0c\u6bcf\u4e2a\u7ed3\u679c\u4e4b\u95f4\u5e94\u6362\u884c\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 abcde a3 aaaaaa aa # \u6837\u4f8b\u8f93\u51fa \u00b6 0 3 \u89e3\u6790 \u00b6 kmp\u6a21\u677f\u9898\u76ee\uff0c\u5339\u914d\u76f8\u540c\u7684\u5b57\u7b26\u4e32 #include <bits/stdc++.h> using namespace std ; char a [ 2005 ] = { 0 }; char str [ 2005 ] = { 0 }; int Next [ 2005 ] = { 0 }; int getNext () { int i = 0 , j = -1 ; Next [ 0 ] = -1 ; while ( a [ i ]) { if ( j == -1 || a [ i ] == a [ j ]) { i ++ ; j ++ ; Next [ i ] = j ; } else { j = Next [ j ]; } } } int main () { while ( 1 ) { scanf ( \"%s\" , str ); if ( str [ 0 ] == '#' ) break ; memset ( Next , 0 , sizeof ( Next )); scanf ( \"%s\" , a ); getNext (); int lena = strlen ( a ), lens = strlen ( str ); int j = 0 , sum = 0 , i = 0 ; while ( i <= lens ) { if ( j == -1 || str [ i ] == a [ j ]) { i ++ ; j ++ ; } else { j = Next [ j ]; } if ( j == lena ) { sum ++ ; j = 0 ; } } printf ( \"%d \\n \" , sum ); } }","title":"2020-08-01"},{"location":"csdn/2020-08-01/#_1","text":"Three friends like to play the following game. The first friend chooses a string S. Then the second friend constructs a new string T that consists of two copies of the string S. finally, the third friend inserts one letter at the beginning, the end or somewhere inside the string T, thereby creating a string U. You are given the string U and your task is to reconstruct the original string S.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-01/#_2","text":"The first line of the input contains N\uff082 \u2264 N \u2264 2000001\uff09, the length of the final string U. The string U itself is given on the second line. It consists of N uppercase English letters (A, B, C, . . . , Z).","title":"\u8f93\u5165"},{"location":"csdn/2020-08-01/#_3","text":"Your program should print the original string S. However, there are two exceptions: 1.If the final string U could not have been created using the above procedure, you should print NOT POSSIBLE. 2.If the original string S is not unique, you should print NOT UNIQUE.","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-01/#_4","text":"7 ABXCABC","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-01/#_5","text":"ABC","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-01/#_6","text":"\u5b57\u7b26\u4e32\u54c8\u5e0c\u7684\u5e94\u7528\uff0c\u6bd4\u8f83\u53bb\u9664\u4e00\u4e2a\u5b57\u6bcd\u540e\u524d\u534a\u90e8\u5206\u7684\u54c8\u5e0c\u503c\u548c\u540e\u534a\u90e8\u5206\u54c8\u5e0c\u503c\u662f\u5426\u76f8\u540c #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef unsigned long long ull ; const int N = 2e6 + 500 ; char a [ N ] = \"\" ; int base = 131 ; ull p [ N ] = { 0 }; ull h [ N ] = { 0 }; ull get ( ull l , ull r ) { return h [ r ] - h [ l -1 ] * p [ r - l + 1 ]; } int main () { int n ; scanf ( \"%d\" , & n ); if ( n % 2 == 0 ) { printf ( \"NOT POSSIBLE \\n \" ); return 0 ; } scanf ( \"%s\" , a + 1 ); p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = p [ i -1 ] * base ; for ( int i = 1 ; i <= n ; i ++ ) h [ i ] = h [ i -1 ] * base + a [ i ] - 'A' ; ull flag = 0 , ans , pos ; ///\u6ce8\u610f\u7528ull\uff0cans\u6570\u636e\u6bd4\u8f83\u5927 for ( int i = 1 ; i <= n ; i ++ ) { ull s1 , s2 ; if ( i <= n / 2 ) { s1 = h [ i -1 ] * p [ n / 2 - i + 1 ] + get ( i + 1 , n / 2 + 1 ); } else { s1 = h [ n / 2 ]; } if ( i <= n / 2 + 1 ) { s2 = get ( n - n / 2 + 1 , n ); } else { s2 = get ( n / 2 + 1 , i -1 ) * p [ n - i ] + get ( i + 1 , n ); } if ( s1 == s2 ) { if ( flag && ans != s1 ) { printf ( \"NOT UNIQUE \\n \" ); return 0 ; } ans = s1 ; pos = i ; flag = 1 ; } } if ( flag ) { for ( int i = 1 , j = 0 ; j < n / 2 ; i ++ ) { if ( i == pos ) continue ; else printf ( \"%c\" , a [ i ]), j ++ ; } printf ( \" \\n \" ); } else { printf ( \"NOT POSSIBLE \\n \" ); } } http://icpc.upc.edu.cn/problem.php?cid=1459&pid=10","title":"\u89e3\u6790"},{"location":"csdn/2020-08-01/#_7","text":"\u4e00\u5757\u82b1\u5e03\u6761\uff0c\u91cc\u9762\u6709\u4e9b\u56fe\u6848\uff0c\u53e6\u6709\u4e00\u5757\u76f4\u63a5\u53ef\u7528\u7684\u5c0f\u9970\u6761\uff0c\u91cc\u9762\u4e5f\u6709\u4e00\u4e9b\u56fe\u6848\u3002\u5bf9\u4e8e\u7ed9\u5b9a\u7684\u82b1\u5e03\u6761\u548c\u5c0f\u9970\u6761\uff0c\u8ba1\u7b97\u4e00\u4e0b\u80fd\u4ece\u82b1\u5e03\u6761\u4e2d\u5c3d\u53ef\u80fd\u526a\u51fa\u51e0\u5757\u5c0f\u9970\u6761\u6765\u5462\uff1f","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-01/#_8","text":"\u8f93\u5165\u4e2d\u542b\u6709\u4e00\u4e9b\u6570\u636e\uff0c\u5206\u522b\u662f\u6210\u5bf9\u51fa\u73b0\u7684\u82b1\u5e03\u6761\u548c\u5c0f\u9970\u6761\uff0c\u5176\u5e03\u6761\u90fd\u662f\u7528\u53ef\u89c1ASCII\u5b57\u7b26\u8868\u793a\u7684\uff0c\u53ef\u89c1\u7684ASCII\u5b57\u7b26\u6709\u591a\u5c11\u4e2a\uff0c\u5e03\u6761\u7684\u82b1\u7eb9\u4e5f\u6709\u591a\u5c11\u79cd\u82b1\u6837\u3002\u82b1\u7eb9\u6761\u548c\u5c0f\u9970\u6761\u4e0d\u4f1a\u8d85\u8fc71000\u4e2a\u5b57\u7b26\u957f\u3002\u5982\u679c\u9047\u89c1#\u5b57\u7b26\uff0c\u5219\u4e0d\u518d\u8fdb\u884c\u5de5\u4f5c\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-01/#_9","text":"\u8f93\u51fa\u80fd\u4ece\u82b1\u7eb9\u5e03\u4e2d\u526a\u51fa\u7684\u6700\u591a\u5c0f\u9970\u6761\u4e2a\u6570\uff0c\u5982\u679c\u4e00\u5757\u90fd\u6ca1\u6709\uff0c\u90a3\u5c31\u8001\u8001\u5b9e\u5b9e\u8f93\u51fa0\uff0c\u6bcf\u4e2a\u7ed3\u679c\u4e4b\u95f4\u5e94\u6362\u884c\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-01/#_10","text":"abcde a3 aaaaaa aa #","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-01/#_11","text":"0 3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-01/#_12","text":"kmp\u6a21\u677f\u9898\u76ee\uff0c\u5339\u914d\u76f8\u540c\u7684\u5b57\u7b26\u4e32 #include <bits/stdc++.h> using namespace std ; char a [ 2005 ] = { 0 }; char str [ 2005 ] = { 0 }; int Next [ 2005 ] = { 0 }; int getNext () { int i = 0 , j = -1 ; Next [ 0 ] = -1 ; while ( a [ i ]) { if ( j == -1 || a [ i ] == a [ j ]) { i ++ ; j ++ ; Next [ i ] = j ; } else { j = Next [ j ]; } } } int main () { while ( 1 ) { scanf ( \"%s\" , str ); if ( str [ 0 ] == '#' ) break ; memset ( Next , 0 , sizeof ( Next )); scanf ( \"%s\" , a ); getNext (); int lena = strlen ( a ), lens = strlen ( str ); int j = 0 , sum = 0 , i = 0 ; while ( i <= lens ) { if ( j == -1 || str [ i ] == a [ j ]) { i ++ ; j ++ ; } else { j = Next [ j ]; } if ( j == lena ) { sum ++ ; j = 0 ; } } printf ( \"%d \\n \" , sum ); } }","title":"\u89e3\u6790"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/","text":"http://icpc.upc.edu.cn/problem.php?id=3756 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u4ece\u524d\u6709\u4e00\u4e2a\u8d38\u6613\u5e02\u573a\uff0c\u5728\u4e00\u4f4d\u6267\u653f\u5b98\u5230\u6765\u4e4b\u524d\u90fd\u662f\u975e\u5e38\u7e41\u8363\u7684\uff0c\u81ea\u4ece\u4ed6\u6765\u4e86\u4e4b\u540e\uff0c\u53d1\u5e03\u4e86\u4e00\u7cfb\u5217\u5947\u602a\u7684\u653f\u4ee4\uff0c\u5bfc\u81f4\u8d38\u6613\u5e02\u573a\u7684\u8870\u843d\u3002 \u6709n\u4e2a\u5546\u8d29\uff0c\u4ece 0\u223cn\u22121\u7f16\u53f7\uff0c\u6bcf\u4e2a\u5546\u8d29\u7684\u5546\u54c1\u6709\u4e00\u4e2a\u4ef7\u683c ai\uff0c\u6709\u4e24\u79cd\u653f\u4ee4\uff1a 1.l,r,c\uff0c\u5bf9\u4e8e i\u2208[l,r],ai\u2190ai+c 2.l,r,d\uff0c\u5bf9\u4e8e i\u2208[l,r],ai\u2190\u230aai/d\u230b,ai \u2190\u230aai/d\u230b \u73b0\u5728\u6709\u4e00\u4e2a\u5916\u4e61\u7684\u65c5\u5ba2\u60f3\u8981\u4e86\u89e3\u8d38\u6613\u5e02\u573a\u7684\u4fe1\u606f\uff0c\u6709\u4e24\u79cd\u8be2\u95ee\u65b9\u5f0f\uff1a 1.\u7ed9\u5b9a l,r\uff0c\u6c42 mini\u2208[l,r]ai 2.\u7ed9\u5b9a l,r\uff0c\u6c42 \u2211i\u2208[l,r]ai \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e3a\u4e24\u4e2a\u7a7a\u683c\u9694\u5f00\u7684\u6574\u6570 n,q\u5206\u522b\u8868\u793a\u5546\u8d29\u4e2a\u6570\u548c\u653f\u4ee4 + \u8be2\u95ee\u4e2a\u6570\u3002 \u7b2c\u4e8c\u884c\u5305\u542bn\u4e2a\u7531\u7a7a\u683c\u9694\u5f00\u7684\u6574\u6570 a0\u223can\u22121 \u63a5\u4e0b\u6765q\u884c\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u64cd\u4f5c\uff0c\u7b2c\u4e00\u4e2a\u6570\u8868\u793a\u64cd\u4f5c\u7f16\u53f7 1\u223c4\u63a5\u4e0b\u6765\u7684\u8f93\u5165\u548c\u95ee\u9898\u63cf\u8ff0\u4e00\u81f4\u3002 \u8f93\u51fa \u00b6 \u5bf9\u4e8e\u6bcf\u4e2a 3\u30014 \u64cd\u4f5c\uff0c\u8f93\u51fa\u8be2\u95ee\u7b54\u6848\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 10 10 -5 -4 -3 -2 -1 0 1 2 3 4 1 0 4 1 1 5 9 1 2 0 9 3 3 0 9 4 0 9 3 0 1 4 2 3 3 4 5 4 6 7 3 8 9 \u6837\u4f8b\u8f93\u51fa \u00b6 -2 -2 -2 -2 0 1 1 \u8fd9\u9053\u9898\u76ee\u4e3b\u8981\u8003\u67e5\u4e86\u7ebf\u6bb5\u6811\u7684\u6807\u8bb0\u548c\u4e0b\u653e\u53ca\u5c06\u9664\u6cd5\u8f6c\u4e3a\u51cf\u6cd5\u7684\u601d\u60f3\uff0c\u7edf\u8ba1\u6bcf\u4e00\u6bb5\u7684max\u548cmin\uff0c\u5224\u65ad\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u7ecf\u8fc7\u9664\u6cd5\u4ee5\u540e\u6240\u51cf\u6389\u7684\u6570\u5b57\u662f\u5426\u76f8\u540c\uff0c\u5982\u679c\u76f8\u540c\uff0c\u5219\u8fd9\u4e00\u6bb5\u90fd\u53ef\u4ee5\u51cf\u6389\u8fd9\u4e2a\u6570\u5b57\uff0c\u4e0b\u653e\u6807\u8bb0\u5373\u53ef\u3002 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f using namespace std ; typedef long long ll ; ll num [ 400500 ] = { 0 }; ll sum [ 400500 ] = { 0 }; ll minn [ 400500 ] = { 0 }; ll maxx [ 400500 ] = { 0 }; ll lazy [ 400500 ] = { 0 }; ll pushup ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; maxx [ t ] = max ( maxx [ 2 * t ], maxx [ 2 * t + 1 ]); minn [ t ] = min ( minn [ 2 * t ], minn [ 2 * t + 1 ]); } ll pushlazy ( ll t , ll lz , ll len ) { sum [ t ] += lz * len ; minn [ t ] += lz ; maxx [ t ] += lz ; lazy [ t ] += lz ; } ll pushdown ( ll l , ll r , ll t ) { if ( lazy [ t ] != 0 ) { ll mid = ( l + r ) / 2 ; pushlazy ( 2 * t , lazy [ t ], mid - l + 1 ); pushlazy ( 2 * t + 1 , lazy [ t ], r - mid ); lazy [ t ] = 0 ; } } ll build ( ll l , ll r , ll t ) { lazy [ t ] = 0 ; if ( l == r ) { sum [ t ] = minn [ t ] = maxx [ t ] = num [ l ]; return 0 ; } ll mid = ( l + r ) / 2 ; build ( l , mid , t * 2 ); build ( mid + 1 , r , 2 * t + 1 ); pushup ( t ); } ll add ( ll x , ll l , ll r , ll L , ll R , ll t ) { if ( l >= L && r <= R ) { lazy [ t ] += x ; sum [ t ] += ( r - l + 1 ) * x ; minn [ t ] += x ; maxx [ t ] += x ; return 0 ; } pushdown ( l , r , t ); ll mid = ( l + r ) / 2 ; if ( L <= mid ) add ( x , l , mid , L , R , 2 * t ); if ( R > mid ) add ( x , mid + 1 , r , L , R , 2 * t + 1 ); pushup ( t ); } ll div ( ll x , ll l , ll r , ll L , ll R , ll t ) { if ( l >= L && r <= R ) { ll A , B ; if ( minn [ t ] < 0 ) A = ( minn [ t ] - x + 1 ) / x ; else A = minn [ t ] / x ; if ( maxx [ t ] < 0 ) B = ( maxx [ t ] - x + 1 ) / x ; else B = maxx [ t ] / x ; if ( A - minn [ t ] == B - maxx [ t ]) { pushlazy ( t , B - maxx [ t ], r - l + 1 ); return 0 ; } } pushdown ( l , r , t ); ll mid = ( l + r ) / 2 ; if ( L <= mid ) div ( x , l , mid , L , R , 2 * t ); if ( R > mid ) div ( x , mid + 1 , r , L , R , 2 * t + 1 ); pushup ( t ); } ll querysum ( ll l , ll r , ll L , ll R , ll t ) { if ( l >= L && r <= R ) return sum [ t ]; pushdown ( l , r , t ); ll mid = ( l + r ) / 2 ; ll ans = 0 ; if ( L <= mid ) ans += querysum ( l , mid , L , R , 2 * t ); if ( R > mid ) ans += querysum ( mid + 1 , r , L , R , 2 * t + 1 ); return ans ; } ll querymin ( ll l , ll r , ll L , ll R , ll t ) { if ( l >= L && r <= R ) return minn [ t ]; pushdown ( l , r , t ); ll mid = ( l + r ) / 2 ; ll ans = inf ; if ( L <= mid ) ans = min ( querymin ( l , mid , L , R , 2 * t ), ans ); if ( R > mid ) ans = min ( querymin ( mid + 1 , r , L , R , 2 * t + 1 ), ans ); return ans ; } int main () { ll n , m , a , b , c , d ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & num [ i ]); build ( 1 , n , 1 ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & a ); if ( a == 1 ) { scanf ( \"%lld%lld%lld\" , & b , & c , & d ); add ( d , 1 , n , b + 1 , c + 1 , 1 ); } else if ( a == 2 ) { scanf ( \"%lld%lld%lld\" , & b , & c , & d ); div ( d , 1 , n , b + 1 , c + 1 , 1 ); } else if ( a == 3 ) { scanf ( \"%lld%lld\" , & b , & c ); printf ( \"%lld \\n \" , querymin ( 1 , n , b + 1 , c + 1 , 1 )); } else { scanf ( \"%lld%lld\" , & b , & c ); printf ( \"%lld \\n \" , querysum ( 1 , n , b + 1 , c + 1 , 1 )); } } } http://icpc.upc.edu.cn/problem.php?cid=2512&pid=4 \u9898\u76ee\u63cf\u8ff0 \u00b6 licunchun \u5728\u5212\u6c34\u3002 licunchun \u6700\u8fd1\u8ff7\u4e0a\u4e86\u4e00\u6b3e\u6253\u602a\u517d\u7684\u6e38\u620f\u3002 n\u4e2a\u602a\u517d\u7ad9\u6210\u4e86\u4e00\u6392\uff0c\u6bcf\u4e2a\u602a\u517d\u90fd\u6709\u4e00\u4e2a\u9632\u5fa1\u503cai\u3002 licunchun \u4f1a\u6309\u7167\u4e00\u79cd\u5947\u602a\u7684\u987a\u5e8f\u6253\u602a\u517d\u3002 \u5bf9\u4e8e\u6bcf\u4e00\u6b21\u6253\u602a\u517d\uff0clicunchun \u9700\u8981\u627e\u5230\u602a\u517d\u5e8f\u5217\u4e2d\u51fa\u73b0\u6b21\u6570\u5927\u4e8e\u7b49\u4e8e2\u7684\u9632\u5fa1\u6700\u5c0f\u503cx\uff0c\u627e\u5230x\u76842\u4e2a\u6700\u5c0f\u4e0b\u6807i,j\uff0c\u5c06\u7b2ci\u4e2a\u602a\u517d\u6253\u6b7b\u5e76\u4ece\u5e8f\u5217\u4e2d\u9664\u53bb\uff0c\u5c06\u7b2cj\u4e2a\u602a\u517d\u7684\u9632\u5fa1\u503caj\u6539\u4e3a2x\u3002 licunchun \u60f3\u77e5\u9053\uff0c\u5728\u53cd\u590d\u8fdb\u884c\u6253\u602a\u517d\u540e\uff0c\u602a\u517d\u5e8f\u5217\u7684\u6700\u7ec8\u72b6\u6001\u662f\u600e\u6837\u7684\u3002 \u8f93\u5165 \u00b6 \u51712\u884c\u3002 \u7b2c1\u884c\uff0c\u8f93\u5165\u6b63\u6574\u6570n\uff0c\u8868\u793a\u602a\u517d\u4e2a\u6570\u3002 \u7b2c1\u884c\uff0c\u8f93\u5165\u7b2ci\u4e2a\u602a\u517d\u7684\u9632\u5fa1\u503cai\u3002 \u8f93\u51fa \u00b6 \u51712\u884c\u3002 \u7b2c1\u884c\uff0c\u8f93\u51fa\u5269\u4f59\u602a\u517d\u4e2a\u6570ans\u3002 \u7b2c2\u884c\uff0c\u5171ans\u6570\uff0c\u6309\u987a\u5e8f\u8f93\u51fa\u4ecd\u7136\u5728\u602a\u517d\u5e8f\u5217\u4e2d\u7684\u602a\u517d\u7684\u9632\u5fa1\u503cai\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 7 3 4 1 2 2 1 1 \u6837\u4f8b\u8f93\u51fa \u00b6 4 3 8 2 1 \u63d0\u793a \u7b80\u5355\u7684\u6a21\u62df\uff0cpriority_queue\u548cpair\u7ed3\u5408\u8d77\u6765\u4f7f\u7528 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 155000 ] = { 0 }; typedef pair < ll , ll > node_pair ; priority_queue < node_pair , vector < node_pair > , greater < node_pair > > q ; int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); q . push ( make_pair ( a [ i ], i )); } while ( q . size () != 1 ) { node_pair b1 = q . top (); q . pop (); node_pair b2 = q . top (); if ( b1 . first == b2 . first ) { a [ b2 . second ] *= 2 ; a [ b1 . second ] = -1 ; q . pop (); q . push ( make_pair ( a [ b2 . second ], b2 . second )); } } queue < ll > w ; for ( ll i = 1 ; i <= n ; i ++ ) { if ( a [ i ] != -1 ) w . push ( a [ i ]); } printf ( \"%d \\n \" , w . size ()); while ( ! w . empty ()) { printf ( \"%lld \" , w . front ()); w . pop (); } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2512&pid=6 \u9898\u76ee\u63cf\u8ff0 \u00b6 licunchun \u627e\u5230\u4e86\u4e00\u5f20\u753b\u3002 licunchun \u5b66\u4e60\u4e86\u819c\u6cd5\uff0c\u60f3\u8981\u4e00\u5757\u4e00\u5757\u5730\uff0c\u8ba9\u91cc\u9762\u7684\u989c\u8272\u6d88\u5931\u3002 \u7167\u7247\u7684\u989c\u8272\u53ea\u6709\u4e00\u884c\u3002licunchun \u6bcf\u6b21\u53ef\u4ee5\u9009\u62e9\u4e2d\u95f4\u4e00\u6bb5\u76f8\u540c\u989c\u8272\u7684\u4e00\u6bb5\u76f4\u63a5\u8ba9\u5b83\u6d88\u5931\u3002 licunchun \u60f3\u77e5\u9053\u6240\u9700\u8981\u7684\u6700\u5c11\u6b21\u6570\u3002 licunchun \u51a5\u601d\u82e6\u60f3\u4e861145141919810\u90fd\u6ca1\u6709\u60f3\u51fa\u6765\uff0c\u4e8e\u662f\u628a\u95ee\u9898\u4ea4\u7ed9\u4e86\u4f60\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u8f93\u5165T\uff0c\u8868\u793a\u6570\u636e\u7ec4\u6570 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff1a \u7b2c\u4e00\u884c\u7ed9\u5b9a\u4e00\u4e2an\uff0c\u8868\u793a\u7167\u7247\u7684\u957f\u5ea6\u3002 \u7b2c\u4e8c\u884c\uff0c\u7ed9\u5b9a\u4e00\u4e32s\uff0c\u7528\u6765\u63cf\u8ff0\u8fd9\u4e2a\u7167\u7247\u7684\u989c\u8272\u3002\u4e3a\u4e86\u65b9\u4fbf\uff0c\u989c\u8272\u7684\u63cf\u8ff0\u7edf\u4e00\u7528\u5c0f\u5199\u5b57\u6bcd\uff0c\u4e00\u79cd\u5b57\u6bcd\u8868\u793a\u4e00\u79cd\u989c\u8272\u3002 \u8f93\u51fa \u00b6 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636eT\uff0c\u4e00\u884c\u8f93\u51fa\u4e00\u4e2a\u6570\u5b57\uff0c\u8868\u793a\u6240\u9700\u8981\u7684\u6700\u5c11\u6b21\u6570\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 3 5 abaca 8 abcddcba 7 lggmmro \u6837\u4f8b\u8f93\u51fa \u00b6 3 4 5 \u63d0\u793a \u00b6 \u52a8\u6001\u89c4\u5212\uff0cdp[i][j]\u4ee3\u8868\u4ee5i\u4e3a\u5f00\u5934\u957f\u5ea6\u4e3aj\u7684\u6700\u5c11\u64cd\u4f5c\u6b21\u6570\uff0c\u6700\u540edp[1][n]\u5373\u4e3a\u7b54\u6848\u3002 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int dp [ 600 ][ 600 ] = { 0 }; char a [ 600 ] = \"\" ; const int inf = 0x3f3f3f ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { memset ( dp , inf , sizeof ( dp )); int n ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , a + 1 ); for ( int i = 1 ; i <= n ; i ++ ) dp [ i ][ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n - i + 1 ; j ++ ) { if ( a [ j ] == a [ i + j -1 ]) { dp [ j ][ i ] = min ( dp [ j ][ i -1 ], dp [ j + 1 ][ i -1 ]); } else { dp [ j ][ i ] = min ( dp [ j ][ i -1 ], dp [ j + 1 ][ i -1 ]) + 1 ; } for ( int k = 1 ; k <= i ; k ++ ) { dp [ j ][ i ] = min ( dp [ j ][ i ], dp [ j ][ k ] + dp [ j + k ][ i - k ]); } } } cout << dp [ 1 ][ n ] << endl ; } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2512&pid=2 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u795e\u4ed9\u59d0\u59d0\u9047\u5230\u4e00\u4e2a\u96be\u9898\uff1a \u6709\u5b9d\u85cf\u51fa\u73b0\u5728\u59d0\u59d0\u9762\u524d\u540e\uff0c\u53c8\u51fa\u73b0\u4e00\u884c\u5b57\u8bf4\u201c\u8fd9\u91cc\u7684\u5404\u79cd\u7c7b\u578b\u7684\u5b9d\u7269\u662f\u653e\u5728\u957f\u65b9\u5f62\u7684\u77f3\u684c\u4e0a\uff0c\u4f60\u53ea\u80fd\u4e00\u6b21\u6027\u62ff\u8d70\u540c\u4e00\u79cd\u7c7b\u578b\u7684\u5b9d\u7269\uff0c\u5e76\u4e14\u8981\u6c42\u4f60\u62ff\u8d70\u7684\u5b9d\u7269\u5fc5\u987b\u4e3a\u67d0\u4e2a\u6b63\u65b9\u5f62\u5b50\u77e9\u9635\u4e2d\u67d0\u6761\u5bf9\u89d2\u7ebf\uff0c\u800c\u4e14\u6b64\u65f6\uff0c\u4f60\u6240\u9009\u62e9\u7684\u8fd9\u4e2a\u6b63\u65b9\u5f62\u5b50\u77e9\u9635\u4e2d\uff0c\u9664\u4e86\u5bf9\u89d2\u7ebf\u4f4d\u7f6e\uff0c\u5176\u5b83\u4f4d\u7f6e\u4e0d\u80fd\u51fa\u73b0\u4f60\u6240\u9700\u8981\u7684\u5b9d\u7269\u7c7b\u578b\uff08\u56e0\u4e3a\u8fd9\u6837\u4f1a\u5206\u5fc3\uff09\uff01\u4f60\u53ef\u4ee5\u628a\u77f3\u684c\u89c6\u4e3a01\u77e9\u9635\uff080\u8868\u793a\u5bf9\u5e94\u4f4d\u7f6e\u4e0d\u662f\u4f60\u6240\u8981\u7684\u7c7b\u578b\uff0c1\u8868\u793a\u5bf9\u5e94\u4f4d\u7f6e\u6709\u4f60\u6240\u8981\u7684\u7c7b\u578b\uff0c\u8fd9\u6837\u6709\u52a9\u4e8e\u4f60\u591a\u62ff\u4e9b\u5b9d\u7269\uff09\u201d\u3002 \u5f53\u7136\u7231\u7f8e\u7684\u59d0\u59d0\u9009\u62e9\u7684\u662f\u53ef\u4ee5\u7f8e\u5bb9\u517b\u989c\u7c7b\u578b\u7684\uff0c\u6240\u4ee5\u5979\u628a\u6240\u60f3\u8981\u7684\u5b9d\u7269(\u5373\u7f8e\u5bb9\u6c34)\u7528\uff11\u8868\u793a\uff0c\u4e0d\u60f3\u8981\u7684\u5c31\u75280\u8868\u793a\u3002\u540c\u65f6\u59d0\u59d0\u662f\u4e2a\u5f88\u8d2a\u5a6a(\u8d2a\u7f8e)\u7684\u795e\u4ed9\uff0c\u6240\u4ee5\u5979\u60f3\u4e00\u4e0b\u62ff\u8d70\u5c3d\u91cf\u591a\u7684\u5979\u6240\u8981\u7684\u7f8e\u5bb9\u54c1\u3002\u8bf7\u4f60\u5e2e\u795e\u4ed9\u59d0\u59d0\u7b97\u4e00\u4e0b\uff0c\u5979\u4e00\u4e0b\u6700\u591a\u53ef\u4ee5\u62ff\u591a\u5c11\u4e2a\uff1f \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u6709\u4e24\u4e2a\u6574\u6570n\u548cm\uff08n\uff0cm\u22651\uff09\uff0c\u63cf\u8ff0\u77f3\u684c\u7684\u89c4\u6a21\u3002\u63a5\u4e0b\u6765\u7684n\u884c\uff0c\u6bcf\u884c\u6709m\u4e2a\u6570\u5b57\uff08\u975e\u201c0\u201d\u5373\u201c1\u201d\uff09\u3002\u6bcf\u4e24\u4e2a\u6570\u5b57\u4e4b\u95f4\u7528\u7a7a\u683c\u9694\u5f00\u3002 \u8f93\u51fa \u00b6 \u53ea\u6709\u4e00\u4e2a\u6574\u6570\u2014\u2014\u795e\u4ed9\u4e00\u4e0b\u6700\u591a\u53ef\u4ee5\u62ff\u5230\u591a\u5c11\u4e2a\u5b9d\u7269\uff0c\u5360\u4e00\u884c\uff0c\u884c\u672b\u6709\u56de\u8f66\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 4 6 0 1 0 1 0 0 0 0 1 0 1 0 1 1 0 0 0 1 0 1 1 0 1 0 \u6837\u4f8b\u8f93\u51fa \u00b6 3 \u63d0\u793a \u00b6 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c\u6709n\uff0cm\u22642500 \u4e8c\u7ef4\u524d\u7f00\u548c #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int a [ 2550 ][ 2550 ] = { 0 }; int d [ 2550 ][ 2550 ] = { 0 }; int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]); d [ i ][ j ] = d [ i -1 ][ j ] + d [ i ][ j -1 ] - d [ i -1 ][ j -1 ] + a [ i ][ j ]; } } int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int cnt = 0 ; while ( i + cnt <= n && j + cnt <= m && a [ i ][ j ] && a [ i + cnt ][ j + cnt ]) { int k1 = d [ i + cnt ][ j + cnt ] - d [ i -1 ][ j + cnt ] - d [ i + cnt ][ j -1 ] + d [ i -1 ][ j -1 ]; int k2 = d [ i + cnt -1 ][ j + cnt -1 ] - d [ i -1 ][ j + cnt -1 ] - d [ i + cnt -1 ][ j -1 ] + d [ i -1 ][ j -1 ]; if ( k1 == cnt + 1 && k1 - k2 == 1 ) { max1 = max ( max1 , cnt + 1 ); cnt ++ ; } else break ; } cnt = 0 ; while ( i + cnt <= n && j - cnt >= 1 && a [ i ][ j ] && a [ i + cnt ][ j - cnt ]) { int k1 = d [ i + cnt ][ j ] - d [ i -1 ][ j ] - d [ i + cnt ][ j - cnt -1 ] + d [ i -1 ][ j -1 - cnt ]; int k2 = d [ i + cnt -1 ][ j ] - d [ i -1 ][ j ] - d [ i + cnt -1 ][ j - cnt ] + d [ i -1 ][ j - cnt ]; if ( k1 == cnt + 1 && k1 - k2 == 1 ) { max1 = max ( max1 , cnt + 1 ); cnt ++ ; } else break ; } } } cout << max1 << endl ; return 0 ; }","title":"2020 08 02 \u7ebf\u6bb5\u6811"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_1","text":"\u4ece\u524d\u6709\u4e00\u4e2a\u8d38\u6613\u5e02\u573a\uff0c\u5728\u4e00\u4f4d\u6267\u653f\u5b98\u5230\u6765\u4e4b\u524d\u90fd\u662f\u975e\u5e38\u7e41\u8363\u7684\uff0c\u81ea\u4ece\u4ed6\u6765\u4e86\u4e4b\u540e\uff0c\u53d1\u5e03\u4e86\u4e00\u7cfb\u5217\u5947\u602a\u7684\u653f\u4ee4\uff0c\u5bfc\u81f4\u8d38\u6613\u5e02\u573a\u7684\u8870\u843d\u3002 \u6709n\u4e2a\u5546\u8d29\uff0c\u4ece 0\u223cn\u22121\u7f16\u53f7\uff0c\u6bcf\u4e2a\u5546\u8d29\u7684\u5546\u54c1\u6709\u4e00\u4e2a\u4ef7\u683c ai\uff0c\u6709\u4e24\u79cd\u653f\u4ee4\uff1a 1.l,r,c\uff0c\u5bf9\u4e8e i\u2208[l,r],ai\u2190ai+c 2.l,r,d\uff0c\u5bf9\u4e8e i\u2208[l,r],ai\u2190\u230aai/d\u230b,ai \u2190\u230aai/d\u230b \u73b0\u5728\u6709\u4e00\u4e2a\u5916\u4e61\u7684\u65c5\u5ba2\u60f3\u8981\u4e86\u89e3\u8d38\u6613\u5e02\u573a\u7684\u4fe1\u606f\uff0c\u6709\u4e24\u79cd\u8be2\u95ee\u65b9\u5f0f\uff1a 1.\u7ed9\u5b9a l,r\uff0c\u6c42 mini\u2208[l,r]ai 2.\u7ed9\u5b9a l,r\uff0c\u6c42 \u2211i\u2208[l,r]ai","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_2","text":"\u7b2c\u4e00\u884c\u4e3a\u4e24\u4e2a\u7a7a\u683c\u9694\u5f00\u7684\u6574\u6570 n,q\u5206\u522b\u8868\u793a\u5546\u8d29\u4e2a\u6570\u548c\u653f\u4ee4 + \u8be2\u95ee\u4e2a\u6570\u3002 \u7b2c\u4e8c\u884c\u5305\u542bn\u4e2a\u7531\u7a7a\u683c\u9694\u5f00\u7684\u6574\u6570 a0\u223can\u22121 \u63a5\u4e0b\u6765q\u884c\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u64cd\u4f5c\uff0c\u7b2c\u4e00\u4e2a\u6570\u8868\u793a\u64cd\u4f5c\u7f16\u53f7 1\u223c4\u63a5\u4e0b\u6765\u7684\u8f93\u5165\u548c\u95ee\u9898\u63cf\u8ff0\u4e00\u81f4\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_3","text":"\u5bf9\u4e8e\u6bcf\u4e2a 3\u30014 \u64cd\u4f5c\uff0c\u8f93\u51fa\u8be2\u95ee\u7b54\u6848\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_4","text":"10 10 -5 -4 -3 -2 -1 0 1 2 3 4 1 0 4 1 1 5 9 1 2 0 9 3 3 0 9 4 0 9 3 0 1 4 2 3 3 4 5 4 6 7 3 8 9","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_5","text":"-2 -2 -2 -2 0 1 1 \u8fd9\u9053\u9898\u76ee\u4e3b\u8981\u8003\u67e5\u4e86\u7ebf\u6bb5\u6811\u7684\u6807\u8bb0\u548c\u4e0b\u653e\u53ca\u5c06\u9664\u6cd5\u8f6c\u4e3a\u51cf\u6cd5\u7684\u601d\u60f3\uff0c\u7edf\u8ba1\u6bcf\u4e00\u6bb5\u7684max\u548cmin\uff0c\u5224\u65ad\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u7ecf\u8fc7\u9664\u6cd5\u4ee5\u540e\u6240\u51cf\u6389\u7684\u6570\u5b57\u662f\u5426\u76f8\u540c\uff0c\u5982\u679c\u76f8\u540c\uff0c\u5219\u8fd9\u4e00\u6bb5\u90fd\u53ef\u4ee5\u51cf\u6389\u8fd9\u4e2a\u6570\u5b57\uff0c\u4e0b\u653e\u6807\u8bb0\u5373\u53ef\u3002 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f using namespace std ; typedef long long ll ; ll num [ 400500 ] = { 0 }; ll sum [ 400500 ] = { 0 }; ll minn [ 400500 ] = { 0 }; ll maxx [ 400500 ] = { 0 }; ll lazy [ 400500 ] = { 0 }; ll pushup ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; maxx [ t ] = max ( maxx [ 2 * t ], maxx [ 2 * t + 1 ]); minn [ t ] = min ( minn [ 2 * t ], minn [ 2 * t + 1 ]); } ll pushlazy ( ll t , ll lz , ll len ) { sum [ t ] += lz * len ; minn [ t ] += lz ; maxx [ t ] += lz ; lazy [ t ] += lz ; } ll pushdown ( ll l , ll r , ll t ) { if ( lazy [ t ] != 0 ) { ll mid = ( l + r ) / 2 ; pushlazy ( 2 * t , lazy [ t ], mid - l + 1 ); pushlazy ( 2 * t + 1 , lazy [ t ], r - mid ); lazy [ t ] = 0 ; } } ll build ( ll l , ll r , ll t ) { lazy [ t ] = 0 ; if ( l == r ) { sum [ t ] = minn [ t ] = maxx [ t ] = num [ l ]; return 0 ; } ll mid = ( l + r ) / 2 ; build ( l , mid , t * 2 ); build ( mid + 1 , r , 2 * t + 1 ); pushup ( t ); } ll add ( ll x , ll l , ll r , ll L , ll R , ll t ) { if ( l >= L && r <= R ) { lazy [ t ] += x ; sum [ t ] += ( r - l + 1 ) * x ; minn [ t ] += x ; maxx [ t ] += x ; return 0 ; } pushdown ( l , r , t ); ll mid = ( l + r ) / 2 ; if ( L <= mid ) add ( x , l , mid , L , R , 2 * t ); if ( R > mid ) add ( x , mid + 1 , r , L , R , 2 * t + 1 ); pushup ( t ); } ll div ( ll x , ll l , ll r , ll L , ll R , ll t ) { if ( l >= L && r <= R ) { ll A , B ; if ( minn [ t ] < 0 ) A = ( minn [ t ] - x + 1 ) / x ; else A = minn [ t ] / x ; if ( maxx [ t ] < 0 ) B = ( maxx [ t ] - x + 1 ) / x ; else B = maxx [ t ] / x ; if ( A - minn [ t ] == B - maxx [ t ]) { pushlazy ( t , B - maxx [ t ], r - l + 1 ); return 0 ; } } pushdown ( l , r , t ); ll mid = ( l + r ) / 2 ; if ( L <= mid ) div ( x , l , mid , L , R , 2 * t ); if ( R > mid ) div ( x , mid + 1 , r , L , R , 2 * t + 1 ); pushup ( t ); } ll querysum ( ll l , ll r , ll L , ll R , ll t ) { if ( l >= L && r <= R ) return sum [ t ]; pushdown ( l , r , t ); ll mid = ( l + r ) / 2 ; ll ans = 0 ; if ( L <= mid ) ans += querysum ( l , mid , L , R , 2 * t ); if ( R > mid ) ans += querysum ( mid + 1 , r , L , R , 2 * t + 1 ); return ans ; } ll querymin ( ll l , ll r , ll L , ll R , ll t ) { if ( l >= L && r <= R ) return minn [ t ]; pushdown ( l , r , t ); ll mid = ( l + r ) / 2 ; ll ans = inf ; if ( L <= mid ) ans = min ( querymin ( l , mid , L , R , 2 * t ), ans ); if ( R > mid ) ans = min ( querymin ( mid + 1 , r , L , R , 2 * t + 1 ), ans ); return ans ; } int main () { ll n , m , a , b , c , d ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & num [ i ]); build ( 1 , n , 1 ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & a ); if ( a == 1 ) { scanf ( \"%lld%lld%lld\" , & b , & c , & d ); add ( d , 1 , n , b + 1 , c + 1 , 1 ); } else if ( a == 2 ) { scanf ( \"%lld%lld%lld\" , & b , & c , & d ); div ( d , 1 , n , b + 1 , c + 1 , 1 ); } else if ( a == 3 ) { scanf ( \"%lld%lld\" , & b , & c ); printf ( \"%lld \\n \" , querymin ( 1 , n , b + 1 , c + 1 , 1 )); } else { scanf ( \"%lld%lld\" , & b , & c ); printf ( \"%lld \\n \" , querysum ( 1 , n , b + 1 , c + 1 , 1 )); } } } http://icpc.upc.edu.cn/problem.php?cid=2512&pid=4","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_6","text":"licunchun \u5728\u5212\u6c34\u3002 licunchun \u6700\u8fd1\u8ff7\u4e0a\u4e86\u4e00\u6b3e\u6253\u602a\u517d\u7684\u6e38\u620f\u3002 n\u4e2a\u602a\u517d\u7ad9\u6210\u4e86\u4e00\u6392\uff0c\u6bcf\u4e2a\u602a\u517d\u90fd\u6709\u4e00\u4e2a\u9632\u5fa1\u503cai\u3002 licunchun \u4f1a\u6309\u7167\u4e00\u79cd\u5947\u602a\u7684\u987a\u5e8f\u6253\u602a\u517d\u3002 \u5bf9\u4e8e\u6bcf\u4e00\u6b21\u6253\u602a\u517d\uff0clicunchun \u9700\u8981\u627e\u5230\u602a\u517d\u5e8f\u5217\u4e2d\u51fa\u73b0\u6b21\u6570\u5927\u4e8e\u7b49\u4e8e2\u7684\u9632\u5fa1\u6700\u5c0f\u503cx\uff0c\u627e\u5230x\u76842\u4e2a\u6700\u5c0f\u4e0b\u6807i,j\uff0c\u5c06\u7b2ci\u4e2a\u602a\u517d\u6253\u6b7b\u5e76\u4ece\u5e8f\u5217\u4e2d\u9664\u53bb\uff0c\u5c06\u7b2cj\u4e2a\u602a\u517d\u7684\u9632\u5fa1\u503caj\u6539\u4e3a2x\u3002 licunchun \u60f3\u77e5\u9053\uff0c\u5728\u53cd\u590d\u8fdb\u884c\u6253\u602a\u517d\u540e\uff0c\u602a\u517d\u5e8f\u5217\u7684\u6700\u7ec8\u72b6\u6001\u662f\u600e\u6837\u7684\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_7","text":"\u51712\u884c\u3002 \u7b2c1\u884c\uff0c\u8f93\u5165\u6b63\u6574\u6570n\uff0c\u8868\u793a\u602a\u517d\u4e2a\u6570\u3002 \u7b2c1\u884c\uff0c\u8f93\u5165\u7b2ci\u4e2a\u602a\u517d\u7684\u9632\u5fa1\u503cai\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_8","text":"\u51712\u884c\u3002 \u7b2c1\u884c\uff0c\u8f93\u51fa\u5269\u4f59\u602a\u517d\u4e2a\u6570ans\u3002 \u7b2c2\u884c\uff0c\u5171ans\u6570\uff0c\u6309\u987a\u5e8f\u8f93\u51fa\u4ecd\u7136\u5728\u602a\u517d\u5e8f\u5217\u4e2d\u7684\u602a\u517d\u7684\u9632\u5fa1\u503cai\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_9","text":"7 3 4 1 2 2 1 1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_10","text":"4 3 8 2 1 \u63d0\u793a \u7b80\u5355\u7684\u6a21\u62df\uff0cpriority_queue\u548cpair\u7ed3\u5408\u8d77\u6765\u4f7f\u7528 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 155000 ] = { 0 }; typedef pair < ll , ll > node_pair ; priority_queue < node_pair , vector < node_pair > , greater < node_pair > > q ; int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); q . push ( make_pair ( a [ i ], i )); } while ( q . size () != 1 ) { node_pair b1 = q . top (); q . pop (); node_pair b2 = q . top (); if ( b1 . first == b2 . first ) { a [ b2 . second ] *= 2 ; a [ b1 . second ] = -1 ; q . pop (); q . push ( make_pair ( a [ b2 . second ], b2 . second )); } } queue < ll > w ; for ( ll i = 1 ; i <= n ; i ++ ) { if ( a [ i ] != -1 ) w . push ( a [ i ]); } printf ( \"%d \\n \" , w . size ()); while ( ! w . empty ()) { printf ( \"%lld \" , w . front ()); w . pop (); } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2512&pid=6","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_11","text":"licunchun \u627e\u5230\u4e86\u4e00\u5f20\u753b\u3002 licunchun \u5b66\u4e60\u4e86\u819c\u6cd5\uff0c\u60f3\u8981\u4e00\u5757\u4e00\u5757\u5730\uff0c\u8ba9\u91cc\u9762\u7684\u989c\u8272\u6d88\u5931\u3002 \u7167\u7247\u7684\u989c\u8272\u53ea\u6709\u4e00\u884c\u3002licunchun \u6bcf\u6b21\u53ef\u4ee5\u9009\u62e9\u4e2d\u95f4\u4e00\u6bb5\u76f8\u540c\u989c\u8272\u7684\u4e00\u6bb5\u76f4\u63a5\u8ba9\u5b83\u6d88\u5931\u3002 licunchun \u60f3\u77e5\u9053\u6240\u9700\u8981\u7684\u6700\u5c11\u6b21\u6570\u3002 licunchun \u51a5\u601d\u82e6\u60f3\u4e861145141919810\u90fd\u6ca1\u6709\u60f3\u51fa\u6765\uff0c\u4e8e\u662f\u628a\u95ee\u9898\u4ea4\u7ed9\u4e86\u4f60\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_12","text":"\u7b2c\u4e00\u884c\u8f93\u5165T\uff0c\u8868\u793a\u6570\u636e\u7ec4\u6570 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff1a \u7b2c\u4e00\u884c\u7ed9\u5b9a\u4e00\u4e2an\uff0c\u8868\u793a\u7167\u7247\u7684\u957f\u5ea6\u3002 \u7b2c\u4e8c\u884c\uff0c\u7ed9\u5b9a\u4e00\u4e32s\uff0c\u7528\u6765\u63cf\u8ff0\u8fd9\u4e2a\u7167\u7247\u7684\u989c\u8272\u3002\u4e3a\u4e86\u65b9\u4fbf\uff0c\u989c\u8272\u7684\u63cf\u8ff0\u7edf\u4e00\u7528\u5c0f\u5199\u5b57\u6bcd\uff0c\u4e00\u79cd\u5b57\u6bcd\u8868\u793a\u4e00\u79cd\u989c\u8272\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_13","text":"\u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636eT\uff0c\u4e00\u884c\u8f93\u51fa\u4e00\u4e2a\u6570\u5b57\uff0c\u8868\u793a\u6240\u9700\u8981\u7684\u6700\u5c11\u6b21\u6570\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_14","text":"3 5 abaca 8 abcddcba 7 lggmmro","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_15","text":"3 4 5","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_16","text":"\u52a8\u6001\u89c4\u5212\uff0cdp[i][j]\u4ee3\u8868\u4ee5i\u4e3a\u5f00\u5934\u957f\u5ea6\u4e3aj\u7684\u6700\u5c11\u64cd\u4f5c\u6b21\u6570\uff0c\u6700\u540edp[1][n]\u5373\u4e3a\u7b54\u6848\u3002 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int dp [ 600 ][ 600 ] = { 0 }; char a [ 600 ] = \"\" ; const int inf = 0x3f3f3f ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { memset ( dp , inf , sizeof ( dp )); int n ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , a + 1 ); for ( int i = 1 ; i <= n ; i ++ ) dp [ i ][ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n - i + 1 ; j ++ ) { if ( a [ j ] == a [ i + j -1 ]) { dp [ j ][ i ] = min ( dp [ j ][ i -1 ], dp [ j + 1 ][ i -1 ]); } else { dp [ j ][ i ] = min ( dp [ j ][ i -1 ], dp [ j + 1 ][ i -1 ]) + 1 ; } for ( int k = 1 ; k <= i ; k ++ ) { dp [ j ][ i ] = min ( dp [ j ][ i ], dp [ j ][ k ] + dp [ j + k ][ i - k ]); } } } cout << dp [ 1 ][ n ] << endl ; } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2512&pid=2","title":"\u63d0\u793a"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_17","text":"\u795e\u4ed9\u59d0\u59d0\u9047\u5230\u4e00\u4e2a\u96be\u9898\uff1a \u6709\u5b9d\u85cf\u51fa\u73b0\u5728\u59d0\u59d0\u9762\u524d\u540e\uff0c\u53c8\u51fa\u73b0\u4e00\u884c\u5b57\u8bf4\u201c\u8fd9\u91cc\u7684\u5404\u79cd\u7c7b\u578b\u7684\u5b9d\u7269\u662f\u653e\u5728\u957f\u65b9\u5f62\u7684\u77f3\u684c\u4e0a\uff0c\u4f60\u53ea\u80fd\u4e00\u6b21\u6027\u62ff\u8d70\u540c\u4e00\u79cd\u7c7b\u578b\u7684\u5b9d\u7269\uff0c\u5e76\u4e14\u8981\u6c42\u4f60\u62ff\u8d70\u7684\u5b9d\u7269\u5fc5\u987b\u4e3a\u67d0\u4e2a\u6b63\u65b9\u5f62\u5b50\u77e9\u9635\u4e2d\u67d0\u6761\u5bf9\u89d2\u7ebf\uff0c\u800c\u4e14\u6b64\u65f6\uff0c\u4f60\u6240\u9009\u62e9\u7684\u8fd9\u4e2a\u6b63\u65b9\u5f62\u5b50\u77e9\u9635\u4e2d\uff0c\u9664\u4e86\u5bf9\u89d2\u7ebf\u4f4d\u7f6e\uff0c\u5176\u5b83\u4f4d\u7f6e\u4e0d\u80fd\u51fa\u73b0\u4f60\u6240\u9700\u8981\u7684\u5b9d\u7269\u7c7b\u578b\uff08\u56e0\u4e3a\u8fd9\u6837\u4f1a\u5206\u5fc3\uff09\uff01\u4f60\u53ef\u4ee5\u628a\u77f3\u684c\u89c6\u4e3a01\u77e9\u9635\uff080\u8868\u793a\u5bf9\u5e94\u4f4d\u7f6e\u4e0d\u662f\u4f60\u6240\u8981\u7684\u7c7b\u578b\uff0c1\u8868\u793a\u5bf9\u5e94\u4f4d\u7f6e\u6709\u4f60\u6240\u8981\u7684\u7c7b\u578b\uff0c\u8fd9\u6837\u6709\u52a9\u4e8e\u4f60\u591a\u62ff\u4e9b\u5b9d\u7269\uff09\u201d\u3002 \u5f53\u7136\u7231\u7f8e\u7684\u59d0\u59d0\u9009\u62e9\u7684\u662f\u53ef\u4ee5\u7f8e\u5bb9\u517b\u989c\u7c7b\u578b\u7684\uff0c\u6240\u4ee5\u5979\u628a\u6240\u60f3\u8981\u7684\u5b9d\u7269(\u5373\u7f8e\u5bb9\u6c34)\u7528\uff11\u8868\u793a\uff0c\u4e0d\u60f3\u8981\u7684\u5c31\u75280\u8868\u793a\u3002\u540c\u65f6\u59d0\u59d0\u662f\u4e2a\u5f88\u8d2a\u5a6a(\u8d2a\u7f8e)\u7684\u795e\u4ed9\uff0c\u6240\u4ee5\u5979\u60f3\u4e00\u4e0b\u62ff\u8d70\u5c3d\u91cf\u591a\u7684\u5979\u6240\u8981\u7684\u7f8e\u5bb9\u54c1\u3002\u8bf7\u4f60\u5e2e\u795e\u4ed9\u59d0\u59d0\u7b97\u4e00\u4e0b\uff0c\u5979\u4e00\u4e0b\u6700\u591a\u53ef\u4ee5\u62ff\u591a\u5c11\u4e2a\uff1f","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_18","text":"\u7b2c\u4e00\u884c\u6709\u4e24\u4e2a\u6574\u6570n\u548cm\uff08n\uff0cm\u22651\uff09\uff0c\u63cf\u8ff0\u77f3\u684c\u7684\u89c4\u6a21\u3002\u63a5\u4e0b\u6765\u7684n\u884c\uff0c\u6bcf\u884c\u6709m\u4e2a\u6570\u5b57\uff08\u975e\u201c0\u201d\u5373\u201c1\u201d\uff09\u3002\u6bcf\u4e24\u4e2a\u6570\u5b57\u4e4b\u95f4\u7528\u7a7a\u683c\u9694\u5f00\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_19","text":"\u53ea\u6709\u4e00\u4e2a\u6574\u6570\u2014\u2014\u795e\u4ed9\u4e00\u4e0b\u6700\u591a\u53ef\u4ee5\u62ff\u5230\u591a\u5c11\u4e2a\u5b9d\u7269\uff0c\u5360\u4e00\u884c\uff0c\u884c\u672b\u6709\u56de\u8f66\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_20","text":"4 6 0 1 0 1 0 0 0 0 1 0 1 0 1 1 0 0 0 1 0 1 1 0 1 0","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_21","text":"3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-02%20%E7%BA%BF%E6%AE%B5%E6%A0%91/#_22","text":"\u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c\u6709n\uff0cm\u22642500 \u4e8c\u7ef4\u524d\u7f00\u548c #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int a [ 2550 ][ 2550 ] = { 0 }; int d [ 2550 ][ 2550 ] = { 0 }; int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]); d [ i ][ j ] = d [ i -1 ][ j ] + d [ i ][ j -1 ] - d [ i -1 ][ j -1 ] + a [ i ][ j ]; } } int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int cnt = 0 ; while ( i + cnt <= n && j + cnt <= m && a [ i ][ j ] && a [ i + cnt ][ j + cnt ]) { int k1 = d [ i + cnt ][ j + cnt ] - d [ i -1 ][ j + cnt ] - d [ i + cnt ][ j -1 ] + d [ i -1 ][ j -1 ]; int k2 = d [ i + cnt -1 ][ j + cnt -1 ] - d [ i -1 ][ j + cnt -1 ] - d [ i + cnt -1 ][ j -1 ] + d [ i -1 ][ j -1 ]; if ( k1 == cnt + 1 && k1 - k2 == 1 ) { max1 = max ( max1 , cnt + 1 ); cnt ++ ; } else break ; } cnt = 0 ; while ( i + cnt <= n && j - cnt >= 1 && a [ i ][ j ] && a [ i + cnt ][ j - cnt ]) { int k1 = d [ i + cnt ][ j ] - d [ i -1 ][ j ] - d [ i + cnt ][ j - cnt -1 ] + d [ i -1 ][ j -1 - cnt ]; int k2 = d [ i + cnt -1 ][ j ] - d [ i -1 ][ j ] - d [ i + cnt -1 ][ j - cnt ] + d [ i -1 ][ j - cnt ]; if ( k1 == cnt + 1 && k1 - k2 == 1 ) { max1 = max ( max1 , cnt + 1 ); cnt ++ ; } else break ; } } } cout << max1 << endl ; return 0 ; }","title":"\u63d0\u793a"},{"location":"csdn/2020-08-03/","text":"http://icpc.upc.edu.cn/problem.php?cid=1461&pid=2 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u6821\u95e8\u5916\u6709\u5f88\u591a\u6811\uff0c\u6709\u82f9\u679c\u6811\uff0c\u9999\u8549\u6811\uff0c\u6709\u4f1a\u6254\u77f3\u5934\u7684\uff0c\u6709\u53ef\u4ee5\u5403\u6389\u8865\u5145\u4f53\u529b\u7684\u2026\u2026 \u5982\u4eca\u5b66\u6821\u51b3\u5b9a\u5728\u67d0\u4e2a\u65f6\u523b\u5728\u67d0\u4e00\u6bb5\u79cd\u4e0a\u4e00\u79cd\u6811\uff0c\u4fdd\u8bc1\u4efb\u4e00\u65f6\u523b\u4e0d\u4f1a\u51fa\u73b0\u4e24\u6bb5\u76f8\u540c\u79cd\u7c7b\u7684\u6811\uff0c\u73b0\u6709\u4e24\u4e2a\u64cd\u4f5c\uff1a K=1\uff0cK=1\uff0c\u8bfb\u5165l\u3001r\u8868\u793a\u5728\u533a\u95f4[l,r]\u4e2d\u79cd\u4e0a\u4e00\u79cd\u6811\uff0c\u6bcf\u6b21\u64cd\u4f5c\u79cd\u7684\u6811\u7684\u79cd\u7c7b\u90fd\u4e0d\u540c K=2\uff0c\u8bfb\u5165l,r\u8868\u793a\u8be2\u95eel~r\u4e4b\u95f4\u80fd\u89c1\u5230\u591a\u5c11\u79cd\u6811 \uff08l,r>0\uff09 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884cn,m\u8868\u793a\u9053\u8def\u603b\u957f\u4e3an\uff0c\u5171\u6709m\u4e2a\u64cd\u4f5c \u63a5\u4e0b\u6765m\u884c\u4e3am\u4e2a\u64cd\u4f5c \u8f93\u51fa \u00b6 \u5bf9\u4e8e\u6bcf\u4e2ak=2\u8f93\u51fa\u4e00\u4e2a\u7b54\u6848 \u6837\u4f8b\u8f93\u5165 \u00b6 5 4 1 1 3 2 2 5 1 2 4 2 3 5 \u6837\u4f8b\u8f93\u51fa' \u00b6 1 2 \u63d0\u793a \u00b6 20%\u7684\u6570\u636e\u4fdd\u8bc1\uff0cn,m<=100 60%\u7684\u6570\u636e\u4fdd\u8bc1\uff0cn <=1000,m<=50000 100%\u7684\u6570\u636e\u4fdd\u8bc1\uff0cn,m<=50000 \u91c7\u7528\u62ec\u53f7\u5e8f\u5217+\u6811\u72b6\u6570\u7ec4\u6765\u89e3\u51b3\u8fd9\u9053\u9898\u76ee\uff0c\u79cd\u6811\u4e3a\u4e00\u4e2a\u533a\u95f4\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u79cd\u6811\u7684\u8d77\u70b9\u6807\u8bb0\u4e00\u4e2a\u5de6\u62ec\u53f7\uff0c\u79cd\u6811\u7684\u7ec8\u70b9\u6807\u8bb0\u4e00\u4e2a\u53f3\u62ec\u53f7\uff0c\u7edf\u8ba1\u7684\u65f6\u5019\u8ba1\u7b97\u7ec8\u70b9\u524d\u5de6\u62ec\u53f7\u7684\u6570\u76ee\u548c\u8d77\u70b9\u524d\u53f3\u62ec\u53f7\u7684\u6570\u76ee\uff0c\u4e24\u4e2a\u505a\u5dee\u5373\u4e3a\u7b54\u6848\u3002 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll c1 [ 500500 ] = { 0 }; ll c2 [ 500500 ] = { 0 }; ll n , m ; ll lowbit ( ll x ) { return x & ( - x ); } ll update1 ( ll k , ll x ) { for ( ll i = k ; i <= n ; i += lowbit ( i )) c1 [ i ] += x ; } ll update2 ( ll k , ll x ) { for ( ll i = k ; i <= n ; i += lowbit ( i )) c2 [ i ] += x ; } ll sum1 ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c1 [ i ]; return ans ; } ll sum2 ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c2 [ i ]; return ans ; } int main () { ll a , b , c ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld%lld\" , & a , & b , & c ); if ( a == 1 ) { update1 ( b , 1 ); /// \u5de6\u62ec\u53f7 update2 ( c , 1 ); /// \u53f3\u62ec\u53f7 } else { printf ( \"%lld \\n \" , sum1 ( c ) - sum2 ( b -1 )); } } } http://icpc.upc.edu.cn/problem.php?cid=1461&pid=4 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u6709\u4e00\u4e2an\u4e2a\u5143\u7d20\u7684\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5143\u7d20\u521d\u59cb\u5747\u4e3a0\u3002\u6709m\u6761\u6307\u4ee4\uff0c\u8981\u4e48\u8ba9\u5176\u4e2d\u4e00\u6bb5\u8fde\u7eed\u5e8f\u5217\u6570\u5b57\u53cd\u8f6c\u2014\u20140\u53d81\uff0c1\u53d80\uff08\u64cd\u4f5c1\uff09\uff0c\u8981\u4e48\u8be2\u95ee\u67d0\u4e2a\u5143\u7d20\u7684\u503c\uff08\u64cd\u4f5c2\uff09\u3002 \u4f8b\u5982\u5f53n=20\u65f6\uff0c10\u6761\u6307\u4ee4\u5982\u4e0b\uff1a \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570n,m\uff0c\u8868\u793a\u6570\u7ec4\u7684\u957f\u5ea6\u548c\u6307\u4ee4\u7684\u6761\u6570\uff1b \u4ee5\u4e0bm\u884c\uff0c\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6570t\u8868\u793a\u64cd\u4f5c\u7684\u79cd\u7c7b\uff1a \u82e5t=1\uff0c\u5219\u63a5\u4e0b\u6765\u6709\u4e24\u4e2a\u6570L,R\uff0c\u8868\u793a\u533a\u95f4[L,R]\u7684\u6bcf\u4e2a\u6570\u5747\u53cd\u8f6c\uff1b \u82e5t=2\uff0c\u5219\u63a5\u4e0b\u6765\u53ea\u6709\u4e00\u4e2a\u6570i\uff0c\u8868\u793a\u8be2\u95ee\u7684\u4e0b\u6807\u3002 \u8f93\u51fa \u00b6 \u6bcf\u4e2a\u64cd\u4f5c2\u8f93\u51fa\u4e00\u884c\uff08\u975e0\u53731\uff09\uff0c\u8868\u793a\u6bcf\u6b21\u64cd\u4f5c2\u7684\u56de\u7b54\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 20 10 1 1 10 2 6 2 12 1 5 12 2 6 2 15 1 6 16 1 11 17 2 12 2 6 \u6837\u4f8b\u8f93\u51fa \u00b6 1 0 0 0 1 1 \u63d0\u793a \u00b6 \u5bf9\u4e8e50%\u7684\u6570\u636e\uff0c1\u2264n\u2264103,1\u2264m\u2264104\uff1b \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c1\u2264n\u2264105,1\u2264m\u22645\u00d7105\uff0c\u4fdd\u8bc1L\u2264R\u3002 \u4e0e\u4e0a\u4e00\u9053\u9898\u76ee\u540c\uff0c\u6811\u72b6\u6570\u7ec4\u7edf\u8ba1\u53cd\u8f6c\u6b21\u6570\u5373\u53ef\u3002 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll c1 [ 500500 ] = { 0 }; ll c2 [ 500500 ] = { 0 }; ll p [ 500500 ] = { 0 }; ll n , m ; ll lowbit ( ll x ) { return x & ( - x ); } ll update1 ( ll k , ll x ) { for ( ll i = k ; i <= n ; i += lowbit ( i )) c1 [ i ] += x ; } ll update2 ( ll k , ll x ) { for ( ll i = k ; i <= n ; i += lowbit ( i )) c2 [ i ] += x ; } ll sum1 ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c1 [ i ]; return ans ; } ll sum2 ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c2 [ i ]; return ans ; } int main () { ll a , b , c ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & a ); if ( a == 1 ) { scanf ( \"%lld%lld\" , & b , & c ); update1 ( b , 1 ); /// \u5de6\u62ec\u53f7 update2 ( c , 1 ); /// \u53f3\u62ec\u53f7 } else { scanf ( \"%lld\" , & b ); printf ( \"%lld \\n \" ,( sum1 ( b ) - sum2 ( b -1 )) % 2 ); } } } http://icpc.upc.edu.cn/problem.php?cid=1431&pid=12 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u5728\u7ed9\u5b9a\u7684N\u4e2a\u6574\u6570A1\uff0cA2\u2026\u2026AN\u4e2d\u9009\u51fa\u4e24\u4e2a\u8fdb\u884cxor\u8fd0\u7b97\uff0c\u5f97\u5230\u7684\u7ed3\u679c\u6700\u5927\u662f\u591a\u5c11\uff1f \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6574\u6570N\uff0c\u7b2c\u4e8c\u884cN\u4e2a\u6574\u6570A1\uff5eAN\u3002 \u8f93\u51fa \u00b6 \u4e00\u4e2a\u6574\u6570\u8868\u793a\u7b54\u6848\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 3 1 2 3 \u6837\u4f8b\u8f93\u51fa \u00b6 3 \u63d0\u793a \u00b6 \u5bf9\u4e8e100%\u7684\u6570\u636e: N<=10^5, 0<=Ai<2^31\u3002 \u7528\u5b57\u5178\u6811\u5b58\u4e8c\u8fdb\u5236\uff0c\u627e\u6700\u5927\u7684\u5f02\u6216\u503c\u3002 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 1005000 ] = { 0 }; int tree [ 5000500 ][ 3 ] = { 0 }; int tot = 1 ; ///\u5fc5\u987b\u4ece1\u5f00\u59cb int in ( int x ) { int p = 1 ; for ( int i = 30 ; i >= 0 ; i -- ) { int k = x >> i & 1 ; if ( tree [ p ][ k ] == 0 ) tree [ p ][ k ] =++ tot ; p = tree [ p ][ k ]; } } int out ( int x ) { int p = 1 , ans = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { int k = x >> i & 1 ; if ( tree [ p ][ ! k ]) { ans = ans * 2 +! k ; p = tree [ p ][ ! k ]; } else { ans = ans * 2 + k ; p = tree [ p ][ k ]; } } return ans ; } int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { in ( a [ i ]); int num = out ( a [ i ]); max1 = max ( max1 , num ^ a [ i ]); } cout << max1 << endl ; return 0 ; }","title":"2020-08-03"},{"location":"csdn/2020-08-03/#_1","text":"\u6821\u95e8\u5916\u6709\u5f88\u591a\u6811\uff0c\u6709\u82f9\u679c\u6811\uff0c\u9999\u8549\u6811\uff0c\u6709\u4f1a\u6254\u77f3\u5934\u7684\uff0c\u6709\u53ef\u4ee5\u5403\u6389\u8865\u5145\u4f53\u529b\u7684\u2026\u2026 \u5982\u4eca\u5b66\u6821\u51b3\u5b9a\u5728\u67d0\u4e2a\u65f6\u523b\u5728\u67d0\u4e00\u6bb5\u79cd\u4e0a\u4e00\u79cd\u6811\uff0c\u4fdd\u8bc1\u4efb\u4e00\u65f6\u523b\u4e0d\u4f1a\u51fa\u73b0\u4e24\u6bb5\u76f8\u540c\u79cd\u7c7b\u7684\u6811\uff0c\u73b0\u6709\u4e24\u4e2a\u64cd\u4f5c\uff1a K=1\uff0cK=1\uff0c\u8bfb\u5165l\u3001r\u8868\u793a\u5728\u533a\u95f4[l,r]\u4e2d\u79cd\u4e0a\u4e00\u79cd\u6811\uff0c\u6bcf\u6b21\u64cd\u4f5c\u79cd\u7684\u6811\u7684\u79cd\u7c7b\u90fd\u4e0d\u540c K=2\uff0c\u8bfb\u5165l,r\u8868\u793a\u8be2\u95eel~r\u4e4b\u95f4\u80fd\u89c1\u5230\u591a\u5c11\u79cd\u6811 \uff08l,r>0\uff09","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-03/#_2","text":"\u7b2c\u4e00\u884cn,m\u8868\u793a\u9053\u8def\u603b\u957f\u4e3an\uff0c\u5171\u6709m\u4e2a\u64cd\u4f5c \u63a5\u4e0b\u6765m\u884c\u4e3am\u4e2a\u64cd\u4f5c","title":"\u8f93\u5165"},{"location":"csdn/2020-08-03/#_3","text":"\u5bf9\u4e8e\u6bcf\u4e2ak=2\u8f93\u51fa\u4e00\u4e2a\u7b54\u6848","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-03/#_4","text":"5 4 1 1 3 2 2 5 1 2 4 2 3 5","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-03/#_5","text":"1 2","title":"\u6837\u4f8b\u8f93\u51fa'"},{"location":"csdn/2020-08-03/#_6","text":"20%\u7684\u6570\u636e\u4fdd\u8bc1\uff0cn,m<=100 60%\u7684\u6570\u636e\u4fdd\u8bc1\uff0cn <=1000,m<=50000 100%\u7684\u6570\u636e\u4fdd\u8bc1\uff0cn,m<=50000 \u91c7\u7528\u62ec\u53f7\u5e8f\u5217+\u6811\u72b6\u6570\u7ec4\u6765\u89e3\u51b3\u8fd9\u9053\u9898\u76ee\uff0c\u79cd\u6811\u4e3a\u4e00\u4e2a\u533a\u95f4\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u79cd\u6811\u7684\u8d77\u70b9\u6807\u8bb0\u4e00\u4e2a\u5de6\u62ec\u53f7\uff0c\u79cd\u6811\u7684\u7ec8\u70b9\u6807\u8bb0\u4e00\u4e2a\u53f3\u62ec\u53f7\uff0c\u7edf\u8ba1\u7684\u65f6\u5019\u8ba1\u7b97\u7ec8\u70b9\u524d\u5de6\u62ec\u53f7\u7684\u6570\u76ee\u548c\u8d77\u70b9\u524d\u53f3\u62ec\u53f7\u7684\u6570\u76ee\uff0c\u4e24\u4e2a\u505a\u5dee\u5373\u4e3a\u7b54\u6848\u3002 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll c1 [ 500500 ] = { 0 }; ll c2 [ 500500 ] = { 0 }; ll n , m ; ll lowbit ( ll x ) { return x & ( - x ); } ll update1 ( ll k , ll x ) { for ( ll i = k ; i <= n ; i += lowbit ( i )) c1 [ i ] += x ; } ll update2 ( ll k , ll x ) { for ( ll i = k ; i <= n ; i += lowbit ( i )) c2 [ i ] += x ; } ll sum1 ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c1 [ i ]; return ans ; } ll sum2 ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c2 [ i ]; return ans ; } int main () { ll a , b , c ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld%lld\" , & a , & b , & c ); if ( a == 1 ) { update1 ( b , 1 ); /// \u5de6\u62ec\u53f7 update2 ( c , 1 ); /// \u53f3\u62ec\u53f7 } else { printf ( \"%lld \\n \" , sum1 ( c ) - sum2 ( b -1 )); } } } http://icpc.upc.edu.cn/problem.php?cid=1461&pid=4","title":"\u63d0\u793a"},{"location":"csdn/2020-08-03/#_7","text":"\u6709\u4e00\u4e2an\u4e2a\u5143\u7d20\u7684\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5143\u7d20\u521d\u59cb\u5747\u4e3a0\u3002\u6709m\u6761\u6307\u4ee4\uff0c\u8981\u4e48\u8ba9\u5176\u4e2d\u4e00\u6bb5\u8fde\u7eed\u5e8f\u5217\u6570\u5b57\u53cd\u8f6c\u2014\u20140\u53d81\uff0c1\u53d80\uff08\u64cd\u4f5c1\uff09\uff0c\u8981\u4e48\u8be2\u95ee\u67d0\u4e2a\u5143\u7d20\u7684\u503c\uff08\u64cd\u4f5c2\uff09\u3002 \u4f8b\u5982\u5f53n=20\u65f6\uff0c10\u6761\u6307\u4ee4\u5982\u4e0b\uff1a","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-03/#_8","text":"\u7b2c\u4e00\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570n,m\uff0c\u8868\u793a\u6570\u7ec4\u7684\u957f\u5ea6\u548c\u6307\u4ee4\u7684\u6761\u6570\uff1b \u4ee5\u4e0bm\u884c\uff0c\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6570t\u8868\u793a\u64cd\u4f5c\u7684\u79cd\u7c7b\uff1a \u82e5t=1\uff0c\u5219\u63a5\u4e0b\u6765\u6709\u4e24\u4e2a\u6570L,R\uff0c\u8868\u793a\u533a\u95f4[L,R]\u7684\u6bcf\u4e2a\u6570\u5747\u53cd\u8f6c\uff1b \u82e5t=2\uff0c\u5219\u63a5\u4e0b\u6765\u53ea\u6709\u4e00\u4e2a\u6570i\uff0c\u8868\u793a\u8be2\u95ee\u7684\u4e0b\u6807\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-03/#_9","text":"\u6bcf\u4e2a\u64cd\u4f5c2\u8f93\u51fa\u4e00\u884c\uff08\u975e0\u53731\uff09\uff0c\u8868\u793a\u6bcf\u6b21\u64cd\u4f5c2\u7684\u56de\u7b54\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-03/#_10","text":"20 10 1 1 10 2 6 2 12 1 5 12 2 6 2 15 1 6 16 1 11 17 2 12 2 6","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-03/#_11","text":"1 0 0 0 1 1","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-03/#_12","text":"\u5bf9\u4e8e50%\u7684\u6570\u636e\uff0c1\u2264n\u2264103,1\u2264m\u2264104\uff1b \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c1\u2264n\u2264105,1\u2264m\u22645\u00d7105\uff0c\u4fdd\u8bc1L\u2264R\u3002 \u4e0e\u4e0a\u4e00\u9053\u9898\u76ee\u540c\uff0c\u6811\u72b6\u6570\u7ec4\u7edf\u8ba1\u53cd\u8f6c\u6b21\u6570\u5373\u53ef\u3002 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll c1 [ 500500 ] = { 0 }; ll c2 [ 500500 ] = { 0 }; ll p [ 500500 ] = { 0 }; ll n , m ; ll lowbit ( ll x ) { return x & ( - x ); } ll update1 ( ll k , ll x ) { for ( ll i = k ; i <= n ; i += lowbit ( i )) c1 [ i ] += x ; } ll update2 ( ll k , ll x ) { for ( ll i = k ; i <= n ; i += lowbit ( i )) c2 [ i ] += x ; } ll sum1 ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c1 [ i ]; return ans ; } ll sum2 ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c2 [ i ]; return ans ; } int main () { ll a , b , c ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & a ); if ( a == 1 ) { scanf ( \"%lld%lld\" , & b , & c ); update1 ( b , 1 ); /// \u5de6\u62ec\u53f7 update2 ( c , 1 ); /// \u53f3\u62ec\u53f7 } else { scanf ( \"%lld\" , & b ); printf ( \"%lld \\n \" ,( sum1 ( b ) - sum2 ( b -1 )) % 2 ); } } } http://icpc.upc.edu.cn/problem.php?cid=1431&pid=12","title":"\u63d0\u793a"},{"location":"csdn/2020-08-03/#_13","text":"\u5728\u7ed9\u5b9a\u7684N\u4e2a\u6574\u6570A1\uff0cA2\u2026\u2026AN\u4e2d\u9009\u51fa\u4e24\u4e2a\u8fdb\u884cxor\u8fd0\u7b97\uff0c\u5f97\u5230\u7684\u7ed3\u679c\u6700\u5927\u662f\u591a\u5c11\uff1f","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-03/#_14","text":"\u7b2c\u4e00\u884c\u4e00\u4e2a\u6574\u6570N\uff0c\u7b2c\u4e8c\u884cN\u4e2a\u6574\u6570A1\uff5eAN\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-03/#_15","text":"\u4e00\u4e2a\u6574\u6570\u8868\u793a\u7b54\u6848\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-03/#_16","text":"3 1 2 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-03/#_17","text":"3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-03/#_18","text":"\u5bf9\u4e8e100%\u7684\u6570\u636e: N<=10^5, 0<=Ai<2^31\u3002 \u7528\u5b57\u5178\u6811\u5b58\u4e8c\u8fdb\u5236\uff0c\u627e\u6700\u5927\u7684\u5f02\u6216\u503c\u3002 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 1005000 ] = { 0 }; int tree [ 5000500 ][ 3 ] = { 0 }; int tot = 1 ; ///\u5fc5\u987b\u4ece1\u5f00\u59cb int in ( int x ) { int p = 1 ; for ( int i = 30 ; i >= 0 ; i -- ) { int k = x >> i & 1 ; if ( tree [ p ][ k ] == 0 ) tree [ p ][ k ] =++ tot ; p = tree [ p ][ k ]; } } int out ( int x ) { int p = 1 , ans = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { int k = x >> i & 1 ; if ( tree [ p ][ ! k ]) { ans = ans * 2 +! k ; p = tree [ p ][ ! k ]; } else { ans = ans * 2 + k ; p = tree [ p ][ k ]; } } return ans ; } int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { in ( a [ i ]); int num = out ( a [ i ]); max1 = max ( max1 , num ^ a [ i ]); } cout << max1 << endl ; return 0 ; }","title":"\u63d0\u793a"},{"location":"csdn/2020-08-04/","text":"http://icpc.upc.edu.cn/problem.php?cid=1404&pid=5 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u8bbeX\u662f\u6709N\u4e2a\u4e0d\u76f8\u540c\u6574\u6570\u7684\u96c6\u5408\u3002\u628aX\u4e2d\u6bcf\u4e2a\u6570\u7528\u4e24\u6b21\uff0c\u6392\u6210\u4e00\u4e2a\u957f\u5ea6\u4e3a2N\u7684\u6570\u5217S\uff0c\u8981\u6c42S\u4e2d\u4efb\u610f\u4e00\u4e2a\u6570i\u4e0e\u53e6\u4e00\u4e2a\u4e0e\u5b83\u76f8\u540c\u7684i\u4e4b\u95f4\u6b63\u597d\u95f4\u9694i\u4e2a\u6570\u5b57\u3002 \u8f93\u5165 \u00b6 \u7b2c1\u884c\u4e00\u4e2a\u6574\u6570N(I\u2264N\u22648)\uff1b \u7b2c2\u884c\u6709N\u4e2a\u6574\u6570\uff08\u6bcf\u4e2a\u6570\u4e0d\u76f8\u540c\uff0c\u5e76\u4e14\u57280\u523016\u4e4b\u95f4\uff09\uff0c\u8868\u793a\u96c6\u5408\u4e2d\u7684\u6570\u3002 \u8f93\u51fa \u00b6 \u8f93\u51fa\u4e00\u4e2a\u6ee1\u8db3\u4e0a\u9762\u8981\u6c42\u7684\u957f\u5ea6\u4e3a2N\u7684\u6570\u5217\uff1b\u82e5\u6709\u591a\u4e2a\u89e3\uff0c\u8f93\u51fa\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\uff1b\u82e5\u6ca1\u6709\u89e3\uff0c\u8f93\u51fa-1\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 5 0 1 2 3 4 \u6837\u4f8b\u8f93\u51fa \u00b6 0 0 2 3 4 2 1 3 1 4 DFS\u641c\u7d22\u6bcf\u4e00\u79cd\u60c5\u51b5\u5373\u53ef\u3002 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int vis [ 100 ] = { 0 }; int data [ 100 ] = { 0 }; int n ; int a [ 100 ] = { 0 }; int dfs ( int k ) { if ( k == 2 * n + 1 ) { for ( int i = 1 ; i <= 2 * n ; i ++ ) { cout << data [ i ] << ' ' ; } cout << endl ; exit ( 0 ); } if ( data [ k ] == -1 ) { for ( int l = 0 ; l < n ; l ++ ) { int i = a [ l ]; if ( k + i + 1 <= 2 * n &&! vis [ i ] && data [ k ] == -1 && data [ k + i + 1 ] == -1 ) { data [ k ] = data [ k + i + 1 ] = i ; vis [ i ] = 1 ; dfs ( k + 1 ); vis [ i ] = 0 ; data [ k ] = data [ k + i + 1 ] = -1 ; } } } else dfs ( k + 1 ); } int main () { std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( 0 ); memset ( data , -1 , sizeof ( data )); cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ]; sort ( a , a + n ); dfs ( 1 ); cout << -1 << endl ; return 0 ; }","title":"2020-08-04"},{"location":"csdn/2020-08-04/#_1","text":"\u8bbeX\u662f\u6709N\u4e2a\u4e0d\u76f8\u540c\u6574\u6570\u7684\u96c6\u5408\u3002\u628aX\u4e2d\u6bcf\u4e2a\u6570\u7528\u4e24\u6b21\uff0c\u6392\u6210\u4e00\u4e2a\u957f\u5ea6\u4e3a2N\u7684\u6570\u5217S\uff0c\u8981\u6c42S\u4e2d\u4efb\u610f\u4e00\u4e2a\u6570i\u4e0e\u53e6\u4e00\u4e2a\u4e0e\u5b83\u76f8\u540c\u7684i\u4e4b\u95f4\u6b63\u597d\u95f4\u9694i\u4e2a\u6570\u5b57\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-04/#_2","text":"\u7b2c1\u884c\u4e00\u4e2a\u6574\u6570N(I\u2264N\u22648)\uff1b \u7b2c2\u884c\u6709N\u4e2a\u6574\u6570\uff08\u6bcf\u4e2a\u6570\u4e0d\u76f8\u540c\uff0c\u5e76\u4e14\u57280\u523016\u4e4b\u95f4\uff09\uff0c\u8868\u793a\u96c6\u5408\u4e2d\u7684\u6570\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-04/#_3","text":"\u8f93\u51fa\u4e00\u4e2a\u6ee1\u8db3\u4e0a\u9762\u8981\u6c42\u7684\u957f\u5ea6\u4e3a2N\u7684\u6570\u5217\uff1b\u82e5\u6709\u591a\u4e2a\u89e3\uff0c\u8f93\u51fa\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\uff1b\u82e5\u6ca1\u6709\u89e3\uff0c\u8f93\u51fa-1\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-04/#_4","text":"5 0 1 2 3 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-04/#_5","text":"0 0 2 3 4 2 1 3 1 4 DFS\u641c\u7d22\u6bcf\u4e00\u79cd\u60c5\u51b5\u5373\u53ef\u3002 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int vis [ 100 ] = { 0 }; int data [ 100 ] = { 0 }; int n ; int a [ 100 ] = { 0 }; int dfs ( int k ) { if ( k == 2 * n + 1 ) { for ( int i = 1 ; i <= 2 * n ; i ++ ) { cout << data [ i ] << ' ' ; } cout << endl ; exit ( 0 ); } if ( data [ k ] == -1 ) { for ( int l = 0 ; l < n ; l ++ ) { int i = a [ l ]; if ( k + i + 1 <= 2 * n &&! vis [ i ] && data [ k ] == -1 && data [ k + i + 1 ] == -1 ) { data [ k ] = data [ k + i + 1 ] = i ; vis [ i ] = 1 ; dfs ( k + 1 ); vis [ i ] = 0 ; data [ k ] = data [ k + i + 1 ] = -1 ; } } } else dfs ( k + 1 ); } int main () { std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( 0 ); memset ( data , -1 , sizeof ( data )); cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ]; sort ( a , a + n ); dfs ( 1 ); cout << -1 << endl ; return 0 ; }","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-05/","text":"http://icpc.upc.edu.cn/problem.php?cid=1442&pid=0 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u7ed9\u5b9a\u6574\u6570N(1\u2264N\u226410^6)\uff0c\u8bd5\u628a\u9636\u4e58N!\u5206\u89e3\u8d28\u56e0\u6570\uff0c\u6309\u7167\u7b97\u672f\u57fa\u672c\u5b9a\u7406\u7684\u5f62\u5f0f\u8f93\u51fa\u5206\u89e3\u7ed3\u679c\u4e2d\u7684pi\u548cci\u5373\u53ef\u3002 \u8f93\u5165 \u00b6 \u4e00\u4e2a\u6574\u6570N\u3002 \u8f93\u51fa \u00b6 N! \u5206\u89e3\u8d28\u56e0\u6570\u540e\u7684\u7ed3\u679c\uff0c\u5171\u82e5\u5e72\u884c\uff0c\u6bcf\u884c\u4e00\u5bf9pi, ci\uff0c\u8868\u793a\u542b\u6709pi^ci\u9879\u3002\u6309\u7167pi\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u8f93\u51fa\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 5 \u6837\u4f8b\u8f93\u51fa \u00b6 2 3 3 1 5 1 \u63d0\u793a \u00b6 5! = 120 = 2^3 * 3 * 5 \u89e3\u6790\uff1a \u00b6 \u6b27\u62c9\u7b5b\u6cd5 https://blog.csdn.net/WHZ2018/article/details/81233937 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int pd [ 1005000 ] = { 0 }; ll c [ 1005000 ] = { 0 }; ll n , k ; int main () { ll cnt = 0 ; scanf ( \"%lld\" , & n ); pd [ 0 ] = pd [ 1 ] = 1 ; for ( ll i = 2 ; i <= n ; i ++ ) { if ( ! pd [ i ]) c [ cnt ++ ] = i ; for ( ll j = 0 ; j < cnt && c [ j ] * i <= n ; j ++ ) { pd [ c [ j ] * i ] = 1 ; if ( i % c [ j ] == 0 ) break ; } } for ( ll i = 0 ; i < cnt ; i ++ ) { ll sum = 0 ; for ( ll j = c [ i ]; j <= n ; j = j * c [ i ]) sum += n / j ; printf ( \"%lld %lld \\n \" , c [ i ], sum ); } return 0 ; } \u4efb\u4e00\u5927\u4e8e2\u7684\u5076\u6570\u90fd\u53ef\u5199\u6210\u4e24\u4e2a\u8d28\u6570\u4e4b\u548c\uff0c\u5206\u5947\u5076\u8ba8\u8bba\u5373\u53ef\u3002 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ); } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ll n , k ; scanf ( \"%lld%lld\" , & n , & k ); if ( n % k != 0 ) { puts ( \"-1 -1 -1\" ); continue ; } ll w = n / k , a , b , c ; int flag = 1 ; if ( w % 2 == 1 ) { a = 3 , b = 2 , c = w - a - b ; while ( c > 2 ) { if ( gcd ( a , b ) == 1 && gcd ( b , c ) == 1 && gcd ( a , c ) == 1 ) { flag = 0 ; break ; } b ++ ; c -- ; } } else { a = 2 , b = 2 , c = w - a - b ; while ( c > 2 ) { if ( gcd ( a , b ) == 1 && gcd ( b , c ) == 1 && gcd ( a , c ) == 1 ) { flag = 0 ; break ; } b ++ ; c -- ; } } if ( flag ) puts ( \"-1 -1 -1\" ); else printf ( \"%lld %lld %lld \\n \" , a * k , b * k , c * k ); } return 0 ; } \u9898\u76ee \u00b6 https://ac.nowcoder.com/acm/contest/6871/E \u4ee3\u7801 \u00b6 \u65b9\u6cd51\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; map < ll , ll > w ; char a [ 2000 ] = { 0 }; ll b [ 3000 ] = { 0 }; ll two () { for ( ll i = 1 ; i <= 8 ; i ++ ) { ll w1 ; if ( a [ i ] >= '0' && a [ i ] <= '9' ) { w1 = a [ i ] - '0' ; } else if ( a [ i ] == 'A' ) { w1 = 10 ; } else if ( a [ i ] == 'B' ) { w1 = 11 ; } else if ( a [ i ] == 'C' ) { w1 = 12 ; } else if ( a [ i ] == 'D' ) { w1 = 13 ; } else if ( a [ i ] == 'E' ) { w1 = 14 ; } else if ( a [ i ] == 'F' ) { w1 = 15 ; } for ( ll j = i * 4 ; j > ( i -1 ) * 4 ; j -- ) { b [ j ] = w1 % 2 ; w1 = w1 / 2 ; } } } ll six () { ll sum = 0 ; for ( ll i = 1 ; i <= 8 ; i ++ ) { sum = 0 ; for ( ll j = 4 * ( i -1 ) + 1 ; j <= 4 * i ; j ++ ) sum = sum * 2 + b [ j ]; if ( sum <= 9 && sum >= 0 ) printf ( \"%d\" , sum ); else if ( sum == 10 ) printf ( \"A\" ); else if ( sum == 11 ) printf ( \"B\" ); else if ( sum == 12 ) printf ( \"C\" ); else if ( sum == 13 ) printf ( \"D\" ); else if ( sum == 14 ) printf ( \"E\" ); else if ( sum == 15 ) printf ( \"F\" ); } printf ( \" \\n \" ); } ll n , m , p , k , summ = 1 , q , sum1 , o ; int main () { scanf ( \"%lld%lld%lld\" , & n , & m , & p ); for ( ll i = 0 ; i < ( 1 << ( m - p )); i ++ ) { scanf ( \"%lld\" , & k ); w [ k ] = i ; } scanf ( \"%lld\" , & q ); for ( ll i = 1 ; i <= q ; i ++ ) { scanf ( \"%s\" , a + 1 ); two (); sum1 = 0 ; for ( ll i = 1 ; i <= 32 - p ; i ++ ) sum1 = sum1 * 2 + b [ i ]; if ( w . find ( sum1 ) == w . end ()) { puts ( \"interrupt!\" ); } else { o = w [ sum1 ]; for ( ll i = 32 - p ; i >= 1 ; i -- ) { b [ i ] = o % 2 ; o = o / 2 ; } six (); } } return 0 ; } \u65b9\u6cd52\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; map < ll , ll > w ; int main () { ll n , m , p ; scanf ( \"%lld%lld%lld\" , & n , & m , & p ); for ( ll i = 0 ; i < 1 << ( m - p ); i ++ ) { ll pos ; scanf ( \"%lld\" , & pos ); w [ pos ] = i ; } ll q ; scanf ( \"%lld\" , & q ); while ( q -- ) { ll tmp ; scanf ( \"%llX\" , & tmp ); printf ( \"%lld \\n \" , tmp ); ll t1 = tmp / ( 1 << p ), t2 = tmp % ( 1 << p ); if ( w . find ( t1 ) == w . end ()) { printf ( \"interrupt! \\n \" ); } else { printf ( \"%08llX \\n \" , w [ t1 ] * ( 1 << p ) + t2 ); } } return 0 ; }","title":"2020-08-05"},{"location":"csdn/2020-08-05/#_1","text":"\u7ed9\u5b9a\u6574\u6570N(1\u2264N\u226410^6)\uff0c\u8bd5\u628a\u9636\u4e58N!\u5206\u89e3\u8d28\u56e0\u6570\uff0c\u6309\u7167\u7b97\u672f\u57fa\u672c\u5b9a\u7406\u7684\u5f62\u5f0f\u8f93\u51fa\u5206\u89e3\u7ed3\u679c\u4e2d\u7684pi\u548cci\u5373\u53ef\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-05/#_2","text":"\u4e00\u4e2a\u6574\u6570N\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-05/#_3","text":"N! \u5206\u89e3\u8d28\u56e0\u6570\u540e\u7684\u7ed3\u679c\uff0c\u5171\u82e5\u5e72\u884c\uff0c\u6bcf\u884c\u4e00\u5bf9pi, ci\uff0c\u8868\u793a\u542b\u6709pi^ci\u9879\u3002\u6309\u7167pi\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u8f93\u51fa\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-05/#_4","text":"5","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-05/#_5","text":"2 3 3 1 5 1","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-05/#_6","text":"5! = 120 = 2^3 * 3 * 5","title":"\u63d0\u793a"},{"location":"csdn/2020-08-05/#_7","text":"\u6b27\u62c9\u7b5b\u6cd5 https://blog.csdn.net/WHZ2018/article/details/81233937 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int pd [ 1005000 ] = { 0 }; ll c [ 1005000 ] = { 0 }; ll n , k ; int main () { ll cnt = 0 ; scanf ( \"%lld\" , & n ); pd [ 0 ] = pd [ 1 ] = 1 ; for ( ll i = 2 ; i <= n ; i ++ ) { if ( ! pd [ i ]) c [ cnt ++ ] = i ; for ( ll j = 0 ; j < cnt && c [ j ] * i <= n ; j ++ ) { pd [ c [ j ] * i ] = 1 ; if ( i % c [ j ] == 0 ) break ; } } for ( ll i = 0 ; i < cnt ; i ++ ) { ll sum = 0 ; for ( ll j = c [ i ]; j <= n ; j = j * c [ i ]) sum += n / j ; printf ( \"%lld %lld \\n \" , c [ i ], sum ); } return 0 ; } \u4efb\u4e00\u5927\u4e8e2\u7684\u5076\u6570\u90fd\u53ef\u5199\u6210\u4e24\u4e2a\u8d28\u6570\u4e4b\u548c\uff0c\u5206\u5947\u5076\u8ba8\u8bba\u5373\u53ef\u3002 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ); } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ll n , k ; scanf ( \"%lld%lld\" , & n , & k ); if ( n % k != 0 ) { puts ( \"-1 -1 -1\" ); continue ; } ll w = n / k , a , b , c ; int flag = 1 ; if ( w % 2 == 1 ) { a = 3 , b = 2 , c = w - a - b ; while ( c > 2 ) { if ( gcd ( a , b ) == 1 && gcd ( b , c ) == 1 && gcd ( a , c ) == 1 ) { flag = 0 ; break ; } b ++ ; c -- ; } } else { a = 2 , b = 2 , c = w - a - b ; while ( c > 2 ) { if ( gcd ( a , b ) == 1 && gcd ( b , c ) == 1 && gcd ( a , c ) == 1 ) { flag = 0 ; break ; } b ++ ; c -- ; } } if ( flag ) puts ( \"-1 -1 -1\" ); else printf ( \"%lld %lld %lld \\n \" , a * k , b * k , c * k ); } return 0 ; }","title":"\u89e3\u6790\uff1a"},{"location":"csdn/2020-08-05/#_8","text":"https://ac.nowcoder.com/acm/contest/6871/E","title":"\u9898\u76ee"},{"location":"csdn/2020-08-05/#_9","text":"\u65b9\u6cd51\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; map < ll , ll > w ; char a [ 2000 ] = { 0 }; ll b [ 3000 ] = { 0 }; ll two () { for ( ll i = 1 ; i <= 8 ; i ++ ) { ll w1 ; if ( a [ i ] >= '0' && a [ i ] <= '9' ) { w1 = a [ i ] - '0' ; } else if ( a [ i ] == 'A' ) { w1 = 10 ; } else if ( a [ i ] == 'B' ) { w1 = 11 ; } else if ( a [ i ] == 'C' ) { w1 = 12 ; } else if ( a [ i ] == 'D' ) { w1 = 13 ; } else if ( a [ i ] == 'E' ) { w1 = 14 ; } else if ( a [ i ] == 'F' ) { w1 = 15 ; } for ( ll j = i * 4 ; j > ( i -1 ) * 4 ; j -- ) { b [ j ] = w1 % 2 ; w1 = w1 / 2 ; } } } ll six () { ll sum = 0 ; for ( ll i = 1 ; i <= 8 ; i ++ ) { sum = 0 ; for ( ll j = 4 * ( i -1 ) + 1 ; j <= 4 * i ; j ++ ) sum = sum * 2 + b [ j ]; if ( sum <= 9 && sum >= 0 ) printf ( \"%d\" , sum ); else if ( sum == 10 ) printf ( \"A\" ); else if ( sum == 11 ) printf ( \"B\" ); else if ( sum == 12 ) printf ( \"C\" ); else if ( sum == 13 ) printf ( \"D\" ); else if ( sum == 14 ) printf ( \"E\" ); else if ( sum == 15 ) printf ( \"F\" ); } printf ( \" \\n \" ); } ll n , m , p , k , summ = 1 , q , sum1 , o ; int main () { scanf ( \"%lld%lld%lld\" , & n , & m , & p ); for ( ll i = 0 ; i < ( 1 << ( m - p )); i ++ ) { scanf ( \"%lld\" , & k ); w [ k ] = i ; } scanf ( \"%lld\" , & q ); for ( ll i = 1 ; i <= q ; i ++ ) { scanf ( \"%s\" , a + 1 ); two (); sum1 = 0 ; for ( ll i = 1 ; i <= 32 - p ; i ++ ) sum1 = sum1 * 2 + b [ i ]; if ( w . find ( sum1 ) == w . end ()) { puts ( \"interrupt!\" ); } else { o = w [ sum1 ]; for ( ll i = 32 - p ; i >= 1 ; i -- ) { b [ i ] = o % 2 ; o = o / 2 ; } six (); } } return 0 ; } \u65b9\u6cd52\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; map < ll , ll > w ; int main () { ll n , m , p ; scanf ( \"%lld%lld%lld\" , & n , & m , & p ); for ( ll i = 0 ; i < 1 << ( m - p ); i ++ ) { ll pos ; scanf ( \"%lld\" , & pos ); w [ pos ] = i ; } ll q ; scanf ( \"%lld\" , & q ); while ( q -- ) { ll tmp ; scanf ( \"%llX\" , & tmp ); printf ( \"%lld \\n \" , tmp ); ll t1 = tmp / ( 1 << p ), t2 = tmp % ( 1 << p ); if ( w . find ( t1 ) == w . end ()) { printf ( \"interrupt! \\n \" ); } else { printf ( \"%08llX \\n \" , w [ t1 ] * ( 1 << p ) + t2 ); } } return 0 ; }","title":"\u4ee3\u7801"},{"location":"csdn/2020-08-06%20%E7%BA%BF%E6%AE%B5%E6%A0%91/","text":"https://www.luogu.com.cn/problem/P3372 \u7ebf\u6bb5\u6811\u533a\u95f4\u6c42\u548c\u548c\u533a\u95f4\u4fee\u6539\u6a21\u677f #include <bits/stdc++.h> #define MAXN 1000001 #define ll long long using namespace std ; unsigned ll num [ MAXN ], sum [ MAXN << 2 ], lazy [ MAXN << 2 ]; ll pushup ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } ll pushlazy ( ll t , ll lz , ll len ) { sum [ t ] += lz * len ; lazy [ t ] += lz ; } ll pushdown ( ll l , ll r , ll t ) { if ( lazy [ t ] != 0 ) { ll mid = ( l + r ) / 2 ; pushlazy ( 2 * t , lazy [ t ], mid - l + 1 ); pushlazy ( 2 * t + 1 , lazy [ t ], r - mid ); lazy [ t ] = 0 ; } } ll build ( ll l , ll r , ll t ) { lazy [ t ] = 0 ; if ( l == r ) { sum [ t ] = num [ l ]; return 0 ; } ll mid = ( l + r ) / 2 ; build ( l , mid , t * 2 ); build ( mid + 1 , r , 2 * t + 1 ); pushup ( t ); } ll add ( ll x , ll l , ll r , ll L , ll R , ll t ) { if ( l >= L && r <= R ) { lazy [ t ] += x ; sum [ t ] += ( r - l + 1 ) * x ; return 0 ; } pushdown ( l , r , t ); ll mid = ( l + r ) / 2 ; if ( L <= mid ) add ( x , l , mid , L , R , 2 * t ); if ( R > mid ) add ( x , mid + 1 , r , L , R , 2 * t + 1 ); pushup ( t ); } ll querysum ( ll l , ll r , ll L , ll R , ll t ) { if ( l >= L && r <= R ) return sum [ t ]; pushdown ( l , r , t ); ll mid = ( l + r ) / 2 ; ll ans = 0 ; if ( L <= mid ) ans += querysum ( l , mid , L , R , 2 * t ); if ( R > mid ) ans += querysum ( mid + 1 , r , L , R , 2 * t + 1 ); return ans ; } int main () { ll n , m , a , b , c , d ; scanf ( \"%lld\" , & n ); scanf ( \"%lld\" , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & num [ i ]); build ( 1 , n , 1 ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & a ); if ( a == 1 ) { scanf ( \"%lld%lld%lld\" , & b , & c , & d ); add ( d , 1 , n , b , c , 1 ); } else if ( a == 2 ) { scanf ( \"%lld%lld\" , & b , & c ); printf ( \"%lld \\n \" , querysum ( 1 , n , b , c , 1 )); } } }","title":"2020 08 06 \u7ebf\u6bb5\u6811"},{"location":"csdn/2020-08-07/","text":"http://acm.hdu.edu.cn/showproblem.php?pid=1285 Problem Description \u00b6 \u6709N\u4e2a\u6bd4\u8d5b\u961f\uff081<=N<=500\uff09\uff0c\u7f16\u53f7\u4f9d\u6b21\u4e3a1\uff0c2\uff0c3\uff0c\u3002\u3002\u3002\u3002\uff0cN\u8fdb\u884c\u6bd4\u8d5b\uff0c\u6bd4\u8d5b\u7ed3\u675f\u540e\uff0c\u88c1\u5224\u59d4\u5458\u4f1a\u8981\u5c06\u6240\u6709\u53c2\u8d5b\u961f\u4f0d\u4ece\u524d\u5f80\u540e\u4f9d\u6b21\u6392\u540d\uff0c\u4f46\u73b0\u5728\u88c1\u5224\u59d4\u5458\u4f1a\u4e0d\u80fd\u76f4\u63a5\u83b7\u5f97\u6bcf\u4e2a\u961f\u7684\u6bd4\u8d5b\u6210\u7ee9\uff0c\u53ea\u77e5\u9053\u6bcf\u573a\u6bd4\u8d5b\u7684\u7ed3\u679c\uff0c\u5373P1\u8d62P2\uff0c\u7528P1\uff0cP2\u8868\u793a\uff0c\u6392\u540d\u65f6P1\u5728P2\u4e4b\u524d\u3002\u73b0\u5728\u8bf7\u4f60\u7f16\u7a0b\u5e8f\u786e\u5b9a\u6392\u540d\u3002 Input \u00b6 \u8f93\u5165\u6709\u82e5\u5e72\u7ec4\uff0c\u6bcf\u7ec4\u4e2d\u7684\u7b2c\u4e00\u884c\u4e3a\u4e8c\u4e2a\u6570N\uff081<=N<=500\uff09\uff0cM\uff1b\u5176\u4e2dN\u8868\u793a\u961f\u4f0d\u7684\u4e2a\u6570\uff0cM\u8868\u793a\u63a5\u7740\u6709M\u884c\u7684\u8f93\u5165\u6570\u636e\u3002\u63a5\u4e0b\u6765\u7684M\u884c\u6570\u636e\u4e2d\uff0c\u6bcf\u884c\u4e5f\u6709\u4e24\u4e2a\u6574\u6570P1\uff0cP2\u8868\u793a\u5373P1\u961f\u8d62\u4e86P2\u961f\u3002 Output \u00b6 \u7ed9\u51fa\u4e00\u4e2a\u7b26\u5408\u8981\u6c42\u7684\u6392\u540d\u3002\u8f93\u51fa\u65f6\u961f\u4f0d\u53f7\u4e4b\u95f4\u6709\u7a7a\u683c\uff0c\u6700\u540e\u4e00\u540d\u540e\u9762\u6ca1\u6709\u7a7a\u683c\u3002 \u5176\u4ed6\u8bf4\u660e\uff1a\u7b26\u5408\u6761\u4ef6\u7684\u6392\u540d\u53ef\u80fd\u4e0d\u662f\u552f\u4e00\u7684\uff0c\u6b64\u65f6\u8981\u6c42\u8f93\u51fa\u65f6\u7f16\u53f7\u5c0f\u7684\u961f\u4f0d\u5728\u524d\uff1b\u8f93\u5165\u6570\u636e\u4fdd\u8bc1\u662f\u6b63\u786e\u7684\uff0c\u5373\u8f93\u5165\u6570\u636e\u786e\u4fdd\u4e00\u5b9a\u80fd\u6709\u4e00\u4e2a\u7b26\u5408\u8981\u6c42\u7684\u6392\u540d\u3002 Sample Input \u00b6 4 3 1 2 2 3 4 3 Sample Output \u00b6 1 2 4 3 \u62d3\u6251\u6392\u5e8f #include <iostream> #include <bits/stdc++.h> using namespace std ; vector < int > g [ 600 ]; int in [ 600 ] = { 0 }; priority_queue < int , vector < int > , greater < int > > que ; queue < int > k ; int n , m , x , y ; int toposort () { for ( int i = 1 ; i <= n ; i ++ ) { if ( ! in [ i ]) que . push ( i ); } while ( ! que . empty ()) { int now = que . top (); que . pop (); k . push ( now ); for ( int i = 0 ; i < g [ now ]. size (); i ++ ) { int t = g [ now ][ i ]; in [ t ] -- ; if ( ! in [ t ]) que . push ( t ); } } } int main () { while ( scanf ( \"%d%d\" , & n , & m ) != EOF ) { for ( int i = 1 ; i <= n ; i ++ ) g [ i ]. clear (), in [ i ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & x , & y ); g [ x ]. push_back ( y ); in [ y ] ++ ; } toposort (); int flag = 0 ; while ( ! k . empty ()) { if ( ! flag ) { printf ( \"%d\" , k . front ()); flag = 1 ; } else { printf ( \" %d\" , k . front ()); } k . pop (); } printf ( \" \\n \" ); } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2537&pid=5 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u6709\u4e00\u4e2an\u00d7n\u5927\u5c0f\u7684\u65b9\u5f62\u5e73\u9762\uff0c\u4e0a\u9762\u6709n\u00d7n\u4e2a\u70b9\uff0c\u6bcf\u4e2a\u70b9(i,j)\u7684\u503cwij\u662f\u7ed9\u5b9a\u7684\u3002 \u5bf9\u4e8e\u70b9(i,j)\uff0c\u6211\u4eec\u79f0\u4e0e\u5176\u6a2a\u7eb5\u4e0b\u6807\u4e4b\u5dee\u7684\u7edd\u5bf9\u503c\u90fd\u4e0d\u8d85\u8fc71\u7684\u70b9\u4e3a\u4e0e\u5176\u76f8\u90bb\u7684\u70b9\u3002 \u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u70b9\u7684\u96c6\u5408S\u4e3a\u6781\u5927\u70b9\u7fa4\uff08\u6781\u5c0f\u70b9\u7fa4\uff09\u5f53\u4e14\u4ec5\u5f53\uff1a 1.S\u4e2d\u6240\u6709\u70b9\u7684\u503c\u76f8\u540c\u3002 2.S\u4e2d\u6240\u6709\u70b9\u90fd\u76f4\u63a5\u6216\u95f4\u63a5\u76f8\u90bb\u3002 3.\u5bf9\u4e8e\u4efb\u610f\u76f8\u90bb\u4e24\u70b9s1,s2\uff0c\u6ee1\u8db3s1\u5c5e\u4e8eS\u4e14s2\u4e0d\u5c5e\u4e8eS\uff0c\u90fd\u6709s1\u7684\u503c>s2\u7684\u503c\uff08\u6781\u5927\u70b9\u7fa4\uff09\uff0c\u6216\u8005s1\u7684\u503c<s2\u7684\u503c\uff08\u6781\u5c0f\u70b9\u7fa4\uff09\u3002 \u5bf9\u4e8e\u7ed9\u5b9a\u7684\u5e73\u9762\uff0c\u4f60\u8981\u6c42\u51fa\u6781\u5927\u70b9\u7fa4\u548c\u6781\u5c0f\u70b9\u7fa4\u7684\u6570\u91cf\u3002\u7279\u522b\u7684\uff0c\u5982\u679c\u6240\u6709\u70b9\u7684\u503c\u90fd\u76f8\u540c\uff0c\u90a3\u4e48\u6574\u4e2a\u5e73\u9762\u5c31\u65e2\u662f\u6781\u5927\u70b9\u7fa4\uff0c\u53c8\u662f\u6781\u5c0f\u70b9\u7fa4\u3002 \u7531\u4e8e\u5de8\u795e ctt \u6b63\u5728\u548c\u5de8\u795e lzh \u4e92\u76f8\u540a\u6253\u6765\u540a\u6253\u53bb\uff0c\u4e8e\u662f\u53ea\u597d\u628a\u8fd9\u4e2a\u4efb\u52a1\u4ea4\u7ed9\u4e86\u4f60\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570n\uff0c\u8868\u793a\u5730\u56fe\u7684\u5927\u5c0f\u3002 \u63a5\u4e0b\u6765\u4e00\u4e2an\u00d7n\u7684\u77e9\u9635\uff0c\u8868\u793a\u5e73\u9762\u4e0a\u6bcf\u4e2a\u70b9\u7684\u503c\u3002 \u8f93\u51fa \u00b6 \u5305\u542b\u4e24\u4e2a\u6570\uff0c\u5206\u522b\u8868\u793a\u6781\u5927\u70b9\u7fa4\u548c\u6781\u5c0f\u70b9\u7fa4\u7684\u6570\u91cf\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 5 2 2 2 1 1 1 1 2 2 1 1 1 1 1 1 1 2 2 1 2 1 2 2 2 2 \u3010\u6837\u4f8b2\u3011 5 4 6 7 3 1 4 4 6 5 5 5 5 5 2 7 4 6 2 4 7 6 1 0 1 6 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 2 1 \u3010\u6837\u4f8b2\u3011 3 3 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca\uff1a \u5982\u4e0b\u56fe\u6240\u793a\uff0c\u6807\u84dd\u7684\u4e3a\u6781\u5927\u70b9\u7fa4\uff0c\u6807\u6a59\u7684\u4e3a\u6781\u5c0f\u70b9\u7fa4\u3002 \u6837\u4f8b2\u89e3\u91ca\uff1a \u5982\u4e0b\u56fe\u6240\u793a\uff0c\u6807\u84dd\u7684\u4e3a\u6781\u5927\u70b9\u7fa4\uff0c\u6807\u6a59\u7684\u4e3a\u6781\u5c0f\u70b9\u7fa4\u3002 DFS+\u6807\u8bb0\u3002 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef unsigned long long ull ; typedef long long ll ; ll a [ 2000 ][ 2000 ] = { 0 }; ll dx [] = { 0 , 1 , 1 , 1 , 0 , 0 , -1 , -1 , -1 }; ll dy [] = { 0 , 1 , 0 , -1 , 1 , -1 , 1 , 0 , -1 }; ll vis [ 2000 ][ 2000 ] = { 0 }; ll vis1 [ 2000 ][ 2000 ] = { 0 }; ll n ; ll sum = 1 ; ll dfs ( ll x , ll y ) { vis1 [ x ][ y ] = vis [ x ][ y ]; for ( ll i = 1 ; i <= 8 ; i ++ ) { ll x1 = x + dx [ i ]; ll y1 = y + dy [ i ]; if ( x1 <= 0 || x1 > n || y1 <= 0 || y1 > n ) continue ; if ( a [ x1 ][ y1 ] == a [ x ][ y ] && vis [ x ][ y ] != vis [ x1 ][ y1 ]) return -1 ; if ( a [ x1 ][ y1 ] == a [ x ][ y ] && vis [ x ][ y ] == vis [ x1 ][ y1 ] &&! vis1 [ x1 ][ y1 ]) { if ( dfs ( x1 , y1 ) == -1 ) return -1 ; } } } int main () { ll l ; int flagh = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 1 ; j <= n ; j ++ ) { scanf ( \"%lld\" , & a [ i ][ j ]); if ( i == 1 && j == 1 ) { l = a [ i ][ j ]; } else { if ( l != a [ i ][ j ]) flagh = 1 ; } } } if ( ! flagh ) { cout << 1 << ' ' << 1 << endl ; return 0 ; } for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 1 ; j <= n ; j ++ ) { ll flag1 = 1 ; ll flag2 = 1 ; for ( ll k = 1 ; k <= 8 ; k ++ ) { ll x = i + dx [ k ]; ll y = j + dy [ k ]; if ( x > n || x <= 0 || y > n || y <= 0 ) continue ; if ( a [ x ][ y ] > a [ i ][ j ]) { flag1 = 0 ; } if ( a [ x ][ y ] < a [ i ][ j ]) { flag2 = 0 ; } } if ( flag1 ) { vis [ i ][ j ] = 1 ; } if ( flag2 ) { vis [ i ][ j ] = 2 ; } } } ll sum1 = 0 , sum2 = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 1 ; j <= n ; j ++ ) { if ( vis [ i ][ j ] != 0 &&! vis1 [ i ][ j ]) { if ( dfs ( i , j ) == -1 ) continue ; if ( vis [ i ][ j ] == 1 ) sum1 ++ ; else sum2 ++ ; } } } cout << sum1 << ' ' << sum2 << endl ; return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2537&pid=1 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u897f\u2f50\u62c9\u5148\u77e5\u7cfb\u7edf\u662f\u2f00\u4e2a\u5f3a\u2f24\u7684\u2f3c\u7075\u6307\u6570\u76d1\u6d4b\u2f79\u7d61\uff0c\u80fd\u4ee5\u58f0\u50cf\u626b\u63cf\u4e3b\u52a8\u76d1\u63a7\u5e02\u2ea0\u7684\u2f3c\u667a\u4e0e\u7cbe\u795e\u72b6\u6001\u3002\u4e3a\u4e86\u5224\u5b9a\u51fa\u66f4\u590d\u6742\u7684\u2f08\u7c7b\u2f3c\u7406\u53c2\u6570\uff0c\u897f\u2f50\u62c9\u7cfb\u7edf\u7eb3\u2f0a\u4e86\u4e0d\u540c\u4e8e\u65e2\u5b58\u2f08\u7c7b\u89c4\u8303\u7684\u8d85\u7fa4\u2f08\u683c\u2500\u2500\u4e0d\u4f1a\u968f\u610f\u548c\u4ed6\u2f08\u4ea7\u2f63\u5171\u9e23\uff0c\u4e5f\u4e0d\u4f1a\u611f\u60c5\u2f64\u4e8b\uff0c\u80fd\u4ee5\u2fae\u2f08\u7c7b\u7684\u773c\u5149\u6765\u4fef\u77b0\u5e76\u88c1\u5b9a\u2f08\u7c7b\u3002 \u88ab\u7eb3\u2f0a\u7684\u8d85\u7fa4\u2f08\u683c\u4f1a\u76f8\u4e92\u5f71\u54cd\uff0c\u5171\u540c\u5904\u7406\u6570\u636e\u3002\u4ed6\u4eec\u4e4b\u95f4\u5177\u4f53\u7684\u5f71\u54cd\u2f45\u5f0f\u5f62\u5982\u2f00\u5f20\u2f46\u5411\u56fe\uff0c\u5982\u679c\u4f60\u5bf9\u2f00\u4e2a\u8282\u70b9\u8fdb\u2f8f\u64cd\u4f5c\uff0c\u548c\u8fd9\u4e2a\u8282\u70b9\u76f8\u90bb\u7684\u8282\u70b9\u4e5f\u4f1a\u53d7\u5230\u76f8\u540c\u7684\u5f71\u54cd\u3002 \u64cd\u4f5c\u6709\u2f00\u79cd\uff1a\u4f7f\u2f00\u4e2a\u8282\u70b9\u7684\u6743\u503c\u52a0\u4e0a\u3002 \u540c\u65f6\u4f60\u8fd8\u5e0c\u671b\u8be2\u95ee\u2f00\u4e2a\u8282\u70b9\u7684\u6743\u503c(\u6bcf\u2f00\u4e2a\u8282\u70b9\u7684\u521d\u59cb\u6743\u503c\u4e3a0)\u3002 \u8f93\u5165 \u00b6 \u7b2c\u2f00\u2f8f\u8bfb\u2f0an,m,Q,\u8868\u2f70\u8282\u70b9\u4e2a\u6570\u548c\u8fb9\u6570,\u4ee5\u53ca\u64cd\u4f5c\u548c\u8be2\u95ee\u7684\u603b\u6570\u3002 \u63a5\u4e0b\u6765m\u2f8f\uff0c\u6bcf\u2f8f\u4e24\u4e2a\u6570ui,vi\u8868\u2f70ui,vi\u4e4b\u95f4\u6709\u8fde\u8fb9\u3002 \u63a5\u4e0b\u6765Q\uff0c\u6bcf\u2f8f\u5148\u8bfb\u2f0a\u2f00\u4e2atype type=0\u8868\u2f70\u2f00\u4e2a\u8be2\u95ee\uff0c\u8bfb\u2f0a\u2f00\u4e2ax,\u8868\u2f70\u8be2\u95eex\u8282\u70b9\u7684\u6743\u503c\u3002 type=1\u8868\u2f70\u2f00\u4e2a\u64cd\u4f5c\uff0c\u8bfb\u2f0ax,y,\u8868\u2f70\u5c06x\u8282\u70b9\u7684\u6743\u503c\u52a0\u4e0ay\u3002\uff08\u4e0ex\u76f8\u90bb\u7684\u8282\u70b9\u6743\u503c\u4e5f\u8981\u52a0\u4e0ay\uff09 \u8f93\u51fa \u00b6 \u5bf9\u4e8e\u6bcf\u2f00\u4e2a\u8be2\u95ee\u8f93\u51fa\u2f00\u2f8f\uff0c\u8868\u2f70\u8be5\u8282\u70b9\u7684\u6743\u503c\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 4 4 4 1 2 1 3 1 4 2 3 1 1 1 0 2 1 3 3 0 2 \u6837\u4f8b\u8f93\u51fa \u00b6 1 4 \u63d0\u793a \u00b6 n,m,Q\u22643\u00d7105\uff0cy\u22641000 \u5206\u5757\u6cd5 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; vector < ll > v [ 1000500 ]; vector < ll > g [ 1000500 ]; vector < ll > b [ 1000500 ]; ll c [ 1000500 ] = { 0 }; int main () { register ll n , m , q , x , y ; scanf ( \"%lld%lld%lld\" , & n , & m , & q ); register ll k = sqrt ( m ); for ( register ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld\" , & x , & y ); v [ x ]. push_back ( y ); v [ y ]. push_back ( x ); } register ll s = n + 1 ; for ( register ll i = 1 ; i <= n ; i ++ ) { if ( v [ i ]. size () >= k ) { register ll t = 0 ; for ( ll j = 0 ; j < v [ i ]. size (); j ++ ) { t ++ ; b [ v [ i ][ j ]]. push_back ( s ); if ( t % k == 0 ) { g [ i ]. push_back ( s ); s ++ ; t = 0 ; } } if ( t % k ) { g [ i ]. push_back ( s ); s ++ ; } } } register ll status ; for ( register ll i = 1 ; i <= q ; i ++ ) { scanf ( \"%lld\" , & status ); if ( status == 0 ) { scanf ( \"%lld\" , & x ); ll t = c [ x ]; for ( register ll j = 0 ; j < b [ x ]. size (); j ++ ) { t += c [ b [ x ][ j ]]; } printf ( \"%lld \\n \" , t ); } else { scanf ( \"%lld%lld\" , & x , & y ); c [ x ] += y ; if ( v [ x ]. size () >= k ) { for ( register ll j = 0 ; j < g [ x ]. size (); j ++ ) { c [ g [ x ][ j ]] += y ; } } else { for ( register ll j = 0 ; j < v [ x ]. size (); j ++ ) { c [ v [ x ][ j ]] += y ; } } } } return 0 ; }","title":"2020-08-07"},{"location":"csdn/2020-08-07/#problem-description","text":"\u6709N\u4e2a\u6bd4\u8d5b\u961f\uff081<=N<=500\uff09\uff0c\u7f16\u53f7\u4f9d\u6b21\u4e3a1\uff0c2\uff0c3\uff0c\u3002\u3002\u3002\u3002\uff0cN\u8fdb\u884c\u6bd4\u8d5b\uff0c\u6bd4\u8d5b\u7ed3\u675f\u540e\uff0c\u88c1\u5224\u59d4\u5458\u4f1a\u8981\u5c06\u6240\u6709\u53c2\u8d5b\u961f\u4f0d\u4ece\u524d\u5f80\u540e\u4f9d\u6b21\u6392\u540d\uff0c\u4f46\u73b0\u5728\u88c1\u5224\u59d4\u5458\u4f1a\u4e0d\u80fd\u76f4\u63a5\u83b7\u5f97\u6bcf\u4e2a\u961f\u7684\u6bd4\u8d5b\u6210\u7ee9\uff0c\u53ea\u77e5\u9053\u6bcf\u573a\u6bd4\u8d5b\u7684\u7ed3\u679c\uff0c\u5373P1\u8d62P2\uff0c\u7528P1\uff0cP2\u8868\u793a\uff0c\u6392\u540d\u65f6P1\u5728P2\u4e4b\u524d\u3002\u73b0\u5728\u8bf7\u4f60\u7f16\u7a0b\u5e8f\u786e\u5b9a\u6392\u540d\u3002","title":"Problem Description"},{"location":"csdn/2020-08-07/#input","text":"\u8f93\u5165\u6709\u82e5\u5e72\u7ec4\uff0c\u6bcf\u7ec4\u4e2d\u7684\u7b2c\u4e00\u884c\u4e3a\u4e8c\u4e2a\u6570N\uff081<=N<=500\uff09\uff0cM\uff1b\u5176\u4e2dN\u8868\u793a\u961f\u4f0d\u7684\u4e2a\u6570\uff0cM\u8868\u793a\u63a5\u7740\u6709M\u884c\u7684\u8f93\u5165\u6570\u636e\u3002\u63a5\u4e0b\u6765\u7684M\u884c\u6570\u636e\u4e2d\uff0c\u6bcf\u884c\u4e5f\u6709\u4e24\u4e2a\u6574\u6570P1\uff0cP2\u8868\u793a\u5373P1\u961f\u8d62\u4e86P2\u961f\u3002","title":"Input"},{"location":"csdn/2020-08-07/#output","text":"\u7ed9\u51fa\u4e00\u4e2a\u7b26\u5408\u8981\u6c42\u7684\u6392\u540d\u3002\u8f93\u51fa\u65f6\u961f\u4f0d\u53f7\u4e4b\u95f4\u6709\u7a7a\u683c\uff0c\u6700\u540e\u4e00\u540d\u540e\u9762\u6ca1\u6709\u7a7a\u683c\u3002 \u5176\u4ed6\u8bf4\u660e\uff1a\u7b26\u5408\u6761\u4ef6\u7684\u6392\u540d\u53ef\u80fd\u4e0d\u662f\u552f\u4e00\u7684\uff0c\u6b64\u65f6\u8981\u6c42\u8f93\u51fa\u65f6\u7f16\u53f7\u5c0f\u7684\u961f\u4f0d\u5728\u524d\uff1b\u8f93\u5165\u6570\u636e\u4fdd\u8bc1\u662f\u6b63\u786e\u7684\uff0c\u5373\u8f93\u5165\u6570\u636e\u786e\u4fdd\u4e00\u5b9a\u80fd\u6709\u4e00\u4e2a\u7b26\u5408\u8981\u6c42\u7684\u6392\u540d\u3002","title":"Output"},{"location":"csdn/2020-08-07/#sample-input","text":"4 3 1 2 2 3 4 3","title":"Sample Input"},{"location":"csdn/2020-08-07/#sample-output","text":"1 2 4 3 \u62d3\u6251\u6392\u5e8f #include <iostream> #include <bits/stdc++.h> using namespace std ; vector < int > g [ 600 ]; int in [ 600 ] = { 0 }; priority_queue < int , vector < int > , greater < int > > que ; queue < int > k ; int n , m , x , y ; int toposort () { for ( int i = 1 ; i <= n ; i ++ ) { if ( ! in [ i ]) que . push ( i ); } while ( ! que . empty ()) { int now = que . top (); que . pop (); k . push ( now ); for ( int i = 0 ; i < g [ now ]. size (); i ++ ) { int t = g [ now ][ i ]; in [ t ] -- ; if ( ! in [ t ]) que . push ( t ); } } } int main () { while ( scanf ( \"%d%d\" , & n , & m ) != EOF ) { for ( int i = 1 ; i <= n ; i ++ ) g [ i ]. clear (), in [ i ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & x , & y ); g [ x ]. push_back ( y ); in [ y ] ++ ; } toposort (); int flag = 0 ; while ( ! k . empty ()) { if ( ! flag ) { printf ( \"%d\" , k . front ()); flag = 1 ; } else { printf ( \" %d\" , k . front ()); } k . pop (); } printf ( \" \\n \" ); } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2537&pid=5","title":"Sample Output"},{"location":"csdn/2020-08-07/#_1","text":"\u6709\u4e00\u4e2an\u00d7n\u5927\u5c0f\u7684\u65b9\u5f62\u5e73\u9762\uff0c\u4e0a\u9762\u6709n\u00d7n\u4e2a\u70b9\uff0c\u6bcf\u4e2a\u70b9(i,j)\u7684\u503cwij\u662f\u7ed9\u5b9a\u7684\u3002 \u5bf9\u4e8e\u70b9(i,j)\uff0c\u6211\u4eec\u79f0\u4e0e\u5176\u6a2a\u7eb5\u4e0b\u6807\u4e4b\u5dee\u7684\u7edd\u5bf9\u503c\u90fd\u4e0d\u8d85\u8fc71\u7684\u70b9\u4e3a\u4e0e\u5176\u76f8\u90bb\u7684\u70b9\u3002 \u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u70b9\u7684\u96c6\u5408S\u4e3a\u6781\u5927\u70b9\u7fa4\uff08\u6781\u5c0f\u70b9\u7fa4\uff09\u5f53\u4e14\u4ec5\u5f53\uff1a 1.S\u4e2d\u6240\u6709\u70b9\u7684\u503c\u76f8\u540c\u3002 2.S\u4e2d\u6240\u6709\u70b9\u90fd\u76f4\u63a5\u6216\u95f4\u63a5\u76f8\u90bb\u3002 3.\u5bf9\u4e8e\u4efb\u610f\u76f8\u90bb\u4e24\u70b9s1,s2\uff0c\u6ee1\u8db3s1\u5c5e\u4e8eS\u4e14s2\u4e0d\u5c5e\u4e8eS\uff0c\u90fd\u6709s1\u7684\u503c>s2\u7684\u503c\uff08\u6781\u5927\u70b9\u7fa4\uff09\uff0c\u6216\u8005s1\u7684\u503c<s2\u7684\u503c\uff08\u6781\u5c0f\u70b9\u7fa4\uff09\u3002 \u5bf9\u4e8e\u7ed9\u5b9a\u7684\u5e73\u9762\uff0c\u4f60\u8981\u6c42\u51fa\u6781\u5927\u70b9\u7fa4\u548c\u6781\u5c0f\u70b9\u7fa4\u7684\u6570\u91cf\u3002\u7279\u522b\u7684\uff0c\u5982\u679c\u6240\u6709\u70b9\u7684\u503c\u90fd\u76f8\u540c\uff0c\u90a3\u4e48\u6574\u4e2a\u5e73\u9762\u5c31\u65e2\u662f\u6781\u5927\u70b9\u7fa4\uff0c\u53c8\u662f\u6781\u5c0f\u70b9\u7fa4\u3002 \u7531\u4e8e\u5de8\u795e ctt \u6b63\u5728\u548c\u5de8\u795e lzh \u4e92\u76f8\u540a\u6253\u6765\u540a\u6253\u53bb\uff0c\u4e8e\u662f\u53ea\u597d\u628a\u8fd9\u4e2a\u4efb\u52a1\u4ea4\u7ed9\u4e86\u4f60\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-07/#_2","text":"\u7b2c\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570n\uff0c\u8868\u793a\u5730\u56fe\u7684\u5927\u5c0f\u3002 \u63a5\u4e0b\u6765\u4e00\u4e2an\u00d7n\u7684\u77e9\u9635\uff0c\u8868\u793a\u5e73\u9762\u4e0a\u6bcf\u4e2a\u70b9\u7684\u503c\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-07/#_3","text":"\u5305\u542b\u4e24\u4e2a\u6570\uff0c\u5206\u522b\u8868\u793a\u6781\u5927\u70b9\u7fa4\u548c\u6781\u5c0f\u70b9\u7fa4\u7684\u6570\u91cf\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-07/#_4","text":"\u3010\u6837\u4f8b1\u3011 5 2 2 2 1 1 1 1 2 2 1 1 1 1 1 1 1 2 2 1 2 1 2 2 2 2 \u3010\u6837\u4f8b2\u3011 5 4 6 7 3 1 4 4 6 5 5 5 5 5 2 7 4 6 2 4 7 6 1 0 1 6","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-07/#_5","text":"\u3010\u6837\u4f8b1\u3011 2 1 \u3010\u6837\u4f8b2\u3011 3 3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-07/#_6","text":"\u6837\u4f8b1\u89e3\u91ca\uff1a \u5982\u4e0b\u56fe\u6240\u793a\uff0c\u6807\u84dd\u7684\u4e3a\u6781\u5927\u70b9\u7fa4\uff0c\u6807\u6a59\u7684\u4e3a\u6781\u5c0f\u70b9\u7fa4\u3002 \u6837\u4f8b2\u89e3\u91ca\uff1a \u5982\u4e0b\u56fe\u6240\u793a\uff0c\u6807\u84dd\u7684\u4e3a\u6781\u5927\u70b9\u7fa4\uff0c\u6807\u6a59\u7684\u4e3a\u6781\u5c0f\u70b9\u7fa4\u3002 DFS+\u6807\u8bb0\u3002 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef unsigned long long ull ; typedef long long ll ; ll a [ 2000 ][ 2000 ] = { 0 }; ll dx [] = { 0 , 1 , 1 , 1 , 0 , 0 , -1 , -1 , -1 }; ll dy [] = { 0 , 1 , 0 , -1 , 1 , -1 , 1 , 0 , -1 }; ll vis [ 2000 ][ 2000 ] = { 0 }; ll vis1 [ 2000 ][ 2000 ] = { 0 }; ll n ; ll sum = 1 ; ll dfs ( ll x , ll y ) { vis1 [ x ][ y ] = vis [ x ][ y ]; for ( ll i = 1 ; i <= 8 ; i ++ ) { ll x1 = x + dx [ i ]; ll y1 = y + dy [ i ]; if ( x1 <= 0 || x1 > n || y1 <= 0 || y1 > n ) continue ; if ( a [ x1 ][ y1 ] == a [ x ][ y ] && vis [ x ][ y ] != vis [ x1 ][ y1 ]) return -1 ; if ( a [ x1 ][ y1 ] == a [ x ][ y ] && vis [ x ][ y ] == vis [ x1 ][ y1 ] &&! vis1 [ x1 ][ y1 ]) { if ( dfs ( x1 , y1 ) == -1 ) return -1 ; } } } int main () { ll l ; int flagh = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 1 ; j <= n ; j ++ ) { scanf ( \"%lld\" , & a [ i ][ j ]); if ( i == 1 && j == 1 ) { l = a [ i ][ j ]; } else { if ( l != a [ i ][ j ]) flagh = 1 ; } } } if ( ! flagh ) { cout << 1 << ' ' << 1 << endl ; return 0 ; } for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 1 ; j <= n ; j ++ ) { ll flag1 = 1 ; ll flag2 = 1 ; for ( ll k = 1 ; k <= 8 ; k ++ ) { ll x = i + dx [ k ]; ll y = j + dy [ k ]; if ( x > n || x <= 0 || y > n || y <= 0 ) continue ; if ( a [ x ][ y ] > a [ i ][ j ]) { flag1 = 0 ; } if ( a [ x ][ y ] < a [ i ][ j ]) { flag2 = 0 ; } } if ( flag1 ) { vis [ i ][ j ] = 1 ; } if ( flag2 ) { vis [ i ][ j ] = 2 ; } } } ll sum1 = 0 , sum2 = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 1 ; j <= n ; j ++ ) { if ( vis [ i ][ j ] != 0 &&! vis1 [ i ][ j ]) { if ( dfs ( i , j ) == -1 ) continue ; if ( vis [ i ][ j ] == 1 ) sum1 ++ ; else sum2 ++ ; } } } cout << sum1 << ' ' << sum2 << endl ; return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2537&pid=1","title":"\u63d0\u793a"},{"location":"csdn/2020-08-07/#_7","text":"\u897f\u2f50\u62c9\u5148\u77e5\u7cfb\u7edf\u662f\u2f00\u4e2a\u5f3a\u2f24\u7684\u2f3c\u7075\u6307\u6570\u76d1\u6d4b\u2f79\u7d61\uff0c\u80fd\u4ee5\u58f0\u50cf\u626b\u63cf\u4e3b\u52a8\u76d1\u63a7\u5e02\u2ea0\u7684\u2f3c\u667a\u4e0e\u7cbe\u795e\u72b6\u6001\u3002\u4e3a\u4e86\u5224\u5b9a\u51fa\u66f4\u590d\u6742\u7684\u2f08\u7c7b\u2f3c\u7406\u53c2\u6570\uff0c\u897f\u2f50\u62c9\u7cfb\u7edf\u7eb3\u2f0a\u4e86\u4e0d\u540c\u4e8e\u65e2\u5b58\u2f08\u7c7b\u89c4\u8303\u7684\u8d85\u7fa4\u2f08\u683c\u2500\u2500\u4e0d\u4f1a\u968f\u610f\u548c\u4ed6\u2f08\u4ea7\u2f63\u5171\u9e23\uff0c\u4e5f\u4e0d\u4f1a\u611f\u60c5\u2f64\u4e8b\uff0c\u80fd\u4ee5\u2fae\u2f08\u7c7b\u7684\u773c\u5149\u6765\u4fef\u77b0\u5e76\u88c1\u5b9a\u2f08\u7c7b\u3002 \u88ab\u7eb3\u2f0a\u7684\u8d85\u7fa4\u2f08\u683c\u4f1a\u76f8\u4e92\u5f71\u54cd\uff0c\u5171\u540c\u5904\u7406\u6570\u636e\u3002\u4ed6\u4eec\u4e4b\u95f4\u5177\u4f53\u7684\u5f71\u54cd\u2f45\u5f0f\u5f62\u5982\u2f00\u5f20\u2f46\u5411\u56fe\uff0c\u5982\u679c\u4f60\u5bf9\u2f00\u4e2a\u8282\u70b9\u8fdb\u2f8f\u64cd\u4f5c\uff0c\u548c\u8fd9\u4e2a\u8282\u70b9\u76f8\u90bb\u7684\u8282\u70b9\u4e5f\u4f1a\u53d7\u5230\u76f8\u540c\u7684\u5f71\u54cd\u3002 \u64cd\u4f5c\u6709\u2f00\u79cd\uff1a\u4f7f\u2f00\u4e2a\u8282\u70b9\u7684\u6743\u503c\u52a0\u4e0a\u3002 \u540c\u65f6\u4f60\u8fd8\u5e0c\u671b\u8be2\u95ee\u2f00\u4e2a\u8282\u70b9\u7684\u6743\u503c(\u6bcf\u2f00\u4e2a\u8282\u70b9\u7684\u521d\u59cb\u6743\u503c\u4e3a0)\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-07/#_8","text":"\u7b2c\u2f00\u2f8f\u8bfb\u2f0an,m,Q,\u8868\u2f70\u8282\u70b9\u4e2a\u6570\u548c\u8fb9\u6570,\u4ee5\u53ca\u64cd\u4f5c\u548c\u8be2\u95ee\u7684\u603b\u6570\u3002 \u63a5\u4e0b\u6765m\u2f8f\uff0c\u6bcf\u2f8f\u4e24\u4e2a\u6570ui,vi\u8868\u2f70ui,vi\u4e4b\u95f4\u6709\u8fde\u8fb9\u3002 \u63a5\u4e0b\u6765Q\uff0c\u6bcf\u2f8f\u5148\u8bfb\u2f0a\u2f00\u4e2atype type=0\u8868\u2f70\u2f00\u4e2a\u8be2\u95ee\uff0c\u8bfb\u2f0a\u2f00\u4e2ax,\u8868\u2f70\u8be2\u95eex\u8282\u70b9\u7684\u6743\u503c\u3002 type=1\u8868\u2f70\u2f00\u4e2a\u64cd\u4f5c\uff0c\u8bfb\u2f0ax,y,\u8868\u2f70\u5c06x\u8282\u70b9\u7684\u6743\u503c\u52a0\u4e0ay\u3002\uff08\u4e0ex\u76f8\u90bb\u7684\u8282\u70b9\u6743\u503c\u4e5f\u8981\u52a0\u4e0ay\uff09","title":"\u8f93\u5165"},{"location":"csdn/2020-08-07/#_9","text":"\u5bf9\u4e8e\u6bcf\u2f00\u4e2a\u8be2\u95ee\u8f93\u51fa\u2f00\u2f8f\uff0c\u8868\u2f70\u8be5\u8282\u70b9\u7684\u6743\u503c\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-07/#_10","text":"4 4 4 1 2 1 3 1 4 2 3 1 1 1 0 2 1 3 3 0 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-07/#_11","text":"1 4","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-07/#_12","text":"n,m,Q\u22643\u00d7105\uff0cy\u22641000 \u5206\u5757\u6cd5 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; vector < ll > v [ 1000500 ]; vector < ll > g [ 1000500 ]; vector < ll > b [ 1000500 ]; ll c [ 1000500 ] = { 0 }; int main () { register ll n , m , q , x , y ; scanf ( \"%lld%lld%lld\" , & n , & m , & q ); register ll k = sqrt ( m ); for ( register ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld\" , & x , & y ); v [ x ]. push_back ( y ); v [ y ]. push_back ( x ); } register ll s = n + 1 ; for ( register ll i = 1 ; i <= n ; i ++ ) { if ( v [ i ]. size () >= k ) { register ll t = 0 ; for ( ll j = 0 ; j < v [ i ]. size (); j ++ ) { t ++ ; b [ v [ i ][ j ]]. push_back ( s ); if ( t % k == 0 ) { g [ i ]. push_back ( s ); s ++ ; t = 0 ; } } if ( t % k ) { g [ i ]. push_back ( s ); s ++ ; } } } register ll status ; for ( register ll i = 1 ; i <= q ; i ++ ) { scanf ( \"%lld\" , & status ); if ( status == 0 ) { scanf ( \"%lld\" , & x ); ll t = c [ x ]; for ( register ll j = 0 ; j < b [ x ]. size (); j ++ ) { t += c [ b [ x ][ j ]]; } printf ( \"%lld \\n \" , t ); } else { scanf ( \"%lld%lld\" , & x , & y ); c [ x ] += y ; if ( v [ x ]. size () >= k ) { for ( register ll j = 0 ; j < g [ x ]. size (); j ++ ) { c [ g [ x ][ j ]] += y ; } } else { for ( register ll j = 0 ; j < v [ x ]. size (); j ++ ) { c [ v [ x ][ j ]] += y ; } } } } return 0 ; }","title":"\u63d0\u793a"},{"location":"csdn/2020-08-08/","text":"http://icpc.upc.edu.cn/problem.php?id=14431 \u9898\u76ee \u00b6 14431: \u7ebf\u6bb5 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u5e73\u9762\u4e0a\u6709N\u4e2a\u4e0d\u76f8\u4ea4\u7684\u7ebf\u6bb5\uff0c\u7f16\u53f71\u5230N\uff0c\u9700\u8981\u6a21\u62df\u4e0b\u843d\uff0c\u5373\u7ebf\u6bb5\u4e0d\u65cb\u8f6c\u5730\u5782\u76f4\u5411\u4e0b\u79fb\u52a8\u5230X\u8f74\u4e0b\u9762\u3002\u5982\u4e0b\u56fe\uff1a \u73b0\u5728\u8981\u4f60\u6765\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u6bcf\u6b21\u5411\u4e0b\u79fb\u52a8\u4e00\u4e2a\u7ebf\u6bb5\uff0cN\u6b21\u540e\u79fb\u8d70\u5168\u90e8\u7ebf\u6bb5\u3002\u4f46\u6709\u4e00\u4e2a\u8981\u6c42\uff1a\u79fb\u52a8\u4e00\u4e2a\u7ebf\u6bb5\u65f6\u4e0d\u80fd\u548c\u5176\u4ed6\u7ebf\u6bb5\u76f8\u78b0\u3002\u56e0\u6b64\u9009\u62e9\u7ebf\u6bb5\u7684\u6b21\u5e8f\u5f88\u91cd\u8981\u3002\u8bf7\u8f93\u51fa\u4f60\u5236\u5b9a\u7684\u6b21\u5e8f\u65b9\u6848\uff0c\u65b9\u6848\u53ef\u80fd\u6709\u591a\u4e2a\uff0c\u4f60\u53ea\u8981\u8f93\u51fa\u5176\u4e2d\u7684\u4e00\u4e2a\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u5305\u542b 1 \u4e2a\u6574\u6570 N\uff0c1\u2264N\u22645000\u3002 \u4e0b\u9762 N \u884c\uff0c\u6bcf\u884c 4 \u4e2a\u6574\u6570 X1,Y1,X2,Y2\uff0c0 \u2264 X1,Y1,X2,Y2 \u2264 10000\u3002\u8868\u793a\u7b2c 1 \u53f7\u5230\u7b2c N \u53f7\u7ebf\u6bb5\u7684 2 \u4e2a \u7aef\u70b9\u3002 \u8f93\u51fa \u00b6 \u4e00\u884c N \u4e2a\u6574\u6570\uff0c\u662f 1 \u5230 N \u7684\u4e00\u4e2a\u6392\u5217\uff0c\u8868\u793a\u6309\u6b21\u5e8f\u5148\u540e\u4e0b\u843d\u7684\u7ebf\u6bb5\u7f16\u53f7\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 4 1 3 2 2 1 1 3 2 2 4 7 3 3 3 5 3 \u3010\u6837\u4f8b2\u3011 4 0 0 1 1 1 2 0 3 2 2 3 3 4 0 3 1 \u3010\u6837\u4f8b3\u3011 3 4 6 5 5 2 1 15 1 3 2 8 7 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 2 4 1 3 \u3010\u6837\u4f8b2\u3011 4 3 1 2 \u3010\u6837\u4f8b3\u3011 2 3 1 \u62d3\u6251\u6392\u5e8f\uff0c\u679a\u4e3e\u5e76\u5224\u65ad\u4e24\u4e24\u4e4b\u95f4\u7684\u6b21\u5e8f\uff0c\u7136\u540e\u518d\u8dd1\u4e00\u904d\u62d3\u6251\u6392\u5e8f\u5373\u53ef\u3002 /** * * \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u795e\u517d\u51fa\u6ca1\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 * *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u250f\u2513\u3000\u3000\u3000\u250f\u2513+ + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u250f\u251b\u253b\u2501\u2501\u2501\u251b\u253b\u2513 + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 \u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2501\u3000\u3000\u3000\u2503 ++ + + + *\u3000\u3000\u3000\u3000\u3000\u3000 \u2588\u2588\u2588\u2588\u2501\u2588\u2588\u2588\u2588 \u2503+ *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u253b\u3000\u3000\u3000\u2503 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2517\u2501\u2513\u3000\u3000\u3000\u250f\u2501\u251b *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503 + + + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000Code is far away from bug with the animal protecting\u3000\u3000\u3000\u3000\u3000\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503 + \u3000\u3000\u3000\u3000\u795e\u517d\u4fdd\u4f51,\u4ee3\u7801\u65e0bug\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503\u3000\u3000+\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000 \u3000\u3000\u2517\u2501\u2501\u2501\u2513 + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2523\u2513 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u250f\u251b *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2517\u2513\u2513\u250f\u2501\u2533\u2513\u250f\u251b + + + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u252b\u252b\u3000\u2503\u252b\u252b *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2517\u253b\u251b\u3000\u2517\u253b\u251b+ + + + * * \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u611f\u89c9\u840c\u840c\u54d2\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 */ #include <iostream> #include <bits/stdc++.h> using namespace std; struct node { int x1,x2,y1,y2; }; node a[5050]= {0}; vector<int>w[5050]; int in[5050]= {0}; int pd(int x,int y) { int min1=max(a[x].x1,a[y].x1),max1=min(a[x].x2,a[y].x2); if(min1>max1) return 0; double kx=(a[x].y1-a[x].y2)*1.0/(a[x].x1-a[x].x2); if(a[x].x1==a[x].x2) kx=0; double ky=(a[y].y1-a[y].y2)*1.0/(a[y].x1-a[y].x2); if(a[y].x1==a[y].x2) ky=0; double x1=a[x].y1+kx*1.0*(min1-a[x].x1); double x2=a[x].y1+kx*1.0*(max1-a[x].x1); double y1=a[y].y1+ky*1.0*(min1-a[y].x1); double y2=a[y].y1+ky*1.0*(max1-a[y].x1); if(min(x1,x2)>min(y1,y2)||max(x1,x2)>max(y1,y2)) return 1; else return 0; } int main() { int n; scanf(\"%d\",&n); for(int i=1; i<=n; i++) { scanf(\"%d%d%d%d\",&a[i].x1,&a[i].y1,&a[i].x2,&a[i].y2); if(a[i].x1>a[i].x2) { swap(a[i].x1,a[i].x2); swap(a[i].y1,a[i].y2); } } for(int i=1; i<=n; i++) { for(int j=1; j<=n; j++) { if(i==j) continue; if(pd(i,j)) { w[j].push_back(i); in[i]++; } } } priority_queue<int,vector<int>,less<int> >w1; queue<int>ans; for(int i=1; i<=n; i++) { if(in[i]==0) w1.push(i); } while(!w1.empty()) { int x=w1.top(); w1.pop(); ans.push(x); for(int i=0; i<w[x].size(); i++) { in[w[x][i]]--; if(in[w[x][i]]==0) { w1.push(w[x][i]); } } } while(!ans.empty()) { printf(\"%d \",ans.front()); ans.pop(); } return 0; } http://icpc.upc.edu.cn/problem.php?id=14850 \u9898\u76ee \u00b6 14850: \u5956\u91d1 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u7531\u4e8e\u65e0\u654c\u7684\u51e1\u51e1\u57282005\u5e74\u4e16\u754c\u82f1\u4fca\u5e05\u6c14\u7537\u603b\u51b3\u9009\u4e2d\u80dc\u51fa\uff0cYali Company\u603b\u7ecf\u7406Mr.Z\u5fc3\u60c5\u597d\uff0c\u51b3\u5b9a\u7ed9\u6bcf\u4f4d\u5458\u5de5\u53d1\u5956\u91d1\u3002\u516c\u53f8\u51b3\u5b9a\u4ee5\u6bcf\u4e2a\u4eba\u672c\u5e74\u5728\u516c\u53f8\u7684\u8d21\u732e\u4e3a\u6807\u51c6\u6765\u8ba1\u7b97\u4ed6\u4eec\u5f97\u5230\u5956\u91d1\u7684\u591a\u5c11\u3002 \u4e8e\u662fMr.Z\u4e0b\u4ee4\u53ec\u5f00m\u65b9\u4f1a\u8c08\u3002\u6bcf\u4f4d\u53c2\u52a0\u4f1a\u8c08\u7684\u4ee3\u8868\u63d0\u51fa\u4e86\u81ea\u5df1\u7684\u610f\u89c1\uff1a\u201c\u6211\u8ba4\u4e3a\u5458\u5de5a\u7684\u5956\u91d1\u5e94\u8be5\u6bd4b\u9ad8\uff01\u201dMr.Z\u51b3\u5b9a\u8981\u627e\u51fa\u4e00\u79cd\u5956\u91d1\u65b9\u6848\uff0c\u6ee1\u8db3\u5404\u4f4d\u4ee3\u8868\u7684\u610f\u89c1\uff0c\u4e14\u540c\u65f6\u4f7f\u5f97\u603b\u5956\u91d1\u6570\u6700\u5c11\u3002\u6bcf\u4f4d\u5458\u5de5\u5956\u91d1\u6700\u5c11\u4e3a100\u5143\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e24\u4e2a\u6574\u6570n,m\uff0c\u8868\u793a\u5458\u5de5\u603b\u6570\u548c\u4ee3\u8868\u6570\uff1b \u4ee5\u4e0bm\u884c\uff0c\u6bcf\u884c2\u4e2a\u6574\u6570a,b\uff0c\u8868\u793a\u67d0\u4e2a\u4ee3\u8868\u8ba4\u4e3a\u7b2ca\u53f7\u5458\u5de5\u5956\u91d1\u5e94\u8be5\u6bd4\u7b2cb\u53f7\u5458\u5de5\u9ad8\u3002 \u8f93\u51fa \u00b6 \u82e5\u65e0\u6cd5\u627e\u5230\u5408\u6cd5\u65b9\u6848\uff0c\u5219\u8f93\u51fa\u201cPoor Xed\u201d\uff1b\u5426\u5219\u8f93\u51fa\u4e00\u4e2a\u6570\u8868\u793a\u6700\u5c11\u603b\u5956\u91d1\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 2 1 1 2 \u6837\u4f8b\u8f93\u51fa \u00b6 201 \u63d0\u793a \u00b6 80\uff05\u7684\u6570\u636e\u6ee1\u8db3n<=1000\uff0cm<=2000\uff1b 100\uff05\u7684\u6570\u636e\u6ee1\u8db3n<=10000\uff0cm<=20000\u3002 \u62d3\u6251\u6392\u5e8f /** * * \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u795e\u517d\u51fa\u6ca1\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 * *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u250f\u2513\u3000\u3000\u3000\u250f\u2513+ + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u250f\u251b\u253b\u2501\u2501\u2501\u251b\u253b\u2513 + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 \u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2501\u3000\u3000\u3000\u2503 ++ + + + *\u3000\u3000\u3000\u3000\u3000\u3000 \u2588\u2588\u2588\u2588\u2501\u2588\u2588\u2588\u2588 \u2503+ *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u253b\u3000\u3000\u3000\u2503 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2517\u2501\u2513\u3000\u3000\u3000\u250f\u2501\u251b *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503 + + + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000Code is far away from bug with the animal protecting\u3000\u3000\u3000\u3000\u3000\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503 + \u3000\u3000\u3000\u3000\u795e\u517d\u4fdd\u4f51,\u4ee3\u7801\u65e0bug\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503\u3000\u3000+\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000 \u3000\u3000\u2517\u2501\u2501\u2501\u2513 + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2523\u2513 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u250f\u251b *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2517\u2513\u2513\u250f\u2501\u2533\u2513\u250f\u251b + + + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u252b\u252b\u3000\u2503\u252b\u252b *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2517\u253b\u251b\u3000\u2517\u253b\u251b+ + + + * * \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u611f\u89c9\u840c\u840c\u54d2\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 */ #include <iostream> #include <bits/stdc++.h> using namespace std; typedef long long ll; vector<int>w[105050]; int in[105050]= {0}; int ans[100500]={0}; struct node { int x,y; }; int main() { int n,m,a,b; scanf(\"%d%d\",&n,&m); for(int i=1; i<=m; i++) { scanf(\"%d%d\",&a,&b); w[b].push_back(a); in[a]++; } queue<node>w1; for(int i=1; i<=n; i++) { if(in[i]==0) w1.push(node{i,100}),ans[i]=100; } ll sum=0; while(!w1.empty()) { node p=w1.front(); w1.pop(); for(int i=0; i<w[p.x].size(); i++) { in[w[p.x][i]]--; ans[w[p.x][i]]=max(ans[w[p.x][i]],p.y+1); if(in[w[p.x][i]]==0) { w1.push(node{w[p.x][i],ans[w[p.x][i]]}); } } } for(int i=1;i<=n;i++) { if(in[i]!=0) ///\u5224\u73af { printf(\"Poor Xed\\n\"); return 0; } sum+=ans[i]; } printf(\"%lld\\n\",sum); return 0; }","title":"2020-08-08"},{"location":"csdn/2020-08-08/#_1","text":"14431: \u7ebf\u6bb5","title":"\u9898\u76ee"},{"location":"csdn/2020-08-08/#_2","text":"\u5e73\u9762\u4e0a\u6709N\u4e2a\u4e0d\u76f8\u4ea4\u7684\u7ebf\u6bb5\uff0c\u7f16\u53f71\u5230N\uff0c\u9700\u8981\u6a21\u62df\u4e0b\u843d\uff0c\u5373\u7ebf\u6bb5\u4e0d\u65cb\u8f6c\u5730\u5782\u76f4\u5411\u4e0b\u79fb\u52a8\u5230X\u8f74\u4e0b\u9762\u3002\u5982\u4e0b\u56fe\uff1a \u73b0\u5728\u8981\u4f60\u6765\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u6bcf\u6b21\u5411\u4e0b\u79fb\u52a8\u4e00\u4e2a\u7ebf\u6bb5\uff0cN\u6b21\u540e\u79fb\u8d70\u5168\u90e8\u7ebf\u6bb5\u3002\u4f46\u6709\u4e00\u4e2a\u8981\u6c42\uff1a\u79fb\u52a8\u4e00\u4e2a\u7ebf\u6bb5\u65f6\u4e0d\u80fd\u548c\u5176\u4ed6\u7ebf\u6bb5\u76f8\u78b0\u3002\u56e0\u6b64\u9009\u62e9\u7ebf\u6bb5\u7684\u6b21\u5e8f\u5f88\u91cd\u8981\u3002\u8bf7\u8f93\u51fa\u4f60\u5236\u5b9a\u7684\u6b21\u5e8f\u65b9\u6848\uff0c\u65b9\u6848\u53ef\u80fd\u6709\u591a\u4e2a\uff0c\u4f60\u53ea\u8981\u8f93\u51fa\u5176\u4e2d\u7684\u4e00\u4e2a\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-08/#_3","text":"\u7b2c\u4e00\u884c\u5305\u542b 1 \u4e2a\u6574\u6570 N\uff0c1\u2264N\u22645000\u3002 \u4e0b\u9762 N \u884c\uff0c\u6bcf\u884c 4 \u4e2a\u6574\u6570 X1,Y1,X2,Y2\uff0c0 \u2264 X1,Y1,X2,Y2 \u2264 10000\u3002\u8868\u793a\u7b2c 1 \u53f7\u5230\u7b2c N \u53f7\u7ebf\u6bb5\u7684 2 \u4e2a \u7aef\u70b9\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-08/#_4","text":"\u4e00\u884c N \u4e2a\u6574\u6570\uff0c\u662f 1 \u5230 N \u7684\u4e00\u4e2a\u6392\u5217\uff0c\u8868\u793a\u6309\u6b21\u5e8f\u5148\u540e\u4e0b\u843d\u7684\u7ebf\u6bb5\u7f16\u53f7\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-08/#_5","text":"\u3010\u6837\u4f8b1\u3011 4 1 3 2 2 1 1 3 2 2 4 7 3 3 3 5 3 \u3010\u6837\u4f8b2\u3011 4 0 0 1 1 1 2 0 3 2 2 3 3 4 0 3 1 \u3010\u6837\u4f8b3\u3011 3 4 6 5 5 2 1 15 1 3 2 8 7","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-08/#_6","text":"\u3010\u6837\u4f8b1\u3011 2 4 1 3 \u3010\u6837\u4f8b2\u3011 4 3 1 2 \u3010\u6837\u4f8b3\u3011 2 3 1 \u62d3\u6251\u6392\u5e8f\uff0c\u679a\u4e3e\u5e76\u5224\u65ad\u4e24\u4e24\u4e4b\u95f4\u7684\u6b21\u5e8f\uff0c\u7136\u540e\u518d\u8dd1\u4e00\u904d\u62d3\u6251\u6392\u5e8f\u5373\u53ef\u3002 /** * * \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u795e\u517d\u51fa\u6ca1\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 * *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u250f\u2513\u3000\u3000\u3000\u250f\u2513+ + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u250f\u251b\u253b\u2501\u2501\u2501\u251b\u253b\u2513 + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 \u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2501\u3000\u3000\u3000\u2503 ++ + + + *\u3000\u3000\u3000\u3000\u3000\u3000 \u2588\u2588\u2588\u2588\u2501\u2588\u2588\u2588\u2588 \u2503+ *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u253b\u3000\u3000\u3000\u2503 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2517\u2501\u2513\u3000\u3000\u3000\u250f\u2501\u251b *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503 + + + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000Code is far away from bug with the animal protecting\u3000\u3000\u3000\u3000\u3000\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503 + \u3000\u3000\u3000\u3000\u795e\u517d\u4fdd\u4f51,\u4ee3\u7801\u65e0bug\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503\u3000\u3000+\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000 \u3000\u3000\u2517\u2501\u2501\u2501\u2513 + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2523\u2513 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u250f\u251b *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2517\u2513\u2513\u250f\u2501\u2533\u2513\u250f\u251b + + + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u252b\u252b\u3000\u2503\u252b\u252b *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2517\u253b\u251b\u3000\u2517\u253b\u251b+ + + + * * \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u611f\u89c9\u840c\u840c\u54d2\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 */ #include <iostream> #include <bits/stdc++.h> using namespace std; struct node { int x1,x2,y1,y2; }; node a[5050]= {0}; vector<int>w[5050]; int in[5050]= {0}; int pd(int x,int y) { int min1=max(a[x].x1,a[y].x1),max1=min(a[x].x2,a[y].x2); if(min1>max1) return 0; double kx=(a[x].y1-a[x].y2)*1.0/(a[x].x1-a[x].x2); if(a[x].x1==a[x].x2) kx=0; double ky=(a[y].y1-a[y].y2)*1.0/(a[y].x1-a[y].x2); if(a[y].x1==a[y].x2) ky=0; double x1=a[x].y1+kx*1.0*(min1-a[x].x1); double x2=a[x].y1+kx*1.0*(max1-a[x].x1); double y1=a[y].y1+ky*1.0*(min1-a[y].x1); double y2=a[y].y1+ky*1.0*(max1-a[y].x1); if(min(x1,x2)>min(y1,y2)||max(x1,x2)>max(y1,y2)) return 1; else return 0; } int main() { int n; scanf(\"%d\",&n); for(int i=1; i<=n; i++) { scanf(\"%d%d%d%d\",&a[i].x1,&a[i].y1,&a[i].x2,&a[i].y2); if(a[i].x1>a[i].x2) { swap(a[i].x1,a[i].x2); swap(a[i].y1,a[i].y2); } } for(int i=1; i<=n; i++) { for(int j=1; j<=n; j++) { if(i==j) continue; if(pd(i,j)) { w[j].push_back(i); in[i]++; } } } priority_queue<int,vector<int>,less<int> >w1; queue<int>ans; for(int i=1; i<=n; i++) { if(in[i]==0) w1.push(i); } while(!w1.empty()) { int x=w1.top(); w1.pop(); ans.push(x); for(int i=0; i<w[x].size(); i++) { in[w[x][i]]--; if(in[w[x][i]]==0) { w1.push(w[x][i]); } } } while(!ans.empty()) { printf(\"%d \",ans.front()); ans.pop(); } return 0; } http://icpc.upc.edu.cn/problem.php?id=14850","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-08/#_7","text":"14850: \u5956\u91d1","title":"\u9898\u76ee"},{"location":"csdn/2020-08-08/#_8","text":"\u7531\u4e8e\u65e0\u654c\u7684\u51e1\u51e1\u57282005\u5e74\u4e16\u754c\u82f1\u4fca\u5e05\u6c14\u7537\u603b\u51b3\u9009\u4e2d\u80dc\u51fa\uff0cYali Company\u603b\u7ecf\u7406Mr.Z\u5fc3\u60c5\u597d\uff0c\u51b3\u5b9a\u7ed9\u6bcf\u4f4d\u5458\u5de5\u53d1\u5956\u91d1\u3002\u516c\u53f8\u51b3\u5b9a\u4ee5\u6bcf\u4e2a\u4eba\u672c\u5e74\u5728\u516c\u53f8\u7684\u8d21\u732e\u4e3a\u6807\u51c6\u6765\u8ba1\u7b97\u4ed6\u4eec\u5f97\u5230\u5956\u91d1\u7684\u591a\u5c11\u3002 \u4e8e\u662fMr.Z\u4e0b\u4ee4\u53ec\u5f00m\u65b9\u4f1a\u8c08\u3002\u6bcf\u4f4d\u53c2\u52a0\u4f1a\u8c08\u7684\u4ee3\u8868\u63d0\u51fa\u4e86\u81ea\u5df1\u7684\u610f\u89c1\uff1a\u201c\u6211\u8ba4\u4e3a\u5458\u5de5a\u7684\u5956\u91d1\u5e94\u8be5\u6bd4b\u9ad8\uff01\u201dMr.Z\u51b3\u5b9a\u8981\u627e\u51fa\u4e00\u79cd\u5956\u91d1\u65b9\u6848\uff0c\u6ee1\u8db3\u5404\u4f4d\u4ee3\u8868\u7684\u610f\u89c1\uff0c\u4e14\u540c\u65f6\u4f7f\u5f97\u603b\u5956\u91d1\u6570\u6700\u5c11\u3002\u6bcf\u4f4d\u5458\u5de5\u5956\u91d1\u6700\u5c11\u4e3a100\u5143\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-08/#_9","text":"\u7b2c\u4e00\u884c\u4e24\u4e2a\u6574\u6570n,m\uff0c\u8868\u793a\u5458\u5de5\u603b\u6570\u548c\u4ee3\u8868\u6570\uff1b \u4ee5\u4e0bm\u884c\uff0c\u6bcf\u884c2\u4e2a\u6574\u6570a,b\uff0c\u8868\u793a\u67d0\u4e2a\u4ee3\u8868\u8ba4\u4e3a\u7b2ca\u53f7\u5458\u5de5\u5956\u91d1\u5e94\u8be5\u6bd4\u7b2cb\u53f7\u5458\u5de5\u9ad8\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-08/#_10","text":"\u82e5\u65e0\u6cd5\u627e\u5230\u5408\u6cd5\u65b9\u6848\uff0c\u5219\u8f93\u51fa\u201cPoor Xed\u201d\uff1b\u5426\u5219\u8f93\u51fa\u4e00\u4e2a\u6570\u8868\u793a\u6700\u5c11\u603b\u5956\u91d1\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-08/#_11","text":"2 1 1 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-08/#_12","text":"201","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-08/#_13","text":"80\uff05\u7684\u6570\u636e\u6ee1\u8db3n<=1000\uff0cm<=2000\uff1b 100\uff05\u7684\u6570\u636e\u6ee1\u8db3n<=10000\uff0cm<=20000\u3002 \u62d3\u6251\u6392\u5e8f /** * * \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u795e\u517d\u51fa\u6ca1\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 * *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u250f\u2513\u3000\u3000\u3000\u250f\u2513+ + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u250f\u251b\u253b\u2501\u2501\u2501\u251b\u253b\u2513 + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 \u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2501\u3000\u3000\u3000\u2503 ++ + + + *\u3000\u3000\u3000\u3000\u3000\u3000 \u2588\u2588\u2588\u2588\u2501\u2588\u2588\u2588\u2588 \u2503+ *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u253b\u3000\u3000\u3000\u2503 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2517\u2501\u2513\u3000\u3000\u3000\u250f\u2501\u251b *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503 + + + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u3000Code is far away from bug with the animal protecting\u3000\u3000\u3000\u3000\u3000\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503 + \u3000\u3000\u3000\u3000\u795e\u517d\u4fdd\u4f51,\u4ee3\u7801\u65e0bug\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000\u3000\u3000\u2503\u3000\u3000+\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u3000 \u3000\u3000\u2517\u2501\u2501\u2501\u2513 + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2523\u2513 *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503 \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u250f\u251b *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2517\u2513\u2513\u250f\u2501\u2533\u2513\u250f\u251b + + + + *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2503\u252b\u252b\u3000\u2503\u252b\u252b *\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2517\u253b\u251b\u3000\u2517\u253b\u251b+ + + + * * \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u611f\u89c9\u840c\u840c\u54d2\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 */ #include <iostream> #include <bits/stdc++.h> using namespace std; typedef long long ll; vector<int>w[105050]; int in[105050]= {0}; int ans[100500]={0}; struct node { int x,y; }; int main() { int n,m,a,b; scanf(\"%d%d\",&n,&m); for(int i=1; i<=m; i++) { scanf(\"%d%d\",&a,&b); w[b].push_back(a); in[a]++; } queue<node>w1; for(int i=1; i<=n; i++) { if(in[i]==0) w1.push(node{i,100}),ans[i]=100; } ll sum=0; while(!w1.empty()) { node p=w1.front(); w1.pop(); for(int i=0; i<w[p.x].size(); i++) { in[w[p.x][i]]--; ans[w[p.x][i]]=max(ans[w[p.x][i]],p.y+1); if(in[w[p.x][i]]==0) { w1.push(node{w[p.x][i],ans[w[p.x][i]]}); } } } for(int i=1;i<=n;i++) { if(in[i]!=0) ///\u5224\u73af { printf(\"Poor Xed\\n\"); return 0; } sum+=ans[i]; } printf(\"%lld\\n\",sum); return 0; }","title":"\u63d0\u793a"},{"location":"csdn/2020-08-09/","text":"http://icpc.upc.edu.cn/problem.php?id=14866 \u9898\u76ee \u00b6 14866: \u9ad8\u5174\u5929\u6570 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u5c0fX\u6027\u683c\u5f88\u72ec\u7279\uff0c\u5982\u679c\u5979\u4eca\u5929\u9ad8\u5174\u5ea6\u6bd4\u4e0a\u6b21\u4e00\u6837\u6216\u66f4\u9ad8\uff0c\u5979\u5c31\u4f1a\u5f88\u5584\u826f\uff0c\u76f8\u53cd\uff0c\u5982\u679c\u5979\u4eca\u5929\u9ad8\u5174\u5ea6\u6bd4\u4e0a\u6b21\u4f4e\uff0c\u5979\u5c31\u4f1a\u5f88\u51f6\uff01\u73b0\u5728\u5df2\u7ecf\u77e5\u9053\u5c0fX\u5728N\u5929\u91cc\u6bcf\u5929\u7684\u9ad8\u5174\u5ea6M\u3002\u6839\u636e\u8fd9N\u5929\u4e2d\u5979\u6bcf\u5929\u9ad8\u5174\u5ea6M\uff0c\u5408\u7406\u5b89\u6392\u4e0e\u5979\u76f8\u5904\u65f6\u95f4\uff0c\u4f7f\u5927\u5bb6\u4e0e\u5c0fX\u53cb\u597d\u76f8\u5904\u5c3d\u91cf\u591a\u5929\u6570\u3002\u73b0\u5728\u8981\u6c42\u8ba1\u7b97\u51fa\u6700\u591a\u80fd\u548c\u5c0fX\u53cb\u597d\u76f8\u5904\u591a\u5c11\u5929\u3002 \u8f93\u5165 \u00b6 \u51712\u884c\uff0c\u7b2c\u4e00\u884c\u4e3a\u4e00\u4e2aN\uff0c\u7b2c\u4e8c\u884c\u4e3aN\u4e2a\u6570\uff0c\u4e3a\u5c0fX\u6bcf\u5929\u7684\u9ad8\u5174\u7a0b\u5ea6M\u3002 \u8f93\u51fa \u00b6 \u51711\u4e2a\u6570\uff0c\u6700\u591a\u80fd\u548c\u5c0fX\u53cb\u597d\u76f8\u5904\u591a\u5c11\u5929\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 5 2 3 5 6 4 \u6837\u4f8b\u8f93\u51fa \u00b6 4 \u63d0\u793a \u00b6 \u5bf9\u4e8e30%\u7684\u6570\u636e\uff0cN<=8000 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0cN\uff0cM<31000 \u89e3\u6790 \u00b6 \u4e8c\u5206\u6cd5\u6c42\u6700\u5927\u4e0a\u5347\u5b50\u5e8f\u5217 \u8fd9\u91cc\u89e3\u91ca\u4e00\u4e0b\uff1a\u9898\u76ee\u6240\u8bf4\u7684\u201c\u6bd4\u4e0a\u6b21\u201d\u662f\u6307\u6211\u4eec\u548c\u5979\u76f8\u5904\u7684\u4e0a\u4e00\u6b21\uff0c\u800c\u4e0d\u662f\u6307\u524d\u4e00\u5929\u3002\u4f8b\u5982\uff0c\u7b2c\u4e09\u5929\u548c\u5979\u76f8\u5904\u540e\u9694\u4e86\u4e24\u5929\u540e\u5373\u7b2c\u516d\u5929\u53c8\u4e0e\u5979\u76f8\u5904\uff0c\u5e94\u8be5\u62ff\u7b2c\u516d\u5929\u5fc3\u60c5\u548c\u7b2c\u4e09\u5929\u5fc3\u60c5\u6bd4\u8f83\u3002 #include <iostream> #include <bits/stdc++.h> using namespace std; typedef long long ll; ll a[300500]={0}; ll c[300500]={0}; int main() { ll n,cnt=0; scanf(\"%lld\",&n); for(ll i=1;i<=n;i++) scanf(\"%lld\",a+i); for(ll i=1;i<=n;i++) { if(a[i]>=c[cnt]) { c[++cnt]=a[i]; } else { ll l=1,r=cnt+1; while(l<r) { ll mid=(l+r)/2; if(a[i]>c[mid]) { l=mid+1; } else if(a[i]<c[mid]) { r=mid; } else if(a[i]==c[mid]) { l=mid+1; } } c[l]=min(c[l],a[i]); } } printf(\"%lld\\n\",cnt); return 0; } http://icpc.upc.edu.cn/problem.php?id=15036 \u9898\u76ee \u00b6 15036: \u9009\u62e9 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u54c8\u54c8\u54c8\uff0c\u5feb\u5fd8\u6389\u4f60\u7684\u70e6\u5fc3\u4e8b\uff0c\u627e\u5f20\u4f4d\u5b50\u5750\u4e0b\u6765\u3002 beny\u548cfife\u4e24\u4eba\u4f5c\u4e3a\u5f7c\u6b64\u7089\u8fb9\u597d\u53cb\uff0c\u51b3\u5b9a\u6765\u4e00\u573a\u60ca\u5fc3\u52a8\u9b44\u7684\u53cb\u8c0a\uff08py\uff09\u8d5b\u3002 fife\u6709n\u4e2a\u968f\u4ece\uff0c\u7b2ci\u4e2a\u968f\u4ece\u6709\u4e00\u4e2a\u80fd\u529b\u503c\uff0c\u4e3aA[i]\u3002 beny\u4e5f\u6709\u5bf9\u5e94\u7684n\u4e2a\u968f\u4ece\uff0c\u7b2ci\u4e2a\u968f\u4ece\u540c\u6837\u4e5f\u6709\u4e00\u4e2a\u80fd\u529b\u503c\uff0c\u4e3aB[i]\u3002 \u7136\u540e\uff0c\u4e00\u7fa4\u968f\u4ece\u7684\u6218\u6597\u529b\u4e3a\u8fd9\u7fa4\u968f\u4ece\u80fd\u529b\u503c\u7684\u603b\u548c\u3002 \u73b0\u5728\uff0cbeny\u548cfife\u6bcf\u4e2a\u4eba\u90fd\u6d3e\u51fa\u81ea\u5df1\u7b2cL\u4e2a\u5230\u7b2cR\u4e2a\uff08\u5171R-L+1\u4e2a\u968f\u4ece\uff09\uff0c\u6765\u4e00\u51b3\u9ad8\u4e0b\u3002 \u4f46\u662f\u7531\u4e8e\u4ed6\u4eec\u5728\u4e00\u7edd\u9ad8\u4e0b\u7684\u540c\u65f6\u8981py\u4efb\u52a1\uff0c\u4ed6\u4eec\u8981\u4f60\u9009\u62e9\u4e00\u5bf9(L,R)\uff0c\u4f7f\u53cc\u65b9\u6218\u6597\u529b\u5dee\u8ddd\u6700\u5c0f\u3002 \u4ed6\u4eec\u8981\u4f60\u8f93\u51fa\u6700\u5c0f\u7684\u6218\u6597\u529b\u5dee\u8ddd\uff08\u6218\u6597\u529b\u8f83\u5927\u7684\u51cf\u6218\u6597\u529b\u8f83\u5c0f\u7684\uff09\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570n\u3002 \u7b2c\u4e8c\u884cn\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6570\u7ec4A\u3002 \u7b2c\u4e09\u884cn\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6570\u7ec4B\u3002 \u8f93\u51fa \u00b6 \u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570\uff0c \u8868\u793a\u6700\u5c0f\u7684\u6218\u6597\u529b\u5dee\u8ddd\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 3 4 2 3 3 4 2 \u3010\u6837\u4f8b2\u3011 5 38 19 5 17 3 15 22 0 6 17 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 0 \u3010\u6837\u4f8b2\u3011 1 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca\uff1aL = 1\uff0c R = 3 \u6837\u4f8b2\u89e3\u91ca\uff1aL = 2\uff0c R = 5 set\u7684\u5e94\u7528 #include <bits/stdc++.h> using namespace std; typedef long long ll; ll a[300500]={0}; ll b[300500]={0}; ll c[300500]={0}; set<ll>::iterator it1,it2; ll x,y,n,ans=99999999999; set<ll>w; int main() { scanf(\"%lld\",&n); for(ll i=1;i<=n;i++) scanf(\"%lld\",&a[i]); for(ll i=1;i<=n;i++) { scanf(\"%lld\",&b[i]); c[i]=c[i-1]+b[i]-a[i]; } w.insert(0); w.insert(99999999999); for(ll i=1;i<=n;i++) { it1=w.upper_bound(c[i]); it2=it1; it2--; x=*it1; y=*it2; ans=min(ans,abs(c[i]-x)); ans=min(ans,abs(c[i]-y)); w.insert(c[i]); } printf(\"%lld\\n\",ans); }","title":"2020-08-09"},{"location":"csdn/2020-08-09/#_1","text":"14866: \u9ad8\u5174\u5929\u6570","title":"\u9898\u76ee"},{"location":"csdn/2020-08-09/#_2","text":"\u5c0fX\u6027\u683c\u5f88\u72ec\u7279\uff0c\u5982\u679c\u5979\u4eca\u5929\u9ad8\u5174\u5ea6\u6bd4\u4e0a\u6b21\u4e00\u6837\u6216\u66f4\u9ad8\uff0c\u5979\u5c31\u4f1a\u5f88\u5584\u826f\uff0c\u76f8\u53cd\uff0c\u5982\u679c\u5979\u4eca\u5929\u9ad8\u5174\u5ea6\u6bd4\u4e0a\u6b21\u4f4e\uff0c\u5979\u5c31\u4f1a\u5f88\u51f6\uff01\u73b0\u5728\u5df2\u7ecf\u77e5\u9053\u5c0fX\u5728N\u5929\u91cc\u6bcf\u5929\u7684\u9ad8\u5174\u5ea6M\u3002\u6839\u636e\u8fd9N\u5929\u4e2d\u5979\u6bcf\u5929\u9ad8\u5174\u5ea6M\uff0c\u5408\u7406\u5b89\u6392\u4e0e\u5979\u76f8\u5904\u65f6\u95f4\uff0c\u4f7f\u5927\u5bb6\u4e0e\u5c0fX\u53cb\u597d\u76f8\u5904\u5c3d\u91cf\u591a\u5929\u6570\u3002\u73b0\u5728\u8981\u6c42\u8ba1\u7b97\u51fa\u6700\u591a\u80fd\u548c\u5c0fX\u53cb\u597d\u76f8\u5904\u591a\u5c11\u5929\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-09/#_3","text":"\u51712\u884c\uff0c\u7b2c\u4e00\u884c\u4e3a\u4e00\u4e2aN\uff0c\u7b2c\u4e8c\u884c\u4e3aN\u4e2a\u6570\uff0c\u4e3a\u5c0fX\u6bcf\u5929\u7684\u9ad8\u5174\u7a0b\u5ea6M\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-09/#_4","text":"\u51711\u4e2a\u6570\uff0c\u6700\u591a\u80fd\u548c\u5c0fX\u53cb\u597d\u76f8\u5904\u591a\u5c11\u5929\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-09/#_5","text":"5 2 3 5 6 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-09/#_6","text":"4","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-09/#_7","text":"\u5bf9\u4e8e30%\u7684\u6570\u636e\uff0cN<=8000 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0cN\uff0cM<31000","title":"\u63d0\u793a"},{"location":"csdn/2020-08-09/#_8","text":"\u4e8c\u5206\u6cd5\u6c42\u6700\u5927\u4e0a\u5347\u5b50\u5e8f\u5217 \u8fd9\u91cc\u89e3\u91ca\u4e00\u4e0b\uff1a\u9898\u76ee\u6240\u8bf4\u7684\u201c\u6bd4\u4e0a\u6b21\u201d\u662f\u6307\u6211\u4eec\u548c\u5979\u76f8\u5904\u7684\u4e0a\u4e00\u6b21\uff0c\u800c\u4e0d\u662f\u6307\u524d\u4e00\u5929\u3002\u4f8b\u5982\uff0c\u7b2c\u4e09\u5929\u548c\u5979\u76f8\u5904\u540e\u9694\u4e86\u4e24\u5929\u540e\u5373\u7b2c\u516d\u5929\u53c8\u4e0e\u5979\u76f8\u5904\uff0c\u5e94\u8be5\u62ff\u7b2c\u516d\u5929\u5fc3\u60c5\u548c\u7b2c\u4e09\u5929\u5fc3\u60c5\u6bd4\u8f83\u3002 #include <iostream> #include <bits/stdc++.h> using namespace std; typedef long long ll; ll a[300500]={0}; ll c[300500]={0}; int main() { ll n,cnt=0; scanf(\"%lld\",&n); for(ll i=1;i<=n;i++) scanf(\"%lld\",a+i); for(ll i=1;i<=n;i++) { if(a[i]>=c[cnt]) { c[++cnt]=a[i]; } else { ll l=1,r=cnt+1; while(l<r) { ll mid=(l+r)/2; if(a[i]>c[mid]) { l=mid+1; } else if(a[i]<c[mid]) { r=mid; } else if(a[i]==c[mid]) { l=mid+1; } } c[l]=min(c[l],a[i]); } } printf(\"%lld\\n\",cnt); return 0; } http://icpc.upc.edu.cn/problem.php?id=15036","title":"\u89e3\u6790"},{"location":"csdn/2020-08-09/#_9","text":"15036: \u9009\u62e9","title":"\u9898\u76ee"},{"location":"csdn/2020-08-09/#_10","text":"\u54c8\u54c8\u54c8\uff0c\u5feb\u5fd8\u6389\u4f60\u7684\u70e6\u5fc3\u4e8b\uff0c\u627e\u5f20\u4f4d\u5b50\u5750\u4e0b\u6765\u3002 beny\u548cfife\u4e24\u4eba\u4f5c\u4e3a\u5f7c\u6b64\u7089\u8fb9\u597d\u53cb\uff0c\u51b3\u5b9a\u6765\u4e00\u573a\u60ca\u5fc3\u52a8\u9b44\u7684\u53cb\u8c0a\uff08py\uff09\u8d5b\u3002 fife\u6709n\u4e2a\u968f\u4ece\uff0c\u7b2ci\u4e2a\u968f\u4ece\u6709\u4e00\u4e2a\u80fd\u529b\u503c\uff0c\u4e3aA[i]\u3002 beny\u4e5f\u6709\u5bf9\u5e94\u7684n\u4e2a\u968f\u4ece\uff0c\u7b2ci\u4e2a\u968f\u4ece\u540c\u6837\u4e5f\u6709\u4e00\u4e2a\u80fd\u529b\u503c\uff0c\u4e3aB[i]\u3002 \u7136\u540e\uff0c\u4e00\u7fa4\u968f\u4ece\u7684\u6218\u6597\u529b\u4e3a\u8fd9\u7fa4\u968f\u4ece\u80fd\u529b\u503c\u7684\u603b\u548c\u3002 \u73b0\u5728\uff0cbeny\u548cfife\u6bcf\u4e2a\u4eba\u90fd\u6d3e\u51fa\u81ea\u5df1\u7b2cL\u4e2a\u5230\u7b2cR\u4e2a\uff08\u5171R-L+1\u4e2a\u968f\u4ece\uff09\uff0c\u6765\u4e00\u51b3\u9ad8\u4e0b\u3002 \u4f46\u662f\u7531\u4e8e\u4ed6\u4eec\u5728\u4e00\u7edd\u9ad8\u4e0b\u7684\u540c\u65f6\u8981py\u4efb\u52a1\uff0c\u4ed6\u4eec\u8981\u4f60\u9009\u62e9\u4e00\u5bf9(L,R)\uff0c\u4f7f\u53cc\u65b9\u6218\u6597\u529b\u5dee\u8ddd\u6700\u5c0f\u3002 \u4ed6\u4eec\u8981\u4f60\u8f93\u51fa\u6700\u5c0f\u7684\u6218\u6597\u529b\u5dee\u8ddd\uff08\u6218\u6597\u529b\u8f83\u5927\u7684\u51cf\u6218\u6597\u529b\u8f83\u5c0f\u7684\uff09\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-09/#_11","text":"\u7b2c\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570n\u3002 \u7b2c\u4e8c\u884cn\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6570\u7ec4A\u3002 \u7b2c\u4e09\u884cn\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6570\u7ec4B\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-09/#_12","text":"\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570\uff0c \u8868\u793a\u6700\u5c0f\u7684\u6218\u6597\u529b\u5dee\u8ddd\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-09/#_13","text":"\u3010\u6837\u4f8b1\u3011 3 4 2 3 3 4 2 \u3010\u6837\u4f8b2\u3011 5 38 19 5 17 3 15 22 0 6 17","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-09/#_14","text":"\u3010\u6837\u4f8b1\u3011 0 \u3010\u6837\u4f8b2\u3011 1","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-09/#_15","text":"\u6837\u4f8b1\u89e3\u91ca\uff1aL = 1\uff0c R = 3 \u6837\u4f8b2\u89e3\u91ca\uff1aL = 2\uff0c R = 5 set\u7684\u5e94\u7528 #include <bits/stdc++.h> using namespace std; typedef long long ll; ll a[300500]={0}; ll b[300500]={0}; ll c[300500]={0}; set<ll>::iterator it1,it2; ll x,y,n,ans=99999999999; set<ll>w; int main() { scanf(\"%lld\",&n); for(ll i=1;i<=n;i++) scanf(\"%lld\",&a[i]); for(ll i=1;i<=n;i++) { scanf(\"%lld\",&b[i]); c[i]=c[i-1]+b[i]-a[i]; } w.insert(0); w.insert(99999999999); for(ll i=1;i<=n;i++) { it1=w.upper_bound(c[i]); it2=it1; it2--; x=*it1; y=*it2; ans=min(ans,abs(c[i]-x)); ans=min(ans,abs(c[i]-y)); w.insert(c[i]); } printf(\"%lld\\n\",ans); }","title":"\u63d0\u793a"},{"location":"csdn/2020-08-10/","text":"http://icpc.upc.edu.cn/problem.php?id=14581 \u9898\u76ee \u00b6 14581: Knight \u9898\u76ee\u63cf\u8ff0 \u00b6 There is a knight - the chess piece - at the origin (0,0) of a two-dimensional grid. When the knight is at the square (i,j), it can be moved to either (i+1,j+2) or (i+2,j+1). In how many ways can the knight reach the square (X,Y)? Find the number of ways modulo 109+7. Constraints \u00b71\u2264X\u2264106 \u00b71\u2264Y\u2264106 \u00b7All values in input are integers. \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: X Y \u8f93\u51fa \u00b6 Print the number of ways for the knight to reach (X,Y) from (0,0), modulo 109+7. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 3 3 \u3010\u6837\u4f8b2\u3011 2 2 \u3010\u6837\u4f8b3\u3011 999999 999999 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 2 \u3010\u6837\u4f8b2\u3011 0 \u3010\u6837\u4f8b3\u3011 151840682 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca There are two ways: (0,0)\u2192(1,2)\u2192(3,3) and (0,0)\u2192(2,1)\u2192(3,3). \u6837\u4f8b2\u89e3\u91ca The knight cannot reach (2,2). \u6837\u4f8b3\u89e3\u91ca Print the number of ways modulo 109+7. \u9006\u5143\u6c42\u7ec4\u5408\u6570 #include <iostream> #include <bits/stdc++.h> using namespace std; typedef long long ll; const int N=1e9+7; long long int w[2005500]={0}; long long int p(long long x,long long y) { long long int sum1=1; while(y) { if (y&1) sum1=(sum1*x)%N; y>>=1; x=(x*x)%N; } return sum1%N; } long long int c1(long long int x,long long int y) { if(x<y) swap(x,y); return w[x]*p(w[x-y]*w[y]%N,N-2)%N; } int main() { register ll a,b; cin>>a>>b; ll y=2*a-b; ll x=2*b-a; if(x%3!=0||y%3!=0||x<0||y<0) { printf(\"0\\n\"); return 0; } x=x/3; y=y/3; ll w2=x+y; w[0]=1; for(ll i=1;i<=2000500;i++) w[i]=(w[i-1]*i)%N; ll w3=(c1(x,w2)+N)%N;//\u9632\u6b62\u8d1f\u6570\u51fa\u73b0\uff0c\u53d6\u4f59\u65f6\u6ce8\u610f cout<<w3<<endl; return 0; } http://icpc.upc.edu.cn/problem.php?id=14625 \u9898\u76ee \u00b6 14625: Max-Min Sums \u9898\u76ee\u63cf\u8ff0 \u00b6 For a finite set of integers X, let f(X)=maxX\u2212minX. Given are N integers A1,...,AN. We will choose K of them and let S be the set of the integers chosen. If we distinguish elements with different indices even when their values are the same, there are NCK ways to make this choice. Find the sum of f(S) over all those ways. Since the answer can be enormous, print it mod(109+7). Constraints \u00b71\u2264N\u2264105 \u00b71\u2264K\u2264N \u00b7|Ai|\u2264109 \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N K A1 ... AN \u8f93\u51fa \u00b6 Print the answer mod(109+7). \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 4 2 1 1 3 4 \u3010\u6837\u4f8b2\u3011 6 3 10 10 10 -10 -10 -10 \u3010\u6837\u4f8b3\u3011 3 1 1 1 1 \u3010\u6837\u4f8b4\u3011 10 6 1000000000 1000000000 1000000000 1000000000 1000000000 0 0 0 0 0 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 11 \u3010\u6837\u4f8b2\u3011 360 \u3010\u6837\u4f8b3\u3011 0 \u3010\u6837\u4f8b4\u3011 999998537 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca There are six ways to choose S: {1,1},{1,3},{1,4},{1,3},{1,4},{3,4} (we distinguish the two 1s). The value of f(S) for these choices are 0,2,3,2,3,1, respectively, for the total of 11. \u6837\u4f8b2\u89e3\u91ca There are 20 ways to choose S. In 18 of them, f(S)=20, and in 2 of them, f(S)=0. \u6837\u4f8b4\u89e3\u91ca Print the sum mod(109+7). \u7edf\u8ba1\u6700\u5927\u503c\u51fa\u73b0\u7684\u6b21\u6570\u548c\u6700\u5c0f\u503c\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u6700\u540e\u6c42\u548c\u3002 #include <iostream> #include <bits/stdc++.h> using namespace std; typedef long long ll; const int N=1e9+7; long long int w[2005500]={0}; ll num[100500]={0}; long long int p(long long x,long long y) { long long int sum1=1; while(y) { if (y&1) sum1=(sum1*x)%N; y>>=1; x=(x*x)%N; } return sum1%N; } long long int c1(long long int x,long long int y) { if(x<y) swap(x,y); return w[x]*p(w[x-y]*w[y]%N,N-2)%N; } int main() { register ll n,k; scanf(\"%lld%lld\",&n,&k); for(int i=0;i<n;i++) scanf(\"%lld\",&num[i]); sort(num,num+n); w[0]=1; for(ll i=1;i<=2000500;i++) w[i]=(w[i-1]*i)%N; ll sum=0; for(ll i=0;i<n-k+1;i++) { sum=(sum+(num[n-i-1]-num[i])%N*c1(n-i-1,k-1)%N)%N; } printf(\"%lld\\n\",(sum%N+N)%N); return 0; }","title":"2020-08-10"},{"location":"csdn/2020-08-10/#_1","text":"14581: Knight","title":"\u9898\u76ee"},{"location":"csdn/2020-08-10/#_2","text":"There is a knight - the chess piece - at the origin (0,0) of a two-dimensional grid. When the knight is at the square (i,j), it can be moved to either (i+1,j+2) or (i+2,j+1). In how many ways can the knight reach the square (X,Y)? Find the number of ways modulo 109+7. Constraints \u00b71\u2264X\u2264106 \u00b71\u2264Y\u2264106 \u00b7All values in input are integers.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-10/#_3","text":"Input is given from Standard Input in the following format: X Y","title":"\u8f93\u5165"},{"location":"csdn/2020-08-10/#_4","text":"Print the number of ways for the knight to reach (X,Y) from (0,0), modulo 109+7.","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-10/#_5","text":"\u3010\u6837\u4f8b1\u3011 3 3 \u3010\u6837\u4f8b2\u3011 2 2 \u3010\u6837\u4f8b3\u3011 999999 999999","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-10/#_6","text":"\u3010\u6837\u4f8b1\u3011 2 \u3010\u6837\u4f8b2\u3011 0 \u3010\u6837\u4f8b3\u3011 151840682","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-10/#_7","text":"\u6837\u4f8b1\u89e3\u91ca There are two ways: (0,0)\u2192(1,2)\u2192(3,3) and (0,0)\u2192(2,1)\u2192(3,3). \u6837\u4f8b2\u89e3\u91ca The knight cannot reach (2,2). \u6837\u4f8b3\u89e3\u91ca Print the number of ways modulo 109+7. \u9006\u5143\u6c42\u7ec4\u5408\u6570 #include <iostream> #include <bits/stdc++.h> using namespace std; typedef long long ll; const int N=1e9+7; long long int w[2005500]={0}; long long int p(long long x,long long y) { long long int sum1=1; while(y) { if (y&1) sum1=(sum1*x)%N; y>>=1; x=(x*x)%N; } return sum1%N; } long long int c1(long long int x,long long int y) { if(x<y) swap(x,y); return w[x]*p(w[x-y]*w[y]%N,N-2)%N; } int main() { register ll a,b; cin>>a>>b; ll y=2*a-b; ll x=2*b-a; if(x%3!=0||y%3!=0||x<0||y<0) { printf(\"0\\n\"); return 0; } x=x/3; y=y/3; ll w2=x+y; w[0]=1; for(ll i=1;i<=2000500;i++) w[i]=(w[i-1]*i)%N; ll w3=(c1(x,w2)+N)%N;//\u9632\u6b62\u8d1f\u6570\u51fa\u73b0\uff0c\u53d6\u4f59\u65f6\u6ce8\u610f cout<<w3<<endl; return 0; } http://icpc.upc.edu.cn/problem.php?id=14625","title":"\u63d0\u793a"},{"location":"csdn/2020-08-10/#_8","text":"14625: Max-Min Sums","title":"\u9898\u76ee"},{"location":"csdn/2020-08-10/#_9","text":"For a finite set of integers X, let f(X)=maxX\u2212minX. Given are N integers A1,...,AN. We will choose K of them and let S be the set of the integers chosen. If we distinguish elements with different indices even when their values are the same, there are NCK ways to make this choice. Find the sum of f(S) over all those ways. Since the answer can be enormous, print it mod(109+7). Constraints \u00b71\u2264N\u2264105 \u00b71\u2264K\u2264N \u00b7|Ai|\u2264109","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-10/#_10","text":"Input is given from Standard Input in the following format: N K A1 ... AN","title":"\u8f93\u5165"},{"location":"csdn/2020-08-10/#_11","text":"Print the answer mod(109+7).","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-10/#_12","text":"\u3010\u6837\u4f8b1\u3011 4 2 1 1 3 4 \u3010\u6837\u4f8b2\u3011 6 3 10 10 10 -10 -10 -10 \u3010\u6837\u4f8b3\u3011 3 1 1 1 1 \u3010\u6837\u4f8b4\u3011 10 6 1000000000 1000000000 1000000000 1000000000 1000000000 0 0 0 0 0","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-10/#_13","text":"\u3010\u6837\u4f8b1\u3011 11 \u3010\u6837\u4f8b2\u3011 360 \u3010\u6837\u4f8b3\u3011 0 \u3010\u6837\u4f8b4\u3011 999998537","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-10/#_14","text":"\u6837\u4f8b1\u89e3\u91ca There are six ways to choose S: {1,1},{1,3},{1,4},{1,3},{1,4},{3,4} (we distinguish the two 1s). The value of f(S) for these choices are 0,2,3,2,3,1, respectively, for the total of 11. \u6837\u4f8b2\u89e3\u91ca There are 20 ways to choose S. In 18 of them, f(S)=20, and in 2 of them, f(S)=0. \u6837\u4f8b4\u89e3\u91ca Print the sum mod(109+7). \u7edf\u8ba1\u6700\u5927\u503c\u51fa\u73b0\u7684\u6b21\u6570\u548c\u6700\u5c0f\u503c\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u6700\u540e\u6c42\u548c\u3002 #include <iostream> #include <bits/stdc++.h> using namespace std; typedef long long ll; const int N=1e9+7; long long int w[2005500]={0}; ll num[100500]={0}; long long int p(long long x,long long y) { long long int sum1=1; while(y) { if (y&1) sum1=(sum1*x)%N; y>>=1; x=(x*x)%N; } return sum1%N; } long long int c1(long long int x,long long int y) { if(x<y) swap(x,y); return w[x]*p(w[x-y]*w[y]%N,N-2)%N; } int main() { register ll n,k; scanf(\"%lld%lld\",&n,&k); for(int i=0;i<n;i++) scanf(\"%lld\",&num[i]); sort(num,num+n); w[0]=1; for(ll i=1;i<=2000500;i++) w[i]=(w[i-1]*i)%N; ll sum=0; for(ll i=0;i<n-k+1;i++) { sum=(sum+(num[n-i-1]-num[i])%N*c1(n-i-1,k-1)%N)%N; } printf(\"%lld\\n\",(sum%N+N)%N); return 0; }","title":"\u63d0\u793a"},{"location":"csdn/2020-08-11/","text":"http://icpc.upc.edu.cn/problem.php?id=14881 \u9898\u76ee \u00b6 14881: \u4f1a\u8bae \u9898\u76ee\u63cf\u8ff0 \u00b6 \u6709\u4e00\u4e2a\u6751\u5e84\u5c45\u4f4f\u7740n\u4e2a\u6751\u6c11\uff0c\u6709n-1\u6761\u8def\u5f84\u4f7f\u5f97\u8fd9n\u4e2a\u6751\u6c11\u7684\u5bb6\u8054\u901a\uff0c\u6bcf\u6761\u8def\u5f84\u7684\u957f\u5ea6\u90fd\u4e3a1\u3002\u73b0\u5728\u6751\u957f\u5e0c\u671b\u5728\u67d0\u4e2a\u6751\u6c11\u5bb6\u4e2d\u53ec\u5f00\u4e00\u573a\u4f1a\u8bae\uff0c\u6751\u957f\u5e0c\u671b\u6240\u6709\u6751\u6c11\u5230\u4f1a\u8bae\u5730\u70b9\u7684\u8ddd\u79bb\u4e4b\u548c\u6700\u5c0f\uff0c\u90a3\u4e48\u6751\u957f\u5e94\u8be5\u8981\u628a\u4f1a\u8bae\u5730\u70b9\u8bbe\u7f6e\u5728\u54ea\u4e2a\u6751\u6c11\u7684\u5bb6\u4e2d\uff0c\u5e76\u4e14\u8fd9\u4e2a\u8ddd\u79bb\u603b\u548c\u6700\u5c0f\u662f\u591a\u5c11\uff1f\u82e5\u6709\u591a\u4e2a\u8282\u70b9\u90fd\u6ee1\u8db3\u6761\u4ef6\uff0c\u5219\u9009\u62e9\u8282\u70b9\u7f16\u53f7\u6700\u5c0f\u7684\u90a3\u4e2a\u70b9\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u3002\u4e00\u4e2a\u6570n\uff0c\u8868\u793a\u6709n\u4e2a\u6751\u6c11\u3002 \u63a5\u4e0b\u6765n-1\u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6570\u5b57a\u548cb\uff0c\u8868\u793a\u6751\u6c11a\u7684\u5bb6\u548c\u6751\u6c11b\u7684\u5bb6\u4e4b\u95f4\u5b58\u5728\u4e00\u6761\u8def\u5f84\u3002 \u8f93\u51fa \u00b6 \u4e00\u884c\u8f93\u51fa\u4e24\u4e2a\u6570\u5b57x\u548cy x\u8868\u793a\u6751\u957f\u5c06\u4f1a\u5728\u54ea\u4e2a\u6751\u6c11\u5bb6\u4e2d\u4e3e\u529e\u4f1a\u8bae y\u8868\u793a\u8ddd\u79bb\u4e4b\u548c\u7684\u6700\u5c0f\u503c \u6837\u4f8b\u8f93\u5165 \u00b6 4 1 2 2 3 3 4 \u6837\u4f8b\u8f93\u51fa \u00b6 2 4 \u63d0\u793a \u00b6 70%\u6570\u636en<=1000 100%\u6570\u636en<=50000 #include <bits/stdc++.h> using namespace std; struct node { int to; int next; }; node e[100500]={0}; int cnt=0; int head[100500]={0}; int size1[100500]={0}; int dis[100500]={0}; int f[100500]={0}; int n; int add(int x,int y) { e[++cnt].to=y; e[cnt].next=head[x]; head[x]=cnt; } int dfs1(int now) { size1[now]=1; for(int i=head[now];i;i=e[i].next) { int to=e[i].to; if(dis[to]) continue; dis[to]=dis[now]+1; dfs1(to); size1[now]+=size1[to]; } } int dfs(int now,int fa) { f[now]=f[fa]+n-2*size1[now]; for(int i=head[now];i;i=e[i].next) { int to=e[i].to; if(to==fa) continue; dfs(to,now); } } int main() { scanf(\"%d\",&n); for(int i=0;i<n-1;i++) { int a,b; scanf(\"%d%d\",&a,&b); add(a,b); add(b,a); } dis[1]=1; dfs1(1); int maxn=0; for(int i=1;i<=n;i++) { maxn+=dis[i]; } maxn-=*n; ///\u6bcf\u4e00\u4e2a\u70b9\u52301\u7684\u8ddd\u79bb\u90fd\u662f\u4ece1\u5f00\u59cb\u8ba1\u7b97\uff0c\u987b\u51cf\u53bb f[1]=maxn; for(int i=head[1];i;i=e[i].next) { int to=e[i].to; dfs(to,1); } int ans=0; for(int i=1;i<=n;i++) { if(f[i]<maxn) maxn=f[i],ans=i; } printf(\"%d %d\\n\",ans,maxn); return 0; } http://icpc.upc.edu.cn/problem.php?id=14539 \u9898\u76ee \u00b6 14539: Ki \u9898\u76ee\u63cf\u8ff0 \u00b6 Given is a rooted tree with N vertices numbered 1 to N. The root is Vertex 1, and the i-th edge ( 1\u2264i\u2264N\u22121) connects Vertex ai and bi. Each of the vertices has a counter installed. Initially, the counters on all the vertices have the value 0. Now, the following Q operations will be performed: Operation j (1\u2264j\u2264Q): Increment by xj the counter on every vertex contained in the subtree rooted at Vertex pj. Find the value of the counter on each vertex after all operations. Constraints \u00b72\u2264N\u22642\u00d7105 \u00b71\u2264Q\u22642\u00d7105 \u00b71\u2264ai<bi\u2264N \u00b71\u2264pj\u2264N \u00b71\u2264xj\u2264104 \u00b7The given graph is a tree. \u00b7All values in input are integers. \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N Q a1 b1 : aN\u22121 bN\u22121 p1 x1 : pQ xQ \u8f93\u51fa \u00b6 Print the values of the counters on Vertex 1,2,\u2026,N after all operations, in this order, with spaces in between. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 4 3 1 2 2 3 2 4 2 10 1 100 3 1 \u3010\u6837\u4f8b2\u3011 6 2 1 2 1 3 2 4 3 6 2 5 1 10 1 10 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 100 110 111 110 \u3010\u6837\u4f8b2\u3011 20 20 20 20 20 20 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca The tree in this input is as follows: Each operation changes the values of the counters on the vertices as follows: \u00b7Operation 1: Increment by 10 the counter on every vertex contained in the subtree rooted at Vertex 2, that is, Vertex 2,3,4. The values of the counters on Vertex 1,2,3,4 are now 0,10,10,10, respectively. \u00b7Operation 2: Increment by 100 the counter on every vertex contained in the subtree rooted at Vertex 1, that is, Vertex 1,2,3,4. The values of the counters on Vertex 1,2,3,4 are now 100,110,110,110, respectively. \u00b7Operation 3: Increment by 1 the counter on every vertex contained in the subtree rooted at Vertex 3, that is, Vertex 3. The values of the counters on Vertex 1,2,3,4 are now 100,110,111,110, respectively. DFS+\u524d\u7f00\u548c #include <bits/stdc++.h> using namespace std; struct node { int to; int next; }; node e[500500]={0}; int cnt=0; int head[500500]={0}; int dis[500500]={0}; int n; int add(int x,int y) { e[++cnt].to=y; e[cnt].next=head[x]; head[x]=cnt; } int dfs(int now,int fa) { dis[now]+=dis[fa]; for(int i=head[now];i;i=e[i].next) { int to=e[i].to; if(to==fa) continue; dfs(to,now); } } int main() { int q; scanf(\"%d%d\",&n,&q); for(int i=0;i<n-1;i++) { int a,b; scanf(\"%d%d\",&a,&b); add(a,b); add(b,a); } for(int i=1;i<=q;i++) { int x,y; scanf(\"%d%d\",&x,&y); dis[x]+=y; } for(int i=head[1];i;i=e[i].next) { int to=e[i].to; dfs(to,1); } for(int i=1;i<=n;i++) { printf(\"%d \",dis[i]); } return 0; } http://icpc.upc.edu.cn/problem.php?id=15047 \u9898\u76ee \u00b6 15047: \u80d6\u864e\u7684\u83dc\u54c1 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u80d6\u864e\u60ca\u559c\u5730\u53d1\u73b0\u4e86\u6709N\u4e2a\u7a97\u53e3\u6709\u4ed6\u6700\u559c\u6b22\u5403\u7684\u83dc\uff08\u5176\u5b9e\u90fd\u559c\u6b22\uff1f\uff09\uff0c\u4f46\u662f\u4ed6\u60f3\u5728\u79fb\u52a8\u6700\u77ed\u8ddd\u79bb\uff08\u6bd5\u7adf\u8d70\u591a\u4e86\u4e5f\u662f\u4f1a\u7d2f\u7684\uff09\u7684\u60c5\u51b5\u4e0b\u5403\u5230\u6240\u6709\u4ed6\u559c\u6b22\u5403\u7684\u83dc\u54c1\uff0c\u9965\u997f\u7684\u4ed6\u5df2\u7ecf\u6ca1\u6709\u529b\u6c14\u5199\u51fa\u4ee3\u7801\u6765\u8ba1\u7b97\u81ea\u5df1\u7684\u6700\u4f73\u65b9\u6cd5\u4e86\uff0c\u6240\u4ee5\u4ed6\u627e\u5230\u4e86\u4f60\uff0c\u6765\u5e2e\u4ed6\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\u73b0\u5728\u7ed9\u4f60N\u4e2a\u7a97\u53e3\u53ca\u7a97\u53e3\u7684\u5750\u6807\uff0c\u8bf7\u8f93\u51fa\u80d6\u864e\u6240\u8981\u79fb\u52a8\u7684\u6700\u5c0f\u8ddd\u79bb\u603b\u548c\u3002 \u80d6\u864e\u4e00\u5f00\u59cb\u5728(0,0)\u70b9\u5904\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570n\uff081\u2264n\u226413\uff09 \u3002 \u63a5\u4e0b\u6765\u6bcf\u884c2\u4e2a\u5b9e\u6570\uff0c\u8868\u793a\u7b2ci\u5757\u7a97\u53e3\u7684\u5750\u6807\u3002 \u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u516c\u5f0f\u4e3a \u8f93\u51fa \u00b6 \u4e00\u4e2a\u6570\uff0c\u8868\u793a\u8981\u8dd1\u7684\u6700\u5c11\u8ddd\u79bb\uff0c\u4fdd\u75592\u4f4d\u5c0f\u6570\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 4 1 1 1 -1 -1 1 -1 -1 \u6837\u4f8b\u8f93\u51fa \u00b6 7.41 \u72b6\u538bDP #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std; double dp[1<<14][20]={0}; struct node { double x; double y; }; node a[20]={0}; double q(int i,int j) { double sum=sqrt((double)((a[i].x-a[j].x)*(a[i].x-a[j].x)*1.0+(a[i].y-a[j].y)*(a[i].y-a[j].y)*1.0)); return sum; } int main() { int n; scanf(\"%d\",&n); for(int i=1;i<=n;i++) { scanf(\"%lf%lf\",&a[i].x,&a[i].y); } for(int i=0;i<(1<<(n+1));i++) { for(int j=0;j<=n;j++) { dp[i][j]=999999999; } } dp[1][0]=0; for(int i=0;i<(1<<(n+1));i+=1) { for(int j=0;j<=n;j++) { if(!(i>>j)&1) continue; for(int k=0;k<=n;k++) { if(j==k) continue; if(!(i>>k)&1) continue; dp[i][j]=min(dp[i][j],dp[i^(1<<j)][k]+q(k,j)); } } } double min1=99999999; int k=(1<<(n+1))-1; for(int i=1;i<=n;i++) { min1=min(min1,dp[k][i]); } printf(\"%.2f\\n\",min1); return 0; }","title":"2020-08-11"},{"location":"csdn/2020-08-11/#_1","text":"14881: \u4f1a\u8bae","title":"\u9898\u76ee"},{"location":"csdn/2020-08-11/#_2","text":"\u6709\u4e00\u4e2a\u6751\u5e84\u5c45\u4f4f\u7740n\u4e2a\u6751\u6c11\uff0c\u6709n-1\u6761\u8def\u5f84\u4f7f\u5f97\u8fd9n\u4e2a\u6751\u6c11\u7684\u5bb6\u8054\u901a\uff0c\u6bcf\u6761\u8def\u5f84\u7684\u957f\u5ea6\u90fd\u4e3a1\u3002\u73b0\u5728\u6751\u957f\u5e0c\u671b\u5728\u67d0\u4e2a\u6751\u6c11\u5bb6\u4e2d\u53ec\u5f00\u4e00\u573a\u4f1a\u8bae\uff0c\u6751\u957f\u5e0c\u671b\u6240\u6709\u6751\u6c11\u5230\u4f1a\u8bae\u5730\u70b9\u7684\u8ddd\u79bb\u4e4b\u548c\u6700\u5c0f\uff0c\u90a3\u4e48\u6751\u957f\u5e94\u8be5\u8981\u628a\u4f1a\u8bae\u5730\u70b9\u8bbe\u7f6e\u5728\u54ea\u4e2a\u6751\u6c11\u7684\u5bb6\u4e2d\uff0c\u5e76\u4e14\u8fd9\u4e2a\u8ddd\u79bb\u603b\u548c\u6700\u5c0f\u662f\u591a\u5c11\uff1f\u82e5\u6709\u591a\u4e2a\u8282\u70b9\u90fd\u6ee1\u8db3\u6761\u4ef6\uff0c\u5219\u9009\u62e9\u8282\u70b9\u7f16\u53f7\u6700\u5c0f\u7684\u90a3\u4e2a\u70b9\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-11/#_3","text":"\u7b2c\u4e00\u884c\u3002\u4e00\u4e2a\u6570n\uff0c\u8868\u793a\u6709n\u4e2a\u6751\u6c11\u3002 \u63a5\u4e0b\u6765n-1\u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6570\u5b57a\u548cb\uff0c\u8868\u793a\u6751\u6c11a\u7684\u5bb6\u548c\u6751\u6c11b\u7684\u5bb6\u4e4b\u95f4\u5b58\u5728\u4e00\u6761\u8def\u5f84\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-11/#_4","text":"\u4e00\u884c\u8f93\u51fa\u4e24\u4e2a\u6570\u5b57x\u548cy x\u8868\u793a\u6751\u957f\u5c06\u4f1a\u5728\u54ea\u4e2a\u6751\u6c11\u5bb6\u4e2d\u4e3e\u529e\u4f1a\u8bae y\u8868\u793a\u8ddd\u79bb\u4e4b\u548c\u7684\u6700\u5c0f\u503c","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-11/#_5","text":"4 1 2 2 3 3 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-11/#_6","text":"2 4","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-11/#_7","text":"70%\u6570\u636en<=1000 100%\u6570\u636en<=50000 #include <bits/stdc++.h> using namespace std; struct node { int to; int next; }; node e[100500]={0}; int cnt=0; int head[100500]={0}; int size1[100500]={0}; int dis[100500]={0}; int f[100500]={0}; int n; int add(int x,int y) { e[++cnt].to=y; e[cnt].next=head[x]; head[x]=cnt; } int dfs1(int now) { size1[now]=1; for(int i=head[now];i;i=e[i].next) { int to=e[i].to; if(dis[to]) continue; dis[to]=dis[now]+1; dfs1(to); size1[now]+=size1[to]; } } int dfs(int now,int fa) { f[now]=f[fa]+n-2*size1[now]; for(int i=head[now];i;i=e[i].next) { int to=e[i].to; if(to==fa) continue; dfs(to,now); } } int main() { scanf(\"%d\",&n); for(int i=0;i<n-1;i++) { int a,b; scanf(\"%d%d\",&a,&b); add(a,b); add(b,a); } dis[1]=1; dfs1(1); int maxn=0; for(int i=1;i<=n;i++) { maxn+=dis[i]; } maxn-=*n; ///\u6bcf\u4e00\u4e2a\u70b9\u52301\u7684\u8ddd\u79bb\u90fd\u662f\u4ece1\u5f00\u59cb\u8ba1\u7b97\uff0c\u987b\u51cf\u53bb f[1]=maxn; for(int i=head[1];i;i=e[i].next) { int to=e[i].to; dfs(to,1); } int ans=0; for(int i=1;i<=n;i++) { if(f[i]<maxn) maxn=f[i],ans=i; } printf(\"%d %d\\n\",ans,maxn); return 0; } http://icpc.upc.edu.cn/problem.php?id=14539","title":"\u63d0\u793a"},{"location":"csdn/2020-08-11/#_8","text":"14539: Ki","title":"\u9898\u76ee"},{"location":"csdn/2020-08-11/#_9","text":"Given is a rooted tree with N vertices numbered 1 to N. The root is Vertex 1, and the i-th edge ( 1\u2264i\u2264N\u22121) connects Vertex ai and bi. Each of the vertices has a counter installed. Initially, the counters on all the vertices have the value 0. Now, the following Q operations will be performed: Operation j (1\u2264j\u2264Q): Increment by xj the counter on every vertex contained in the subtree rooted at Vertex pj. Find the value of the counter on each vertex after all operations. Constraints \u00b72\u2264N\u22642\u00d7105 \u00b71\u2264Q\u22642\u00d7105 \u00b71\u2264ai<bi\u2264N \u00b71\u2264pj\u2264N \u00b71\u2264xj\u2264104 \u00b7The given graph is a tree. \u00b7All values in input are integers.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-11/#_10","text":"Input is given from Standard Input in the following format: N Q a1 b1 : aN\u22121 bN\u22121 p1 x1 : pQ xQ","title":"\u8f93\u5165"},{"location":"csdn/2020-08-11/#_11","text":"Print the values of the counters on Vertex 1,2,\u2026,N after all operations, in this order, with spaces in between.","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-11/#_12","text":"\u3010\u6837\u4f8b1\u3011 4 3 1 2 2 3 2 4 2 10 1 100 3 1 \u3010\u6837\u4f8b2\u3011 6 2 1 2 1 3 2 4 3 6 2 5 1 10 1 10","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-11/#_13","text":"\u3010\u6837\u4f8b1\u3011 100 110 111 110 \u3010\u6837\u4f8b2\u3011 20 20 20 20 20 20","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-11/#_14","text":"\u6837\u4f8b1\u89e3\u91ca The tree in this input is as follows: Each operation changes the values of the counters on the vertices as follows: \u00b7Operation 1: Increment by 10 the counter on every vertex contained in the subtree rooted at Vertex 2, that is, Vertex 2,3,4. The values of the counters on Vertex 1,2,3,4 are now 0,10,10,10, respectively. \u00b7Operation 2: Increment by 100 the counter on every vertex contained in the subtree rooted at Vertex 1, that is, Vertex 1,2,3,4. The values of the counters on Vertex 1,2,3,4 are now 100,110,110,110, respectively. \u00b7Operation 3: Increment by 1 the counter on every vertex contained in the subtree rooted at Vertex 3, that is, Vertex 3. The values of the counters on Vertex 1,2,3,4 are now 100,110,111,110, respectively. DFS+\u524d\u7f00\u548c #include <bits/stdc++.h> using namespace std; struct node { int to; int next; }; node e[500500]={0}; int cnt=0; int head[500500]={0}; int dis[500500]={0}; int n; int add(int x,int y) { e[++cnt].to=y; e[cnt].next=head[x]; head[x]=cnt; } int dfs(int now,int fa) { dis[now]+=dis[fa]; for(int i=head[now];i;i=e[i].next) { int to=e[i].to; if(to==fa) continue; dfs(to,now); } } int main() { int q; scanf(\"%d%d\",&n,&q); for(int i=0;i<n-1;i++) { int a,b; scanf(\"%d%d\",&a,&b); add(a,b); add(b,a); } for(int i=1;i<=q;i++) { int x,y; scanf(\"%d%d\",&x,&y); dis[x]+=y; } for(int i=head[1];i;i=e[i].next) { int to=e[i].to; dfs(to,1); } for(int i=1;i<=n;i++) { printf(\"%d \",dis[i]); } return 0; } http://icpc.upc.edu.cn/problem.php?id=15047","title":"\u63d0\u793a"},{"location":"csdn/2020-08-11/#_15","text":"15047: \u80d6\u864e\u7684\u83dc\u54c1","title":"\u9898\u76ee"},{"location":"csdn/2020-08-11/#_16","text":"\u80d6\u864e\u60ca\u559c\u5730\u53d1\u73b0\u4e86\u6709N\u4e2a\u7a97\u53e3\u6709\u4ed6\u6700\u559c\u6b22\u5403\u7684\u83dc\uff08\u5176\u5b9e\u90fd\u559c\u6b22\uff1f\uff09\uff0c\u4f46\u662f\u4ed6\u60f3\u5728\u79fb\u52a8\u6700\u77ed\u8ddd\u79bb\uff08\u6bd5\u7adf\u8d70\u591a\u4e86\u4e5f\u662f\u4f1a\u7d2f\u7684\uff09\u7684\u60c5\u51b5\u4e0b\u5403\u5230\u6240\u6709\u4ed6\u559c\u6b22\u5403\u7684\u83dc\u54c1\uff0c\u9965\u997f\u7684\u4ed6\u5df2\u7ecf\u6ca1\u6709\u529b\u6c14\u5199\u51fa\u4ee3\u7801\u6765\u8ba1\u7b97\u81ea\u5df1\u7684\u6700\u4f73\u65b9\u6cd5\u4e86\uff0c\u6240\u4ee5\u4ed6\u627e\u5230\u4e86\u4f60\uff0c\u6765\u5e2e\u4ed6\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\u73b0\u5728\u7ed9\u4f60N\u4e2a\u7a97\u53e3\u53ca\u7a97\u53e3\u7684\u5750\u6807\uff0c\u8bf7\u8f93\u51fa\u80d6\u864e\u6240\u8981\u79fb\u52a8\u7684\u6700\u5c0f\u8ddd\u79bb\u603b\u548c\u3002 \u80d6\u864e\u4e00\u5f00\u59cb\u5728(0,0)\u70b9\u5904\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-11/#_17","text":"\u7b2c\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570n\uff081\u2264n\u226413\uff09 \u3002 \u63a5\u4e0b\u6765\u6bcf\u884c2\u4e2a\u5b9e\u6570\uff0c\u8868\u793a\u7b2ci\u5757\u7a97\u53e3\u7684\u5750\u6807\u3002 \u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u516c\u5f0f\u4e3a","title":"\u8f93\u5165"},{"location":"csdn/2020-08-11/#_18","text":"\u4e00\u4e2a\u6570\uff0c\u8868\u793a\u8981\u8dd1\u7684\u6700\u5c11\u8ddd\u79bb\uff0c\u4fdd\u75592\u4f4d\u5c0f\u6570\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-11/#_19","text":"4 1 1 1 -1 -1 1 -1 -1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-11/#_20","text":"7.41 \u72b6\u538bDP #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std; double dp[1<<14][20]={0}; struct node { double x; double y; }; node a[20]={0}; double q(int i,int j) { double sum=sqrt((double)((a[i].x-a[j].x)*(a[i].x-a[j].x)*1.0+(a[i].y-a[j].y)*(a[i].y-a[j].y)*1.0)); return sum; } int main() { int n; scanf(\"%d\",&n); for(int i=1;i<=n;i++) { scanf(\"%lf%lf\",&a[i].x,&a[i].y); } for(int i=0;i<(1<<(n+1));i++) { for(int j=0;j<=n;j++) { dp[i][j]=999999999; } } dp[1][0]=0; for(int i=0;i<(1<<(n+1));i+=1) { for(int j=0;j<=n;j++) { if(!(i>>j)&1) continue; for(int k=0;k<=n;k++) { if(j==k) continue; if(!(i>>k)&1) continue; dp[i][j]=min(dp[i][j],dp[i^(1<<j)][k]+q(k,j)); } } } double min1=99999999; int k=(1<<(n+1))-1; for(int i=1;i<=n;i++) { min1=min(min1,dp[k][i]); } printf(\"%.2f\\n\",min1); return 0; }","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-12%20%20%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","text":"http://icpc.upc.edu.cn/problem.php?cid=2539&pid=3 \u9898\u76ee\u63cf\u8ff0 \u00b6 Q:KZB \u4f60\u6821\u672c SA \u505a\u5b8c\u505a\u4ec0\u4e48\u554a\uff1f KZB: \u4f5c\u5f0a\uff08\u505a B\uff09\u554a \u6709\u4e00\u6b21\uff0c\u67d0\u7ea7\u67d0\u67d0\u73ed\u7684\u73ed\u4e3b\u4efb\u53bb\u67e5\u4e86\u76d1\u63a7\uff0c\u53d1\u73b0 KZB \u6709\u4eba\u6284\u4f5c\u4e1a\uff0c\u5c31\u628a\u5168\u73ed\u9a82\u4e86\u4e00\u901a\u3002 \u4e3a\u4e86\u9632\u6b62\u8fd9\u7c7b\u4e8b\u60c5\u518d\u6b21\u53d1\u751f Jay \u5c31\u60f3\u51fa\u4e86\u4e00\u9053\u9898\u3002 \u5047\u5982\u6574\u4e2a\u73ed\u4e3a\u4e00\u4e2an\u00d7n\u7684\u77e9\u9635\uff0c\u800c\u5728\u76d1\u63a7\u8f83\u524d\u9762\u7684\u4eba\u4f1a\u906e\u4f4f\u540e\u9762\u7684\u4eba\uff08\u8be6\u89c1\u540e\u9762\u7684\u6837\u4f8b\u89e3\u91ca\uff09\u3002\u6c42\u76d1\u63a7\u4e0d\u4f1a\u53d1\u73b0\u7684\u4eba\u6570\uff08\u5047\u8bbe\u76d1\u63a7\u9ad8\u5ea6\u4e3a1\uff09\u3002 Tip: \u56e0\u4e3a\u76d1\u63a7\u5728(1,1)\u7684\u4f4d\u7f6e\uff0c\u6240\u4ee5\u4f1a\u5360\u4e00\u4e2a\u4f4d\u7f6e\u3002 \u8f93\u5165 \u00b6 \u4e00\u4e2a\u6570n\u3002 \u8f93\u51fa \u00b6 \u4e00\u4e2a\u6570\uff0c\u5373\u76d1\u63a7\u4e0d\u4f1a\u770b\u5230\u7684\u5b66\u751f\u4eba\u6570\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 6 \u6837\u4f8b\u8f93\u51fa \u00b6 14 \u63d0\u793a \u00b6 \u6837\u4f8b\u89e3\u91ca:\u5f53n=6\u65f6\uff0c\u5750\u5728(3,5)\u4e0a\u7684\u540c\u5b66\u4f1a\u88ab\u5750\u5728(2,3)\u4e0a\u7684\u540c\u5b66\u6321\u4f4f\uff0c\u4ee5\u6b64\u7c7b\u63a8\u3002 \u53ef\u4ee5\u53d1\u73b0\u5f53gcd(x,y)\u4e0d\u4e3a1\u65f6\u5373\u7167\u4e0d\u5230\uff0c\u6b27\u62c9\u51fd\u6570\u6c42n\u6570\u5b57\u4ee5\u5185\u7684\u8d28\u56e0\u6570\u5bf9\u6709\u591a\u5c11\u5373\u53ef\u3002 \u56fe\u4e3an\u4e3a5\u65f6\u7684\u89e3\u91ca\uff0c\u6807\u6ce8\u4e3a1\u7684\u662f\u76d1\u63a7\u80fd\u591f\u53d1\u73b0\u7684 \u6b27\u62c9\u51fd\u6570\u7b80\u4ecb\uff1a https://zhuanlan.zhihu.com/p/42748145 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> using namespace std; typedef long long ll; ll n, ans, pr[200507], ph[200507], cnt ; bool vis[200507] ; int main() //\u7ed3\u5408\u4e86\u6b27\u62c9\u7b5b\u6cd5 { ph[1] = 1 ; scanf(\"%lld\", &n ); if(n==1||n==2) { cout<<0<<endl; return 0; } for(ll i = 2 ; i<=n-1; ++ i ) //\u5206\u89e3\u8d28\u56e0\u6570\u548c\u521d\u59cb\u5316 { if(!vis[i]) { cnt ++ ; pr[cnt] = i ; ph[i] = i - 1 ; } for(ll j = 1 ; j <=cnt&&i*pr[j]<=n-1;++ j ) //\u6b27\u62c9\u7b5b\u6cd5 { vis[ i * pr[j] ] = 1 ; if( i % pr[j] == 0 ) { ph[ pr[j] * i ] = ph[i] * pr[j] ; break; } else ph [ pr[j] * i] = ph[i] * (pr[j] - 1 ); } } for(ll i = 2 ; i <= n-1 ; ++ i ) ans += ph[i];//\u7d2f\u52a0\u7ed3\u679c ans=ans*2+4; ans=n*n-ans; cout<<ans<<endl; return 0; }","title":"2020 08 12  \u6b27\u62c9\u51fd\u6570"},{"location":"csdn/2020-08-12%20%20%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#_1","text":"Q:KZB \u4f60\u6821\u672c SA \u505a\u5b8c\u505a\u4ec0\u4e48\u554a\uff1f KZB: \u4f5c\u5f0a\uff08\u505a B\uff09\u554a \u6709\u4e00\u6b21\uff0c\u67d0\u7ea7\u67d0\u67d0\u73ed\u7684\u73ed\u4e3b\u4efb\u53bb\u67e5\u4e86\u76d1\u63a7\uff0c\u53d1\u73b0 KZB \u6709\u4eba\u6284\u4f5c\u4e1a\uff0c\u5c31\u628a\u5168\u73ed\u9a82\u4e86\u4e00\u901a\u3002 \u4e3a\u4e86\u9632\u6b62\u8fd9\u7c7b\u4e8b\u60c5\u518d\u6b21\u53d1\u751f Jay \u5c31\u60f3\u51fa\u4e86\u4e00\u9053\u9898\u3002 \u5047\u5982\u6574\u4e2a\u73ed\u4e3a\u4e00\u4e2an\u00d7n\u7684\u77e9\u9635\uff0c\u800c\u5728\u76d1\u63a7\u8f83\u524d\u9762\u7684\u4eba\u4f1a\u906e\u4f4f\u540e\u9762\u7684\u4eba\uff08\u8be6\u89c1\u540e\u9762\u7684\u6837\u4f8b\u89e3\u91ca\uff09\u3002\u6c42\u76d1\u63a7\u4e0d\u4f1a\u53d1\u73b0\u7684\u4eba\u6570\uff08\u5047\u8bbe\u76d1\u63a7\u9ad8\u5ea6\u4e3a1\uff09\u3002 Tip: \u56e0\u4e3a\u76d1\u63a7\u5728(1,1)\u7684\u4f4d\u7f6e\uff0c\u6240\u4ee5\u4f1a\u5360\u4e00\u4e2a\u4f4d\u7f6e\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-12%20%20%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#_2","text":"\u4e00\u4e2a\u6570n\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-12%20%20%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#_3","text":"\u4e00\u4e2a\u6570\uff0c\u5373\u76d1\u63a7\u4e0d\u4f1a\u770b\u5230\u7684\u5b66\u751f\u4eba\u6570\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-12%20%20%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#_4","text":"6","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-12%20%20%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#_5","text":"14","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-12%20%20%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#_6","text":"\u6837\u4f8b\u89e3\u91ca:\u5f53n=6\u65f6\uff0c\u5750\u5728(3,5)\u4e0a\u7684\u540c\u5b66\u4f1a\u88ab\u5750\u5728(2,3)\u4e0a\u7684\u540c\u5b66\u6321\u4f4f\uff0c\u4ee5\u6b64\u7c7b\u63a8\u3002 \u53ef\u4ee5\u53d1\u73b0\u5f53gcd(x,y)\u4e0d\u4e3a1\u65f6\u5373\u7167\u4e0d\u5230\uff0c\u6b27\u62c9\u51fd\u6570\u6c42n\u6570\u5b57\u4ee5\u5185\u7684\u8d28\u56e0\u6570\u5bf9\u6709\u591a\u5c11\u5373\u53ef\u3002 \u56fe\u4e3an\u4e3a5\u65f6\u7684\u89e3\u91ca\uff0c\u6807\u6ce8\u4e3a1\u7684\u662f\u76d1\u63a7\u80fd\u591f\u53d1\u73b0\u7684 \u6b27\u62c9\u51fd\u6570\u7b80\u4ecb\uff1a https://zhuanlan.zhihu.com/p/42748145 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> using namespace std; typedef long long ll; ll n, ans, pr[200507], ph[200507], cnt ; bool vis[200507] ; int main() //\u7ed3\u5408\u4e86\u6b27\u62c9\u7b5b\u6cd5 { ph[1] = 1 ; scanf(\"%lld\", &n ); if(n==1||n==2) { cout<<0<<endl; return 0; } for(ll i = 2 ; i<=n-1; ++ i ) //\u5206\u89e3\u8d28\u56e0\u6570\u548c\u521d\u59cb\u5316 { if(!vis[i]) { cnt ++ ; pr[cnt] = i ; ph[i] = i - 1 ; } for(ll j = 1 ; j <=cnt&&i*pr[j]<=n-1;++ j ) //\u6b27\u62c9\u7b5b\u6cd5 { vis[ i * pr[j] ] = 1 ; if( i % pr[j] == 0 ) { ph[ pr[j] * i ] = ph[i] * pr[j] ; break; } else ph [ pr[j] * i] = ph[i] * (pr[j] - 1 ); } } for(ll i = 2 ; i <= n-1 ; ++ i ) ans += ph[i];//\u7d2f\u52a0\u7ed3\u679c ans=ans*2+4; ans=n*n-ans; cout<<ans<<endl; return 0; }","title":"\u63d0\u793a"},{"location":"csdn/2020-08-13/","text":"http://icpc.upc.edu.cn/problem.php?id=16535 \u9898\u76ee \u00b6 16535: Lead of Wisdom \u9898\u76ee\u63cf\u8ff0 \u00b6 In an online game, \"Lead of Wisdom\" is a place where the lucky player can randomly get powerful items. There are k types of items, a player can wear at most one item for each type. For the i-th item, it has four attributes ai,bi,ci and di. Assume the set of items that the player wearing is S, the damage rate of the player DMG can be calculated by the formula: Little Q has got n items from \"Lead of Wisdom\", please write a program to help him select which items to wear such that the value of DMG is maximized. \u8f93\u5165 \u00b6 The first line of the input contains a single integer T (1\u2264T\u226410), the number of test cases. For each case, the first line of the input contains two integers n and k (1\u2264n,k\u226450), denoting the number of items and the number of item types. Each of the following n lines contains five integers ti,ai,bi,ci and di (1\u2264ti\u2264k, 0\u2264ai,bi,ci,di\u2264100), denoting an item of type ti whose attributes are ai,bi,ci and di. \u8f93\u51fa \u00b6 For each test case, output a single line containing an integer, the maximum value of DMG. \u6837\u4f8b\u8f93\u5165 \u00b6 1 6 4 1 17 25 10 0 2 0 0 25 14 4 17 0 21 0 1 5 22 0 10 2 0 16 20 0 4 37 0 0 0 \u6837\u4f8b\u8f93\u51fa \u00b6 297882000 \u66b4\u529b\u641c\u7d22\u5373\u53ef #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int a , b , c , d ; }; vector < node > w [ 60 ]; int t , n , k , a , b , c , d , e ; int cnt = 0 ; ll max1 = 0 ; map < int , int > mp ; inline int q ( register int p , register int sum1 , register int sum2 , register int sum3 , register int sum4 ) { if ( p == cnt + 1 ) { max1 = max ( max1 ,( ll ) sum1 * sum2 * sum3 * sum4 ); return 0 ; } if ( w [ p ]. empty ()) q ( p + 1 , sum1 , sum2 , sum3 , sum4 ); else for ( register int i = 0 ; i < w [ p ]. size (); i ++ ) { q ( p + 1 , sum1 + w [ p ][ i ]. a , sum2 + w [ p ][ i ]. b , sum3 + w [ p ][ i ]. c , sum4 + w [ p ][ i ]. d ); } } int main () { scanf ( \"%d\" , & t ); while ( t -- ) { max1 = 0 ; scanf ( \"%d%d\" , & n , & k ); for ( register int i = 1 ; i <= k ; i ++ ) w [ i ]. clear (); mp . clear (); cnt = 0 ; for ( register int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d%d%d%d%d\" , & e , & a , & b , & c , & d ); if ( mp [ e ] == 0 ) { mp [ e ] =++ cnt ; } w [ mp [ e ]]. push_back ({ a , b , c , d }); } q ( 1 , 100 , 100 , 100 , 100 ); printf ( \"%lld \\n \" , max1 ); } }","title":"2020-08-13"},{"location":"csdn/2020-08-13/#_1","text":"16535: Lead of Wisdom","title":"\u9898\u76ee"},{"location":"csdn/2020-08-13/#_2","text":"In an online game, \"Lead of Wisdom\" is a place where the lucky player can randomly get powerful items. There are k types of items, a player can wear at most one item for each type. For the i-th item, it has four attributes ai,bi,ci and di. Assume the set of items that the player wearing is S, the damage rate of the player DMG can be calculated by the formula: Little Q has got n items from \"Lead of Wisdom\", please write a program to help him select which items to wear such that the value of DMG is maximized.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-13/#_3","text":"The first line of the input contains a single integer T (1\u2264T\u226410), the number of test cases. For each case, the first line of the input contains two integers n and k (1\u2264n,k\u226450), denoting the number of items and the number of item types. Each of the following n lines contains five integers ti,ai,bi,ci and di (1\u2264ti\u2264k, 0\u2264ai,bi,ci,di\u2264100), denoting an item of type ti whose attributes are ai,bi,ci and di.","title":"\u8f93\u5165"},{"location":"csdn/2020-08-13/#_4","text":"For each test case, output a single line containing an integer, the maximum value of DMG.","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-13/#_5","text":"1 6 4 1 17 25 10 0 2 0 0 25 14 4 17 0 21 0 1 5 22 0 10 2 0 16 20 0 4 37 0 0 0","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-13/#_6","text":"297882000 \u66b4\u529b\u641c\u7d22\u5373\u53ef #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int a , b , c , d ; }; vector < node > w [ 60 ]; int t , n , k , a , b , c , d , e ; int cnt = 0 ; ll max1 = 0 ; map < int , int > mp ; inline int q ( register int p , register int sum1 , register int sum2 , register int sum3 , register int sum4 ) { if ( p == cnt + 1 ) { max1 = max ( max1 ,( ll ) sum1 * sum2 * sum3 * sum4 ); return 0 ; } if ( w [ p ]. empty ()) q ( p + 1 , sum1 , sum2 , sum3 , sum4 ); else for ( register int i = 0 ; i < w [ p ]. size (); i ++ ) { q ( p + 1 , sum1 + w [ p ][ i ]. a , sum2 + w [ p ][ i ]. b , sum3 + w [ p ][ i ]. c , sum4 + w [ p ][ i ]. d ); } } int main () { scanf ( \"%d\" , & t ); while ( t -- ) { max1 = 0 ; scanf ( \"%d%d\" , & n , & k ); for ( register int i = 1 ; i <= k ; i ++ ) w [ i ]. clear (); mp . clear (); cnt = 0 ; for ( register int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d%d%d%d%d\" , & e , & a , & b , & c , & d ); if ( mp [ e ] == 0 ) { mp [ e ] =++ cnt ; } w [ mp [ e ]]. push_back ({ a , b , c , d }); } q ( 1 , 100 , 100 , 100 , 100 ); printf ( \"%lld \\n \" , max1 ); } }","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-14/","text":"http://icpc.upc.edu.cn/problem.php?cid=2526&pid=5 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u5728\u66fe\u7ecf\u7684\u8bb2\u89e3\u4e2d\uff0c\u82b1\u548c\u4ed6\u7684\u5144\u5f1f\u59d0\u59b9\u4eec\u88ab\u8fd9\u4e2a\u53eb\u505a Yyx \u7684\u4eba\u6446\u6765\u6446\u53bb\uff0c\u5413\u5f97\u8033\u6735\u90fd\u778e\u4e86\uff0c\u5634\u5df4\u4e5f\u542c\u4e0d\u89c1\u4e86\u3002\u4e8e\u662f\u4ed6\u4eec\u51b3\u5b9a\u300c\u4ee5\u5176\u4eba\u4e4b\u9053\u8fd8\u6cbb\u5176\u4eba\u4e4b\u8eab\u300d\uff0c\u4ed6\u4eec\u628a Yyx, Kangkang, Michael \u7b49\u4eba\u6446\u6210\u4e00\u6392\uff0c\u8fd9\u4e2a\u65f6\u5019\uff0c\u82b1\u8bf4\u9053\uff1a\u300c\u4f60\u4eec\u7684\u8eab\u9ad8\u592a\u4e0d\u548c\u8c10\u4e86\uff0c\u53ea\u6709\u6ee1\u8db3\u6211\u7684\u8981\u6c42\u7684\u4eba\u624d\u80fd\u7559\u4e0b\uff0c\u5176\u4ed6\u4eba\u90fd\u53bb\u5f53\u82b1\u3002\u300d\u800c Yyx \u60f3\u7559\u4e0b\u5c3d\u91cf\u591a\u7684\u540c\u80de\u4eec\uff0c\u4e8e\u662f\u4ed6\u6765\u627e\u4f60\u4e86\u3002 \u5177\u4f53\u800c\u8a00\uff0c\u4eba\u7684\u9ad8\u5ea6\u53ef\u4ee5\u770b\u6210\u4e00\u5217\u6574\u6570h1,h2,...,hn\u3002 \u8bbe\u5f53\u4e00\u90e8\u5206\u4eba\u51fa\u53bb\u540e\uff0c\u5269\u4e0b\u7684\u4eba\u7684\u9ad8\u5ea6\u4f9d\u6b21\u4e3ag1,g2,...,gm \uff0c\u5219\u82b1\u4eec\u5e0c\u671b\u4e0b\u9762\u4e24\u4e2a\u6761\u4ef6\u4e2d\u81f3\u5c11\u6709\u4e00\u4e2a\u6ee1\u8db3\uff1a \u00b7\u6761\u4ef6A \uff1a\u5bf9\u4e8e\u6240\u6709 g2i>g2i-1,g2i>g2i+1\u3002 \u00b7\u6761\u4ef6B \uff1a\u5bf9\u4e8e\u6240\u6709 g2i<g2i-1,g2i 1 \u65f6\u6700\u591a\u6709\u4e00\u4e2a\u80fd\u6ee1\u8db3\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u5305\u542b\u4e00\u4e2a\u6b63\u6574\u6570 n \uff0c\u8868\u793a\u5f00\u59cb\u65f6\u7684\u4eba\u6570\u3002 \u7b2c\u4e8c\u884c\u5305\u542b n \u4e2a\u6b63\u6574\u6570\uff0c\u4f9d\u6b21\u4e3a h1,h2,...hn , \u8868\u793a\u6bcf\u4e2a\u4eba\u7684\u9ad8\u5ea6\u3002 \u8f93\u51fa \u00b6 \u8f93\u51fa\u7559\u4e0b\u7684\u4eba\u6570\u7684\u6700\u5927\u503c\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 5 5 3 2 1 2 \u6837\u4f8b\u8f93\u51fa \u00b6 3 \u63d0\u793a \u00b6 \u5bf9\u4e8e\u6240\u6709\u6570\u636e\uff0c1\u2264n\u2264106,0\u2264hi\u2264106 \u52a8\u6001\u89c4\u5212 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std; typedef long long ll; ll a[1005000]={0}; ll s1[1005000]={0}; ll s2[1005000]={0}; int main() { ll n; scanf(\"%lld\",&n); for(ll i=1;i<=n;i++) scanf(\"%lld\",&a[i]); s1[1]=s2[1]=1; for(ll i=2;i<=n;i++) { if(a[i]>a[i-1]) { s1[i]=max(s1[i-1],s2[i-1]+1); s2[i]=s2[i-1]; } if(a[i]==a[i-1]) { s1[i]=s1[i-1]; s2[i]=s2[i-1]; } if(a[i]<a[i-1]) { s2[i]=max(s2[i],s1[i-1]+1); s1[i]=s1[i-1]; } } printf(\"%lld\\n\",max(s1[n],s2[n])); }","title":"2020-08-14"},{"location":"csdn/2020-08-14/#_1","text":"\u5728\u66fe\u7ecf\u7684\u8bb2\u89e3\u4e2d\uff0c\u82b1\u548c\u4ed6\u7684\u5144\u5f1f\u59d0\u59b9\u4eec\u88ab\u8fd9\u4e2a\u53eb\u505a Yyx \u7684\u4eba\u6446\u6765\u6446\u53bb\uff0c\u5413\u5f97\u8033\u6735\u90fd\u778e\u4e86\uff0c\u5634\u5df4\u4e5f\u542c\u4e0d\u89c1\u4e86\u3002\u4e8e\u662f\u4ed6\u4eec\u51b3\u5b9a\u300c\u4ee5\u5176\u4eba\u4e4b\u9053\u8fd8\u6cbb\u5176\u4eba\u4e4b\u8eab\u300d\uff0c\u4ed6\u4eec\u628a Yyx, Kangkang, Michael \u7b49\u4eba\u6446\u6210\u4e00\u6392\uff0c\u8fd9\u4e2a\u65f6\u5019\uff0c\u82b1\u8bf4\u9053\uff1a\u300c\u4f60\u4eec\u7684\u8eab\u9ad8\u592a\u4e0d\u548c\u8c10\u4e86\uff0c\u53ea\u6709\u6ee1\u8db3\u6211\u7684\u8981\u6c42\u7684\u4eba\u624d\u80fd\u7559\u4e0b\uff0c\u5176\u4ed6\u4eba\u90fd\u53bb\u5f53\u82b1\u3002\u300d\u800c Yyx \u60f3\u7559\u4e0b\u5c3d\u91cf\u591a\u7684\u540c\u80de\u4eec\uff0c\u4e8e\u662f\u4ed6\u6765\u627e\u4f60\u4e86\u3002 \u5177\u4f53\u800c\u8a00\uff0c\u4eba\u7684\u9ad8\u5ea6\u53ef\u4ee5\u770b\u6210\u4e00\u5217\u6574\u6570h1,h2,...,hn\u3002 \u8bbe\u5f53\u4e00\u90e8\u5206\u4eba\u51fa\u53bb\u540e\uff0c\u5269\u4e0b\u7684\u4eba\u7684\u9ad8\u5ea6\u4f9d\u6b21\u4e3ag1,g2,...,gm \uff0c\u5219\u82b1\u4eec\u5e0c\u671b\u4e0b\u9762\u4e24\u4e2a\u6761\u4ef6\u4e2d\u81f3\u5c11\u6709\u4e00\u4e2a\u6ee1\u8db3\uff1a \u00b7\u6761\u4ef6A \uff1a\u5bf9\u4e8e\u6240\u6709 g2i>g2i-1,g2i>g2i+1\u3002 \u00b7\u6761\u4ef6B \uff1a\u5bf9\u4e8e\u6240\u6709 g2i<g2i-1,g2i 1 \u65f6\u6700\u591a\u6709\u4e00\u4e2a\u80fd\u6ee1\u8db3\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-14/#_2","text":"\u7b2c\u4e00\u884c\u5305\u542b\u4e00\u4e2a\u6b63\u6574\u6570 n \uff0c\u8868\u793a\u5f00\u59cb\u65f6\u7684\u4eba\u6570\u3002 \u7b2c\u4e8c\u884c\u5305\u542b n \u4e2a\u6b63\u6574\u6570\uff0c\u4f9d\u6b21\u4e3a h1,h2,...hn , \u8868\u793a\u6bcf\u4e2a\u4eba\u7684\u9ad8\u5ea6\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-14/#_3","text":"\u8f93\u51fa\u7559\u4e0b\u7684\u4eba\u6570\u7684\u6700\u5927\u503c\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-14/#_4","text":"5 5 3 2 1 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-14/#_5","text":"3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-14/#_6","text":"\u5bf9\u4e8e\u6240\u6709\u6570\u636e\uff0c1\u2264n\u2264106,0\u2264hi\u2264106 \u52a8\u6001\u89c4\u5212 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std; typedef long long ll; ll a[1005000]={0}; ll s1[1005000]={0}; ll s2[1005000]={0}; int main() { ll n; scanf(\"%lld\",&n); for(ll i=1;i<=n;i++) scanf(\"%lld\",&a[i]); s1[1]=s2[1]=1; for(ll i=2;i<=n;i++) { if(a[i]>a[i-1]) { s1[i]=max(s1[i-1],s2[i-1]+1); s2[i]=s2[i-1]; } if(a[i]==a[i-1]) { s1[i]=s1[i-1]; s2[i]=s2[i-1]; } if(a[i]<a[i-1]) { s2[i]=max(s2[i],s1[i-1]+1); s1[i]=s1[i-1]; } } printf(\"%lld\\n\",max(s1[n],s2[n])); }","title":"\u63d0\u793a"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/","text":"http://icpc.upc.edu.cn/problem.php?cid=2535&pid=1 \u9898\u76ee\u63cf\u8ff0 \u00b6 eobiyye\u7ed9\u4e86\u4f60\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u5e8f\u5217ai\uff0c\u5e8f\u5217\u4e2d\u6bcf\u4e2a\u5143\u7d20\u7684\u521d\u59cb\u503c\u4e3a0\u3002 \u63a5\u4e0b\u6765\u5979\u4f1a\u5bf9\u8fd9\u4e2a\u5e8f\u5217\u8fdb\u884cm\u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u64cd\u4f5c\u67094\u4e2a\u53c2\u6570l,r,s,e\uff0c\u8868\u793a\u5c06\u533a\u95f4[l,r]\u52a0\u4e0a\u4e00\u4e2a\u9996\u9879\u4e3as\uff0c\u672b\u9879\u4e3ae\u7684\u7b49\u5dee\u6570\u5217\u3002 \u82e5\u4e00\u6b21\u64cd\u4f5c\u4e2dl=1,r=5,s=2,e=10\uff0c\u5219\u5bf9\u5e8f\u5217\u4e2d\u7b2c1~5\u4e2a\u6570\u5206\u522b\u52a0\u4e0a2,4,6,8,10\u3002 \u73b0\u5728Geobiyye\u8981\u6c42\u4f60\u6c42\u51fam\u6b21\u64cd\u4f5c\u540e\u5e8f\u5217\u4e2d\u7684\u6bcf\u4e2a\u6570\u7684\u503c\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c2\u4e2a\u6574\u6570n,m\uff0c\u8868\u793a\u5e8f\u5217\u957f\u5ea6\u548c\u64cd\u4f5c\u6570\u3002 \u63a5\u4e0b\u6765m\u884c\uff0c\u6bcf\u884c4\u4e2a\u6574\u6570l,r,s,e\uff0c\u542b\u4e49\u89c1\u9898\u76ee\u63cf\u8ff0\u3002 \u6570\u636e\u4fdd\u8bc1\u7b49\u5dee\u6570\u5217\u4e2d\u7684\u6bcf\u4e00\u9879\u90fd\u662f\u6574\u6570\u3002 \u8f93\u51fa \u00b6 \u7531\u4e8e\u8f93\u51fa\u6570\u636e\u8fc7\u5927\uff0cGeobiyye\u53ea\u60f3\u8981\u77e5\u9053\u6700\u7ec8\u5e8f\u5217\u6bcf\u4e00\u9879\u7684\u5f02\u6216\u548c\uff0c\u5373\u3002\uff08\u5176\u4e2d\u8868\u793a\u4e8c\u8fdb\u5236\u4e0b\u7684\u5f02\u6216\u64cd\u4f5c\uff0c\u5728c++\u4e2d\u4e3a^\uff09 \u6837\u4f8b\u8f93\u5165 \u00b6 5 2 1 5 2 10 2 4 1 1 \u6837\u4f8b\u8f93\u51fa \u00b6 3 \u6837\u4f8b\u89e3\u91ca\uff1a \u00b6 \u7b2c\u4e00\u6b21\u64cd\u4f5c\u52a0\u7684\u6570\u5217\uff1a2 4 6 8 10 \u7b2c\u4e8c\u6b21\u64cd\u4f5c\u52a0\u7684\u6570\u5217\uff1a0 1 1 1 0 \u6240\u6709\u64cd\u4f5c\u7ed3\u675f\u540e\u5e8f\u5217\u6bcf\u4e2a\u5143\u7d20\u503c\u4e3a\uff1a2 5 7 9 10\u3002 \u8f93\u51fa\u5f02\u6216\u548c\uff0c\u5c31\u662f3\u3002 \u3010\u6570\u636e\u8303\u56f4\u3011 \u5bf9\u4e8e30%\u7684\u6570\u636e\uff1an,m\u22641000 \u3002 \u5bf9\u4e8e50%\u7684\u6570\u636e\uff1an,m\u2264100000\u3002 \u5bf9\u4e8e\u53e6\u591620%\u7684\u6570\u636e\uff1as=e\u3002 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff1an,m\u2264500000,1\u2264l\uff1cr\u2264n\u3002 \u6570\u636e\u4fdd\u8bc1\u8f93\u5165\u6570\u636e\u4ee5\u53ca\u5728\u4efb\u4f55\u65f6\u5019\u5e8f\u5217\u4e2d\u7684\u6570\u5728[0,9\u00d71018]\u8303\u56f4\u5185\u3002 \u7b49\u5dee\u6570\u5217\u7684\u524d\u7f00\u548c #include <bits/stdc++.h> using namespace std ; const long long int N = 1e7 + 500 ; long long int out [ N ] = { 0 }; int main () { std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( 0 ); register long long int n , m , l , r , ks , e1 , dc , tmp = 0 ; register long long int max1 = 0 , ans = 0 ; cin >> n >> m ; register long long int i ; for ( i = 1 ; i <= m ; i ++ ) { cin >> l >> r >> ks >> e1 ; dc = ( e1 - ks ) / ( r - l ); out [ l ] = out [ l ] + ks ; out [ l + 1 ] = out [ l + 1 ] + dc - ks ; out [ r + 1 ] = out [ r + 1 ] - dc - e1 ; out [ r + 2 ] = out [ r + 2 ] + e1 ; } for ( i = 1 ; i <= n ; i ++ ) { out [ i ] = out [ i -1 ] + out [ i ]; tmp += out [ i ]; ans = ans ^ tmp ; } cout << ans << endl ; return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2535&pid=5 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u8bf7\u5f00 long long\u3002 \u8001\u7239\u8bf4\u8981\u7528\u9b54\u6cd5\u6253\u8d25\u9b54\u6cd5 \u2014\u2014\u2014\u2014 3edc2wsx1qaz \u4e00\u5929\uff0c\u5de8\u795e 3edc2wsx1qaz \u6b63\u5728\u68ee\u6797\u91cc\u6f2b\u6b65\uff0c\u7a81\u7136\uff0c\u4e00\u53ea\u51f6\u6076\u7684\u53cc\u5934\u5de8\u4eba\u62e6\u4f4f\u4e86\u4ed6\u3002 \u53cc\u5934\u5de8\u4eba\u7684\u4e24\u4e2a\u5934\u7684\u653b\u51fb\u529b\u5206\u522b\u4e3aa,b\u3002\u5b83\u6bcf\u6b21\u53ef\u4ee5\u5bf9 3edc2wsx1qaz \u9020\u6210 |a-b| \u7684\u9b54\u6cd5\u4f24\u5bb3\u3002 3edc2wsx1qaz \u89c9\u5f97\u8fd9\u53ea\u602a\u7269\u5341\u5206\u96be\u7f20\u3002 \u201c\u8981\u7528\u9b54\u6cd5\u6253\u8d25\u9b54\u6cd5\uff01\u201d \u5c31\u5728\u8fd9\u65f6\uff0c\u8001\u7239\u7684\u8bdd\u56de\u54cd\u5728 3edc2wsx1qaz \u7684\u8033\u8fb9\uff0c3edc2wsx1qaz \u987f\u65f6\u611f\u5230\u4e00\u80a1\u529b\u91cf\u6d8c\u4e0a\u5fc3\u5934\uff0c\u4e8e\u662f\uff0c\u4ed6\u51b3\u5b9a\u4ece\u5b83\u7684\u7279\u6b8a\u80fd\u529b\u4e0b\u624b\uff0c\u4ece\u800c\u6253\u8d25\u5b83\u3002 998244353\u5e74\u524d\uff0c\u5de8\u795e Rainy7 \u66fe\u7ecf\u6559\u8fc7\u4ed6\u540d\u4e3a \u722a\u5df4 \u7684 % \u6cd5\uff0c\u4ed6\u51b3\u5b9a\u7528\u8fd9\u79cd % \u6cd5\u51fb\u8d25\u5de8\u4eba\u3002 3edc2wsx1qaz \u53ef\u4ee5\u4f7f\u7528\u65e0\u9650\u6b21\u6cd5\u672f\uff0c\u7b2ci\u6b21\u4f7f\u7528\u53ef\u4ee5\u4efb\u9009\u4e00\u4e2a\u5934\uff0c\u4f7f\u5f97\u5b83\u7684\u653b\u51fb\u529b\u589e\u52a0\u6216\u51cf\u5c11i\u3002\uff08\u5728\u6b64\u8fc7\u7a0b\u4e2d\u653b\u51fb\u529b\u53ef\u4ee5\u662f\u8d1f\u6570\uff09 3edc2wsx1qaz \u4e0d\u60f3\u53d7\u5230\u4efb\u4f55\u4f24\u5bb3\uff0c\u6240\u4ee5\uff0c\u4ed6\u60f3\u77e5\u9053\uff0c\u4ed6\u81f3\u5c11\u8981\u65bd\u51e0\u6b21\u6cd5\uff0c\u624d\u80fd\u4f7f\u5f97a-b=0\u3002 3edc2wsx1qaz \u53ea\u7528\u4e86114514-1919810 s\u5c31\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u4e8e\u662f\u8ba9\u60a8\u89e3\u51b3\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6570T\uff0c\u8868\u793a\u6570\u636e\u7ec4\u6570\u3002 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff0c\u4e00\u884c\u4e24\u4e2a\u6570a,b\uff0c\u4ee3\u8868\u53cc\u5934\u5de8\u4eba\u4e24\u4e2a\u5934\u7684\u653b\u51fb\u529b\u3002 \u8f93\u51fa \u00b6 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff0c\u4e00\u884c\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6700\u5c0f\u6b21\u6570\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 3 1 3 11 11 30 20 \u3010\u6837\u4f8b2\u3011 1 114514 1919810 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 3 0 4 \u3010\u6837\u4f8b2\u3011 1900 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca\uff1a \u5bf9\u4e8e\u6570\u636e1\uff0c\u4e00\u79cd\u64cd\u4f5c\u6d41\u7a0b\u5982\u4e0b\uff1a1+1=2,3+2=5,2+3=5 \u5bf9\u4e8e\u6570\u636e2\uff0c\u7531\u4e8e\u76f8\u7b49\uff0c\u6240\u4ee5\u7b54\u6848\u4e3a0\u3002 \u5bf9\u4e8e\u6570\u636e3\uff0c\u4e00\u79cd\u64cd\u4f5c\u6d41\u7a0b\u5982\u4e0b\uff1a20+1+2+3+4=30\u3002 \u89e3\u6790 \u00b6 \u5047\u8bbe\u53cc\u65b9\u7684\u8840\u91cf\u5206\u522b\u4e3aa\u548cb\uff08a<b\uff09\uff0c\u7531\u4e8e\u51cf\u6cd5\u76f8\u5f53\u4e8e\u5bf9\u53e6\u4e00\u4e2a\u8fdb\u884c\u52a0\u6cd5\u8fd0\u7b97\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u7528\u52a0\u6cd5\u3002\u9996\u5148\uff0c\u6211\u4eec\u5bf9a\u8fdb\u884c\u52a0\u6cd5\u76f4\u5230\u5927\u4e8e\u7b49\u4e8eb\uff0c\u5982\u679c\u7b49\u4e8eb\uff0c\u7ed3\u679c\u5c31\u662f\u8fdb\u884c\u52a0\u6cd5\u7684\u6b21\u6570\uff0c\u5982\u679c\u5927\u4e8eb\uff0c\u5219\u5206\u4e24\u79cd\u60c5\u51b5\uff0c\u5982\u679c\u8d85\u51fa\u7684\u6570\u76ee\u4e3a\u5076\u6570\uff0c\u5219\u6211\u4eec\u53ef\u4ee5\u628a\u591a\u51fa\u6765\u7684\u90e8\u5206\u9664\u4ee52\u4ecea\u51cf\u53bb\u52a0\u5230b\u4e0a\uff0c\u8fd9\u6837\u4e24\u8fb9\u5c31\u76f8\u540c\u4e86\uff0c\u5982\u679c\u4e3a\u5947\u6570\uff0c\u7ee7\u7eed\u52a0\uff0c\u76f4\u81f3\u5dee\u503c\u4e3a\u5076\u6570\u4e3a\u6b62\u3002 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int a , b ; scanf ( \"%d%d\" , & a , & b ); if ( a > b ) swap ( a , b ); int i ; for ( i = 1 ; a < b || ( a > b && ( a - b ) % 2 == 1 ); i ++ ) a += i ; cout << i -1 << endl ; } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2535&pid=6 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u8bf7\u5f00 long long\u3002 \u82e5\u4f17\u4eba\u7686\u4e27\u6c14\uff0c\u5219\u6211\u8c12\u89c1\u8c0f\u8a00\u3002\u2014\u2014\u2014\u2014 Rainy7 \u5728\u6d69\u701a\u65e0\u57a0\u7684\u5b87\u5b99\u4e2d\uff0c\u5206\u5e03\u7740\u8bb8\u8bb8\u591a\u591a\u7684\u6587\u660e\uff0c\u5b83\u4eec\u4e4b\u95f4\u7ecf\u5e38\u8d77\u51b2\u7a81\u3002 \u4e00\u6b21\uff0c\u4e00\u4e2a\u6587\u660e\u6d3e\u51fa\u5927\u6279\u661f\u8230\u8fdb\u653b\u5730\u7403\uff0c\u5730\u7403\u4eba\u88ab\u6253\u5f97\u843d\u8352\u800c\u9003\u3002 \u6b64\u65f6\u5728\u5730\u7403\u4e0a\uff0c\u5de8\u795e Rainy7 \u5929\u5929\u540a\u6253\u96c6\u8bad\u961f\uff0c\u5df2\u7ecf\u611f\u5230\u538c\u70e6\u4e86\uff0c\u4e8e\u662f\uff0cRainy7 \u4fbf\u53bb\u540a\u6253\u5916\u661f\u4eba\u4e86\u3002 Rainy7 \u4f7f\u7528\u9b54\u6cd5\uff0c\u5c06\u8fd9n\u8258\u661f\u8230\u5c01\u9501\u4f4f\u4e86\u3002\u7136\u800c\uff0c\u8fd9\u4e9b\u661f\u8230\u90fd\u6709\u62a4\u76fe\u4fdd\u62a4\uff0cRainy7 \u8981\u60f3\u65b9\u8bbe\u6cd5\u7834\u9664\u5b83\u4eec\u3002 \u661f\u8230\u7684\u5c01\u9501\u5173\u7cfb\u53ef\u4ee5\u770b\u6210\u4e00\u68f5\u6811\u3002\u4e00\u5f00\u59cb\uff0c Rainy7 \u53ef\u4ee5\u4efb\u9009\u4e00\u8258\u661f\u8230\uff0c\u7136\u540e\u76f4\u63a5\u89e3\u9664\u5b83\u7684\u62a4\u76fe\u3002\u7d27\u63a5\u7740\uff0cRainy7 \u53ef\u4ee5\u8fdb\u884cn\u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u9009\u62e9\u4e00\u8258\u672a\u88ab\u62a4\u76fe\u4fdd\u62a4\u7684\u661f\u8230\uff0c\u7136\u540e\u76f4\u63a5\u6467\u6bc1\u5b83\uff0c\u5e76\u4e14\u83b7\u5f97\u5b83\u88ab\u6467\u6bc1\u524d\u6240\u5728\u7684\u5168\u90fd\u662f\u672a\u88ab\u6467\u6bc1\u7684\u661f\u8230\u7684\u8fde\u901a\u5757\u7684\u5927\u5c0f\u7684\u9b54\u6cd5\u503c\u3002\u4e00\u8258\u661f\u8230\u88ab\u6467\u6bc1\u540e\uff0c\u4e0e\u5b83\u76f4\u63a5\u76f8\u8fde\u4e14\u672a\u88ab\u6467\u6bc1\u7684\u661f\u8230\u7684\u62a4\u76fe\u4f1a\u5168\u90e8\u88ab\u89e3\u9664\u3002 Rainy7 \u60f3\u77e5\u9053\uff0c\u81ea\u5df1\u6700\u591a\u80fd\u83b7\u5f97\u591a\u5c11\u9b54\u6cd5\u503c\u3002\u5979\u53ea\u7528\u4e86114514-1919810s\u5c31\u89e3\u51b3\u4e86\u95ee\u9898\uff0c\u4e8e\u662f\u628a\u95ee\u9898\u629b\u7ed9\u4e86\u60a8\u3002 \u5982\u56fe\u6240\u793a\uff0c\u52a0\u7c97\u7684\u661f\u8230\u8868\u793a\u5df2\u7ecf\u88ab\u6467\u6bc1\u3002\u82e5\u9009\u62e92\u53f7\u661f\u8230\uff0c\u5c06\u4f1a\u83b7\u5f974\u70b9\u9b54\u6cd5\u503c\uff0c\u5e76\u4e14\u89e3\u96643,5,6\u7684\u62a4\u76fe\u3002\u82e5\u9009\u62e99\u53f7\u661f\u8230\uff0c\u5c06\u4f1a\u83b7\u5f973\u70b9\u9b54\u6cd5\u503c\uff0c\u5e76\u4e14\u89e3\u96647,8\u7684\u62a4\u76fe\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6570n\uff0c\u8868\u793a\u661f\u8230\u6570\u91cf\u3002 \u63a5\u4e0b\u6765n-1\u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6570u,v\uff0c\u8868\u793a\u661f\u8230\u7684\u76f8\u8fde\u5173\u7cfb\u3002 \u8f93\u51fa \u00b6 \u4e00\u884c\u4e00\u4e2a\u6570\uff0c\u8868\u793a\u6700\u591a\u80fd\u83b7\u5f97\u7684\u9b54\u6cd5\u503c\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 9 1 2 2 3 2 5 2 6 1 4 4 9 9 7 9 8 \u3010\u6837\u4f8b2\u3011 5 1 2 1 3 2 4 2 5 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 36 \u3010\u6837\u4f8b2\u3011 14 \u63d0\u793a \u00b6 \u89e3\u6790 \u00b6 \u6811\u5f62DP\uff0c\u5148\u6c42\u51fa1\u70b9\u7684\u9b54\u6cd5\u503c\uff0c\u540e\u7ecf\u8fc7\u72b6\u6001\u8f6c\u79fb\u6c42\u51fa\u5176\u4ed6\u70b9\u7684\u9b54\u6cd5\u503c\uff0c\u6c42\u6700\u5927\u503c\u5373\u53ef\u3002 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; vector < ll > w [ 300500 ]; int vis [ 300500 ] = { 0 }; int vis1 [ 300500 ] = { 0 }; ll size1 [ 300500 ] = { 0 }; ll ans [ 300500 ] = { 0 }; ll n ; ll dfs ( ll k ) { if ( size1 [ k ] != 0 ) return size1 [ k ]; size1 [ k ] = 1 ; vis [ k ] = 1 ; for ( ll i = 0 ; i < w [ k ]. size (); i ++ ) { if ( ! vis [ w [ k ][ i ]]) { size1 [ k ] += dfs ( w [ k ][ i ]); } } return size1 [ k ]; } ll dfs1 ( ll k ) { vis1 [ k ] = 1 ; for ( ll i = 0 ; i < w [ k ]. size (); i ++ ) { if ( ! vis1 [ w [ k ][ i ]]) { ll x = w [ k ][ i ]; ans [ x ] = ans [ k ] + ( n - size1 [ x ] -1 ) - ( size1 [ x ] -1 ); dfs1 ( x ); } } } int main () { scanf ( \"%lld\" , & n ); ll x , y ; for ( ll i = 1 ; i <= n -1 ; i ++ ) { scanf ( \"%lld%lld\" , & x , & y ); w [ x ]. push_back ( y ); w [ y ]. push_back ( x ); } dfs ( 1 ); for ( ll i = 1 ; i <= n ; i ++ ) { ans [ 1 ] += size1 [ i ]; } dfs1 ( 1 ); ll max1 = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { max1 = max ( max1 , ans [ i ]); } cout << max1 << endl ; return 0 ; }","title":"2020 08 16 \u6811\u5f62DP+\u7b49\u5dee\u6570\u5217\u524d\u7f00\u548c"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_1","text":"eobiyye\u7ed9\u4e86\u4f60\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u5e8f\u5217ai\uff0c\u5e8f\u5217\u4e2d\u6bcf\u4e2a\u5143\u7d20\u7684\u521d\u59cb\u503c\u4e3a0\u3002 \u63a5\u4e0b\u6765\u5979\u4f1a\u5bf9\u8fd9\u4e2a\u5e8f\u5217\u8fdb\u884cm\u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u64cd\u4f5c\u67094\u4e2a\u53c2\u6570l,r,s,e\uff0c\u8868\u793a\u5c06\u533a\u95f4[l,r]\u52a0\u4e0a\u4e00\u4e2a\u9996\u9879\u4e3as\uff0c\u672b\u9879\u4e3ae\u7684\u7b49\u5dee\u6570\u5217\u3002 \u82e5\u4e00\u6b21\u64cd\u4f5c\u4e2dl=1,r=5,s=2,e=10\uff0c\u5219\u5bf9\u5e8f\u5217\u4e2d\u7b2c1~5\u4e2a\u6570\u5206\u522b\u52a0\u4e0a2,4,6,8,10\u3002 \u73b0\u5728Geobiyye\u8981\u6c42\u4f60\u6c42\u51fam\u6b21\u64cd\u4f5c\u540e\u5e8f\u5217\u4e2d\u7684\u6bcf\u4e2a\u6570\u7684\u503c\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_2","text":"\u7b2c\u4e00\u884c2\u4e2a\u6574\u6570n,m\uff0c\u8868\u793a\u5e8f\u5217\u957f\u5ea6\u548c\u64cd\u4f5c\u6570\u3002 \u63a5\u4e0b\u6765m\u884c\uff0c\u6bcf\u884c4\u4e2a\u6574\u6570l,r,s,e\uff0c\u542b\u4e49\u89c1\u9898\u76ee\u63cf\u8ff0\u3002 \u6570\u636e\u4fdd\u8bc1\u7b49\u5dee\u6570\u5217\u4e2d\u7684\u6bcf\u4e00\u9879\u90fd\u662f\u6574\u6570\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_3","text":"\u7531\u4e8e\u8f93\u51fa\u6570\u636e\u8fc7\u5927\uff0cGeobiyye\u53ea\u60f3\u8981\u77e5\u9053\u6700\u7ec8\u5e8f\u5217\u6bcf\u4e00\u9879\u7684\u5f02\u6216\u548c\uff0c\u5373\u3002\uff08\u5176\u4e2d\u8868\u793a\u4e8c\u8fdb\u5236\u4e0b\u7684\u5f02\u6216\u64cd\u4f5c\uff0c\u5728c++\u4e2d\u4e3a^\uff09","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_4","text":"5 2 1 5 2 10 2 4 1 1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_5","text":"3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_6","text":"\u7b2c\u4e00\u6b21\u64cd\u4f5c\u52a0\u7684\u6570\u5217\uff1a2 4 6 8 10 \u7b2c\u4e8c\u6b21\u64cd\u4f5c\u52a0\u7684\u6570\u5217\uff1a0 1 1 1 0 \u6240\u6709\u64cd\u4f5c\u7ed3\u675f\u540e\u5e8f\u5217\u6bcf\u4e2a\u5143\u7d20\u503c\u4e3a\uff1a2 5 7 9 10\u3002 \u8f93\u51fa\u5f02\u6216\u548c\uff0c\u5c31\u662f3\u3002 \u3010\u6570\u636e\u8303\u56f4\u3011 \u5bf9\u4e8e30%\u7684\u6570\u636e\uff1an,m\u22641000 \u3002 \u5bf9\u4e8e50%\u7684\u6570\u636e\uff1an,m\u2264100000\u3002 \u5bf9\u4e8e\u53e6\u591620%\u7684\u6570\u636e\uff1as=e\u3002 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff1an,m\u2264500000,1\u2264l\uff1cr\u2264n\u3002 \u6570\u636e\u4fdd\u8bc1\u8f93\u5165\u6570\u636e\u4ee5\u53ca\u5728\u4efb\u4f55\u65f6\u5019\u5e8f\u5217\u4e2d\u7684\u6570\u5728[0,9\u00d71018]\u8303\u56f4\u5185\u3002 \u7b49\u5dee\u6570\u5217\u7684\u524d\u7f00\u548c #include <bits/stdc++.h> using namespace std ; const long long int N = 1e7 + 500 ; long long int out [ N ] = { 0 }; int main () { std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( 0 ); register long long int n , m , l , r , ks , e1 , dc , tmp = 0 ; register long long int max1 = 0 , ans = 0 ; cin >> n >> m ; register long long int i ; for ( i = 1 ; i <= m ; i ++ ) { cin >> l >> r >> ks >> e1 ; dc = ( e1 - ks ) / ( r - l ); out [ l ] = out [ l ] + ks ; out [ l + 1 ] = out [ l + 1 ] + dc - ks ; out [ r + 1 ] = out [ r + 1 ] - dc - e1 ; out [ r + 2 ] = out [ r + 2 ] + e1 ; } for ( i = 1 ; i <= n ; i ++ ) { out [ i ] = out [ i -1 ] + out [ i ]; tmp += out [ i ]; ans = ans ^ tmp ; } cout << ans << endl ; return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2535&pid=5","title":"\u6837\u4f8b\u89e3\u91ca\uff1a"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_7","text":"\u8bf7\u5f00 long long\u3002 \u8001\u7239\u8bf4\u8981\u7528\u9b54\u6cd5\u6253\u8d25\u9b54\u6cd5 \u2014\u2014\u2014\u2014 3edc2wsx1qaz \u4e00\u5929\uff0c\u5de8\u795e 3edc2wsx1qaz \u6b63\u5728\u68ee\u6797\u91cc\u6f2b\u6b65\uff0c\u7a81\u7136\uff0c\u4e00\u53ea\u51f6\u6076\u7684\u53cc\u5934\u5de8\u4eba\u62e6\u4f4f\u4e86\u4ed6\u3002 \u53cc\u5934\u5de8\u4eba\u7684\u4e24\u4e2a\u5934\u7684\u653b\u51fb\u529b\u5206\u522b\u4e3aa,b\u3002\u5b83\u6bcf\u6b21\u53ef\u4ee5\u5bf9 3edc2wsx1qaz \u9020\u6210 |a-b| \u7684\u9b54\u6cd5\u4f24\u5bb3\u3002 3edc2wsx1qaz \u89c9\u5f97\u8fd9\u53ea\u602a\u7269\u5341\u5206\u96be\u7f20\u3002 \u201c\u8981\u7528\u9b54\u6cd5\u6253\u8d25\u9b54\u6cd5\uff01\u201d \u5c31\u5728\u8fd9\u65f6\uff0c\u8001\u7239\u7684\u8bdd\u56de\u54cd\u5728 3edc2wsx1qaz \u7684\u8033\u8fb9\uff0c3edc2wsx1qaz \u987f\u65f6\u611f\u5230\u4e00\u80a1\u529b\u91cf\u6d8c\u4e0a\u5fc3\u5934\uff0c\u4e8e\u662f\uff0c\u4ed6\u51b3\u5b9a\u4ece\u5b83\u7684\u7279\u6b8a\u80fd\u529b\u4e0b\u624b\uff0c\u4ece\u800c\u6253\u8d25\u5b83\u3002 998244353\u5e74\u524d\uff0c\u5de8\u795e Rainy7 \u66fe\u7ecf\u6559\u8fc7\u4ed6\u540d\u4e3a \u722a\u5df4 \u7684 % \u6cd5\uff0c\u4ed6\u51b3\u5b9a\u7528\u8fd9\u79cd % \u6cd5\u51fb\u8d25\u5de8\u4eba\u3002 3edc2wsx1qaz \u53ef\u4ee5\u4f7f\u7528\u65e0\u9650\u6b21\u6cd5\u672f\uff0c\u7b2ci\u6b21\u4f7f\u7528\u53ef\u4ee5\u4efb\u9009\u4e00\u4e2a\u5934\uff0c\u4f7f\u5f97\u5b83\u7684\u653b\u51fb\u529b\u589e\u52a0\u6216\u51cf\u5c11i\u3002\uff08\u5728\u6b64\u8fc7\u7a0b\u4e2d\u653b\u51fb\u529b\u53ef\u4ee5\u662f\u8d1f\u6570\uff09 3edc2wsx1qaz \u4e0d\u60f3\u53d7\u5230\u4efb\u4f55\u4f24\u5bb3\uff0c\u6240\u4ee5\uff0c\u4ed6\u60f3\u77e5\u9053\uff0c\u4ed6\u81f3\u5c11\u8981\u65bd\u51e0\u6b21\u6cd5\uff0c\u624d\u80fd\u4f7f\u5f97a-b=0\u3002 3edc2wsx1qaz \u53ea\u7528\u4e86114514-1919810 s\u5c31\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u4e8e\u662f\u8ba9\u60a8\u89e3\u51b3\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_8","text":"\u7b2c\u4e00\u884c\u4e00\u4e2a\u6570T\uff0c\u8868\u793a\u6570\u636e\u7ec4\u6570\u3002 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff0c\u4e00\u884c\u4e24\u4e2a\u6570a,b\uff0c\u4ee3\u8868\u53cc\u5934\u5de8\u4eba\u4e24\u4e2a\u5934\u7684\u653b\u51fb\u529b\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_9","text":"\u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff0c\u4e00\u884c\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6700\u5c0f\u6b21\u6570\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_10","text":"\u3010\u6837\u4f8b1\u3011 3 1 3 11 11 30 20 \u3010\u6837\u4f8b2\u3011 1 114514 1919810","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_11","text":"\u3010\u6837\u4f8b1\u3011 3 0 4 \u3010\u6837\u4f8b2\u3011 1900","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_12","text":"\u6837\u4f8b1\u89e3\u91ca\uff1a \u5bf9\u4e8e\u6570\u636e1\uff0c\u4e00\u79cd\u64cd\u4f5c\u6d41\u7a0b\u5982\u4e0b\uff1a1+1=2,3+2=5,2+3=5 \u5bf9\u4e8e\u6570\u636e2\uff0c\u7531\u4e8e\u76f8\u7b49\uff0c\u6240\u4ee5\u7b54\u6848\u4e3a0\u3002 \u5bf9\u4e8e\u6570\u636e3\uff0c\u4e00\u79cd\u64cd\u4f5c\u6d41\u7a0b\u5982\u4e0b\uff1a20+1+2+3+4=30\u3002","title":"\u63d0\u793a"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_13","text":"\u5047\u8bbe\u53cc\u65b9\u7684\u8840\u91cf\u5206\u522b\u4e3aa\u548cb\uff08a<b\uff09\uff0c\u7531\u4e8e\u51cf\u6cd5\u76f8\u5f53\u4e8e\u5bf9\u53e6\u4e00\u4e2a\u8fdb\u884c\u52a0\u6cd5\u8fd0\u7b97\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u7528\u52a0\u6cd5\u3002\u9996\u5148\uff0c\u6211\u4eec\u5bf9a\u8fdb\u884c\u52a0\u6cd5\u76f4\u5230\u5927\u4e8e\u7b49\u4e8eb\uff0c\u5982\u679c\u7b49\u4e8eb\uff0c\u7ed3\u679c\u5c31\u662f\u8fdb\u884c\u52a0\u6cd5\u7684\u6b21\u6570\uff0c\u5982\u679c\u5927\u4e8eb\uff0c\u5219\u5206\u4e24\u79cd\u60c5\u51b5\uff0c\u5982\u679c\u8d85\u51fa\u7684\u6570\u76ee\u4e3a\u5076\u6570\uff0c\u5219\u6211\u4eec\u53ef\u4ee5\u628a\u591a\u51fa\u6765\u7684\u90e8\u5206\u9664\u4ee52\u4ecea\u51cf\u53bb\u52a0\u5230b\u4e0a\uff0c\u8fd9\u6837\u4e24\u8fb9\u5c31\u76f8\u540c\u4e86\uff0c\u5982\u679c\u4e3a\u5947\u6570\uff0c\u7ee7\u7eed\u52a0\uff0c\u76f4\u81f3\u5dee\u503c\u4e3a\u5076\u6570\u4e3a\u6b62\u3002 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int a , b ; scanf ( \"%d%d\" , & a , & b ); if ( a > b ) swap ( a , b ); int i ; for ( i = 1 ; a < b || ( a > b && ( a - b ) % 2 == 1 ); i ++ ) a += i ; cout << i -1 << endl ; } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2535&pid=6","title":"\u89e3\u6790"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_14","text":"\u8bf7\u5f00 long long\u3002 \u82e5\u4f17\u4eba\u7686\u4e27\u6c14\uff0c\u5219\u6211\u8c12\u89c1\u8c0f\u8a00\u3002\u2014\u2014\u2014\u2014 Rainy7 \u5728\u6d69\u701a\u65e0\u57a0\u7684\u5b87\u5b99\u4e2d\uff0c\u5206\u5e03\u7740\u8bb8\u8bb8\u591a\u591a\u7684\u6587\u660e\uff0c\u5b83\u4eec\u4e4b\u95f4\u7ecf\u5e38\u8d77\u51b2\u7a81\u3002 \u4e00\u6b21\uff0c\u4e00\u4e2a\u6587\u660e\u6d3e\u51fa\u5927\u6279\u661f\u8230\u8fdb\u653b\u5730\u7403\uff0c\u5730\u7403\u4eba\u88ab\u6253\u5f97\u843d\u8352\u800c\u9003\u3002 \u6b64\u65f6\u5728\u5730\u7403\u4e0a\uff0c\u5de8\u795e Rainy7 \u5929\u5929\u540a\u6253\u96c6\u8bad\u961f\uff0c\u5df2\u7ecf\u611f\u5230\u538c\u70e6\u4e86\uff0c\u4e8e\u662f\uff0cRainy7 \u4fbf\u53bb\u540a\u6253\u5916\u661f\u4eba\u4e86\u3002 Rainy7 \u4f7f\u7528\u9b54\u6cd5\uff0c\u5c06\u8fd9n\u8258\u661f\u8230\u5c01\u9501\u4f4f\u4e86\u3002\u7136\u800c\uff0c\u8fd9\u4e9b\u661f\u8230\u90fd\u6709\u62a4\u76fe\u4fdd\u62a4\uff0cRainy7 \u8981\u60f3\u65b9\u8bbe\u6cd5\u7834\u9664\u5b83\u4eec\u3002 \u661f\u8230\u7684\u5c01\u9501\u5173\u7cfb\u53ef\u4ee5\u770b\u6210\u4e00\u68f5\u6811\u3002\u4e00\u5f00\u59cb\uff0c Rainy7 \u53ef\u4ee5\u4efb\u9009\u4e00\u8258\u661f\u8230\uff0c\u7136\u540e\u76f4\u63a5\u89e3\u9664\u5b83\u7684\u62a4\u76fe\u3002\u7d27\u63a5\u7740\uff0cRainy7 \u53ef\u4ee5\u8fdb\u884cn\u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u9009\u62e9\u4e00\u8258\u672a\u88ab\u62a4\u76fe\u4fdd\u62a4\u7684\u661f\u8230\uff0c\u7136\u540e\u76f4\u63a5\u6467\u6bc1\u5b83\uff0c\u5e76\u4e14\u83b7\u5f97\u5b83\u88ab\u6467\u6bc1\u524d\u6240\u5728\u7684\u5168\u90fd\u662f\u672a\u88ab\u6467\u6bc1\u7684\u661f\u8230\u7684\u8fde\u901a\u5757\u7684\u5927\u5c0f\u7684\u9b54\u6cd5\u503c\u3002\u4e00\u8258\u661f\u8230\u88ab\u6467\u6bc1\u540e\uff0c\u4e0e\u5b83\u76f4\u63a5\u76f8\u8fde\u4e14\u672a\u88ab\u6467\u6bc1\u7684\u661f\u8230\u7684\u62a4\u76fe\u4f1a\u5168\u90e8\u88ab\u89e3\u9664\u3002 Rainy7 \u60f3\u77e5\u9053\uff0c\u81ea\u5df1\u6700\u591a\u80fd\u83b7\u5f97\u591a\u5c11\u9b54\u6cd5\u503c\u3002\u5979\u53ea\u7528\u4e86114514-1919810s\u5c31\u89e3\u51b3\u4e86\u95ee\u9898\uff0c\u4e8e\u662f\u628a\u95ee\u9898\u629b\u7ed9\u4e86\u60a8\u3002 \u5982\u56fe\u6240\u793a\uff0c\u52a0\u7c97\u7684\u661f\u8230\u8868\u793a\u5df2\u7ecf\u88ab\u6467\u6bc1\u3002\u82e5\u9009\u62e92\u53f7\u661f\u8230\uff0c\u5c06\u4f1a\u83b7\u5f974\u70b9\u9b54\u6cd5\u503c\uff0c\u5e76\u4e14\u89e3\u96643,5,6\u7684\u62a4\u76fe\u3002\u82e5\u9009\u62e99\u53f7\u661f\u8230\uff0c\u5c06\u4f1a\u83b7\u5f973\u70b9\u9b54\u6cd5\u503c\uff0c\u5e76\u4e14\u89e3\u96647,8\u7684\u62a4\u76fe\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_15","text":"\u7b2c\u4e00\u884c\u4e00\u4e2a\u6570n\uff0c\u8868\u793a\u661f\u8230\u6570\u91cf\u3002 \u63a5\u4e0b\u6765n-1\u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6570u,v\uff0c\u8868\u793a\u661f\u8230\u7684\u76f8\u8fde\u5173\u7cfb\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_16","text":"\u4e00\u884c\u4e00\u4e2a\u6570\uff0c\u8868\u793a\u6700\u591a\u80fd\u83b7\u5f97\u7684\u9b54\u6cd5\u503c\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_17","text":"\u3010\u6837\u4f8b1\u3011 9 1 2 2 3 2 5 2 6 1 4 4 9 9 7 9 8 \u3010\u6837\u4f8b2\u3011 5 1 2 1 3 2 4 2 5","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_18","text":"\u3010\u6837\u4f8b1\u3011 36 \u3010\u6837\u4f8b2\u3011 14","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_19","text":"","title":"\u63d0\u793a"},{"location":"csdn/2020-08-16%20%E6%A0%91%E5%BD%A2DP%2B%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%89%8D%E7%BC%80%E5%92%8C/#_20","text":"\u6811\u5f62DP\uff0c\u5148\u6c42\u51fa1\u70b9\u7684\u9b54\u6cd5\u503c\uff0c\u540e\u7ecf\u8fc7\u72b6\u6001\u8f6c\u79fb\u6c42\u51fa\u5176\u4ed6\u70b9\u7684\u9b54\u6cd5\u503c\uff0c\u6c42\u6700\u5927\u503c\u5373\u53ef\u3002 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; vector < ll > w [ 300500 ]; int vis [ 300500 ] = { 0 }; int vis1 [ 300500 ] = { 0 }; ll size1 [ 300500 ] = { 0 }; ll ans [ 300500 ] = { 0 }; ll n ; ll dfs ( ll k ) { if ( size1 [ k ] != 0 ) return size1 [ k ]; size1 [ k ] = 1 ; vis [ k ] = 1 ; for ( ll i = 0 ; i < w [ k ]. size (); i ++ ) { if ( ! vis [ w [ k ][ i ]]) { size1 [ k ] += dfs ( w [ k ][ i ]); } } return size1 [ k ]; } ll dfs1 ( ll k ) { vis1 [ k ] = 1 ; for ( ll i = 0 ; i < w [ k ]. size (); i ++ ) { if ( ! vis1 [ w [ k ][ i ]]) { ll x = w [ k ][ i ]; ans [ x ] = ans [ k ] + ( n - size1 [ x ] -1 ) - ( size1 [ x ] -1 ); dfs1 ( x ); } } } int main () { scanf ( \"%lld\" , & n ); ll x , y ; for ( ll i = 1 ; i <= n -1 ; i ++ ) { scanf ( \"%lld%lld\" , & x , & y ); w [ x ]. push_back ( y ); w [ y ]. push_back ( x ); } dfs ( 1 ); for ( ll i = 1 ; i <= n ; i ++ ) { ans [ 1 ] += size1 [ i ]; } dfs1 ( 1 ); ll max1 = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { max1 = max ( max1 , ans [ i ]); } cout << max1 << endl ; return 0 ; }","title":"\u89e3\u6790"},{"location":"csdn/2020-08-17/","text":"http://icpc.upc.edu.cn/problem.php?cid=2548&pid=2 \u9898\u76ee\u63cf\u8ff0 \u00b6 Rainy7 \u6210\u4e3a\u56fd\u738b\u540e\uff0c\u751f\u6d3b\u60a0\u95f2\u81ea\u5728\uff0c\u5979\u7ecf\u5e38\u51fa\u95e8\u6563\u6b65\uff0c\u89c2\u8d4f\u9b54\u6cd5\u738b\u56fd\u7684\u7f8e\u4e3d\u98ce\u666f\u3002 \u5979\u6563\u6b65\u7684\u5730\u65b9\u662f\u4e2a\u5145\u6ee1\u80fd\u91cf\u7684\u77e9\u5f62\uff0c\u6bcf\u4e2a\u65b9\u683c\u91cc\u90fd\u957f\u6ee1\u4e86\u80fd\u91cf\u82b1\u548c\u80fd\u91cf\u8349\u3002 \u82b3\u8349\u9c9c\u7f8e\uff0c\u843d\u82f1\u7f24\u7eb7\u3002Rainy7\u751a\u5f02\u4e4b\uff0c\u590d\u524d\u884c\uff0c\u6b32\u7a77\u5176\u77e9\u5f62\u3002 Rainy7 \u6563\u6b65\u65f6\uff0c\u4f1a\u6cbf\u77e9\u5f62\u5bf9\u89d2\u7ebf\u4ece\u5de6\u4e0a\u89d2\u8d70\u5230\u53f3\u4e0b\u89d2\uff0c\u5979\u80fd\u89c2\u8d4f\u5230\u6240\u6709\u5979\u7ecf\u8fc7\u7684\u683c\u5b50\uff08\u4e0d\u5305\u62ec\u683c\u70b9\uff09\u4e2d\u7684\u80fd\u91cf\u82b1\u548c\u80fd\u91cf\u8349\u3002\u5979\u5e0c\u671b\u81ea\u5df1\u80fd\u89c2\u8d4f\u5230Q\u4e2a\u683c\u5b50\u91cc\u7684\u80fd\u91cf\u82b1\u548c\u80fd\u91cf\u8349\u3002 Rainy7 \u547d\u4ee4 CaBeF_Yyx \u627e\u51fa\u6240\u6709\u80fd\u6ee1\u8db3\u5979\u7684\u8981\u6c42\u7684\u77e9\u5f62\uff0c\u5426\u5219\u5979\u8981\u7528\u780d\u5934\u672f\u5c06 CaBeF_Yyx \u7684\u5934\u780d\u4e0b\u6765\u3002 \u4e3a\u4e86\u4e0d\u88ab\u780d\u5934\uff0cCaBef_Yyx \u5f88\u5feb\u5730\u60f3\u51fa\u4e86\u505a\u6cd5\uff0c\u5e76\u628a\u8fd9\u9898\u6254\u7ed9\u4e86\u4f60\u3002 Rainy7 \u53c8\u7a81\u53d1\u5947\u60f3\uff0c\u7528\u4e86\u4e00\u4e2a\u795e\u5947\u7684\u6cd5\u672f\uff0c\u5c06\u77e9\u5f62\u53d8\u4e3a\u4e86\u534a\u5f84\u4e3aR\u7684\u5706\u3002 \u5c06\u8be5\u5706\u7684\u5706\u5fc3\u770b\u4f5c\u4e00\u4e2a\u957f\u6ee1\u4e86\u80fd\u91cf\u82b1\u548c\u80fd\u91cf\u8349\u7684\u5e73\u9762\u76f4\u89d2\u5750\u6807\u7cfb\u4e2d\u7684\u539f\u70b9\uff0cRainy7 \u60f3\u77e5\u9053\uff0c\u6709\u591a\u5c11\u4e2a\u683c\u70b9\u843d\u5728\u5706\u4e0a \uff1f \u5979\u53c8\u5c06\u8fd9\u4e2a\u95ee\u9898\u4ea4\u7ed9 CaBeF_Yyx\u3002 \u8fd9\u6b21 CaBeF_Yyx \u88ab\u96be\u5012\u4e86\uff0c\u5979\u4e0d\u77e5\u9053\u8be5\u5982\u4f55\u89e3\u51b3\uff0c\u4e8e\u662f\u5c06\u8fd9\u4e2a\u95ee\u9898\u6254\u7ed9\u4e86\u4f60\u3002 \u6240\u4ee5\u4f60\u4e00\u5171\u8981\u89e3\u51b3\u4e24\u4e2a\u95ee\u9898\uff0c\u624d\u80fd\u4fdd\u8bc1 CaBeF_Yyx \u4e0d\u88ab Rainy7 \u780d\u5934\u3002 \u4e3a\u4e86\u62ef\u6551 CaBeF_Yyx \uff0c\u8bf7\u4f60\u65e0\u8bba\u5982\u4f55\u4e5f\u8981\u505a\u51fa\u6765\u3002 \u6709\u591a\u7ec4\u6570\u636e\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\uff0c\u4e00\u4e2a\u6574\u6570T \uff0c\u8868\u793a\u8be2\u95ee\u6b21\u6570\u3002 \u63a5\u4e0b\u6765T\u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6574\u6570Q,R \uff0c\u610f\u4e49\u5982\u9898\u3002 \u8f93\u51fa \u00b6 T \u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6bcf\u6b21\u8be2\u95ee\u7684\u7b54\u6848\uff0c\u7b2c\u4e00\u4e2a\u8868\u793a\u6ee1\u8db3\u6761\u4ef6\u77e9\u9635\u7684\u6570\u91cf\uff0c\u7b2c\u4e8c\u4e2a\u8868\u793a\u5706\u4e0a\u683c\u70b9\u6570\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 1 4 4 \u6837\u4f8b\u8f93\u51fa \u00b6 4 4 \u63d0\u793a \u00b6 \u5bf9\u4e8e\u5168\u90e8\u6570\u636e\uff0c1\u2264T\u226410,1\u2264Q\u2264107,1\u2264R\u22642\u00d7109 \u957f\u548c\u5bbd\u5206\u522b\u4e3aX\uff0cY\u7684\u77e9\u5f62\u4e0e\u957f\u548c\u5bbd\u5206\u522b\u4e3aY,X\u7684\u77e9\u5f62\u662f\u540c\u4e00\u4e2a\u77e9\u5f62\u3002 \u89e3\u6790 \u00b6 \u53c2\u7167\u535a\u5ba2\uff1a https://blog.csdn.net/qq_30205523/article/details/100528069 https://blog.csdn.net/clover_hxy/article/details/72955869 \u6c42\u7b2c\u4e00\u4e2a\u6570\uff0cm*n\u7684\u77e9\u5f62\u5bf9\u89d2\u7ebf\u8fc7\u65b9\u683c\u7684\u6570\u76ee\u4e3am+n-gcd(m,n) \u5219\u53ef\u5217\u5f97\u65b9\u7a0b\uff0cm+n-gcd(m,n)=k\uff0c\u63d0\u53d6\u56e0\u5f0fgcd(m,n)\u8bb0\u4e3ag\uff0c\u5219\u539f\u5f0f\u53d8\u4e3am/g+n/g-1=k/g\uff0c\u5219m/g\u548cn/g\u4e00\u5b9a\u4e92\u8d28\u4e14\u548c\u4e3a1+k/g\uff0c\u6b64\u65f6g\u4e00\u5b9a\u4e3ak\u7684\u7ea6\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u679a\u4e3ek\u7684\u7ea6\u6570\uff0c\u7136\u540e\u6839\u636em/g\u548cn/g\u4e92\u8d28\uff0c\u5219gcd(m/g,n/g)=1\uff0c\u7531gcd\u7684\u6027\u8d28\uff0c\u5219gcd(m/g,m/g+n/g)=1\uff0c\u5373\u4e3agcd(m/g,k/g+1)=1\uff0c\u4e92\u8d28\uff0c\u6b27\u62c9\u51fd\u6570\u6c42\u51fa\u6570\u76ee\u6c42\u548c\u5373\u53ef\u3002 \u7b2c\u4e8c\u4e2a\u6570\u7684\u6c42\u89e3\u89c1\u7b2c\u4e8c\u7bc7\u535a\u5ba2\u3002 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll n = 1e7 + 50 ; ll pr [ 10005007 ] = { 0 }, ph [ 10005007 ] = { 0 }; bool vis [ 10005007 ] = { 0 }; ll R , ans = 0 , S , sum = 1 , x , cnt = 0 ; ll gcd ( ll a , ll b ) { return b == 0 ? a : gcd ( b , a % b ); } void fun ( ll d ) { ll v ; for ( ll u = 1 ; u <= ( ll ) sqrt ( 1.0 * 2 * R / d ); u ++ ) { v = ( ll ) sqrt ( 1.0 * 2 * R / d - u * u * 1.0 ); if ( gcd ( v , u ) == 1 && u <= v && d * ( u * u + v * v ) == 2 * R ) ans ++ ; } } int main () { ph [ 1 ] = 1 ; for ( register ll i = 2 ; i <= n -1 ; ++ i ) { if ( ! vis [ i ]) { cnt ++ ; pr [ cnt ] = i ; ph [ i ] = i - 1 ; } for ( register ll j = 1 ; j <= cnt && i * pr [ j ] <= n -1 ; ++ j ) //\u6b27\u62c9\u7b5b\u6cd5 { vis [ i * pr [ j ] ] = 1 ; if ( i % pr [ j ] == 0 ) { ph [ pr [ j ] * i ] = ph [ i ] * pr [ j ] ; break ; } else ph [ pr [ j ] * i ] = ph [ i ] * ( pr [ j ] - 1 ); } } register ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ans = 0 , sum = 1 ; scanf ( \"%lld\" , & S ); for ( register ll i = 1 ; i <= sqrt ( S ); i ++ ) { if ( S % i == 0 ) { sum += ph [ S / i + 1 ]; if ( i * i != S ) sum += ph [ i + 1 ]; } } sum /= 2 ; scanf ( \"%lld\" , & R ); for ( register ll i = 1 ; i <= ( ll ) sqrt ( 1.0 * R * 2 ); i ++ ) { if ( 2 * R % i == 0 ) { if (( ll ) i * i != 2 * R ) { fun ( 2 * R / i ); fun ( i ); } else fun ( i ); } } ans *= 4 ; printf ( \"%lld %lld \\n \" , sum , ans ); } return 0 ; }","title":"2020-08-17"},{"location":"csdn/2020-08-17/#_1","text":"Rainy7 \u6210\u4e3a\u56fd\u738b\u540e\uff0c\u751f\u6d3b\u60a0\u95f2\u81ea\u5728\uff0c\u5979\u7ecf\u5e38\u51fa\u95e8\u6563\u6b65\uff0c\u89c2\u8d4f\u9b54\u6cd5\u738b\u56fd\u7684\u7f8e\u4e3d\u98ce\u666f\u3002 \u5979\u6563\u6b65\u7684\u5730\u65b9\u662f\u4e2a\u5145\u6ee1\u80fd\u91cf\u7684\u77e9\u5f62\uff0c\u6bcf\u4e2a\u65b9\u683c\u91cc\u90fd\u957f\u6ee1\u4e86\u80fd\u91cf\u82b1\u548c\u80fd\u91cf\u8349\u3002 \u82b3\u8349\u9c9c\u7f8e\uff0c\u843d\u82f1\u7f24\u7eb7\u3002Rainy7\u751a\u5f02\u4e4b\uff0c\u590d\u524d\u884c\uff0c\u6b32\u7a77\u5176\u77e9\u5f62\u3002 Rainy7 \u6563\u6b65\u65f6\uff0c\u4f1a\u6cbf\u77e9\u5f62\u5bf9\u89d2\u7ebf\u4ece\u5de6\u4e0a\u89d2\u8d70\u5230\u53f3\u4e0b\u89d2\uff0c\u5979\u80fd\u89c2\u8d4f\u5230\u6240\u6709\u5979\u7ecf\u8fc7\u7684\u683c\u5b50\uff08\u4e0d\u5305\u62ec\u683c\u70b9\uff09\u4e2d\u7684\u80fd\u91cf\u82b1\u548c\u80fd\u91cf\u8349\u3002\u5979\u5e0c\u671b\u81ea\u5df1\u80fd\u89c2\u8d4f\u5230Q\u4e2a\u683c\u5b50\u91cc\u7684\u80fd\u91cf\u82b1\u548c\u80fd\u91cf\u8349\u3002 Rainy7 \u547d\u4ee4 CaBeF_Yyx \u627e\u51fa\u6240\u6709\u80fd\u6ee1\u8db3\u5979\u7684\u8981\u6c42\u7684\u77e9\u5f62\uff0c\u5426\u5219\u5979\u8981\u7528\u780d\u5934\u672f\u5c06 CaBeF_Yyx \u7684\u5934\u780d\u4e0b\u6765\u3002 \u4e3a\u4e86\u4e0d\u88ab\u780d\u5934\uff0cCaBef_Yyx \u5f88\u5feb\u5730\u60f3\u51fa\u4e86\u505a\u6cd5\uff0c\u5e76\u628a\u8fd9\u9898\u6254\u7ed9\u4e86\u4f60\u3002 Rainy7 \u53c8\u7a81\u53d1\u5947\u60f3\uff0c\u7528\u4e86\u4e00\u4e2a\u795e\u5947\u7684\u6cd5\u672f\uff0c\u5c06\u77e9\u5f62\u53d8\u4e3a\u4e86\u534a\u5f84\u4e3aR\u7684\u5706\u3002 \u5c06\u8be5\u5706\u7684\u5706\u5fc3\u770b\u4f5c\u4e00\u4e2a\u957f\u6ee1\u4e86\u80fd\u91cf\u82b1\u548c\u80fd\u91cf\u8349\u7684\u5e73\u9762\u76f4\u89d2\u5750\u6807\u7cfb\u4e2d\u7684\u539f\u70b9\uff0cRainy7 \u60f3\u77e5\u9053\uff0c\u6709\u591a\u5c11\u4e2a\u683c\u70b9\u843d\u5728\u5706\u4e0a \uff1f \u5979\u53c8\u5c06\u8fd9\u4e2a\u95ee\u9898\u4ea4\u7ed9 CaBeF_Yyx\u3002 \u8fd9\u6b21 CaBeF_Yyx \u88ab\u96be\u5012\u4e86\uff0c\u5979\u4e0d\u77e5\u9053\u8be5\u5982\u4f55\u89e3\u51b3\uff0c\u4e8e\u662f\u5c06\u8fd9\u4e2a\u95ee\u9898\u6254\u7ed9\u4e86\u4f60\u3002 \u6240\u4ee5\u4f60\u4e00\u5171\u8981\u89e3\u51b3\u4e24\u4e2a\u95ee\u9898\uff0c\u624d\u80fd\u4fdd\u8bc1 CaBeF_Yyx \u4e0d\u88ab Rainy7 \u780d\u5934\u3002 \u4e3a\u4e86\u62ef\u6551 CaBeF_Yyx \uff0c\u8bf7\u4f60\u65e0\u8bba\u5982\u4f55\u4e5f\u8981\u505a\u51fa\u6765\u3002 \u6709\u591a\u7ec4\u6570\u636e\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-17/#_2","text":"\u7b2c\u4e00\u884c\uff0c\u4e00\u4e2a\u6574\u6570T \uff0c\u8868\u793a\u8be2\u95ee\u6b21\u6570\u3002 \u63a5\u4e0b\u6765T\u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6574\u6570Q,R \uff0c\u610f\u4e49\u5982\u9898\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-17/#_3","text":"T \u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6bcf\u6b21\u8be2\u95ee\u7684\u7b54\u6848\uff0c\u7b2c\u4e00\u4e2a\u8868\u793a\u6ee1\u8db3\u6761\u4ef6\u77e9\u9635\u7684\u6570\u91cf\uff0c\u7b2c\u4e8c\u4e2a\u8868\u793a\u5706\u4e0a\u683c\u70b9\u6570\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-17/#_4","text":"1 4 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-17/#_5","text":"4 4","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-17/#_6","text":"\u5bf9\u4e8e\u5168\u90e8\u6570\u636e\uff0c1\u2264T\u226410,1\u2264Q\u2264107,1\u2264R\u22642\u00d7109 \u957f\u548c\u5bbd\u5206\u522b\u4e3aX\uff0cY\u7684\u77e9\u5f62\u4e0e\u957f\u548c\u5bbd\u5206\u522b\u4e3aY,X\u7684\u77e9\u5f62\u662f\u540c\u4e00\u4e2a\u77e9\u5f62\u3002","title":"\u63d0\u793a"},{"location":"csdn/2020-08-17/#_7","text":"\u53c2\u7167\u535a\u5ba2\uff1a https://blog.csdn.net/qq_30205523/article/details/100528069 https://blog.csdn.net/clover_hxy/article/details/72955869 \u6c42\u7b2c\u4e00\u4e2a\u6570\uff0cm*n\u7684\u77e9\u5f62\u5bf9\u89d2\u7ebf\u8fc7\u65b9\u683c\u7684\u6570\u76ee\u4e3am+n-gcd(m,n) \u5219\u53ef\u5217\u5f97\u65b9\u7a0b\uff0cm+n-gcd(m,n)=k\uff0c\u63d0\u53d6\u56e0\u5f0fgcd(m,n)\u8bb0\u4e3ag\uff0c\u5219\u539f\u5f0f\u53d8\u4e3am/g+n/g-1=k/g\uff0c\u5219m/g\u548cn/g\u4e00\u5b9a\u4e92\u8d28\u4e14\u548c\u4e3a1+k/g\uff0c\u6b64\u65f6g\u4e00\u5b9a\u4e3ak\u7684\u7ea6\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u679a\u4e3ek\u7684\u7ea6\u6570\uff0c\u7136\u540e\u6839\u636em/g\u548cn/g\u4e92\u8d28\uff0c\u5219gcd(m/g,n/g)=1\uff0c\u7531gcd\u7684\u6027\u8d28\uff0c\u5219gcd(m/g,m/g+n/g)=1\uff0c\u5373\u4e3agcd(m/g,k/g+1)=1\uff0c\u4e92\u8d28\uff0c\u6b27\u62c9\u51fd\u6570\u6c42\u51fa\u6570\u76ee\u6c42\u548c\u5373\u53ef\u3002 \u7b2c\u4e8c\u4e2a\u6570\u7684\u6c42\u89e3\u89c1\u7b2c\u4e8c\u7bc7\u535a\u5ba2\u3002 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll n = 1e7 + 50 ; ll pr [ 10005007 ] = { 0 }, ph [ 10005007 ] = { 0 }; bool vis [ 10005007 ] = { 0 }; ll R , ans = 0 , S , sum = 1 , x , cnt = 0 ; ll gcd ( ll a , ll b ) { return b == 0 ? a : gcd ( b , a % b ); } void fun ( ll d ) { ll v ; for ( ll u = 1 ; u <= ( ll ) sqrt ( 1.0 * 2 * R / d ); u ++ ) { v = ( ll ) sqrt ( 1.0 * 2 * R / d - u * u * 1.0 ); if ( gcd ( v , u ) == 1 && u <= v && d * ( u * u + v * v ) == 2 * R ) ans ++ ; } } int main () { ph [ 1 ] = 1 ; for ( register ll i = 2 ; i <= n -1 ; ++ i ) { if ( ! vis [ i ]) { cnt ++ ; pr [ cnt ] = i ; ph [ i ] = i - 1 ; } for ( register ll j = 1 ; j <= cnt && i * pr [ j ] <= n -1 ; ++ j ) //\u6b27\u62c9\u7b5b\u6cd5 { vis [ i * pr [ j ] ] = 1 ; if ( i % pr [ j ] == 0 ) { ph [ pr [ j ] * i ] = ph [ i ] * pr [ j ] ; break ; } else ph [ pr [ j ] * i ] = ph [ i ] * ( pr [ j ] - 1 ); } } register ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ans = 0 , sum = 1 ; scanf ( \"%lld\" , & S ); for ( register ll i = 1 ; i <= sqrt ( S ); i ++ ) { if ( S % i == 0 ) { sum += ph [ S / i + 1 ]; if ( i * i != S ) sum += ph [ i + 1 ]; } } sum /= 2 ; scanf ( \"%lld\" , & R ); for ( register ll i = 1 ; i <= ( ll ) sqrt ( 1.0 * R * 2 ); i ++ ) { if ( 2 * R % i == 0 ) { if (( ll ) i * i != 2 * R ) { fun ( 2 * R / i ); fun ( i ); } else fun ( i ); } } ans *= 4 ; printf ( \"%lld %lld \\n \" , sum , ans ); } return 0 ; }","title":"\u89e3\u6790"},{"location":"csdn/2020-08-18/","text":"http://icpc.upc.edu.cn/problem.php?cid=2548&pid=4 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u5728\u4e00\u7247\u6816\u606f\u5730\u4e0a\u6709N\u68f5\u6811\uff0c\u6bcf\u68f5\u6811\u4e0b\u4f4f\u7740\u4e00\u53ea\u5154\u5b50\uff0c\u6709M\u6761\u8def\u5f84\u8fde\u63a5\u8fd9\u4e9b\u6811\u3002\u66f4\u7279\u6b8a\u5730\u662f\uff0c\u53ea\u6709\u4e00\u68f5\u6811\u67093\u6761\u6216\u66f4\u591a\u7684\u8def\u5f84\u4e0e\u5b83\u76f8\u8fde\uff0c\u5176\u5b83\u7684\u6811\u53ea\u67091\u6761\u62162\u6761\u8def\u5f84\u4e0e\u5176\u76f8\u8fde\u3002\u6362\u53e5\u8bdd\u8bb2\uff0c\u8fd9\u4e9b\u6811\u548c\u6811\u4e4b\u95f4\u7684\u8def\u5f84\u6784\u6210\u4e00\u5f20N\u4e2a\u70b9\u3001M\u6761\u8fb9\u7684\u65e0\u5411\u8fde\u901a\u56fe\uff0c\u800c\u5ea6\u6570\u5927\u4e8e2\u7684\u70b9\u81f3\u591a\u67091\u4e2a\u3002 \u8fd1\u5e74\u4ee5\u6765\uff0c\u6816\u606f\u5730\u9891\u7e41\u6536\u5230\u4eba\u7c7b\u7684\u4fb5\u6270\u3002\u5154\u5b50\u4eec\u8054\u5408\u8d77\u6765\u53ec\u5f00\u4e86\u4e00\u573a\u4f1a\u8bae\uff0c\u51b3\u5b9a\u5728\u5176\u4e2dK\u68f5\u6811\u4e0a\u5efa\u9020\u6811\u6d1e\u3002\u5f53\u5371\u9669\u6765\u4e34\u65f6\uff0c\u6bcf\u53ea\u5154\u5b50\u5747\u4f1a\u540c\u65f6\u524d\u5f80\u8ddd\u79bb\u5b83\u6700\u8fd1\u7684\u6811\u6d1e\u8eb2\u907f\uff0c\u8def\u7a0b\u4e2d\u82b1\u8d39\u7684\u65f6\u95f4\u5728\u6570\u503c\u4e0a\u7b49\u4e8e\u8ddd\u79bb\u3002\u4e3a\u4e86\u5728\u6700\u77ed\u7684\u65f6\u95f4\u5185\u8ba9\u6240\u6709\u5154\u5b50\u8131\u79bb\u5371\u9669\uff0c\u8bf7\u4f60\u5b89\u6392\u4e00\u79cd\u5efa\u9020\u6811\u6d1e\u7684\u65b9\u5f0f\uff0c\u4f7f\u6700\u540e\u4e00\u53ea\u5230\u8fbe\u6811\u6d1e\u7684\u5154\u5b50\u6240\u82b1\u8d39\u7684\u65f6\u95f4\u5c3d\u91cf\u5c11\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u67093\u4e2a\u6574\u6570N\uff0cM\uff0cK\uff0c\u5206\u522b\u8868\u793a\u6811\uff08\u5154\u5b50\uff09\u7684\u4e2a\u6570\u3001\u8def\u5f84\u6570\u3001\u8ba1\u5212\u5efa\u9020\u7684\u6811\u6d1e\u6570\u3002 \u63a5\u4e0b\u6765M\u884c\u6bcf\u884c\u4e09\u4e2a\u6574\u6570x,y\uff0c\u8868\u793a\u7b2cx\u68f5\u6811\u548c\u7b2cy\u68f5\u6811\u4e4b\u95f4\u6709\u4e00\u6761\u8def\u5f84\u76f8\u8fde\u30021<=x,y<=N\uff0cx\u2260y\uff0c\u4efb\u610f\u4e24\u68f5\u6811\u4e4b\u95f4\u81f3\u591a\u53ea\u67091\u6761\u8def\u5f84\u3002 \u8f93\u51fa \u00b6 \u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u5728\u6700\u4f18\u65b9\u6848\u4e0b\uff0c\u6700\u540e\u4e00\u53ea\u5230\u8fbe\u6811\u6d1e\u7684\u5154\u5b50\u6240\u82b1\u8d39\u7684\u65f6\u95f4\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 5 5 2 1 2 2 3 3 1 1 4 4 5 \u6837\u4f8b\u8f93\u51fa \u00b6 1 \u63d0\u793a \u00b6 \u5bf9\u4e8e20%\u7684\u6570\u636e\uff0c1\u2009\u2264\u2009 n\u2009\u2264\u200910\u3002 \u5bf9\u4e8e\u53e6\u591630%\u7684\u6570\u636e\uff0c\u6bcf\u68f5\u6811\u81f3\u591a\u4e0e2\u6761\u8def\u5f84\u76f8\u8fde\u3002 \u5bf9\u4e8e\u53e6\u591630%\u7684\u6570\u636e\uff0c\u4fdd\u8bc1\u5b58\u5728\u4e00\u79cd\u6700\u4f18\u89e3\uff0c\u4f7f\u4e0e3\u6761\u6216\u66f4\u591a\u8def\u5f84\u76f8\u8fde\u7684\u6811\u4e0a\u4e00\u5b9a\u5efa\u9020\u4e86\u6811\u6d1e\u3002 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c1\u2009\u2264\u2009n\u2009\u2264\u20092000\uff0cn-1<=m<=n*(n-1)/2\u3002 \u89e3\u6790 \u00b6 \u56fe\u8bba+\u4e8c\u5206\u67e5\u627e \u6ce8\uff1a\u672c\u9898\u7f3a\u4e4f\u6d4b\u8bd5\u7528\u4f8b\uff0c\u53ef\u80fd\u4f1a\u6709bug\uff0c\u5efa\u8bae\u53c2\u7167\u535a\u5ba2\uff1a https://www.cnblogs.com/Shawn7xc/p/7771441.html https://www.cnblogs.com/candy99/p/6003565.html #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int to ; int next ; }; int n , m , x , y , k ; int head [ 100500 ] = { 0 }; int vis [ 100500 ] = { 0 }; int first [ 100500 ] = { 0 }; int e [ 100500 ] = { 0 }; node a [ 100500 ] = { 0 }; int root = 0 ; int cnt = 0 ; int deep = 0 ; int dfs ( int n , int len ) { deep += 1 ; vis [ n ] = 1 ; if ( len == 0 ) return 0 ; for ( int i = head [ n ]; i ; i = a [ i ]. next ) { int w = a [ i ]. to ; if ( ! vis [ w ]) { dfs ( w , len -1 ); } } } int add ( int x , int y ) { a [ ++ cnt ]. to = y ; a [ cnt ]. next = head [ x ]; head [ x ] = cnt ; } int check ( int x ) { memset ( vis , 0 , sizeof ( vis )); dfs ( root , x ); memcpy ( first , vis , sizeof ( vis )); for ( int i = 1 ; i <= n ; i ++ ) { if ( first [ i ]) { int out = 1 ; memset ( vis , 0 , sizeof ( vis )); dfs ( i , x ); for ( int j = 1 ; j <= n ; j ++ ) { if ( ! vis [ j ]) { deep = 0 ; dfs ( j , n ); out += ( deep + 2 * x ) / ( 2 * x + 1 ); } } if ( out <= k ) return 1 ; } } return 0 ; } int main () { scanf ( \"%d%d%%d\" , & n , & m , & k ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & x , & y ); add ( x , y ); add ( y , x ); e [ x ] ++ ; e [ y ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( e [ i ] > 2 ) { root = i ; break ; } } if ( ! root ) { cout << ( n + k -1 ) / k / 2 << endl ; exit ( 0 ); } int l = 1 , r = n + 1 ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( check ( mid )) { l = mid + 1 ; } else { r = mid ; } } cout << l << endl ; return 0 ; }","title":"2020-08-18"},{"location":"csdn/2020-08-18/#_1","text":"\u5728\u4e00\u7247\u6816\u606f\u5730\u4e0a\u6709N\u68f5\u6811\uff0c\u6bcf\u68f5\u6811\u4e0b\u4f4f\u7740\u4e00\u53ea\u5154\u5b50\uff0c\u6709M\u6761\u8def\u5f84\u8fde\u63a5\u8fd9\u4e9b\u6811\u3002\u66f4\u7279\u6b8a\u5730\u662f\uff0c\u53ea\u6709\u4e00\u68f5\u6811\u67093\u6761\u6216\u66f4\u591a\u7684\u8def\u5f84\u4e0e\u5b83\u76f8\u8fde\uff0c\u5176\u5b83\u7684\u6811\u53ea\u67091\u6761\u62162\u6761\u8def\u5f84\u4e0e\u5176\u76f8\u8fde\u3002\u6362\u53e5\u8bdd\u8bb2\uff0c\u8fd9\u4e9b\u6811\u548c\u6811\u4e4b\u95f4\u7684\u8def\u5f84\u6784\u6210\u4e00\u5f20N\u4e2a\u70b9\u3001M\u6761\u8fb9\u7684\u65e0\u5411\u8fde\u901a\u56fe\uff0c\u800c\u5ea6\u6570\u5927\u4e8e2\u7684\u70b9\u81f3\u591a\u67091\u4e2a\u3002 \u8fd1\u5e74\u4ee5\u6765\uff0c\u6816\u606f\u5730\u9891\u7e41\u6536\u5230\u4eba\u7c7b\u7684\u4fb5\u6270\u3002\u5154\u5b50\u4eec\u8054\u5408\u8d77\u6765\u53ec\u5f00\u4e86\u4e00\u573a\u4f1a\u8bae\uff0c\u51b3\u5b9a\u5728\u5176\u4e2dK\u68f5\u6811\u4e0a\u5efa\u9020\u6811\u6d1e\u3002\u5f53\u5371\u9669\u6765\u4e34\u65f6\uff0c\u6bcf\u53ea\u5154\u5b50\u5747\u4f1a\u540c\u65f6\u524d\u5f80\u8ddd\u79bb\u5b83\u6700\u8fd1\u7684\u6811\u6d1e\u8eb2\u907f\uff0c\u8def\u7a0b\u4e2d\u82b1\u8d39\u7684\u65f6\u95f4\u5728\u6570\u503c\u4e0a\u7b49\u4e8e\u8ddd\u79bb\u3002\u4e3a\u4e86\u5728\u6700\u77ed\u7684\u65f6\u95f4\u5185\u8ba9\u6240\u6709\u5154\u5b50\u8131\u79bb\u5371\u9669\uff0c\u8bf7\u4f60\u5b89\u6392\u4e00\u79cd\u5efa\u9020\u6811\u6d1e\u7684\u65b9\u5f0f\uff0c\u4f7f\u6700\u540e\u4e00\u53ea\u5230\u8fbe\u6811\u6d1e\u7684\u5154\u5b50\u6240\u82b1\u8d39\u7684\u65f6\u95f4\u5c3d\u91cf\u5c11\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-18/#_2","text":"\u7b2c\u4e00\u884c\u67093\u4e2a\u6574\u6570N\uff0cM\uff0cK\uff0c\u5206\u522b\u8868\u793a\u6811\uff08\u5154\u5b50\uff09\u7684\u4e2a\u6570\u3001\u8def\u5f84\u6570\u3001\u8ba1\u5212\u5efa\u9020\u7684\u6811\u6d1e\u6570\u3002 \u63a5\u4e0b\u6765M\u884c\u6bcf\u884c\u4e09\u4e2a\u6574\u6570x,y\uff0c\u8868\u793a\u7b2cx\u68f5\u6811\u548c\u7b2cy\u68f5\u6811\u4e4b\u95f4\u6709\u4e00\u6761\u8def\u5f84\u76f8\u8fde\u30021<=x,y<=N\uff0cx\u2260y\uff0c\u4efb\u610f\u4e24\u68f5\u6811\u4e4b\u95f4\u81f3\u591a\u53ea\u67091\u6761\u8def\u5f84\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-18/#_3","text":"\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u5728\u6700\u4f18\u65b9\u6848\u4e0b\uff0c\u6700\u540e\u4e00\u53ea\u5230\u8fbe\u6811\u6d1e\u7684\u5154\u5b50\u6240\u82b1\u8d39\u7684\u65f6\u95f4\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-18/#_4","text":"5 5 2 1 2 2 3 3 1 1 4 4 5","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-18/#_5","text":"1","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-18/#_6","text":"\u5bf9\u4e8e20%\u7684\u6570\u636e\uff0c1\u2009\u2264\u2009 n\u2009\u2264\u200910\u3002 \u5bf9\u4e8e\u53e6\u591630%\u7684\u6570\u636e\uff0c\u6bcf\u68f5\u6811\u81f3\u591a\u4e0e2\u6761\u8def\u5f84\u76f8\u8fde\u3002 \u5bf9\u4e8e\u53e6\u591630%\u7684\u6570\u636e\uff0c\u4fdd\u8bc1\u5b58\u5728\u4e00\u79cd\u6700\u4f18\u89e3\uff0c\u4f7f\u4e0e3\u6761\u6216\u66f4\u591a\u8def\u5f84\u76f8\u8fde\u7684\u6811\u4e0a\u4e00\u5b9a\u5efa\u9020\u4e86\u6811\u6d1e\u3002 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c1\u2009\u2264\u2009n\u2009\u2264\u20092000\uff0cn-1<=m<=n*(n-1)/2\u3002","title":"\u63d0\u793a"},{"location":"csdn/2020-08-18/#_7","text":"\u56fe\u8bba+\u4e8c\u5206\u67e5\u627e \u6ce8\uff1a\u672c\u9898\u7f3a\u4e4f\u6d4b\u8bd5\u7528\u4f8b\uff0c\u53ef\u80fd\u4f1a\u6709bug\uff0c\u5efa\u8bae\u53c2\u7167\u535a\u5ba2\uff1a https://www.cnblogs.com/Shawn7xc/p/7771441.html https://www.cnblogs.com/candy99/p/6003565.html #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int to ; int next ; }; int n , m , x , y , k ; int head [ 100500 ] = { 0 }; int vis [ 100500 ] = { 0 }; int first [ 100500 ] = { 0 }; int e [ 100500 ] = { 0 }; node a [ 100500 ] = { 0 }; int root = 0 ; int cnt = 0 ; int deep = 0 ; int dfs ( int n , int len ) { deep += 1 ; vis [ n ] = 1 ; if ( len == 0 ) return 0 ; for ( int i = head [ n ]; i ; i = a [ i ]. next ) { int w = a [ i ]. to ; if ( ! vis [ w ]) { dfs ( w , len -1 ); } } } int add ( int x , int y ) { a [ ++ cnt ]. to = y ; a [ cnt ]. next = head [ x ]; head [ x ] = cnt ; } int check ( int x ) { memset ( vis , 0 , sizeof ( vis )); dfs ( root , x ); memcpy ( first , vis , sizeof ( vis )); for ( int i = 1 ; i <= n ; i ++ ) { if ( first [ i ]) { int out = 1 ; memset ( vis , 0 , sizeof ( vis )); dfs ( i , x ); for ( int j = 1 ; j <= n ; j ++ ) { if ( ! vis [ j ]) { deep = 0 ; dfs ( j , n ); out += ( deep + 2 * x ) / ( 2 * x + 1 ); } } if ( out <= k ) return 1 ; } } return 0 ; } int main () { scanf ( \"%d%d%%d\" , & n , & m , & k ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & x , & y ); add ( x , y ); add ( y , x ); e [ x ] ++ ; e [ y ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( e [ i ] > 2 ) { root = i ; break ; } } if ( ! root ) { cout << ( n + k -1 ) / k / 2 << endl ; exit ( 0 ); } int l = 1 , r = n + 1 ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( check ( mid )) { l = mid + 1 ; } else { r = mid ; } } cout << l << endl ; return 0 ; }","title":"\u89e3\u6790"},{"location":"csdn/2020-08-19/","text":"http://icpc.upc.edu.cn/problem.php?cid=2550&pid=6 \u9898\u76ee\u63cf\u8ff0 \u00b6 Rainy7 \u4e00\u5929\u9192\u6765\uff0c\u53d1\u73b0\u81ea\u5df1\u8fdb\u5165\u4e86\u9b54\u6cd5\u4e16\u754c\u3002 \u4e00\u9053\u5927\u95e8\u77d7\u7acb\u5728 Rainy7 \u9762\u524d\uff0c\u4f3c\u4e4e\u9700\u8981\u5bc6\u7801\u89e3\u9501\u3002 Rainy7 \u7ecf\u8fc7\u4e00\u756a\u67e5\u627e\u540e\uff0c\u627e\u5230\u4e86\u5bc6\u7801\u5bf9\u5e94\u7684\u95ee\u9898\uff1a\u5728n\u00d7m\u7684\u68cb\u76d8\u4e0a\u6446\u653e\u4e24\u4e2a\u4e0d\u540c\u989c\u8272\u7684\u7687\u540e\uff0c\u4f7f\u5f97\u5b83\u4eec\u80fd\u591f\u76f8\u4e92\u653b\u51fb\uff0c\u603b\u5171\u6709\u591a\u5c11\u79cd\u6446\u6cd5\uff1f \u6211\u4eec\u79f0\u4e24\u4e2a\u7687\u540e\u80fd\u591f\u76f8\u4e92\u653b\u51fb\uff0c\u5f53\u4e14\u4ec5\u5f53\u5b83\u4eec\u5728\u540c\u4e00\u884c\u6216\u540c\u4e00\u5217\u6216\u540c\u4e00\u659c\u7ebf\u4e0a\u3002 \u5979\u53ea\u7528\u4e86114514-1919810 s\u5c31\u89e3\u51b3\u4e86\u95ee\u9898\u5e76\u6253\u5f00\u4e86\u5927\u95e8\uff0c\u4e8e\u662f\u628a\u95ee\u9898\u4ea4\u7ed9\u4e86\u60a8\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6574\u6570t\uff0c\u8868\u793a\u6570\u636e\u7ec4\u6570\u3002 \u63a5\u4e0b\u6765t\u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6b63\u6574\u6570n,m\uff0c\u8868\u793a\u68cb\u76d8\u7684\u957f\u548c\u5bbd\u3002 \u8f93\u51fa \u00b6 t\u884c\uff0c\u6bcf\u884c\u4e00\u4e2a\u6570\uff0c\u8868\u793a\u65b9\u6848\u6570\u3002 \u7531\u4e8e\u8fd9\u4e2a\u6570\u53ef\u80fd\u5f88\u5927\uff0c\u60a8\u53ea\u8981\u8f93\u51fa\u5b83\u5bf9109+7\u53d6\u6a21\u7684\u7ed3\u679c\u5c31\u53ef\u4ee5\u4e86\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 1 2 2 \u3010\u6837\u4f8b2\u3011 1 114514 114514 \u3010\u6837\u4f8b3\u3011 2 165528 123456 132435 423153 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 12 \u3010\u6837\u4f8b2\u3011 587308676 \u3010\u6837\u4f8b3\u3011 718509545 475373430 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca \u5982\u56fe\u6240\u793a\uff1a \u5bf9\u4e8e20%\u7684\u6570\u636e\uff0c1\u2264n,m\u226450,1\u2264t\u226410 \u5bf9\u4e8e50%\u7684\u6570\u636e\uff0c1\u2264n,m\u2264300 \u5bf9\u4e8e70%\u7684\u6570\u636e\uff0c1\u2264n,m\u22645000 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c1\u2264n,m\u22645\u00d7105,1\u2264t\u22645000 \u672c\u9898\u90e8\u5206\u6570\u636e\u5361\u5e38\uff0c\u8bf7\u6ce8\u610f\u5e38\u6570\u4f18\u5316 \u89e3\u6790 \u00b6 \u8fd9\u9053\u9898\u76ee\u53ef\u4ee5\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\u6765\u8ba8\u8bba\uff0c\u6a2a\u7ad6\u548c\u5bf9\u89d2\u7ebf\uff0c\u6a2a\u548c\u7ad6\u90fd\u6bd4\u8f83\u7b80\u5355\uff0c\u7ed3\u679c\u4e3an*m*(n+m-2)\uff0c\u5bf9\u89d2\u7ebf\u4e0a\u63a8\u5230\u89c1\u4e0b\u56fe\uff1a #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int mod = 1e9 + 7 ; ll n , m ; ll mul ( ll a , ll b ) { ll sum1 = 0 ; ll sum2 = a ; while ( b != 0 ) { if ( b % 2 == 1 ) sum1 = ( sum1 + sum2 ) % mod ; sum2 = ( sum2 + sum2 ) % mod ; b = b / 2 ; } return sum1 ; } int main () { ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll ans = 0 ; scanf ( \"%lld%lld\" , & n , & m ); if ( n > m ) swap ( n , m ); ans += mul ( n * m , n + m -2 ); ll k1 = n * ( n -1 ) * 2 ; ll k2 = 3 * m - n -1 ; if ( k1 % 3 == 0 ) k1 = k1 / 3 ; else if ( k2 % 3 == 0 ) k2 = k2 / 3 ; ans += mul ( k1 , k2 ); printf ( \"%lld \\n \" , ans % mod ); } return 0 ; }","title":"2020-08-19"},{"location":"csdn/2020-08-19/#_1","text":"Rainy7 \u4e00\u5929\u9192\u6765\uff0c\u53d1\u73b0\u81ea\u5df1\u8fdb\u5165\u4e86\u9b54\u6cd5\u4e16\u754c\u3002 \u4e00\u9053\u5927\u95e8\u77d7\u7acb\u5728 Rainy7 \u9762\u524d\uff0c\u4f3c\u4e4e\u9700\u8981\u5bc6\u7801\u89e3\u9501\u3002 Rainy7 \u7ecf\u8fc7\u4e00\u756a\u67e5\u627e\u540e\uff0c\u627e\u5230\u4e86\u5bc6\u7801\u5bf9\u5e94\u7684\u95ee\u9898\uff1a\u5728n\u00d7m\u7684\u68cb\u76d8\u4e0a\u6446\u653e\u4e24\u4e2a\u4e0d\u540c\u989c\u8272\u7684\u7687\u540e\uff0c\u4f7f\u5f97\u5b83\u4eec\u80fd\u591f\u76f8\u4e92\u653b\u51fb\uff0c\u603b\u5171\u6709\u591a\u5c11\u79cd\u6446\u6cd5\uff1f \u6211\u4eec\u79f0\u4e24\u4e2a\u7687\u540e\u80fd\u591f\u76f8\u4e92\u653b\u51fb\uff0c\u5f53\u4e14\u4ec5\u5f53\u5b83\u4eec\u5728\u540c\u4e00\u884c\u6216\u540c\u4e00\u5217\u6216\u540c\u4e00\u659c\u7ebf\u4e0a\u3002 \u5979\u53ea\u7528\u4e86114514-1919810 s\u5c31\u89e3\u51b3\u4e86\u95ee\u9898\u5e76\u6253\u5f00\u4e86\u5927\u95e8\uff0c\u4e8e\u662f\u628a\u95ee\u9898\u4ea4\u7ed9\u4e86\u60a8\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-19/#_2","text":"\u7b2c\u4e00\u884c\u4e00\u4e2a\u6574\u6570t\uff0c\u8868\u793a\u6570\u636e\u7ec4\u6570\u3002 \u63a5\u4e0b\u6765t\u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6b63\u6574\u6570n,m\uff0c\u8868\u793a\u68cb\u76d8\u7684\u957f\u548c\u5bbd\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-19/#_3","text":"t\u884c\uff0c\u6bcf\u884c\u4e00\u4e2a\u6570\uff0c\u8868\u793a\u65b9\u6848\u6570\u3002 \u7531\u4e8e\u8fd9\u4e2a\u6570\u53ef\u80fd\u5f88\u5927\uff0c\u60a8\u53ea\u8981\u8f93\u51fa\u5b83\u5bf9109+7\u53d6\u6a21\u7684\u7ed3\u679c\u5c31\u53ef\u4ee5\u4e86\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-19/#_4","text":"\u3010\u6837\u4f8b1\u3011 1 2 2 \u3010\u6837\u4f8b2\u3011 1 114514 114514 \u3010\u6837\u4f8b3\u3011 2 165528 123456 132435 423153","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-19/#_5","text":"\u3010\u6837\u4f8b1\u3011 12 \u3010\u6837\u4f8b2\u3011 587308676 \u3010\u6837\u4f8b3\u3011 718509545 475373430","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-19/#_6","text":"\u6837\u4f8b1\u89e3\u91ca \u5982\u56fe\u6240\u793a\uff1a \u5bf9\u4e8e20%\u7684\u6570\u636e\uff0c1\u2264n,m\u226450,1\u2264t\u226410 \u5bf9\u4e8e50%\u7684\u6570\u636e\uff0c1\u2264n,m\u2264300 \u5bf9\u4e8e70%\u7684\u6570\u636e\uff0c1\u2264n,m\u22645000 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c1\u2264n,m\u22645\u00d7105,1\u2264t\u22645000 \u672c\u9898\u90e8\u5206\u6570\u636e\u5361\u5e38\uff0c\u8bf7\u6ce8\u610f\u5e38\u6570\u4f18\u5316","title":"\u63d0\u793a"},{"location":"csdn/2020-08-19/#_7","text":"\u8fd9\u9053\u9898\u76ee\u53ef\u4ee5\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\u6765\u8ba8\u8bba\uff0c\u6a2a\u7ad6\u548c\u5bf9\u89d2\u7ebf\uff0c\u6a2a\u548c\u7ad6\u90fd\u6bd4\u8f83\u7b80\u5355\uff0c\u7ed3\u679c\u4e3an*m*(n+m-2)\uff0c\u5bf9\u89d2\u7ebf\u4e0a\u63a8\u5230\u89c1\u4e0b\u56fe\uff1a #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int mod = 1e9 + 7 ; ll n , m ; ll mul ( ll a , ll b ) { ll sum1 = 0 ; ll sum2 = a ; while ( b != 0 ) { if ( b % 2 == 1 ) sum1 = ( sum1 + sum2 ) % mod ; sum2 = ( sum2 + sum2 ) % mod ; b = b / 2 ; } return sum1 ; } int main () { ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll ans = 0 ; scanf ( \"%lld%lld\" , & n , & m ); if ( n > m ) swap ( n , m ); ans += mul ( n * m , n + m -2 ); ll k1 = n * ( n -1 ) * 2 ; ll k2 = 3 * m - n -1 ; if ( k1 % 3 == 0 ) k1 = k1 / 3 ; else if ( k2 % 3 == 0 ) k2 = k2 / 3 ; ans += mul ( k1 , k2 ); printf ( \"%lld \\n \" , ans % mod ); } return 0 ; }","title":"\u89e3\u6790"},{"location":"csdn/2020-08-20/","text":"http://icpc.upc.edu.cn/problem.php?cid=2550&pid=5 \u9898\u76ee\u63cf\u8ff0 \u00b6 L\u56fd\u4e00\u5171\u6709N\u5ea7\u57ce\u9547\uff0c\u5f00\u59cb\u65f6\u5b83\u4eec\u4e24\u4e24\u4e0d\u8fde\u901a\u3002L\u56fd\u8ba1\u5212\u4f9d\u6b21\u5efa\u9020N-1\u6761\u9053\u8def\uff0c\u628a\u6240\u6709\u57ce\u9547\u8fde\u901a\u8d77\u6765\u3002\u6bcf\u5efa\u5b8c\u4e00\u6761\u9053\u8def\uff0c\u4f60\u9700\u8981\u56de\u7b54\u8fd9\u6761\u9053\u8def\u6240\u5728\u8fde\u901a\u5757\u5185\u8ddd\u79bb\u6700\u8fdc\u7684\u4e24\u5ea7\u57ce\u9547\u4e4b\u95f4\u7684\u8ddd\u79bb\u3002\u4e24\u5ea7\u57ce\u9547\u4e4b\u95f4\u7684\u8ddd\u79bb\u5b9a\u4e49\u4e3a\u4ece\u4e00\u5ea7\u8d70\u5230\u53e6\u4e00\u5ea7\u6240\u9700\u8981\u7ecf\u8fc7\u7684\u6700\u5c11\u9053\u8def\u6570\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6574\u6570N\uff0c\u8868\u793a\u57ce\u9547\u7684\u6570\u91cf\u3002 \u63a5\u4e0b\u6765N-1\u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6574\u6570ai,bi\u8868\u793a\u63a5\u4e0b\u6765\u5efa\u7684\u9053\u8def\u8fde\u901a\u7684\u4e24\u5ea7\u57ce\u9547\u3002 \u4fdd\u8bc1N-1\u6761\u9053\u8def\u80fd\u591f\u4f7f\u6240\u6709\u57ce\u9547\u8fde\u901a\u3002 \u8f93\u51fa \u00b6 \u8f93\u51faN-1\u884c\uff0c\u6bcf\u884c\u4e00\u4e2a\u6574\u6570\u8868\u793a\u5efa\u5b8c\u7b2ci\u6761\u9053\u8def\u540e\u7684\u7b54\u6848\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 5 3 5 3 4 1 2 1 3 \u6837\u4f8b\u8f93\u51fa \u00b6 1 2 1 3 \u63d0\u793a \u00b6 \u5bf9\u4e8e20%\u7684\u6570\u636e\uff0cn\u2264300; \u5bf9\u4e8e50%\u7684\u6570\u636e\uff0cn\u22642000; \u5bf9\u4e8e\u53e6\u591620%\u7684\u6570\u636e\uff0c\u4fdd\u8bc1bi=i+1,ai<=i; \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0cn\u2264300000\u3002 \u89e3\u6790 \u00b6 \u53c2\u8003\u4e8e\uff1a https://blog.csdn.net/qq_43857314/article/details/108108130 lca+st\u7b97\u6cd5\u8be6\u7ec6\u8bb2\u89e3\uff1a https://www.csdn.net/gather_27/MtjaQg0sNjAxOTEtYmxvZwO0O0OO0O0O.html RMQ\u7b97\u6cd5\u5206\u6790 https://blog.csdn.net/y990041769/article/details/38405063 ST\u7b97\u6cd5\u662f\u5c06\u8df3\u7684\u6b65\u6570\u52a0\u4ee5\u4e8c\u8fdb\u5236\u4f18\u5316\u3002 LCA+ST\u500d\u589e+\u6811\u7684\u76f4\u5f84+\u5e76\u67e5\u96c6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <cstdio> #include <cstring> #include <algorithm> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int maxn = 3e5 + 5 ; struct node { int to , nex , w ; } road [ maxn * 2 ]; struct nd { int x ; int y ; }; nd qq [ maxn ] = { 0 }; int n , q , cnt ; int pre [ maxn ][ 32 ], head [ maxn ], depth [ maxn ]; int dis [ maxn ]; ll fa [ maxn ] = { 0 }, s [ maxn ] = { 0 }, t [ maxn ] = { 0 }; void add ( int u , int v , int w ) { road [ cnt ]. to = v ; road [ cnt ]. w = w ; road [ cnt ]. nex = head [ u ]; head [ u ] = cnt ++ ; } void dfs ( int u , int fa ) { pre [ u ][ 0 ] = fa ; depth [ u ] = depth [ fa ] + 1 ; for ( int i = 1 ; ( 1 << i ) <= depth [ u ]; i ++ ) //\u500d\u589e pre [ u ][ i ] = pre [ pre [ u ][ i -1 ]][ i -1 ]; for ( int i = head [ u ]; ~ i ; i = road [ i ]. nex ) { int v = road [ i ]. to ; if ( v != fa ) { dis [ v ] = dis [ u ] + road [ i ]. w ; dfs ( v , u ); } } } int lca ( int u , int v ) { if ( depth [ u ] < depth [ v ]) { swap ( u , v ); } int i = -1 , j ; while (( 1 << ( i + 1 )) <= depth [ u ]) i ++ ; for ( j = i ; j >= 0 ; j -- ) { if ( depth [ u ] - ( 1 << j ) >= depth [ v ]) { u = pre [ u ][ j ]; } } if ( u == v ) return u ; for ( int j = i ; j >= 0 ; j -- ) { if ( pre [ u ][ j ] != pre [ v ][ j ]) { u = pre [ u ][ j ]; v = pre [ v ][ j ]; } } return pre [ u ][ 0 ]; } int findfa ( int x ) { if ( fa [ x ] != x ) return fa [ x ] = findfa ( fa [ x ]); else return x ; } int cmp ( ll & x , ll & y , int & z , int a , int b ) { int dis1 = dis [ a ] + dis [ b ] -2 * dis [ lca ( a , b )]; if ( dis1 > z ) { z = dis1 ; x = a ; y = b ; } } int solve ( int x , int y ) { int fx = findfa ( x ), fy = findfa ( y ); int a = s [ fx ], b = t [ fx ], c = s [ fy ], d = t [ fy ]; fa [ fx ] = fy ; int ans = 0 ; cmp ( s [ fy ], t [ fy ], ans , a , b ); cmp ( s [ fy ], t [ fy ], ans , a , c ); cmp ( s [ fy ], t [ fy ], ans , a , d ); cmp ( s [ fy ], t [ fy ], ans , b , c ); cmp ( s [ fy ], t [ fy ], ans , b , d ); cmp ( s [ fy ], t [ fy ], ans , c , d ); return ans ; } int main () { scanf ( \"%d\" , & n ); memset ( head , -1 , sizeof ( head )); memset ( depth , 0 , sizeof ( depth )); for ( int i = 1 ; i <= n ; i ++ ) fa [ i ] = s [ i ] = t [ i ] = i ; cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int u , v , w ; scanf ( \"%d %d\" , & u , & v ); w = 1 ; qq [ i ]. x = u ; qq [ i ]. y = v ; add ( u , v , w ); add ( v , u , w ); } dis [ 1 ] = 0 ; dfs ( 1 , 0 ); for ( int i = 1 ; i < n ; i ++ ) { printf ( \"%d \\n \" , solve ( qq [ i ]. x , qq [ i ]. y )); } }","title":"2020-08-20"},{"location":"csdn/2020-08-20/#_1","text":"L\u56fd\u4e00\u5171\u6709N\u5ea7\u57ce\u9547\uff0c\u5f00\u59cb\u65f6\u5b83\u4eec\u4e24\u4e24\u4e0d\u8fde\u901a\u3002L\u56fd\u8ba1\u5212\u4f9d\u6b21\u5efa\u9020N-1\u6761\u9053\u8def\uff0c\u628a\u6240\u6709\u57ce\u9547\u8fde\u901a\u8d77\u6765\u3002\u6bcf\u5efa\u5b8c\u4e00\u6761\u9053\u8def\uff0c\u4f60\u9700\u8981\u56de\u7b54\u8fd9\u6761\u9053\u8def\u6240\u5728\u8fde\u901a\u5757\u5185\u8ddd\u79bb\u6700\u8fdc\u7684\u4e24\u5ea7\u57ce\u9547\u4e4b\u95f4\u7684\u8ddd\u79bb\u3002\u4e24\u5ea7\u57ce\u9547\u4e4b\u95f4\u7684\u8ddd\u79bb\u5b9a\u4e49\u4e3a\u4ece\u4e00\u5ea7\u8d70\u5230\u53e6\u4e00\u5ea7\u6240\u9700\u8981\u7ecf\u8fc7\u7684\u6700\u5c11\u9053\u8def\u6570\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-20/#_2","text":"\u7b2c\u4e00\u884c\u4e00\u4e2a\u6574\u6570N\uff0c\u8868\u793a\u57ce\u9547\u7684\u6570\u91cf\u3002 \u63a5\u4e0b\u6765N-1\u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6574\u6570ai,bi\u8868\u793a\u63a5\u4e0b\u6765\u5efa\u7684\u9053\u8def\u8fde\u901a\u7684\u4e24\u5ea7\u57ce\u9547\u3002 \u4fdd\u8bc1N-1\u6761\u9053\u8def\u80fd\u591f\u4f7f\u6240\u6709\u57ce\u9547\u8fde\u901a\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-20/#_3","text":"\u8f93\u51faN-1\u884c\uff0c\u6bcf\u884c\u4e00\u4e2a\u6574\u6570\u8868\u793a\u5efa\u5b8c\u7b2ci\u6761\u9053\u8def\u540e\u7684\u7b54\u6848\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-20/#_4","text":"5 3 5 3 4 1 2 1 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-20/#_5","text":"1 2 1 3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-20/#_6","text":"\u5bf9\u4e8e20%\u7684\u6570\u636e\uff0cn\u2264300; \u5bf9\u4e8e50%\u7684\u6570\u636e\uff0cn\u22642000; \u5bf9\u4e8e\u53e6\u591620%\u7684\u6570\u636e\uff0c\u4fdd\u8bc1bi=i+1,ai<=i; \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0cn\u2264300000\u3002","title":"\u63d0\u793a"},{"location":"csdn/2020-08-20/#_7","text":"\u53c2\u8003\u4e8e\uff1a https://blog.csdn.net/qq_43857314/article/details/108108130 lca+st\u7b97\u6cd5\u8be6\u7ec6\u8bb2\u89e3\uff1a https://www.csdn.net/gather_27/MtjaQg0sNjAxOTEtYmxvZwO0O0OO0O0O.html RMQ\u7b97\u6cd5\u5206\u6790 https://blog.csdn.net/y990041769/article/details/38405063 ST\u7b97\u6cd5\u662f\u5c06\u8df3\u7684\u6b65\u6570\u52a0\u4ee5\u4e8c\u8fdb\u5236\u4f18\u5316\u3002 LCA+ST\u500d\u589e+\u6811\u7684\u76f4\u5f84+\u5e76\u67e5\u96c6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <cstdio> #include <cstring> #include <algorithm> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int maxn = 3e5 + 5 ; struct node { int to , nex , w ; } road [ maxn * 2 ]; struct nd { int x ; int y ; }; nd qq [ maxn ] = { 0 }; int n , q , cnt ; int pre [ maxn ][ 32 ], head [ maxn ], depth [ maxn ]; int dis [ maxn ]; ll fa [ maxn ] = { 0 }, s [ maxn ] = { 0 }, t [ maxn ] = { 0 }; void add ( int u , int v , int w ) { road [ cnt ]. to = v ; road [ cnt ]. w = w ; road [ cnt ]. nex = head [ u ]; head [ u ] = cnt ++ ; } void dfs ( int u , int fa ) { pre [ u ][ 0 ] = fa ; depth [ u ] = depth [ fa ] + 1 ; for ( int i = 1 ; ( 1 << i ) <= depth [ u ]; i ++ ) //\u500d\u589e pre [ u ][ i ] = pre [ pre [ u ][ i -1 ]][ i -1 ]; for ( int i = head [ u ]; ~ i ; i = road [ i ]. nex ) { int v = road [ i ]. to ; if ( v != fa ) { dis [ v ] = dis [ u ] + road [ i ]. w ; dfs ( v , u ); } } } int lca ( int u , int v ) { if ( depth [ u ] < depth [ v ]) { swap ( u , v ); } int i = -1 , j ; while (( 1 << ( i + 1 )) <= depth [ u ]) i ++ ; for ( j = i ; j >= 0 ; j -- ) { if ( depth [ u ] - ( 1 << j ) >= depth [ v ]) { u = pre [ u ][ j ]; } } if ( u == v ) return u ; for ( int j = i ; j >= 0 ; j -- ) { if ( pre [ u ][ j ] != pre [ v ][ j ]) { u = pre [ u ][ j ]; v = pre [ v ][ j ]; } } return pre [ u ][ 0 ]; } int findfa ( int x ) { if ( fa [ x ] != x ) return fa [ x ] = findfa ( fa [ x ]); else return x ; } int cmp ( ll & x , ll & y , int & z , int a , int b ) { int dis1 = dis [ a ] + dis [ b ] -2 * dis [ lca ( a , b )]; if ( dis1 > z ) { z = dis1 ; x = a ; y = b ; } } int solve ( int x , int y ) { int fx = findfa ( x ), fy = findfa ( y ); int a = s [ fx ], b = t [ fx ], c = s [ fy ], d = t [ fy ]; fa [ fx ] = fy ; int ans = 0 ; cmp ( s [ fy ], t [ fy ], ans , a , b ); cmp ( s [ fy ], t [ fy ], ans , a , c ); cmp ( s [ fy ], t [ fy ], ans , a , d ); cmp ( s [ fy ], t [ fy ], ans , b , c ); cmp ( s [ fy ], t [ fy ], ans , b , d ); cmp ( s [ fy ], t [ fy ], ans , c , d ); return ans ; } int main () { scanf ( \"%d\" , & n ); memset ( head , -1 , sizeof ( head )); memset ( depth , 0 , sizeof ( depth )); for ( int i = 1 ; i <= n ; i ++ ) fa [ i ] = s [ i ] = t [ i ] = i ; cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int u , v , w ; scanf ( \"%d %d\" , & u , & v ); w = 1 ; qq [ i ]. x = u ; qq [ i ]. y = v ; add ( u , v , w ); add ( v , u , w ); } dis [ 1 ] = 0 ; dfs ( 1 , 0 ); for ( int i = 1 ; i < n ; i ++ ) { printf ( \"%d \\n \" , solve ( qq [ i ]. x , qq [ i ]. y )); } }","title":"\u89e3\u6790"},{"location":"csdn/2020-08-21/","text":"http://icpc.upc.edu.cn/problem.php?cid=2552&pid=0 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u7ecf\u8fc7\u6570\u5929\u7684\u8270\u82e6\u8dcb\u6d89\uff0cRainy7 \u7ec8\u4e8e\u8fdb\u5165\u4e86\u9b54\u6cd5\u738b\u56fd\u3002\u7531\u4e8e Rainy7 \u662f\u5927\u9b54\u6cd5\u5e08\uff0c\u6240\u4ee5\u5979\u53d7\u5230\u4e86\u56fd\u738b 3edc2wsx1qaz \u7684\u70ed\u60c5\u6b3e\u5f85\u3002 Rainy7 \u4eab\u7528\u5b8c\u56fd\u5bb4\u540e\uff0c\u56fd\u738b\u5411\u5979\u9053\u51fa\u4e86\u9b54\u6cd5\u738b\u56fd\u7684\u56f0\u96be\uff1a\u738b\u56fd\u6b63\u906d\u53d7\u7740\u9b54\u517d\u7684\u88ad\u51fb\u3002\u738b\u56fd\u4e2d\u7684\u6240\u6709\u4eba\u90fd\u65e0\u6cd5\u51fb\u8d25\u9b54\u517d\uff0c\u6240\u4ee5\u56fd\u738b\u6073\u8bf7\u5927\u9b54\u6cd5\u5e08 Rainy7 \u5e2e\u52a9\u738b\u56fd\u4e0e\u9b54\u517d\u6218\u6597\u3002 Rainy7 \u723d\u5feb\u5730\u7b54\u5e94\u4e86\u3002\u56fd\u738b\u6b23\u559c\u82e5\u72c2\uff0c\u5e76\u7acb\u5373\u9080\u8bf7 Rainy7 \u5230\u9b54\u6cd5\u4e16\u754c\u6700\u5927\u7684\u9b54\u6cd5\u9635\u4e2d\u6c72\u53d6\u9b54\u6cd5\uff0c\u4ee5\u505a\u597d\u6218\u6597\u51c6\u5907\u3002 \u8fd9\u4e2a\u9b54\u6cd5\u9635\u662f\u4e00\u4e2an\u884cm\u5217\u7684\u77e9\u9635\uff0c\u77e9\u9635\u4e2d\u6bcf\u4e2a\u683c\u5b50\u90fd\u6709\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u7684\u9b54\u6cd5\u503c\uff0c\u7b2ci\u884c\u7b2cj\u5217\u7684\u683c\u5b50\u7684\u9b54\u6cd5\u503c\u4e3aaij\u3002 Rainy7 \u8981\u4ece\u7b2c1\u884c\u7b2c1\u5217\u7684\u683c\u5b50\u8d70\u5230\u7b2cn\u884c\u7b2cm\u5217\u7684\u683c\u5b50\u3002\u5982\u679c Rainy7 \u5f53\u524d\u5728\u7b2ci\u884c\u7b2cj\u5217\u7684\u683c\u5b50\u4e0a\uff0c\u5219\u5979\u4e0b\u4e00\u6b65\u53ef\u4ee5\u8d70\u5230\u7b2ci+1\u884c\u7b2cj\u5217\u7684\u683c\u5b50\u6216\u7b2c i\u884c\u7b2cj+1\u5217\u7684\u683c\u5b50\u4e0a\uff08\u5982\u679c\u90a3\u4e2a\u683c\u5b50\u5b58\u5728\u7684\u8bdd\uff09\uff0c\u76f4\u5230\u5979\u8d70\u5230\u7b2cn\u884c\u7b2cm\u5217\u7684\u683c\u5b50\u4e3a\u6b62\u3002 Rainy7 \u53ea\u80fd\u6309\u8fd9\u6837\u7684\u65b9\u5f0f\u8d70\u4e00\u6b21\u3002\u8d70\u5b8c\u540e\uff0cRainy7 \u6c72\u53d6\u5230\u7684\u9b54\u6cd5\u503c\u662f\u5979\u8d70\u8fc7\u7684\u6240\u6709\u683c\u5b50\u7684\u9b54\u6cd5\u503c\u7684\u4e0e\u548c\uff0c\u5373\u628a\u5979\u8d70\u8fc7\u7684\u6240\u6709\u683c\u5b50\u7684\u9b54\u6cd5\u503c\u5168\u90e8\u6309\u4f4d\u4e0e\u8d77\u6765\u7684\u7ed3\u679c\u3002 Rainy7 \u60f3\u77e5\u9053\u5979\u6700\u591a\u80fd\u6c72\u53d6\u5230\u591a\u5c11\u9b54\u6cd5\u503c\u3002Rainy7 \u53ea\u7528\u4e86114514-1919810s\u5c31\u7b97\u51fa\u4e86\u7b54\u6848\uff0c\u5728\u5979\u5f00\u59cb\u6c72\u53d6\u9b54\u6cd5\u4e4b\u524d\uff0c\u5979\u4e5f\u60f3\u8ba9\u4f60\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 \u9877\u523b\u95f4\uff0c\u9b54\u6cd5\u6c72\u53d6\u5b8c\u6bd5\u4e86\uff0cRainy7 \u4fbf\u575a\u5b9a\u5730\u5411\u6218\u573a\u8d70\u53bb\u2026\u2026 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e24\u4e2a\u6574\u6570n,m\uff0c\u5206\u522b\u8868\u793a\u9b54\u6cd5\u9635\u7684\u884c\u6570\u548c\u5217\u6570\u3002 \u63a5\u4e0b\u6765n\u884c\uff0c\u6bcf\u884c\u5305\u542bm\u4e2a\u6574\u6570\uff0c\u5176\u4e2d\u7b2ci\u7684\u7b2cj\u4e2a\u6570\u8868\u793aaij\u3002 \u8f93\u51fa \u00b6 \u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a Rainy7 \u80fd\u6c72\u53d6\u5230\u7684\u9b54\u6cd5\u503c\u7684\u6700\u5927\u503c\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 3 4 3 7 7 7 6 3 8 4 1 3 3 7 \u3010\u6837\u4f8b2\u3011 10 10 2047 2047 1535 2043 863 1983 2046 2015 2047 2047 1903 1535 1982 2015 2047 1531 1791 2015 2025 2045 767 927 2023 2039 2015 1918 2042 2039 935 2047 2022 2045 1499 991 2046 2047 2047 959 1023 2047 2038 1999 2046 1919 1519 2015 1007 2047 2047 1023 2047 991 1983 2047 1919 1655 1791 2013 1535 2047 2047 2047 1974 1535 2047 2031 1847 1535 2047 2045 1023 1023 2047 2047 1919 2011 1983 1791 1979 2023 2047 2047 2047 2045 1503 511 1023 2004 2039 2047 895 1525 2031 1911 2039 1967 1852 1023 1983 2047 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 3 \u3010\u6837\u4f8b2\u3011 1284 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca\uff1a \u6211\u4eec\u7528(i,j)\u8868\u793a\u9b54\u6cd5\u9635\u7b2ci\u884c\u7b2cj\u5217\u7684\u683c\u5b50\u3002 Rainy7 \u8d70\u8fc7\u7684\u8def\u5f84\u4e3a\uff1a(1,1)->(1,2)->(2,2)->(3,2)->(3,3)->(3,4)\uff0c\u6c72\u53d6\u5230\u7684\u9b54\u6cd5\u503c\u4e3a 3 and 7 and 3 and 4 and 3 and 7 = 3\u3002 \u6837\u4f8b2\u89e3\u91ca: Rainy7 \u8d70\u8fc7\u7684\u4e00\u79cd\u6700\u4f73\u8def\u5f84\u4e3a\uff1a (1,1)->(1,2)->(1,3)->(2,3)->(2,4)->(2.5)->(3,5)->(4,5)->(5,5)->(6,5)->(7,5)->(7,6)->(7,7)->(7,8)->(7,9)->(7,10)->(8,10)->(9,10)->(10.10)\u3002 \u5bf9\u4e8e\u5168\u90e8\u6570\u636e\uff0c1\u2264n,m\u22642\u00d7103,0\u2264aij\u2264231-1\u3002 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 2500 ][ 2500 ] = { 0 }; int n , m ; int dp [ 2500 ][ 2500 ] = { 0 }; int max1 = 0 ; int cnt = 0 ; int p [ 2005 ][ 2005 ] = { 0 }; int vis [ 2005 ][ 2005 ] = { 0 }; inline int dfs () { if ( vis [ 1 ][ 1 ]) return 0 ; cnt ++ ; p [ 1 ][ 1 ] = cnt ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( vis [ i ][ j ]) continue ; if ( i > 1 &&! vis [ i -1 ][ j ] && p [ i -1 ][ j ] == cnt ) p [ i ][ j ] = cnt ; if ( j > 1 &&! vis [ i ][ j -1 ] && p [ i ][ j -1 ] == cnt ) p [ i ][ j ] = cnt ; } } if ( p [ n ][ m ] == cnt ) return 1 ; else return 0 ; } int last [ 2005 ][ 2005 ] = { 0 }; int l [ 100 ] = { 0 }; int main () { scanf ( \"%d%d\" , & n , & m ); for ( register int i = 1 ; i <= n ; i ++ ) { for ( register int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]); } } for ( int k = 31 ; k >= 0 ; k -- ) { if ( ! (( a [ 1 ][ 1 ] >> k ) & 1 )) continue ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { vis [ i ][ j ] = last [ i ][ j ]; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( ! (( a [ i ][ j ] >> k ) & 1 )) vis [ i ][ j ] = 1 ; } } if ( dfs ()) { l [ k ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { last [ i ][ j ] = vis [ i ][ j ]; } } } } int sum = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { sum += l [ i ] * ( 1 << i ); } cout << sum << endl ; return 0 ; }","title":"2020-08-21"},{"location":"csdn/2020-08-21/#_1","text":"\u7ecf\u8fc7\u6570\u5929\u7684\u8270\u82e6\u8dcb\u6d89\uff0cRainy7 \u7ec8\u4e8e\u8fdb\u5165\u4e86\u9b54\u6cd5\u738b\u56fd\u3002\u7531\u4e8e Rainy7 \u662f\u5927\u9b54\u6cd5\u5e08\uff0c\u6240\u4ee5\u5979\u53d7\u5230\u4e86\u56fd\u738b 3edc2wsx1qaz \u7684\u70ed\u60c5\u6b3e\u5f85\u3002 Rainy7 \u4eab\u7528\u5b8c\u56fd\u5bb4\u540e\uff0c\u56fd\u738b\u5411\u5979\u9053\u51fa\u4e86\u9b54\u6cd5\u738b\u56fd\u7684\u56f0\u96be\uff1a\u738b\u56fd\u6b63\u906d\u53d7\u7740\u9b54\u517d\u7684\u88ad\u51fb\u3002\u738b\u56fd\u4e2d\u7684\u6240\u6709\u4eba\u90fd\u65e0\u6cd5\u51fb\u8d25\u9b54\u517d\uff0c\u6240\u4ee5\u56fd\u738b\u6073\u8bf7\u5927\u9b54\u6cd5\u5e08 Rainy7 \u5e2e\u52a9\u738b\u56fd\u4e0e\u9b54\u517d\u6218\u6597\u3002 Rainy7 \u723d\u5feb\u5730\u7b54\u5e94\u4e86\u3002\u56fd\u738b\u6b23\u559c\u82e5\u72c2\uff0c\u5e76\u7acb\u5373\u9080\u8bf7 Rainy7 \u5230\u9b54\u6cd5\u4e16\u754c\u6700\u5927\u7684\u9b54\u6cd5\u9635\u4e2d\u6c72\u53d6\u9b54\u6cd5\uff0c\u4ee5\u505a\u597d\u6218\u6597\u51c6\u5907\u3002 \u8fd9\u4e2a\u9b54\u6cd5\u9635\u662f\u4e00\u4e2an\u884cm\u5217\u7684\u77e9\u9635\uff0c\u77e9\u9635\u4e2d\u6bcf\u4e2a\u683c\u5b50\u90fd\u6709\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u7684\u9b54\u6cd5\u503c\uff0c\u7b2ci\u884c\u7b2cj\u5217\u7684\u683c\u5b50\u7684\u9b54\u6cd5\u503c\u4e3aaij\u3002 Rainy7 \u8981\u4ece\u7b2c1\u884c\u7b2c1\u5217\u7684\u683c\u5b50\u8d70\u5230\u7b2cn\u884c\u7b2cm\u5217\u7684\u683c\u5b50\u3002\u5982\u679c Rainy7 \u5f53\u524d\u5728\u7b2ci\u884c\u7b2cj\u5217\u7684\u683c\u5b50\u4e0a\uff0c\u5219\u5979\u4e0b\u4e00\u6b65\u53ef\u4ee5\u8d70\u5230\u7b2ci+1\u884c\u7b2cj\u5217\u7684\u683c\u5b50\u6216\u7b2c i\u884c\u7b2cj+1\u5217\u7684\u683c\u5b50\u4e0a\uff08\u5982\u679c\u90a3\u4e2a\u683c\u5b50\u5b58\u5728\u7684\u8bdd\uff09\uff0c\u76f4\u5230\u5979\u8d70\u5230\u7b2cn\u884c\u7b2cm\u5217\u7684\u683c\u5b50\u4e3a\u6b62\u3002 Rainy7 \u53ea\u80fd\u6309\u8fd9\u6837\u7684\u65b9\u5f0f\u8d70\u4e00\u6b21\u3002\u8d70\u5b8c\u540e\uff0cRainy7 \u6c72\u53d6\u5230\u7684\u9b54\u6cd5\u503c\u662f\u5979\u8d70\u8fc7\u7684\u6240\u6709\u683c\u5b50\u7684\u9b54\u6cd5\u503c\u7684\u4e0e\u548c\uff0c\u5373\u628a\u5979\u8d70\u8fc7\u7684\u6240\u6709\u683c\u5b50\u7684\u9b54\u6cd5\u503c\u5168\u90e8\u6309\u4f4d\u4e0e\u8d77\u6765\u7684\u7ed3\u679c\u3002 Rainy7 \u60f3\u77e5\u9053\u5979\u6700\u591a\u80fd\u6c72\u53d6\u5230\u591a\u5c11\u9b54\u6cd5\u503c\u3002Rainy7 \u53ea\u7528\u4e86114514-1919810s\u5c31\u7b97\u51fa\u4e86\u7b54\u6848\uff0c\u5728\u5979\u5f00\u59cb\u6c72\u53d6\u9b54\u6cd5\u4e4b\u524d\uff0c\u5979\u4e5f\u60f3\u8ba9\u4f60\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 \u9877\u523b\u95f4\uff0c\u9b54\u6cd5\u6c72\u53d6\u5b8c\u6bd5\u4e86\uff0cRainy7 \u4fbf\u575a\u5b9a\u5730\u5411\u6218\u573a\u8d70\u53bb\u2026\u2026","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-08-21/#_2","text":"\u7b2c\u4e00\u884c\u4e24\u4e2a\u6574\u6570n,m\uff0c\u5206\u522b\u8868\u793a\u9b54\u6cd5\u9635\u7684\u884c\u6570\u548c\u5217\u6570\u3002 \u63a5\u4e0b\u6765n\u884c\uff0c\u6bcf\u884c\u5305\u542bm\u4e2a\u6574\u6570\uff0c\u5176\u4e2d\u7b2ci\u7684\u7b2cj\u4e2a\u6570\u8868\u793aaij\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-08-21/#_3","text":"\u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a Rainy7 \u80fd\u6c72\u53d6\u5230\u7684\u9b54\u6cd5\u503c\u7684\u6700\u5927\u503c\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-08-21/#_4","text":"\u3010\u6837\u4f8b1\u3011 3 4 3 7 7 7 6 3 8 4 1 3 3 7 \u3010\u6837\u4f8b2\u3011 10 10 2047 2047 1535 2043 863 1983 2046 2015 2047 2047 1903 1535 1982 2015 2047 1531 1791 2015 2025 2045 767 927 2023 2039 2015 1918 2042 2039 935 2047 2022 2045 1499 991 2046 2047 2047 959 1023 2047 2038 1999 2046 1919 1519 2015 1007 2047 2047 1023 2047 991 1983 2047 1919 1655 1791 2013 1535 2047 2047 2047 1974 1535 2047 2031 1847 1535 2047 2045 1023 1023 2047 2047 1919 2011 1983 1791 1979 2023 2047 2047 2047 2045 1503 511 1023 2004 2039 2047 895 1525 2031 1911 2039 1967 1852 1023 1983 2047","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-08-21/#_5","text":"\u3010\u6837\u4f8b1\u3011 3 \u3010\u6837\u4f8b2\u3011 1284","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-08-21/#_6","text":"\u6837\u4f8b1\u89e3\u91ca\uff1a \u6211\u4eec\u7528(i,j)\u8868\u793a\u9b54\u6cd5\u9635\u7b2ci\u884c\u7b2cj\u5217\u7684\u683c\u5b50\u3002 Rainy7 \u8d70\u8fc7\u7684\u8def\u5f84\u4e3a\uff1a(1,1)->(1,2)->(2,2)->(3,2)->(3,3)->(3,4)\uff0c\u6c72\u53d6\u5230\u7684\u9b54\u6cd5\u503c\u4e3a 3 and 7 and 3 and 4 and 3 and 7 = 3\u3002 \u6837\u4f8b2\u89e3\u91ca: Rainy7 \u8d70\u8fc7\u7684\u4e00\u79cd\u6700\u4f73\u8def\u5f84\u4e3a\uff1a (1,1)->(1,2)->(1,3)->(2,3)->(2,4)->(2.5)->(3,5)->(4,5)->(5,5)->(6,5)->(7,5)->(7,6)->(7,7)->(7,8)->(7,9)->(7,10)->(8,10)->(9,10)->(10.10)\u3002 \u5bf9\u4e8e\u5168\u90e8\u6570\u636e\uff0c1\u2264n,m\u22642\u00d7103,0\u2264aij\u2264231-1\u3002 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 2500 ][ 2500 ] = { 0 }; int n , m ; int dp [ 2500 ][ 2500 ] = { 0 }; int max1 = 0 ; int cnt = 0 ; int p [ 2005 ][ 2005 ] = { 0 }; int vis [ 2005 ][ 2005 ] = { 0 }; inline int dfs () { if ( vis [ 1 ][ 1 ]) return 0 ; cnt ++ ; p [ 1 ][ 1 ] = cnt ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( vis [ i ][ j ]) continue ; if ( i > 1 &&! vis [ i -1 ][ j ] && p [ i -1 ][ j ] == cnt ) p [ i ][ j ] = cnt ; if ( j > 1 &&! vis [ i ][ j -1 ] && p [ i ][ j -1 ] == cnt ) p [ i ][ j ] = cnt ; } } if ( p [ n ][ m ] == cnt ) return 1 ; else return 0 ; } int last [ 2005 ][ 2005 ] = { 0 }; int l [ 100 ] = { 0 }; int main () { scanf ( \"%d%d\" , & n , & m ); for ( register int i = 1 ; i <= n ; i ++ ) { for ( register int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]); } } for ( int k = 31 ; k >= 0 ; k -- ) { if ( ! (( a [ 1 ][ 1 ] >> k ) & 1 )) continue ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { vis [ i ][ j ] = last [ i ][ j ]; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( ! (( a [ i ][ j ] >> k ) & 1 )) vis [ i ][ j ] = 1 ; } } if ( dfs ()) { l [ k ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { last [ i ][ j ] = vis [ i ][ j ]; } } } } int sum = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { sum += l [ i ] * ( 1 << i ); } cout << sum << endl ; return 0 ; }","title":"\u63d0\u793a"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","text":"http://icpc.upc.edu.cn/problem.php?cid=2570&pid=6 \u9898\u76ee\u63cf\u8ff0 \u00b6 When Mr. B, Mr. G and Mr. M were preparing for the 2012 ACM-ICPC World Final Contest, Mr. B had collected a large set of contest problems for their daily training. When they decided to take training, Mr. B would choose one of them from the problem set. All the problems in the problem set had been sorted by their time of publish. Each time Prof. S, their coach, would tell them to choose one problem published within a particular time interval. That is to say, if problems had been sorted in a line, each time they would choose one of them from a specified segment of the line. Moreover, when collecting the problems, Mr. B had also known an estimation of each problem\u2019s difficultness. When he was asked to choose a problem, if he chose the easiest one, Mr. G would complain that \u201cHey, what a trivial problem!\u201d; if he chose the hardest one, Mr. M would grumble that it took too much time to finish it. To address this dilemma, Mr. B decided to take the one with the medium difficulty. Therefore, he needed a way to know the median number in the given interval of the sequence. \u8f93\u5165 \u00b6 For each test case, the first line contains a single integer n (1 <= n <= 100,000) indicating the total number of problems. The second line contains n integers xi (0 <= xi <= 1,000,000,000), separated by single space, denoting the difficultness of each problem, already sorted by publish time. The next line contains a single integer m (1 <= m <= 100,000), specifying number of queries. Then m lines follow, each line contains a pair of integers, A and B (1 <= A <= B <= n), denoting that Mr. B needed to choose a problem between positions A and B (inclusively, positions are counted from 1). It is guaranteed that the number of items between A and B is odd. \u8f93\u51fa \u00b6 For each query, output a single line containing an integer that denotes the difficultness of the problem that Mr. B should choose. \u6837\u4f8b\u8f93\u5165 \u00b6 5 5 3 2 4 1 3 1 3 2 4 3 5 5 10 6 4 8 2 3 1 3 2 4 3 5 \u6837\u4f8b\u8f93\u51fa \u00b6 Case 1: 3 3 2 Case 2: 6 6 4 \u5212\u5206\u6811\u6a21\u677f \u5212\u5206\u6811\u8bb2\u89e3\uff1a https://blog.csdn.net/qq_38984851/article/details/81559956 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int tree [ 20 ][ 100500 ] = { 0 }; int to [ 20 ][ 100500 ] = { 0 }; int num [ 100500 ] = { 0 }; int sorted [ 100500 ] = { 0 }; int build ( int l , int r , int deep ) { if ( l == r ) return 0 ; int mid = ( l + r ) / 2 ; int midd = sorted [ mid ]; int suppose = mid - l + 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( tree [ deep ][ i ] < midd ) suppose -- ; } int sleft = l , sright = mid + 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( i == l ) to [ deep ][ l ] = 0 ; else to [ deep ][ i ] = to [ deep ][ i -1 ]; if ( tree [ deep ][ i ] < midd ) { to [ deep ][ i ] ++ ; tree [ deep + 1 ][ sleft ++ ] = tree [ deep ][ i ]; } else if ( tree [ deep ][ i ] == midd && suppose > 0 ) { suppose -- ; to [ deep ][ i ] ++ ; tree [ deep + 1 ][ sleft ++ ] = tree [ deep ][ i ]; } else { tree [ deep + 1 ][ sright ++ ] = tree [ deep ][ i ]; } } build ( l , mid , deep + 1 ); build ( mid + 1 , r , deep + 1 ); } int query ( int l , int r , int L , int R , int k , int deep ) { if ( L == R ) return tree [ deep ][ L ]; int mid = ( l + r ) / 2 ; int lef ; int toleft ; if ( l == L ) lef = 0 , toleft = to [ deep ][ R ]; else lef = to [ deep ][ L -1 ], toleft = to [ deep ][ R ] - lef ; if ( k <= toleft ) { return query ( l , mid , l + lef , l + toleft + lef -1 , k , deep + 1 ); } else { return query ( mid + 1 , r , mid + L - l - lef + 1 , mid + R - l - toleft - lef + 1 , k - toleft , deep + 1 ); } } int main () { int n , m , summ = 0 ; while ( scanf ( \"%d\" , & n ) != EOF ) { summ ++ ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & num [ i ]); sorted [ i ] = num [ i ]; tree [ 0 ][ i ] = num [ i ]; } sort ( sorted + 1 , sorted + n + 1 ); build ( 1 , n , 0 ); printf ( \"Case %d: \\n \" , summ ); scanf ( \"%d\" , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int a , b , c ; /// a,b,c\u4ee3\u8868\u67e5\u8be2a\u5230b\u533a\u95f4\u5185\u7b2cc\u5927\u7684\u6570 scanf ( \"%d%d\" , & a , & b ); c = ( b - a ) / 2 + 1 ; printf ( \"%d \\n \" , query ( 1 , n , a , b , c , 0 )); } } } http://icpc.upc.edu.cn/problem.php?cid=2570&pid=3 \u9898\u76ee\u63cf\u8ff0 \u00b6 Mr. B loves to play with colorful stones. There are n colors of stones in his collection. Two stones with the same color are indistinguishable. Mr. B would like to select some stones and arrange them in line to form a beautiful pattern. After several arrangements he finds it very hard for him to enumerate all the patterns. So he asks you to write a program to count the number of different possible patterns. Two patterns are considered different, if and only if they have different number of stones or have different colors on at least one position. \u8f93\u5165 \u00b6 Each test case starts with a line containing an integer n indicating the kinds of stones Mr. B have. Following this is a line containing n integers - the number of available stones of each color respectively. All the input numbers will be nonnegative and no more than 100. \u8f93\u51fa \u00b6 For each test case, display a single line containing the case number and the number of different patterns Mr. B can make with these stones, modulo 1,000,000,007, which is a prime number. \u6837\u4f8b\u8f93\u5165 \u00b6 3 1 1 1 2 1 2 \u6837\u4f8b\u8f93\u51fa \u00b6 Case 1: 15 Case 2: 8 \u63d0\u793a \u00b6 In the first case, suppose the colors of the stones Mr. B has are B, G and M, the different patterns Mr. B can form are: B; G; M; BG; BM; GM; GB; MB; MG; BGM; BMG; GBM; GMB; MBG; MGB. \u52a8\u6001\u89c4\u5212DP+\u7ec4\u5408\u6570\u5b66 \u53c2\u7167\u535a\u5ba2 https://blog.csdn.net/nobody_like_you/article/details/100016385 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 105 ] = { 0 }; ll sum [ 105 ] = { 0 }; ll dp [ 105 ][ 10500 ] = { 0 }; const ll N = 1e9 + 7 ; ll c1 [ 10550 ][ 115 ] = { 0 }; int main () { for ( ll i = 0 ; i <= 10500 ; i ++ ) { for ( ll j = 0 ; j <= i && j <= 105 ; j ++ ) { if ( j == 0 || i == j ) c1 [ i ][ j ] = 1 ; else c1 [ i ][ j ] = c1 [ i -1 ][ j ] + c1 [ i -1 ][ j -1 ]; c1 [ i ][ j ] %= N ; } } register ll n , sum1 = 0 ; while ( ~ scanf ( \"%lld\" , & n )) { memset ( dp , 0 , sizeof ( dp )); sum1 ++ ; for ( register ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]), sum [ i ] = sum [ i -1 ] + a [ i ]; dp [ 0 ][ 0 ] = 1 ; for ( register ll i = 1 ; i <= n ; i ++ ) { for ( register ll j = 0 ; j <= sum [ i ]; j ++ ) { for ( register ll k = 0 ; k <= a [ i ] && k <= j ; k ++ ) { dp [ i ][ j ] = dp [ i ][ j ] + c1 [ j ][ k ] * dp [ i -1 ][ j - k ]; dp [ i ][ j ] %= N ; } } } register ll summ = 0 ; for ( register ll i = 1 ; i <= sum [ n ]; i ++ ) { summ += dp [ n ][ i ]; summ %= N ; } printf ( \"Case %lld: %lld \\n \" , sum1 , summ ); //cout<<\"Case \"<<sum1<<\": \"<<summ<<endl; } } \u9898\u76ee\u63cf\u8ff0 \u00b6 \u73b0\u6709r\u4e2a\u4e92\u4e0d\u76f8\u540c\u7684\u76d2\u5b50\u548cn\u4e2a\u4e92\u4e0d\u76f8\u540c\u7684\u7403\uff0c\u8981\u5c06\u8fd9n\u4e2a\u7403\u653e\u5165r\u4e2a\u76d2\u5b50\u4e2d\uff0c\u4e14\u4e0d\u5141\u8bb8\u6709\u7a7a\u76d2\u5b50\u3002\u95ee\u6709\u591a\u5c11\u79cd\u65b9\u6cd5\uff1f \u4f8b\u5982\uff1a\u67092\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\uff08\u5206\u522b\u7f16\u4e3a1\u53f7\u548c2\u53f7\uff09\u548c3\u4e2a\u4e0d\u540c\u7684\u7403\uff08\u5206\u522b\u7f16\u4e3a1\u30012\u30013\u53f7\uff09\uff0c\u5219\u67096\u79cd\u4e0d\u540c\u7684\u65b9\u6cd5\uff1a \u8f93\u5165 \u00b6 \u4e24\u4e2a\u6574\u6570\uff0cn\u548cr\uff0c\u4e2d\u95f4\u7528\u7a7a\u683c\u5206\u9694\u3002\uff080\u2264n, r\u226410\uff09 \u8f93\u51fa \u00b6 \u4ec5\u4e00\u884c\uff0c\u4e00\u4e2a\u6574\u6570\uff08\u4fdd\u8bc1\u5728\u957f\u6574\u578b\u8303\u56f4\u5185\uff09\u3002\u8868\u793an\u4e2a\u7403\u653e\u5165r\u4e2a\u76d2\u5b50\u7684\u65b9\u6cd5\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 3 2 \u6837\u4f8b\u8f93\u51fa \u00b6 6 \u89e3\u6790 \u00b6 \u9996\u5148\u5c4f\u853d\u4e00\u4e2a\u6761\u4ef6->r\u4e2a\u76d2\u5b50\u4e92\u4e0d\u76f8\u540c,\u8bbe\u5b9a\u6211\u4eec\u5c06\u7b2ci\u4e2a\u7403\u5c06\u8981\u653e\u5230\u7b2ck\u4e2a\u76d2\u5b50\u91cc\uff08\u524di-1\u4e2a\u7403\u5df2\u7ecf\u5728\u524dk\u4e2a\u76d2\u5b50\u91cc\u653e\u597d\uff09\u4e8e\u662f\u6709\u5982\u4e0b\u9012\u63a8\u516c\u5f0f\uff1a s[i,k] = s[i-i,k-1]+s[i-1,k]*k \u4e5f\u5c31\u662f\u8bf4\u5bf9\u4e8e\u7b2ci\u4e2a\u7403\uff0c\u5f53\u7b2ck\u4e2a\u76d2\u5b50\u4e3a\u7a7a\u65f6\uff0c\u5c31\u5fc5\u987b\u8981\u653e\u5230\u7b2ck\u4e2a\u76d2\u5b50\u91cc\uff0c\u5f53\u7b2ck\u4e2a\u76d2\u5b50\u4e0d\u4e3a\u7a7a\u65f6\uff0c\u53ef\u4ee5\u4efb\u610f\u653e\u5230k\u4e2a\u76d2\u5b50\u5176\u4e2d\u7684\u4e00\u4e2a\u3002 #include <iostream> using namespace std ; const long long int N = 1e9 + 7 ; int a [ 100 ][ 100 ] = { 0 }; typedef long long ll ; int main () { int n , k ; cin >> n >> k ; for ( int i = 1 ; i <= 15 ; i ++ ) { a [ i ][ 1 ] = 1 ; } for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { a [ i ][ j ] = a [ i -1 ][ j ] * j + a [ i -1 ][ j -1 ]; } } for ( int i = 1 ; i <= k ; i ++ ) a [ n ][ k ] = a [ n ][ k ] * i ; cout << a [ n ][ k ] << endl ; return 0 ; }","title":"2020 09 05 \u5212\u5206\u6811\u6c42\u67d0\u4e00\u533a\u95f4\u7684\u4e2d\u4f4d\u6570"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_1","text":"When Mr. B, Mr. G and Mr. M were preparing for the 2012 ACM-ICPC World Final Contest, Mr. B had collected a large set of contest problems for their daily training. When they decided to take training, Mr. B would choose one of them from the problem set. All the problems in the problem set had been sorted by their time of publish. Each time Prof. S, their coach, would tell them to choose one problem published within a particular time interval. That is to say, if problems had been sorted in a line, each time they would choose one of them from a specified segment of the line. Moreover, when collecting the problems, Mr. B had also known an estimation of each problem\u2019s difficultness. When he was asked to choose a problem, if he chose the easiest one, Mr. G would complain that \u201cHey, what a trivial problem!\u201d; if he chose the hardest one, Mr. M would grumble that it took too much time to finish it. To address this dilemma, Mr. B decided to take the one with the medium difficulty. Therefore, he needed a way to know the median number in the given interval of the sequence.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_2","text":"For each test case, the first line contains a single integer n (1 <= n <= 100,000) indicating the total number of problems. The second line contains n integers xi (0 <= xi <= 1,000,000,000), separated by single space, denoting the difficultness of each problem, already sorted by publish time. The next line contains a single integer m (1 <= m <= 100,000), specifying number of queries. Then m lines follow, each line contains a pair of integers, A and B (1 <= A <= B <= n), denoting that Mr. B needed to choose a problem between positions A and B (inclusively, positions are counted from 1). It is guaranteed that the number of items between A and B is odd.","title":"\u8f93\u5165"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_3","text":"For each query, output a single line containing an integer that denotes the difficultness of the problem that Mr. B should choose.","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_4","text":"5 5 3 2 4 1 3 1 3 2 4 3 5 5 10 6 4 8 2 3 1 3 2 4 3 5","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_5","text":"Case 1: 3 3 2 Case 2: 6 6 4 \u5212\u5206\u6811\u6a21\u677f \u5212\u5206\u6811\u8bb2\u89e3\uff1a https://blog.csdn.net/qq_38984851/article/details/81559956 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int tree [ 20 ][ 100500 ] = { 0 }; int to [ 20 ][ 100500 ] = { 0 }; int num [ 100500 ] = { 0 }; int sorted [ 100500 ] = { 0 }; int build ( int l , int r , int deep ) { if ( l == r ) return 0 ; int mid = ( l + r ) / 2 ; int midd = sorted [ mid ]; int suppose = mid - l + 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( tree [ deep ][ i ] < midd ) suppose -- ; } int sleft = l , sright = mid + 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( i == l ) to [ deep ][ l ] = 0 ; else to [ deep ][ i ] = to [ deep ][ i -1 ]; if ( tree [ deep ][ i ] < midd ) { to [ deep ][ i ] ++ ; tree [ deep + 1 ][ sleft ++ ] = tree [ deep ][ i ]; } else if ( tree [ deep ][ i ] == midd && suppose > 0 ) { suppose -- ; to [ deep ][ i ] ++ ; tree [ deep + 1 ][ sleft ++ ] = tree [ deep ][ i ]; } else { tree [ deep + 1 ][ sright ++ ] = tree [ deep ][ i ]; } } build ( l , mid , deep + 1 ); build ( mid + 1 , r , deep + 1 ); } int query ( int l , int r , int L , int R , int k , int deep ) { if ( L == R ) return tree [ deep ][ L ]; int mid = ( l + r ) / 2 ; int lef ; int toleft ; if ( l == L ) lef = 0 , toleft = to [ deep ][ R ]; else lef = to [ deep ][ L -1 ], toleft = to [ deep ][ R ] - lef ; if ( k <= toleft ) { return query ( l , mid , l + lef , l + toleft + lef -1 , k , deep + 1 ); } else { return query ( mid + 1 , r , mid + L - l - lef + 1 , mid + R - l - toleft - lef + 1 , k - toleft , deep + 1 ); } } int main () { int n , m , summ = 0 ; while ( scanf ( \"%d\" , & n ) != EOF ) { summ ++ ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & num [ i ]); sorted [ i ] = num [ i ]; tree [ 0 ][ i ] = num [ i ]; } sort ( sorted + 1 , sorted + n + 1 ); build ( 1 , n , 0 ); printf ( \"Case %d: \\n \" , summ ); scanf ( \"%d\" , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int a , b , c ; /// a,b,c\u4ee3\u8868\u67e5\u8be2a\u5230b\u533a\u95f4\u5185\u7b2cc\u5927\u7684\u6570 scanf ( \"%d%d\" , & a , & b ); c = ( b - a ) / 2 + 1 ; printf ( \"%d \\n \" , query ( 1 , n , a , b , c , 0 )); } } } http://icpc.upc.edu.cn/problem.php?cid=2570&pid=3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_6","text":"Mr. B loves to play with colorful stones. There are n colors of stones in his collection. Two stones with the same color are indistinguishable. Mr. B would like to select some stones and arrange them in line to form a beautiful pattern. After several arrangements he finds it very hard for him to enumerate all the patterns. So he asks you to write a program to count the number of different possible patterns. Two patterns are considered different, if and only if they have different number of stones or have different colors on at least one position.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_7","text":"Each test case starts with a line containing an integer n indicating the kinds of stones Mr. B have. Following this is a line containing n integers - the number of available stones of each color respectively. All the input numbers will be nonnegative and no more than 100.","title":"\u8f93\u5165"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_8","text":"For each test case, display a single line containing the case number and the number of different patterns Mr. B can make with these stones, modulo 1,000,000,007, which is a prime number.","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_9","text":"3 1 1 1 2 1 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_10","text":"Case 1: 15 Case 2: 8","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_11","text":"In the first case, suppose the colors of the stones Mr. B has are B, G and M, the different patterns Mr. B can form are: B; G; M; BG; BM; GM; GB; MB; MG; BGM; BMG; GBM; GMB; MBG; MGB. \u52a8\u6001\u89c4\u5212DP+\u7ec4\u5408\u6570\u5b66 \u53c2\u7167\u535a\u5ba2 https://blog.csdn.net/nobody_like_you/article/details/100016385 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 105 ] = { 0 }; ll sum [ 105 ] = { 0 }; ll dp [ 105 ][ 10500 ] = { 0 }; const ll N = 1e9 + 7 ; ll c1 [ 10550 ][ 115 ] = { 0 }; int main () { for ( ll i = 0 ; i <= 10500 ; i ++ ) { for ( ll j = 0 ; j <= i && j <= 105 ; j ++ ) { if ( j == 0 || i == j ) c1 [ i ][ j ] = 1 ; else c1 [ i ][ j ] = c1 [ i -1 ][ j ] + c1 [ i -1 ][ j -1 ]; c1 [ i ][ j ] %= N ; } } register ll n , sum1 = 0 ; while ( ~ scanf ( \"%lld\" , & n )) { memset ( dp , 0 , sizeof ( dp )); sum1 ++ ; for ( register ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]), sum [ i ] = sum [ i -1 ] + a [ i ]; dp [ 0 ][ 0 ] = 1 ; for ( register ll i = 1 ; i <= n ; i ++ ) { for ( register ll j = 0 ; j <= sum [ i ]; j ++ ) { for ( register ll k = 0 ; k <= a [ i ] && k <= j ; k ++ ) { dp [ i ][ j ] = dp [ i ][ j ] + c1 [ j ][ k ] * dp [ i -1 ][ j - k ]; dp [ i ][ j ] %= N ; } } } register ll summ = 0 ; for ( register ll i = 1 ; i <= sum [ n ]; i ++ ) { summ += dp [ n ][ i ]; summ %= N ; } printf ( \"Case %lld: %lld \\n \" , sum1 , summ ); //cout<<\"Case \"<<sum1<<\": \"<<summ<<endl; } }","title":"\u63d0\u793a"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_12","text":"\u73b0\u6709r\u4e2a\u4e92\u4e0d\u76f8\u540c\u7684\u76d2\u5b50\u548cn\u4e2a\u4e92\u4e0d\u76f8\u540c\u7684\u7403\uff0c\u8981\u5c06\u8fd9n\u4e2a\u7403\u653e\u5165r\u4e2a\u76d2\u5b50\u4e2d\uff0c\u4e14\u4e0d\u5141\u8bb8\u6709\u7a7a\u76d2\u5b50\u3002\u95ee\u6709\u591a\u5c11\u79cd\u65b9\u6cd5\uff1f \u4f8b\u5982\uff1a\u67092\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\uff08\u5206\u522b\u7f16\u4e3a1\u53f7\u548c2\u53f7\uff09\u548c3\u4e2a\u4e0d\u540c\u7684\u7403\uff08\u5206\u522b\u7f16\u4e3a1\u30012\u30013\u53f7\uff09\uff0c\u5219\u67096\u79cd\u4e0d\u540c\u7684\u65b9\u6cd5\uff1a","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_13","text":"\u4e24\u4e2a\u6574\u6570\uff0cn\u548cr\uff0c\u4e2d\u95f4\u7528\u7a7a\u683c\u5206\u9694\u3002\uff080\u2264n, r\u226410\uff09","title":"\u8f93\u5165"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_14","text":"\u4ec5\u4e00\u884c\uff0c\u4e00\u4e2a\u6574\u6570\uff08\u4fdd\u8bc1\u5728\u957f\u6574\u578b\u8303\u56f4\u5185\uff09\u3002\u8868\u793an\u4e2a\u7403\u653e\u5165r\u4e2a\u76d2\u5b50\u7684\u65b9\u6cd5\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_15","text":"3 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_16","text":"6","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-05%20%E5%88%92%E5%88%86%E6%A0%91%E6%B1%82%E6%9F%90%E4%B8%80%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#_17","text":"\u9996\u5148\u5c4f\u853d\u4e00\u4e2a\u6761\u4ef6->r\u4e2a\u76d2\u5b50\u4e92\u4e0d\u76f8\u540c,\u8bbe\u5b9a\u6211\u4eec\u5c06\u7b2ci\u4e2a\u7403\u5c06\u8981\u653e\u5230\u7b2ck\u4e2a\u76d2\u5b50\u91cc\uff08\u524di-1\u4e2a\u7403\u5df2\u7ecf\u5728\u524dk\u4e2a\u76d2\u5b50\u91cc\u653e\u597d\uff09\u4e8e\u662f\u6709\u5982\u4e0b\u9012\u63a8\u516c\u5f0f\uff1a s[i,k] = s[i-i,k-1]+s[i-1,k]*k \u4e5f\u5c31\u662f\u8bf4\u5bf9\u4e8e\u7b2ci\u4e2a\u7403\uff0c\u5f53\u7b2ck\u4e2a\u76d2\u5b50\u4e3a\u7a7a\u65f6\uff0c\u5c31\u5fc5\u987b\u8981\u653e\u5230\u7b2ck\u4e2a\u76d2\u5b50\u91cc\uff0c\u5f53\u7b2ck\u4e2a\u76d2\u5b50\u4e0d\u4e3a\u7a7a\u65f6\uff0c\u53ef\u4ee5\u4efb\u610f\u653e\u5230k\u4e2a\u76d2\u5b50\u5176\u4e2d\u7684\u4e00\u4e2a\u3002 #include <iostream> using namespace std ; const long long int N = 1e9 + 7 ; int a [ 100 ][ 100 ] = { 0 }; typedef long long ll ; int main () { int n , k ; cin >> n >> k ; for ( int i = 1 ; i <= 15 ; i ++ ) { a [ i ][ 1 ] = 1 ; } for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { a [ i ][ j ] = a [ i -1 ][ j ] * j + a [ i -1 ][ j -1 ]; } } for ( int i = 1 ; i <= k ; i ++ ) a [ n ][ k ] = a [ n ][ k ] * i ; cout << a [ n ][ k ] << endl ; return 0 ; }","title":"\u89e3\u6790"},{"location":"csdn/2020-09-07/","text":"http://icpc.upc.edu.cn/problem.php?cid=2564&pid=7 \u9898\u76ee\u63cf\u8ff0 \u00b6 You are working with a strange text editor for texts consisting only of open and close parentheses. The editor accepts the following three keys as editing commands to modify the text kept in it. \u00b7\u2018(\u2019 appends an open parenthesis (\u2018(\u2019) to the end of the text. \u00b7\u2018)\u2019 appends a close parenthesis (\u2018)\u2019) to the end of the text. \u00b7\u2018-\u2019 removes the last character of the text. A balanced string is one of the following. \u00b7\u201c()\u201d \u00b7\u201c(X)\u201d where X is a balanced string \u00b7\u201cXY\u201d where both X and Y are balanced strings Initially, the editor keeps an empty text. You are interested in the number of balanced substrings in the text kept in the editor after each of your key command inputs. Note that, for the same balanced substring occurring twice or more, their occurrences should be counted separately. Also note that, when some balanced substrings are inside a balanced substring, both the inner and outer balanced substrings should be counted. \u8f93\u5165 \u00b6 The input consists of a single test case given in a line containing a number of characters, each of which is a command key to the editor, that is, either \u2018(\u2019, \u2018)\u2019, or \u2018-\u2019. The number of characters does not exceed 200 000. They represent a key input sequence to the editor. It is guaranteed that no \u2018-\u2019 command comes when the text is empty. \u8f93\u51fa \u00b6 Print the numbers of balanced substrings in the text kept in the editor after each of the key command inputs are applied, each in one line. Thus, the number of output lines should be the same as the number of characters in the input line. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 (()())---) \u3010\u6837\u4f8b2\u3011 ()--()()----)(()())) \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 0 0 1 1 3 4 3 1 1 2 \u3010\u6837\u4f8b2\u3011 0 1 0 0 0 1 1 3 1 1 0 0 0 0 0 1 1 3 4 4 \u89e3\u6790 \u00b6 DP\u52a8\u6001\u89c4\u5212+\u5806\u6808+\u79bb\u6563\u5316\u5904\u7406 #include <bits/stdc++.h> using namespace std ; char a [ 300500 ] = { 0 }; stack < int > w ; int dp [ 300500 ] = { 0 }; int flag [ 300500 ] = { 0 }; int main () { scanf ( \"%s\" , a + 1 ); long long sum = 0 ; long long s = 1 ; for ( int i = 1 ; a [ i ]; i ++ ) { if ( a [ i ] == '(' ) { s ++ ; w . push ( s ); dp [ s ] = flag [ s ] = 0 ; } if ( a [ i ] == ')' ) { s ++ ; if ( ! w . empty ()) { int u = w . top (); w . pop (); dp [ s ] = dp [ u -1 ] + 1 ; flag [ s ] = u ; sum += dp [ s ]; } else { dp [ s ] = flag [ s ] = 0 ; } } if ( a [ i ] == '-' ) { sum -= dp [ s ]; while ( ! w . empty () && w . top () >= s ) w . pop (); if ( flag [ s ] != 0 ) w . push ( flag [ s ]); s -- ; } printf ( \"%lld \\n \" , sum ); } } http://icpc.upc.edu.cn/problem.php?cid=2573&pid=2 \u9898\u76ee\u63cf\u8ff0 \u00b6 It's easy for ACMer to calculate A^X mod P. Now given seven integers n, A, K, a, b, m, P, and a function f(x) which defined as following. f(x) = K, x = 1 f(x) = (a*f(x-1) + b)%m , x > 1 Now, Your task is to calculate ( A^(f(1)) + A^(f(2)) + A^(f(3)) + ...... + A^(f(n)) ) modular P. \u8f93\u5165 \u00b6 In the first line there is an integer T (1 < T <= 40), which indicates the number of test cases, and then T test cases follow. A test case contains seven integers n, A, K, a, b, m, P in one line. 1 <= n <= 10^6 0 <= A, K, a, b <= 10^9 1 <= m, P <= 10^9 \u8f93\u51fa \u00b6 For each case, the output format is \u201cCase #c: ans\u201d. c is the case number start from 1. ans is the answer of this problem. \u6837\u4f8b\u8f93\u5165 \u00b6 2 3 2 1 1 1 100 100 3 15 123 2 3 1000 107 \u6837\u4f8b\u8f93\u51fa \u00b6 Case #1: 14 Case #2: 63 \u53c2\u7167\u4e8e https://blog.csdn.net/Little_boy_z/article/details/80042689 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef unsigned long long ll ; int n , A , K , a , b , m , p ; ll dp1 [ 100500 ] = { 0 }; ll dp2 [ 100500 ] = { 0 }; int db () { dp1 [ 0 ] = dp2 [ 0 ] = 1 ; dp1 [ 1 ] = A % p ; for ( int i = 2 ; i <= 100000 ; i ++ ) { dp1 [ i ] = ( dp1 [ i -1 ] * dp1 [ 1 ]) % p ; } dp2 [ 1 ] = dp1 [ 100000 ]; for ( int i = 2 ; i <= 100000 ; i ++ ) { dp2 [ i ] = ( dp2 [ i -1 ] * dp2 [ 1 ]) % p ; } } int main () { int t ; cin >> t ; for ( int j = 1 ; j <= t ; j ++ ) { cin >> n >> A >> K >> a >> b >> m >> p ; cout << \"Case #\" << j << \": \" ; ll ans = 0 ; ll ans2 = K ; db (); for ( int i = 1 ; i <= n ; i ++ ) { ans += dp1 [ ans2 % 100000 ] * dp2 [ ans2 / 100000 ]; ans %= p ; ans2 = ( ans2 * a + b ) % m ; } cout << ans % p << endl ; } return 0 ; }","title":"2020-09-07"},{"location":"csdn/2020-09-07/#_1","text":"You are working with a strange text editor for texts consisting only of open and close parentheses. The editor accepts the following three keys as editing commands to modify the text kept in it. \u00b7\u2018(\u2019 appends an open parenthesis (\u2018(\u2019) to the end of the text. \u00b7\u2018)\u2019 appends a close parenthesis (\u2018)\u2019) to the end of the text. \u00b7\u2018-\u2019 removes the last character of the text. A balanced string is one of the following. \u00b7\u201c()\u201d \u00b7\u201c(X)\u201d where X is a balanced string \u00b7\u201cXY\u201d where both X and Y are balanced strings Initially, the editor keeps an empty text. You are interested in the number of balanced substrings in the text kept in the editor after each of your key command inputs. Note that, for the same balanced substring occurring twice or more, their occurrences should be counted separately. Also note that, when some balanced substrings are inside a balanced substring, both the inner and outer balanced substrings should be counted.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-07/#_2","text":"The input consists of a single test case given in a line containing a number of characters, each of which is a command key to the editor, that is, either \u2018(\u2019, \u2018)\u2019, or \u2018-\u2019. The number of characters does not exceed 200 000. They represent a key input sequence to the editor. It is guaranteed that no \u2018-\u2019 command comes when the text is empty.","title":"\u8f93\u5165"},{"location":"csdn/2020-09-07/#_3","text":"Print the numbers of balanced substrings in the text kept in the editor after each of the key command inputs are applied, each in one line. Thus, the number of output lines should be the same as the number of characters in the input line.","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-07/#_4","text":"\u3010\u6837\u4f8b1\u3011 (()())---) \u3010\u6837\u4f8b2\u3011 ()--()()----)(()()))","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-07/#_5","text":"\u3010\u6837\u4f8b1\u3011 0 0 1 1 3 4 3 1 1 2 \u3010\u6837\u4f8b2\u3011 0 1 0 0 0 1 1 3 1 1 0 0 0 0 0 1 1 3 4 4","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-07/#_6","text":"DP\u52a8\u6001\u89c4\u5212+\u5806\u6808+\u79bb\u6563\u5316\u5904\u7406 #include <bits/stdc++.h> using namespace std ; char a [ 300500 ] = { 0 }; stack < int > w ; int dp [ 300500 ] = { 0 }; int flag [ 300500 ] = { 0 }; int main () { scanf ( \"%s\" , a + 1 ); long long sum = 0 ; long long s = 1 ; for ( int i = 1 ; a [ i ]; i ++ ) { if ( a [ i ] == '(' ) { s ++ ; w . push ( s ); dp [ s ] = flag [ s ] = 0 ; } if ( a [ i ] == ')' ) { s ++ ; if ( ! w . empty ()) { int u = w . top (); w . pop (); dp [ s ] = dp [ u -1 ] + 1 ; flag [ s ] = u ; sum += dp [ s ]; } else { dp [ s ] = flag [ s ] = 0 ; } } if ( a [ i ] == '-' ) { sum -= dp [ s ]; while ( ! w . empty () && w . top () >= s ) w . pop (); if ( flag [ s ] != 0 ) w . push ( flag [ s ]); s -- ; } printf ( \"%lld \\n \" , sum ); } } http://icpc.upc.edu.cn/problem.php?cid=2573&pid=2","title":"\u89e3\u6790"},{"location":"csdn/2020-09-07/#_7","text":"It's easy for ACMer to calculate A^X mod P. Now given seven integers n, A, K, a, b, m, P, and a function f(x) which defined as following. f(x) = K, x = 1 f(x) = (a*f(x-1) + b)%m , x > 1 Now, Your task is to calculate ( A^(f(1)) + A^(f(2)) + A^(f(3)) + ...... + A^(f(n)) ) modular P.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-07/#_8","text":"In the first line there is an integer T (1 < T <= 40), which indicates the number of test cases, and then T test cases follow. A test case contains seven integers n, A, K, a, b, m, P in one line. 1 <= n <= 10^6 0 <= A, K, a, b <= 10^9 1 <= m, P <= 10^9","title":"\u8f93\u5165"},{"location":"csdn/2020-09-07/#_9","text":"For each case, the output format is \u201cCase #c: ans\u201d. c is the case number start from 1. ans is the answer of this problem.","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-07/#_10","text":"2 3 2 1 1 1 100 100 3 15 123 2 3 1000 107","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-07/#_11","text":"Case #1: 14 Case #2: 63 \u53c2\u7167\u4e8e https://blog.csdn.net/Little_boy_z/article/details/80042689 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef unsigned long long ll ; int n , A , K , a , b , m , p ; ll dp1 [ 100500 ] = { 0 }; ll dp2 [ 100500 ] = { 0 }; int db () { dp1 [ 0 ] = dp2 [ 0 ] = 1 ; dp1 [ 1 ] = A % p ; for ( int i = 2 ; i <= 100000 ; i ++ ) { dp1 [ i ] = ( dp1 [ i -1 ] * dp1 [ 1 ]) % p ; } dp2 [ 1 ] = dp1 [ 100000 ]; for ( int i = 2 ; i <= 100000 ; i ++ ) { dp2 [ i ] = ( dp2 [ i -1 ] * dp2 [ 1 ]) % p ; } } int main () { int t ; cin >> t ; for ( int j = 1 ; j <= t ; j ++ ) { cin >> n >> A >> K >> a >> b >> m >> p ; cout << \"Case #\" << j << \": \" ; ll ans = 0 ; ll ans2 = K ; db (); for ( int i = 1 ; i <= n ; i ++ ) { ans += dp1 [ ans2 % 100000 ] * dp2 [ ans2 / 100000 ]; ans %= p ; ans2 = ( ans2 * a + b ) % m ; } cout << ans % p << endl ; } return 0 ; }","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-08%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","text":"http://icpc.upc.edu.cn/problem.php?cid=2573&pid=4 \u9898\u76ee\u63cf\u8ff0 \u00b6 Coco is a beautiful ACMer girl living in a very beautiful mountain. There are many trees and flowers on the mountain, and there are many animals and birds also. Coco like the mountain so much that she now name some letter sequences as Mountain Subsequences. A Mountain Subsequence is defined as following: If the length of the subsequence is n, there should be a max value letter, and the subsequence should like this, a1 < ...< ai < ai+1 < Amax > aj > aj+1 > ... > an It should have at least 3 elements, and in the left of the max value letter there should have at least one element, the same as in the right. The value of the letter is the ASCII value. Given a letter sequence, Coco wants to know how many Mountain Subsequences exist. \u8f93\u5165 \u00b6 Input contains multiple test cases. For each case there is a number n (1<= n <= 100000) which means the length of the letter sequence in the first line, and the next line contains the letter sequence. Please note that the letter sequence only contain lowercase letters. \u8f93\u51fa \u00b6 For each case please output the number of the mountain subsequences module 2012. \u6837\u4f8b\u8f93\u5165 \u00b6 4 abca \u6837\u4f8b\u8f93\u51fa \u00b6 4 \u63d0\u793a \u00b6 The 4 mountain subsequences are: aba, aca, bca, abca \u7528\u6807\u8bb0\u6570\u7ec4\u7684\u65b9\u6cd5\u6765\u964d\u4f4e\u65f6\u95f4\u590d\u6742\u5ea6 AC\u4ee3\u7801 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef unsigned long long ull ; char a [ 100500 ] = { 0 }; ull dp2 [ 100500 ] = { 0 }; ull dp1 [ 100500 ] = { 0 }; ll w [ 200 ] = { 0 }; int main () { ll n ; while ( scanf ( \"%lld%s\" , & n , a + 1 ) != EOF ) { for ( int i = 0 ; i < 30 ; i ++ ) w [ i ] = 0 ; for ( register ll i = n ; i >= 1 ; i -- ) { dp2 [ i ] = 0 ; for ( char j = 'a' ; j < a [ i ]; j ++ ) { dp2 [ i ] += w [ j - 'a' ]; dp2 [ i ] %= 2012 ; } w [ a [ i ] - 'a' ] += dp2 [ i ] + 1 ; w [ a [ i ] - 'a' ] %= 2012 ; } for ( int i = 0 ; i < 30 ; i ++ ) w [ i ] = 0 ; register long long ans = 0 ; for ( register ll i = 1 ; i <= n ; i ++ ) { dp1 [ i ] = 0 ; for ( ll j = 'a' ; j < a [ i ]; j ++ ) { dp1 [ i ] += w [ j - 'a' ]; dp1 [ i ] %= 2012 ; } w [ a [ i ] - 'a' ] += dp1 [ i ] + 1 ; w [ a [ i ] - 'a' ] %= 2012 ; } for ( register ll i = 1 ; i <= n ; i ++ ) ans += ( dp1 [ i ] * dp2 [ i ]) % 2012 , ans %= 2012 ; printf ( \"%lld \\n \" , ans ); } return 0 ; } \u65f6\u95f4\u8d85\u9650 #pragma GCC optimize(2) #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef unsigned long long ull ; char a [ 100500 ] = { 0 }; ull dp1 [ 100500 ] = { 0 }; ull dp2 [ 100500 ] = { 0 }; int main () { ll n ; while ( scanf ( \"%lld%s\" , & n , a + 1 ) != EOF ) { for ( int i = 0 ; i <= n + 50 ; i ++ ) dp1 [ i ] = dp2 [ i ] = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 1 ; j < i ; j ++ ) if ( a [ j ] < a [ i ]) dp1 [ i ] = dp1 [ i ] + dp1 [ j ] + 1 ; } for ( ll i = n ; i >= 1 ; i -- ) { for ( ll j = n ; j > i ; j -- ) if ( a [ i ] > a [ j ]) dp2 [ i ] = dp2 [ i ] + dp2 [ j ] + 1 ; } long long ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { if ( dp1 [ i ] >= 1 && dp2 [ i ] >= 1 ) ans += dp1 [ i ] % 2012 * dp2 [ i ] % 2012 ; ans %= 2012 ; } cout << ans << endl ; } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2570&pid=8 \u9898\u76ee\u63cf\u8ff0 \u00b6 In China, there are two companies offering the Internet service for the people from all cities: China Telecom and China Unicom. They both are planning to build cables between cities. Obviously, the government wants to connect all the cities in minimum costs. So the minister of finance Mr. B wants to choose some of the cable plans from the two companies and calculate the minimum cost needed to connect all the cities. Mr. B knows that N-1 cables should be built in order to connect all N cities of China. For some honorable reason, Mr. B should choose K cables from the China Telecom and the rest N-1-K cables from the China Unicom. Your job is to help Mr. B determine which cables should be built and the minimum cost to build them. You may assume that the solution always exists. \u8f93\u5165 \u00b6 Each test case starts with a line containing the number of cities N (1 <= N <= 50,000), number of cable plans M (N-1 <= M <= 100,000) and the number of required cables from China Telecom K (0 <= K <= N-1). This is followed by M lines, each containing four integers a, b, c, x (0 <= a, b <= N-1, a != b, 1 <= c <= 100, x in {0,1} indicating the pair of cities this cable will connect, the cost to build this cable and the company this cable plan belongs to. x=0 denotes that the cable plan belongs to China Telecom and x=1 denotes that the cable plan is from China Unicom. \u8f93\u51fa \u00b6 For each test case, display the case number and the minimum cost of the cable building. \u6837\u4f8b\u8f93\u5165 \u00b6 2 2 1 0 1 1 1 0 1 2 0 2 2 0 0 1 1 1 0 1 2 0 \u6837\u4f8b\u8f93\u51fa \u00b6 Case 1: 2 Case 2: 1 \u63d0\u793a \u00b6 In the first case, there are two cable plans between the only two cities, one from China Telecom and one from China Unicom. Mr. B needs to choose the one from China Telecom to satisfy the problem requirement even the cost is higher. In the second case, Mr. B must choose the cable from China Unicom, which leads the answer to 1. \u4e8c\u5206+\u6700\u5c0f\u751f\u6210\u6811 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <iostream> #include <bits/stdc++.h> using namespace std ; int n , m , k , sum1 ; int fa [ 500500 ] = { 0 }; struct node { int x , y , z , t ; }; node a [ 500500 ] = { 0 }; bool cmp ( node a , node b ) { if ( a . z != b . z ) return a . z < b . z ; else return a . t < b . t ; } int findfa ( int x ) { if ( x == fa [ x ]) return x ; else return fa [ x ] = findfa ( fa [ x ]); } int add ( int x , int y ) { int fx = findfa ( x ); int fy = findfa ( y ); if ( fx != fy ) { fa [ fx ] = fy ; return 1 ; } return 0 ; } int pd ( int x ) { for ( int i = 1 ; i <= m ; i ++ ) if ( a [ i ]. t == 0 ) a [ i ]. z = a [ i ]. z + x ; for ( int i = 0 ; i <= n ; i ++ ) fa [ i ] = i ; sort ( a + 1 , a + m + 1 , cmp ); int sum = 0 , cnt = n -1 ; sum1 = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( add ( a [ i ]. x , a [ i ]. y )) { sum ++ ; cnt -= a [ i ]. t ; sum1 += a [ i ]. z ; } if ( sum == n -1 ) break ; } for ( int i = 1 ; i <= m ; i ++ ) { if ( a [ i ]. t == 0 ) { a [ i ]. z = a [ i ]. z - x ; } } return cnt >= k ; } int main () { int summ = 0 ; while ( scanf ( \"%d%d%d\" , & n , & m , & k ) != EOF ) { int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d%d%d\" , & a [ i ]. x , & a [ i ]. y , & a [ i ]. z , & a [ i ]. t ); } int l = -100 , r = 100 ; while ( l < r ) { int mid = ( l + r -1 ) / 2 ; if ( pd ( mid )) { l = mid + 1 ; ans = sum1 - k * mid ; } else { r = mid ; } } printf ( \"Case %d: %d \\n \" , ++ summ , ans ); } return 0 ; }","title":"2020 09 08 \u4e8c\u5206+\u6700\u5c0f\u751f\u6210\u6811"},{"location":"csdn/2020-09-08%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#_1","text":"Coco is a beautiful ACMer girl living in a very beautiful mountain. There are many trees and flowers on the mountain, and there are many animals and birds also. Coco like the mountain so much that she now name some letter sequences as Mountain Subsequences. A Mountain Subsequence is defined as following: If the length of the subsequence is n, there should be a max value letter, and the subsequence should like this, a1 < ...< ai < ai+1 < Amax > aj > aj+1 > ... > an It should have at least 3 elements, and in the left of the max value letter there should have at least one element, the same as in the right. The value of the letter is the ASCII value. Given a letter sequence, Coco wants to know how many Mountain Subsequences exist.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-08%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#_2","text":"Input contains multiple test cases. For each case there is a number n (1<= n <= 100000) which means the length of the letter sequence in the first line, and the next line contains the letter sequence. Please note that the letter sequence only contain lowercase letters.","title":"\u8f93\u5165"},{"location":"csdn/2020-09-08%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#_3","text":"For each case please output the number of the mountain subsequences module 2012.","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-08%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#_4","text":"4 abca","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-08%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#_5","text":"4","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-08%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#_6","text":"The 4 mountain subsequences are: aba, aca, bca, abca \u7528\u6807\u8bb0\u6570\u7ec4\u7684\u65b9\u6cd5\u6765\u964d\u4f4e\u65f6\u95f4\u590d\u6742\u5ea6 AC\u4ee3\u7801 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef unsigned long long ull ; char a [ 100500 ] = { 0 }; ull dp2 [ 100500 ] = { 0 }; ull dp1 [ 100500 ] = { 0 }; ll w [ 200 ] = { 0 }; int main () { ll n ; while ( scanf ( \"%lld%s\" , & n , a + 1 ) != EOF ) { for ( int i = 0 ; i < 30 ; i ++ ) w [ i ] = 0 ; for ( register ll i = n ; i >= 1 ; i -- ) { dp2 [ i ] = 0 ; for ( char j = 'a' ; j < a [ i ]; j ++ ) { dp2 [ i ] += w [ j - 'a' ]; dp2 [ i ] %= 2012 ; } w [ a [ i ] - 'a' ] += dp2 [ i ] + 1 ; w [ a [ i ] - 'a' ] %= 2012 ; } for ( int i = 0 ; i < 30 ; i ++ ) w [ i ] = 0 ; register long long ans = 0 ; for ( register ll i = 1 ; i <= n ; i ++ ) { dp1 [ i ] = 0 ; for ( ll j = 'a' ; j < a [ i ]; j ++ ) { dp1 [ i ] += w [ j - 'a' ]; dp1 [ i ] %= 2012 ; } w [ a [ i ] - 'a' ] += dp1 [ i ] + 1 ; w [ a [ i ] - 'a' ] %= 2012 ; } for ( register ll i = 1 ; i <= n ; i ++ ) ans += ( dp1 [ i ] * dp2 [ i ]) % 2012 , ans %= 2012 ; printf ( \"%lld \\n \" , ans ); } return 0 ; } \u65f6\u95f4\u8d85\u9650 #pragma GCC optimize(2) #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef unsigned long long ull ; char a [ 100500 ] = { 0 }; ull dp1 [ 100500 ] = { 0 }; ull dp2 [ 100500 ] = { 0 }; int main () { ll n ; while ( scanf ( \"%lld%s\" , & n , a + 1 ) != EOF ) { for ( int i = 0 ; i <= n + 50 ; i ++ ) dp1 [ i ] = dp2 [ i ] = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 1 ; j < i ; j ++ ) if ( a [ j ] < a [ i ]) dp1 [ i ] = dp1 [ i ] + dp1 [ j ] + 1 ; } for ( ll i = n ; i >= 1 ; i -- ) { for ( ll j = n ; j > i ; j -- ) if ( a [ i ] > a [ j ]) dp2 [ i ] = dp2 [ i ] + dp2 [ j ] + 1 ; } long long ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { if ( dp1 [ i ] >= 1 && dp2 [ i ] >= 1 ) ans += dp1 [ i ] % 2012 * dp2 [ i ] % 2012 ; ans %= 2012 ; } cout << ans << endl ; } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2570&pid=8","title":"\u63d0\u793a"},{"location":"csdn/2020-09-08%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#_7","text":"In China, there are two companies offering the Internet service for the people from all cities: China Telecom and China Unicom. They both are planning to build cables between cities. Obviously, the government wants to connect all the cities in minimum costs. So the minister of finance Mr. B wants to choose some of the cable plans from the two companies and calculate the minimum cost needed to connect all the cities. Mr. B knows that N-1 cables should be built in order to connect all N cities of China. For some honorable reason, Mr. B should choose K cables from the China Telecom and the rest N-1-K cables from the China Unicom. Your job is to help Mr. B determine which cables should be built and the minimum cost to build them. You may assume that the solution always exists.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-08%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#_8","text":"Each test case starts with a line containing the number of cities N (1 <= N <= 50,000), number of cable plans M (N-1 <= M <= 100,000) and the number of required cables from China Telecom K (0 <= K <= N-1). This is followed by M lines, each containing four integers a, b, c, x (0 <= a, b <= N-1, a != b, 1 <= c <= 100, x in {0,1} indicating the pair of cities this cable will connect, the cost to build this cable and the company this cable plan belongs to. x=0 denotes that the cable plan belongs to China Telecom and x=1 denotes that the cable plan is from China Unicom.","title":"\u8f93\u5165"},{"location":"csdn/2020-09-08%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#_9","text":"For each test case, display the case number and the minimum cost of the cable building.","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-08%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#_10","text":"2 2 1 0 1 1 1 0 1 2 0 2 2 0 0 1 1 1 0 1 2 0","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-08%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#_11","text":"Case 1: 2 Case 2: 1","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-08%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#_12","text":"In the first case, there are two cable plans between the only two cities, one from China Telecom and one from China Unicom. Mr. B needs to choose the one from China Telecom to satisfy the problem requirement even the cost is higher. In the second case, Mr. B must choose the cable from China Unicom, which leads the answer to 1. \u4e8c\u5206+\u6700\u5c0f\u751f\u6210\u6811 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <iostream> #include <bits/stdc++.h> using namespace std ; int n , m , k , sum1 ; int fa [ 500500 ] = { 0 }; struct node { int x , y , z , t ; }; node a [ 500500 ] = { 0 }; bool cmp ( node a , node b ) { if ( a . z != b . z ) return a . z < b . z ; else return a . t < b . t ; } int findfa ( int x ) { if ( x == fa [ x ]) return x ; else return fa [ x ] = findfa ( fa [ x ]); } int add ( int x , int y ) { int fx = findfa ( x ); int fy = findfa ( y ); if ( fx != fy ) { fa [ fx ] = fy ; return 1 ; } return 0 ; } int pd ( int x ) { for ( int i = 1 ; i <= m ; i ++ ) if ( a [ i ]. t == 0 ) a [ i ]. z = a [ i ]. z + x ; for ( int i = 0 ; i <= n ; i ++ ) fa [ i ] = i ; sort ( a + 1 , a + m + 1 , cmp ); int sum = 0 , cnt = n -1 ; sum1 = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( add ( a [ i ]. x , a [ i ]. y )) { sum ++ ; cnt -= a [ i ]. t ; sum1 += a [ i ]. z ; } if ( sum == n -1 ) break ; } for ( int i = 1 ; i <= m ; i ++ ) { if ( a [ i ]. t == 0 ) { a [ i ]. z = a [ i ]. z - x ; } } return cnt >= k ; } int main () { int summ = 0 ; while ( scanf ( \"%d%d%d\" , & n , & m , & k ) != EOF ) { int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d%d%d\" , & a [ i ]. x , & a [ i ]. y , & a [ i ]. z , & a [ i ]. t ); } int l = -100 , r = 100 ; while ( l < r ) { int mid = ( l + r -1 ) / 2 ; if ( pd ( mid )) { l = mid + 1 ; ans = sum1 - k * mid ; } else { r = mid ; } } printf ( \"Case %d: %d \\n \" , ++ summ , ans ); } return 0 ; }","title":"\u63d0\u793a"},{"location":"csdn/2020-09-08%20%E6%95%B0%E4%BD%8DDP%2B%E4%BA%8C%E5%88%86/","text":"http://icpc.upc.edu.cn/problem.php?cid=2573&pid=6 \u9898\u76ee\u63cf\u8ff0 \u00b6 Tom is very interested in number problem. Nowadays he is thinking of a problem about A-number and B-number. A-number is a positive integer whose decimal form contains 7 or it can be divided by 7. We can write down the first 10 A-number ( a[i] is the ith A-number) {a[1]=7,a[2]=14,a[3]=17,a[4]=21,a[5]=27,a[6]=28,a[7]=35,a[8]=37,a[9]=42,a[10]=47}; B-number is Sub-sequence of A-number which contains all A-number but a[k] ( that k is a A-number.) Like 35, is the 7 th A-number and 7 is also an A-number so the 35 ( a[7] ) is not a B-number. We also can write down the first 10 B-number. {b[1]=7,b[2]=14,b[3]=17,b[4]=21,b[5]=27,b[6]=28,b[7]=37,b[8]=42,b[9]=47,b[10]=49}; Now Given an integer N, please output the Nth B-number. \u8f93\u5165 \u00b6 The input consists of multiple test cases. For each test case, there will be a positive integer N as the description. \u8f93\u51fa \u00b6 For each test case, output an integer indicating the Nth B-number. You can assume the result will be no more then 2^63-1. \u6837\u4f8b\u8f93\u5165 \u00b6 1 7 100 \u6837\u4f8b\u8f93\u51fa \u00b6 7 37 470 \u6570\u4f4dDP+\u4e8c\u5206\u67e5\u627e https://www.cnblogs.com/shinecheng/p/3601235.html https://blog.csdn.net/weixin_33827965/article/details/93230896 #include <bits/stdc++.h> using namespace std ; typedef unsigned long long ll ; ///2^63-1 \u5efa\u8bae\u7528unsigned long long ll newx ; ll number [ 1005 ] = { 0 }; ll dp [ 1005 ][ 1005 ] = { 0 }; ll power [ 300 ] = { 0 }; inline ll dfs ( ll i , ll mod , int lim ) ///lim\u4e3a\u6807\u8bb0\u662f\u5426\u6709\u4e0a\u9650 { if ( i == 0 ) return mod == 0 ; if ( ! lim &&~ dp [ i ][ mod ]) /// ~(-1)=0 return dp [ i ][ mod ]; int end1 = lim ? number [ i ] : 9 ; ll ans = 0 ; for ( int j = 0 ; j <= end1 ; j ++ ) { if ( j != 7 ) ans += dfs ( i -1 ,( mod - ( j * power [ i -1 ]) % 7 + 7 ) % 7 , lim && j == end1 ); ///\u53d6\u4f59\u4e3a7\u7684\u60c5\u51b5 else if ( j == 7 ) ans += ( lim && j == end1 ) ? ( newx % power [ i -1 ] + 1 ) : power [ i -1 ]; ///\u9996\u4f4d\u4e3a7\u7684\u60c5\u51b5 } if ( ! lim ) ///\u6ca1\u6709\u9650\u5236 dp [ i ][ mod ] = ans ; return ans ; } ll js ( ll p ) { newx = p ; if ( p == 0 ) return 0 ; int k = 0 ; while ( p != 0 ) { number [ ++ k ] = p % 10 ; p = p / 10 ; } return dfs ( k , 0 , 1 ) -1 ; } ll out ( ll n ) { ll l = 1 , r = ( 1l l << 63 ) -1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ;; ll a = js ( mid ); ll b = a - js ( a ); if ( b >= n ) r = mid ; else l = mid + 1 ; } return l ; } int main () { power [ 0 ] = 1 ; for ( int i = 1 ; i <= 100 ; i ++ ) power [ i ] = power [ i -1 ] * 10 ; ll n ; for ( int i = 0 ; i < 200 ; i ++ ) for ( int j = 0 ; j < 200 ; j ++ ) dp [ i ][ j ] = -1 ; while ( scanf ( \"%lld\" , & n ) != EOF ) printf ( \"%lld \\n \" , out ( n )); }","title":"2020 09 08 \u6570\u4f4dDP+\u4e8c\u5206"},{"location":"csdn/2020-09-08%20%E6%95%B0%E4%BD%8DDP%2B%E4%BA%8C%E5%88%86/#_1","text":"Tom is very interested in number problem. Nowadays he is thinking of a problem about A-number and B-number. A-number is a positive integer whose decimal form contains 7 or it can be divided by 7. We can write down the first 10 A-number ( a[i] is the ith A-number) {a[1]=7,a[2]=14,a[3]=17,a[4]=21,a[5]=27,a[6]=28,a[7]=35,a[8]=37,a[9]=42,a[10]=47}; B-number is Sub-sequence of A-number which contains all A-number but a[k] ( that k is a A-number.) Like 35, is the 7 th A-number and 7 is also an A-number so the 35 ( a[7] ) is not a B-number. We also can write down the first 10 B-number. {b[1]=7,b[2]=14,b[3]=17,b[4]=21,b[5]=27,b[6]=28,b[7]=37,b[8]=42,b[9]=47,b[10]=49}; Now Given an integer N, please output the Nth B-number.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-08%20%E6%95%B0%E4%BD%8DDP%2B%E4%BA%8C%E5%88%86/#_2","text":"The input consists of multiple test cases. For each test case, there will be a positive integer N as the description.","title":"\u8f93\u5165"},{"location":"csdn/2020-09-08%20%E6%95%B0%E4%BD%8DDP%2B%E4%BA%8C%E5%88%86/#_3","text":"For each test case, output an integer indicating the Nth B-number. You can assume the result will be no more then 2^63-1.","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-08%20%E6%95%B0%E4%BD%8DDP%2B%E4%BA%8C%E5%88%86/#_4","text":"1 7 100","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-08%20%E6%95%B0%E4%BD%8DDP%2B%E4%BA%8C%E5%88%86/#_5","text":"7 37 470 \u6570\u4f4dDP+\u4e8c\u5206\u67e5\u627e https://www.cnblogs.com/shinecheng/p/3601235.html https://blog.csdn.net/weixin_33827965/article/details/93230896 #include <bits/stdc++.h> using namespace std ; typedef unsigned long long ll ; ///2^63-1 \u5efa\u8bae\u7528unsigned long long ll newx ; ll number [ 1005 ] = { 0 }; ll dp [ 1005 ][ 1005 ] = { 0 }; ll power [ 300 ] = { 0 }; inline ll dfs ( ll i , ll mod , int lim ) ///lim\u4e3a\u6807\u8bb0\u662f\u5426\u6709\u4e0a\u9650 { if ( i == 0 ) return mod == 0 ; if ( ! lim &&~ dp [ i ][ mod ]) /// ~(-1)=0 return dp [ i ][ mod ]; int end1 = lim ? number [ i ] : 9 ; ll ans = 0 ; for ( int j = 0 ; j <= end1 ; j ++ ) { if ( j != 7 ) ans += dfs ( i -1 ,( mod - ( j * power [ i -1 ]) % 7 + 7 ) % 7 , lim && j == end1 ); ///\u53d6\u4f59\u4e3a7\u7684\u60c5\u51b5 else if ( j == 7 ) ans += ( lim && j == end1 ) ? ( newx % power [ i -1 ] + 1 ) : power [ i -1 ]; ///\u9996\u4f4d\u4e3a7\u7684\u60c5\u51b5 } if ( ! lim ) ///\u6ca1\u6709\u9650\u5236 dp [ i ][ mod ] = ans ; return ans ; } ll js ( ll p ) { newx = p ; if ( p == 0 ) return 0 ; int k = 0 ; while ( p != 0 ) { number [ ++ k ] = p % 10 ; p = p / 10 ; } return dfs ( k , 0 , 1 ) -1 ; } ll out ( ll n ) { ll l = 1 , r = ( 1l l << 63 ) -1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ;; ll a = js ( mid ); ll b = a - js ( a ); if ( b >= n ) r = mid ; else l = mid + 1 ; } return l ; } int main () { power [ 0 ] = 1 ; for ( int i = 1 ; i <= 100 ; i ++ ) power [ i ] = power [ i -1 ] * 10 ; ll n ; for ( int i = 0 ; i < 200 ; i ++ ) for ( int j = 0 ; j < 200 ; j ++ ) dp [ i ][ j ] = -1 ; while ( scanf ( \"%lld\" , & n ) != EOF ) printf ( \"%lld \\n \" , out ( n )); }","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-09%20%E6%95%B0%E4%BD%8DDP/","text":"http://icpc.upc.edu.cn/problem.php?id=14643 \u9898\u76ee\u63cf\u8ff0 \u00b6 Find the number of integers between 1 and N (inclusive) that contains exactly K non-zero digits when written in base ten. Constraints \u00b71\u2264N<10100 \u00b71\u2264K\u22643 \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N K \u8f93\u51fa \u00b6 Print the count. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 100 1 \u3010\u6837\u4f8b2\u3011 25 2 \u3010\u6837\u4f8b3\u3011 314159 2 \u3010\u6837\u4f8b4\u3011 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 3 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 19 \u3010\u6837\u4f8b2\u3011 14 \u3010\u6837\u4f8b3\u3011 937 \u3010\u6837\u4f8b4\u3011 117879300 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca The following 19 integers satisfy the condition:1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100 \u6837\u4f8b2\u89e3\u91ca The following 14 integers satisfy the condition:11,12,13,14,15,16,17,18,19,21,22,23,24,25 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll dp [ 300 ][ 30 ] = { 0 }; char a [ 1005 ] = { 0 }; int main () { ll k ; scanf ( \"%s%lld\" , a + 1 , & k ); ll n = strlen ( a + 1 ); dp [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i <= 200 ; i ++ ) { dp [ i ][ 0 ] = dp [ i -1 ][ 0 ]; for ( int j = 1 ; j <= 20 ; j ++ ) dp [ i ][ j ] = dp [ i -1 ][ j ] + 9 * dp [ i -1 ][ j -1 ]; } ll sum = 0 , cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] > '0' && k - cnt >= 0 ) sum += dp [ n - i ][ k - cnt ]; if ( a [ i ] > '1' && k -1 - cnt >= 0 ) sum += ( a [ i ] - '0' -1 ) * dp [ n - i ][ k -1 - cnt ]; if ( a [ i ] > '0' ) cnt ++ ; } if ( cnt == k ) sum ++ ; cout << sum << endl ; }","title":"2020 09 09 \u6570\u4f4dDP"},{"location":"csdn/2020-09-09%20%E6%95%B0%E4%BD%8DDP/#_1","text":"Find the number of integers between 1 and N (inclusive) that contains exactly K non-zero digits when written in base ten. Constraints \u00b71\u2264N<10100 \u00b71\u2264K\u22643","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-09%20%E6%95%B0%E4%BD%8DDP/#_2","text":"Input is given from Standard Input in the following format: N K","title":"\u8f93\u5165"},{"location":"csdn/2020-09-09%20%E6%95%B0%E4%BD%8DDP/#_3","text":"Print the count.","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-09%20%E6%95%B0%E4%BD%8DDP/#_4","text":"\u3010\u6837\u4f8b1\u3011 100 1 \u3010\u6837\u4f8b2\u3011 25 2 \u3010\u6837\u4f8b3\u3011 314159 2 \u3010\u6837\u4f8b4\u3011 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-09%20%E6%95%B0%E4%BD%8DDP/#_5","text":"\u3010\u6837\u4f8b1\u3011 19 \u3010\u6837\u4f8b2\u3011 14 \u3010\u6837\u4f8b3\u3011 937 \u3010\u6837\u4f8b4\u3011 117879300","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-09%20%E6%95%B0%E4%BD%8DDP/#_6","text":"\u6837\u4f8b1\u89e3\u91ca The following 19 integers satisfy the condition:1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100 \u6837\u4f8b2\u89e3\u91ca The following 14 integers satisfy the condition:11,12,13,14,15,16,17,18,19,21,22,23,24,25 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll dp [ 300 ][ 30 ] = { 0 }; char a [ 1005 ] = { 0 }; int main () { ll k ; scanf ( \"%s%lld\" , a + 1 , & k ); ll n = strlen ( a + 1 ); dp [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i <= 200 ; i ++ ) { dp [ i ][ 0 ] = dp [ i -1 ][ 0 ]; for ( int j = 1 ; j <= 20 ; j ++ ) dp [ i ][ j ] = dp [ i -1 ][ j ] + 9 * dp [ i -1 ][ j -1 ]; } ll sum = 0 , cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] > '0' && k - cnt >= 0 ) sum += dp [ n - i ][ k - cnt ]; if ( a [ i ] > '1' && k -1 - cnt >= 0 ) sum += ( a [ i ] - '0' -1 ) * dp [ n - i ][ k -1 - cnt ]; if ( a [ i ] > '0' ) cnt ++ ; } if ( cnt == k ) sum ++ ; cout << sum << endl ; }","title":"\u63d0\u793a"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/","text":"http://icpc.upc.edu.cn/status.php?user_id=2019UPC135&cid=1461 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u73b0\u5728\u8bf7\u6c42\u4f60\u7ef4\u62a4\u4e00\u4e2a\u6570\u5217\uff0c\u8981\u6c42\u63d0\u4f9b\u4ee5\u4e0b\u4e24\u79cd\u64cd\u4f5c\uff1a1\u3001\u67e5\u8be2\u64cd\u4f5c\u3002\u8bed\u6cd5\uff1aQL\u529f\u80fd\uff1a\u67e5\u8be2\u5f53\u524d\u6570\u5217\u4e2d\u672b\u5c3eL\u4e2a\u6570\u4e2d\u7684\u6700\u5927\u7684\u6570\uff0c\u5e76\u8f93\u51fa\u8fd9\u4e2a\u6570\u7684\u503c\u3002\u9650\u5236\uff1aL\u4e0d\u8d85\u8fc7\u5f53\u524d\u6570\u5217\u7684\u957f\u5ea6\u30022\u3001\u63d2\u5165\u64cd\u4f5c\u3002\u8bed\u6cd5\uff1aAn\u529f\u80fd\uff1a\u5c06n\u52a0\u4e0at\uff0c\u5176\u4e2dt\u662f\u6700\u8fd1\u4e00\u6b21\u67e5\u8be2\u64cd\u4f5c\u7684\u7b54\u6848\uff08\u5982\u679c\u8fd8\u672a\u6267\u884c\u8fc7\u67e5\u8be2\u64cd\u4f5c\uff0c\u5219t=0)\uff0c\u5e76\u5c06\u6240\u5f97\u7ed3\u679c\u5bf9\u4e00\u4e2a\u56fa\u5b9a\u7684\u5e38\u6570D\u53d6\u6a21\uff0c\u5c06\u6240\u5f97\u7b54\u6848\u63d2\u5165\u5230\u6570\u5217\u7684\u672b\u5c3e\u3002\u9650\u5236\uff1an\u662f\u975e\u8d1f\u6574\u6570\u5e76\u4e14\u5728\u957f\u6574\u8303\u56f4\u5185\u3002\u6ce8\u610f\uff1a\u521d\u59cb\u65f6\u6570\u5217\u662f\u7a7a\u7684\uff0c\u6ca1\u6709\u4e00\u4e2a\u6570\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e24\u4e2a\u6574\u6570\uff0cM\u548cD\uff0c\u5176\u4e2dM\u8868\u793a\u64cd\u4f5c\u7684\u4e2a\u6570(M <= 200,000)\uff0cD\u5982\u4e0a\u6587\u4e2d\u6240\u8ff0\uff0c\u6ee1\u8db3D\u5728longint\u5185\u3002\u63a5\u4e0b\u6765M\u884c\uff0c\u67e5\u8be2\u64cd\u4f5c\u6216\u8005\u63d2\u5165\u64cd\u4f5c\u3002 \u8f93\u51fa \u00b6 \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8be2\u95ee\u64cd\u4f5c\uff0c\u8f93\u51fa\u4e00\u884c\u3002\u8be5\u884c\u53ea\u6709\u4e00\u4e2a\u6570\uff0c\u5373\u5e8f\u5217\u4e2d\u6700\u540eL\u4e2a\u6570\u7684\u6700\u5927\u6570\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 5 100 A 96 Q 1 A 97 Q 1 Q 2 \u6837\u4f8b\u8f93\u51fa \u00b6 96 93 96 \u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u6570\u7ec4\u6c42\u6700\u503c \u9644\u4e00\u5f20\u56fe\u5e2e\u52a9\u7406\u89e3\u4ee3\u7801 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f using namespace std ; typedef long long ll ; ll c [ 400500 ] = { 0 }; ll h [ 400500 ] = { 0 }; ll lowbit ( ll x ) { return x & ( - x ); } ll getmax ( ll l , ll r ) { ll max1 = h [ r ]; while ( l <= r ) { max1 = max ( max1 , h [ r ]); for ( -- r ; r - l >= lowbit ( r ); r -= lowbit ( r )) max1 = max ( max1 , c [ r ]); } return max1 ; } char s [ 100 ]; int main () { ll n , d , a , t = 0 , cnt = 0 ; scanf ( \"%lld%lld\" , & n , & d ); while ( n -- ) { scanf ( \"%s%lld\" , s , & a ); if ( s [ 0 ] == 'A' ) { h [ ++ cnt ] = ( a + t ) % d ; c [ cnt ] = max ( getmax ( cnt - lowbit ( cnt ) + 1 , cnt -1 ), h [ cnt ]); } else { t = getmax ( cnt - a + 1 , cnt ); printf ( \"%d \\n \" , t ); } } } \u5355\u70b9\u4fee\u6539+\u533a\u95f4\u67e5\u8be2\u6c42\u548c \u00b6 \u9898\u76ee \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u5b57n\uff0c\u8868\u793a\u6570\u7ec4\u5927\u5c0f\uff0c\u540e\u6709n\u4e2a\u6570\u5b57\uff0c\u8868\u793a\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u6570\u5b57\u7684\u521d\u59cb\u503c\uff0c\u7136\u540e\u8fdb\u884cm\u6b21\u64cd\u4f5c\uff0c\u2018Q\u2019\u4ee3\u8868\u67e5\u8be2\uff0c\u67e5\u8be2\u67d0\u4e00\u533a\u95f4\u6240\u6709\u5143\u7d20\u7684\u548c\uff0c\u2018C\u2019\u4ee3\u8868\u4fee\u6539\uff0c\u5728\u67d0\u4e00\u5143\u7d20\u4e0a\u52a0\u4e0a\u503c\u3002 \u8f93\u5165 \u00b6 10 7 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 Q 2 4 C 2 4 Q 2 4 \u8f93\u51fa \u00b6 4 55 9 15 18 \u6811\u72b6\u6570\u7ec4\u5355\u70b9\u4fee\u6539+\u533a\u95f4\u6c42\u548c #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n , m ; ll h [ 100500 ] = { 0 }; ll c [ 100500 ] = { 0 }; ll lowbit ( ll x ) { return x & ( - x ); } ll add ( ll x , ll a ) { while ( x <= n ) { c [ x ] += a ; x += lowbit ( x ); } } ll getsum ( ll l ) { ll sum = 0 ; while ( l > 0 ) { sum += c [ l ]; l -= lowbit ( l ); } return sum ; } int main () { scanf ( \"%lld%lld\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & h [ i ]); add ( h [ i ], i ); } char a [ 100 ]; ll b , c ; while ( m -- ) { scanf ( \"%s%lld%lld\" , a , & b , & c ); if ( a [ 0 ] == 'Q' ) { printf ( \"%lld \\n \" , getsum ( c ) - getsum ( b -1 )); } else { add ( b , c ); } } return 0 ; } \u533a\u95f4\u4fee\u6539+\u533a\u95f4\u67e5\u8be2 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=1461&pid=13 \u9898\u76ee\u63cf\u8ff0 \u00b6 You have N integers, A1, A2, ... , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. \u8f93\u5165 \u00b6 The first line contains two numbers N and Q. 1 \u2264 N,Q \u2264 100000. The second line contains N numbers, the initial values of A1, A2, ... , AN. -1000000000 \u2264 Ai \u2264 1000000000. Each of the next Q lines represents an operation. \"C a b c\" means adding c to each of Aa, Aa+1, ... , Ab. -10000 \u2264 c \u2264 10000. \"Q a b\" means querying the sum of Aa, Aa+1, ... , Ab. \u8f93\u51fa \u00b6 You need to answer all Q commands in order. One answer in a line. \u6837\u4f8b\u8f93\u5165 \u00b6 10 5 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 3 Q 2 4 \u6837\u4f8b\u8f93\u51fa \u00b6 4 55 9 15 \u63d0\u793a The sums may exceed the range of 32-bit integers. #include <bits/stdc++.h> #define inf 0x3f3f3f using namespace std ; typedef long long ll ; ll num [ 400500 ] = { 0 }; ll sum [ 400500 ] = { 0 }; ll lazy [ 400500 ] = { 0 }; ll n , m , b , c , d ; ll pushup ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } ll pushlazy ( ll t , ll lz , ll len ) { sum [ t ] += lz * len ; lazy [ t ] += lz ; } ll pushdown ( ll l , ll r , ll t ) { if ( lazy [ t ] != 0 ) { ll mid = ( l + r ) / 2 ; pushlazy ( 2 * t , lazy [ t ], mid - l + 1 ); pushlazy ( 2 * t + 1 , lazy [ t ], r - mid ); lazy [ t ] = 0 ; } } ll build ( ll l , ll r , ll t ) { lazy [ t ] = 0 ; if ( l == r ) { sum [ t ] = num [ l ]; return 0 ; } ll mid = ( l + r ) / 2 ; build ( l , mid , t * 2 ); build ( mid + 1 , r , 2 * t + 1 ); pushup ( t ); } ll add ( ll x , ll l , ll r , ll L , ll R , ll t ) { if ( l >= L && r <= R ) { lazy [ t ] += x ; sum [ t ] += ( r - l + 1 ) * x ; return 0 ; } pushdown ( l , r , t ); ll mid = ( l + r ) / 2 ; if ( L <= mid ) add ( x , l , mid , L , R , 2 * t ); if ( R > mid ) add ( x , mid + 1 , r , L , R , 2 * t + 1 ); pushup ( t ); } ll querysum ( ll l , ll r , ll L , ll R , ll t ) { if ( l >= L && r <= R ) return sum [ t ]; pushdown ( l , r , t ); ll mid = ( l + r ) / 2 ; ll ans = 0 ; if ( L <= mid ) ans += querysum ( l , mid , L , R , 2 * t ); if ( R > mid ) ans += querysum ( mid + 1 , r , L , R , 2 * t + 1 ); return ans ; } int main () { scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & num [ i ]); build ( 1 , n , 1 ); char a [ 100 ] = { 0 }; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s\" , a ); if ( a [ 0 ] == 'C' ) { scanf ( \"%lld%lld%lld\" , & b , & c , & d ); add ( d , 1 , n , b , c , 1 ); } else { scanf ( \"%lld%lld\" , & b , & c ); printf ( \"%lld \\n \" , querysum ( 1 , n , b , c , 1 )); } } }","title":"2020 09 11 \u6811\u72b6\u6570\u7ec4\u6c42\u6700\u5927\u503c"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_1","text":"\u73b0\u5728\u8bf7\u6c42\u4f60\u7ef4\u62a4\u4e00\u4e2a\u6570\u5217\uff0c\u8981\u6c42\u63d0\u4f9b\u4ee5\u4e0b\u4e24\u79cd\u64cd\u4f5c\uff1a1\u3001\u67e5\u8be2\u64cd\u4f5c\u3002\u8bed\u6cd5\uff1aQL\u529f\u80fd\uff1a\u67e5\u8be2\u5f53\u524d\u6570\u5217\u4e2d\u672b\u5c3eL\u4e2a\u6570\u4e2d\u7684\u6700\u5927\u7684\u6570\uff0c\u5e76\u8f93\u51fa\u8fd9\u4e2a\u6570\u7684\u503c\u3002\u9650\u5236\uff1aL\u4e0d\u8d85\u8fc7\u5f53\u524d\u6570\u5217\u7684\u957f\u5ea6\u30022\u3001\u63d2\u5165\u64cd\u4f5c\u3002\u8bed\u6cd5\uff1aAn\u529f\u80fd\uff1a\u5c06n\u52a0\u4e0at\uff0c\u5176\u4e2dt\u662f\u6700\u8fd1\u4e00\u6b21\u67e5\u8be2\u64cd\u4f5c\u7684\u7b54\u6848\uff08\u5982\u679c\u8fd8\u672a\u6267\u884c\u8fc7\u67e5\u8be2\u64cd\u4f5c\uff0c\u5219t=0)\uff0c\u5e76\u5c06\u6240\u5f97\u7ed3\u679c\u5bf9\u4e00\u4e2a\u56fa\u5b9a\u7684\u5e38\u6570D\u53d6\u6a21\uff0c\u5c06\u6240\u5f97\u7b54\u6848\u63d2\u5165\u5230\u6570\u5217\u7684\u672b\u5c3e\u3002\u9650\u5236\uff1an\u662f\u975e\u8d1f\u6574\u6570\u5e76\u4e14\u5728\u957f\u6574\u8303\u56f4\u5185\u3002\u6ce8\u610f\uff1a\u521d\u59cb\u65f6\u6570\u5217\u662f\u7a7a\u7684\uff0c\u6ca1\u6709\u4e00\u4e2a\u6570\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_2","text":"\u7b2c\u4e00\u884c\u4e24\u4e2a\u6574\u6570\uff0cM\u548cD\uff0c\u5176\u4e2dM\u8868\u793a\u64cd\u4f5c\u7684\u4e2a\u6570(M <= 200,000)\uff0cD\u5982\u4e0a\u6587\u4e2d\u6240\u8ff0\uff0c\u6ee1\u8db3D\u5728longint\u5185\u3002\u63a5\u4e0b\u6765M\u884c\uff0c\u67e5\u8be2\u64cd\u4f5c\u6216\u8005\u63d2\u5165\u64cd\u4f5c\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_3","text":"\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8be2\u95ee\u64cd\u4f5c\uff0c\u8f93\u51fa\u4e00\u884c\u3002\u8be5\u884c\u53ea\u6709\u4e00\u4e2a\u6570\uff0c\u5373\u5e8f\u5217\u4e2d\u6700\u540eL\u4e2a\u6570\u7684\u6700\u5927\u6570\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_4","text":"5 100 A 96 Q 1 A 97 Q 1 Q 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_5","text":"96 93 96 \u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u6570\u7ec4\u6c42\u6700\u503c \u9644\u4e00\u5f20\u56fe\u5e2e\u52a9\u7406\u89e3\u4ee3\u7801 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f using namespace std ; typedef long long ll ; ll c [ 400500 ] = { 0 }; ll h [ 400500 ] = { 0 }; ll lowbit ( ll x ) { return x & ( - x ); } ll getmax ( ll l , ll r ) { ll max1 = h [ r ]; while ( l <= r ) { max1 = max ( max1 , h [ r ]); for ( -- r ; r - l >= lowbit ( r ); r -= lowbit ( r )) max1 = max ( max1 , c [ r ]); } return max1 ; } char s [ 100 ]; int main () { ll n , d , a , t = 0 , cnt = 0 ; scanf ( \"%lld%lld\" , & n , & d ); while ( n -- ) { scanf ( \"%s%lld\" , s , & a ); if ( s [ 0 ] == 'A' ) { h [ ++ cnt ] = ( a + t ) % d ; c [ cnt ] = max ( getmax ( cnt - lowbit ( cnt ) + 1 , cnt -1 ), h [ cnt ]); } else { t = getmax ( cnt - a + 1 , cnt ); printf ( \"%d \\n \" , t ); } } }","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_6","text":"","title":"\u5355\u70b9\u4fee\u6539+\u533a\u95f4\u67e5\u8be2\u6c42\u548c"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_7","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u5b57n\uff0c\u8868\u793a\u6570\u7ec4\u5927\u5c0f\uff0c\u540e\u6709n\u4e2a\u6570\u5b57\uff0c\u8868\u793a\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u6570\u5b57\u7684\u521d\u59cb\u503c\uff0c\u7136\u540e\u8fdb\u884cm\u6b21\u64cd\u4f5c\uff0c\u2018Q\u2019\u4ee3\u8868\u67e5\u8be2\uff0c\u67e5\u8be2\u67d0\u4e00\u533a\u95f4\u6240\u6709\u5143\u7d20\u7684\u548c\uff0c\u2018C\u2019\u4ee3\u8868\u4fee\u6539\uff0c\u5728\u67d0\u4e00\u5143\u7d20\u4e0a\u52a0\u4e0a\u503c\u3002","title":"\u9898\u76ee"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_8","text":"10 7 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 Q 2 4 C 2 4 Q 2 4","title":"\u8f93\u5165"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_9","text":"4 55 9 15 18 \u6811\u72b6\u6570\u7ec4\u5355\u70b9\u4fee\u6539+\u533a\u95f4\u6c42\u548c #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n , m ; ll h [ 100500 ] = { 0 }; ll c [ 100500 ] = { 0 }; ll lowbit ( ll x ) { return x & ( - x ); } ll add ( ll x , ll a ) { while ( x <= n ) { c [ x ] += a ; x += lowbit ( x ); } } ll getsum ( ll l ) { ll sum = 0 ; while ( l > 0 ) { sum += c [ l ]; l -= lowbit ( l ); } return sum ; } int main () { scanf ( \"%lld%lld\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & h [ i ]); add ( h [ i ], i ); } char a [ 100 ]; ll b , c ; while ( m -- ) { scanf ( \"%s%lld%lld\" , a , & b , & c ); if ( a [ 0 ] == 'Q' ) { printf ( \"%lld \\n \" , getsum ( c ) - getsum ( b -1 )); } else { add ( b , c ); } } return 0 ; }","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_10","text":"http://icpc.upc.edu.cn/problem.php?cid=1461&pid=13","title":"\u533a\u95f4\u4fee\u6539+\u533a\u95f4\u67e5\u8be2"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_11","text":"You have N integers, A1, A2, ... , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_12","text":"The first line contains two numbers N and Q. 1 \u2264 N,Q \u2264 100000. The second line contains N numbers, the initial values of A1, A2, ... , AN. -1000000000 \u2264 Ai \u2264 1000000000. Each of the next Q lines represents an operation. \"C a b c\" means adding c to each of Aa, Aa+1, ... , Ab. -10000 \u2264 c \u2264 10000. \"Q a b\" means querying the sum of Aa, Aa+1, ... , Ab.","title":"\u8f93\u5165"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_13","text":"You need to answer all Q commands in order. One answer in a line.","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_14","text":"10 5 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 3 Q 2 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-11%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC/#_15","text":"4 55 9 15 \u63d0\u793a The sums may exceed the range of 32-bit integers. #include <bits/stdc++.h> #define inf 0x3f3f3f using namespace std ; typedef long long ll ; ll num [ 400500 ] = { 0 }; ll sum [ 400500 ] = { 0 }; ll lazy [ 400500 ] = { 0 }; ll n , m , b , c , d ; ll pushup ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } ll pushlazy ( ll t , ll lz , ll len ) { sum [ t ] += lz * len ; lazy [ t ] += lz ; } ll pushdown ( ll l , ll r , ll t ) { if ( lazy [ t ] != 0 ) { ll mid = ( l + r ) / 2 ; pushlazy ( 2 * t , lazy [ t ], mid - l + 1 ); pushlazy ( 2 * t + 1 , lazy [ t ], r - mid ); lazy [ t ] = 0 ; } } ll build ( ll l , ll r , ll t ) { lazy [ t ] = 0 ; if ( l == r ) { sum [ t ] = num [ l ]; return 0 ; } ll mid = ( l + r ) / 2 ; build ( l , mid , t * 2 ); build ( mid + 1 , r , 2 * t + 1 ); pushup ( t ); } ll add ( ll x , ll l , ll r , ll L , ll R , ll t ) { if ( l >= L && r <= R ) { lazy [ t ] += x ; sum [ t ] += ( r - l + 1 ) * x ; return 0 ; } pushdown ( l , r , t ); ll mid = ( l + r ) / 2 ; if ( L <= mid ) add ( x , l , mid , L , R , 2 * t ); if ( R > mid ) add ( x , mid + 1 , r , L , R , 2 * t + 1 ); pushup ( t ); } ll querysum ( ll l , ll r , ll L , ll R , ll t ) { if ( l >= L && r <= R ) return sum [ t ]; pushdown ( l , r , t ); ll mid = ( l + r ) / 2 ; ll ans = 0 ; if ( L <= mid ) ans += querysum ( l , mid , L , R , 2 * t ); if ( R > mid ) ans += querysum ( mid + 1 , r , L , R , 2 * t + 1 ); return ans ; } int main () { scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & num [ i ]); build ( 1 , n , 1 ); char a [ 100 ] = { 0 }; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s\" , a ); if ( a [ 0 ] == 'C' ) { scanf ( \"%lld%lld%lld\" , & b , & c , & d ); add ( d , 1 , n , b , c , 1 ); } else { scanf ( \"%lld%lld\" , & b , & c ); printf ( \"%lld \\n \" , querysum ( 1 , n , b , c , 1 )); } } }","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-12%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/","text":"http://icpc.upc.edu.cn/problem.php?cid=2569&pid=6 \u9898\u76ee\u63cf\u8ff0 \u00b6 It is now far into the future and human civilization is ancient history. Archaeologists from a distant planet have recently discovered Earth. Among many other things, they want to decipher the English language. They have collected many printed documents to form a dictionary, but are aware that sometimes words are not spelled correctly (typos are a universal problem). They want to classify each word in the dictionary as either correct or a typo. Na\u00efvely, they do this using a simple rule: a typo is any word in the dictionary such that deleting a single character from that word produces another word in the dictionary. Help these alien archaeologists out! Given a dictionary of words, determine which words are typos. That is,which words result in another word in the dictionary after deleting a single character. For example if our dictionary is {hoose, hose, nose, noises}. Then hoose is a typo because we can obtain hose by deleting a single \u2019o\u2019 from hoose. But noises is not a typo because deleting any single character does not result in another word in the dictionary. However, if our dictionary is {hoose, hose, nose, noises, noise} then the typos are hoose, noises,and noise. \u8f93\u5165 \u00b6 The \ufb01rst line of input contains a single integer n, indicating the number of words in the dictionary. The next n lines describe the dictionary. The ith of which contains the ith word in the dictionary. Each word consists only of lowercase English letters. All words are unique. The total length of all strings is at most 1 000 000. \u8f93\u51fa \u00b6 Display the words that are typos in the dictionary. These should be output in the same order they appear in the input. If there are no typos, simply display the phrase NO TYPOS. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 5 hoose hose nose noises noise \u3010\u6837\u4f8b2\u3011 4 hose hoose oose moose \u3010\u6837\u4f8b3\u3011 5 banana bananana bannanaa orange orangers \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 hoose noises noise \u3010\u6837\u4f8b2\u3011 hoose moose \u3010\u6837\u4f8b3\u3011 NO TYPOS \u89e3\u6790 \u00b6 \u5b57\u7b26\u4e32\u54c8\u5e0c #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; char a [ 2000500 ] = { 0 }; typedef unsigned long long ll ; char b [ 2000500 ] = { 0 }; ll h [ 2000500 ] = { 0 }; ll p [ 2000500 ] = { 0 }; int base = 31 ; map < ll , int > w ; vector < int > q ; ll get ( ll l , ll r ) { //cout<<l<<' '<<r<<' '<<h[r]-h[l-1]*p[r-l+1]<<endl; return h [ r ] - h [ l -1 ] * p [ r - l + 1 ]; } int main () { ios :: sync_with_stdio ( false ); cout . tie ( NULL ); int n ; scanf ( \"%d\" , & n ); a [ 0 ] = ' ' ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , b ); b [ strlen ( b ) + 1 ] = '\\0' ; b [ strlen ( b )] = ' ' ; strcat ( a , b ); } p [ 0 ] = 1 ; for ( int i = 0 ; a [ i ]; i ++ ) { if ( a [ i ] == ' ' ) { q . push_back ( i ); if ( i != 0 ) w [ h [ i -1 ]] = 1 ; } else { h [ i ] = h [ i -1 ] * base + a [ i ] - 'a' + 1 ; } if ( i != 0 ) p [ i ] = p [ i -1 ] * base ; } int flag = 1 ; for ( int i = 0 ; i < q . size () -1 ; i ++ ) { for ( int j = q [ i ] + 1 ; j < q [ i + 1 ]; j ++ ) { ll sum2 = h [ j -1 ] * p [ q [ i + 1 ] - j -1 ] + get ( j + 1 , q [ i + 1 ] -1 ); if ( w [ sum2 ]) { for ( int k = q [ i ] + 1 ; k < q [ i + 1 ]; k ++ ) { printf ( \"%c\" , a [ k ]); } printf ( \" \\n \" ); flag = 0 ; break ; } } } if ( flag ) { printf ( \"NO TYPOS \\n \" ); } return 0 ; }","title":"2020 09 12 \u5b57\u7b26\u4e32\u54c8\u5e0c"},{"location":"csdn/2020-09-12%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/#_1","text":"It is now far into the future and human civilization is ancient history. Archaeologists from a distant planet have recently discovered Earth. Among many other things, they want to decipher the English language. They have collected many printed documents to form a dictionary, but are aware that sometimes words are not spelled correctly (typos are a universal problem). They want to classify each word in the dictionary as either correct or a typo. Na\u00efvely, they do this using a simple rule: a typo is any word in the dictionary such that deleting a single character from that word produces another word in the dictionary. Help these alien archaeologists out! Given a dictionary of words, determine which words are typos. That is,which words result in another word in the dictionary after deleting a single character. For example if our dictionary is {hoose, hose, nose, noises}. Then hoose is a typo because we can obtain hose by deleting a single \u2019o\u2019 from hoose. But noises is not a typo because deleting any single character does not result in another word in the dictionary. However, if our dictionary is {hoose, hose, nose, noises, noise} then the typos are hoose, noises,and noise.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-12%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/#_2","text":"The \ufb01rst line of input contains a single integer n, indicating the number of words in the dictionary. The next n lines describe the dictionary. The ith of which contains the ith word in the dictionary. Each word consists only of lowercase English letters. All words are unique. The total length of all strings is at most 1 000 000.","title":"\u8f93\u5165"},{"location":"csdn/2020-09-12%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/#_3","text":"Display the words that are typos in the dictionary. These should be output in the same order they appear in the input. If there are no typos, simply display the phrase NO TYPOS.","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-12%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/#_4","text":"\u3010\u6837\u4f8b1\u3011 5 hoose hose nose noises noise \u3010\u6837\u4f8b2\u3011 4 hose hoose oose moose \u3010\u6837\u4f8b3\u3011 5 banana bananana bannanaa orange orangers","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-12%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/#_5","text":"\u3010\u6837\u4f8b1\u3011 hoose noises noise \u3010\u6837\u4f8b2\u3011 hoose moose \u3010\u6837\u4f8b3\u3011 NO TYPOS","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-12%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/#_6","text":"\u5b57\u7b26\u4e32\u54c8\u5e0c #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; char a [ 2000500 ] = { 0 }; typedef unsigned long long ll ; char b [ 2000500 ] = { 0 }; ll h [ 2000500 ] = { 0 }; ll p [ 2000500 ] = { 0 }; int base = 31 ; map < ll , int > w ; vector < int > q ; ll get ( ll l , ll r ) { //cout<<l<<' '<<r<<' '<<h[r]-h[l-1]*p[r-l+1]<<endl; return h [ r ] - h [ l -1 ] * p [ r - l + 1 ]; } int main () { ios :: sync_with_stdio ( false ); cout . tie ( NULL ); int n ; scanf ( \"%d\" , & n ); a [ 0 ] = ' ' ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , b ); b [ strlen ( b ) + 1 ] = '\\0' ; b [ strlen ( b )] = ' ' ; strcat ( a , b ); } p [ 0 ] = 1 ; for ( int i = 0 ; a [ i ]; i ++ ) { if ( a [ i ] == ' ' ) { q . push_back ( i ); if ( i != 0 ) w [ h [ i -1 ]] = 1 ; } else { h [ i ] = h [ i -1 ] * base + a [ i ] - 'a' + 1 ; } if ( i != 0 ) p [ i ] = p [ i -1 ] * base ; } int flag = 1 ; for ( int i = 0 ; i < q . size () -1 ; i ++ ) { for ( int j = q [ i ] + 1 ; j < q [ i + 1 ]; j ++ ) { ll sum2 = h [ j -1 ] * p [ q [ i + 1 ] - j -1 ] + get ( j + 1 , q [ i + 1 ] -1 ); if ( w [ sum2 ]) { for ( int k = q [ i ] + 1 ; k < q [ i + 1 ]; k ++ ) { printf ( \"%c\" , a [ k ]); } printf ( \" \\n \" ); flag = 0 ; break ; } } } if ( flag ) { printf ( \"NO TYPOS \\n \" ); } return 0 ; }","title":"\u89e3\u6790"},{"location":"csdn/2020-09-12/","text":"#include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ll k , l ; scanf ( \"%lld%lld\" , & k , & l ); ll max1 ; int flag = -1 , f = -1 ; for ( int i = l ; i < 2000 && flag == -1 ; i ++ ) { if ( i % 2 ) { ll p = ( i -1 ) / 2 ; double d = ( k + p * i ) * 1.0 / ( i -1 ); ll w = d ; if ( d == w ) { if ( w <= 1e6 && w >= 1 ) flag = w , f = i ; } } else { ll p = i / 2 ; double d = ( k + p * i ) * 1.0 / ( i -1 ); ll w = d ; if ( d == w ) { if ( w <= 1e6 && w >= 1 ) flag = w , f = i ; } } } if ( flag == -1 ) { cout << -1 << endl ; continue ; } cout << f << endl ; int x ; if ( f % 2 == 0 ) { x = -1 ; } else { x = 0 ; } for ( int i = 1 ; i < f ; i ++ ) { cout << x << ' ' ; if ( x == -1 ) x = 0 ; else x = -1 ; } cout << flag << endl ; } return 0 ; } #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n , m , k , sum = 0 ; scanf ( \"%lld%lld%lld\" , & n , & m , & k ); if ( n > m ) { sum = sum + m * ( m -1 ) / 2 ; ll last = n - m + 1 ; ll time = last / k ; if ( last % k ) time ++ ; sum += ( m -1 ) * time ; sum += ( time -1 ) * last + ( time -1 ) * ( time -2 ) * ( - k ) / 2 ; sum += last % k ; } else { sum = n * ( n + 1 ) / 2 ; } cout << sum << endl ; return 0 ; }","title":"2020-09-12"},{"location":"csdn/2020-09-21%20%E5%87%B8%E5%8C%85%E7%AE%97%E6%B3%95/","text":"http://icpc.upc.edu.cn/problem.php?cid=2585&pid=7 \u9898\u76ee\u63cf\u8ff0 \u00b6 Recently, the nation was shocked by news of Sungai Kim Kim incident in Pasir Gudang, Johor, which has been polluted by chemical waste. Thousands of people who are affected had experienced nausea, dizziness and vomiting, and more than 100 schools were ordered to shut. In order to ensure that such incident will not happen again, an early warning system need o be developed so that residents can make early preparation, and authorities are able to move and act much faster. A group of scientists has formed a committee to handle the incident, and a smart system with Internet of Things (IoT) sensors was suggested. Numerous sensors which can sense and monitor damages to the environment, either air or water, have been strategically installed around the state, and their coordinates are also recorded. However, the proposed system encountered a failure during its first testing phase. They want you to fix the problem in determining whether the given coordinates of sensors are safe or in the affected areas. An affected area is defined as the polygon with the minimum length perimeter that can enclose all sensors that trigger warning signal within that area. For example, the sensors (represented by dots) of an affected area and its associated polygon, as well as safe (represented by triangles) and unsafe (represented by diamonds) points of the first dataset are illustrated below. \u8f93\u5165 \u00b6 The input will contain records of data for several test cases of affected areas. The first line of each data set contains a non-negative integer T, the number of test cases (1\u2264T\u226450). Each test case starts with two non-negative integer C and P which is the number of coordinates (3\u2264C\u226450), and points (1\u2264P\u226450), respectively. The next C lines contain coordinates (x-coordinate, y-coordinate) of each installed sensor, separated with blank spaces. The following P lines contain coordinates (x-coordinate, y-coordinate) of certain locations in the state, separated with blank spaces. All coordinates are integers between \u2212500 and 500 inclusive. \u8f93\u51fa \u00b6 For each test case, output the following item: First line: The number of the test cases. The first record corresponds to Case1, the second to Case2 , etc. Next line: A listing of all the points that appear on the perimeter of the affected area. The points must be identified in the standard form \"x-coordinate y- coordinate\". The listing must be oriented counter-clockwise and begin and end with the same point. Last line: For each point of location in the data set, output the line: x\u2212coordinatey\u2212coordinateisstatus where x\u2212coordinatey\u2212coordinate is the coordinate of the location from the input and status is \u2032safe\u2032 or \u2032unsafe\u2032. A location is considered unsafe it is within the sensor perimeter. A point in exactly at the edge of the perimeter is considered safe. \u6837\u4f8b\u8f93\u5165 \u00b6 2 6 5 -477 -180 31 -266 -474 28 147 49 323 -53 277 -79 346 488 -139 -183 -427 129 386 -222 -408 -315 5 2 -52 -325 104 420 315 356 -192 8 493 146 404 228 -239 484 \u6837\u4f8b\u8f93\u51fa \u00b6 Case 1 -477 -180 31 -266 323 -53 147 49 -474 28 -477 -180 346 488 is safe! -139 -183 is unsafe! -427 129 is safe! 386 -222 is safe! -408 -315 is safe! Case 2 -192 8 -52 -325 493 146 315 356 104 420 -192 8 404 228 is unsafe! -239 484 is safe! \u51f8\u5305\u7b97\u6cd5 #include <bits/stdc++.h> using namespace std ; const int maxn = 1e3 + 9 ; const int mod = 1e9 + 7 ; struct node { double x , y ; }; struct point { double x , y ; point friend operator - ( point a , point b ) { return { a . x - b . x , a . y - b . y }; } } p [ maxn ], s [ maxn ], query [ maxn ]; double dis ( point a , point b ) { point c = a - b ; return sqrt ( c . x * c . x + c . y * c . y ); } double chax ( point a , point b ) //\u53c9\u4e58 { return a . x * b . y - a . y * b . x ; } double mulx ( point p1 , point p2 , point p3 ) { return chax ( p2 - p1 , p3 - p1 ); } bool cmp2 ( point a , point b ) { if ( a . x != b . x ) return a . x < b . x ; return a . y < b . y ; } double xxx , yyy ; vector < node > v ; int judge ( int i , int j , int k ) { double xpa = xxx - v [ i ]. x ; double ypa = yyy - v [ i ]. y ; double xpb = xxx - v [ j ]. x ; double ypb = yyy - v [ j ]. y ; double xpc = xxx - v [ k ]. x ; double ypc = yyy - v [ k ]. y ; double ans1 = xpa * ypb - xpb * ypa ; double ans2 = xpb * ypc - xpc * ypb ; double ans3 = xpc * ypa - xpa * ypc ; if ( ans1 == 0 || ans2 == 0 || ans3 == 0 ) return 1 ; if ( ans1 > 0 && ans2 > 0 && ans3 > 0 ) return 1 ; if ( ans1 < 0 && ans2 < 0 && ans3 < 0 ) return 1 ; return 0 ; } int hack ( int i , int j ) { double xpa = xxx - v [ i ]. x ; double ypa = yyy - v [ i ]. y ; double xpb = xxx - v [ j ]. x ; double ypb = yyy - v [ j ]. y ; double ans1 = xpa * ypb - xpb * ypa ; if ( ans1 == 0 ) return 1 ; return 0 ; } int main () { int T ; cin >> T ; int cas = 0 ; for ( int j = 1 ; j <= T ; j ++ ) { v . clear (); int n , q ; cin >> n >> q ; for ( int i = 0 ; i < n ; i ++ ) { cin >> p [ i ]. x >> p [ i ]. y ; } sort ( p , p + n , cmp2 ); int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( m > 1 && mulx ( s [ m -2 ], s [ m -1 ], p [ i ]) <= 0 ) m -- ; s [ m ++ ] = p [ i ]; } int kk = m ; for ( int i = n -2 ; i >= 0 ; i -- ) { while ( m > kk && mulx ( s [ m -2 ], s [ m -1 ], p [ i ]) <= 0 ) m -- ; s [ m ++ ] = p [ i ]; } if ( n > 1 ) m -- ; printf ( \"Case %d \\n \" , j ); for ( int i = 0 ; i < m ; i ++ ) { cout << s [ i ]. x << \" \" << s [ i ]. y << endl ; v . push_back ({ s [ i ]. x , s [ i ]. y }); } cout << s [ 0 ]. x << \" \" << s [ 0 ]. y << endl ; for ( int ii = 1 ; ii <= q ; ii ++ ) { scanf ( \"%lf%lf\" , & xxx , & yyy ); int flag = 1 ; for ( int i = 0 ; i < v . size () && flag ; i ++ ) { for ( int j = i + 1 ; j < v . size () && flag ; j ++ ) { for ( int k = j + 1 ; k < v . size () && flag ; k ++ ) { if ( judge ( i , j , k )) { flag = 0 ; } } } } for ( int i = 0 ; i < v . size () -1 &&! flag ; i ++ ) if ( hack ( i , i + 1 )) flag = 1 ; if ( hack ( v . size () -1 , 0 )) flag = 1 ; if ( ! flag ) { printf ( \"%.0f %.0f is unsafe! \\n \" , xxx , yyy ); } else { printf ( \"%.0f %.0f is safe! \\n \" , xxx , yyy ); } } printf ( \" \\n \" ); } } \u51f8\u5305\u7b97\u6cd5\u6a21\u677f //AndrewScan /* * @Author: lzyws739307453 * @Language: C++ */ #include <bits/stdc++.h> using namespace std ; const int MAXN = 105 ; const double eps = 1e-8 ; typedef struct Point { double x , y ; Point ( double x_ = 0 , double y_ = 0 ) : x ( x_ ), y ( y_ ) {} bool operator < ( const Point & s ) const { return x != s . x ? x < s . x : y < s . y ; } } vect ; struct Point p [ MAXN ], S [ MAXN ], s ; int sgn ( double x ) { return x < - eps ? -1 : x > eps ? 1 : 0 ; } vect operator - ( const Point a , const Point b ) { return vect ( a . x - b . x , a . y - b . y ); } double Cross ( const vect a , const vect b ) { return a . x * b . y - a . y * b . x ; } double dist ( const Point a , const Point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool Onleft ( const Point a , const Point b , const Point c ) { return sgn ( Cross ( b - a , c - a )) > 0 ; } bool InTB ( const Point p [], const Point s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j = ( i + 1 ) % n ; if ( Cross ( p [ j ] - p [ i ], s - p [ i ]) <= 0 ) return false ; } return true ; } int AndrewScan ( Point p [], int n ) { sort ( p , p + n ); int top = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( top > 1 && ! Onleft ( S [ top - 2 ], S [ top - 1 ], p [ i ])) top -- ; S [ top ++ ] = p [ i ]; } int tmp = top ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( top > tmp && ! Onleft ( S [ top - 2 ], S [ top - 1 ], p [ i ])) top -- ; S [ top ++ ] = p [ i ]; } return top ; } int main () { int n , q , t , cnt , kase = 0 ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & q ); for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%lf%lf\" , & p [ i ]. x , & p [ i ]. y ); cnt = AndrewScan ( p , n ); if ( n > 1 ) cnt -- ; if ( kase ) printf ( \" \\n \" ); printf ( \"Case %d \\n \" , ++ kase ); for ( int i = 0 ; i < cnt ; i ++ ) printf ( \"%.0lf %.0lf \\n \" , S [ i ]. x , S [ i ]. y ); printf ( \"%.0lf %.0lf \\n \" , S [ 0 ]. x , S [ 0 ]. y ); while ( q -- ) { scanf ( \"%lf%lf\" , & s . x , & s . y ); printf ( \"%.0lf %.0lf \" , s . x , s . y ); if ( InTB ( S , s , cnt )) printf ( \"is unsafe! \\n \" ); else printf ( \"is safe! \\n \" ); } } return 0 ; } #include <iostream> #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #define PI 3.1415926535 using namespace std ; struct node { int x , y ; }; node vex [ 1000 ]; //\u5b58\u5165\u7684\u6240\u6709\u7684\u70b9 node stackk [ 1000 ]; //\u51f8\u5305\u4e2d\u6240\u6709\u7684\u70b9 int xx , yy ; bool cmp1 ( node a , node b ) //\u6392\u5e8f\u627e\u7b2c\u4e00\u4e2a\u70b9 { if ( a . y == b . y ) return a . x < b . x ; else return a . y < b . y ; } int cross ( node a , node b , node c ) //\u8ba1\u7b97\u53c9\u79ef { return ( b . x - a . x ) * ( c . y - a . y ) - ( c . x - a . x ) * ( b . y - a . y ); } double dis ( node a , node b ) //\u8ba1\u7b97\u8ddd\u79bb { return sqrt (( a . x - b . x ) * ( a . x - b . x ) * 1.0 + ( a . y - b . y ) * ( a . y - b . y )); } bool cmp2 ( node a , node b ) //\u6781\u89d2\u6392\u5e8f\u53e6\u4e00\u79cd\u65b9\u6cd5\uff0c\u901f\u5ea6\u5feb { if ( atan2 ( a . y - yy , a . x - xx ) != atan2 ( b . y - yy , b . x - xx )) return ( atan2 ( a . y - yy , a . x - xx )) < ( atan2 ( b . y - yy , b . x - xx )); return a . x < b . x ; } bool cmp ( node a , node b ) //\u6781\u89d2\u6392\u5e8f { int m = cross ( vex [ 0 ], a , b ); if ( m > 0 ) return 1 ; else if ( m == 0 && dis ( vex [ 0 ], a ) - dis ( vex [ 0 ], b ) <= 0 ) return 1 ; else return 0 ; /*if(m==0) return dis(vex[0],a)-dis(vex[0],b)<=0?true:false; else return m>0?true:false;*/ } int main () { int t , L ; while ( ~ scanf ( \"%d\" , & t ), t ) { int i ; for ( i = 0 ; i < t ; i ++ ) { scanf ( \"%d%d\" , & vex [ i ]. x , & vex [ i ]. y ); } if ( t == 1 ) printf ( \"%.2f \\n \" , 0.00 ); else if ( t == 2 ) printf ( \"%.2f \\n \" , dis ( vex [ 0 ], vex [ 1 ])); else { memset ( stackk , 0 , sizeof ( stackk )); sort ( vex , vex + t , cmp1 ); stackk [ 0 ] = vex [ 0 ]; xx = stackk [ 0 ]. x ; yy = stackk [ 0 ]. y ; sort ( vex + 1 , vex + t , cmp2 ); //cmp2\u662f\u66f4\u5feb\u7684\uff0ccmp\u66f4\u5bb9\u6613\u7406\u89e3 stackk [ 1 ] = vex [ 1 ]; //\u5c06\u51f8\u5305\u4e2d\u7684\u7b2c\u4e24\u4e2a\u70b9\u5b58\u5165\u51f8\u5305\u7684\u7ed3\u6784\u4f53\u4e2d int top = 1 ; //\u6700\u540e\u51f8\u5305\u4e2d\u62e5\u6709\u70b9\u7684\u4e2a\u6570 for ( i = 2 ; i < t ; i ++ ) { while ( i >= 1 && cross ( stackk [ top -1 ], stackk [ top ], vex [ i ]) < 0 ) //\u5bf9\u4f7f\u7528\u6781\u89d2\u6392\u5e8f\u7684i>=1\u6709\u65f6\u53ef\u4ee5\u4e0d\u7528\uff0c\u4f46\u52a0\u4e0a\u603b\u662f\u597d\u7684 top -- ; stackk [ ++ top ] = vex [ i ]; //\u63a7\u5236<0\u6216<=0\u53ef\u4ee5\u63a7\u5236\u91cd\u70b9\uff0c\u5171\u7ebf\u7684\uff0c\u5177\u4f53\u89c6\u9898\u76ee\u800c\u5b9a\u3002 } double s = 0 ; //for(i=1; i<=top; i++)//\u8f93\u51fa\u51f8\u5305\u4e0a\u7684\u70b9 //cout<<stackk[i].x<<\" \"<<stackk[i].y<<endl; for ( i = 1 ; i <= top ; i ++ ) //\u8ba1\u7b97\u51f8\u5305\u7684\u5468\u957f s += dis ( stackk [ i -1 ], stackk [ i ]); s += dis ( stackk [ top ], vex [ 0 ]); //\u6700\u540e\u4e00\u4e2a\u70b9\u548c\u7b2c\u4e00\u4e2a\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb /*s+=2*PI*L; int ans=s+0.5;//\u56db\u820d\u4e94\u5165 printf(\"%d\\n\",ans);*/ printf ( \"%.2lf \\n \" , s ); } } }","title":"2020 09 21 \u51f8\u5305\u7b97\u6cd5"},{"location":"csdn/2020-09-21%20%E5%87%B8%E5%8C%85%E7%AE%97%E6%B3%95/#_1","text":"Recently, the nation was shocked by news of Sungai Kim Kim incident in Pasir Gudang, Johor, which has been polluted by chemical waste. Thousands of people who are affected had experienced nausea, dizziness and vomiting, and more than 100 schools were ordered to shut. In order to ensure that such incident will not happen again, an early warning system need o be developed so that residents can make early preparation, and authorities are able to move and act much faster. A group of scientists has formed a committee to handle the incident, and a smart system with Internet of Things (IoT) sensors was suggested. Numerous sensors which can sense and monitor damages to the environment, either air or water, have been strategically installed around the state, and their coordinates are also recorded. However, the proposed system encountered a failure during its first testing phase. They want you to fix the problem in determining whether the given coordinates of sensors are safe or in the affected areas. An affected area is defined as the polygon with the minimum length perimeter that can enclose all sensors that trigger warning signal within that area. For example, the sensors (represented by dots) of an affected area and its associated polygon, as well as safe (represented by triangles) and unsafe (represented by diamonds) points of the first dataset are illustrated below.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-21%20%E5%87%B8%E5%8C%85%E7%AE%97%E6%B3%95/#_2","text":"The input will contain records of data for several test cases of affected areas. The first line of each data set contains a non-negative integer T, the number of test cases (1\u2264T\u226450). Each test case starts with two non-negative integer C and P which is the number of coordinates (3\u2264C\u226450), and points (1\u2264P\u226450), respectively. The next C lines contain coordinates (x-coordinate, y-coordinate) of each installed sensor, separated with blank spaces. The following P lines contain coordinates (x-coordinate, y-coordinate) of certain locations in the state, separated with blank spaces. All coordinates are integers between \u2212500 and 500 inclusive.","title":"\u8f93\u5165"},{"location":"csdn/2020-09-21%20%E5%87%B8%E5%8C%85%E7%AE%97%E6%B3%95/#_3","text":"For each test case, output the following item: First line: The number of the test cases. The first record corresponds to Case1, the second to Case2 , etc. Next line: A listing of all the points that appear on the perimeter of the affected area. The points must be identified in the standard form \"x-coordinate y- coordinate\". The listing must be oriented counter-clockwise and begin and end with the same point. Last line: For each point of location in the data set, output the line: x\u2212coordinatey\u2212coordinateisstatus where x\u2212coordinatey\u2212coordinate is the coordinate of the location from the input and status is \u2032safe\u2032 or \u2032unsafe\u2032. A location is considered unsafe it is within the sensor perimeter. A point in exactly at the edge of the perimeter is considered safe.","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-21%20%E5%87%B8%E5%8C%85%E7%AE%97%E6%B3%95/#_4","text":"2 6 5 -477 -180 31 -266 -474 28 147 49 323 -53 277 -79 346 488 -139 -183 -427 129 386 -222 -408 -315 5 2 -52 -325 104 420 315 356 -192 8 493 146 404 228 -239 484","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-21%20%E5%87%B8%E5%8C%85%E7%AE%97%E6%B3%95/#_5","text":"Case 1 -477 -180 31 -266 323 -53 147 49 -474 28 -477 -180 346 488 is safe! -139 -183 is unsafe! -427 129 is safe! 386 -222 is safe! -408 -315 is safe! Case 2 -192 8 -52 -325 493 146 315 356 104 420 -192 8 404 228 is unsafe! -239 484 is safe! \u51f8\u5305\u7b97\u6cd5 #include <bits/stdc++.h> using namespace std ; const int maxn = 1e3 + 9 ; const int mod = 1e9 + 7 ; struct node { double x , y ; }; struct point { double x , y ; point friend operator - ( point a , point b ) { return { a . x - b . x , a . y - b . y }; } } p [ maxn ], s [ maxn ], query [ maxn ]; double dis ( point a , point b ) { point c = a - b ; return sqrt ( c . x * c . x + c . y * c . y ); } double chax ( point a , point b ) //\u53c9\u4e58 { return a . x * b . y - a . y * b . x ; } double mulx ( point p1 , point p2 , point p3 ) { return chax ( p2 - p1 , p3 - p1 ); } bool cmp2 ( point a , point b ) { if ( a . x != b . x ) return a . x < b . x ; return a . y < b . y ; } double xxx , yyy ; vector < node > v ; int judge ( int i , int j , int k ) { double xpa = xxx - v [ i ]. x ; double ypa = yyy - v [ i ]. y ; double xpb = xxx - v [ j ]. x ; double ypb = yyy - v [ j ]. y ; double xpc = xxx - v [ k ]. x ; double ypc = yyy - v [ k ]. y ; double ans1 = xpa * ypb - xpb * ypa ; double ans2 = xpb * ypc - xpc * ypb ; double ans3 = xpc * ypa - xpa * ypc ; if ( ans1 == 0 || ans2 == 0 || ans3 == 0 ) return 1 ; if ( ans1 > 0 && ans2 > 0 && ans3 > 0 ) return 1 ; if ( ans1 < 0 && ans2 < 0 && ans3 < 0 ) return 1 ; return 0 ; } int hack ( int i , int j ) { double xpa = xxx - v [ i ]. x ; double ypa = yyy - v [ i ]. y ; double xpb = xxx - v [ j ]. x ; double ypb = yyy - v [ j ]. y ; double ans1 = xpa * ypb - xpb * ypa ; if ( ans1 == 0 ) return 1 ; return 0 ; } int main () { int T ; cin >> T ; int cas = 0 ; for ( int j = 1 ; j <= T ; j ++ ) { v . clear (); int n , q ; cin >> n >> q ; for ( int i = 0 ; i < n ; i ++ ) { cin >> p [ i ]. x >> p [ i ]. y ; } sort ( p , p + n , cmp2 ); int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( m > 1 && mulx ( s [ m -2 ], s [ m -1 ], p [ i ]) <= 0 ) m -- ; s [ m ++ ] = p [ i ]; } int kk = m ; for ( int i = n -2 ; i >= 0 ; i -- ) { while ( m > kk && mulx ( s [ m -2 ], s [ m -1 ], p [ i ]) <= 0 ) m -- ; s [ m ++ ] = p [ i ]; } if ( n > 1 ) m -- ; printf ( \"Case %d \\n \" , j ); for ( int i = 0 ; i < m ; i ++ ) { cout << s [ i ]. x << \" \" << s [ i ]. y << endl ; v . push_back ({ s [ i ]. x , s [ i ]. y }); } cout << s [ 0 ]. x << \" \" << s [ 0 ]. y << endl ; for ( int ii = 1 ; ii <= q ; ii ++ ) { scanf ( \"%lf%lf\" , & xxx , & yyy ); int flag = 1 ; for ( int i = 0 ; i < v . size () && flag ; i ++ ) { for ( int j = i + 1 ; j < v . size () && flag ; j ++ ) { for ( int k = j + 1 ; k < v . size () && flag ; k ++ ) { if ( judge ( i , j , k )) { flag = 0 ; } } } } for ( int i = 0 ; i < v . size () -1 &&! flag ; i ++ ) if ( hack ( i , i + 1 )) flag = 1 ; if ( hack ( v . size () -1 , 0 )) flag = 1 ; if ( ! flag ) { printf ( \"%.0f %.0f is unsafe! \\n \" , xxx , yyy ); } else { printf ( \"%.0f %.0f is safe! \\n \" , xxx , yyy ); } } printf ( \" \\n \" ); } } \u51f8\u5305\u7b97\u6cd5\u6a21\u677f //AndrewScan /* * @Author: lzyws739307453 * @Language: C++ */ #include <bits/stdc++.h> using namespace std ; const int MAXN = 105 ; const double eps = 1e-8 ; typedef struct Point { double x , y ; Point ( double x_ = 0 , double y_ = 0 ) : x ( x_ ), y ( y_ ) {} bool operator < ( const Point & s ) const { return x != s . x ? x < s . x : y < s . y ; } } vect ; struct Point p [ MAXN ], S [ MAXN ], s ; int sgn ( double x ) { return x < - eps ? -1 : x > eps ? 1 : 0 ; } vect operator - ( const Point a , const Point b ) { return vect ( a . x - b . x , a . y - b . y ); } double Cross ( const vect a , const vect b ) { return a . x * b . y - a . y * b . x ; } double dist ( const Point a , const Point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool Onleft ( const Point a , const Point b , const Point c ) { return sgn ( Cross ( b - a , c - a )) > 0 ; } bool InTB ( const Point p [], const Point s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j = ( i + 1 ) % n ; if ( Cross ( p [ j ] - p [ i ], s - p [ i ]) <= 0 ) return false ; } return true ; } int AndrewScan ( Point p [], int n ) { sort ( p , p + n ); int top = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( top > 1 && ! Onleft ( S [ top - 2 ], S [ top - 1 ], p [ i ])) top -- ; S [ top ++ ] = p [ i ]; } int tmp = top ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( top > tmp && ! Onleft ( S [ top - 2 ], S [ top - 1 ], p [ i ])) top -- ; S [ top ++ ] = p [ i ]; } return top ; } int main () { int n , q , t , cnt , kase = 0 ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & q ); for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%lf%lf\" , & p [ i ]. x , & p [ i ]. y ); cnt = AndrewScan ( p , n ); if ( n > 1 ) cnt -- ; if ( kase ) printf ( \" \\n \" ); printf ( \"Case %d \\n \" , ++ kase ); for ( int i = 0 ; i < cnt ; i ++ ) printf ( \"%.0lf %.0lf \\n \" , S [ i ]. x , S [ i ]. y ); printf ( \"%.0lf %.0lf \\n \" , S [ 0 ]. x , S [ 0 ]. y ); while ( q -- ) { scanf ( \"%lf%lf\" , & s . x , & s . y ); printf ( \"%.0lf %.0lf \" , s . x , s . y ); if ( InTB ( S , s , cnt )) printf ( \"is unsafe! \\n \" ); else printf ( \"is safe! \\n \" ); } } return 0 ; } #include <iostream> #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #define PI 3.1415926535 using namespace std ; struct node { int x , y ; }; node vex [ 1000 ]; //\u5b58\u5165\u7684\u6240\u6709\u7684\u70b9 node stackk [ 1000 ]; //\u51f8\u5305\u4e2d\u6240\u6709\u7684\u70b9 int xx , yy ; bool cmp1 ( node a , node b ) //\u6392\u5e8f\u627e\u7b2c\u4e00\u4e2a\u70b9 { if ( a . y == b . y ) return a . x < b . x ; else return a . y < b . y ; } int cross ( node a , node b , node c ) //\u8ba1\u7b97\u53c9\u79ef { return ( b . x - a . x ) * ( c . y - a . y ) - ( c . x - a . x ) * ( b . y - a . y ); } double dis ( node a , node b ) //\u8ba1\u7b97\u8ddd\u79bb { return sqrt (( a . x - b . x ) * ( a . x - b . x ) * 1.0 + ( a . y - b . y ) * ( a . y - b . y )); } bool cmp2 ( node a , node b ) //\u6781\u89d2\u6392\u5e8f\u53e6\u4e00\u79cd\u65b9\u6cd5\uff0c\u901f\u5ea6\u5feb { if ( atan2 ( a . y - yy , a . x - xx ) != atan2 ( b . y - yy , b . x - xx )) return ( atan2 ( a . y - yy , a . x - xx )) < ( atan2 ( b . y - yy , b . x - xx )); return a . x < b . x ; } bool cmp ( node a , node b ) //\u6781\u89d2\u6392\u5e8f { int m = cross ( vex [ 0 ], a , b ); if ( m > 0 ) return 1 ; else if ( m == 0 && dis ( vex [ 0 ], a ) - dis ( vex [ 0 ], b ) <= 0 ) return 1 ; else return 0 ; /*if(m==0) return dis(vex[0],a)-dis(vex[0],b)<=0?true:false; else return m>0?true:false;*/ } int main () { int t , L ; while ( ~ scanf ( \"%d\" , & t ), t ) { int i ; for ( i = 0 ; i < t ; i ++ ) { scanf ( \"%d%d\" , & vex [ i ]. x , & vex [ i ]. y ); } if ( t == 1 ) printf ( \"%.2f \\n \" , 0.00 ); else if ( t == 2 ) printf ( \"%.2f \\n \" , dis ( vex [ 0 ], vex [ 1 ])); else { memset ( stackk , 0 , sizeof ( stackk )); sort ( vex , vex + t , cmp1 ); stackk [ 0 ] = vex [ 0 ]; xx = stackk [ 0 ]. x ; yy = stackk [ 0 ]. y ; sort ( vex + 1 , vex + t , cmp2 ); //cmp2\u662f\u66f4\u5feb\u7684\uff0ccmp\u66f4\u5bb9\u6613\u7406\u89e3 stackk [ 1 ] = vex [ 1 ]; //\u5c06\u51f8\u5305\u4e2d\u7684\u7b2c\u4e24\u4e2a\u70b9\u5b58\u5165\u51f8\u5305\u7684\u7ed3\u6784\u4f53\u4e2d int top = 1 ; //\u6700\u540e\u51f8\u5305\u4e2d\u62e5\u6709\u70b9\u7684\u4e2a\u6570 for ( i = 2 ; i < t ; i ++ ) { while ( i >= 1 && cross ( stackk [ top -1 ], stackk [ top ], vex [ i ]) < 0 ) //\u5bf9\u4f7f\u7528\u6781\u89d2\u6392\u5e8f\u7684i>=1\u6709\u65f6\u53ef\u4ee5\u4e0d\u7528\uff0c\u4f46\u52a0\u4e0a\u603b\u662f\u597d\u7684 top -- ; stackk [ ++ top ] = vex [ i ]; //\u63a7\u5236<0\u6216<=0\u53ef\u4ee5\u63a7\u5236\u91cd\u70b9\uff0c\u5171\u7ebf\u7684\uff0c\u5177\u4f53\u89c6\u9898\u76ee\u800c\u5b9a\u3002 } double s = 0 ; //for(i=1; i<=top; i++)//\u8f93\u51fa\u51f8\u5305\u4e0a\u7684\u70b9 //cout<<stackk[i].x<<\" \"<<stackk[i].y<<endl; for ( i = 1 ; i <= top ; i ++ ) //\u8ba1\u7b97\u51f8\u5305\u7684\u5468\u957f s += dis ( stackk [ i -1 ], stackk [ i ]); s += dis ( stackk [ top ], vex [ 0 ]); //\u6700\u540e\u4e00\u4e2a\u70b9\u548c\u7b2c\u4e00\u4e2a\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb /*s+=2*PI*L; int ans=s+0.5;//\u56db\u820d\u4e94\u5165 printf(\"%d\\n\",ans);*/ printf ( \"%.2lf \\n \" , s ); } } }","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-23%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","text":"http://icpc.upc.edu.cn/problem.php?cid=2586&pid=3 \u9898\u76ee\u63cf\u8ff0 \u00b6 We define B(x) as the number of digit 1 in the binary representation of x. For example, B(7) =B((111) 2 ) = 3, B(8) = B((1000) 2 ) = 1, B(9) = B((1001) 2 ) = 2. We define F(x) = min{y j (y > x)\u2227(B(y)\u2264B(x))}. For example, F(4) = 8, F(5) = 6, F(6) = 8. Zayin has a forest (a set of trees), whose nodes are numbered from 1 to n. For each node (e.g. node x),if F(x) is not greater than n, then the father of node x is F(x), else, node x is the root of a tree. We use A [ i ] to denote the number of apples on the node i. Initially, all the A [ i ] (1\u2264i\u2264n) are equal to zero. In order to make his girlfriend happy, Zayin is going to perform magic on the tree. The magic consists of two types of operations: 1. Add x v : For every ancestor of node x (including itself), put v more apples on it. In other words, for every node (e.g. node y) on the path between node x and the root of its tree, let A[y] = A[y] + v. 2. Sum L R : Count the total number of apples on the nodes whose index is between L and R. In other words, you need to calculate . \u8f93\u5165 \u00b6 The first line contains two integers n and m (1\u2264n\u22641018 , 1\u2264m\u2264105 ), where n is the number of nodes and m is the number of operations. The next m lines describe the m operations in order. Each line contains three integers. The first of them is op. If op = 1, then the next two integers will be x and v, representing an Add operation. If op = 2, then the next two integers will be L and R, representing a Sum operation. (1\u2264x\u2264n, 1\u2264v\u2264109 , 1\u2264L\u2264R\u2264n) \u8f93\u51fa \u00b6 For each Sum operation, output one line including one number, denoting the corresponding result. \u6837\u4f8b\u8f93\u5165 \u00b6 8 6 1 1 1 1 3 2 1 5 3 1 7 4 2 1 5 2 4 8 \u6837\u4f8b\u8f93\u51fa \u00b6 10 23 \u6811\u72b6\u6570\u7ec4 #pragma GCC optimize(3) #pragma GCC optimize(\"Ofast\",\"uroll-loops\",\"omit-frame-pointer\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n ; unordered_map < ll , ll > w ; void add ( ll k , ll m ) { for ( ll d = m , i = k ; i <= n ; i += i & ( - i ), d += m ) w [ i ] += d ; } ll query ( ll n ) { ll sum = 0 ; for ( ll i = n ; i ; i -= i & ( - i )) if ( w . count ( i )) sum += w [ i ]; return sum ; } int main () { std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( 0 ); int k ; cin >> n >> k ; ll a , b , c ; for ( int i = 1 ; i <= k ; i ++ ) { cin >> a >> b >> c ; if ( a == 1 ) { add ( b , c ); } else { printf ( \"%lld \\n \" , - query ( b -1 ) + query ( c )); } } }","title":"2020 09 23 \u6811\u72b6\u6570\u7ec4"},{"location":"csdn/2020-09-23%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/#_1","text":"We define B(x) as the number of digit 1 in the binary representation of x. For example, B(7) =B((111) 2 ) = 3, B(8) = B((1000) 2 ) = 1, B(9) = B((1001) 2 ) = 2. We define F(x) = min{y j (y > x)\u2227(B(y)\u2264B(x))}. For example, F(4) = 8, F(5) = 6, F(6) = 8. Zayin has a forest (a set of trees), whose nodes are numbered from 1 to n. For each node (e.g. node x),if F(x) is not greater than n, then the father of node x is F(x), else, node x is the root of a tree. We use A [ i ] to denote the number of apples on the node i. Initially, all the A [ i ] (1\u2264i\u2264n) are equal to zero. In order to make his girlfriend happy, Zayin is going to perform magic on the tree. The magic consists of two types of operations: 1. Add x v : For every ancestor of node x (including itself), put v more apples on it. In other words, for every node (e.g. node y) on the path between node x and the root of its tree, let A[y] = A[y] + v. 2. Sum L R : Count the total number of apples on the nodes whose index is between L and R. In other words, you need to calculate .","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-23%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/#_2","text":"The first line contains two integers n and m (1\u2264n\u22641018 , 1\u2264m\u2264105 ), where n is the number of nodes and m is the number of operations. The next m lines describe the m operations in order. Each line contains three integers. The first of them is op. If op = 1, then the next two integers will be x and v, representing an Add operation. If op = 2, then the next two integers will be L and R, representing a Sum operation. (1\u2264x\u2264n, 1\u2264v\u2264109 , 1\u2264L\u2264R\u2264n)","title":"\u8f93\u5165"},{"location":"csdn/2020-09-23%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/#_3","text":"For each Sum operation, output one line including one number, denoting the corresponding result.","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-23%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/#_4","text":"8 6 1 1 1 1 3 2 1 5 3 1 7 4 2 1 5 2 4 8","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-23%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/#_5","text":"10 23 \u6811\u72b6\u6570\u7ec4 #pragma GCC optimize(3) #pragma GCC optimize(\"Ofast\",\"uroll-loops\",\"omit-frame-pointer\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n ; unordered_map < ll , ll > w ; void add ( ll k , ll m ) { for ( ll d = m , i = k ; i <= n ; i += i & ( - i ), d += m ) w [ i ] += d ; } ll query ( ll n ) { ll sum = 0 ; for ( ll i = n ; i ; i -= i & ( - i )) if ( w . count ( i )) sum += w [ i ]; return sum ; } int main () { std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( 0 ); int k ; cin >> n >> k ; ll a , b , c ; for ( int i = 1 ; i <= k ; i ++ ) { cin >> a >> b >> c ; if ( a == 1 ) { add ( b , c ); } else { printf ( \"%lld \\n \" , - query ( b -1 ) + query ( c )); } } }","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-26%20%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/","text":"http://icpc.upc.edu.cn/problem.php?cid=2587&pid=6 \u9898\u76ee\u63cf\u8ff0 \u00b6 Bonnie and Clyde have noticed that parallel processing improves throughput so, instead of robbing one bank together, they\u2019ve decided to rob two different banks simultaneously (each robbing one). They both succeeded and now they need to run to their get-away 1934 Ford Model (730 Deluxe Sedan). There are complications, of course, or the movie won\u2019t be exciting! The city is in the shape of a matrix with cells. Bonnie and Clyde are in two different cells, and the get-away car is in a different cell as well. Bonnie and Clyde can move in four directions: north, south, east, and west (the border cells of course have fewer move options since they cannot move across the outer walls of the city). Some cells are also blocked, i.e., neither one can move into it. To put more adventure in the movie, it is also the case that once Bonnie or Clyde moves into a cell, then neither one can move into that cell anymore, i.e., a cell is used at most once. Bonnie and Clyde cannot move into each other\u2019s starting position either. Given the city map (in the form of a matrix), the location for Bonnie, Clyde, and car, you are to compute the minimum total number of moves needed for both Bonnie and Clyde to get to the car, i.e., the total number of moves made by Bonnie plus the total number of moves made by Clyde. \u8f93\u5165 \u00b6 The first input line contains two integers, r and c (2 \u2264 r, c \u2264 30), providing the number of rows and columns for the matrix. Each of the next r lines contains c characters, starting in column 1; this is the input matrix. There will be exactly one \u201cB\u201d (Bonnie\u2019s starting location), one \u201cC\u201d (Clyde\u2019s starting location), and one \u201cF\u201d (where the get-away Ford car is) in the input maze. The remaining cells will be \u201c.\u201d (empty cell \u2013 one can move into) or \u201cx\u201d (blocked \u2013 one cannot move into). \u8f93\u51fa \u00b6 Print the minimum total number of moves needed for both Bonnie and Clyde to get to the car. If they cannot get to the car, print -1. Note that when one reaches the car, he/she stops moving. \u6837\u4f8b\u8f93\u5165 \u00b6 6 5 ..... ...C. .B.x. ..... ...F. ..... \u6837\u4f8b\u8f93\u51fa \u00b6 9 \u63d0\u793a \u00b6 Bonnie can reach the car with 4 moves and Clyde can reach the car with 5 moves, for a total of 9 moves. #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int next ; int flow ; int dis ; int to ; }; int head [ 100500 ] = { 0 }; node edge [ 100500 ] = { 0 }; int dis [ 100500 ] = { 0 }; int pre [ 100500 ] = { 0 }; int vis [ 100500 ] = { 0 }; int last [ 100500 ] = { 0 }; int flow [ 100500 ] = { 0 }; char g [ 1000 ][ 1000 ] = { 0 }; int n , m , s , t , cnt = -1 , maxflow = 0 , mincost = 0 ; int num ( int i , int j ) { return i * m + j ; } int add ( int from , int to , int flow , int dis ) { edge [ ++ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. flow = flow ; edge [ cnt ]. dis = dis ; head [ from ] = cnt ; } queue < int > w ; bool spfa ( int start , int end1 ) { w . push ( start ); memset ( dis , 0x3f3f3f , sizeof ( dis )); memset ( vis , 0 , sizeof ( vis )); memset ( flow , 0x3f3f3f , sizeof ( flow )); pre [ end1 ] = -1 ; vis [ start ] = 1 ; dis [ start ] = 0 ; while ( ! w . empty ()) { int now = w . front (); w . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i != -1 ; i = edge [ i ]. next ) { //cout<<i<<endl; if ( edge [ i ]. flow > 0 && dis [ edge [ i ]. to ] > dis [ now ] + edge [ i ]. dis ) { dis [ edge [ i ]. to ] = dis [ now ] + edge [ i ]. dis ; pre [ edge [ i ]. to ] = now ; last [ edge [ i ]. to ] = i ; flow [ edge [ i ]. to ] = min ( flow [ now ], edge [ i ]. flow ); if ( ! vis [ edge [ i ]. to ]) { vis [ edge [ i ]. to ] = 1 ; w . push ( edge [ i ]. to ); } } } } return pre [ end1 ] != -1 ; } int MCMF () { while ( spfa ( s , t )) { maxflow += flow [ t ]; mincost += dis [ t ] * flow [ t ]; int now = t ; while ( now != s ) { edge [ last [ now ]]. flow -= flow [ t ]; edge [ last [ now ] ^ 1 ]. flow += flow [ t ]; now = pre [ now ]; } } } int main () { memset ( head , -1 , sizeof ( head )); scanf ( \"%d%d\" , & n , & m ); s = n * m + 200 , t = n * m + 100 ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , g [ i ] + 1 ); } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( g [ i ][ j ] == 'x' ) continue ; if ( j > 1 && g [ i ][ j -1 ] != 'x' ) { add ( num ( i , j ), num ( i , j -1 ), 1 , 1 ); add ( num ( i , j -1 ), num ( i , j ), 0 , -1 ); } if ( i > 1 && g [ i -1 ][ j ] != 'x' ) { add ( num ( i , j ), num ( i -1 , j ), 1 , 1 ); add ( num ( i -1 , j ), num ( i , j ), 0 , -1 ); } if ( j < m && g [ i ][ j + 1 ] != 'x' ) { add ( num ( i , j ), num ( i , j + 1 ), 1 , 1 ); add ( num ( i , j + 1 ), num ( i , j ), 0 , -1 ); } if ( i < n && g [ i + 1 ][ j ] != 'x' ) { add ( num ( i , j ), num ( i + 1 , j ), 1 , 1 ); add ( num ( i + 1 , j ), num ( i , j ), 0 , -1 ); } if ( g [ i ][ j ] == 'F' ) { add ( s , num ( i , j ), 2 , 0 ); add ( num ( i , j ), s , 0 , 0 ); } if ( g [ i ][ j ] == 'C' || g [ i ][ j ] == 'B' ) { add ( num ( i , j ), t , 1 , 0 ); add ( t , num ( i , j ), 0 , 0 ); } } } MCMF (); // cout<<maxflow<<\" \"<<mincost<<endl; if ( maxflow != 2 ) printf ( \"-1 \\n \" ); else printf ( \"%d \\n \" , mincost ); }","title":"2020 09 26 \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u95ee\u9898"},{"location":"csdn/2020-09-26%20%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/#_1","text":"Bonnie and Clyde have noticed that parallel processing improves throughput so, instead of robbing one bank together, they\u2019ve decided to rob two different banks simultaneously (each robbing one). They both succeeded and now they need to run to their get-away 1934 Ford Model (730 Deluxe Sedan). There are complications, of course, or the movie won\u2019t be exciting! The city is in the shape of a matrix with cells. Bonnie and Clyde are in two different cells, and the get-away car is in a different cell as well. Bonnie and Clyde can move in four directions: north, south, east, and west (the border cells of course have fewer move options since they cannot move across the outer walls of the city). Some cells are also blocked, i.e., neither one can move into it. To put more adventure in the movie, it is also the case that once Bonnie or Clyde moves into a cell, then neither one can move into that cell anymore, i.e., a cell is used at most once. Bonnie and Clyde cannot move into each other\u2019s starting position either. Given the city map (in the form of a matrix), the location for Bonnie, Clyde, and car, you are to compute the minimum total number of moves needed for both Bonnie and Clyde to get to the car, i.e., the total number of moves made by Bonnie plus the total number of moves made by Clyde.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-09-26%20%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/#_2","text":"The first input line contains two integers, r and c (2 \u2264 r, c \u2264 30), providing the number of rows and columns for the matrix. Each of the next r lines contains c characters, starting in column 1; this is the input matrix. There will be exactly one \u201cB\u201d (Bonnie\u2019s starting location), one \u201cC\u201d (Clyde\u2019s starting location), and one \u201cF\u201d (where the get-away Ford car is) in the input maze. The remaining cells will be \u201c.\u201d (empty cell \u2013 one can move into) or \u201cx\u201d (blocked \u2013 one cannot move into).","title":"\u8f93\u5165"},{"location":"csdn/2020-09-26%20%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/#_3","text":"Print the minimum total number of moves needed for both Bonnie and Clyde to get to the car. If they cannot get to the car, print -1. Note that when one reaches the car, he/she stops moving.","title":"\u8f93\u51fa"},{"location":"csdn/2020-09-26%20%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/#_4","text":"6 5 ..... ...C. .B.x. ..... ...F. .....","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-09-26%20%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/#_5","text":"9","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-09-26%20%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/#_6","text":"Bonnie can reach the car with 4 moves and Clyde can reach the car with 5 moves, for a total of 9 moves. #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int next ; int flow ; int dis ; int to ; }; int head [ 100500 ] = { 0 }; node edge [ 100500 ] = { 0 }; int dis [ 100500 ] = { 0 }; int pre [ 100500 ] = { 0 }; int vis [ 100500 ] = { 0 }; int last [ 100500 ] = { 0 }; int flow [ 100500 ] = { 0 }; char g [ 1000 ][ 1000 ] = { 0 }; int n , m , s , t , cnt = -1 , maxflow = 0 , mincost = 0 ; int num ( int i , int j ) { return i * m + j ; } int add ( int from , int to , int flow , int dis ) { edge [ ++ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. flow = flow ; edge [ cnt ]. dis = dis ; head [ from ] = cnt ; } queue < int > w ; bool spfa ( int start , int end1 ) { w . push ( start ); memset ( dis , 0x3f3f3f , sizeof ( dis )); memset ( vis , 0 , sizeof ( vis )); memset ( flow , 0x3f3f3f , sizeof ( flow )); pre [ end1 ] = -1 ; vis [ start ] = 1 ; dis [ start ] = 0 ; while ( ! w . empty ()) { int now = w . front (); w . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i != -1 ; i = edge [ i ]. next ) { //cout<<i<<endl; if ( edge [ i ]. flow > 0 && dis [ edge [ i ]. to ] > dis [ now ] + edge [ i ]. dis ) { dis [ edge [ i ]. to ] = dis [ now ] + edge [ i ]. dis ; pre [ edge [ i ]. to ] = now ; last [ edge [ i ]. to ] = i ; flow [ edge [ i ]. to ] = min ( flow [ now ], edge [ i ]. flow ); if ( ! vis [ edge [ i ]. to ]) { vis [ edge [ i ]. to ] = 1 ; w . push ( edge [ i ]. to ); } } } } return pre [ end1 ] != -1 ; } int MCMF () { while ( spfa ( s , t )) { maxflow += flow [ t ]; mincost += dis [ t ] * flow [ t ]; int now = t ; while ( now != s ) { edge [ last [ now ]]. flow -= flow [ t ]; edge [ last [ now ] ^ 1 ]. flow += flow [ t ]; now = pre [ now ]; } } } int main () { memset ( head , -1 , sizeof ( head )); scanf ( \"%d%d\" , & n , & m ); s = n * m + 200 , t = n * m + 100 ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , g [ i ] + 1 ); } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( g [ i ][ j ] == 'x' ) continue ; if ( j > 1 && g [ i ][ j -1 ] != 'x' ) { add ( num ( i , j ), num ( i , j -1 ), 1 , 1 ); add ( num ( i , j -1 ), num ( i , j ), 0 , -1 ); } if ( i > 1 && g [ i -1 ][ j ] != 'x' ) { add ( num ( i , j ), num ( i -1 , j ), 1 , 1 ); add ( num ( i -1 , j ), num ( i , j ), 0 , -1 ); } if ( j < m && g [ i ][ j + 1 ] != 'x' ) { add ( num ( i , j ), num ( i , j + 1 ), 1 , 1 ); add ( num ( i , j + 1 ), num ( i , j ), 0 , -1 ); } if ( i < n && g [ i + 1 ][ j ] != 'x' ) { add ( num ( i , j ), num ( i + 1 , j ), 1 , 1 ); add ( num ( i + 1 , j ), num ( i , j ), 0 , -1 ); } if ( g [ i ][ j ] == 'F' ) { add ( s , num ( i , j ), 2 , 0 ); add ( num ( i , j ), s , 0 , 0 ); } if ( g [ i ][ j ] == 'C' || g [ i ][ j ] == 'B' ) { add ( num ( i , j ), t , 1 , 0 ); add ( t , num ( i , j ), 0 , 0 ); } } } MCMF (); // cout<<maxflow<<\" \"<<mincost<<endl; if ( maxflow != 2 ) printf ( \"-1 \\n \" ); else printf ( \"%d \\n \" , mincost ); }","title":"\u63d0\u793a"},{"location":"csdn/2020-10-04%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E6%89%AB%E6%8F%8F%E7%BA%BF/","text":"http://icpc.upc.edu.cn/problem.php?cid=2590&pid=1 \u9898\u76ee\u63cf\u8ff0 \u00b6 Consider a square map with N \u00d7 N cells. We indicate the coordinate of a cell by (i, j), where 1 \u2264 i, j \u2264 N . Each cell has a color either white or black. The color of each cell is initialized to white. The map supports the operation flip([xlow , xhigh], [ylow , yhigh]), which flips the color of each cell in the rectangle [xlow , xhigh] \u00d7 [ylow , yhigh]. Given a sequence of flip operations, our problem is to count the number of black cells in the final map. We illustrate this in the following example. Figure (a) shows the initial map. Next, we call flip([2, 4], [1, 3]) and obtain Figure (b). Then, we call flip([1, 5], [3, 5]) and obtain Figure \u00a9. This map contains 18 black cells. \u8f93\u5165 \u00b6 The first line contains the number of test cases T (T < 10). Each test case begins with a line containing two integers N and K (1 < N, K < 10000), where N is the parameter of the map size and K is the number of flip operations. Each subsequent line corresponds to a flip operation, with four integers: xlow , xhigh, ylow , yhigh. \u8f93\u51fa \u00b6 For each test case, output the answer in a line. \u6837\u4f8b\u8f93\u5165 \u00b6 1 5 2 2 4 1 3 1 5 3 5 \u6837\u4f8b\u8f93\u51fa \u00b6 18 \u7ebf\u6bb5\u6811+\u626b\u63cf\u7ebf #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int h , a , b , num ; }; int mark [ 100500 ] = { 0 }; int sum [ 100500 ] = { 0 }; node edge [ 100500 ] = { 0 }; bool cmp ( node a , node b ) { if ( a . h == b . h ) return a . num > b . num ; else return a . h < b . h ; } int nodeupdate ( int root , int l , int r , ll num ) { mark [ root ] ^= 1 ; sum [ root ] = r - l + 1 - sum [ root ]; } int pushdown ( int root , int l , int r ) { if ( mark [ root ] == 0 ) return 0 ; int mid = ( l + r ) / 2 ; nodeupdate ( 2 * root , l , mid , mark [ root ]); nodeupdate ( 2 * root + 1 , mid + 1 , r , mark [ root ]); mark [ root ] = 0 ; } int update ( int root , int l , int r , int L , int R , ll num ) { if ( l >= L && r <= R ) { nodeupdate ( root , l , r , num ); return 0 ; } pushdown ( root , l , r ); int mid = ( l + r ) / 2 ; if ( mid >= L ) update ( root * 2 , l , mid , L , R , num ); if ( mid < R ) update ( root * 2 + 1 , mid + 1 , r , L , R , num ); sum [ root ] = sum [ 2 * root ] + sum [ 2 * root + 1 ]; } int main () { int t , cnt ; scanf ( \"%d\" , & t ); while ( t -- ) { memset ( sum , 0 , sizeof ( sum )); memset ( mark , 0 , sizeof ( mark )); int n , m , ans = 0 ; cnt = 0 ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int x1 , y1 , x2 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & x2 , & y1 , & y2 ); edge [ cnt ++ ] = node { y1 , x1 , x2 , 1 }; edge [ cnt ++ ] = node { y2 , x1 , x2 , -1 }; } sort ( edge , edge + cnt , cmp ); for ( int i = 1 , j = 0 ; i <= n ; i ++ ) { while ( j < cnt && edge [ j ]. h <= i && edge [ j ]. num == 1 ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } ans += sum [ 1 ]; while ( j < cnt && edge [ j ]. h <= i ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } } cout << ans << endl ; } return 0 ; } \u6c42\u7531\u591a\u4e2a\u77e9\u5f62\u6240\u56f4\u6210\u7684\u9762\u79ef\uff0c\u4ee3\u7801\u5f85\u9a8c\u8bc1 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int h , a , b , num ; }; int mark [ 100500 ] = { 0 }; int sum [ 100500 ] = { 0 }; node edge [ 100500 ] = { 0 }; bool cmp ( node a , node b ) { if ( a . h == b . h ) return a . num > b . num ; else return a . h < b . h ; } int pushup ( int root , int l , int r , ll num ) { mark [ root ] ^= num ; if ( mark [ root ]) sum [ root ] = r - l + 1 ; else if ( l == r ) sum [ root ] = 0 ; else sum [ root ] = sum [ 2 * root ] + sum [ 2 * root + 1 ]; } int pushdown ( int root , int l , int r ) { if ( mark [ root ] == 0 ) return 0 ; int mid = ( l + r ) / 2 ; pushup ( 2 * root , l , mid , mark [ root ]); pushup ( 2 * root + 1 , mid + 1 , r , mark [ root ]); mark [ root ] = 0 ; } int update ( int root , int l , int r , int L , int R , ll num ) { if ( l >= L && r <= R ) { pushup ( root , l , r , num ); return 0 ; } pushdown ( root , l , r ); int mid = ( l + r ) / 2 ; if ( mid >= L ) update ( root * 2 , l , mid , L , R , num ); if ( mid < R ) update ( root * 2 + 1 , mid + 1 , r , L , R , num ); sum [ root ] = sum [ 2 * root ] + sum [ 2 * root + 1 ]; } int main () { int t , cnt ; scanf ( \"%d\" , & t ); while ( t -- ) { memset ( sum , 0 , sizeof ( sum )); memset ( mark , 0 , sizeof ( mark )); int n , m , ans = 0 ; cnt = 0 ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int x1 , y1 , x2 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & x2 , & y1 , & y2 ); edge [ cnt ++ ] = node { y1 , x1 , x2 , 1 }; edge [ cnt ++ ] = node { y2 , x1 , x2 , -1 }; } sort ( edge , edge + cnt , cmp ); for ( int i = 1 , j = 0 ; i <= n ; i ++ ) { while ( j < cnt && edge [ j ]. h <= i && edge [ j ]. num == 1 ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } ans += sum [ 1 ]; while ( j < cnt && edge [ j ]. h <= i ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } } cout << ans << endl ; } return 0 ; } \u53e6\uff1a\u5982\u679c\u6570\u636e\u91cf\u6bd4\u8f83\u5927\u6216\u8005\u51fa\u73b0\u5c0f\u6570\u53ef\u4ee5\u52a0\u79bb\u6563\u5316\u5904\u7406\u3002 https://www.cnblogs.com/heya/p/11315849.html","title":"2020 10 04 \u7ebf\u6bb5\u6811+\u626b\u63cf\u7ebf"},{"location":"csdn/2020-10-04%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E6%89%AB%E6%8F%8F%E7%BA%BF/#_1","text":"Consider a square map with N \u00d7 N cells. We indicate the coordinate of a cell by (i, j), where 1 \u2264 i, j \u2264 N . Each cell has a color either white or black. The color of each cell is initialized to white. The map supports the operation flip([xlow , xhigh], [ylow , yhigh]), which flips the color of each cell in the rectangle [xlow , xhigh] \u00d7 [ylow , yhigh]. Given a sequence of flip operations, our problem is to count the number of black cells in the final map. We illustrate this in the following example. Figure (a) shows the initial map. Next, we call flip([2, 4], [1, 3]) and obtain Figure (b). Then, we call flip([1, 5], [3, 5]) and obtain Figure \u00a9. This map contains 18 black cells.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-10-04%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E6%89%AB%E6%8F%8F%E7%BA%BF/#_2","text":"The first line contains the number of test cases T (T < 10). Each test case begins with a line containing two integers N and K (1 < N, K < 10000), where N is the parameter of the map size and K is the number of flip operations. Each subsequent line corresponds to a flip operation, with four integers: xlow , xhigh, ylow , yhigh.","title":"\u8f93\u5165"},{"location":"csdn/2020-10-04%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E6%89%AB%E6%8F%8F%E7%BA%BF/#_3","text":"For each test case, output the answer in a line.","title":"\u8f93\u51fa"},{"location":"csdn/2020-10-04%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E6%89%AB%E6%8F%8F%E7%BA%BF/#_4","text":"1 5 2 2 4 1 3 1 5 3 5","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-10-04%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E6%89%AB%E6%8F%8F%E7%BA%BF/#_5","text":"18 \u7ebf\u6bb5\u6811+\u626b\u63cf\u7ebf #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int h , a , b , num ; }; int mark [ 100500 ] = { 0 }; int sum [ 100500 ] = { 0 }; node edge [ 100500 ] = { 0 }; bool cmp ( node a , node b ) { if ( a . h == b . h ) return a . num > b . num ; else return a . h < b . h ; } int nodeupdate ( int root , int l , int r , ll num ) { mark [ root ] ^= 1 ; sum [ root ] = r - l + 1 - sum [ root ]; } int pushdown ( int root , int l , int r ) { if ( mark [ root ] == 0 ) return 0 ; int mid = ( l + r ) / 2 ; nodeupdate ( 2 * root , l , mid , mark [ root ]); nodeupdate ( 2 * root + 1 , mid + 1 , r , mark [ root ]); mark [ root ] = 0 ; } int update ( int root , int l , int r , int L , int R , ll num ) { if ( l >= L && r <= R ) { nodeupdate ( root , l , r , num ); return 0 ; } pushdown ( root , l , r ); int mid = ( l + r ) / 2 ; if ( mid >= L ) update ( root * 2 , l , mid , L , R , num ); if ( mid < R ) update ( root * 2 + 1 , mid + 1 , r , L , R , num ); sum [ root ] = sum [ 2 * root ] + sum [ 2 * root + 1 ]; } int main () { int t , cnt ; scanf ( \"%d\" , & t ); while ( t -- ) { memset ( sum , 0 , sizeof ( sum )); memset ( mark , 0 , sizeof ( mark )); int n , m , ans = 0 ; cnt = 0 ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int x1 , y1 , x2 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & x2 , & y1 , & y2 ); edge [ cnt ++ ] = node { y1 , x1 , x2 , 1 }; edge [ cnt ++ ] = node { y2 , x1 , x2 , -1 }; } sort ( edge , edge + cnt , cmp ); for ( int i = 1 , j = 0 ; i <= n ; i ++ ) { while ( j < cnt && edge [ j ]. h <= i && edge [ j ]. num == 1 ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } ans += sum [ 1 ]; while ( j < cnt && edge [ j ]. h <= i ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } } cout << ans << endl ; } return 0 ; } \u6c42\u7531\u591a\u4e2a\u77e9\u5f62\u6240\u56f4\u6210\u7684\u9762\u79ef\uff0c\u4ee3\u7801\u5f85\u9a8c\u8bc1 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int h , a , b , num ; }; int mark [ 100500 ] = { 0 }; int sum [ 100500 ] = { 0 }; node edge [ 100500 ] = { 0 }; bool cmp ( node a , node b ) { if ( a . h == b . h ) return a . num > b . num ; else return a . h < b . h ; } int pushup ( int root , int l , int r , ll num ) { mark [ root ] ^= num ; if ( mark [ root ]) sum [ root ] = r - l + 1 ; else if ( l == r ) sum [ root ] = 0 ; else sum [ root ] = sum [ 2 * root ] + sum [ 2 * root + 1 ]; } int pushdown ( int root , int l , int r ) { if ( mark [ root ] == 0 ) return 0 ; int mid = ( l + r ) / 2 ; pushup ( 2 * root , l , mid , mark [ root ]); pushup ( 2 * root + 1 , mid + 1 , r , mark [ root ]); mark [ root ] = 0 ; } int update ( int root , int l , int r , int L , int R , ll num ) { if ( l >= L && r <= R ) { pushup ( root , l , r , num ); return 0 ; } pushdown ( root , l , r ); int mid = ( l + r ) / 2 ; if ( mid >= L ) update ( root * 2 , l , mid , L , R , num ); if ( mid < R ) update ( root * 2 + 1 , mid + 1 , r , L , R , num ); sum [ root ] = sum [ 2 * root ] + sum [ 2 * root + 1 ]; } int main () { int t , cnt ; scanf ( \"%d\" , & t ); while ( t -- ) { memset ( sum , 0 , sizeof ( sum )); memset ( mark , 0 , sizeof ( mark )); int n , m , ans = 0 ; cnt = 0 ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int x1 , y1 , x2 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & x2 , & y1 , & y2 ); edge [ cnt ++ ] = node { y1 , x1 , x2 , 1 }; edge [ cnt ++ ] = node { y2 , x1 , x2 , -1 }; } sort ( edge , edge + cnt , cmp ); for ( int i = 1 , j = 0 ; i <= n ; i ++ ) { while ( j < cnt && edge [ j ]. h <= i && edge [ j ]. num == 1 ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } ans += sum [ 1 ]; while ( j < cnt && edge [ j ]. h <= i ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } } cout << ans << endl ; } return 0 ; } \u53e6\uff1a\u5982\u679c\u6570\u636e\u91cf\u6bd4\u8f83\u5927\u6216\u8005\u51fa\u73b0\u5c0f\u6570\u53ef\u4ee5\u52a0\u79bb\u6563\u5316\u5904\u7406\u3002 https://www.cnblogs.com/heya/p/11315849.html","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-10-05/","text":"\u5df2\u77e5\u4e8c\u53c9\u6811\u7684\u4e2d\u5e8f\u548c\u540e\u5e8f\u6c42\u524d\u5e8f \u00b6 \u9898\u76ee \u00b6 https://www.luogu.com.cn/problem/P1030 \u53c2\u8003\u4e8e \u00b6 https://www.luogu.com.cn/problem/solution/P1030 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int dfs ( string a , string b ) { if ( a . size () == 0 ) return 0 ; cout << b [ b . size () -1 ]; int k = a . find ( b [ b . size () -1 ]); dfs ( a . substr ( 0 , k ), b . substr ( 0 , k )); dfs ( a . substr ( k + 1 ), b . substr ( k , a . size () - k -1 )); } int main () { string a , b ; cin >> a >> b ; dfs ( a , b ); return 0 ; }","title":"2020-10-05"},{"location":"csdn/2020-10-05/#_1","text":"","title":"\u5df2\u77e5\u4e8c\u53c9\u6811\u7684\u4e2d\u5e8f\u548c\u540e\u5e8f\u6c42\u524d\u5e8f"},{"location":"csdn/2020-10-05/#_2","text":"https://www.luogu.com.cn/problem/P1030","title":"\u9898\u76ee"},{"location":"csdn/2020-10-05/#_3","text":"https://www.luogu.com.cn/problem/solution/P1030","title":"\u53c2\u8003\u4e8e"},{"location":"csdn/2020-10-05/#_4","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int dfs ( string a , string b ) { if ( a . size () == 0 ) return 0 ; cout << b [ b . size () -1 ]; int k = a . find ( b [ b . size () -1 ]); dfs ( a . substr ( 0 , k ), b . substr ( 0 , k )); dfs ( a . substr ( k + 1 ), b . substr ( k , a . size () - k -1 )); } int main () { string a , b ; cin >> a >> b ; dfs ( a , b ); return 0 ; }","title":"\u4ee3\u7801"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/","text":"http://icpc.upc.edu.cn/problem.php?cid=2592&pid=5 \u9898\u76ee\u63cf\u8ff0 \u00b6 DIDIDI and WNJXYK are good friends. One day, they go to the zoo. The monkeys are playing happily. There are n monkeys named 1-n. At first, the first one hangs its tail on the tree. The other n-1 monkeys, either are caught by other monkeys, or catch other monkeys, or both. In the next m seconds, every second, there will be a monkey releasing its left hand or right hand. And then some monkeys will drop on the floor. Given the relationship between monkeys, calculate the landing time of every monkey. \u8f93\u5165 \u00b6 The first line of input contains a positive integer T, telling you there are T test cases followed. Each test case, first line includes two integers n, m. n means number of monkeys, and m as mentioned in the description. Then following n lines, the k-th line has two integers, describe the k-th monkey\u2019s information. The first integer is the index of monkey in its left hand, the second integer is the index of monkey in its right hand. -1 indicates there is nothing in its hand. Then following m lines, the i-th line gives the information at time i-1, every line has two numbers, the first is the index of the monkey, the second is the hand that it releases, 1 is left hand, 2 is right hand. It\u2019s guaranteed that all the monkeys aren\u2019t on the floor at the beginning. \u8f93\u51fa \u00b6 For each test case, print a line \u201cCase #x: \u201d, where x is the case number (starting from 1) and print n integers. The i-th integer is the time monkey i drop in the floor. If monkey i don\u2019t land on the floor, print -1; \u6837\u4f8b\u8f93\u5165 \u00b6 1 3 2 -1 3 3 -1 1 2 1 2 3 1 \u6837\u4f8b\u8f93\u51fa \u00b6 Case #1: -1 1 1 \u63d0\u793a \u00b6 Tips:1\u2264T\u226410,1\u2264n\u2264200,000,0\u2264m\u2264400,000 Initially, the first monkey\u2019s tail hangs on the tree. The first monkey\u2019s right hand catches the third monkey, the second monkey\u2019s left hand catches the third monkey, and the third\u2019s left hand catches the first monkey while the right hand catches the second. On time 0, the first monkey releases its right hand, no monkey lands on the floor. On time 1, the third monkey releases its left hand, then the second monkey and the third land on the floor. \u53c2\u8003\u535a\u5ba2 \u00b6 https://blog.csdn.net/Cosmic_Tree/article/details/108921892 #pragma GCC optimize(3) #pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int x , y ; }; int ans [ 200500 ] = { 0 }; node a [ 400500 ] = { 0 }; int vis [ 200500 ][ 3 ] = { 0 }; int g [ 200500 ][ 2 ] = { 0 }; int father [ 200500 ] = { 0 }; vector < int > deep [ 200500 ]; int findfa ( int n ) { if ( n == father [ n ]) return n ; else return father [ n ] = findfa ( father [ n ]); } int union1 ( int a , int b ) { int fa = findfa ( a ); int fb = findfa ( b ); if ( fa == fb ) return 0 ; if ( deep [ fa ]. size () > deep [ fb ]. size ()) swap ( fa , fb ); father [ fa ] = fb ; deep [ fb ]. insert ( deep [ fb ]. end (), deep [ fa ]. begin (), deep [ fa ]. end ()); } int union2 ( int a , int b , int ans1 ) { if ( b == -1 ) return 0 ; int fa = findfa ( a ); int fb = findfa ( b ); if ( fa == fb ) return 0 ; int f1 = findfa ( 1 ); if ( fa == f1 ) { for ( int i = 0 ; i < deep [ fb ]. size (); i ++ ) { ans [ deep [ fb ][ i ]] = ans1 ; } } if ( fb == f1 ) { for ( int i = 0 ; i < deep [ fa ]. size (); i ++ ) { ans [ deep [ fa ][ i ]] = ans1 ; } } if ( deep [ fa ]. size () > deep [ fb ]. size ()) swap ( fa , fb ); father [ fa ] = fb ; deep [ fb ]. insert ( deep [ fb ]. end (), deep [ fa ]. begin (), deep [ fa ]. end ()); } int main () { int t ; scanf ( \"%d\" , & t ); for ( int t1 = 1 ; t1 <= t ; t1 ++ ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { father [ i ] = i ; deep [ i ]. clear (); deep [ i ]. push_back ( i ); vis [ i ][ 1 ] = vis [ i ][ 2 ] = 0 ; ans [ i ] = -1 ; } for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d%d\" , & g [ i ][ 1 ], & g [ i ][ 2 ]); } for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & a [ i ]. x , & a [ i ]. y ); vis [ a [ i ]. x ][ a [ i ]. y ] = 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( vis [ i ][ 1 ] == 0 && g [ i ][ 1 ] != -1 ) { union1 ( i , g [ i ][ 1 ]); } if ( vis [ i ][ 2 ] == 0 && g [ i ][ 2 ] != -1 ) { union1 ( i , g [ i ][ 2 ]); } } for ( int i = m ; i >= 1 ; i -- ) { union2 ( a [ i ]. x , g [ a [ i ]. x ][ a [ i ]. y ], i -1 ); } printf ( \"Case #%d: \" , t1 ); for ( int i = 1 ; i <= n ; i ++ ) { printf ( \"%d \" , ans [ i ]); } printf ( \" \\n \" ); } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2592&pid=7 \u9898\u76ee\u63cf\u8ff0 \u00b6 WNJXYK and DIDIDI are friends. They are thinking about getting strong all the time. They are playing a very hard online game and they can\u2019t defeat any monster in this game now. If they can\u2019t defeat monsters, they will not get EXP and will not get strong forever. They finally found that the only way for them to get strong is to upgrade their equipment with their limited coins. Each equipment can be upgrade many times with paying some money. And of course, they will get power from each upgrade. They have N equipment in total and each equipment can be upgrade for Ki times. At first, equipment are all in Level 0. If you upgrade the ith equipment from Level j-1 to Level j, you will pay Cij coins and get Wij power. They have M coins in total and they want to know the most power they can get with these coins. \u8f93\u5165 \u00b6 The first line of input contains a positive integer T telling you there are T test cases followed. In each Test Case, there is two positive integers N,M in the first line indicates that there are N equipment and M coins. The following N Lines, there is a positive integer Ki at first indicates that the ith equipment can be upgrade Ki times. And there are 2Ki positive integers followed Wij,Cij. \u8f93\u51fa \u00b6 You need to output one line for each Test Case. \u201cCase #X: Y\u201d means the max power they can get in Xth Test Case is Y. \u6837\u4f8b\u8f93\u5165 \u00b6 1 3 5 1 1 1 2 1 1 5 4 1 5 3 \u6837\u4f8b\u8f93\u51fa \u00b6 Case #1: 7 \u63d0\u793a \u00b6 Tips:1\u2264T\u226410,1\u2264N\u226420,0\u2264M\u22641e9,0\u2264Ki\u22644,1\u2264Cij,Wij\u22641e9 In this Sample, they can upgrade their equipment like this and this is the only for them to get 7 power with 5 coins. \u89e3\u6790 \u00b6 \u53cc\u5411DFS+\u4e8c\u5206\u4f18\u5316 #pragma GCC optimize(3) #pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll INF = 1e18 ; struct node { ll x , y ; }; ll sum1 [ 100 ][ 100 ] = { 0 }; ll p1 [ 100 ][ 100 ] = { 0 }; ll n , m ; node ans [ 5005000 ] = { 0 }; ll max1 =- INF ; ll cnt = 0 ; ll size1 [ 100 ] = { 0 }; bool cmp ( node a , node b ) { return a . y < b . y ; } ll dfs1 ( ll k , ll e , ll sum , ll p ) { if ( k > e ) { ans [ ++ cnt ] = node { sum , p }; max1 = max ( max1 , sum ); return 0 ; } for ( ll i = 0 ; i <= size1 [ k ]; i ++ ) { if ( p + p1 [ k ][ i ] > m ) continue ; dfs1 ( k + 1 , e , sum + sum1 [ k ][ i ], p + p1 [ k ][ i ]); } dfs1 ( k + 1 , e , sum , p ); } ll find1 ( ll num ) { ll l = 1 , r = cnt + 1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( ans [ mid ]. y < num ) l = mid + 1 ; else if ( ans [ mid ]. y > num ) r = mid ; else if ( ans [ mid ]. y == num ) l = mid + 1 ; } if ( ans [ l -1 ]. y <= num ) return l -1 ; else return -1 ; } ll dfs2 ( ll k , ll e , ll sum , ll p ) { if ( k > e ) { ll pos = find1 ( m - p ); if ( ~ pos ) max1 = max ( max1 , sum + ans [ pos ]. x ); max1 = max ( max1 , sum ); return 0 ; } for ( int i = 0 ; i <= size1 [ k ]; i ++ ) { if ( p + p1 [ k ][ i ] > m ) continue ; dfs2 ( k + 1 , e , sum + sum1 [ k ][ i ], p + p1 [ k ][ i ]); } dfs2 ( k + 1 , e , sum , p ); } int main () { int t ; scanf ( \"%d\" , & t ); for ( int t1 = 1 ; t1 <= t ; t1 ++ ) { scanf ( \"%lld%lld\" , & n , & m ); cnt = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & size1 [ i ]); for ( ll j = 1 ; j <= size1 [ i ]; j ++ ) { ll x , y ; scanf ( \"%lld%lld\" , & sum1 [ i ][ j ], & p1 [ i ][ j ]); sum1 [ i ][ j ] += sum1 [ i ][ j -1 ]; p1 [ i ][ j ] += p1 [ i ][ j -1 ]; } } max1 =- INF ; dfs1 ( 1 , n / 2 , 0 , 0 ); sort ( ans + 1 , ans + 1 + cnt , cmp ); ans [ 0 ]. x =- INF ; for ( ll i = 1 ; i <= cnt ; i ++ ) { ans [ i ]. x = max ( ans [ i -1 ]. x , ans [ i ]. x ); } dfs2 ( n / 2 + 1 , n , 0 , 0 ); printf ( \"Case #%d: %lld \\n \" , t1 , max1 ); } return 0 ; }","title":"2020 10 07 \u5e76\u67e5\u96c6+\u542f\u53d1\u5f0f\u5408\u5e76"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/#_1","text":"DIDIDI and WNJXYK are good friends. One day, they go to the zoo. The monkeys are playing happily. There are n monkeys named 1-n. At first, the first one hangs its tail on the tree. The other n-1 monkeys, either are caught by other monkeys, or catch other monkeys, or both. In the next m seconds, every second, there will be a monkey releasing its left hand or right hand. And then some monkeys will drop on the floor. Given the relationship between monkeys, calculate the landing time of every monkey.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/#_2","text":"The first line of input contains a positive integer T, telling you there are T test cases followed. Each test case, first line includes two integers n, m. n means number of monkeys, and m as mentioned in the description. Then following n lines, the k-th line has two integers, describe the k-th monkey\u2019s information. The first integer is the index of monkey in its left hand, the second integer is the index of monkey in its right hand. -1 indicates there is nothing in its hand. Then following m lines, the i-th line gives the information at time i-1, every line has two numbers, the first is the index of the monkey, the second is the hand that it releases, 1 is left hand, 2 is right hand. It\u2019s guaranteed that all the monkeys aren\u2019t on the floor at the beginning.","title":"\u8f93\u5165"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/#_3","text":"For each test case, print a line \u201cCase #x: \u201d, where x is the case number (starting from 1) and print n integers. The i-th integer is the time monkey i drop in the floor. If monkey i don\u2019t land on the floor, print -1;","title":"\u8f93\u51fa"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/#_4","text":"1 3 2 -1 3 3 -1 1 2 1 2 3 1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/#_5","text":"Case #1: -1 1 1","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/#_6","text":"Tips:1\u2264T\u226410,1\u2264n\u2264200,000,0\u2264m\u2264400,000 Initially, the first monkey\u2019s tail hangs on the tree. The first monkey\u2019s right hand catches the third monkey, the second monkey\u2019s left hand catches the third monkey, and the third\u2019s left hand catches the first monkey while the right hand catches the second. On time 0, the first monkey releases its right hand, no monkey lands on the floor. On time 1, the third monkey releases its left hand, then the second monkey and the third land on the floor.","title":"\u63d0\u793a"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/#_7","text":"https://blog.csdn.net/Cosmic_Tree/article/details/108921892 #pragma GCC optimize(3) #pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int x , y ; }; int ans [ 200500 ] = { 0 }; node a [ 400500 ] = { 0 }; int vis [ 200500 ][ 3 ] = { 0 }; int g [ 200500 ][ 2 ] = { 0 }; int father [ 200500 ] = { 0 }; vector < int > deep [ 200500 ]; int findfa ( int n ) { if ( n == father [ n ]) return n ; else return father [ n ] = findfa ( father [ n ]); } int union1 ( int a , int b ) { int fa = findfa ( a ); int fb = findfa ( b ); if ( fa == fb ) return 0 ; if ( deep [ fa ]. size () > deep [ fb ]. size ()) swap ( fa , fb ); father [ fa ] = fb ; deep [ fb ]. insert ( deep [ fb ]. end (), deep [ fa ]. begin (), deep [ fa ]. end ()); } int union2 ( int a , int b , int ans1 ) { if ( b == -1 ) return 0 ; int fa = findfa ( a ); int fb = findfa ( b ); if ( fa == fb ) return 0 ; int f1 = findfa ( 1 ); if ( fa == f1 ) { for ( int i = 0 ; i < deep [ fb ]. size (); i ++ ) { ans [ deep [ fb ][ i ]] = ans1 ; } } if ( fb == f1 ) { for ( int i = 0 ; i < deep [ fa ]. size (); i ++ ) { ans [ deep [ fa ][ i ]] = ans1 ; } } if ( deep [ fa ]. size () > deep [ fb ]. size ()) swap ( fa , fb ); father [ fa ] = fb ; deep [ fb ]. insert ( deep [ fb ]. end (), deep [ fa ]. begin (), deep [ fa ]. end ()); } int main () { int t ; scanf ( \"%d\" , & t ); for ( int t1 = 1 ; t1 <= t ; t1 ++ ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { father [ i ] = i ; deep [ i ]. clear (); deep [ i ]. push_back ( i ); vis [ i ][ 1 ] = vis [ i ][ 2 ] = 0 ; ans [ i ] = -1 ; } for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d%d\" , & g [ i ][ 1 ], & g [ i ][ 2 ]); } for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & a [ i ]. x , & a [ i ]. y ); vis [ a [ i ]. x ][ a [ i ]. y ] = 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( vis [ i ][ 1 ] == 0 && g [ i ][ 1 ] != -1 ) { union1 ( i , g [ i ][ 1 ]); } if ( vis [ i ][ 2 ] == 0 && g [ i ][ 2 ] != -1 ) { union1 ( i , g [ i ][ 2 ]); } } for ( int i = m ; i >= 1 ; i -- ) { union2 ( a [ i ]. x , g [ a [ i ]. x ][ a [ i ]. y ], i -1 ); } printf ( \"Case #%d: \" , t1 ); for ( int i = 1 ; i <= n ; i ++ ) { printf ( \"%d \" , ans [ i ]); } printf ( \" \\n \" ); } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2592&pid=7","title":"\u53c2\u8003\u535a\u5ba2"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/#_8","text":"WNJXYK and DIDIDI are friends. They are thinking about getting strong all the time. They are playing a very hard online game and they can\u2019t defeat any monster in this game now. If they can\u2019t defeat monsters, they will not get EXP and will not get strong forever. They finally found that the only way for them to get strong is to upgrade their equipment with their limited coins. Each equipment can be upgrade many times with paying some money. And of course, they will get power from each upgrade. They have N equipment in total and each equipment can be upgrade for Ki times. At first, equipment are all in Level 0. If you upgrade the ith equipment from Level j-1 to Level j, you will pay Cij coins and get Wij power. They have M coins in total and they want to know the most power they can get with these coins.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/#_9","text":"The first line of input contains a positive integer T telling you there are T test cases followed. In each Test Case, there is two positive integers N,M in the first line indicates that there are N equipment and M coins. The following N Lines, there is a positive integer Ki at first indicates that the ith equipment can be upgrade Ki times. And there are 2Ki positive integers followed Wij,Cij.","title":"\u8f93\u5165"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/#_10","text":"You need to output one line for each Test Case. \u201cCase #X: Y\u201d means the max power they can get in Xth Test Case is Y.","title":"\u8f93\u51fa"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/#_11","text":"1 3 5 1 1 1 2 1 1 5 4 1 5 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/#_12","text":"Case #1: 7","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/#_13","text":"Tips:1\u2264T\u226410,1\u2264N\u226420,0\u2264M\u22641e9,0\u2264Ki\u22644,1\u2264Cij,Wij\u22641e9 In this Sample, they can upgrade their equipment like this and this is the only for them to get 7 power with 5 coins.","title":"\u63d0\u793a"},{"location":"csdn/2020-10-07%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/#_14","text":"\u53cc\u5411DFS+\u4e8c\u5206\u4f18\u5316 #pragma GCC optimize(3) #pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll INF = 1e18 ; struct node { ll x , y ; }; ll sum1 [ 100 ][ 100 ] = { 0 }; ll p1 [ 100 ][ 100 ] = { 0 }; ll n , m ; node ans [ 5005000 ] = { 0 }; ll max1 =- INF ; ll cnt = 0 ; ll size1 [ 100 ] = { 0 }; bool cmp ( node a , node b ) { return a . y < b . y ; } ll dfs1 ( ll k , ll e , ll sum , ll p ) { if ( k > e ) { ans [ ++ cnt ] = node { sum , p }; max1 = max ( max1 , sum ); return 0 ; } for ( ll i = 0 ; i <= size1 [ k ]; i ++ ) { if ( p + p1 [ k ][ i ] > m ) continue ; dfs1 ( k + 1 , e , sum + sum1 [ k ][ i ], p + p1 [ k ][ i ]); } dfs1 ( k + 1 , e , sum , p ); } ll find1 ( ll num ) { ll l = 1 , r = cnt + 1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( ans [ mid ]. y < num ) l = mid + 1 ; else if ( ans [ mid ]. y > num ) r = mid ; else if ( ans [ mid ]. y == num ) l = mid + 1 ; } if ( ans [ l -1 ]. y <= num ) return l -1 ; else return -1 ; } ll dfs2 ( ll k , ll e , ll sum , ll p ) { if ( k > e ) { ll pos = find1 ( m - p ); if ( ~ pos ) max1 = max ( max1 , sum + ans [ pos ]. x ); max1 = max ( max1 , sum ); return 0 ; } for ( int i = 0 ; i <= size1 [ k ]; i ++ ) { if ( p + p1 [ k ][ i ] > m ) continue ; dfs2 ( k + 1 , e , sum + sum1 [ k ][ i ], p + p1 [ k ][ i ]); } dfs2 ( k + 1 , e , sum , p ); } int main () { int t ; scanf ( \"%d\" , & t ); for ( int t1 = 1 ; t1 <= t ; t1 ++ ) { scanf ( \"%lld%lld\" , & n , & m ); cnt = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & size1 [ i ]); for ( ll j = 1 ; j <= size1 [ i ]; j ++ ) { ll x , y ; scanf ( \"%lld%lld\" , & sum1 [ i ][ j ], & p1 [ i ][ j ]); sum1 [ i ][ j ] += sum1 [ i ][ j -1 ]; p1 [ i ][ j ] += p1 [ i ][ j -1 ]; } } max1 =- INF ; dfs1 ( 1 , n / 2 , 0 , 0 ); sort ( ans + 1 , ans + 1 + cnt , cmp ); ans [ 0 ]. x =- INF ; for ( ll i = 1 ; i <= cnt ; i ++ ) { ans [ i ]. x = max ( ans [ i -1 ]. x , ans [ i ]. x ); } dfs2 ( n / 2 + 1 , n , 0 , 0 ); printf ( \"Case #%d: %lld \\n \" , t1 , max1 ); } return 0 ; }","title":"\u89e3\u6790"},{"location":"csdn/2020-10-15%20dsu%20on%20tree/","text":"http://icpc.upc.edu.cn/problem.php?cid=2597&pid=10 \u9898\u76ee\u63cf\u8ff0 \u00b6 Christmas is still one month away, but Mr. Panda already starts the Christmas preparation. Mr. Panda is decorating a Christmas tree with a set of Russian dolls. There are n Russian dolls numbered 1, 2, . . . , n. The ith doll is designed to be perfected nested inside the i + 1th doll for all 1 \u2264 i \u2264 n \u2212 1. Nesting dolls are stable only if they have neighboring ordinal numbers, otherwise the smaller one will slide out from the larger one. Dolls can be nested recursively. For example, the n dolls can be nested all the way up from smallest to largest until there is only one doll left. The Christmas tree happens to have n nodes wit one Russian roll dangling on each node. Doll number 1 is put at the tree root. Mr. Panda will invite his friend Mr. Sheep to collect some dolls from the Christmas tree as gifts on Christmas Eve. Mr. Sheep will pick a tree node and collects all the dolls in the sub-tree with the selected node as the sub-tree root. As there could be a lot of dolls, Mr. Sheep want to nest the dolls he collects for easy carrying. The dolls should be stably nested. He wonders for each tree node, how many dolls will be ended up if he nests them as much as possible. \u8f93\u5165 \u00b6 The first line of input gives the number of test cases T (1 \u2264 T \u2264 10). T test cases follow. Each test case starts with a line containing an integer n (1 \u2264 n \u2264 2 \u00d7 105), the number of dolls and also the number of tree nodes. The next n \u2212 1 lines each contains two integers x and y (1 \u2264 x, y \u2264 n), denoting doll number x and doll number y are neighbors in the Christmas tree. It is guaranteed that the sum of n in all cases is not greater than 106. \u8f93\u51fa \u00b6 For each test case, the output consists one line starts with \u201cCase #x:\u201d, where x is the test case number (starting from 1), followed by next n integers. The ith (1 \u2264 i \u2264 n) integer indicates the number of dolls will be ended up if Mr. Sheep selects tree node that contains doll i, collects all the dolls in the sub-tree,and nests the dolls stably as much as possible. \u6837\u4f8b\u8f93\u5165 \u00b6 1 7 1 2 2 4 2 6 1 3 3 5 3 7 \u6837\u4f8b\u8f93\u51fa \u00b6 Case #1: 1 3 3 1 1 1 1 \u89e3\u6790 \u00b6 dsu on tree\u7b97\u6cd5\uff0c\u8be6\u60c5\u89c1\uff1a https://blog.csdn.net/qq_43472263/article/details/104150940 #include <bits/stdc++.h> using namespace std ; struct node { int from ; int to ; int next ; }; vector < node > edge ; int head [ 200050 ] = { 0 }; int hson [ 200050 ] = { 0 }; //int dep[200500]= {0}; //int father[200500]= {0}; int siz [ 200050 ] = { 0 }; int ans [ 200050 ] = { 0 }; int add_edge ( int from , int to ) { edge . push_back ({ from , to , head [ from ]}); head [ from ] = edge . size () -1 ; } int dfs1 ( int now , int depth , int fa ) { //dep[now]=depth; //father[now]=fa; siz [ now ] = 1 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { if ( edge [ i ]. to != fa ) { dfs1 ( edge [ i ]. to , depth + 1 , now ); siz [ now ] += siz [ edge [ i ]. to ]; if ( hson [ now ] == -1 || siz [ edge [ i ]. to ] > siz [ hson [ now ]]) hson [ now ] = edge [ i ]. to ; } } } bool flag [ 200050 ] = { 0 }; bool vis [ 200050 ] = { 0 }; int cnt = 0 ; int update ( int now , int fa , bool flg ) { int sum = flag [ now -1 ] + flag [ now + 1 ]; if ( flg ) ///\u63d2\u5165 { if ( sum == 2 ) cnt -- ; else if ( sum == 0 ) cnt ++ ; } else ///\u79fb\u9664 { if ( sum == 0 ) cnt -- ; else if ( sum == 2 ) cnt ++ ; } flag [ now ] = flg ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { if ( edge [ i ]. to != fa &&! vis [ edge [ i ]. to ]) { update ( edge [ i ]. to , now , flg ); } } } int dfs2 ( int now , int fa , bool kep ) { for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { if ( edge [ i ]. to != fa && edge [ i ]. to != hson [ now ]) { dfs2 ( edge [ i ]. to , now , false ); } } if ( hson [ now ] != -1 ) { dfs2 ( hson [ now ], now , true ); vis [ hson [ now ]] = 1 ; } update ( now , fa , true ); ans [ now ] = cnt ; if ( hson [ now ] != -1 ) vis [ hson [ now ]] = 0 ; if ( ! kep ) update ( now , fa , false ); } int main () { int t ; scanf ( \"%d\" , & t ); for ( int t1 = 1 ; t1 <= t ; t1 ++ ) { memset ( hson , -1 , sizeof ( hson )); memset ( head , 0 , sizeof ( head )); edge . clear (); edge . push_back ({ -1 , -1 , -1 }); int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n -1 ; i ++ ) { int x , y ; scanf ( \"%d%d\" , & x , & y ); add_edge ( x , y ); add_edge ( y , x ); } dfs1 ( 1 , 0 , -1 ); memset ( flag , 0 , sizeof ( flag )); memset ( vis , 0 , sizeof ( vis )); dfs2 ( 1 , -1 , false ); printf ( \"Case #%d:\" , t1 ); for ( int i = 1 ; i <= n ; i ++ ) printf ( \" %d\" , ans [ i ]); printf ( \" \\n \" ); } }","title":"2020 10 15 dsu on tree"},{"location":"csdn/2020-10-15%20dsu%20on%20tree/#_1","text":"Christmas is still one month away, but Mr. Panda already starts the Christmas preparation. Mr. Panda is decorating a Christmas tree with a set of Russian dolls. There are n Russian dolls numbered 1, 2, . . . , n. The ith doll is designed to be perfected nested inside the i + 1th doll for all 1 \u2264 i \u2264 n \u2212 1. Nesting dolls are stable only if they have neighboring ordinal numbers, otherwise the smaller one will slide out from the larger one. Dolls can be nested recursively. For example, the n dolls can be nested all the way up from smallest to largest until there is only one doll left. The Christmas tree happens to have n nodes wit one Russian roll dangling on each node. Doll number 1 is put at the tree root. Mr. Panda will invite his friend Mr. Sheep to collect some dolls from the Christmas tree as gifts on Christmas Eve. Mr. Sheep will pick a tree node and collects all the dolls in the sub-tree with the selected node as the sub-tree root. As there could be a lot of dolls, Mr. Sheep want to nest the dolls he collects for easy carrying. The dolls should be stably nested. He wonders for each tree node, how many dolls will be ended up if he nests them as much as possible.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-10-15%20dsu%20on%20tree/#_2","text":"The first line of input gives the number of test cases T (1 \u2264 T \u2264 10). T test cases follow. Each test case starts with a line containing an integer n (1 \u2264 n \u2264 2 \u00d7 105), the number of dolls and also the number of tree nodes. The next n \u2212 1 lines each contains two integers x and y (1 \u2264 x, y \u2264 n), denoting doll number x and doll number y are neighbors in the Christmas tree. It is guaranteed that the sum of n in all cases is not greater than 106.","title":"\u8f93\u5165"},{"location":"csdn/2020-10-15%20dsu%20on%20tree/#_3","text":"For each test case, the output consists one line starts with \u201cCase #x:\u201d, where x is the test case number (starting from 1), followed by next n integers. The ith (1 \u2264 i \u2264 n) integer indicates the number of dolls will be ended up if Mr. Sheep selects tree node that contains doll i, collects all the dolls in the sub-tree,and nests the dolls stably as much as possible.","title":"\u8f93\u51fa"},{"location":"csdn/2020-10-15%20dsu%20on%20tree/#_4","text":"1 7 1 2 2 4 2 6 1 3 3 5 3 7","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-10-15%20dsu%20on%20tree/#_5","text":"Case #1: 1 3 3 1 1 1 1","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-10-15%20dsu%20on%20tree/#_6","text":"dsu on tree\u7b97\u6cd5\uff0c\u8be6\u60c5\u89c1\uff1a https://blog.csdn.net/qq_43472263/article/details/104150940 #include <bits/stdc++.h> using namespace std ; struct node { int from ; int to ; int next ; }; vector < node > edge ; int head [ 200050 ] = { 0 }; int hson [ 200050 ] = { 0 }; //int dep[200500]= {0}; //int father[200500]= {0}; int siz [ 200050 ] = { 0 }; int ans [ 200050 ] = { 0 }; int add_edge ( int from , int to ) { edge . push_back ({ from , to , head [ from ]}); head [ from ] = edge . size () -1 ; } int dfs1 ( int now , int depth , int fa ) { //dep[now]=depth; //father[now]=fa; siz [ now ] = 1 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { if ( edge [ i ]. to != fa ) { dfs1 ( edge [ i ]. to , depth + 1 , now ); siz [ now ] += siz [ edge [ i ]. to ]; if ( hson [ now ] == -1 || siz [ edge [ i ]. to ] > siz [ hson [ now ]]) hson [ now ] = edge [ i ]. to ; } } } bool flag [ 200050 ] = { 0 }; bool vis [ 200050 ] = { 0 }; int cnt = 0 ; int update ( int now , int fa , bool flg ) { int sum = flag [ now -1 ] + flag [ now + 1 ]; if ( flg ) ///\u63d2\u5165 { if ( sum == 2 ) cnt -- ; else if ( sum == 0 ) cnt ++ ; } else ///\u79fb\u9664 { if ( sum == 0 ) cnt -- ; else if ( sum == 2 ) cnt ++ ; } flag [ now ] = flg ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { if ( edge [ i ]. to != fa &&! vis [ edge [ i ]. to ]) { update ( edge [ i ]. to , now , flg ); } } } int dfs2 ( int now , int fa , bool kep ) { for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { if ( edge [ i ]. to != fa && edge [ i ]. to != hson [ now ]) { dfs2 ( edge [ i ]. to , now , false ); } } if ( hson [ now ] != -1 ) { dfs2 ( hson [ now ], now , true ); vis [ hson [ now ]] = 1 ; } update ( now , fa , true ); ans [ now ] = cnt ; if ( hson [ now ] != -1 ) vis [ hson [ now ]] = 0 ; if ( ! kep ) update ( now , fa , false ); } int main () { int t ; scanf ( \"%d\" , & t ); for ( int t1 = 1 ; t1 <= t ; t1 ++ ) { memset ( hson , -1 , sizeof ( hson )); memset ( head , 0 , sizeof ( head )); edge . clear (); edge . push_back ({ -1 , -1 , -1 }); int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n -1 ; i ++ ) { int x , y ; scanf ( \"%d%d\" , & x , & y ); add_edge ( x , y ); add_edge ( y , x ); } dfs1 ( 1 , 0 , -1 ); memset ( flag , 0 , sizeof ( flag )); memset ( vis , 0 , sizeof ( vis )); dfs2 ( 1 , -1 , false ); printf ( \"Case #%d:\" , t1 ); for ( int i = 1 ; i <= n ; i ++ ) printf ( \" %d\" , ans [ i ]); printf ( \" \\n \" ); } }","title":"\u89e3\u6790"},{"location":"csdn/2020-11-23/","text":"kmp\u7b97\u6cd5\u5339\u914d\u6a21\u677f #include <bits/stdc++.h> using namespace std ; const int maxn = 1000 ; int Next [ 1000006 ]; int Get_NEXT ( string p ) ///\u627e\u5b57\u4e32\u7684 { Next [ 0 ] = -1 ; int j = 0 ; int k = -1 ; while ( j < p . length ()) { if ( k == -1 || p [ j ] == p [ k ]) { j ++ ; k ++ ; Next [ j ] = k ; } else k = Next [ k ]; } } int KMP ( string s , string p ) ///\u4e3b\u4e32s\uff0c\u5b57\u4e32p { int i = 0 ; int j = 0 ; while (( i < ( int )( s . length ())) && ( j < ( int )( p . length ()))) { if ( j == -1 || s [ i ] == p [ j ]) { i ++ ; j ++ ; } else { j = Next [ j ]; } if ( j >= ( int )( p . length ())) { return i - ( int )( p . length ()); } } return 0 ; } int main () { string s , p ; cin >> s ; cin >> p ; Get_NEXT ( p ); cout << KMP ( s , p ); }","title":"2020-11-23"},{"location":"csdn/2020-12-02/","text":"[\u5916\u94fe\u56fe\u7247\u8f6c\u5b58\u5931\u8d25,\u6e90\u7ad9\u53ef\u80fd\u6709\u9632\u76d7\u94fe\u673a\u5236,\u5efa\u8bae\u5c06\u56fe\u7247\u4fdd\u5b58\u4e0b\u6765\u76f4\u63a5\u4e0a\u4f20(img-jIVkSS2i-1606919449049)( https://github.com/WCX1024979076/image1/blob/master/img/gou.jpg?raw=true )] [\u5916\u94fe\u56fe\u7247\u8f6c\u5b58\u5931\u8d25,\u6e90\u7ad9\u53ef\u80fd\u6709\u9632\u76d7\u94fe\u673a\u5236,\u5efa\u8bae\u5c06\u56fe\u7247\u4fdd\u5b58\u4e0b\u6765\u76f4\u63a5\u4e0a\u4f20(img-MQc294y6-1606919449069)( https://raw.githubusercontent.com/WCX1024979076/image1/master/img/gou.jpg )] [\u5916\u94fe\u56fe\u7247\u8f6c\u5b58\u5931\u8d25,\u6e90\u7ad9\u53ef\u80fd\u6709\u9632\u76d7\u94fe\u673a\u5236,\u5efa\u8bae\u5c06\u56fe\u7247\u4fdd\u5b58\u4e0b\u6765\u76f4\u63a5\u4e0a\u4f20(img-bz0hB4HN-1606919449077)( https://github.com/WCX1024979076/image1/raw/master/img/gou.jpg?raw=true )]","title":"2020-12-02"},{"location":"csdn/2020-7-31/","text":"http://icpc.upc.edu.cn/problem.php?cid=1459&pid=0 \u9898\u76ee \u00b6 \u8fd9\u662f\u4e00\u9053\u6a21\u677f\u9898\u3002 \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32A\u548c\u4e00\u4e2a\u5b57\u7b26\u4e32B\uff0c\u6c42B\u5728A\u4e2d\u7684\u51fa\u73b0\u6b21\u6570\u3002A\u548cB\u4e2d\u7684\u5b57\u7b26\u5747\u4e3a\u82f1\u8bed\u5927\u5199\u5b57\u6bcd\u6216\u5c0f\u5199\u5b57\u6bcd\u3002 A\u4e2d\u4e0d\u540c\u4f4d\u7f6e\u51fa\u73b0\u7684B\u53ef\u91cd\u53e0\u3002 \u8f93\u5165 \u00b6 \u8f93\u5165\u5171\u4e24\u884c\uff0c\u5206\u522b\u662f\u5b57\u7b26\u4e32A\u548c\u5b57\u7b26\u4e32B\u3002 \u8f93\u51fa \u00b6 \u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793aB\u5728A\u4e2d\u7684\u51fa\u73b0\u6b21\u6570\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 zyzyzyz zyz \u6837\u4f8b\u8f93\u51fa \u00b6 3 \u63d0\u793a \u00b6 1\u2264A,B\u7684\u957f\u5ea6\u226410^6\uff0cA\u3001B\u4ec5\u5305\u542b\u5927\u5c0f\u5199\u5b57\u6bcd\u3002 \u89e3\u6790 \u00b6 \u8fd9\u662f\u4e00\u9053\u5b57\u7b26\u4e32\u54c8\u5e0c\u7684\u9898\u76ee #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int N = 1e6 + 500 ; char a [ N ] = \"\" ; char b [ N ] = \"\" ; int base = 31 ; long long p [ N ] = { 0 }; long long h [ N ] = { 0 }; long long sum1 = 0 , js1 , sum = 0 ; int la = 1 , lb = 1 ; char w ; int main () { scanf ( \"%s\" , a + 1 ); scanf ( \"%s\" , b + 1 ); for (; a [ la ]; la ++ ); for (; b [ lb ]; lb ++ ); la -- ; lb -- ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= max ( la , lb ); i ++ ) p [ i ] = p [ i -1 ] * base ; //\u8fdb\u5236 if ( a [ 1 ] >= 'A' && a [ 1 ] <= 'Z' ) //\u5224\u65ad\u5927\u5c0f\u5199 w = 'A' ; else w = 'a' ; for ( int i = la ; i >= 1 ; i -- ) h [ i ] = h [ i + 1 ] * base + a [ i ] - w + 1 ; //\u6c42a\u5b57\u7b26\u4e32\u7684\u54c8\u5e0c\u6570\u7ec4 for ( int i = lb ; i >= 1 ; i -- ) sum1 = sum1 * base + b [ i ] - w + 1 ; //\u6c42b\u5b57\u7b26\u4e32\u7684\u54c8\u5e0c for ( int i = 1 ; i <= la - lb + 3 ; i ++ ) //\u6ce8\u610fi\u5fc5\u987b\u5c0f\u4e8e\u7b49\u4e8ela-lb \u5426\u5219\u6570\u7ec4\u4f1a\u8d8a\u754c { js1 = h [ i ] - h [ i + lb ] * p [ lb ]; //\u5224\u65ad\u662f\u5426\u76f8\u7b49 if ( js1 == sum1 ) sum += 1 ; } cout << sum << endl ; } http://icpc.upc.edu.cn/problem.php?cid=1459&pid=2 \u9898\u76ee \u00b6 Given two strings a and b we define a * b to be their concatenation. For example, if a = \"abc\" and b = \"def\" then a * b = \"abcdef\". If we think of concatenation as multiplication, exponentiation by a non-negative integer is defined in the normal way: a^0 = \"\" (the empty string) and a^(n+1) = a*(a^n). \u8f93\u5165 \u00b6 Each test case is a line of input representing s, a string of printable characters. \u8f93\u51fa \u00b6 For each s you should print the largest n such that s = a^n for some stringa. The length of s will be at least 1 and will not exceed 1 million characters. A line containing a period follows the last test case. \u6837\u4f8b\u8f93\u5165 \u00b6 abcd aaaa ababab \u6837\u4f8b\u8f93\u51fa \u00b6 1 4 3 \u89e3\u6790 \u00b6 KMP\u7b97\u6cd5\u7684\u5e94\u7528 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; const ll N = 1005000 ; ll Next [ N ]; char s [ N ]; char t [ N ]; ll tlen , len ; void getNext ( char s [ N ]) { ll j = 0 , k = -1 ; Next [ 0 ] = -1 ; while ( j < tlen ) { if ( k == -1 || s [ j ] == s [ k ]) { Next [ ++ j ] =++ k ; } else k = Next [ k ]; } } int main () { while ( 1 ) { scanf ( \"%s\" , s ); if ( s [ 0 ] == '.' ) break ; tlen = strlen ( s ); len = tlen ; getNext ( s ); ll kk = tlen - Next [ tlen ]; if ( strlen ( s ) % kk == 0 ) { printf ( \"%d \\n \" , strlen ( s ) / kk ); } else { printf ( \"1 \\n \" ); //\u5982\u679c\u4e0d\u80fd\u9664\u5c3d\uff0c\u8bf4\u660e\u6709\u540e\u7f00\uff0c\u4f8b\u5982abababa\uff0c\u8fd9\u79cd\u60c5\u51b5\u53ea\u80fd\u4e3a1 } } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2510&pid=4 \u9898\u76ee \u00b6 \u5728CSP\u521d\u8d5b\u540e\uff0cchen03\u7684RP\u5feb\u7528\u5b8c\u4e86\u3002 RP\u662f\u4e2a\u795e\u5947\u7684\u4e1c\u897f\u3002\u5177\u4f53\u6765\u8bf4\uff0cchen03\u7684RP\u503c\u53ef\u4ee5\u7528\u4e8c\u8fdb\u5236\u6b63\u6574\u6570a\u548c\u5341\u8fdb\u5236\u6b63\u6574\u6570n\u8868\u793a\u3002\u4ed6\u7684RP\u503c\u53ef\u4ee5\u8868\u793a\u4e3a RP=axor(a<<1)xor(a<<2)xor...xor(a<<(n-1))\u3002 \u5176\u4e2da<<i\u8868\u793a\u5c06a\u5de6\u79fbi\u4f4d\uff0cxor\u8868\u793a\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u3002 chen03\u60f3\u77e5\u9053\u4ed6\u7684RP\u503c\u662f\u591a\u5c11\u3002 \u6ce8\uff1a 1.\u5c06a\u5de6\u79fbi\u4f4d\uff0c\u5373\u5728a\u540e\u6dfb\u52a0i\u4e2a0\uff0c\u4e5f\u53ef\u4ee5\u770b\u6210a\u00d72i\uff0c\u5728C++\u4e2d\u7684\u8fd0\u7b97\u7b26\u4e3a<<\uff1b 2.\u6309\u4f4d\u5f02\u6216\uff1a\u5728\u4e8c\u8fdb\u5236\u4e0b\uff0c\u5bf9\u4e24\u4e2a\u6570\u7684\u6bcf\u4e00\u4f4d\u8fdb\u884c\u5f02\u6216\u8fd0\u7b97\uff0c\u5e76\u628a\u7ed3\u679c\u653e\u5230\u7b54\u6848\u7684\u5f53\u524d\u4f4d\u4e0a\uff0c\u5728C++\u4e2d\u7684\u8fd0\u7b97\u7b26\u4e3a^\u3002\u5f02\u6216\uff0c\u5373\u4e24\u4e2a\u503c\u540c\u4e3a1\u6216\u540c\u4e3a0\u65f6\u7ed3\u679c\u4e3a0\uff0c\u5426\u5219\u4e3a1\u3002 \u8f93\u5165 \u00b6 \u5171\u4e24\u884c\uff0c\u7b2c\u4e00\u884c\u4e00\u4e2a\u4e8c\u8fdb\u5236\u6b63\u6574\u6570 a\uff08\u4fdd\u8bc1\u4e0d\u542b\u524d\u5bfc 0\uff09\uff0c\u7b2c\u4e8c\u884c\u4e00\u4e2a\u5341\u8fdb\u5236\u6b63\u6574\u6570 n\uff0c\u610f\u4e49\u5982\u9898\u76ee\u63cf\u8ff0\u3002 \u8f93\u51fa \u00b6 \u4e00\u884c\u4e00\u4e2a\u4e8c\u8fdb\u5236\u6b63\u6574\u6570\uff0c\u8868\u793a chen03 \u7684 RP \u503c\u3002\u7b54\u6848\u4e0d\u7528\u53d6\u6a21\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 100001001 4 \u6837\u4f8b\u8f93\u51fa \u00b6 111101110111 \u63d0\u793a \u00b6 \u89e3\u6790 \u00b6 \u9996\u5148\u5148\u7b80\u5355\u4ecb\u7ecd\u4e00\u4e0b\u5f02\u6216(xor)\uff0c\u5f02\u6216\u5171\u5206\u4e3a4\u79cd\u60c5\u51b5 0\u5f02\u62161\u7b49\u4e8e1 1\u5f02\u62160\u7b49\u4e8e1 0\u5f02\u62160\u7b49\u4e8e0 1\u5f02\u62161\u7b49\u4e8e0 \u5f02\u6216\u6700\u540e\u7ed3\u679c\u53ea\u548c1\u7684\u4e2a\u6570\u6709\u5173\uff0c1\u4e3a\u5947\u6570\u4e2a\uff0c\u7ed3\u679c\u5c31\u4e3a1\uff0c1\u4e3a\u5076\u6570\u4e2a\uff0c\u7ed3\u679c\u5c31\u4e3a0\uff0c\u4f8b\u5982\uff1a 0 xor 0 xor 0 xor 1 = 1 0 xor 0 xor 1 xor 1 = 0 0 xor 0 xor 0 xor 1 xor 1 = 0 \u9898\u76ee\u662f\u6307\u5c06\u4e00\u4e2a2\u8fdb\u5236\u6570\u8fdb\u884c\u5411\u5de6\u79fb\u4f4d\u6c42\u5f02\u6216\u7ed3\u679c\uff0c\u4e0b\u56fe\u5c31\u662f\u5bf9\u6837\u4f8b\u7684\u89e3\u91ca\uff0c\u7b2c\u4e00\u4e8c\u4e09\u56db\u884c\u5206\u522b\u8868\u793a\u79fb\u52a8\u4e00\u4f4d\uff0c\u4e24\u4f4d\uff0c\u4e09\u4f4d\u548c\u56db\u4f4d\uff0c\u7136\u540e\u7edf\u8ba1\u6bcf\u4e00\u5217\u4e2d1\u7684\u6570\u76ee\uff0c\u5982\u679c1\u4e3a\u5947\u6570\u4e2a\uff0c\u7ed3\u679c\u5c31\u4e3a1\uff0c\u5426\u5219\u5c31\u4e3a0.\u3002 \u8fd9\u4e2a\u9898\u76ee\u53ef\u4ee5\u5206\u4e3a\u4e24\u79cd\u60c5\u51b5\uff0c\u6837\u4f8b\u662f\u5176\u4e2d\u7684\u4e00\u79cd\u60c5\u51b5\uff0cn\u7684\u6570\u76ee\u5c0f\u4e8e\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff0c\u53e6\u4e00\u79cd\u60c5\u51b5\u662f\u5927\u4e8e\uff0c\u5982 111 5 \u8fd9\u79cd\u60c5\u51b5\u53ef\u4ee5\u53d1\u73b0\u4e2d\u95f4\u90e8\u5206\u7684\u7ed3\u679c\u5168\u90e8\u76f8\u540c\uff0c\u5373\u5982\u4e0b\u56fe\u6240\u793a\uff1a \u7136\u540e\u76f4\u63a5\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u6c42\u6bcf\u4e00\u5217\u4e2d1\u7684\u4e2a\u6570\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; char a [ 1005000 ] = { 0 }; int b [ 1005000 ] = { 0 }; int c [ 1005000 ] = { 0 }; int main () { int n ; scanf ( \"%s\" , & a ); scanf ( \"%d\" , & n ); int m = strlen ( a ); int p = n - m ; queue < char > w ; int sum1 = 0 ; for ( int i = 0 ; a [ i ]; i ++ ) { if ( w . size () < n ) { w . push ( a [ i ]); if ( a [ i ] == '1' ) sum1 ++ ; int k1 = sum1 % 2 ; if ( k1 == 1 ) { printf ( \"1\" ); } else { printf ( \"0\" ); } } else { int p = w . front (); w . pop (); if ( p == '1' ) sum1 -- ; w . push ( a [ i ]); if ( a [ i ] == '1' ) sum1 ++ ; int k1 = sum1 % 2 ; if ( k1 == 1 ) { printf ( \"1\" ); } else { printf ( \"0\" ); } } } for ( int i = 0 ; i < p ; i ++ ) { int k1 = sum1 % 2 ; if ( k1 == 1 ) { printf ( \"1\" ); } else { printf ( \"0\" ); } } while ( w . size () != 1 ) { int p = w . front (); w . pop (); if ( p == '1' ) sum1 -- ; int k1 = sum1 % 2 ; if ( k1 == 1 ) { printf ( \"1\" ); } else { printf ( \"0\" ); } } } http://icpc.upc.edu.cn/problem.php?cid=1459&pid=3 \u9898\u76ee\u63cf\u8ff0 \u00b6 The little cat is so famous, that many couples tramp over hill and dale to Byteland, and asked the little cat to give names to their newly-born babies. They seek the name, and at the same time seek the fame. In order to escape from such boring job, the innovative little cat works out an easy but fantastic algorithm: Step1. Connect the father's name and the mother's name, to a new string S. Step2. Find a proper prefix-suffix string of S (which is not only the prefix, but also the suffix of S). Example: Father='ala', Mother='la', we have S = 'ala'+'la' = 'alala'. Potential prefix-suffix strings of S are {'a', 'ala', 'alala'}. Given the string S, could you help the little cat to write a program to calculate the length of possible prefix-suffix strings of S? (He might thank you by giving your baby a name:) \u8f93\u5165 \u00b6 The input contains a number of test cases. Each test case occupies a single line that contains the string S described above. Restrictions: Only lowercase letters may appear in the input. 1 <= Length of S <= 400000. \u8f93\u51fa \u00b6 For each test case, output a single line with integer numbers in increasing order, denoting the possible length of the new baby's name. \u6837\u4f8b\u8f93\u5165 \u00b6 ababcababababcabab aaaaa \u6837\u4f8b\u8f93\u51fa \u00b6 2 4 9 18 1 2 3 4 5 \u89e3\u6790 \u00b6 kmp\u7b97\u6cd5next\u6570\u7ec4\u7684\u5e94\u7528 #include <bits/stdc++.h> using namespace std ; char a [ 500500 ] = { 0 }; int Next [ 500500 ] = { 0 }; int getNext () { int i = 0 , j = -1 ; Next [ 0 ] = -1 ; while ( a [ i ]) { if ( j == -1 || a [ i ] == a [ j ]) { i ++ ; j ++ ; Next [ i ] = j ; } else { j = Next [ j ]; } } } int main () { while ( scanf ( \"%s\" , a ) != EOF ) { getNext (); int k = strlen ( a ); stack < int > w ; while ( k >= 1 ) { w . push ( k ); k = Next [ k ]; } while ( ! w . empty ()) { if ( w . size () == 1 ) cout << w . top () << endl ; else cout << w . top () << ' ' ; w . pop (); } } }","title":"2020-7-31"},{"location":"csdn/2020-7-31/#_1","text":"\u8fd9\u662f\u4e00\u9053\u6a21\u677f\u9898\u3002 \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32A\u548c\u4e00\u4e2a\u5b57\u7b26\u4e32B\uff0c\u6c42B\u5728A\u4e2d\u7684\u51fa\u73b0\u6b21\u6570\u3002A\u548cB\u4e2d\u7684\u5b57\u7b26\u5747\u4e3a\u82f1\u8bed\u5927\u5199\u5b57\u6bcd\u6216\u5c0f\u5199\u5b57\u6bcd\u3002 A\u4e2d\u4e0d\u540c\u4f4d\u7f6e\u51fa\u73b0\u7684B\u53ef\u91cd\u53e0\u3002","title":"\u9898\u76ee"},{"location":"csdn/2020-7-31/#_2","text":"\u8f93\u5165\u5171\u4e24\u884c\uff0c\u5206\u522b\u662f\u5b57\u7b26\u4e32A\u548c\u5b57\u7b26\u4e32B\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-7-31/#_3","text":"\u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793aB\u5728A\u4e2d\u7684\u51fa\u73b0\u6b21\u6570\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-7-31/#_4","text":"zyzyzyz zyz","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-7-31/#_5","text":"3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-7-31/#_6","text":"1\u2264A,B\u7684\u957f\u5ea6\u226410^6\uff0cA\u3001B\u4ec5\u5305\u542b\u5927\u5c0f\u5199\u5b57\u6bcd\u3002","title":"\u63d0\u793a"},{"location":"csdn/2020-7-31/#_7","text":"\u8fd9\u662f\u4e00\u9053\u5b57\u7b26\u4e32\u54c8\u5e0c\u7684\u9898\u76ee #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int N = 1e6 + 500 ; char a [ N ] = \"\" ; char b [ N ] = \"\" ; int base = 31 ; long long p [ N ] = { 0 }; long long h [ N ] = { 0 }; long long sum1 = 0 , js1 , sum = 0 ; int la = 1 , lb = 1 ; char w ; int main () { scanf ( \"%s\" , a + 1 ); scanf ( \"%s\" , b + 1 ); for (; a [ la ]; la ++ ); for (; b [ lb ]; lb ++ ); la -- ; lb -- ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= max ( la , lb ); i ++ ) p [ i ] = p [ i -1 ] * base ; //\u8fdb\u5236 if ( a [ 1 ] >= 'A' && a [ 1 ] <= 'Z' ) //\u5224\u65ad\u5927\u5c0f\u5199 w = 'A' ; else w = 'a' ; for ( int i = la ; i >= 1 ; i -- ) h [ i ] = h [ i + 1 ] * base + a [ i ] - w + 1 ; //\u6c42a\u5b57\u7b26\u4e32\u7684\u54c8\u5e0c\u6570\u7ec4 for ( int i = lb ; i >= 1 ; i -- ) sum1 = sum1 * base + b [ i ] - w + 1 ; //\u6c42b\u5b57\u7b26\u4e32\u7684\u54c8\u5e0c for ( int i = 1 ; i <= la - lb + 3 ; i ++ ) //\u6ce8\u610fi\u5fc5\u987b\u5c0f\u4e8e\u7b49\u4e8ela-lb \u5426\u5219\u6570\u7ec4\u4f1a\u8d8a\u754c { js1 = h [ i ] - h [ i + lb ] * p [ lb ]; //\u5224\u65ad\u662f\u5426\u76f8\u7b49 if ( js1 == sum1 ) sum += 1 ; } cout << sum << endl ; } http://icpc.upc.edu.cn/problem.php?cid=1459&pid=2","title":"\u89e3\u6790"},{"location":"csdn/2020-7-31/#_8","text":"Given two strings a and b we define a * b to be their concatenation. For example, if a = \"abc\" and b = \"def\" then a * b = \"abcdef\". If we think of concatenation as multiplication, exponentiation by a non-negative integer is defined in the normal way: a^0 = \"\" (the empty string) and a^(n+1) = a*(a^n).","title":"\u9898\u76ee"},{"location":"csdn/2020-7-31/#_9","text":"Each test case is a line of input representing s, a string of printable characters.","title":"\u8f93\u5165"},{"location":"csdn/2020-7-31/#_10","text":"For each s you should print the largest n such that s = a^n for some stringa. The length of s will be at least 1 and will not exceed 1 million characters. A line containing a period follows the last test case.","title":"\u8f93\u51fa"},{"location":"csdn/2020-7-31/#_11","text":"abcd aaaa ababab","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-7-31/#_12","text":"1 4 3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-7-31/#_13","text":"KMP\u7b97\u6cd5\u7684\u5e94\u7528 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; const ll N = 1005000 ; ll Next [ N ]; char s [ N ]; char t [ N ]; ll tlen , len ; void getNext ( char s [ N ]) { ll j = 0 , k = -1 ; Next [ 0 ] = -1 ; while ( j < tlen ) { if ( k == -1 || s [ j ] == s [ k ]) { Next [ ++ j ] =++ k ; } else k = Next [ k ]; } } int main () { while ( 1 ) { scanf ( \"%s\" , s ); if ( s [ 0 ] == '.' ) break ; tlen = strlen ( s ); len = tlen ; getNext ( s ); ll kk = tlen - Next [ tlen ]; if ( strlen ( s ) % kk == 0 ) { printf ( \"%d \\n \" , strlen ( s ) / kk ); } else { printf ( \"1 \\n \" ); //\u5982\u679c\u4e0d\u80fd\u9664\u5c3d\uff0c\u8bf4\u660e\u6709\u540e\u7f00\uff0c\u4f8b\u5982abababa\uff0c\u8fd9\u79cd\u60c5\u51b5\u53ea\u80fd\u4e3a1 } } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2510&pid=4","title":"\u89e3\u6790"},{"location":"csdn/2020-7-31/#_14","text":"\u5728CSP\u521d\u8d5b\u540e\uff0cchen03\u7684RP\u5feb\u7528\u5b8c\u4e86\u3002 RP\u662f\u4e2a\u795e\u5947\u7684\u4e1c\u897f\u3002\u5177\u4f53\u6765\u8bf4\uff0cchen03\u7684RP\u503c\u53ef\u4ee5\u7528\u4e8c\u8fdb\u5236\u6b63\u6574\u6570a\u548c\u5341\u8fdb\u5236\u6b63\u6574\u6570n\u8868\u793a\u3002\u4ed6\u7684RP\u503c\u53ef\u4ee5\u8868\u793a\u4e3a RP=axor(a<<1)xor(a<<2)xor...xor(a<<(n-1))\u3002 \u5176\u4e2da<<i\u8868\u793a\u5c06a\u5de6\u79fbi\u4f4d\uff0cxor\u8868\u793a\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u3002 chen03\u60f3\u77e5\u9053\u4ed6\u7684RP\u503c\u662f\u591a\u5c11\u3002 \u6ce8\uff1a 1.\u5c06a\u5de6\u79fbi\u4f4d\uff0c\u5373\u5728a\u540e\u6dfb\u52a0i\u4e2a0\uff0c\u4e5f\u53ef\u4ee5\u770b\u6210a\u00d72i\uff0c\u5728C++\u4e2d\u7684\u8fd0\u7b97\u7b26\u4e3a<<\uff1b 2.\u6309\u4f4d\u5f02\u6216\uff1a\u5728\u4e8c\u8fdb\u5236\u4e0b\uff0c\u5bf9\u4e24\u4e2a\u6570\u7684\u6bcf\u4e00\u4f4d\u8fdb\u884c\u5f02\u6216\u8fd0\u7b97\uff0c\u5e76\u628a\u7ed3\u679c\u653e\u5230\u7b54\u6848\u7684\u5f53\u524d\u4f4d\u4e0a\uff0c\u5728C++\u4e2d\u7684\u8fd0\u7b97\u7b26\u4e3a^\u3002\u5f02\u6216\uff0c\u5373\u4e24\u4e2a\u503c\u540c\u4e3a1\u6216\u540c\u4e3a0\u65f6\u7ed3\u679c\u4e3a0\uff0c\u5426\u5219\u4e3a1\u3002","title":"\u9898\u76ee"},{"location":"csdn/2020-7-31/#_15","text":"\u5171\u4e24\u884c\uff0c\u7b2c\u4e00\u884c\u4e00\u4e2a\u4e8c\u8fdb\u5236\u6b63\u6574\u6570 a\uff08\u4fdd\u8bc1\u4e0d\u542b\u524d\u5bfc 0\uff09\uff0c\u7b2c\u4e8c\u884c\u4e00\u4e2a\u5341\u8fdb\u5236\u6b63\u6574\u6570 n\uff0c\u610f\u4e49\u5982\u9898\u76ee\u63cf\u8ff0\u3002","title":"\u8f93\u5165"},{"location":"csdn/2020-7-31/#_16","text":"\u4e00\u884c\u4e00\u4e2a\u4e8c\u8fdb\u5236\u6b63\u6574\u6570\uff0c\u8868\u793a chen03 \u7684 RP \u503c\u3002\u7b54\u6848\u4e0d\u7528\u53d6\u6a21\u3002","title":"\u8f93\u51fa"},{"location":"csdn/2020-7-31/#_17","text":"100001001 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-7-31/#_18","text":"111101110111","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-7-31/#_19","text":"","title":"\u63d0\u793a"},{"location":"csdn/2020-7-31/#_20","text":"\u9996\u5148\u5148\u7b80\u5355\u4ecb\u7ecd\u4e00\u4e0b\u5f02\u6216(xor)\uff0c\u5f02\u6216\u5171\u5206\u4e3a4\u79cd\u60c5\u51b5 0\u5f02\u62161\u7b49\u4e8e1 1\u5f02\u62160\u7b49\u4e8e1 0\u5f02\u62160\u7b49\u4e8e0 1\u5f02\u62161\u7b49\u4e8e0 \u5f02\u6216\u6700\u540e\u7ed3\u679c\u53ea\u548c1\u7684\u4e2a\u6570\u6709\u5173\uff0c1\u4e3a\u5947\u6570\u4e2a\uff0c\u7ed3\u679c\u5c31\u4e3a1\uff0c1\u4e3a\u5076\u6570\u4e2a\uff0c\u7ed3\u679c\u5c31\u4e3a0\uff0c\u4f8b\u5982\uff1a 0 xor 0 xor 0 xor 1 = 1 0 xor 0 xor 1 xor 1 = 0 0 xor 0 xor 0 xor 1 xor 1 = 0 \u9898\u76ee\u662f\u6307\u5c06\u4e00\u4e2a2\u8fdb\u5236\u6570\u8fdb\u884c\u5411\u5de6\u79fb\u4f4d\u6c42\u5f02\u6216\u7ed3\u679c\uff0c\u4e0b\u56fe\u5c31\u662f\u5bf9\u6837\u4f8b\u7684\u89e3\u91ca\uff0c\u7b2c\u4e00\u4e8c\u4e09\u56db\u884c\u5206\u522b\u8868\u793a\u79fb\u52a8\u4e00\u4f4d\uff0c\u4e24\u4f4d\uff0c\u4e09\u4f4d\u548c\u56db\u4f4d\uff0c\u7136\u540e\u7edf\u8ba1\u6bcf\u4e00\u5217\u4e2d1\u7684\u6570\u76ee\uff0c\u5982\u679c1\u4e3a\u5947\u6570\u4e2a\uff0c\u7ed3\u679c\u5c31\u4e3a1\uff0c\u5426\u5219\u5c31\u4e3a0.\u3002 \u8fd9\u4e2a\u9898\u76ee\u53ef\u4ee5\u5206\u4e3a\u4e24\u79cd\u60c5\u51b5\uff0c\u6837\u4f8b\u662f\u5176\u4e2d\u7684\u4e00\u79cd\u60c5\u51b5\uff0cn\u7684\u6570\u76ee\u5c0f\u4e8e\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff0c\u53e6\u4e00\u79cd\u60c5\u51b5\u662f\u5927\u4e8e\uff0c\u5982 111 5 \u8fd9\u79cd\u60c5\u51b5\u53ef\u4ee5\u53d1\u73b0\u4e2d\u95f4\u90e8\u5206\u7684\u7ed3\u679c\u5168\u90e8\u76f8\u540c\uff0c\u5373\u5982\u4e0b\u56fe\u6240\u793a\uff1a \u7136\u540e\u76f4\u63a5\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u6c42\u6bcf\u4e00\u5217\u4e2d1\u7684\u4e2a\u6570\u5373\u53ef\u3002","title":"\u89e3\u6790"},{"location":"csdn/2020-7-31/#_21","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; char a [ 1005000 ] = { 0 }; int b [ 1005000 ] = { 0 }; int c [ 1005000 ] = { 0 }; int main () { int n ; scanf ( \"%s\" , & a ); scanf ( \"%d\" , & n ); int m = strlen ( a ); int p = n - m ; queue < char > w ; int sum1 = 0 ; for ( int i = 0 ; a [ i ]; i ++ ) { if ( w . size () < n ) { w . push ( a [ i ]); if ( a [ i ] == '1' ) sum1 ++ ; int k1 = sum1 % 2 ; if ( k1 == 1 ) { printf ( \"1\" ); } else { printf ( \"0\" ); } } else { int p = w . front (); w . pop (); if ( p == '1' ) sum1 -- ; w . push ( a [ i ]); if ( a [ i ] == '1' ) sum1 ++ ; int k1 = sum1 % 2 ; if ( k1 == 1 ) { printf ( \"1\" ); } else { printf ( \"0\" ); } } } for ( int i = 0 ; i < p ; i ++ ) { int k1 = sum1 % 2 ; if ( k1 == 1 ) { printf ( \"1\" ); } else { printf ( \"0\" ); } } while ( w . size () != 1 ) { int p = w . front (); w . pop (); if ( p == '1' ) sum1 -- ; int k1 = sum1 % 2 ; if ( k1 == 1 ) { printf ( \"1\" ); } else { printf ( \"0\" ); } } } http://icpc.upc.edu.cn/problem.php?cid=1459&pid=3","title":"\u4ee3\u7801"},{"location":"csdn/2020-7-31/#_22","text":"The little cat is so famous, that many couples tramp over hill and dale to Byteland, and asked the little cat to give names to their newly-born babies. They seek the name, and at the same time seek the fame. In order to escape from such boring job, the innovative little cat works out an easy but fantastic algorithm: Step1. Connect the father's name and the mother's name, to a new string S. Step2. Find a proper prefix-suffix string of S (which is not only the prefix, but also the suffix of S). Example: Father='ala', Mother='la', we have S = 'ala'+'la' = 'alala'. Potential prefix-suffix strings of S are {'a', 'ala', 'alala'}. Given the string S, could you help the little cat to write a program to calculate the length of possible prefix-suffix strings of S? (He might thank you by giving your baby a name:)","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/2020-7-31/#_23","text":"The input contains a number of test cases. Each test case occupies a single line that contains the string S described above. Restrictions: Only lowercase letters may appear in the input. 1 <= Length of S <= 400000.","title":"\u8f93\u5165"},{"location":"csdn/2020-7-31/#_24","text":"For each test case, output a single line with integer numbers in increasing order, denoting the possible length of the new baby's name.","title":"\u8f93\u51fa"},{"location":"csdn/2020-7-31/#_25","text":"ababcababababcabab aaaaa","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/2020-7-31/#_26","text":"2 4 9 18 1 2 3 4 5","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/2020-7-31/#_27","text":"kmp\u7b97\u6cd5next\u6570\u7ec4\u7684\u5e94\u7528 #include <bits/stdc++.h> using namespace std ; char a [ 500500 ] = { 0 }; int Next [ 500500 ] = { 0 }; int getNext () { int i = 0 , j = -1 ; Next [ 0 ] = -1 ; while ( a [ i ]) { if ( j == -1 || a [ i ] == a [ j ]) { i ++ ; j ++ ; Next [ i ] = j ; } else { j = Next [ j ]; } } } int main () { while ( scanf ( \"%s\" , a ) != EOF ) { getNext (); int k = strlen ( a ); stack < int > w ; while ( k >= 1 ) { w . push ( k ); k = Next [ k ]; } while ( ! w . empty ()) { if ( w . size () == 1 ) cout << w . top () << endl ; else cout << w . top () << ' ' ; w . pop (); } } }","title":"\u89e3\u6790"},{"location":"csdn/2021-02-02/","text":"A\u9898 \u00b6 \u9898\u89e3 \u00b6 \u7b7e\u5230\u9898\u76ee\uff0c\u7ed9\u5b9a\u4e09\u4e2a\u6570a,b\u548cc\uff0c\u9009\u62e9\u4e00\u4e2a\u6570x\uff0c\u4f7f\u5f97x-2<=a\uff0cx-1<=b\u4e14x<=c\uff0c\u6c423*x-3\u7684\u6700\u5927\u503c\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; int main () { int a , b , c ; cin >> a >> b >> c ; int min1 = min ( a + 2 , min ( b + 1 , c )); cout << min1 + min1 -1 + min1 -2 << endl ; } B\u9898 \u00b6 \u9898\u89e3 \u00b6 \u7ed9\u5b9a2 * n\u4e2a\u70b9\uff0c\u5728\u524dn\u4e2a\u70b9\u4e2d\u9009\u4e00\u4e2a\u70b9i\uff0c\u5728\u540en\u4e2a\u70b9\u4e2d\u9009\u4e00\u4e2a\u70b9j\uff0c\u6784\u9020\u4e00\u79cd\u5339\u914d\u65b9\u5f0f\u4f7f\u5f97\u4efb\u610f\u4e24\u70b9\u6a2a\u7eb5\u5750\u6807\u548c(xi+xj,yi+yj)\u5747\u76f8\u540c\u3002\u7531\u4e8exi+xj\u5747\u76f8\u540c\uff0c\u53ef\u4ee5\u628a\u8fd92 * n\u4e2a\u70b9\u7684x\u5750\u6807\u8fdb\u884c\u6c42\u548c\u7136\u540e\u5e73\u5747\u5206\u914d\u6210n\u4efd\uff0c\u8fd9\u6837\u5c31\u5f97\u5230\u4e86xi+xj\u7684\u5b9a\u503c\uff0cy\u5750\u6807\u540c\u7406\u3002\uff08\u6ce8\u610f\u5f00long long\uff09 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n ; scanf ( \"%lld\" , & n ); ll sum1 = 0 , sum2 = 0 , x , y ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { scanf ( \"%lld%lld\" , & x , & y ); sum1 += x , sum2 += y ; } sum1 /= n , sum2 /= n ; cout << sum1 << ' ' << sum2 << endl ; } C\u9898 \u00b6 \u9898\u89e3 \u00b6 \u8be5\u9898\u4e3a\u6253\u8868\u627e\u89c4\u5f8b\u6240\u505a\u51fa\u6765\u7684\uff0c\u5bb9\u6613\u53d1\u73b0\u8fd9\u4e9b\u6700\u5c0f\u503c\u6240\u5bf9\u5e94\u7684k\u53ef\u4ee5\u548cn\u7684\u56e0\u6570\u4e00\u4e00\u5bf9\u5e94\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u679a\u4e3en\u7684\u56e0\u6570\u7136\u540e\u6c42\u51fa\u7ed3\u679c\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; set < ll > s ; ll n ; ll cal ( ll x ) { ll size1 = n / x ; ll ans = size1 + size1 * ( size1 -1 ) / 2 * x ; return ans ; } int main () { scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { s . insert ( cal ( i )); s . insert ( cal ( n / i )); } } set < ll > :: iterator it = s . begin (); while ( it != s . end ()) { cout <<* it << ' ' ; it ++ ; } cout << endl ; } D\u9898 \u00b6 \u9898\u89e3 \u00b6 \u8fd9\u91cc\u4ee5n=4\u4e3a\u4f8b \u56db\u4e2a\u6570\u4e00\u7ec4\uff0c\u53ef\u4ee5\u7ec4\u62104! \u4e2a\u7b54\u6848 \u7b2c\u4e00\u6392\u5f53\u4e2d \u6bcf\u4e00\u5bf9\u6570\u540e\u4e09\u4e2a \u548c \u4e0b\u4e00\u5bf9\u6570\u7684\u7b2c\u4e00\u4e2a \u7ec4\u6210\u4e00\u4e2a\u7b54\u6848\uff0c\u800c\u7b2c\u4e00\u6392\u4e2d\u6070\u67093! \u5bf9\u6570\uff0c\u6240\u4ee5\u7b54\u6848\u4e3a(3! - 1)*4 \u7b2c\u4e00\u6392\u6709\u516d\u5bf9\u6570\uff0c\u53ef\u4ee5\u5212\u5206\u4e3a3\u7ec4\uff0c\u6bcf\u7ec4\u4e24\u4e2a\uff0c\u4e14\u6bcf\u7ec4\u4e2d \u4e0a\u4e00\u5bf9\u6570\u7684\u540e\u4e24\u4e2a \u548c \u4e0b\u4e00\u5bf9\u6570\u7684\u524d\u4e24\u4e2a \u7ec4\u6210\u7b54\u6848\uff0c\u6240\u4ee5\u7b54\u6848\u53c8\u5e94\u5f53\u52a0\u4e0a(2! - 1) * 4 * 3 \u7efc\u4e0a\u7b54\u6848\u4e3a4! + (3! - 1) * 4 + (2! - 1) * 4 * 3 =56 \u540c\u7406\uff0c5\u7684\u7b54\u6848\u4e3a\uff1a5! + (4! - 1) * 5 + (3! - 1) * 5 * 4 + (2! - 1) * 5 * 4 * 3 = 4 *5! - 5 - 5 *4 - 5 *4 *3 = 395 \u6ce8\u610f\u7279\u52241 \uff01\uff01\uff01 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n ; const ll mod = 998244353 ; int main () { scanf ( \"%lld\" , & n ); if ( n == 1 ) { cout << 1 << endl ; return 0 ; } ll ans = 1 ; for ( ll i = 1 ; i <= n ; i ++ ) { ans = ans * i ; ans %= mod ; } ans = ans * ( n -1 ); ans %= mod ; ll sum1 = 1 ; for ( ll i = n ; i >= 3 ; i -- ) { sum1 *= i ; sum1 %= mod ; ans = ans - sum1 ; ans = ( ans % mod + mod ) % mod ; } ans = ( ans % mod + mod ) % mod ; cout << ans << endl ; } I\u9898 \u00b6 \u9898\u89e3 \u00b6 \u56fe\u8bba\u9898\u76ee\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u8be5\u70b9\u5230\u6839\u8282\u70b9\u7684\u6743\u503c\u6700\u5c0f\u503c\u5373\u4e3a\u5b50\u8282\u70b9\u6743\u503c\u7684\u6700\u5c0f\u503c\uff0c\u6240\u4ee5\u5148dfs\u786e\u5b9a-1\u70b9\u7684\u6743\u503cs[i]\uff0c\u7136\u540e\u6839\u636e\u5f97\u51fa\u7684\u6743\u503c\u8be5\u70b9\u6743\u503cs[i]\u548c\u7236\u8282\u70b9\u6743\u503cs[i]\u5224\u65ad\u662f\u5426\u7b26\u5408\u6761\u4ef6\u5e76\u6c42\u548c\u5f97\u51fa\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; vector < ll > v [ 100500 ]; ll s [ 100500 ] = { 0 }; ll fa [ 100500 ] = { 0 }; ll dfs ( ll k , ll fa ) { ll min1 = inf ; for ( int i : v [ k ]) { if ( i != fa ) { if ( dfs ( i , k ) == -1 ) return -1 ; if ( s [ i ] != -1 ) min1 = min ( min1 , s [ i ]); } } if ( s [ k ] == -1 ) { if ( min1 != inf ) s [ k ] = min1 ; } else { if ( s [ k ] > min1 ) return -1 ; } return 0 ; } ll ans = 0 ; ll dfs1 ( ll k , ll fa , ll sum ) { if ( s [ k ] == -1 ) return 0 ; if ( s [ k ] < sum ) return -1 ; sum = max ( sum , s [ k ]); ans = ans + s [ k ] - s [ fa ]; for ( int i : v [ k ]) { if ( i != fa ) { if ( dfs1 ( i , k , sum ) == -1 ) return -1 ; } } return 0 ; } int main () { ll n , m ; scanf ( \"%lld\" , & n ); fa [ 1 ] = 0 ; for ( ll i = 2 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & m ); fa [ i ] = m ; v [ i ]. push_back ( m ); v [ m ]. push_back ( i ); } for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & s [ i ]); s [ 0 ] = 0 ; if ( dfs ( 1 , -1 ) == -1 ) { printf ( \"-1 \\n \" ); return 0 ; } if ( dfs1 ( 1 , 0 , 0 ) == -1 ) { printf ( \"-1 \\n \" ); return 0 ; } cout << ans << endl ; }","title":"2021-02-02"},{"location":"csdn/2021-02-02/#a","text":"","title":"A\u9898"},{"location":"csdn/2021-02-02/#_1","text":"\u7b7e\u5230\u9898\u76ee\uff0c\u7ed9\u5b9a\u4e09\u4e2a\u6570a,b\u548cc\uff0c\u9009\u62e9\u4e00\u4e2a\u6570x\uff0c\u4f7f\u5f97x-2<=a\uff0cx-1<=b\u4e14x<=c\uff0c\u6c423*x-3\u7684\u6700\u5927\u503c\u3002","title":"\u9898\u89e3"},{"location":"csdn/2021-02-02/#_2","text":"#include <bits/stdc++.h> using namespace std ; int main () { int a , b , c ; cin >> a >> b >> c ; int min1 = min ( a + 2 , min ( b + 1 , c )); cout << min1 + min1 -1 + min1 -2 << endl ; }","title":"\u4ee3\u7801"},{"location":"csdn/2021-02-02/#b","text":"","title":"B\u9898"},{"location":"csdn/2021-02-02/#_3","text":"\u7ed9\u5b9a2 * n\u4e2a\u70b9\uff0c\u5728\u524dn\u4e2a\u70b9\u4e2d\u9009\u4e00\u4e2a\u70b9i\uff0c\u5728\u540en\u4e2a\u70b9\u4e2d\u9009\u4e00\u4e2a\u70b9j\uff0c\u6784\u9020\u4e00\u79cd\u5339\u914d\u65b9\u5f0f\u4f7f\u5f97\u4efb\u610f\u4e24\u70b9\u6a2a\u7eb5\u5750\u6807\u548c(xi+xj,yi+yj)\u5747\u76f8\u540c\u3002\u7531\u4e8exi+xj\u5747\u76f8\u540c\uff0c\u53ef\u4ee5\u628a\u8fd92 * n\u4e2a\u70b9\u7684x\u5750\u6807\u8fdb\u884c\u6c42\u548c\u7136\u540e\u5e73\u5747\u5206\u914d\u6210n\u4efd\uff0c\u8fd9\u6837\u5c31\u5f97\u5230\u4e86xi+xj\u7684\u5b9a\u503c\uff0cy\u5750\u6807\u540c\u7406\u3002\uff08\u6ce8\u610f\u5f00long long\uff09","title":"\u9898\u89e3"},{"location":"csdn/2021-02-02/#_4","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n ; scanf ( \"%lld\" , & n ); ll sum1 = 0 , sum2 = 0 , x , y ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { scanf ( \"%lld%lld\" , & x , & y ); sum1 += x , sum2 += y ; } sum1 /= n , sum2 /= n ; cout << sum1 << ' ' << sum2 << endl ; }","title":"\u4ee3\u7801"},{"location":"csdn/2021-02-02/#c","text":"","title":"C\u9898"},{"location":"csdn/2021-02-02/#_5","text":"\u8be5\u9898\u4e3a\u6253\u8868\u627e\u89c4\u5f8b\u6240\u505a\u51fa\u6765\u7684\uff0c\u5bb9\u6613\u53d1\u73b0\u8fd9\u4e9b\u6700\u5c0f\u503c\u6240\u5bf9\u5e94\u7684k\u53ef\u4ee5\u548cn\u7684\u56e0\u6570\u4e00\u4e00\u5bf9\u5e94\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u679a\u4e3en\u7684\u56e0\u6570\u7136\u540e\u6c42\u51fa\u7ed3\u679c\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"csdn/2021-02-02/#_6","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; set < ll > s ; ll n ; ll cal ( ll x ) { ll size1 = n / x ; ll ans = size1 + size1 * ( size1 -1 ) / 2 * x ; return ans ; } int main () { scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { s . insert ( cal ( i )); s . insert ( cal ( n / i )); } } set < ll > :: iterator it = s . begin (); while ( it != s . end ()) { cout <<* it << ' ' ; it ++ ; } cout << endl ; }","title":"\u4ee3\u7801"},{"location":"csdn/2021-02-02/#d","text":"","title":"D\u9898"},{"location":"csdn/2021-02-02/#_7","text":"\u8fd9\u91cc\u4ee5n=4\u4e3a\u4f8b \u56db\u4e2a\u6570\u4e00\u7ec4\uff0c\u53ef\u4ee5\u7ec4\u62104! \u4e2a\u7b54\u6848 \u7b2c\u4e00\u6392\u5f53\u4e2d \u6bcf\u4e00\u5bf9\u6570\u540e\u4e09\u4e2a \u548c \u4e0b\u4e00\u5bf9\u6570\u7684\u7b2c\u4e00\u4e2a \u7ec4\u6210\u4e00\u4e2a\u7b54\u6848\uff0c\u800c\u7b2c\u4e00\u6392\u4e2d\u6070\u67093! \u5bf9\u6570\uff0c\u6240\u4ee5\u7b54\u6848\u4e3a(3! - 1)*4 \u7b2c\u4e00\u6392\u6709\u516d\u5bf9\u6570\uff0c\u53ef\u4ee5\u5212\u5206\u4e3a3\u7ec4\uff0c\u6bcf\u7ec4\u4e24\u4e2a\uff0c\u4e14\u6bcf\u7ec4\u4e2d \u4e0a\u4e00\u5bf9\u6570\u7684\u540e\u4e24\u4e2a \u548c \u4e0b\u4e00\u5bf9\u6570\u7684\u524d\u4e24\u4e2a \u7ec4\u6210\u7b54\u6848\uff0c\u6240\u4ee5\u7b54\u6848\u53c8\u5e94\u5f53\u52a0\u4e0a(2! - 1) * 4 * 3 \u7efc\u4e0a\u7b54\u6848\u4e3a4! + (3! - 1) * 4 + (2! - 1) * 4 * 3 =56 \u540c\u7406\uff0c5\u7684\u7b54\u6848\u4e3a\uff1a5! + (4! - 1) * 5 + (3! - 1) * 5 * 4 + (2! - 1) * 5 * 4 * 3 = 4 *5! - 5 - 5 *4 - 5 *4 *3 = 395 \u6ce8\u610f\u7279\u52241 \uff01\uff01\uff01","title":"\u9898\u89e3"},{"location":"csdn/2021-02-02/#_8","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n ; const ll mod = 998244353 ; int main () { scanf ( \"%lld\" , & n ); if ( n == 1 ) { cout << 1 << endl ; return 0 ; } ll ans = 1 ; for ( ll i = 1 ; i <= n ; i ++ ) { ans = ans * i ; ans %= mod ; } ans = ans * ( n -1 ); ans %= mod ; ll sum1 = 1 ; for ( ll i = n ; i >= 3 ; i -- ) { sum1 *= i ; sum1 %= mod ; ans = ans - sum1 ; ans = ( ans % mod + mod ) % mod ; } ans = ( ans % mod + mod ) % mod ; cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"csdn/2021-02-02/#i","text":"","title":"I\u9898"},{"location":"csdn/2021-02-02/#_9","text":"\u56fe\u8bba\u9898\u76ee\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u8be5\u70b9\u5230\u6839\u8282\u70b9\u7684\u6743\u503c\u6700\u5c0f\u503c\u5373\u4e3a\u5b50\u8282\u70b9\u6743\u503c\u7684\u6700\u5c0f\u503c\uff0c\u6240\u4ee5\u5148dfs\u786e\u5b9a-1\u70b9\u7684\u6743\u503cs[i]\uff0c\u7136\u540e\u6839\u636e\u5f97\u51fa\u7684\u6743\u503c\u8be5\u70b9\u6743\u503cs[i]\u548c\u7236\u8282\u70b9\u6743\u503cs[i]\u5224\u65ad\u662f\u5426\u7b26\u5408\u6761\u4ef6\u5e76\u6c42\u548c\u5f97\u51fa\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"csdn/2021-02-02/#_10","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; vector < ll > v [ 100500 ]; ll s [ 100500 ] = { 0 }; ll fa [ 100500 ] = { 0 }; ll dfs ( ll k , ll fa ) { ll min1 = inf ; for ( int i : v [ k ]) { if ( i != fa ) { if ( dfs ( i , k ) == -1 ) return -1 ; if ( s [ i ] != -1 ) min1 = min ( min1 , s [ i ]); } } if ( s [ k ] == -1 ) { if ( min1 != inf ) s [ k ] = min1 ; } else { if ( s [ k ] > min1 ) return -1 ; } return 0 ; } ll ans = 0 ; ll dfs1 ( ll k , ll fa , ll sum ) { if ( s [ k ] == -1 ) return 0 ; if ( s [ k ] < sum ) return -1 ; sum = max ( sum , s [ k ]); ans = ans + s [ k ] - s [ fa ]; for ( int i : v [ k ]) { if ( i != fa ) { if ( dfs1 ( i , k , sum ) == -1 ) return -1 ; } } return 0 ; } int main () { ll n , m ; scanf ( \"%lld\" , & n ); fa [ 1 ] = 0 ; for ( ll i = 2 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & m ); fa [ i ] = m ; v [ i ]. push_back ( m ); v [ m ]. push_back ( i ); } for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & s [ i ]); s [ 0 ] = 0 ; if ( dfs ( 1 , -1 ) == -1 ) { printf ( \"-1 \\n \" ); return 0 ; } if ( dfs1 ( 1 , 0 , 0 ) == -1 ) { printf ( \"-1 \\n \" ); return 0 ; } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"csdn/2021-02-24/","text":"2020 icpc asia tehran regional contest E\u9898 \u00b6 Social Distancing \u00b6 \u9898\u89e3 \u00b6 \u5207\u6bd4\u96ea\u592b\u8ddd\u79bb\u548c\u66fc\u54c8\u987f\u8ddd\u79bb\u76f8\u4e92\u8f6c\u53d8 \u6839\u636e\u4e0a\u8ff0\u6027\u8d28\uff0c\u53ef\u4ee5\u5c06\u6c42\u5207\u6bd4\u96ea\u592b\u4e0d\u7b49\u5f0f\u6700\u5c0f\u503c\u8f6c\u5316\u4e3a\u6c42\u66fc\u54c8\u987f\u8ddd\u79bb\u7684\u6700\u5c0f\u503c\u3002 \u4e8c\u7ef4\u77e9\u9635\u6c42\u66fc\u54c8\u987f\u8ddd\u79bb\u53ef\u4ee5\u6839\u636e\u524d\u7f00\u548c\u6765\u51cf\u5c11\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u5982\u679c\u8be5\u70b9\u975e\u75c5\u4eba\uff0c\u6807\u8bb0\u4e3a1\uff0c\u4ee3\u8868\u8be5\u70b9\u6743\u503c\u4e3a1\uff1b\u53cd\u4e4b\u5219\u6807\u8bb0\u4e3a-1\uff0c\u540e\u671f\u6c42\u524d\u7f00\u548c\u65f6\u8be5\u70b9\u6743\u503c\u5b9a\u4e3a0\uff1b\u7136\u540e\u5206\u522b\u6cbf\u56db\u4e2a\u65b9\u5411\u6c42\u524d\u7f00\u548c\uff0c\u53d6\u6700\u5c0f\u503c\u5373\u4e3a\u6bcf\u4e2a\u70b9\u7684\u6700\u5c0f\u66fc\u54c8\u987f\u8ddd\u79bb\u3002 \u6700\u540e\u6839\u636e\u6700\u5c0f\u66fc\u54c8\u987f\u8ddd\u79bbdfs\u8fdb\u884c\u641c\u7d22\u5373\u53ef\u5f97\u51fa\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char a [ 505 ][ 505 ] = { 0 }; int ans1 [ 505 ][ 505 ] = { 0 }; int dis [ 505 ][ 505 ] = { 0 }; int sx , sy , ex , ey ; struct node { int x , y , val ; }; int dx [] = { 0 , 1 , -1 , 0 , 0 }; int dy [] = { 0 , 0 , 0 , 1 , -1 }; int n , m ; int ans = -1 ; int dfs ( int x , int y , int val ) { if ( ans >= val ) return 0 ; if ( x == ex && y == ey ) { ans = max ( ans , val ); return 0 ; } for ( int i = 1 ; i <= 4 ; i ++ ) { int xx = x + dx [ i ], yy = y + dy [ i ]; if ( xx < 1 || xx > n || yy < 1 || yy > m ) continue ; if ( a [ xx ][ yy ] == '#' ) continue ; int val1 = min ( val , dis [ xx ][ yy ]); if ( ans1 [ xx ][ yy ] >= val1 ) continue ; ans1 [ xx ][ yy ] = val1 ; dfs ( xx , yy , val1 ); } return 0 ; } int mp [ 1050 ][ 1050 ] = { 0 }; int mp_sum1 [ 1050 ][ 1050 ] = { 0 }; int mp_sum2 [ 1050 ][ 1050 ] = { 0 }; int mp_sum3 [ 1050 ][ 1050 ] = { 0 }; int mp_sum4 [ 1050 ][ 1050 ] = { 0 }; int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dis [ i ][ j ] = inf ; } } for ( int i = 0 ; i < 1050 ; i ++ ) for ( int j = 0 ; j < 1050 ; j ++ ) mp_sum1 [ i ][ j ] = mp_sum2 [ i ][ j ] = mp_sum3 [ i ][ j ] = mp_sum4 [ i ][ j ] = inf ; int sum = 0 ; for ( int i = 0 ; i <= n + 1 ; i ++ ) { int j = 0 ; mp [ i + j ][ i - j + 500 ] = inf ; j = m + 1 ; mp [ i + j ][ i - j + 500 ] = inf ; } for ( int j = 0 ; j <= m + 1 ; j ++ ) { int i = 0 ; mp [ i + j ][ i - j + 500 ] = inf ; i = n + 1 ; mp [ i + j ][ i - j + 500 ] = inf ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ][ j ] == '*' ) { sum ++ ; mp [ i + j ][ i - j + 500 ] = -1 ; } else { mp [ i + j ][ i - j + 500 ] = 1 ; } if ( a [ i ][ j ] == 'S' ) sx = i , sy = j ; if ( a [ i ][ j ] == 'E' ) ex = i , ey = j ; } } for ( int i = 1 ; i < 1050 ; i ++ ) { for ( int j = 1 ; j < 1050 ; j ++ ) { if ( mp [ i ][ j ] == -1 ) mp_sum1 [ i ][ j ] = 0 ; else mp_sum1 [ i ][ j ] = min ( mp_sum1 [ i ][ j ], min ( mp_sum1 [ i -1 ][ j ], mp_sum1 [ i ][ j -1 ]) + mp [ i ][ j ]); } } for ( int i = 1 ; i < 1050 ; i ++ ) { for ( int j = 1049 ; j >= 1 ; j -- ) { if ( mp [ i ][ j ] == -1 ) mp_sum2 [ i ][ j ] = 0 ; else mp_sum2 [ i ][ j ] = min ( mp_sum2 [ i ][ j ], min ( mp_sum2 [ i -1 ][ j ], mp_sum2 [ i ][ j + 1 ]) + mp [ i ][ j ]); } } for ( int i = 1049 ; i >= 1 ; i -- ) { for ( int j = 1 ; j < 1050 ; j ++ ) { if ( mp [ i ][ j ] == -1 ) mp_sum3 [ i ][ j ] = 0 ; else mp_sum3 [ i ][ j ] = min ( mp_sum3 [ i ][ j ], min ( mp_sum3 [ i + 1 ][ j ], mp_sum3 [ i ][ j -1 ]) + mp [ i ][ j ]); } } for ( int i = 1049 ; i >= 1 ; i -- ) { for ( int j = 1049 ; j >= 1 ; j -- ) { if ( mp [ i ][ j ] == -1 ) mp_sum4 [ i ][ j ] = 0 ; else mp_sum4 [ i ][ j ] = min ( mp_sum4 [ i ][ j ], min ( mp_sum4 [ i + 1 ][ j ], mp_sum4 [ i ][ j + 1 ]) + mp [ i ][ j ]); } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int xx = i + j , yy = i - j + 500 ; dis [ i ][ j ] = min ( min ( mp_sum1 [ xx ][ yy ], mp_sum2 [ xx ][ yy ]), min ( mp_sum3 [ xx ][ yy ], mp_sum4 [ xx ][ yy ])); } } dfs ( sx , sy , dis [ sx ][ sy ]); if ( ans != -1 && sum == 0 ) { printf ( \"safe \\n \" ); return 0 ; } printf ( \"%d \\n \" , ans ); return 0 ; }","title":"2021-02-24"},{"location":"csdn/2021-02-24/#2020-icpc-asia-tehran-regional-contest-e","text":"","title":"2020 icpc asia tehran regional contest E\u9898"},{"location":"csdn/2021-02-24/#social-distancing","text":"","title":"Social Distancing"},{"location":"csdn/2021-02-24/#_1","text":"\u5207\u6bd4\u96ea\u592b\u8ddd\u79bb\u548c\u66fc\u54c8\u987f\u8ddd\u79bb\u76f8\u4e92\u8f6c\u53d8 \u6839\u636e\u4e0a\u8ff0\u6027\u8d28\uff0c\u53ef\u4ee5\u5c06\u6c42\u5207\u6bd4\u96ea\u592b\u4e0d\u7b49\u5f0f\u6700\u5c0f\u503c\u8f6c\u5316\u4e3a\u6c42\u66fc\u54c8\u987f\u8ddd\u79bb\u7684\u6700\u5c0f\u503c\u3002 \u4e8c\u7ef4\u77e9\u9635\u6c42\u66fc\u54c8\u987f\u8ddd\u79bb\u53ef\u4ee5\u6839\u636e\u524d\u7f00\u548c\u6765\u51cf\u5c11\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u5982\u679c\u8be5\u70b9\u975e\u75c5\u4eba\uff0c\u6807\u8bb0\u4e3a1\uff0c\u4ee3\u8868\u8be5\u70b9\u6743\u503c\u4e3a1\uff1b\u53cd\u4e4b\u5219\u6807\u8bb0\u4e3a-1\uff0c\u540e\u671f\u6c42\u524d\u7f00\u548c\u65f6\u8be5\u70b9\u6743\u503c\u5b9a\u4e3a0\uff1b\u7136\u540e\u5206\u522b\u6cbf\u56db\u4e2a\u65b9\u5411\u6c42\u524d\u7f00\u548c\uff0c\u53d6\u6700\u5c0f\u503c\u5373\u4e3a\u6bcf\u4e2a\u70b9\u7684\u6700\u5c0f\u66fc\u54c8\u987f\u8ddd\u79bb\u3002 \u6700\u540e\u6839\u636e\u6700\u5c0f\u66fc\u54c8\u987f\u8ddd\u79bbdfs\u8fdb\u884c\u641c\u7d22\u5373\u53ef\u5f97\u51fa\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"csdn/2021-02-24/#_2","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char a [ 505 ][ 505 ] = { 0 }; int ans1 [ 505 ][ 505 ] = { 0 }; int dis [ 505 ][ 505 ] = { 0 }; int sx , sy , ex , ey ; struct node { int x , y , val ; }; int dx [] = { 0 , 1 , -1 , 0 , 0 }; int dy [] = { 0 , 0 , 0 , 1 , -1 }; int n , m ; int ans = -1 ; int dfs ( int x , int y , int val ) { if ( ans >= val ) return 0 ; if ( x == ex && y == ey ) { ans = max ( ans , val ); return 0 ; } for ( int i = 1 ; i <= 4 ; i ++ ) { int xx = x + dx [ i ], yy = y + dy [ i ]; if ( xx < 1 || xx > n || yy < 1 || yy > m ) continue ; if ( a [ xx ][ yy ] == '#' ) continue ; int val1 = min ( val , dis [ xx ][ yy ]); if ( ans1 [ xx ][ yy ] >= val1 ) continue ; ans1 [ xx ][ yy ] = val1 ; dfs ( xx , yy , val1 ); } return 0 ; } int mp [ 1050 ][ 1050 ] = { 0 }; int mp_sum1 [ 1050 ][ 1050 ] = { 0 }; int mp_sum2 [ 1050 ][ 1050 ] = { 0 }; int mp_sum3 [ 1050 ][ 1050 ] = { 0 }; int mp_sum4 [ 1050 ][ 1050 ] = { 0 }; int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dis [ i ][ j ] = inf ; } } for ( int i = 0 ; i < 1050 ; i ++ ) for ( int j = 0 ; j < 1050 ; j ++ ) mp_sum1 [ i ][ j ] = mp_sum2 [ i ][ j ] = mp_sum3 [ i ][ j ] = mp_sum4 [ i ][ j ] = inf ; int sum = 0 ; for ( int i = 0 ; i <= n + 1 ; i ++ ) { int j = 0 ; mp [ i + j ][ i - j + 500 ] = inf ; j = m + 1 ; mp [ i + j ][ i - j + 500 ] = inf ; } for ( int j = 0 ; j <= m + 1 ; j ++ ) { int i = 0 ; mp [ i + j ][ i - j + 500 ] = inf ; i = n + 1 ; mp [ i + j ][ i - j + 500 ] = inf ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ][ j ] == '*' ) { sum ++ ; mp [ i + j ][ i - j + 500 ] = -1 ; } else { mp [ i + j ][ i - j + 500 ] = 1 ; } if ( a [ i ][ j ] == 'S' ) sx = i , sy = j ; if ( a [ i ][ j ] == 'E' ) ex = i , ey = j ; } } for ( int i = 1 ; i < 1050 ; i ++ ) { for ( int j = 1 ; j < 1050 ; j ++ ) { if ( mp [ i ][ j ] == -1 ) mp_sum1 [ i ][ j ] = 0 ; else mp_sum1 [ i ][ j ] = min ( mp_sum1 [ i ][ j ], min ( mp_sum1 [ i -1 ][ j ], mp_sum1 [ i ][ j -1 ]) + mp [ i ][ j ]); } } for ( int i = 1 ; i < 1050 ; i ++ ) { for ( int j = 1049 ; j >= 1 ; j -- ) { if ( mp [ i ][ j ] == -1 ) mp_sum2 [ i ][ j ] = 0 ; else mp_sum2 [ i ][ j ] = min ( mp_sum2 [ i ][ j ], min ( mp_sum2 [ i -1 ][ j ], mp_sum2 [ i ][ j + 1 ]) + mp [ i ][ j ]); } } for ( int i = 1049 ; i >= 1 ; i -- ) { for ( int j = 1 ; j < 1050 ; j ++ ) { if ( mp [ i ][ j ] == -1 ) mp_sum3 [ i ][ j ] = 0 ; else mp_sum3 [ i ][ j ] = min ( mp_sum3 [ i ][ j ], min ( mp_sum3 [ i + 1 ][ j ], mp_sum3 [ i ][ j -1 ]) + mp [ i ][ j ]); } } for ( int i = 1049 ; i >= 1 ; i -- ) { for ( int j = 1049 ; j >= 1 ; j -- ) { if ( mp [ i ][ j ] == -1 ) mp_sum4 [ i ][ j ] = 0 ; else mp_sum4 [ i ][ j ] = min ( mp_sum4 [ i ][ j ], min ( mp_sum4 [ i + 1 ][ j ], mp_sum4 [ i ][ j + 1 ]) + mp [ i ][ j ]); } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int xx = i + j , yy = i - j + 500 ; dis [ i ][ j ] = min ( min ( mp_sum1 [ xx ][ yy ], mp_sum2 [ xx ][ yy ]), min ( mp_sum3 [ xx ][ yy ], mp_sum4 [ xx ][ yy ])); } } dfs ( sx , sy , dis [ sx ][ sy ]); if ( ans != -1 && sum == 0 ) { printf ( \"safe \\n \" ); return 0 ; } printf ( \"%d \\n \" , ans ); return 0 ; }","title":"\u4ee3\u7801"},{"location":"csdn/Beyond%20compare4%2030%E5%A4%A9%E8%AF%95%E7%94%A8%E8%BF%87%E6%9C%9F/","text":"Beyond compare4 \u00b6 \u65b0\u5efa\u4e00\u4e2atxt\u6587\u6863\uff0c\u590d\u5236\u4ee5\u4e0b\u5185\u5bb9\uff1a reg delete \"HKEY_CURRENT_USER\\Software\\Scooter Software\\Beyond Compare 4\" /v CacheID /f exit \u91cd\u547d\u540d\u4e3a Bcompare.bat\uff0c\u70b9\u51fb\u8fd0\u884c\uff0c\u5373\u53ef\u83b7\u5f97\u53e6\u5916\u768430\u5929\u8bd5\u7528","title":"Beyond compare4 30\u5929\u8bd5\u7528\u8fc7\u671f"},{"location":"csdn/Beyond%20compare4%2030%E5%A4%A9%E8%AF%95%E7%94%A8%E8%BF%87%E6%9C%9F/#beyond-compare4","text":"\u65b0\u5efa\u4e00\u4e2atxt\u6587\u6863\uff0c\u590d\u5236\u4ee5\u4e0b\u5185\u5bb9\uff1a reg delete \"HKEY_CURRENT_USER\\Software\\Scooter Software\\Beyond Compare 4\" /v CacheID /f exit \u91cd\u547d\u540d\u4e3a Bcompare.bat\uff0c\u70b9\u51fb\u8fd0\u884c\uff0c\u5373\u53ef\u83b7\u5f97\u53e6\u5916\u768430\u5929\u8bd5\u7528","title":"Beyond compare4"},{"location":"csdn/GitHub%E5%8D%9A%E5%AE%A2/","text":"github\u535a\u5ba2\u5730\u5740 \u00b6 https://github.tim-wcx.ltd/","title":"GitHub\u535a\u5ba2"},{"location":"csdn/GitHub%E5%8D%9A%E5%AE%A2/#github","text":"https://github.tim-wcx.ltd/","title":"github\u535a\u5ba2\u5730\u5740"},{"location":"csdn/_coverpage/","text":"Tim-wcx \u00b6 \u4e2a\u4eba\u6587\u6863\u7f51\u7ad9 \u00b6 GitHub Get Started","title":"Tim-wcx"},{"location":"csdn/_coverpage/#tim-wcx","text":"","title":"Tim-wcx"},{"location":"csdn/_coverpage/#_1","text":"GitHub Get Started","title":"\u4e2a\u4eba\u6587\u6863\u7f51\u7ad9"},{"location":"csdn/_sidebar/","text":"\u4e0a\u4e00\u7ea7 csdn\u5bfc\u51fa 2020-08-01 2020-08-02\u7ebf\u6bb5\u6811 2020-08-03 2020-08-04 2020-08-05 2020-08-06\u7ebf\u6bb5\u6811 2020-08-07 2020-08-08 2020-08-09 2020-08-10 2020-08-11 2020-08-12\u6b27\u62c9\u51fd\u6570 2020-08-13 2020-08-14 2020-08-16\u6811\u5f62DP+\u7b49\u5dee\u6570\u5217\u524d\u7f00\u548c 2020-08-17 2020-08-18 2020-08-19 2020-08-20 2020-08-21 2020-09-05\u5212\u5206\u6811\u6c42\u67d0\u4e00\u533a\u95f4\u7684\u4e2d\u4f4d\u6570 2020-09-07 2020-09-08\u4e8c\u5206+\u6700\u5c0f\u751f\u6210\u6811 2020-09-08\u6570\u4f4dDP+\u4e8c\u5206 2020-09-09\u6570\u4f4dDP 2020-09-11\u6811\u72b6\u6570\u7ec4\u6c42\u6700\u5927\u503c 2020-09-12\u5b57\u7b26\u4e32\u54c8\u5e0c 2020-09-12 2020-09-21\u51f8\u5305\u7b97\u6cd5 2020-09-23\u6811\u72b6\u6570\u7ec4 2020-09-26\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u95ee\u9898 2020-10-04\u7ebf\u6bb5\u6811+\u626b\u63cf\u7ebf 2020-10-05 2020-10-07\u5e76\u67e5\u96c6+\u542f\u53d1\u5f0f\u5408\u5e76 2020-10-15dsuontree 2020-11-23 2020-12-02 2020-7-31 2021-02-02 2021-02-24 Beyondcompare430\u5929\u8bd5\u7528\u8fc7\u671f GitHub\u535a\u5ba2 \u4e8c\u5206+\u4e8c\u5206\u67e5\u627e\u6a21\u677f \u5f02\u6216\u6c42\u548c\u5f0f \u6c42\u7ec4\u5408\u6570\u7684\u65b9\u6cd5 \u6c42\u9006\u5e8f\u5bf9 \u7b80\u4ecb\u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u5b9a\u7406 \u94fe\u8868","title":" sidebar"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/","text":"1.\u67e5\u627e\u5143\u7d20k\u7684\u4f4d\u7f6e \u00b6 \u8f93\u5165 \u00b6 3 123 132 145 1 123 \u8f93\u51fa \u00b6 1 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; ll n ; ll find1 ( ll k ) { ll l = 1 , r = n + 1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( a [ mid ] == k ) return mid ; else if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; } } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); ll m ; scanf ( \"%lld\" , & m ); ll k ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & k ); printf ( \"%lld \\n \" , find1 ( k )); } } 2.\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8ek\u7684\u5143\u7d20\u4f4d\u7f6e \u00b6 \u8f93\u5165 \u00b6 6 1 2 2 3 3 4 4 1 2 3 4 \u8f93\u51fa \u00b6 1 2 4 6 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; ll n ; ll find1 ( ll k ) { ll l = 1 , r = n + 1 ; //\u641c\u7d22\u65f6\u5de6\u95ed\u53f3\u5f00,while\u5faa\u73afl<r\u5373\u53ef while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; else if ( a [ mid ] == k ) r = mid ; } return l ; } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); ll m ; scanf ( \"%lld\" , & m ); ll k ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & k ); printf ( \"%lld \\n \" , find1 ( k )); } } 2.\u67e5\u627e\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e\u7b49\u4e8ek\u7684\u5143\u7d20\u4f4d\u7f6e \u00b6 \u8f93\u5165 \u00b6 6 1 2 2 3 3 4 4 1 2 3 4 \u8f93\u51fa \u00b6 1 3 5 6 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; ll n ; ll find1 ( ll k ) { ll l = 1 , r = n + 1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; else if ( a [ mid ] == k ) l = mid + 1 ; } return l -1 ; // \u7531\u4e8el=mid+1 \u6240\u4ee5l\u4e0d\u662f\u7b54\u6848 } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); ll m ; scanf ( \"%lld\" , & m ); ll k ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & k ); printf ( \"%lld \\n \" , find1 ( k )); } } \u7528\u4e8c\u5206\u6cd5\u89e3\u9898\u65f6\uff0cmid\u4e0a\u4e0b\u53d6\u503c\u6b63\u786e\u4e0e\u5426\u5173\u7cfb\u7a0b\u5e8f\u662f\u5426\u8fdb\u5165\u6b7b\u5faa\u73af\uff01\uff01 \u5bf9\u4e0eif(test(mid)) l=mid; else r=mid-1; \u5982\u679c\u7528 mid=(l+r)/2 \u4f1a\u51fa\u73b0\u95ee\u9898\uff01\uff01\uff01 \u53d6l=3,r=4,\u4f1a\u53d1\u73b0\u7a0b\u5e8f\u6b7b\u5faa\u73af\uff01\uff01\uff01\u5f97\u7528 mid=l+(r-l+1)/2; \u5bf9\u4e8eif(test(mid)) r=mid; else l=mid+1; \u663e\u7136\u5f97\u7528mid=(l+r)/2 \u4e24\u79cd\u65b9\u5f0f\u4e00\u4e2a\u5411\u4e0a\uff0c\u4e00\u4e2a\u5411\u4e0b\u53d6\u6574\uff0c\u5177\u4f53\u95ee\u9898\u5177\u4f53\u5206\u6790\uff01\uff01 \u53c2\u8003\u4e8e\uff1a https://blog.csdn.net/wakouboy/article/details/22995997 https://www.jianshu.com/p/f3e3a84d7b8c https://www.cnblogs.com/luoxn28/p/5767571.html ----------------------------------\u5206\u5272\u7ebf----------------------------------------------------- http://icpc.upc.edu.cn/problem.php?cid=1405&pid=9 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u6709\u4e00\u5929\uff0c\u8d2a\u5403\u7684\u732a\u516b\u6212\u6765\u5230\u4e86\u4e00\u4e2a\u5927\u679c\u56ed\uff0c\u679c\u56ed\u91cc\u6709n(n\u2264100000)\u4e2a\u5927\u897f\u74dc\uff0c\u6bcf\u4e2a\u897f\u74dc \u7684\u8d28\u91cf\u4e0d\u5927\u4e8e\u957f\u6574\u578b(longint)\uff0c\u5e76\u4e14\u6bcf\u4e2a\u897f\u74dc\u7684\u8d28\u91cf\u90fd\u4e0d\u540c\u3002\u732a\u516b\u6212\u975e\u5e38\u65e0\u804a\uff0c\u5148\u628a\u6240\u6709\u7684\u897f\u74dc\u6309\u4ece\u5c0f\u5230\u5927\u6392\u5217\uff0c\u7136\u540e\u518d\u9009m(m\u2264l00000)\u4e2a\u8d28\u91cf\u662fKi\u7684\u897f\u74dc\uff0c\u8bf7\u4f60\u5e2e\u4ed6\u628a\u60f3\u5403\u7684\u897f\u74dc\u627e\u51fa\u6765\u3002 \u8f93\u5165 \u00b6 \u7b2c1\u884c\u8f93\u5165n\uff0c\u7136\u540e\u4ee5\u4e0bn\u884c\u8f93\u5165n\u4e2a\u6574\u6570\uff1b \u63a5\u7740\u8f93\u5165m\uff0c\u7136\u540e\u4ee5\u4e0bm\u884c\uff0c\u6bcf\u884c\u4e00\u4e2a\u6574\u6570Ki\u3002 \u8f93\u51fa \u00b6 \u8f93\u51fam\u884c\uff0c\u6bcf\u884c\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u91cd\u65b0\u6392\u5217\u540e\uff0cKi\u5728\u8fd9N\u4e2a\u6570\u4e2d\u7684\u4f4d\u7f6e\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 3 132 123 145 1 123 \u6837\u4f8b\u8f93\u51fa \u00b6 1 \u7b80\u5355\u7684\u6392\u5e8f+\u4e8c\u5206\u67e5\u627e #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; ll n ; ll find1 ( ll k ) { ll l = 1 , r = n + 1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( a [ mid ] == k ) return mid ; else if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; } } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); sort ( a + 1 , a + n + 1 ); ll m ; scanf ( \"%lld\" , & m ); ll k ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & k ); printf ( \"%lld \\n \" , find1 ( k )); } } http://icpc.upc.edu.cn/problem.php?cid=1405&pid=11 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u6211\u6709\u5f88\u591a\uff08n\u6761\uff09\u73cd\u73e0\u9879\u94fe\uff0c\u6bcf\u5929\u6211\u90fd\u8981\u4ece\u4e2d\u6311\u4e00\u6761\u6234\u4e0a\u2026\u2026\u6311\u54ea\u6761\u5f88\u6709\u8bb2\u7a76\uff0c\u4e0d\u80fd\u592a\u96be\u770b\u4e5f\u4e0d\u80fd\u592a\u597d\u770b\u3002\u6240\u4ee5\u6211\u5e0c\u671b\u4f60\u80fd\u5e2e\u5e2e\u6211\uff0c\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u2015\u2015\u6bcf\u5929\u5e2e\u6211\u7b97\u7b97\uff0c\u90a3\u5929\u6211\u80fd\u6234\u7684\u9879\u94fe\u6709\u591a\u5c11\u6761\u3002 \u8f93\u5165 \u00b6 \u7b2c1\u884c\u4e3a\u6b63\u6574\u6570n\uff0c\u8868\u793a\u9879\u94fe\u7684\u603b\u6761\u6570(n\u2264100000)\uff1b \u7b2c2\u884c\u6709n\u4e2a\u6574\u6570\uff08\u4ee3\u8868\u6bcf\u6761\u9879\u94fe\u6676\u7684\u597d\u770b\u7a0b\u5ea6Xi\uff0c0\u2264Xi\u2264maxlongint\uff09\uff1b \u7b2c3\u884c\u4e3a\u6b63\u6574\u6570m\uff0c\u8868\u793a\u603b\u5929\u6570(\u4e5f\u5c31\u662f\u603b\u8be2\u95ee\u6b21\u6570\uff0c\u5176\u4e2dm\u2264100000)\uff1b \u4ee5\u4e0bm\u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6574\u6570Ai\uff0cBi(1\u2264Ai\uff0cBi\u2264maxlongint)\uff0c\u8be2\u95ee\u597d\u770b\u7a0b\u5ea6\u5728Ai\u5230Bi\u4e4b\u95f4\u7684\u9879\u94fe\u6761\u6570\uff08\u542b\u7b49\u4e8eAi\u6216Bi\u7684\uff0cAi\u4e0eBi\u5927\u5c0f\u5173\u7cfb\u4e0d\u786e\u5b9a\uff09\u3002 \u8f93\u51fa \u00b6 \u8f93\u51fam\u884c\uff0c\u5bf9\u4e8e\u6bcf\u6b21\u8be2\u95ee\u8f93\u51fa\u4e00\u884c\uff0c\u4eceAi\u5230Bi(\u542bAi\uff0cBi)\u597d\u770b\u7a0b\u5ea6\u5728Ai\u5230Bi\u4e4b\u95f4\u7684\u9879\u94fe\u6761\u6570\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 7 8 2 3 5 6 7 7 6 1 5 8 6 1 10 5 5 4 4 7 8 \u6837\u4f8b\u8f93\u51fa \u00b6 3 4 7 1 0 3 \u67e5\u627e\u5de6\u53f3\u8fb9\u754c\u505a\u5dee\u5373\u53ef\u3002 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; ll n ; ll find1 ( ll k ) { ll l = 1 , r = n + 1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; else if ( a [ mid ] == k ) l = mid + 1 ; } return l -1 ; } ll find2 ( ll k ) { ll l = 1 , r = n + 1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; else if ( a [ mid ] == k ) r = mid ; } return l ; } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); sort ( a + 1 , a + n + 1 ); ll m ; scanf ( \"%lld\" , & m ); ll o , p ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld\" , & o , & p ); if ( o > p ) swap ( o , p ); printf ( \"%lld \\n \" , - find2 ( o ) + find1 ( p ) + 1 ); } } http://icpc.upc.edu.cn/problem.php?cid=1405&pid=10 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u4e07\u5723\u8282\u53c8\u5230\u4e86\uff01FJ\u6253\u7b97\u5e26\u4ed6\u7684\u5976\u725b\u53bb\u53c2\u52a0\u5316\u88c5\u665a\u4f1a\uff0c\u4f46\u662f\uff0cFJ\u53ea\u505a\u4e86\u4e00\u5957\u80fd\u5bb9\u4e0b\u4e24\u5934\u603b\u957f\u4e0d\u8d85\u8fc7S (1\u2264S\u22641000000)\u7684\u5976\u725b\u6050\u6016\u670d\u88c5\u3002FJ\u517b\u4e86N(2\u2264N\u226420000)\u5934\u63091--N\u987a\u5e8f\u7f16\u53f7\u7684\u5976\u725b\uff0c\u7f16\u53f7\u4e3ai\u7684\u5976\u725b\u7684\u957f\u5ea6\u4e3aL_i(1\u2264L_i\u22641000000)\u3002\u5982\u679c\u4e24\u5934\u5976\u725b\u7684\u603b\u957f\u5ea6\u4e0d\u8d85\u8fc7S\uff0c\u90a3\u4e48\u5979\u4eec\u5c31\u80fd\u7a7f\u4e0b\u8fd9\u5957\u670d\u88c5\u3002 FJ\u60f3\u77e5\u9053\uff0c\u5982\u679c\u4ed6\u60f3\u9009\u62e9\u4e24\u5934\u4e0d\u540c\u7684\u5976\u725b\u6765\u7a7f\u8fd9\u5957\u8863\u670d\uff0c\u4e00\u5171\u6709\u591a\u5c11\u79cd\u6ee1\u8db3\u6761\u4ef6\u7684\u65b9\u6848\u3002 \u8f93\u5165 \u00b6 \u7b2c1\u884c\u662f2\u4e2a\u6574\u6570\uff1aN\u548cS\uff1b \u7b2c2\uff5eN+l\u884c\u6bcf\u884c\u4e00\u4e2a\u6574\u6570\uff1aL_i\u3002 \u8f93\u51fa \u00b6 1\u4e2a\u6574\u6570\uff0c\u8868\u793aFJ\u53ef\u9009\u62e9\u7684\u6240\u6709\u65b9\u6848\u6570\u3002\u6ce8\u610f\u5976\u725b\u987a\u5e8f\u4e0d\u540c\u7684\u4e24\u79cd\u65b9\u6848\u662f\u88ab\u89c6\u4e3a\u76f8\u540c\u7684\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 4 6 3 5 2 1 \u6837\u4f8b\u8f93\u51fa \u00b6 4 \u63d0\u793a \u00b6 \u6837\u4f8b\u8bf4\u660e\uff1a4\u79cd\u9009\u62e9\u5206\u522b\u4e3a\uff1a\u5976\u725b1\u548c\u5976\u725b3\uff1b\u5976\u725bl\u548c\u5976\u725b4\uff1b\u5976\u725b2\u548c\u5976\u725b4\uff1b\u5976\u725b3\u548c\u5976\u725b4\u3002 \u4e8c\u5206\uff0c\u67e5\u627e\u7b26\u5408\u6761\u4ef6\u7684\u4e0a\u754c\u6c42\u548c\u5373\u53ef\u3002 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; ll n , k ; ll find1 ( ll k ) { ll l = 1 , r = n + 1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; else if ( a [ mid ] == k ) l = mid + 1 ; } return l -1 ; } int main () { scanf ( \"%lld%lld\" , & n , & k ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); sort ( a + 1 , a + n + 1 ); ll sum = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll w = find1 ( k - a [ i ]); if ( i <= w ) w -- ; sum += w ; } cout << sum / 2 << endl ; } \u9644\u4e0a\u4e00\u4efd\u4e8c\u5206\u67e5\u627e\u7684\u6a21\u677f #include <bits/stdc++.h> using namespace std ; int a [ 100500 ] = { 0 }; ///\u4ece\u5c0f\u5230\u5927\u6392\u5e8f int n , m ; int find1 ( int k ) ///\u67e5\u627e\u67d0\u4e00\u4e2a\u6570\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e { int l = 1 , r = n , mid ; while ( l < r ) ///while\u5faa\u73af\u6761\u4ef6\u4e3al<r,\u5219\u8df3\u51fa\u5faa\u73af\u65f6l==r,\u51cf\u5c11\u5bf9\u8fd4\u56de\u503c\u7684\u8003\u8651 { mid = ( l + r ) / 2 ; ///\u7531\u4e8e\u662fl=mid+1,\u5efa\u8bae\u7528(l+r)/2 if ( a [ mid ] == k ) r = mid ; else if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; } if ( a [ r ] == k ) return r ; else return -1 ; } int find2 ( int k ) ///\u67e5\u627e\u67d0\u4e00\u4e2a\u6570\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e { int l = 1 , r = n , mid ; while ( l < r ) { mid = ( l + r + 1 ) / 2 ; ///\u7531\u4e8e\u662fr=mid-1,\u5efa\u8bae\u7528(l+r+1)/2 if ( a [ mid ] == k ) l = mid ; else if ( a [ mid ] > k ) r = mid -1 ; else if ( a [ mid ] < k ) l = mid ; } if ( a [ l ] == k ) return l ; else return -1 ; } int find3 ( int k ) ///\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8ek\u7684\u5143\u7d20\u4f4d\u7f6e { int l = 1 , r = n , mid ; while ( l < r ) { mid = ( l + r ) / 2 ; ///\u7531\u4e8e\u662fl=mid+1,\u5efa\u8bae\u7528(l+r)/2 if ( a [ mid ] == k ) r = mid ; else if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; } if ( a [ l ] >= k ) return l ; else return -1 ; } int find4 ( int k ) ///\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8ek\u7684\u5143\u7d20\u4f4d\u7f6e { int l = 1 , r = n , mid ; while ( l < r ) { mid = ( l + r ) / 2 ; ///\u7531\u4e8e\u662fl=mid+1,\u5efa\u8bae\u7528(l+r)/2 if ( a [ mid ] == k ) l = mid + 1 ; else if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; } if ( a [ l ] > k ) return l ; else return -1 ; } int find5 ( int k ) ///\u67e5\u627e\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e\u7b49\u4e8ek\u7684\u5143\u7d20\u4f4d\u7f6e { int l = 1 , r = n , mid ; while ( l < r ) { mid = ( l + r + 1 ) / 2 ; ///\u7531\u4e8e\u662fr=mid-1,\u5efa\u8bae\u7528(l+r+1)/2 if ( a [ mid ] == k ) l = mid ; else if ( a [ mid ] > k ) r = mid -1 ; else if ( a [ mid ] < k ) l = mid ; } if ( a [ l ] <= k ) return l ; else return -1 ; } int find6 ( int k ) ///\u67e5\u627e\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8ek\u7684\u5143\u7d20\u4f4d\u7f6e { int l = 1 , r = n , mid ; while ( l < r ) { mid = ( l + r + 1 ) / 2 ; ///\u7531\u4e8e\u662fr=mid-1,\u5efa\u8bae\u7528(l+r+1)/2 if ( a [ mid ] == k ) r = mid -1 ; else if ( a [ mid ] > k ) r = mid -1 ; else if ( a [ mid ] < k ) l = mid ; } if ( a [ l ] < k ) return l ; else return -1 ; } int main () { printf ( \"\u8bf7\u8f93\u5165\u6570\u5b57\u4e2a\u6570: \\n \" ); scanf ( \"%d\" , & n ); printf ( \"\u8bf7\u8f93\u5165\u4e00\u884c\u6570\u5b57,\u4e0d\u5fc5\u5206\u524d\u540e\u987a\u5e8f: \\n \" ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); sort ( a + 1 , a + n + 1 ); printf ( \"\u8bf7\u8f93\u5165\u8981\u67e5\u8be2\u7684\u6570\u5b57: \\n \" ); while ( scanf ( \"%d\" , & m ) != EOF ) { int ans1 , ans2 , ans3 , ans4 , ans5 , ans6 ; ans1 = find1 ( m ); ans2 = find2 ( m ); ans3 = find3 ( m ); ans4 = find4 ( m ); ans5 = find5 ( m ); ans6 = find6 ( m ); printf ( \"%d \u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\u4e3a %d \\n \" , m , ans1 ); printf ( \"%d \u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\u4e3a %d \\n \" , m , ans2 ); printf ( \"\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8e\u6570\u5b57 %d \u7684\u4f4d\u7f6e\u4e3a %d \\n \" , m , ans3 ); printf ( \"\u7b2c\u4e00\u4e2a\u5927\u4e8e\u6570\u5b57 %d \u7684\u4f4d\u7f6e\u4e3a %d \\n \" , m , ans4 ); printf ( \"\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e\u7b49\u4e8e\u6570\u5b57 %d \u7684\u4f4d\u7f6e\u4e3a %d \\n \" , m , ans5 ); printf ( \"\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e\u6570\u5b57 %d \u7684\u4f4d\u7f6e\u4e3a %d \\n \" , m , ans6 ); printf ( \"\u8bf7\u8f93\u5165\u8981\u67e5\u8be2\u7684\u6570\u5b57: \\n \" ); } }","title":"\u4e8c\u5206+\u4e8c\u5206\u67e5\u627e\u6a21\u677f"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#1k","text":"","title":"1.\u67e5\u627e\u5143\u7d20k\u7684\u4f4d\u7f6e"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_1","text":"3 123 132 145 1 123","title":"\u8f93\u5165"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_2","text":"1","title":"\u8f93\u51fa"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_3","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; ll n ; ll find1 ( ll k ) { ll l = 1 , r = n + 1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( a [ mid ] == k ) return mid ; else if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; } } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); ll m ; scanf ( \"%lld\" , & m ); ll k ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & k ); printf ( \"%lld \\n \" , find1 ( k )); } }","title":"\u4ee3\u7801"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#2k","text":"","title":"2.\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8ek\u7684\u5143\u7d20\u4f4d\u7f6e"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_4","text":"6 1 2 2 3 3 4 4 1 2 3 4","title":"\u8f93\u5165"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_5","text":"1 2 4 6","title":"\u8f93\u51fa"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_6","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; ll n ; ll find1 ( ll k ) { ll l = 1 , r = n + 1 ; //\u641c\u7d22\u65f6\u5de6\u95ed\u53f3\u5f00,while\u5faa\u73afl<r\u5373\u53ef while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; else if ( a [ mid ] == k ) r = mid ; } return l ; } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); ll m ; scanf ( \"%lld\" , & m ); ll k ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & k ); printf ( \"%lld \\n \" , find1 ( k )); } }","title":"\u4ee3\u7801"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#2k_1","text":"","title":"2.\u67e5\u627e\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e\u7b49\u4e8ek\u7684\u5143\u7d20\u4f4d\u7f6e"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_7","text":"6 1 2 2 3 3 4 4 1 2 3 4","title":"\u8f93\u5165"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_8","text":"1 3 5 6","title":"\u8f93\u51fa"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_9","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; ll n ; ll find1 ( ll k ) { ll l = 1 , r = n + 1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; else if ( a [ mid ] == k ) l = mid + 1 ; } return l -1 ; // \u7531\u4e8el=mid+1 \u6240\u4ee5l\u4e0d\u662f\u7b54\u6848 } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); ll m ; scanf ( \"%lld\" , & m ); ll k ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & k ); printf ( \"%lld \\n \" , find1 ( k )); } } \u7528\u4e8c\u5206\u6cd5\u89e3\u9898\u65f6\uff0cmid\u4e0a\u4e0b\u53d6\u503c\u6b63\u786e\u4e0e\u5426\u5173\u7cfb\u7a0b\u5e8f\u662f\u5426\u8fdb\u5165\u6b7b\u5faa\u73af\uff01\uff01 \u5bf9\u4e0eif(test(mid)) l=mid; else r=mid-1; \u5982\u679c\u7528 mid=(l+r)/2 \u4f1a\u51fa\u73b0\u95ee\u9898\uff01\uff01\uff01 \u53d6l=3,r=4,\u4f1a\u53d1\u73b0\u7a0b\u5e8f\u6b7b\u5faa\u73af\uff01\uff01\uff01\u5f97\u7528 mid=l+(r-l+1)/2; \u5bf9\u4e8eif(test(mid)) r=mid; else l=mid+1; \u663e\u7136\u5f97\u7528mid=(l+r)/2 \u4e24\u79cd\u65b9\u5f0f\u4e00\u4e2a\u5411\u4e0a\uff0c\u4e00\u4e2a\u5411\u4e0b\u53d6\u6574\uff0c\u5177\u4f53\u95ee\u9898\u5177\u4f53\u5206\u6790\uff01\uff01 \u53c2\u8003\u4e8e\uff1a https://blog.csdn.net/wakouboy/article/details/22995997 https://www.jianshu.com/p/f3e3a84d7b8c https://www.cnblogs.com/luoxn28/p/5767571.html ----------------------------------\u5206\u5272\u7ebf----------------------------------------------------- http://icpc.upc.edu.cn/problem.php?cid=1405&pid=9","title":"\u4ee3\u7801"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_10","text":"\u6709\u4e00\u5929\uff0c\u8d2a\u5403\u7684\u732a\u516b\u6212\u6765\u5230\u4e86\u4e00\u4e2a\u5927\u679c\u56ed\uff0c\u679c\u56ed\u91cc\u6709n(n\u2264100000)\u4e2a\u5927\u897f\u74dc\uff0c\u6bcf\u4e2a\u897f\u74dc \u7684\u8d28\u91cf\u4e0d\u5927\u4e8e\u957f\u6574\u578b(longint)\uff0c\u5e76\u4e14\u6bcf\u4e2a\u897f\u74dc\u7684\u8d28\u91cf\u90fd\u4e0d\u540c\u3002\u732a\u516b\u6212\u975e\u5e38\u65e0\u804a\uff0c\u5148\u628a\u6240\u6709\u7684\u897f\u74dc\u6309\u4ece\u5c0f\u5230\u5927\u6392\u5217\uff0c\u7136\u540e\u518d\u9009m(m\u2264l00000)\u4e2a\u8d28\u91cf\u662fKi\u7684\u897f\u74dc\uff0c\u8bf7\u4f60\u5e2e\u4ed6\u628a\u60f3\u5403\u7684\u897f\u74dc\u627e\u51fa\u6765\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_11","text":"\u7b2c1\u884c\u8f93\u5165n\uff0c\u7136\u540e\u4ee5\u4e0bn\u884c\u8f93\u5165n\u4e2a\u6574\u6570\uff1b \u63a5\u7740\u8f93\u5165m\uff0c\u7136\u540e\u4ee5\u4e0bm\u884c\uff0c\u6bcf\u884c\u4e00\u4e2a\u6574\u6570Ki\u3002","title":"\u8f93\u5165"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_12","text":"\u8f93\u51fam\u884c\uff0c\u6bcf\u884c\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u91cd\u65b0\u6392\u5217\u540e\uff0cKi\u5728\u8fd9N\u4e2a\u6570\u4e2d\u7684\u4f4d\u7f6e\u3002","title":"\u8f93\u51fa"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_13","text":"3 132 123 145 1 123","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_14","text":"1 \u7b80\u5355\u7684\u6392\u5e8f+\u4e8c\u5206\u67e5\u627e #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; ll n ; ll find1 ( ll k ) { ll l = 1 , r = n + 1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( a [ mid ] == k ) return mid ; else if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; } } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); sort ( a + 1 , a + n + 1 ); ll m ; scanf ( \"%lld\" , & m ); ll k ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & k ); printf ( \"%lld \\n \" , find1 ( k )); } } http://icpc.upc.edu.cn/problem.php?cid=1405&pid=11","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_15","text":"\u6211\u6709\u5f88\u591a\uff08n\u6761\uff09\u73cd\u73e0\u9879\u94fe\uff0c\u6bcf\u5929\u6211\u90fd\u8981\u4ece\u4e2d\u6311\u4e00\u6761\u6234\u4e0a\u2026\u2026\u6311\u54ea\u6761\u5f88\u6709\u8bb2\u7a76\uff0c\u4e0d\u80fd\u592a\u96be\u770b\u4e5f\u4e0d\u80fd\u592a\u597d\u770b\u3002\u6240\u4ee5\u6211\u5e0c\u671b\u4f60\u80fd\u5e2e\u5e2e\u6211\uff0c\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u2015\u2015\u6bcf\u5929\u5e2e\u6211\u7b97\u7b97\uff0c\u90a3\u5929\u6211\u80fd\u6234\u7684\u9879\u94fe\u6709\u591a\u5c11\u6761\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_16","text":"\u7b2c1\u884c\u4e3a\u6b63\u6574\u6570n\uff0c\u8868\u793a\u9879\u94fe\u7684\u603b\u6761\u6570(n\u2264100000)\uff1b \u7b2c2\u884c\u6709n\u4e2a\u6574\u6570\uff08\u4ee3\u8868\u6bcf\u6761\u9879\u94fe\u6676\u7684\u597d\u770b\u7a0b\u5ea6Xi\uff0c0\u2264Xi\u2264maxlongint\uff09\uff1b \u7b2c3\u884c\u4e3a\u6b63\u6574\u6570m\uff0c\u8868\u793a\u603b\u5929\u6570(\u4e5f\u5c31\u662f\u603b\u8be2\u95ee\u6b21\u6570\uff0c\u5176\u4e2dm\u2264100000)\uff1b \u4ee5\u4e0bm\u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6574\u6570Ai\uff0cBi(1\u2264Ai\uff0cBi\u2264maxlongint)\uff0c\u8be2\u95ee\u597d\u770b\u7a0b\u5ea6\u5728Ai\u5230Bi\u4e4b\u95f4\u7684\u9879\u94fe\u6761\u6570\uff08\u542b\u7b49\u4e8eAi\u6216Bi\u7684\uff0cAi\u4e0eBi\u5927\u5c0f\u5173\u7cfb\u4e0d\u786e\u5b9a\uff09\u3002","title":"\u8f93\u5165"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_17","text":"\u8f93\u51fam\u884c\uff0c\u5bf9\u4e8e\u6bcf\u6b21\u8be2\u95ee\u8f93\u51fa\u4e00\u884c\uff0c\u4eceAi\u5230Bi(\u542bAi\uff0cBi)\u597d\u770b\u7a0b\u5ea6\u5728Ai\u5230Bi\u4e4b\u95f4\u7684\u9879\u94fe\u6761\u6570\u3002","title":"\u8f93\u51fa"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_18","text":"7 8 2 3 5 6 7 7 6 1 5 8 6 1 10 5 5 4 4 7 8","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_19","text":"3 4 7 1 0 3 \u67e5\u627e\u5de6\u53f3\u8fb9\u754c\u505a\u5dee\u5373\u53ef\u3002 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; ll n ; ll find1 ( ll k ) { ll l = 1 , r = n + 1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; else if ( a [ mid ] == k ) l = mid + 1 ; } return l -1 ; } ll find2 ( ll k ) { ll l = 1 , r = n + 1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; else if ( a [ mid ] == k ) r = mid ; } return l ; } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); sort ( a + 1 , a + n + 1 ); ll m ; scanf ( \"%lld\" , & m ); ll o , p ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld\" , & o , & p ); if ( o > p ) swap ( o , p ); printf ( \"%lld \\n \" , - find2 ( o ) + find1 ( p ) + 1 ); } } http://icpc.upc.edu.cn/problem.php?cid=1405&pid=10","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_20","text":"\u4e07\u5723\u8282\u53c8\u5230\u4e86\uff01FJ\u6253\u7b97\u5e26\u4ed6\u7684\u5976\u725b\u53bb\u53c2\u52a0\u5316\u88c5\u665a\u4f1a\uff0c\u4f46\u662f\uff0cFJ\u53ea\u505a\u4e86\u4e00\u5957\u80fd\u5bb9\u4e0b\u4e24\u5934\u603b\u957f\u4e0d\u8d85\u8fc7S (1\u2264S\u22641000000)\u7684\u5976\u725b\u6050\u6016\u670d\u88c5\u3002FJ\u517b\u4e86N(2\u2264N\u226420000)\u5934\u63091--N\u987a\u5e8f\u7f16\u53f7\u7684\u5976\u725b\uff0c\u7f16\u53f7\u4e3ai\u7684\u5976\u725b\u7684\u957f\u5ea6\u4e3aL_i(1\u2264L_i\u22641000000)\u3002\u5982\u679c\u4e24\u5934\u5976\u725b\u7684\u603b\u957f\u5ea6\u4e0d\u8d85\u8fc7S\uff0c\u90a3\u4e48\u5979\u4eec\u5c31\u80fd\u7a7f\u4e0b\u8fd9\u5957\u670d\u88c5\u3002 FJ\u60f3\u77e5\u9053\uff0c\u5982\u679c\u4ed6\u60f3\u9009\u62e9\u4e24\u5934\u4e0d\u540c\u7684\u5976\u725b\u6765\u7a7f\u8fd9\u5957\u8863\u670d\uff0c\u4e00\u5171\u6709\u591a\u5c11\u79cd\u6ee1\u8db3\u6761\u4ef6\u7684\u65b9\u6848\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_21","text":"\u7b2c1\u884c\u662f2\u4e2a\u6574\u6570\uff1aN\u548cS\uff1b \u7b2c2\uff5eN+l\u884c\u6bcf\u884c\u4e00\u4e2a\u6574\u6570\uff1aL_i\u3002","title":"\u8f93\u5165"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_22","text":"1\u4e2a\u6574\u6570\uff0c\u8868\u793aFJ\u53ef\u9009\u62e9\u7684\u6240\u6709\u65b9\u6848\u6570\u3002\u6ce8\u610f\u5976\u725b\u987a\u5e8f\u4e0d\u540c\u7684\u4e24\u79cd\u65b9\u6848\u662f\u88ab\u89c6\u4e3a\u76f8\u540c\u7684\u3002","title":"\u8f93\u51fa"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_23","text":"4 6 3 5 2 1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_24","text":"4","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/%E4%BA%8C%E5%88%86%2B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/#_25","text":"\u6837\u4f8b\u8bf4\u660e\uff1a4\u79cd\u9009\u62e9\u5206\u522b\u4e3a\uff1a\u5976\u725b1\u548c\u5976\u725b3\uff1b\u5976\u725bl\u548c\u5976\u725b4\uff1b\u5976\u725b2\u548c\u5976\u725b4\uff1b\u5976\u725b3\u548c\u5976\u725b4\u3002 \u4e8c\u5206\uff0c\u67e5\u627e\u7b26\u5408\u6761\u4ef6\u7684\u4e0a\u754c\u6c42\u548c\u5373\u53ef\u3002 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; ll n , k ; ll find1 ( ll k ) { ll l = 1 , r = n + 1 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; else if ( a [ mid ] == k ) l = mid + 1 ; } return l -1 ; } int main () { scanf ( \"%lld%lld\" , & n , & k ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); sort ( a + 1 , a + n + 1 ); ll sum = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll w = find1 ( k - a [ i ]); if ( i <= w ) w -- ; sum += w ; } cout << sum / 2 << endl ; } \u9644\u4e0a\u4e00\u4efd\u4e8c\u5206\u67e5\u627e\u7684\u6a21\u677f #include <bits/stdc++.h> using namespace std ; int a [ 100500 ] = { 0 }; ///\u4ece\u5c0f\u5230\u5927\u6392\u5e8f int n , m ; int find1 ( int k ) ///\u67e5\u627e\u67d0\u4e00\u4e2a\u6570\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e { int l = 1 , r = n , mid ; while ( l < r ) ///while\u5faa\u73af\u6761\u4ef6\u4e3al<r,\u5219\u8df3\u51fa\u5faa\u73af\u65f6l==r,\u51cf\u5c11\u5bf9\u8fd4\u56de\u503c\u7684\u8003\u8651 { mid = ( l + r ) / 2 ; ///\u7531\u4e8e\u662fl=mid+1,\u5efa\u8bae\u7528(l+r)/2 if ( a [ mid ] == k ) r = mid ; else if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; } if ( a [ r ] == k ) return r ; else return -1 ; } int find2 ( int k ) ///\u67e5\u627e\u67d0\u4e00\u4e2a\u6570\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e { int l = 1 , r = n , mid ; while ( l < r ) { mid = ( l + r + 1 ) / 2 ; ///\u7531\u4e8e\u662fr=mid-1,\u5efa\u8bae\u7528(l+r+1)/2 if ( a [ mid ] == k ) l = mid ; else if ( a [ mid ] > k ) r = mid -1 ; else if ( a [ mid ] < k ) l = mid ; } if ( a [ l ] == k ) return l ; else return -1 ; } int find3 ( int k ) ///\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8ek\u7684\u5143\u7d20\u4f4d\u7f6e { int l = 1 , r = n , mid ; while ( l < r ) { mid = ( l + r ) / 2 ; ///\u7531\u4e8e\u662fl=mid+1,\u5efa\u8bae\u7528(l+r)/2 if ( a [ mid ] == k ) r = mid ; else if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; } if ( a [ l ] >= k ) return l ; else return -1 ; } int find4 ( int k ) ///\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8ek\u7684\u5143\u7d20\u4f4d\u7f6e { int l = 1 , r = n , mid ; while ( l < r ) { mid = ( l + r ) / 2 ; ///\u7531\u4e8e\u662fl=mid+1,\u5efa\u8bae\u7528(l+r)/2 if ( a [ mid ] == k ) l = mid + 1 ; else if ( a [ mid ] > k ) r = mid ; else if ( a [ mid ] < k ) l = mid + 1 ; } if ( a [ l ] > k ) return l ; else return -1 ; } int find5 ( int k ) ///\u67e5\u627e\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e\u7b49\u4e8ek\u7684\u5143\u7d20\u4f4d\u7f6e { int l = 1 , r = n , mid ; while ( l < r ) { mid = ( l + r + 1 ) / 2 ; ///\u7531\u4e8e\u662fr=mid-1,\u5efa\u8bae\u7528(l+r+1)/2 if ( a [ mid ] == k ) l = mid ; else if ( a [ mid ] > k ) r = mid -1 ; else if ( a [ mid ] < k ) l = mid ; } if ( a [ l ] <= k ) return l ; else return -1 ; } int find6 ( int k ) ///\u67e5\u627e\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8ek\u7684\u5143\u7d20\u4f4d\u7f6e { int l = 1 , r = n , mid ; while ( l < r ) { mid = ( l + r + 1 ) / 2 ; ///\u7531\u4e8e\u662fr=mid-1,\u5efa\u8bae\u7528(l+r+1)/2 if ( a [ mid ] == k ) r = mid -1 ; else if ( a [ mid ] > k ) r = mid -1 ; else if ( a [ mid ] < k ) l = mid ; } if ( a [ l ] < k ) return l ; else return -1 ; } int main () { printf ( \"\u8bf7\u8f93\u5165\u6570\u5b57\u4e2a\u6570: \\n \" ); scanf ( \"%d\" , & n ); printf ( \"\u8bf7\u8f93\u5165\u4e00\u884c\u6570\u5b57,\u4e0d\u5fc5\u5206\u524d\u540e\u987a\u5e8f: \\n \" ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); sort ( a + 1 , a + n + 1 ); printf ( \"\u8bf7\u8f93\u5165\u8981\u67e5\u8be2\u7684\u6570\u5b57: \\n \" ); while ( scanf ( \"%d\" , & m ) != EOF ) { int ans1 , ans2 , ans3 , ans4 , ans5 , ans6 ; ans1 = find1 ( m ); ans2 = find2 ( m ); ans3 = find3 ( m ); ans4 = find4 ( m ); ans5 = find5 ( m ); ans6 = find6 ( m ); printf ( \"%d \u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\u4e3a %d \\n \" , m , ans1 ); printf ( \"%d \u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\u4e3a %d \\n \" , m , ans2 ); printf ( \"\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8e\u6570\u5b57 %d \u7684\u4f4d\u7f6e\u4e3a %d \\n \" , m , ans3 ); printf ( \"\u7b2c\u4e00\u4e2a\u5927\u4e8e\u6570\u5b57 %d \u7684\u4f4d\u7f6e\u4e3a %d \\n \" , m , ans4 ); printf ( \"\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e\u7b49\u4e8e\u6570\u5b57 %d \u7684\u4f4d\u7f6e\u4e3a %d \\n \" , m , ans5 ); printf ( \"\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e\u6570\u5b57 %d \u7684\u4f4d\u7f6e\u4e3a %d \\n \" , m , ans6 ); printf ( \"\u8bf7\u8f93\u5165\u8981\u67e5\u8be2\u7684\u6570\u5b57: \\n \" ); } }","title":"\u63d0\u793a"},{"location":"csdn/%E5%BC%82%E6%88%96%E6%B1%82%E5%92%8C%E5%BC%8F/","text":"\u5f02\u6216\u6c42\u548c\u5f0f \u00b6 \u53c2\u8003\u4e8e\uff1a https://blog.csdn.net/ECNU_LZJ/article/details/72853774?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.nonecase \u9898\u76ee \u00b6 \u7ed9\u5b9a\u957f\u5ea6\u4e3an\u7684\u5e8f\u5217A[i]\uff0c\u6c42\u6240\u6709A[i] xor A[j] (i<j)\u7684\u503c\u4e4b\u548c \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6574\u6570N \u63a5\u4e0b\u6765N\u884c\uff0c\u7b2ci\u884c\u4e3aA[i] \u8f93\u51fa \u00b6 \u6240\u9700\u7684\u503c \u6837\u4f8b\u8f93\u5165 \u00b6 3 7 3 5 \u6837\u4f8b\u8f93\u51fa \u00b6 12 \u6837\u4f8b\u89e3\u91ca \u00b6 7 xor 3+3 xor 5+7 xor 5 = 4+6+2 = 12 \u9898\u89e3 \u00b6 \u5f02\u6216\uff1aC++\u4e2d\u5373\u4e3a ^ \u8fd0\u7b97\u7b26 0^0=0 , 0^1=1 ,1^0=1, 1^1=0 \u6570\u5b57\u90fd\u5316\u6210\u4e8c\u8fdb\u5236\uff1a7:111, 3:011, 5:101 \u5f02\u6216\u5177\u6709\u4ea4\u6362\u5f8b\uff0c\u4e5f\u5c31\u662f\u8bf4\u53ea\u8981\u80fd\u591f\u4f7f\u5f97\u4efb\u610f\u4e24\u4e2a\u6570\u5b57\u90fd\u5f02\u6216\u4e00\u6b21\uff0c\u5c31\u6ca1\u6709\u5fc5\u8981\u6bcf\u6b21\u7528\u524d\u9762\u7684\u6570\u5b57\u5f02\u6216\u540e\u9762\u7684\u6570\u5b57\u3002\u8fd9\u542f\u53d1\u6211\u4eec\u4e0d\u5173\u6ce8\u5f02\u6216\u7684\u987a\u5e8f\uff0c\u800c\u662f\u5173\u6ce8\u7ed3\u679c\u3002 \u6613\u77e5\uff1aa\u4e2a1\uff0cb\u4e2a0\u4e24\u4e24\u5f02\u6216\u7684\u7ed3\u679c\u80af\u5b9a\u662fa*b\u4e2a1\uff0c\u5176\u4f59\u90fd\u662f0\u3002 \u4e09\u4e2a\u6570\u5b57\u7684\u6700\u4f4e\u4f4d\u5206\u522b\u662f1,1,1\uff0c\u4e5f\u5c31\u662f\u4e09\u4e2a1\u3002\u90a3\u4e48\u6700\u4f4e\u4f4d\u5f02\u6216\u7684\u7ed3\u679c\u4e00\u5b9a\u662f\u96f6\u4e2a1\uff0c\u4e09\u4e2a0\uff0c\u76f8\u52a0\u4e3a0\u3002 \u6b21\u4f4e\u4f4d\u5206\u522b\u662f1,1,0\uff0c\u4e5f\u5c31\u662f\u4e24\u4e2a1\u4e00\u4e2a0\u3002\u90a3\u4e48\u6b21\u4f4e\u4f4d\u5f02\u6216\u7684\u7ed3\u679c\u4e00\u5b9a\u662f\u4e24\u4e2a1\uff0c\u4e00\u4e2a0\uff0c\u76f8\u52a0\u4e3a2\u3002 \u6700\u9ad8\u4f4d\u5206\u522b\u662f1,0,1\uff0c\u4e5f\u5c31\u662f\u4e24\u4e2a1\u4e00\u4e2a0\u3002\u90a3\u4e48\u6700\u9ad8\u4f4d\u5f02\u6216\u7684\u7ed3\u679c\u4e00\u5b9a\u662f\u4e24\u4e2a1\uff0c\u4e00\u4e2a0\uff0c\u76f8\u52a0\u4e3a2\u3002 \u6240\u4ee5\u6700\u540e\u7684\u7b54\u6848\u5e94\u8be5\u662f \u4ee3\u7801\u5982\u4e0b\uff1a #include <iostream> #include <bits/stdc++.h> using namespace std; long long b[50]={0}; int main() { int n; scanf(\"%d\",&n); long long a; for(int i=1;i<=n;i++) { scanf(\"%lld\",&a); int cnt=0; while(a) { cnt++; if(a%2==1) { b[cnt]++; } a=a/2; } } long long sum=0; for(int i=0;i<=31;i++) { sum=sum+(1<<i)*(b[i+1])*(n-b[i+1]); //b[i+1]\u4e3a1\u7684\u4e2a\u6570\uff0cn-b[i+1]\u4e3a0\u7684\u4e2a\u6570,1<<i\u4e3a2\u7684i\u6b21\u5e42 } cout<<sum<<endl; return 0; }","title":"\u5f02\u6216\u6c42\u548c\u5f0f"},{"location":"csdn/%E5%BC%82%E6%88%96%E6%B1%82%E5%92%8C%E5%BC%8F/#_1","text":"\u53c2\u8003\u4e8e\uff1a https://blog.csdn.net/ECNU_LZJ/article/details/72853774?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.nonecase","title":"\u5f02\u6216\u6c42\u548c\u5f0f"},{"location":"csdn/%E5%BC%82%E6%88%96%E6%B1%82%E5%92%8C%E5%BC%8F/#_2","text":"\u7ed9\u5b9a\u957f\u5ea6\u4e3an\u7684\u5e8f\u5217A[i]\uff0c\u6c42\u6240\u6709A[i] xor A[j] (i<j)\u7684\u503c\u4e4b\u548c","title":"\u9898\u76ee"},{"location":"csdn/%E5%BC%82%E6%88%96%E6%B1%82%E5%92%8C%E5%BC%8F/#_3","text":"\u7b2c\u4e00\u884c\u4e00\u4e2a\u6574\u6570N \u63a5\u4e0b\u6765N\u884c\uff0c\u7b2ci\u884c\u4e3aA[i]","title":"\u8f93\u5165"},{"location":"csdn/%E5%BC%82%E6%88%96%E6%B1%82%E5%92%8C%E5%BC%8F/#_4","text":"\u6240\u9700\u7684\u503c","title":"\u8f93\u51fa"},{"location":"csdn/%E5%BC%82%E6%88%96%E6%B1%82%E5%92%8C%E5%BC%8F/#_5","text":"3 7 3 5","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/%E5%BC%82%E6%88%96%E6%B1%82%E5%92%8C%E5%BC%8F/#_6","text":"12","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/%E5%BC%82%E6%88%96%E6%B1%82%E5%92%8C%E5%BC%8F/#_7","text":"7 xor 3+3 xor 5+7 xor 5 = 4+6+2 = 12","title":"\u6837\u4f8b\u89e3\u91ca"},{"location":"csdn/%E5%BC%82%E6%88%96%E6%B1%82%E5%92%8C%E5%BC%8F/#_8","text":"\u5f02\u6216\uff1aC++\u4e2d\u5373\u4e3a ^ \u8fd0\u7b97\u7b26 0^0=0 , 0^1=1 ,1^0=1, 1^1=0 \u6570\u5b57\u90fd\u5316\u6210\u4e8c\u8fdb\u5236\uff1a7:111, 3:011, 5:101 \u5f02\u6216\u5177\u6709\u4ea4\u6362\u5f8b\uff0c\u4e5f\u5c31\u662f\u8bf4\u53ea\u8981\u80fd\u591f\u4f7f\u5f97\u4efb\u610f\u4e24\u4e2a\u6570\u5b57\u90fd\u5f02\u6216\u4e00\u6b21\uff0c\u5c31\u6ca1\u6709\u5fc5\u8981\u6bcf\u6b21\u7528\u524d\u9762\u7684\u6570\u5b57\u5f02\u6216\u540e\u9762\u7684\u6570\u5b57\u3002\u8fd9\u542f\u53d1\u6211\u4eec\u4e0d\u5173\u6ce8\u5f02\u6216\u7684\u987a\u5e8f\uff0c\u800c\u662f\u5173\u6ce8\u7ed3\u679c\u3002 \u6613\u77e5\uff1aa\u4e2a1\uff0cb\u4e2a0\u4e24\u4e24\u5f02\u6216\u7684\u7ed3\u679c\u80af\u5b9a\u662fa*b\u4e2a1\uff0c\u5176\u4f59\u90fd\u662f0\u3002 \u4e09\u4e2a\u6570\u5b57\u7684\u6700\u4f4e\u4f4d\u5206\u522b\u662f1,1,1\uff0c\u4e5f\u5c31\u662f\u4e09\u4e2a1\u3002\u90a3\u4e48\u6700\u4f4e\u4f4d\u5f02\u6216\u7684\u7ed3\u679c\u4e00\u5b9a\u662f\u96f6\u4e2a1\uff0c\u4e09\u4e2a0\uff0c\u76f8\u52a0\u4e3a0\u3002 \u6b21\u4f4e\u4f4d\u5206\u522b\u662f1,1,0\uff0c\u4e5f\u5c31\u662f\u4e24\u4e2a1\u4e00\u4e2a0\u3002\u90a3\u4e48\u6b21\u4f4e\u4f4d\u5f02\u6216\u7684\u7ed3\u679c\u4e00\u5b9a\u662f\u4e24\u4e2a1\uff0c\u4e00\u4e2a0\uff0c\u76f8\u52a0\u4e3a2\u3002 \u6700\u9ad8\u4f4d\u5206\u522b\u662f1,0,1\uff0c\u4e5f\u5c31\u662f\u4e24\u4e2a1\u4e00\u4e2a0\u3002\u90a3\u4e48\u6700\u9ad8\u4f4d\u5f02\u6216\u7684\u7ed3\u679c\u4e00\u5b9a\u662f\u4e24\u4e2a1\uff0c\u4e00\u4e2a0\uff0c\u76f8\u52a0\u4e3a2\u3002 \u6240\u4ee5\u6700\u540e\u7684\u7b54\u6848\u5e94\u8be5\u662f \u4ee3\u7801\u5982\u4e0b\uff1a #include <iostream> #include <bits/stdc++.h> using namespace std; long long b[50]={0}; int main() { int n; scanf(\"%d\",&n); long long a; for(int i=1;i<=n;i++) { scanf(\"%lld\",&a); int cnt=0; while(a) { cnt++; if(a%2==1) { b[cnt]++; } a=a/2; } } long long sum=0; for(int i=0;i<=31;i++) { sum=sum+(1<<i)*(b[i+1])*(n-b[i+1]); //b[i+1]\u4e3a1\u7684\u4e2a\u6570\uff0cn-b[i+1]\u4e3a0\u7684\u4e2a\u6570,1<<i\u4e3a2\u7684i\u6b21\u5e42 } cout<<sum<<endl; return 0; }","title":"\u9898\u89e3"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/","text":"1.\u66b4\u529b \u00b6 \u6839\u636e\u9636\u4e58\u516c\u5f0f\u5c55\u5f00\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u8f83\u9ad8\uff0c\u4e14\u5bb9\u6613\u70b8\u6389long long 2.\u501f\u7528double\u66b4\u529b\u6765\u6c42 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=1438&pid=9 \u9898\u76ee\u63cf\u8ff0 \u00b6 Imagine you are attending your math lesson at school. Once again, you are bored because your teacher tells things that you already mastered years ago (this time he's explaining that (a+b)2=a2+2ab+b2). So you decide to waste your time with drawing modern art instead. Fortunately you have a piece of squared paper and you choose a rectangle of size n*m on the paper. Let's call this rectangle together with the lines it contains a grid. Starting at the lower left corner of the grid, you move your pencil to the upper right corner, taking care that it stays on the lines and moves only to the right or up. The result is shown on the left: Really a masterpiece, isn't it? Repeating the procedure one more time, you arrive with the picture shown on the right. Now you wonder: how many different works of art can you produce? \u8f93\u5165 \u00b6 The input contains several testcases. Each is specified by two unsigned 32-bit integers n and m, denoting the size of the rectangle. As you can observe, the number of lines of the corresponding grid is one more in each dimension. Input is terminated by n=m=0. \u8f93\u51fa \u00b6 For each test case output on a line the number of different art works that can be generated using the procedure described above. That is, how many paths are there on a grid where each step of the path consists of moving one unit to the right or one unit up? You may safely assume that this number fits into a 32-bit unsigned integer. \u6837\u4f8b\u8f93\u5165 \u00b6 5 4 1 1 0 0 \u6837\u4f8b\u8f93\u51fa \u00b6 126 2 \u8f93\u5165a\u548cb\uff0c\u6c42C(b,a+b) #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { register ll n , k , a , b ; register ll sum , p ; register long double sum1 = 1.0 ; while ( scanf ( \"%lld%lld\" , & n , & k ) && ( n != 0 || k != 0 )) { sum1 = 1.0 ; a = n + k ; b = n < k ? n : k ; for ( int i = 1 ; i <= b ; i ++ ) { sum1 = sum1 * a * 1.0 / i ; a -- ; } sum1 += 0.5 ; sum = sum1 ; printf ( \"%lld \\n \" , sum ); } return 0 ; } 3.\u9006\u5143\u6c42\u7ec4\u5408\u6570 \u00b6 http://icpc.upc.edu.cn/problem.php?id=12104 \u9898\u76ee\u63cf\u8ff0 \u00b6 You are given positive integers N and M. How many sequences a of length N consisting of positive integers satisfy a1\u00d7a2\u00d7...\u00d7aN=M? Find the count modulo 109+7. Here, two sequences a' and a\" are considered different when there exists some i such that a'i\u2260a\"i. Constraints \u00b7All values in input are integers. \u00b71\u2264N\u2264105 \u00b71\u2264M\u2264109 \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N M \u8f93\u51fa \u00b6 Print the number of the sequences consisting of positive integers that satisfy the condition, modulo 109+7. \u6837\u4f8b\u8f93\u5165 \u00b6 2 6 \u6837\u4f8b\u8f93\u51fa \u00b6 4 \u63d0\u793a \u00b6 Four sequences satisfy the condition: {a1,a2}={1,6},{2,3},{3,2} and {6,1}. \u601d\u8def \u00b6 \u8d28\u56e0\u6570\u5206\u89e3\uff0c\u7136\u540e\u6bcf\u4e2a\u7d20\u6570\u56e0\u5b50\u4e2a\u6570\uff0c\u8bbe\u4e3ax\uff0c\u8f6c\u5316\u4e3a\u628ax\u4e2a\u76f8\u540c\u7684\u653e\u8fdbn\u4e2a\u4f4d\u7f6e\uff0c\u5f00\u59cb\u5199\u7684n^x,\u4f46\u662fwa,\u540e\u6765\u5199\u7684\u9694\u677f\u6cd5\u3002 C(n+x-1,n-1)\u3002 \u4e3a\u5565\u4e0d\u662fn^x\uff0c\u56e0\u4e3a\u5143\u7d20\u76f8\u540c\uff0c\u4e0d\u540c\u65b9\u6848\u53d6\u51b3\u4e8e\u6bcf\u4e2a\u76d2\u5b50\u591a\u5c11\u4e2a\u7403\u3002\u53c8\u9694\u677f\u6cd5\u4e0d\u80fd\u6709\u7a7a\u5143\u7d20\uff0c\u4f46\u9898\u76ee\u53ef\u4ee5\u3002\u6240\u4ee5\u6211\u4eec\u6dfb\u52a0\u4e09\u5757\u9694\u677f\uff0c\u7b54\u6848\u4e3a\u4e0a\u3002 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef unsigned long long ll ; const ll N = 1e9 + 7 ; ll w [ 505500 ] = { 0 }; ll p ( ll x , ll y ) { ll sum1 = 1 ; while ( y ) { if ( y & 1 ) sum1 = ( sum1 % N * x % N ) % N ; y >>= 1 ; x = ( x % N * x % N ) % N ; } return sum1 % N ; } ll c1 ( ll x , ll y ) { if ( x < y ) swap ( x , y ); return ( w [ x ] % N * p (( w [ x - y ] % N * w [ y ] % N ) % N , N -2 ) % N ) % N ; } int main () { ll n , m ; w [ 1 ] = 1 ; for ( ll i = 2 ; i <= 500500 ; i ++ ) w [ i ] = ( w [ i -1 ] * i ) % N ; cin >> n >> m ; if ( n == 1 ) { cout << 1 << endl ; return 0 ; } ll sum = 1 ; for ( ll i = 2 ; i * i <= m + 100 ; i ++ ) { if ( m % i != 0 ) continue ; ll js = 0 ; while ( m % i == 0 ) { m = m / i ; js ++ ; } sum = ( sum % N * c1 ( n -1 , n + js -1 ) % N ) % N ; } if ( m != 1 ) sum = ( sum % N * n % N ) % N ; cout << sum % N << endl ; return 0 ; }","title":"\u6c42\u7ec4\u5408\u6570\u7684\u65b9\u6cd5"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#1","text":"\u6839\u636e\u9636\u4e58\u516c\u5f0f\u5c55\u5f00\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u8f83\u9ad8\uff0c\u4e14\u5bb9\u6613\u70b8\u6389long long","title":"1.\u66b4\u529b"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#2double","text":"http://icpc.upc.edu.cn/problem.php?cid=1438&pid=9","title":"2.\u501f\u7528double\u66b4\u529b\u6765\u6c42"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#_1","text":"Imagine you are attending your math lesson at school. Once again, you are bored because your teacher tells things that you already mastered years ago (this time he's explaining that (a+b)2=a2+2ab+b2). So you decide to waste your time with drawing modern art instead. Fortunately you have a piece of squared paper and you choose a rectangle of size n*m on the paper. Let's call this rectangle together with the lines it contains a grid. Starting at the lower left corner of the grid, you move your pencil to the upper right corner, taking care that it stays on the lines and moves only to the right or up. The result is shown on the left: Really a masterpiece, isn't it? Repeating the procedure one more time, you arrive with the picture shown on the right. Now you wonder: how many different works of art can you produce?","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#_2","text":"The input contains several testcases. Each is specified by two unsigned 32-bit integers n and m, denoting the size of the rectangle. As you can observe, the number of lines of the corresponding grid is one more in each dimension. Input is terminated by n=m=0.","title":"\u8f93\u5165"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#_3","text":"For each test case output on a line the number of different art works that can be generated using the procedure described above. That is, how many paths are there on a grid where each step of the path consists of moving one unit to the right or one unit up? You may safely assume that this number fits into a 32-bit unsigned integer.","title":"\u8f93\u51fa"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#_4","text":"5 4 1 1 0 0","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#_5","text":"126 2 \u8f93\u5165a\u548cb\uff0c\u6c42C(b,a+b) #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { register ll n , k , a , b ; register ll sum , p ; register long double sum1 = 1.0 ; while ( scanf ( \"%lld%lld\" , & n , & k ) && ( n != 0 || k != 0 )) { sum1 = 1.0 ; a = n + k ; b = n < k ? n : k ; for ( int i = 1 ; i <= b ; i ++ ) { sum1 = sum1 * a * 1.0 / i ; a -- ; } sum1 += 0.5 ; sum = sum1 ; printf ( \"%lld \\n \" , sum ); } return 0 ; }","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#3","text":"http://icpc.upc.edu.cn/problem.php?id=12104","title":"3.\u9006\u5143\u6c42\u7ec4\u5408\u6570"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#_6","text":"You are given positive integers N and M. How many sequences a of length N consisting of positive integers satisfy a1\u00d7a2\u00d7...\u00d7aN=M? Find the count modulo 109+7. Here, two sequences a' and a\" are considered different when there exists some i such that a'i\u2260a\"i. Constraints \u00b7All values in input are integers. \u00b71\u2264N\u2264105 \u00b71\u2264M\u2264109","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#_7","text":"Input is given from Standard Input in the following format: N M","title":"\u8f93\u5165"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#_8","text":"Print the number of the sequences consisting of positive integers that satisfy the condition, modulo 109+7.","title":"\u8f93\u51fa"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#_9","text":"2 6","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#_10","text":"4","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#_11","text":"Four sequences satisfy the condition: {a1,a2}={1,6},{2,3},{3,2} and {6,1}.","title":"\u63d0\u793a"},{"location":"csdn/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/#_12","text":"\u8d28\u56e0\u6570\u5206\u89e3\uff0c\u7136\u540e\u6bcf\u4e2a\u7d20\u6570\u56e0\u5b50\u4e2a\u6570\uff0c\u8bbe\u4e3ax\uff0c\u8f6c\u5316\u4e3a\u628ax\u4e2a\u76f8\u540c\u7684\u653e\u8fdbn\u4e2a\u4f4d\u7f6e\uff0c\u5f00\u59cb\u5199\u7684n^x,\u4f46\u662fwa,\u540e\u6765\u5199\u7684\u9694\u677f\u6cd5\u3002 C(n+x-1,n-1)\u3002 \u4e3a\u5565\u4e0d\u662fn^x\uff0c\u56e0\u4e3a\u5143\u7d20\u76f8\u540c\uff0c\u4e0d\u540c\u65b9\u6848\u53d6\u51b3\u4e8e\u6bcf\u4e2a\u76d2\u5b50\u591a\u5c11\u4e2a\u7403\u3002\u53c8\u9694\u677f\u6cd5\u4e0d\u80fd\u6709\u7a7a\u5143\u7d20\uff0c\u4f46\u9898\u76ee\u53ef\u4ee5\u3002\u6240\u4ee5\u6211\u4eec\u6dfb\u52a0\u4e09\u5757\u9694\u677f\uff0c\u7b54\u6848\u4e3a\u4e0a\u3002 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef unsigned long long ll ; const ll N = 1e9 + 7 ; ll w [ 505500 ] = { 0 }; ll p ( ll x , ll y ) { ll sum1 = 1 ; while ( y ) { if ( y & 1 ) sum1 = ( sum1 % N * x % N ) % N ; y >>= 1 ; x = ( x % N * x % N ) % N ; } return sum1 % N ; } ll c1 ( ll x , ll y ) { if ( x < y ) swap ( x , y ); return ( w [ x ] % N * p (( w [ x - y ] % N * w [ y ] % N ) % N , N -2 ) % N ) % N ; } int main () { ll n , m ; w [ 1 ] = 1 ; for ( ll i = 2 ; i <= 500500 ; i ++ ) w [ i ] = ( w [ i -1 ] * i ) % N ; cin >> n >> m ; if ( n == 1 ) { cout << 1 << endl ; return 0 ; } ll sum = 1 ; for ( ll i = 2 ; i * i <= m + 100 ; i ++ ) { if ( m % i != 0 ) continue ; ll js = 0 ; while ( m % i == 0 ) { m = m / i ; js ++ ; } sum = ( sum % N * c1 ( n -1 , n + js -1 ) % N ) % N ; } if ( m != 1 ) sum = ( sum % N * n % N ) % N ; cout << sum % N << endl ; return 0 ; }","title":"\u601d\u8def"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/","text":"1.\u6811\u72b6\u6570\u7ec4\u76f4\u63a5\u6c42\u9006\u5e8f\u5bf9 \u00b6 \u91c7\u7528\u6811\u72b6\u6570\u7ec4\u6807\u8bb0\u6765\u6c42\u9006\u5e8f\u5bf9 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n , m ; ll a [ 100500 ] = { 0 }; ll c [ 100500 ] = { 0 }; ll maxn = 10050 , k , ans = 0 ; ll lowbit ( ll x ) { return x & ( - x ); } ll add ( ll k , ll x ) { for ( ll i = k ; i <= maxn ; i += lowbit ( i )) c [ i ] += x ; } ll getsum ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c [ i ]; return ans ; } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & k ); add ( k , 1 ); ans += i - getsum ( k ); } printf ( \"%d \\n \" , ans ); } 2.\u79bb\u6563\u5316+\u6811\u72b6\u6570\u7ec4\u6c42\u9006\u5e8f\u5bf9 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=1422&pid=3 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u201c\u88c5\u6ee1\u4e86\u9e45\u5375\u77f3\u7684\u74f6\u5b50\u662f\u6ee1\u7684\u5417\uff1f\u201d\u58a8\u8001\u5e08\u66fe\u7ecf\u8fd9\u6837\u95ee\u8fc7\u4ed6\u7684\u5b66\u751f\u3002\u201c\u4e0d\u662f\uff0c\u56e0\u4e3a\u8fd8\u53ef\u4ee5\u653e\u5165\u5c0f\u77f3\u5b50\u3001\u518d\u653e\u5165\u7ec6\u7802\u3001\u6700\u540e\u518d\u5012\u5165\u6c34\u3002\u201d\u5b66\u751f\u4eec\u56de\u7b54\u3002\u201c\u90a3\u4e48\u4ece\u4e2d\u53ef\u4ee5\u5f97\u5230\u4ec0\u4e48\u542f\u793a\u5462\uff1f\u201d\u58a8\u8001\u5e08\u53c8\u95ee\uff0c\u201c\u542f\u793a\u6211\u4eec\u65f6\u95f4\u603b\u662f\u53ef\u4ee5\u6324\u51fa\u6765\u7684\uff01\u201d\u4e00\u4e2a\u806a\u660e\u7684\u5b66\u751f\u62a2\u7b54\u3002\u201c\u4f60\u8bf4\u5f97\u5bf9\uff01\u201d\u58a8\u8001\u5e08\u5fae\u7b11\u9053\uff0c\u201c\u4f46\u6211\u8fd8\u8981\u544a\u8bc9\u4f60\u4eec\u53e6\u4e00\u4e2a\u91cd\u8981\u7ecf\u9a8c\uff0c\u90a3\u5c31\u662f\uff1a\u5982\u679c\u4f60\u4e0d\u5148\u5c06\u5927\u7684\u9e45\u5375\u77f3\u653e\u8fdb\u74f6\u5b50\u91cc\u53bb\uff0c\u4f60\u4e5f\u8bb8\u4ee5\u540e\u6c38\u8fdc\u6ca1\u673a\u4f1a\u518d\u628a\u5b83\u4eec\u653e\u8fdb\u53bb\u4e86\u3002\u201d \u4f46\u8fd9\u4e16\u4e0a\u7684\u5f88\u591a\u4eba\uff0c\u505a\u4e8b\u5374\u7ecf\u5e38\u5206\u4e0d\u6e05\u4e8b\u60c5\u7684\u8f7b\u91cd\u7f13\u6025\u3002\u6211\u4eec\u53ef\u7231\u7684\u5178\u72f1\u957f\u5927\u4eba\u5c31\u72af\u4e86\u8fd9\u4e2a\u9519\u8bef\uff0c\u5f53\u4ed6\u770b\u5230\u8eab\u9ad8\u53c2\u5dee\u4e0d\u9f50\u7684\u72f1\u8b66\u4eec\u6392\u6210\u4e00\u5217\u65f6\uff0c\u7709\u6bdb\u62e7\u6210\u4e86\u4e00\u4e2a\u7ed3\uff0c\u4ed6\u6700\u60f3\u77e5\u9053\u7684\u5c31\u662f\uff0c\u5230\u5e95\u6709\u591a\u5c11\u4e2a\u72f1\u8b66\u9006\u5e8f\u6392\u961f\u4e86\u3002\u8fd9\u53ef\u4ee5\u62bd\u8c61\u4e3a\u6c42\u9006\u5e8f\u5bf9\u7684\u4e2a\u6570\u95ee\u9898\uff1a\u5373\u5bf9\u4e8e\u4e00\u4e2a\u5305\u542bn\u4e2a\u975e\u8d1f\u6574\u6570\u7684\u6570\u7ec4A[1\uff0c\u2026\uff0cn]\uff0c\u5982\u679c\u6709i < j\uff0c\u4e14A[ i ]>A[ j ]\uff0c\u5219\u79f0(A[ i] \uff0cA[ j] )\u4e3a\u6570\u7ec4A\u4e2d\u7684\u4e00\u4e2a\u9006\u5e8f\u5bf9\u3002 \u4f8b\u5982\uff0c\u6570\u7ec4\uff083\uff0c1\uff0c4\uff0c5\uff0c2\uff09\u7684\u9006\u5e8f\u5bf9\u6709(3\uff0c1)\uff0c(3\uff0c2)\uff0c(4\uff0c2)\uff0c(5\uff0c2)\u51714\u4e2a\u3002 \u8f93\u5165 \u00b6 \u5305\u62ec\u4e24\u884c\uff0c\u7b2c\u4e00\u884c\u662f\u4e00\u4e2a\u6574\u6570n(1\u2264n\u22641000)\uff0c\u8868\u793a\u72f1\u8b66\u4eba\u6570\u3002\u7b2c\u4e8c\u884c\u5305\u542bn\u4e2a\u6574\u6570\uff0c\u7528\u7a7a\u683c\u5206\u9694\uff0c\u5373\u6bcf\u4e2a\u72f1\u8b66\u7684\u8eab\u9ad8\uff0c\u72f1\u8b66\u8eab\u9ad8\u5747\u5728int\u8303\u56f4\u5185\u3002 \u8f93\u51fa \u00b6 \u5305\u62ec\u4e00\u884c\uff0c\u8fd9\u4e00\u884c\u53ea\u5305\u542b\u4e00\u4e2a\u6574\u6570\uff0c\u5373\u9006\u5e8f\u5bf9\u7684\u4e2a\u6570\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 5 3 1 4 5 2 \u6837\u4f8b\u8f93\u51fa \u00b6 4 \u9996\u5148\u4ecb\u7ecd\u4e00\u4e0b\u79bb\u6563\u5316\uff0c\u79bb\u6563\u5316\u662f\u5728\u4e0d\u6539\u53d8\u6570\u636e\u76f8\u5bf9\u5927\u5c0f\u7684\u6761\u4ef6\u4e0b\uff0c\u5bf9\u6570\u636e\u8fdb\u884c\u76f8\u5e94\u7684\u7f29\u5c0f\u3002\u4f8b\u5982\uff1a\u539f\u6570\u636e\uff1a1,999,100000,15\uff1b\u5904\u7406\u540e\uff1a1,3,4,2\uff1b \u8fd9\u6837\u7ecf\u8fc7\u79bb\u6563\u5316\u5904\u7406\u540e\u80fd\u591f\u51cf\u5c11\u6807\u8bb0\u6570\u7ec4\u7684\u8303\u56f4\uff0c\u51cf\u5c11\u65f6\u95f4\u590d\u6742\u5ea6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n , m ; struct node { ll x ; ll pos ; }; node a [ 100500 ] = { 0 }; ll b [ 100500 ] = { 0 }; ll c [ 100500 ] = { 0 }; ll maxn = 100005 , k , ans = 0 ; ll lowbit ( ll x ) { return x & ( - x ); } ll add ( ll k , ll x ) { for ( ll i = k ; i <= maxn ; i += lowbit ( i )) c [ i ] += x ; } ll getsum ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c [ i ]; return ans ; } bool cmp ( node a , node b ) { return a . x < b . x ; } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]. x ); a [ i ]. pos = i ; } sort ( a + 1 , a + n + 1 , cmp ); ll cnt = 1 ; for ( ll i = 1 ; i <= n ; i ++ ) { if ( i != 1 && a [ i ]. x != a [ i -1 ]. x ) cnt ++ ; b [ a [ i ]. pos ] = cnt ; } for ( ll i = 1 ; i <= n ; i ++ ) { add ( b [ i ], 1 ); ans += i - getsum ( b [ i ]); } printf ( \"%lld \\n \" , ans ); } 3.\u5f52\u5e76\u6392\u5e8f\u6c42\u9006\u5e8f\u5bf9 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2436&pid=0 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u67d0\u6b63\u6559\u6388\u7ea7\u7279\u7ea7\u6559\u5e08\u83b7\u5f97\u4e86\u4e00\u6bb5\u53e4\u8001\u7684\u6587\u5b57\uff0c\u5168\u90e8\u7531 26 \u4e2a\u5927\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u3002\u4ed6\u4ea7\u751f\u4e86\u4e00\u4e2a\u75af\u72c2\u7684\u60f3\u6cd5\uff0c\u5373\u60f3\u628a\u8fd9\u6bb5\u6587\u5b57\u4e2d\u6240\u6709\u5b57\u6bcd\u6309 A \u5230 Z \u7684\u987a\u5e8f\u6392\u5e8f\uff0c\u5373\u6240\u6709 A \u653e\u5728\u5f00\u5934\uff0c\u7136\u540e\u8ddf\u7740\u6240\u6709 B\uff0c\u518d\u662f\u6240\u6709 C\uff0c\u6700\u540e\u662f\u6240\u6709 Z\u3002\u6bd4\u5982\u539f \u5b57\u7b26\u4e32\u4e3a\u201cHELLOWORLD\u201d\uff0c\u6392\u5e8f\u540e\u5e94\u53d8\u4e3a\u201cDEHLLLOORW\u201d\u3002\u4f46\u662f\u7279\u6559\u6bd5\u7adf\u9886\u7740\u56fd\u52a1\u9662\u7684\u7279\u6b8a\u6d25\u8d34\uff0c\u4e8e\u662f\u4ed6\u8fd8\u6709\u4e00\u4e2a\u8981\u6c42\uff0c\u5373\u6392\u5e8f\u65f6\u6bcf\u6b21\u53ea\u80fd\u4ea4\u6362\u76f8\u90bb\u4e24\u4e2a\u5b57\u6bcd\u3002\u73b0\u5728\u4ed6\u60f3\u77e5\u9053\u6700\u5c11\u4ea4\u6362\u591a\u5c11\u6b21\u80fd\u5b8c\u6210\u6392\u5e8f\uff1f \u8f93\u5165 \u00b6 \u4ec5\u4e00\u884c\uff0c\u5305\u542b\u4e00\u4e2a\u4ec5\u542b\u5927\u5199\u5b57\u6bcd\u7684\u957f\u5ea6\u4e3a L \u7684\u5b57\u7b26\u4e32\uff08\u6ce8\u610f L \u4e0d\u8f93\u5165\uff09\u3002 \u8f93\u51fa \u00b6 \u5171\u4e00\u884c\uff0c\u5305\u542b\u4e00\u4e2a\u6574\u6570\u8868\u793a\u6700\u5c11\u4ea4\u6362\u6b21\u6570\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 LSDSL \u3010\u6837\u4f8b2\u3011 HELLOWORLD \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 4 \u3010\u6837\u4f8b2\u3011 16 \u63d0\u793a \u00b6 \u5bf9\u4e8e50%\u7684\u6570\u636e\uff0c1\u2264L\u22642000\uff1b \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c1\u2264L\u22642\u00d710^6 \u501f\u7528\u5f52\u5e76\u6392\u5e8f\u6765\u6c42\u9006\u5e8f\u5bf9 #include <iostream> #include <bits/stdc++.h> using namespace std ; char a1 [ 2005000 ] = \"\" ; int a [ 2005000 ] = { 0 }; int b [ 2005000 ] = { 0 }; long long int merge_sort ( long long int l , long long int r ) { if ( l >= r ) return 0 ; long long int mid = ( l + r ) >> 1 , res = 0 ; res += merge_sort ( l , mid ); res += merge_sort ( mid + 1 , r ); long long int i = l , j = mid + 1 , cnt = 0 ; while ( i <= mid && j <= r ) if ( a [ i ] <= a [ j ]) b [ cnt ++ ] = a [ i ++ ]; else { res += mid - i + 1 ; b [ cnt ++ ] = a [ j ++ ]; } while ( i <= mid ) b [ cnt ++ ] = a [ i ++ ]; while ( j <= r ) b [ cnt ++ ] = a [ j ++ ]; for ( long long int i = l , j = 0 ; j < cnt ; ++ i , ++ j ) a [ i ] = b [ j ]; return res ; } int main () { scanf ( \"%s\" , a1 ); for ( long long int i = 0 ; a1 [ i ]; i ++ ) { a [ i ] = a1 [ i ] - 'a' ; } long long int sum = merge_sort ( 0 , strlen ( a1 ) -1 ); cout << sum << endl ; return 0 ; }","title":"\u6c42\u9006\u5e8f\u5bf9"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/#1","text":"\u91c7\u7528\u6811\u72b6\u6570\u7ec4\u6807\u8bb0\u6765\u6c42\u9006\u5e8f\u5bf9 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n , m ; ll a [ 100500 ] = { 0 }; ll c [ 100500 ] = { 0 }; ll maxn = 10050 , k , ans = 0 ; ll lowbit ( ll x ) { return x & ( - x ); } ll add ( ll k , ll x ) { for ( ll i = k ; i <= maxn ; i += lowbit ( i )) c [ i ] += x ; } ll getsum ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c [ i ]; return ans ; } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & k ); add ( k , 1 ); ans += i - getsum ( k ); } printf ( \"%d \\n \" , ans ); }","title":"1.\u6811\u72b6\u6570\u7ec4\u76f4\u63a5\u6c42\u9006\u5e8f\u5bf9"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/#2","text":"http://icpc.upc.edu.cn/problem.php?cid=1422&pid=3","title":"2.\u79bb\u6563\u5316+\u6811\u72b6\u6570\u7ec4\u6c42\u9006\u5e8f\u5bf9"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/#_1","text":"\u201c\u88c5\u6ee1\u4e86\u9e45\u5375\u77f3\u7684\u74f6\u5b50\u662f\u6ee1\u7684\u5417\uff1f\u201d\u58a8\u8001\u5e08\u66fe\u7ecf\u8fd9\u6837\u95ee\u8fc7\u4ed6\u7684\u5b66\u751f\u3002\u201c\u4e0d\u662f\uff0c\u56e0\u4e3a\u8fd8\u53ef\u4ee5\u653e\u5165\u5c0f\u77f3\u5b50\u3001\u518d\u653e\u5165\u7ec6\u7802\u3001\u6700\u540e\u518d\u5012\u5165\u6c34\u3002\u201d\u5b66\u751f\u4eec\u56de\u7b54\u3002\u201c\u90a3\u4e48\u4ece\u4e2d\u53ef\u4ee5\u5f97\u5230\u4ec0\u4e48\u542f\u793a\u5462\uff1f\u201d\u58a8\u8001\u5e08\u53c8\u95ee\uff0c\u201c\u542f\u793a\u6211\u4eec\u65f6\u95f4\u603b\u662f\u53ef\u4ee5\u6324\u51fa\u6765\u7684\uff01\u201d\u4e00\u4e2a\u806a\u660e\u7684\u5b66\u751f\u62a2\u7b54\u3002\u201c\u4f60\u8bf4\u5f97\u5bf9\uff01\u201d\u58a8\u8001\u5e08\u5fae\u7b11\u9053\uff0c\u201c\u4f46\u6211\u8fd8\u8981\u544a\u8bc9\u4f60\u4eec\u53e6\u4e00\u4e2a\u91cd\u8981\u7ecf\u9a8c\uff0c\u90a3\u5c31\u662f\uff1a\u5982\u679c\u4f60\u4e0d\u5148\u5c06\u5927\u7684\u9e45\u5375\u77f3\u653e\u8fdb\u74f6\u5b50\u91cc\u53bb\uff0c\u4f60\u4e5f\u8bb8\u4ee5\u540e\u6c38\u8fdc\u6ca1\u673a\u4f1a\u518d\u628a\u5b83\u4eec\u653e\u8fdb\u53bb\u4e86\u3002\u201d \u4f46\u8fd9\u4e16\u4e0a\u7684\u5f88\u591a\u4eba\uff0c\u505a\u4e8b\u5374\u7ecf\u5e38\u5206\u4e0d\u6e05\u4e8b\u60c5\u7684\u8f7b\u91cd\u7f13\u6025\u3002\u6211\u4eec\u53ef\u7231\u7684\u5178\u72f1\u957f\u5927\u4eba\u5c31\u72af\u4e86\u8fd9\u4e2a\u9519\u8bef\uff0c\u5f53\u4ed6\u770b\u5230\u8eab\u9ad8\u53c2\u5dee\u4e0d\u9f50\u7684\u72f1\u8b66\u4eec\u6392\u6210\u4e00\u5217\u65f6\uff0c\u7709\u6bdb\u62e7\u6210\u4e86\u4e00\u4e2a\u7ed3\uff0c\u4ed6\u6700\u60f3\u77e5\u9053\u7684\u5c31\u662f\uff0c\u5230\u5e95\u6709\u591a\u5c11\u4e2a\u72f1\u8b66\u9006\u5e8f\u6392\u961f\u4e86\u3002\u8fd9\u53ef\u4ee5\u62bd\u8c61\u4e3a\u6c42\u9006\u5e8f\u5bf9\u7684\u4e2a\u6570\u95ee\u9898\uff1a\u5373\u5bf9\u4e8e\u4e00\u4e2a\u5305\u542bn\u4e2a\u975e\u8d1f\u6574\u6570\u7684\u6570\u7ec4A[1\uff0c\u2026\uff0cn]\uff0c\u5982\u679c\u6709i < j\uff0c\u4e14A[ i ]>A[ j ]\uff0c\u5219\u79f0(A[ i] \uff0cA[ j] )\u4e3a\u6570\u7ec4A\u4e2d\u7684\u4e00\u4e2a\u9006\u5e8f\u5bf9\u3002 \u4f8b\u5982\uff0c\u6570\u7ec4\uff083\uff0c1\uff0c4\uff0c5\uff0c2\uff09\u7684\u9006\u5e8f\u5bf9\u6709(3\uff0c1)\uff0c(3\uff0c2)\uff0c(4\uff0c2)\uff0c(5\uff0c2)\u51714\u4e2a\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/#_2","text":"\u5305\u62ec\u4e24\u884c\uff0c\u7b2c\u4e00\u884c\u662f\u4e00\u4e2a\u6574\u6570n(1\u2264n\u22641000)\uff0c\u8868\u793a\u72f1\u8b66\u4eba\u6570\u3002\u7b2c\u4e8c\u884c\u5305\u542bn\u4e2a\u6574\u6570\uff0c\u7528\u7a7a\u683c\u5206\u9694\uff0c\u5373\u6bcf\u4e2a\u72f1\u8b66\u7684\u8eab\u9ad8\uff0c\u72f1\u8b66\u8eab\u9ad8\u5747\u5728int\u8303\u56f4\u5185\u3002","title":"\u8f93\u5165"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/#_3","text":"\u5305\u62ec\u4e00\u884c\uff0c\u8fd9\u4e00\u884c\u53ea\u5305\u542b\u4e00\u4e2a\u6574\u6570\uff0c\u5373\u9006\u5e8f\u5bf9\u7684\u4e2a\u6570\u3002","title":"\u8f93\u51fa"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/#_4","text":"5 3 1 4 5 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/#_5","text":"4 \u9996\u5148\u4ecb\u7ecd\u4e00\u4e0b\u79bb\u6563\u5316\uff0c\u79bb\u6563\u5316\u662f\u5728\u4e0d\u6539\u53d8\u6570\u636e\u76f8\u5bf9\u5927\u5c0f\u7684\u6761\u4ef6\u4e0b\uff0c\u5bf9\u6570\u636e\u8fdb\u884c\u76f8\u5e94\u7684\u7f29\u5c0f\u3002\u4f8b\u5982\uff1a\u539f\u6570\u636e\uff1a1,999,100000,15\uff1b\u5904\u7406\u540e\uff1a1,3,4,2\uff1b \u8fd9\u6837\u7ecf\u8fc7\u79bb\u6563\u5316\u5904\u7406\u540e\u80fd\u591f\u51cf\u5c11\u6807\u8bb0\u6570\u7ec4\u7684\u8303\u56f4\uff0c\u51cf\u5c11\u65f6\u95f4\u590d\u6742\u5ea6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n , m ; struct node { ll x ; ll pos ; }; node a [ 100500 ] = { 0 }; ll b [ 100500 ] = { 0 }; ll c [ 100500 ] = { 0 }; ll maxn = 100005 , k , ans = 0 ; ll lowbit ( ll x ) { return x & ( - x ); } ll add ( ll k , ll x ) { for ( ll i = k ; i <= maxn ; i += lowbit ( i )) c [ i ] += x ; } ll getsum ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c [ i ]; return ans ; } bool cmp ( node a , node b ) { return a . x < b . x ; } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]. x ); a [ i ]. pos = i ; } sort ( a + 1 , a + n + 1 , cmp ); ll cnt = 1 ; for ( ll i = 1 ; i <= n ; i ++ ) { if ( i != 1 && a [ i ]. x != a [ i -1 ]. x ) cnt ++ ; b [ a [ i ]. pos ] = cnt ; } for ( ll i = 1 ; i <= n ; i ++ ) { add ( b [ i ], 1 ); ans += i - getsum ( b [ i ]); } printf ( \"%lld \\n \" , ans ); }","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/#3","text":"http://icpc.upc.edu.cn/problem.php?cid=2436&pid=0","title":"3.\u5f52\u5e76\u6392\u5e8f\u6c42\u9006\u5e8f\u5bf9"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/#_6","text":"\u67d0\u6b63\u6559\u6388\u7ea7\u7279\u7ea7\u6559\u5e08\u83b7\u5f97\u4e86\u4e00\u6bb5\u53e4\u8001\u7684\u6587\u5b57\uff0c\u5168\u90e8\u7531 26 \u4e2a\u5927\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u3002\u4ed6\u4ea7\u751f\u4e86\u4e00\u4e2a\u75af\u72c2\u7684\u60f3\u6cd5\uff0c\u5373\u60f3\u628a\u8fd9\u6bb5\u6587\u5b57\u4e2d\u6240\u6709\u5b57\u6bcd\u6309 A \u5230 Z \u7684\u987a\u5e8f\u6392\u5e8f\uff0c\u5373\u6240\u6709 A \u653e\u5728\u5f00\u5934\uff0c\u7136\u540e\u8ddf\u7740\u6240\u6709 B\uff0c\u518d\u662f\u6240\u6709 C\uff0c\u6700\u540e\u662f\u6240\u6709 Z\u3002\u6bd4\u5982\u539f \u5b57\u7b26\u4e32\u4e3a\u201cHELLOWORLD\u201d\uff0c\u6392\u5e8f\u540e\u5e94\u53d8\u4e3a\u201cDEHLLLOORW\u201d\u3002\u4f46\u662f\u7279\u6559\u6bd5\u7adf\u9886\u7740\u56fd\u52a1\u9662\u7684\u7279\u6b8a\u6d25\u8d34\uff0c\u4e8e\u662f\u4ed6\u8fd8\u6709\u4e00\u4e2a\u8981\u6c42\uff0c\u5373\u6392\u5e8f\u65f6\u6bcf\u6b21\u53ea\u80fd\u4ea4\u6362\u76f8\u90bb\u4e24\u4e2a\u5b57\u6bcd\u3002\u73b0\u5728\u4ed6\u60f3\u77e5\u9053\u6700\u5c11\u4ea4\u6362\u591a\u5c11\u6b21\u80fd\u5b8c\u6210\u6392\u5e8f\uff1f","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/#_7","text":"\u4ec5\u4e00\u884c\uff0c\u5305\u542b\u4e00\u4e2a\u4ec5\u542b\u5927\u5199\u5b57\u6bcd\u7684\u957f\u5ea6\u4e3a L \u7684\u5b57\u7b26\u4e32\uff08\u6ce8\u610f L \u4e0d\u8f93\u5165\uff09\u3002","title":"\u8f93\u5165"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/#_8","text":"\u5171\u4e00\u884c\uff0c\u5305\u542b\u4e00\u4e2a\u6574\u6570\u8868\u793a\u6700\u5c11\u4ea4\u6362\u6b21\u6570\u3002","title":"\u8f93\u51fa"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/#_9","text":"\u3010\u6837\u4f8b1\u3011 LSDSL \u3010\u6837\u4f8b2\u3011 HELLOWORLD","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/#_10","text":"\u3010\u6837\u4f8b1\u3011 4 \u3010\u6837\u4f8b2\u3011 16","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/#_11","text":"\u5bf9\u4e8e50%\u7684\u6570\u636e\uff0c1\u2264L\u22642000\uff1b \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c1\u2264L\u22642\u00d710^6 \u501f\u7528\u5f52\u5e76\u6392\u5e8f\u6765\u6c42\u9006\u5e8f\u5bf9 #include <iostream> #include <bits/stdc++.h> using namespace std ; char a1 [ 2005000 ] = \"\" ; int a [ 2005000 ] = { 0 }; int b [ 2005000 ] = { 0 }; long long int merge_sort ( long long int l , long long int r ) { if ( l >= r ) return 0 ; long long int mid = ( l + r ) >> 1 , res = 0 ; res += merge_sort ( l , mid ); res += merge_sort ( mid + 1 , r ); long long int i = l , j = mid + 1 , cnt = 0 ; while ( i <= mid && j <= r ) if ( a [ i ] <= a [ j ]) b [ cnt ++ ] = a [ i ++ ]; else { res += mid - i + 1 ; b [ cnt ++ ] = a [ j ++ ]; } while ( i <= mid ) b [ cnt ++ ] = a [ i ++ ]; while ( j <= r ) b [ cnt ++ ] = a [ j ++ ]; for ( long long int i = l , j = 0 ; j < cnt ; ++ i , ++ j ) a [ i ] = b [ j ]; return res ; } int main () { scanf ( \"%s\" , a1 ); for ( long long int i = 0 ; a1 [ i ]; i ++ ) { a [ i ] = a1 [ i ] - 'a' ; } long long int sum = merge_sort ( 0 , strlen ( a1 ) -1 ); cout << sum << endl ; return 0 ; }","title":"\u63d0\u793a"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/","text":"\u6b27\u51e0\u91cc\u5fb7\u5b9a\u7406: \u00b6 \u5bf9\u4e8e\u6574\u6570a,b\u6765\u8bf4\uff0cgcd(a, b)==gcd(b, a%b)==d(a\u4e0eb\u7684\u6700\u5927\u516c\u7ea6\u6570)\uff0c\u53c8\u79f0\u4e3a\u8f97\u8f6c\u76f8\u9664\u6cd5 \u8bc1\u660e\uff1a \u56e0\u4e3aa\u662fd\u7684\u500d\u6570\uff0cb\u662fd\u7684\u500d\u6570\uff1b\u6240\u4ee5a%d=0\uff1b b%d=0\uff1b \u8bbek=a/b\uff1br=a%b\uff1b\u5219 a=k*b+r\uff1b \u7531\u4e0a\u5f97\u51fa\uff1ar=a-k*b\uff1b \u56e0\u4e3aa\u548cb\u90fd\u662fd\u7684\u500d\u6570\uff0c\u6240\u4ee5(a-k*b)\u4e5f\u662fd\u7684\u500d\u6570\uff0c\u6240\u4ee5r\u4e5f\u662fd\u7684\u500d\u6570\uff1b \u6240\u4ee5gcd(a, b)==gcd(b, a%b)==d \u800c\u4e3a\u4ec0\u4e48\u8981\u8bc1\u660egcd(a, b)==gcd(b, a%b)==d\u8fd9\u4e2a\u5f0f\u5b50\u6210\u7acb\u5462\uff1f \u5176\u5b9e\u8bc1\u660egcd(a, b)==gcd(a, a%b)==d\u8fd9\u4e2a\u5f0f\u5b50\u6210\u7acb\u4e5f\u662f\u53ef\u4ee5\u7684\uff0c\u56e0\u4e3aa\u4e5f\u662fd\u7684\u500d\u6570\uff0c\u4f46\u662f\u5728\u8fdb\u884c\u9012\u5f52\u4e4b\u524d\u8981\u8fdb\u884c\u4e00\u6b65\u64cd\u4f5c\uff0c\u5c31\u662f\u5224\u65ada\u4e0eb\u7684\u5927\u5c0f\uff0c\u5982\u679ca<b,\u5c31\u6ca1\u529e\u6cd5\u8fdb\u884c\u9012\u5f52\u6216\u8005\u5faa\u73af\u6c42\u6700\u5927\u516c\u7ea6\u6570\uff0c\u90a3\u4e48\u5982\u679ca b,\u90a3\u4e48a%b<a\u5fc5\u5b9a\u6210\u7acb\uff1b \u4e8b\u5b9e\u53d1\u73b0\u8bc1\u660egcd(a, b)==gcd(b, a%b)==d\u8fd9\u4e2a\u5f0f\u5b50\u4f1a\u7f29\u5c0f\u5904\u7406\u7684\u6570\u636e\u7684\u8303\u56f4\uff1b \u6b27\u51e0\u91cc\u5fb7\u5e94\u7528\uff1a \u7528\u6765\u6c42a\uff0cb\u7684\u6700\u5927\u516c\u7ea6\u6570\u3002 \u4ee3\u7801\u5b9e\u73b0\uff1a int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ); } \u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u5b9a\u5f8b\uff1a \u00b6 \u5bf9\u4e8e\u4e0d\u5b8c\u5168\u4e3a0\u7684\u975e\u8d1f\u6574\u6570a\uff0cb;gcd(a, b)\u8868\u793aa, b\u7684\u6700\u5927\u516c\u7ea6\u6570\uff0c\u5fc5\u5b9a\u5b58\u5728\u6574\u6570\u5bf9x\uff0cy\uff0c\u6ee1\u8db3a*x+b*y==gcd(a, b); \u8bc1\u660e\uff1a a*x1+b*y1=gcd(a, b); b*x2+(a%b)*y2=gcd(b, a%b); \u56e0\u4e3a\u7531\u6b27\u51e0\u91cc\u5fb7\u5b9a\u7406\u77e5\uff1agcd(a, b)==gcd(b, a%b) \u6240\u4ee5a*x1+b*y1=b*x2+(a%b)*y2; \u3000\u3000\u56e0\u4e3ar=a%b, r =a-k*b\u6240\u4ee5==> a*x1+b*y1=b*x2+(a-k*b)*y2; \u3000\u3000\u56e0\u4e3ak=a/b;\u6240\u4ee5\u3000==> a*x1+b*y1=b*x2+(a-(a/b)*b)*y2; \u3000\u3000\u5c55\u5f00\u5f97\u5230\u3000\u3000==>\u3000\u3000\u3000\u3000 a*x1+b*y1=b*x2+a*y2-b*(a/b)*y2;\u3000\u3000\u8f6c\u6362\u5f97\u5230 ==> a*x1+b*y1=a*y2+b*(x2-(a/b)*y2); \u89c2\u5bdf\u4e0a\u5f0f\u53ef\u77e5 x1=y2, y1=x2-a/b*y2; \u7531\u6b64\u53ef\u77e5x1\uff0cy1\u662f\u7531x2\uff0cy2\u5f97\u51fa\u6765\u7684\uff0c\u7531\u6b64\u7c7b\u63a8x2\uff0cy2\u662f\u7531x3\uff0cy3\u5f97\u51fa\u6765\u7684\uff0c \u90a3\u4ec0\u4e48\u65f6\u5019\u662f\u7ec8\u6b62\u5462\uff1f\u4e5f\u5c31\u662f\u9012\u5f52gcd(a, b)\u4e2db=0\u65f6\uff1b\u4e5f\u5c31\u662f\u8bf4\u6b64\u65f6a\u7684\u503c\u5c31\u662f\u8981\u6c42\u5f97\u6700\u5927\u516c\u7ea6\u6570 \u5373gcd(a, 0)\u6b64\u65f6\u7531\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u5f8ba*x+b*y==gcd(a, b)\u77e5 a*x+b*y=a; \u89e3\u51fax=1, y=0; \u6b64\u65f6\u5c31\u662f\u9012\u5f52\u7ec8\u6b62\u7684\u5730\u65b9\uff1a \u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u5e94\u7528\uff1a \u5c31\u6211\u76ee\u524d\u6240\u77e5\u7684\u5c31\u662f\uff1a\u6c42\u89e3\u4e0d\u5b9a\u65b9\u7a0b\uff1b\u5982a*x+b*y=c; \u5df2\u77e5a, b, c\u7684\u503c\u6c42x\u548cy\u7684\u503c \u90a3\u4e48\u95ee\u9898\u6765\u4e86\uff0c\u5982\u4f55\u5c06\u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u5b9a\u5f8b\u5e94\u7528\u5728\u6c42\u89e3\u4e0d\u5b9a\u65b9\u7a0b\u5462\uff1f \u53ef\u4ee5\u8fd9\u6837\u8f6c\u5316 a*x+b*y=gcd(a, b)*c/gcd(a, b); \u6700\u540e\u8f6c\u5316\u4e3a a*x/(c/gcd(a, b))+b*y/(c/gcd(a, b))=gcd(a, b); \u6700\u540e\u6c42\u51fa\u7684\u89e3x0\uff0cy0\u4e58\u4e0ac/gcd(a, b)\u5c31\u662f\u6700\u7ec8\u7684\u7ed3\u679c\u4e86 x1=x0*c/gcd(a, b); y1=y0*c/gcd(a, b); \u4ee3\u7801\u5b9e\u73b0\uff1a \u4e3e\u4f8b\u8bf4\u660e\uff1a http://codeforces.com/problemset/problem/7/C #include <stdio.h> long long exgcd ( long long a , long long b , long long & x , long long & y ); int main () { long long a , b , c , ans , x , y ; while ( scanf ( \"%lld%lld%lld\" , & a , & b , & c ) != EOF ) { ans = exgcd ( a , b , x , y ); if ( c % ans == 0 ) { x =- x * c / ans ; y =- y * c / ans ; printf ( \"%lld %lld \\n \" , x , y ); } else printf ( \"-1 \\n \" ); } return 0 ; } long long exgcd ( long long a , long long b , long long & x , long long & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } long long r = exgcd ( b , a % b , x , y ), t ; t = x ; x = y ; y = t - ( a / b ) * y ; return r ; } \u4f46\u8fd9\u53ea\u662f\u6c42\u5f97\u4e86\u4e00\u7ec4\u89e3x1\uff0cy1 \u5bf9\u4e8ex,y\u5bf9\u5e94\u7684\u89e3\u96c6\u662f\uff1a x=x1+b/gcd(a, b)*t; y=y1-b/gcd(a, b)*t; \u8bc1\u660e\uff1a a*x+b*y=d,d=gcd(a,b). \u63a8\u5bfc\uff1aa*x1+b*y1=a*x2+b*y2 ---->a*(x1-x2)=b*(y2-y1) ---->a/d*(x1-x2)=b/d*(y2-y1) ---->a/d,b/d\u4e92\u8d28 ---->x1-x2=k*(b/d),y2-y1=k*(a/d) ----->x=x0+b/d*k,y=y0-a/d*k,k\u4e3a\u4efb\u610f\u6574\u6570\u3002 \u53c2\u8003\u4e8e\uff1a \u6b27\u51e0\u91cc\u5fb7\u548c\u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u8be6\u89e3 \u4ee5\u53ca\u4f8b\u9898CodeForces 7C \u62d3\u5c55GCD\uff0c\u5982\u4f55\u7531\u4e00\u7ec4\u89e3\u63a8\u51fa\u591a\u7ec4\u89e3\uff1f ----------------------------\u5206\u5272\u7ebf---------------------------------------------- http://icpc.upc.edu.cn/problem.php?cid=1437&pid=5 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u4e24\u53ea\u9752\u86d9\u5728\u7f51\u4e0a\u76f8\u8bc6\u4e86\uff0c\u5b83\u4eec\u804a\u5f97\u5f88\u5f00\u5fc3\uff0c\u4e8e\u662f\u89c9\u5f97\u5f88\u6709\u5fc5\u8981\u89c1\u4e00\u9762\u3002\u5b83\u4eec\u5f88\u9ad8\u5174\u5730\u53d1\u73b0\u5b83\u4eec\u4f4f\u5728\u540c\u4e00\u6761\u7eac\u5ea6\u7ebf\u4e0a\uff0c\u4e8e\u662f\u5b83\u4eec\u7ea6\u5b9a\u5404\u81ea\u671d\u897f\u8df3\uff0c\u76f4\u5230\u78b0\u9762\u4e3a\u6b62\u3002\u53ef\u662f\u5b83\u4eec\u51fa\u53d1\u4e4b\u524d\u5fd8\u8bb0\u4e86\u4e00\u4ef6\u5f88\u91cd\u8981\u7684\u4e8b\u60c5\uff0c\u65e2\u6ca1\u6709\u95ee\u6e05\u695a\u5bf9\u65b9\u7684\u7279\u5f81\uff0c\u4e5f\u6ca1\u6709\u7ea6\u5b9a\u89c1\u9762\u7684\u5177\u4f53\u4f4d\u7f6e\u3002\u4e0d\u8fc7\u9752\u86d9\u4eec\u90fd\u662f\u5f88\u4e50\u89c2\u7684\uff0c\u5b83\u4eec\u89c9\u5f97\u53ea\u8981\u4e00\u76f4\u671d\u7740\u67d0\u4e2a\u65b9\u5411\u8df3\u4e0b\u53bb\uff0c\u603b\u80fd\u78b0\u5230\u5bf9\u65b9\u7684\u3002\u4f46\u662f\u9664\u975e\u8fd9\u4e24\u53ea\u9752\u86d9\u5728\u540c\u4e00\u65f6\u95f4\u8df3\u5230\u540c\u4e00\u70b9\u4e0a\uff0c\u4e0d\u7136\u662f\u6c38\u8fdc\u90fd\u4e0d\u53ef\u80fd\u78b0\u9762\u7684\u3002\u4e3a\u4e86\u5e2e\u52a9\u8fd9\u4e24\u53ea\u4e50\u89c2\u7684\u9752\u86d9\uff0c\u4f60\u88ab\u8981\u6c42\u5199\u4e00\u4e2a\u7a0b\u5e8f\u6765\u5224\u65ad\u8fd9\u4e24\u53ea\u9752\u86d9\u662f\u5426\u80fd\u591f\u78b0\u9762\uff0c\u4f1a\u5728\u4ec0\u4e48\u65f6\u5019\u78b0\u9762\u3002 \u6211\u4eec\u628a\u8fd9\u4e24\u53ea\u9752\u86d9\u5206\u522b\u53eb\u505a\u9752\u86d9A\u548c\u9752\u86d9B\uff0c\u5e76\u4e14\u89c4\u5b9a\u7eac\u5ea6\u7ebf\u4e0a\u4e1c\u7ecf0\u5ea6\u5904\u4e3a\u539f\u70b9\uff0c\u7531\u4e1c\u5f80\u897f\u4e3a\u6b63\u65b9\u5411\uff0c\u5355\u4f4d\u957f\u5ea61\u7c73\uff0c\u8fd9\u6837\u6211\u4eec\u5c31\u5f97\u5230\u4e86\u4e00\u6761\u9996\u5c3e\u76f8\u63a5\u7684\u6570\u8f74\u3002\u8bbe\u9752\u86d9A\u7684\u51fa\u53d1\u70b9\u5750\u6807\u662fx\uff0c\u9752\u86d9B\u7684\u51fa\u53d1\u70b9\u5750\u6807\u662fy\u3002\u9752\u86d9A\u4e00\u6b21\u80fd\u8df3m\u7c73\uff0c\u9752\u86d9B\u4e00\u6b21\u80fd\u8df3n\u7c73\uff0c\u4e24\u53ea\u9752\u86d9\u8df3\u4e00\u6b21\u6240\u82b1\u8d39\u7684\u65f6\u95f4\u76f8\u540c\u3002\u7eac\u5ea6\u7ebf\u603b\u957fL\u7c73\u3002\u73b0\u5728\u8981\u4f60\u6c42\u51fa\u5b83\u4eec\u8df3\u4e86\u51e0\u6b21\u4ee5\u540e\u624d\u4f1a\u78b0\u9762\u3002 \u8f93\u5165 \u00b6 \u8f93\u5165\u53ea\u5305\u62ec\u4e00\u884c5\u4e2a\u6574\u6570x\uff0cy\uff0cm\uff0cn\uff0cL\uff0c\u5176\u4e2dx\u2260y < 2000000000\uff0c0 < m\u3001n < 2000000000\uff0c0 < L < 2100000000\u3002 \u8f93\u51fa \u00b6 \u8f93\u51fa\u78b0\u9762\u6240\u9700\u8981\u7684\u8df3\u8dc3\u6b21\u6570\uff0c\u5982\u679c\u6c38\u8fdc\u4e0d\u53ef\u80fd\u78b0\u9762\u5219\u8f93\u51fa\u4e00\u884c\"Impossible\" \u6837\u4f8b\u8f93\u5165 \u00b6 1 2 3 4 5 \u6837\u4f8b\u8f93\u51fa \u00b6 4 \u89e3\u6790 \u00b6 \u8bbe\u4e24\u53ea\u9752\u86d9\u8df3\u4e86t\u6b65\uff0cA\u7684\u5750\u6807\u4e3ax+mt,B\u7684\u5750\u6807\u4e3ay+nt\uff0c\u4ed6\u4eec\u76f8\u9047\u7684\u65f6\u5019\u6ee1\u8db3x+mt-(y+nt) = pL(p\u8868\u793a\u4e24\u9752\u86d9\u8d70\u8fc7\u7684\u8def\u7a0b\u76f8\u5deep\u5708) \u79fb\u9879\u540e\uff1a(n-m)t+Lp=x-y #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll N = 1e9 + 7 ; ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll d = exgcd ( b , a % b , x , y ); ll t = x ; x = y ; y = t - ( a / b ) * y ; return d ; } int main () { ll x , y , m , n , l ; cin >> x >> y >> m >> n >> l ; if ( m == n ) { cout << \"Impossible\" << endl ; return 0 ; } ll x1 = 0 , y1 = 0 , a = n - m , b = l , c = x - y ; ll d = exgcd ( a , b , x1 , y1 ); if ( c % d != 0 ) { cout << \"Impossible\" << endl ; return 0 ; } else { x1 = x1 * c / d ; x1 = ( x1 % ( b / d ) + ( b / d )) % ( b / d ); cout << x1 << endl ; } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2592&pid=2 \u9898\u76ee\u63cf\u8ff0 \u00b6 DIDIDI often takes a shower in school public bathroom. DIDIDI must take a shower in B days after the previous one, or he will die. For routine maintenance, bathroom closes one day per A days. But DIDIDI is lazy, he hopes he can take a shower as less as possible. So he wants to find a stable period for arranging dates of shower. For example, DIDIDI should take a shower every 3-day, and bathroom closes every Sunday. In order to minimize the shower times, in every two-week, DIDIDI can choose Monday, Thursday, Saturday (to avoid Sunday), Tuesday, Friday to take shower. In this case, he need to take a shower 2.5 times per week. Your assignment is to calculate how many times per A days DIDIDI need to take a shower. \u8f93\u5165 \u00b6 The first line of input contains a positive integer T telling you there are T test cases followed. Each test case will contain two integer, A, B. \u8f93\u51fa \u00b6 For each test case, print a line \u201cCase #x: y\u201d, where x is the case number (starting from 1) and y is times per A days of taking a shower. (if y is not a integer, please print fraction like \u201ca/b\u201d, gcd(a,b) = 1) \u6837\u4f8b\u8f93\u5165 \u00b6 2 7 3 7 4 \u6837\u4f8b\u8f93\u51fa \u00b6 Case #1: 5/2 Case #2: 2 \u63d0\u793a \u00b6 Tips:1\u2264T\u22642000,2\u2264A,B\u22641e8 Case 1: if bathroom closes in 7 th day every 7 days, he can take a shower in 1 st ,4 th , 6 th , 2 nd ,5 th ,1 st , 4 th , 6 th , 2 nd ,5 th \u2026\u2026 every period contains five shower times and two 7-day, so answer is 5/2. Csse 2: if bathroom closes in 7 th day every 7 days, he can take a shower in 3 rd ,6 th , 3 rd , 6 th \u2026\u2026every period contains two shower times and a 7-day, so answer is 2. \u89e3\u51b3 \u00b6 \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\uff1aa*x+b *y=gcd(a,b) \u5bf9\u4e8e\u8fd9\u4e2a\u9898\uff0cgcd==1\u7684\u65f6\u5019\u624d\u4f1a\u7528\u5230\u8fd9\u4e2a\u6765\u6c42x,y\u3002 \u4f46\u662f\u5f97\u51fa\u7684\u53ea\u6709\u5176\u4e2d\u4e00\u4e2a(x,y)\uff0c\u5176\u4e2d\u4e00\u4e2a\u4e3a\u8d1f\u6570\uff0c\u800c\u4e14\u9898\u76ee\u4e2d\u5fc5\u987b b*y - a*x == 1.\u516c\u5f0f\u5f97\u51fa\u6765\u7684\u53ef\u80fd\u662f -1. \u5f97\u4e0d\u51fa\u7b54\u6848\uff0c\u4e66\u4e2d\u5199\u5230\u6709\u591a\u7ec4\u89e3\uff0c\u89e3\u7b49\u4e8e x+ka' , y-kb' (a' = a / gcd(a,b) , b' = b / gcd(a,b) \uff0ck\u4e3a\u6574\u6570). \u4f46\u662f\uff0c \u53ea\u6709a>0\u624d\u4e0d\u7b26\u5408\u60c5\u51b5,a\u53ea\u80fd\u6bcf\u6b21\u51cfb\u3002 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll N = 1e9 + 7 ; ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ); } ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll d = exgcd ( b , a % b , x , y ); ll t = x ; x = y ; y = t - ( a / b ) * y ; return d ; } int main () { int t ; scanf ( \"%d\" , & t ); for ( int t1 = 1 ; t1 <= t ; t1 ++ ) { ll a , b ; scanf ( \"%lld%lld\" , & a , & b ); ll g = gcd ( a , b ); if ( g == 1 ) { ll x = 0 , y = 0 ; ll d = exgcd ( a , b , x , y ); if ( abs ( a * x ) - abs ( b * y ) < 0 ) { x = abs ( x ); y = abs ( y ); if ( x == 1 ) cout << \"Case #\" << t1 << \": \" << y << endl ; else cout << \"Case #\" << t1 << \": \" << y << \"/\" << x << endl ; } else { while ( abs ( a * x ) - abs ( b * y ) >= 0 ) { x = x - b / d ; y = y + a / d ; } x = abs ( x ); y = abs ( y ); if ( x == 1 ) cout << \"Case #\" << t1 << \": \" << y << endl ; else cout << \"Case #\" << t1 << \": \" << y << \"/\" << x << endl ; } } else { if ( b == g ) { cout << \"Case #\" << t1 << \": \" << a / g << endl ; } else { cout << \"Case #\" << t1 << \": \" << a / g << \"/\" << b / g << endl ; } } } return 0 ; }","title":"\u7b80\u4ecb\u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u5b9a\u7406"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_1","text":"\u5bf9\u4e8e\u6574\u6570a,b\u6765\u8bf4\uff0cgcd(a, b)==gcd(b, a%b)==d(a\u4e0eb\u7684\u6700\u5927\u516c\u7ea6\u6570)\uff0c\u53c8\u79f0\u4e3a\u8f97\u8f6c\u76f8\u9664\u6cd5 \u8bc1\u660e\uff1a \u56e0\u4e3aa\u662fd\u7684\u500d\u6570\uff0cb\u662fd\u7684\u500d\u6570\uff1b\u6240\u4ee5a%d=0\uff1b b%d=0\uff1b \u8bbek=a/b\uff1br=a%b\uff1b\u5219 a=k*b+r\uff1b \u7531\u4e0a\u5f97\u51fa\uff1ar=a-k*b\uff1b \u56e0\u4e3aa\u548cb\u90fd\u662fd\u7684\u500d\u6570\uff0c\u6240\u4ee5(a-k*b)\u4e5f\u662fd\u7684\u500d\u6570\uff0c\u6240\u4ee5r\u4e5f\u662fd\u7684\u500d\u6570\uff1b \u6240\u4ee5gcd(a, b)==gcd(b, a%b)==d \u800c\u4e3a\u4ec0\u4e48\u8981\u8bc1\u660egcd(a, b)==gcd(b, a%b)==d\u8fd9\u4e2a\u5f0f\u5b50\u6210\u7acb\u5462\uff1f \u5176\u5b9e\u8bc1\u660egcd(a, b)==gcd(a, a%b)==d\u8fd9\u4e2a\u5f0f\u5b50\u6210\u7acb\u4e5f\u662f\u53ef\u4ee5\u7684\uff0c\u56e0\u4e3aa\u4e5f\u662fd\u7684\u500d\u6570\uff0c\u4f46\u662f\u5728\u8fdb\u884c\u9012\u5f52\u4e4b\u524d\u8981\u8fdb\u884c\u4e00\u6b65\u64cd\u4f5c\uff0c\u5c31\u662f\u5224\u65ada\u4e0eb\u7684\u5927\u5c0f\uff0c\u5982\u679ca<b,\u5c31\u6ca1\u529e\u6cd5\u8fdb\u884c\u9012\u5f52\u6216\u8005\u5faa\u73af\u6c42\u6700\u5927\u516c\u7ea6\u6570\uff0c\u90a3\u4e48\u5982\u679ca b,\u90a3\u4e48a%b<a\u5fc5\u5b9a\u6210\u7acb\uff1b \u4e8b\u5b9e\u53d1\u73b0\u8bc1\u660egcd(a, b)==gcd(b, a%b)==d\u8fd9\u4e2a\u5f0f\u5b50\u4f1a\u7f29\u5c0f\u5904\u7406\u7684\u6570\u636e\u7684\u8303\u56f4\uff1b \u6b27\u51e0\u91cc\u5fb7\u5e94\u7528\uff1a \u7528\u6765\u6c42a\uff0cb\u7684\u6700\u5927\u516c\u7ea6\u6570\u3002 \u4ee3\u7801\u5b9e\u73b0\uff1a int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ); }","title":"\u6b27\u51e0\u91cc\u5fb7\u5b9a\u7406:"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_2","text":"\u5bf9\u4e8e\u4e0d\u5b8c\u5168\u4e3a0\u7684\u975e\u8d1f\u6574\u6570a\uff0cb;gcd(a, b)\u8868\u793aa, b\u7684\u6700\u5927\u516c\u7ea6\u6570\uff0c\u5fc5\u5b9a\u5b58\u5728\u6574\u6570\u5bf9x\uff0cy\uff0c\u6ee1\u8db3a*x+b*y==gcd(a, b); \u8bc1\u660e\uff1a a*x1+b*y1=gcd(a, b); b*x2+(a%b)*y2=gcd(b, a%b); \u56e0\u4e3a\u7531\u6b27\u51e0\u91cc\u5fb7\u5b9a\u7406\u77e5\uff1agcd(a, b)==gcd(b, a%b) \u6240\u4ee5a*x1+b*y1=b*x2+(a%b)*y2; \u3000\u3000\u56e0\u4e3ar=a%b, r =a-k*b\u6240\u4ee5==> a*x1+b*y1=b*x2+(a-k*b)*y2; \u3000\u3000\u56e0\u4e3ak=a/b;\u6240\u4ee5\u3000==> a*x1+b*y1=b*x2+(a-(a/b)*b)*y2; \u3000\u3000\u5c55\u5f00\u5f97\u5230\u3000\u3000==>\u3000\u3000\u3000\u3000 a*x1+b*y1=b*x2+a*y2-b*(a/b)*y2;\u3000\u3000\u8f6c\u6362\u5f97\u5230 ==> a*x1+b*y1=a*y2+b*(x2-(a/b)*y2); \u89c2\u5bdf\u4e0a\u5f0f\u53ef\u77e5 x1=y2, y1=x2-a/b*y2; \u7531\u6b64\u53ef\u77e5x1\uff0cy1\u662f\u7531x2\uff0cy2\u5f97\u51fa\u6765\u7684\uff0c\u7531\u6b64\u7c7b\u63a8x2\uff0cy2\u662f\u7531x3\uff0cy3\u5f97\u51fa\u6765\u7684\uff0c \u90a3\u4ec0\u4e48\u65f6\u5019\u662f\u7ec8\u6b62\u5462\uff1f\u4e5f\u5c31\u662f\u9012\u5f52gcd(a, b)\u4e2db=0\u65f6\uff1b\u4e5f\u5c31\u662f\u8bf4\u6b64\u65f6a\u7684\u503c\u5c31\u662f\u8981\u6c42\u5f97\u6700\u5927\u516c\u7ea6\u6570 \u5373gcd(a, 0)\u6b64\u65f6\u7531\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u5f8ba*x+b*y==gcd(a, b)\u77e5 a*x+b*y=a; \u89e3\u51fax=1, y=0; \u6b64\u65f6\u5c31\u662f\u9012\u5f52\u7ec8\u6b62\u7684\u5730\u65b9\uff1a \u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u5e94\u7528\uff1a \u5c31\u6211\u76ee\u524d\u6240\u77e5\u7684\u5c31\u662f\uff1a\u6c42\u89e3\u4e0d\u5b9a\u65b9\u7a0b\uff1b\u5982a*x+b*y=c; \u5df2\u77e5a, b, c\u7684\u503c\u6c42x\u548cy\u7684\u503c \u90a3\u4e48\u95ee\u9898\u6765\u4e86\uff0c\u5982\u4f55\u5c06\u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u5b9a\u5f8b\u5e94\u7528\u5728\u6c42\u89e3\u4e0d\u5b9a\u65b9\u7a0b\u5462\uff1f \u53ef\u4ee5\u8fd9\u6837\u8f6c\u5316 a*x+b*y=gcd(a, b)*c/gcd(a, b); \u6700\u540e\u8f6c\u5316\u4e3a a*x/(c/gcd(a, b))+b*y/(c/gcd(a, b))=gcd(a, b); \u6700\u540e\u6c42\u51fa\u7684\u89e3x0\uff0cy0\u4e58\u4e0ac/gcd(a, b)\u5c31\u662f\u6700\u7ec8\u7684\u7ed3\u679c\u4e86 x1=x0*c/gcd(a, b); y1=y0*c/gcd(a, b); \u4ee3\u7801\u5b9e\u73b0\uff1a \u4e3e\u4f8b\u8bf4\u660e\uff1a http://codeforces.com/problemset/problem/7/C #include <stdio.h> long long exgcd ( long long a , long long b , long long & x , long long & y ); int main () { long long a , b , c , ans , x , y ; while ( scanf ( \"%lld%lld%lld\" , & a , & b , & c ) != EOF ) { ans = exgcd ( a , b , x , y ); if ( c % ans == 0 ) { x =- x * c / ans ; y =- y * c / ans ; printf ( \"%lld %lld \\n \" , x , y ); } else printf ( \"-1 \\n \" ); } return 0 ; } long long exgcd ( long long a , long long b , long long & x , long long & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } long long r = exgcd ( b , a % b , x , y ), t ; t = x ; x = y ; y = t - ( a / b ) * y ; return r ; } \u4f46\u8fd9\u53ea\u662f\u6c42\u5f97\u4e86\u4e00\u7ec4\u89e3x1\uff0cy1 \u5bf9\u4e8ex,y\u5bf9\u5e94\u7684\u89e3\u96c6\u662f\uff1a x=x1+b/gcd(a, b)*t; y=y1-b/gcd(a, b)*t; \u8bc1\u660e\uff1a a*x+b*y=d,d=gcd(a,b). \u63a8\u5bfc\uff1aa*x1+b*y1=a*x2+b*y2 ---->a*(x1-x2)=b*(y2-y1) ---->a/d*(x1-x2)=b/d*(y2-y1) ---->a/d,b/d\u4e92\u8d28 ---->x1-x2=k*(b/d),y2-y1=k*(a/d) ----->x=x0+b/d*k,y=y0-a/d*k,k\u4e3a\u4efb\u610f\u6574\u6570\u3002 \u53c2\u8003\u4e8e\uff1a \u6b27\u51e0\u91cc\u5fb7\u548c\u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u8be6\u89e3 \u4ee5\u53ca\u4f8b\u9898CodeForces 7C \u62d3\u5c55GCD\uff0c\u5982\u4f55\u7531\u4e00\u7ec4\u89e3\u63a8\u51fa\u591a\u7ec4\u89e3\uff1f ----------------------------\u5206\u5272\u7ebf---------------------------------------------- http://icpc.upc.edu.cn/problem.php?cid=1437&pid=5","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u5b9a\u5f8b\uff1a"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_3","text":"\u4e24\u53ea\u9752\u86d9\u5728\u7f51\u4e0a\u76f8\u8bc6\u4e86\uff0c\u5b83\u4eec\u804a\u5f97\u5f88\u5f00\u5fc3\uff0c\u4e8e\u662f\u89c9\u5f97\u5f88\u6709\u5fc5\u8981\u89c1\u4e00\u9762\u3002\u5b83\u4eec\u5f88\u9ad8\u5174\u5730\u53d1\u73b0\u5b83\u4eec\u4f4f\u5728\u540c\u4e00\u6761\u7eac\u5ea6\u7ebf\u4e0a\uff0c\u4e8e\u662f\u5b83\u4eec\u7ea6\u5b9a\u5404\u81ea\u671d\u897f\u8df3\uff0c\u76f4\u5230\u78b0\u9762\u4e3a\u6b62\u3002\u53ef\u662f\u5b83\u4eec\u51fa\u53d1\u4e4b\u524d\u5fd8\u8bb0\u4e86\u4e00\u4ef6\u5f88\u91cd\u8981\u7684\u4e8b\u60c5\uff0c\u65e2\u6ca1\u6709\u95ee\u6e05\u695a\u5bf9\u65b9\u7684\u7279\u5f81\uff0c\u4e5f\u6ca1\u6709\u7ea6\u5b9a\u89c1\u9762\u7684\u5177\u4f53\u4f4d\u7f6e\u3002\u4e0d\u8fc7\u9752\u86d9\u4eec\u90fd\u662f\u5f88\u4e50\u89c2\u7684\uff0c\u5b83\u4eec\u89c9\u5f97\u53ea\u8981\u4e00\u76f4\u671d\u7740\u67d0\u4e2a\u65b9\u5411\u8df3\u4e0b\u53bb\uff0c\u603b\u80fd\u78b0\u5230\u5bf9\u65b9\u7684\u3002\u4f46\u662f\u9664\u975e\u8fd9\u4e24\u53ea\u9752\u86d9\u5728\u540c\u4e00\u65f6\u95f4\u8df3\u5230\u540c\u4e00\u70b9\u4e0a\uff0c\u4e0d\u7136\u662f\u6c38\u8fdc\u90fd\u4e0d\u53ef\u80fd\u78b0\u9762\u7684\u3002\u4e3a\u4e86\u5e2e\u52a9\u8fd9\u4e24\u53ea\u4e50\u89c2\u7684\u9752\u86d9\uff0c\u4f60\u88ab\u8981\u6c42\u5199\u4e00\u4e2a\u7a0b\u5e8f\u6765\u5224\u65ad\u8fd9\u4e24\u53ea\u9752\u86d9\u662f\u5426\u80fd\u591f\u78b0\u9762\uff0c\u4f1a\u5728\u4ec0\u4e48\u65f6\u5019\u78b0\u9762\u3002 \u6211\u4eec\u628a\u8fd9\u4e24\u53ea\u9752\u86d9\u5206\u522b\u53eb\u505a\u9752\u86d9A\u548c\u9752\u86d9B\uff0c\u5e76\u4e14\u89c4\u5b9a\u7eac\u5ea6\u7ebf\u4e0a\u4e1c\u7ecf0\u5ea6\u5904\u4e3a\u539f\u70b9\uff0c\u7531\u4e1c\u5f80\u897f\u4e3a\u6b63\u65b9\u5411\uff0c\u5355\u4f4d\u957f\u5ea61\u7c73\uff0c\u8fd9\u6837\u6211\u4eec\u5c31\u5f97\u5230\u4e86\u4e00\u6761\u9996\u5c3e\u76f8\u63a5\u7684\u6570\u8f74\u3002\u8bbe\u9752\u86d9A\u7684\u51fa\u53d1\u70b9\u5750\u6807\u662fx\uff0c\u9752\u86d9B\u7684\u51fa\u53d1\u70b9\u5750\u6807\u662fy\u3002\u9752\u86d9A\u4e00\u6b21\u80fd\u8df3m\u7c73\uff0c\u9752\u86d9B\u4e00\u6b21\u80fd\u8df3n\u7c73\uff0c\u4e24\u53ea\u9752\u86d9\u8df3\u4e00\u6b21\u6240\u82b1\u8d39\u7684\u65f6\u95f4\u76f8\u540c\u3002\u7eac\u5ea6\u7ebf\u603b\u957fL\u7c73\u3002\u73b0\u5728\u8981\u4f60\u6c42\u51fa\u5b83\u4eec\u8df3\u4e86\u51e0\u6b21\u4ee5\u540e\u624d\u4f1a\u78b0\u9762\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_4","text":"\u8f93\u5165\u53ea\u5305\u62ec\u4e00\u884c5\u4e2a\u6574\u6570x\uff0cy\uff0cm\uff0cn\uff0cL\uff0c\u5176\u4e2dx\u2260y < 2000000000\uff0c0 < m\u3001n < 2000000000\uff0c0 < L < 2100000000\u3002","title":"\u8f93\u5165"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_5","text":"\u8f93\u51fa\u78b0\u9762\u6240\u9700\u8981\u7684\u8df3\u8dc3\u6b21\u6570\uff0c\u5982\u679c\u6c38\u8fdc\u4e0d\u53ef\u80fd\u78b0\u9762\u5219\u8f93\u51fa\u4e00\u884c\"Impossible\"","title":"\u8f93\u51fa"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_6","text":"1 2 3 4 5","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_7","text":"4","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_8","text":"\u8bbe\u4e24\u53ea\u9752\u86d9\u8df3\u4e86t\u6b65\uff0cA\u7684\u5750\u6807\u4e3ax+mt,B\u7684\u5750\u6807\u4e3ay+nt\uff0c\u4ed6\u4eec\u76f8\u9047\u7684\u65f6\u5019\u6ee1\u8db3x+mt-(y+nt) = pL(p\u8868\u793a\u4e24\u9752\u86d9\u8d70\u8fc7\u7684\u8def\u7a0b\u76f8\u5deep\u5708) \u79fb\u9879\u540e\uff1a(n-m)t+Lp=x-y #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll N = 1e9 + 7 ; ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll d = exgcd ( b , a % b , x , y ); ll t = x ; x = y ; y = t - ( a / b ) * y ; return d ; } int main () { ll x , y , m , n , l ; cin >> x >> y >> m >> n >> l ; if ( m == n ) { cout << \"Impossible\" << endl ; return 0 ; } ll x1 = 0 , y1 = 0 , a = n - m , b = l , c = x - y ; ll d = exgcd ( a , b , x1 , y1 ); if ( c % d != 0 ) { cout << \"Impossible\" << endl ; return 0 ; } else { x1 = x1 * c / d ; x1 = ( x1 % ( b / d ) + ( b / d )) % ( b / d ); cout << x1 << endl ; } return 0 ; } http://icpc.upc.edu.cn/problem.php?cid=2592&pid=2","title":"\u89e3\u6790"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_9","text":"DIDIDI often takes a shower in school public bathroom. DIDIDI must take a shower in B days after the previous one, or he will die. For routine maintenance, bathroom closes one day per A days. But DIDIDI is lazy, he hopes he can take a shower as less as possible. So he wants to find a stable period for arranging dates of shower. For example, DIDIDI should take a shower every 3-day, and bathroom closes every Sunday. In order to minimize the shower times, in every two-week, DIDIDI can choose Monday, Thursday, Saturday (to avoid Sunday), Tuesday, Friday to take shower. In this case, he need to take a shower 2.5 times per week. Your assignment is to calculate how many times per A days DIDIDI need to take a shower.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_10","text":"The first line of input contains a positive integer T telling you there are T test cases followed. Each test case will contain two integer, A, B.","title":"\u8f93\u5165"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_11","text":"For each test case, print a line \u201cCase #x: y\u201d, where x is the case number (starting from 1) and y is times per A days of taking a shower. (if y is not a integer, please print fraction like \u201ca/b\u201d, gcd(a,b) = 1)","title":"\u8f93\u51fa"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_12","text":"2 7 3 7 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_13","text":"Case #1: 5/2 Case #2: 2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_14","text":"Tips:1\u2264T\u22642000,2\u2264A,B\u22641e8 Case 1: if bathroom closes in 7 th day every 7 days, he can take a shower in 1 st ,4 th , 6 th , 2 nd ,5 th ,1 st , 4 th , 6 th , 2 nd ,5 th \u2026\u2026 every period contains five shower times and two 7-day, so answer is 5/2. Csse 2: if bathroom closes in 7 th day every 7 days, he can take a shower in 3 rd ,6 th , 3 rd , 6 th \u2026\u2026every period contains two shower times and a 7-day, so answer is 2.","title":"\u63d0\u793a"},{"location":"csdn/%E7%AE%80%E4%BB%8B%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86/#_15","text":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\uff1aa*x+b *y=gcd(a,b) \u5bf9\u4e8e\u8fd9\u4e2a\u9898\uff0cgcd==1\u7684\u65f6\u5019\u624d\u4f1a\u7528\u5230\u8fd9\u4e2a\u6765\u6c42x,y\u3002 \u4f46\u662f\u5f97\u51fa\u7684\u53ea\u6709\u5176\u4e2d\u4e00\u4e2a(x,y)\uff0c\u5176\u4e2d\u4e00\u4e2a\u4e3a\u8d1f\u6570\uff0c\u800c\u4e14\u9898\u76ee\u4e2d\u5fc5\u987b b*y - a*x == 1.\u516c\u5f0f\u5f97\u51fa\u6765\u7684\u53ef\u80fd\u662f -1. \u5f97\u4e0d\u51fa\u7b54\u6848\uff0c\u4e66\u4e2d\u5199\u5230\u6709\u591a\u7ec4\u89e3\uff0c\u89e3\u7b49\u4e8e x+ka' , y-kb' (a' = a / gcd(a,b) , b' = b / gcd(a,b) \uff0ck\u4e3a\u6574\u6570). \u4f46\u662f\uff0c \u53ea\u6709a>0\u624d\u4e0d\u7b26\u5408\u60c5\u51b5,a\u53ea\u80fd\u6bcf\u6b21\u51cfb\u3002 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll N = 1e9 + 7 ; ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ); } ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll d = exgcd ( b , a % b , x , y ); ll t = x ; x = y ; y = t - ( a / b ) * y ; return d ; } int main () { int t ; scanf ( \"%d\" , & t ); for ( int t1 = 1 ; t1 <= t ; t1 ++ ) { ll a , b ; scanf ( \"%lld%lld\" , & a , & b ); ll g = gcd ( a , b ); if ( g == 1 ) { ll x = 0 , y = 0 ; ll d = exgcd ( a , b , x , y ); if ( abs ( a * x ) - abs ( b * y ) < 0 ) { x = abs ( x ); y = abs ( y ); if ( x == 1 ) cout << \"Case #\" << t1 << \": \" << y << endl ; else cout << \"Case #\" << t1 << \": \" << y << \"/\" << x << endl ; } else { while ( abs ( a * x ) - abs ( b * y ) >= 0 ) { x = x - b / d ; y = y + a / d ; } x = abs ( x ); y = abs ( y ); if ( x == 1 ) cout << \"Case #\" << t1 << \": \" << y << endl ; else cout << \"Case #\" << t1 << \": \" << y << \"/\" << x << endl ; } } else { if ( b == g ) { cout << \"Case #\" << t1 << \": \" << a / g << endl ; } else { cout << \"Case #\" << t1 << \": \" << a / g << \"/\" << b / g << endl ; } } } return 0 ; }","title":"\u89e3\u51b3"},{"location":"csdn/%E9%93%BE%E8%A1%A8/","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef unsigned long long ull ; const int maxn = 1e5 + 5 ; class List ; //\u524d\u89c6\u5b9a\u4e49,\u5426\u5219\u53cb\u5143\u65e0\u6cd5\u5b9a\u4e49 class LinkNode { friend List ; //\u94fe\u8868\u7ed3\u70b9\u7c7b\u7684\u5b9a\u4e49 private : LinkNode * link ; int data ; public : LinkNode ( const int & item , LinkNode * ptr = NULL ) { data = item ; link = ptr ; } LinkNode ( LinkNode * ptr = NULL ) { link = ptr ; } ~ LinkNode () { }; }; class List { //\u5355\u94fe\u8868\u7c7b\u7684\u5b9a\u4e49 private : LinkNode * first ; //\u6307\u5411\u9996\u7ed3\u70b9\u7684\u6307\u9488 public : List () { first = new LinkNode (); } ~ List () { MakeEmpty (); //\u6790\u6784\u51fd\u6570 } void MakeEmpty ( ); //\u94fe\u8868\u7f6e\u7a7a int Remove ( int i ); //\u9700\u8981\u8865\u5145\u7684\u6210\u5458\u51fd\u6570 void input ( int endTag ); void output (); //\u9700\u8981\u8865\u5145\u7684\u6210\u5458\u51fd\u6570 }; void List :: MakeEmpty ( ) { LinkNode * q ; while ( first -> link != NULL ) { q = first -> link ; first -> link = q -> link ; delete q ; } }; void List :: input ( int endTag ) { LinkNode * newnode , * last ; last = new LinkNode ( 0 ); first -> data = 0 ; int val ; cin >> val ; while ( val != endTag ) { newnode = new LinkNode ( val ); last -> link = newnode ; last = newnode ; if ( first -> data == 0 ) { first -> data = -1 ; first -> link = newnode ; } cin >> val ; } } int List :: Remove ( int index ) { cout << \"remove\" << endl ; //cout<<first->link<<endl; //if(first==NULL) //return 0; LinkNode * q = first , * last ; int cnt = 0 ; while ( q -> link != NULL && cnt < index ) { last = q ; q = q -> link ; cnt = cnt + 1 ; } if ( q -> link == NULL && cnt != index ) { cout << \"Error!!!\" << endl ; return -1 ; } last -> link = q -> link ; return 0 ; } void List :: output () { //cout<<first->link<<endl; LinkNode * q = first , * last ; //cout<<\"\u7b54\u6848\u662f\"<<endl; // cout<<first->data<<\" \"; while ( q -> link != NULL ) { q = q -> link ; cout << q -> data << \" \" ; } cout << endl ; } int main () { List l ; l . input ( 0 ); //0\u4e3a\u8f93\u5165\u7684\u7ed3\u675f\u6570\u5b57 l . output (); int index ; cin >> index ; //\u8981\u5220\u9664\u7684\u5143\u7d20\u7684\u4e0b\u6807\uff0c\u4e0b\u6807\u4ece0 \u5f00\u59cb l . Remove ( index ); l . output (); //\u5220\u9664\u540e\u8f93\u51fa l . MakeEmpty (); return 0 ; }","title":"\u94fe\u8868"},{"location":"icpc/","text":"ICPC\u6a21\u677f\u5e93","title":"Index"},{"location":"icpc/_coverpage/","text":"Tim-wcx \u00b6 \u4e2a\u4eba\u6587\u6863\u7f51\u7ad9 \u00b6 GitHub Get Started","title":"Tim-wcx"},{"location":"icpc/_coverpage/#tim-wcx","text":"","title":"Tim-wcx"},{"location":"icpc/_coverpage/#_1","text":"GitHub Get Started","title":"\u4e2a\u4eba\u6587\u6863\u7f51\u7ad9"},{"location":"icpc/_sidebar/","text":"\u4e0a\u4e00\u7ea7 ICPC\u6a21\u677f \u4e2a\u4eba\u6a21\u677f kuangbin\u6a21\u677f","title":" sidebar"},{"location":"icpc/kuangbin%E6%A8%A1%E6%9D%BF/","text":"This browser does not support PDFs. Please download the PDF to view it: Download PDF","title":"kuangbin\u6a21\u677f"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/","text":"\u6742\u9879 \u00b6 \u5feb\u8bfb&O2\u4f18\u5316 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #define inf1 0x3f3f3f3f #define inf2 0x3f3f3f3f3f3f3f3f const double Pi = acos ( -1 ); std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( 0 ); cout << fixed << setprecision ( 20 ) << ans << endl ; read\u51fd\u6570\u5feb\u8bfb \u00b6 inline int read () { int z = 0 , flag = 1 ; char ch = getchar (); while ( ch < '0' || ch > '9' ) { if ( ch == '-' ) flag = -1 ; ch = getchar (); } while ( ch >= '0' && ch <= '9' ) { z = z * 10 + ch - '0' ; ch = getchar (); } return z * flag ; } \u51fd\u6570\u5f0f__int128 \u8f93\u5165\u548c\u8f93\u51fa \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; __int128 int128read () { __int128 x = 0 ; int flag = 1 ; string a ; cin >> a ; for ( char c : a ) { if ( c == '-' ) flag = -1 ; else x = x * 10 + c - '0' ; } return flag * x ; } void int128print ( __int128 x ) { if ( x < 0 ) { putchar ( '-' ); x =- x ; } if ( x > 9 ) int128print ( x / 10 ); putchar ( x % 10 + '0' ); } int main () { __int128 a = int128read (), b = int128read (); int128print ( a + b ); } \u91cd\u8f7d\u5f0f __int128 \u8f93\u5165\u548c\u8f93\u51fa \u00b6 #include <bits/stdc++.h> using namespace std ; istream & operator >> ( istream & in , __int128 & x ) { x = 0 ; int flag = 1 ; string a ; in >> a ; for ( char c : a ) { if ( c == '-' ) flag = -1 ; else x = x * 10 + c - '0' ; } x = flag * x ; return in ; } ostream & operator << ( ostream & out , __int128 & x ) { if ( x < 0 ) { out << '-' ; x = - x ; } stack < int > s ; while ( x ) { s . push ( x % 10 ); x /= 10 ; } while ( ! s . empty ()) { out << s . top (); s . pop (); } return out ; } int main () { __int128 a , b ; cin >> a >> b ; cout << a << ' ' << b << endl ; return 0 ; } java ACM \u57fa\u7840 \u00b6 import java.io.* ; import java.math.* ; import java.util.* ; public class Main { public static void main ( String args [] ) { //BigDecimal\u5927\u6570Double\u7c7b //\u8bfb\u5165 Scanner cin = new Scanner ( new BufferedInputStream ( System . in )); int a ; double b ; BigInteger c ; String d ; a = cin . nextInt (); b = cin . nextDouble (); c = cin . nextBigInteger (); d = cin . nextLine (); // \u6bcf\u79cd\u7c7b\u578b\u90fd\u6709\u76f8\u5e94\u7684\u8f93\u5165\u51fd\u6570. System . out . printf ( \"\u8f93\u5165\u7684\u4e3a%d %f %s %s\\n\" , a , b , c . toString (), d ); c = cin . nextBigInteger ( 2 ); //\u5927\u6570\u4ee52\u8fdb\u5236\u8bfb\u5165 String tmp = c . toString ( 2 ); ///\u5c06\u5927\u6570\u4ee5\u4e8c\u8fdb\u5236\u5f62\u5f0f\u8f93\u51fa System . out . print ( 1 ); // cout << \u2026; System . out . println ( 1 ); // cout << \u2026 << endl; System . out . printf ( \"%d\" , 1 ); // \u4e0eC\u4e2d\u7684printf\u7528\u6cd5\u7c7b\u4f3c. ///\u5b57\u7b26\u4e32\u5904\u7406 String st = \"abcdefg\" ; System . out . println ( st . charAt ( 0 )); // st.charAt(i)\u5c31\u76f8\u5f53\u4e8est[i]. char [] ch ; ch = st . toCharArray (); // \u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u5b57\u7b26\u6570\u7ec4. for ( int i = 0 ; i < ch . length ; i ++ ) ch [ i ] += 1 ; System . out . println ( ch ); // \u8f93\u5165\u4e3a\u201cbcdefgh\u201d. if ( st . startsWith ( \"a\" )) // \u5982\u679c\u5b57\u7b26\u4e32\u4ee5'0'\u5f00\u5934. st = st . substring ( 1 ); // \u5219\u4ece\u7b2c1\u4f4d\u5f00\u59cbcopy(\u5f00\u5934\u4e3a\u7b2c0\u4f4d). ///\u8fdb\u5236\u8f6c\u5316 int num = 15 , base = 2 ; System . out . printf ( \"15\u8f6c2\u8fdb\u5236\u4e3a%s\\n\" , Integer . toString ( num , base )); st = \"1111\" ; System . out . printf ( \"2\u8fdb\u5236\u76841111\u8f6c10\u8fdb\u5236\u4e3a%d\\n\" , Integer . parseInt ( st , base )); // \u628ast\u5f53\u505abase\u8fdb\u5236\uff0c\u8f6c\u621010\u8fdb\u5236\u7684int(parseInt\u6709\u4e24\u4e2a\u53c2\u6570,\u7b2c\u4e00\u4e2a\u4e3a\u8981\u8f6c\u7684\u5b57\u7b26\u4e32,\u7b2c\u4e8c\u4e2a\u4e3a\u8fdb\u5236). BigInteger m = new BigInteger ( st , base ); // st\u662f\u5b57\u7b26\u4e32\uff0cbase\u662fst\u7684\u8fdb\u5236. ///\u6392\u5e8f int n = cin . nextInt (); Integer [] arr = new Integer [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ]= cin . nextInt (); Arrays . sort ( arr , new Comparator < Integer > () { @Override public int compare ( Integer o1 , Integer o2 ) { return o2 - o1 ; ///\u4ece\u5927\u5230\u5c0f\u6392\u5e8f } }); for ( int i = 0 ; i < n ; i ++ ) System . out . printf ( \"%d \" , arr [ i ] ); System . out . println (); ///\u6e05\u7a7a Arrays . fill ( arr , 5 ); for ( int i = 0 ; i < n ; i ++ ) System . out . printf ( \"%d \" , arr [ i ] ); System . out . println (); ///\u4e8c\u5206\u67e5\u627e System . out . println ( Arrays . binarySearch ( arr , 5 )); ///\u5982\u679ckey\u5728\u6570\u7ec4\u4e2d\uff0c\u5219\u8fd4\u56de\u641c\u7d22\u503c\u7684\u7d22\u5f15\uff1b\u5426\u5219\u8fd4\u56de-1\u6216\u8005\u201d-\u201c(\u63d2\u5165\u70b9)\u3002 ///\u63d2\u5165\u70b9\u662f\u7d22\u5f15\u952e\u5c06\u8981\u63d2\u5165\u6570\u7ec4\u7684\u90a3\u4e00\u70b9\uff0c\u5373\u7b2c\u4e00\u4e2a\u5927\u4e8e\u8be5\u952e\u7684\u5143\u7d20\u7d22\u5f15\u3002 } } java BigInteger \u8fd0\u7b97 \u00b6 import java.io.* ; import java.math.* ; import java.util.* ; public class Main { public static void main ( String args [] ) { Scanner cin = new Scanner ( System . in ); while ( cin . hasNext ()) ///\u76f8\u5f53\u4e8e scanf()!=EOF { BigInteger a , b , c ; //\u5927\u6570\u521d\u59cb\u5316 //1.\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32 BigInteger interNum1 = new BigInteger ( \"1011100111\" , 2 ); //2.\u5341\u8fdb\u5236\u5b57\u7b26\u4e32 BigInteger interNum2 = new BigInteger ( \"123456\" ); //3.\u5341\u8fdb\u5236\u6570\u5b57 BigInteger interNum3 = BigInteger . valueOf ( 8 ); //\u5927\u6570\u8bfb\u5165 a = cin . nextBigInteger (); b = cin . nextBigInteger (); //\u57fa\u672c\u8fd0\u7b97 //1.\u628aa\u4e0eb\u76f8\u52a0\u5e76\u8d4b\u7ed9c c = a . add ( b ); //2.\u628aa\u4e0eb\u76f8\u51cf\u5e76\u8d4b\u7ed9c c = a . subtract ( b ); //3.\u628aa\u4e0eb\u76f8\u4e58\u5e76\u8d4b\u7ed9c c = a . multiply ( b ); //4.\u628aa\u4e0eb\u76f8\u9664\u5e76\u8d4b\u7ed9c c = a . divide ( b ); //5.\u53d6\u6a21\uff0c(\u9700 b > 0\uff0c\u5426\u5219\u51fa\u73b0\u5f02\u5e38\uff1aArithmeticException(\"BigInteger: modulus not positive\")) c = a . mod ( b ); //6.\u6c42\u4f59 c = a . remainder ( b ); //7.\u76f8\u5f53\u4e8ea^b c = a . pow ( 2 ); //8.\u6839\u636e\u8be5\u6570\u503c\u662f\u5c0f\u4e8e\u3001\u7b49\u4e8e\u3001\u6216\u5927\u4e8ea \u8fd4\u56de -1\u30010 \u6216 1 int ans1 = a . compareTo ( b ); //9.\u5224\u65ad\u4e24\u6570\u662f\u5426\u76f8\u7b49\uff0c\u4e5f\u53ef\u4ee5\u7528compareTo\u6765\u4ee3\u66ff boolean ans2 = a . equals ( b ); //10.\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c c = a . min ( b ); c = a . max ( b ); //\u7c7b\u578b\u8f6c\u6362 //1.\u8f6c\u6362\u4e3abigNum\u7684\u4e8c\u8fdb\u5236\u8865\u7801\u5f62\u5f0f byte [] num1 = a . toByteArray (); //2.\u8f6c\u6362\u4e3abigNum\u7684\u5341\u8fdb\u5236\u5b57\u7b26\u4e32\u5f62\u5f0f String num2 = a . toString (); //3.\u8f6c\u6362\u4e3abigNum\u7684radix\u8fdb\u5236\u5b57\u7b26\u4e32\u5f62\u5f0f String num3 = a . toString ( 2 ); //4.\u5c06bigNum\u8f6c\u6362\u4e3aint int num4 = a . intValue (); //5.\u5c06bigNum\u8f6c\u6362\u4e3along long num5 = a . longValue (); //6.\u5c06bigNum\u8f6c\u6362\u4e3afloat float num6 = a . floatValue (); //7.\u5c06bigNum\u8f6c\u6362\u4e3adouble double num7 = a . doubleValue (); //\u4e8c\u8fdb\u5236\u8fd0\u7b97 //1.\u4e0e\uff1aa&b BigInteger bigNum1 = a . and ( b ); //2.\u6216\uff1aa|b BigInteger bigNum2 = a . or ( b ); //3.\u5f02\u6216\uff1aa^b BigInteger bigNum3 = a . xor ( b ); //4.\u53d6\u53cd\uff1a~a BigInteger bigNum4 = a . not (); //5.\u5de6\u79fbn\u4f4d\uff1a (a << n) BigInteger bigNum5 = a . shiftLeft ( 3 ); //6.\u53f3\u79fbn\u4f4d\uff1a (a >> n) BigInteger bigNum6 = a . shiftRight ( 3 ); } } } java BigDecimal \u8fd0\u7b97 \u00b6 import java.io.* ; import java.math.* ; import java.util.* ; public class Main { public static void main ( String args [] ) { Scanner cin = new Scanner ( System . in ); while ( cin . hasNext ()) ///\u76f8\u5f53\u4e8e scanf()!=EOF { BigDecimal a , b , c ; //\u5927\u6570\u521d\u59cb\u5316 //1.\u5341\u8fdb\u5236\u5b57\u7b26\u4e32 BigDecimal interNum1 = new BigDecimal ( \"0.005\" ); //2.\u5341\u8fdb\u5236\u6570\u5b57 BigDecimal interNum2 = new BigDecimal ( 0.000005 ); BigDecimal interNum3 = BigDecimal . valueOf ( 0.000005 ); //\u5927\u6570\u8bfb\u5165 a = cin . nextBigDecimal (); b = cin . nextBigDecimal (); //\u5927\u6570\u4fdd\u7559\u5c0f\u6570\u4f4d\u8f93\u51fa BigDecimal d = a . setScale ( 10 , RoundingMode . HALF_UP ); //\u4fdd\u7559\u5341\u4f4d\u5c0f\u6570 System . out . println ( d ); //\u57fa\u672c\u8fd0\u7b97 //1.\u628aa\u4e0eb\u76f8\u52a0\u5e76\u8d4b\u7ed9c c = a . add ( b ); //2.\u628aa\u4e0eb\u76f8\u51cf\u5e76\u8d4b\u7ed9c c = a . subtract ( b ); //3.\u628aa\u4e0eb\u76f8\u4e58\u5e76\u8d4b\u7ed9c c = a . multiply ( b ); //4.\u628aa\u4e0eb\u76f8\u9664\u5e76\u8d4b\u7ed9c c = a . divide ( b , 10 , BigDecimal . ROUND_UP ); //\u820d\u5165\u8fdc\u79bb\u96f6\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_DOWN ); //\u63a5\u8fd1\u96f6\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_CEILING ); //\u63a5\u8fd1\u6b63\u65e0\u7a77\u5927\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_FLOOR ); //\u63a5\u8fd1\u8d1f\u65e0\u7a77\u5927\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_HALF_UP ); //\u5411\u201c\u6700\u63a5\u8fd1\u7684\u201d\u6570\u5b57\u820d\u5165\uff0c\u5982\u679c\u4e0e\u4e24\u4e2a\u76f8\u90bb\u6570\u5b57\u7684\u8ddd\u79bb\u76f8\u7b49\uff0c\u5219\u4e3a\u5411\u4e0a\u820d\u5165\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_HALF_DOWN ); //\u5411\u201c\u6700\u63a5\u8fd1\u7684\u201d\u6570\u5b57\u820d\u5165\uff0c\u5982\u679c\u4e0e\u4e24\u4e2a\u76f8\u90bb\u6570\u5b57\u7684\u8ddd\u79bb\u76f8\u7b49\uff0c\u5219\u4e3a\u4e0a\u820d\u5165\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_HALF_EVEN ); //\u5411\u201c\u6700\u63a5\u8fd1\u7684\u201d\u6570\u5b57\u820d\u5165\uff0c\u5982\u679c\u4e0e\u4e24\u4e2a\u76f8\u90bb\u6570\u5b57\u7684\u8ddd\u79bb\u76f8\u7b49\uff0c\u5219\u5411\u76f8\u90bb\u7684\u5076\u6570\u820d\u5165\u3002 //5.\u6c42\u4f59 c = a . remainder ( b ); //6.\u76f8\u5f53\u4e8ea^b c = a . pow ( 2 ); //7.\u6839\u636e\u8be5\u6570\u503c\u662f\u5c0f\u4e8e\u3001\u7b49\u4e8e\u3001\u6216\u5927\u4e8ea \u8fd4\u56de -1\u30010 \u6216 1 int ans1 = a . compareTo ( b ); //8.\u5224\u65ad\u4e24\u6570\u662f\u5426\u76f8\u7b49\uff0c\u4e5f\u53ef\u4ee5\u7528compareTo\u6765\u4ee3\u66ff boolean ans2 = a . equals ( b ); //9.\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c c = a . min ( b ); c = a . max ( b ); //10.\u7edd\u5bf9\u503c c = a . abs (); //\u7c7b\u578b\u8f6c\u6362 //1.\u8f6c\u6362\u4e3abigNum\u7684\u5341\u8fdb\u5236\u5b57\u7b26\u4e32\u5f62\u5f0f String num2 = a . toString (); //2.\u5c06bigNum\u8f6c\u6362\u4e3aint int num4 = a . intValue (); //3.\u5c06bigNum\u8f6c\u6362\u4e3along long num5 = a . longValue (); //4.\u5c06bigNum\u8f6c\u6362\u4e3afloat float num6 = a . floatValue (); //5.\u5c06bigNum\u8f6c\u6362\u4e3adouble double num7 = a . doubleValue (); } } } \u5224\u65ad\u5468\u51e0 \u00b6 int getWeek ( int y , int m , int d ) { if ( m == 1 || m == 2 ) { m += 12 ; y -- ; } int week = ( d + 1 + 2 * m + 3 * ( m + 1 ) / 5 + y + y / 4 - y / 100 + y / 400 ) % 7 ; return week ; } \u7ec4\u5408\u6570\u5947\u5076\u5224\u65ad \u00b6 \u56fe\u8bba \u00b6 \u5806\u4f18\u5316prim\u7b97\u6cd5 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; struct node { int to , val ; }; vector < node > v [ 100500 ]; struct node1 { int now , val ; bool operator < ( const node1 & a ) const { return a . val < val ; } }; priority_queue < node1 > que ; int dis [ 100500 ] = { 0 }; void prim () { memset ( dis , -1 , sizeof ( dis )); que . push ({ 1 , 0 }); while ( ! que . empty ()) { node1 now = que . top (); que . pop (); if ( dis [ now . now ] != -1 ) continue ; dis [ now . now ] = now . val ; for ( int i = 0 ; i < v [ now . now ]. size (); i ++ ) { int to = v [ now . now ][ i ]. to ; int val = v [ now . now ][ i ]. val ; if ( dis [ to ] != -1 ) continue ; que . push ({ to , val }); } } } int main () { int n , m , from , to , val ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d%d\" , & from , & to , & val ); v [ from ]. push_back ({ to , val }); v [ to ]. push_back ({ from , val }); } prim (); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { if ( dis [ i ] == -1 ) return 0 * puts ( \"orz\" ); ///\u4e0d\u8fde\u901a ans += dis [ i ]; } cout << ans << endl ; } ```` #### SPFA\u5224\u65ad\u8d1f\u73af ``` c ++ #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <queue> #include <algorithm> #define INF 0x3f3f3f3f using namespace std ; const int MAXN = 5500 ; int n , m , w ; struct Edge { int v , w , next ; } edge [ MAXN ]; int head [ MAXN ], dis [ MAXN ], vis [ MAXN ], t ; void Init () { memset ( head , -1 , sizeof ( head )); t = 0 ; } void Add_edge ( int u , int v , int w ) { edge [ t ]. v = v ; edge [ t ]. w = w ; edge [ t ]. next = head [ u ]; head [ u ] = t ++ ; } bool SPFA () { int mark [ MAXN ]; //\u8bb0\u5f55\u6bcf\u4e2a\u70b9\u5982\u961f\u5217\u7684\u6b21\u6570 for ( int i = 1 ; i <= n ; i ++ ) { mark [ i ] = 0 ; dis [ i ] = INF ; vis [ i ] = 0 ; } queue < int > q ; q . push ( 1 ); //\u6211\u4eec\u53ea\u9700\u8981\u5224\u65ad\u8d1f\u73af\uff0c\u968f\u4fbf\u627e\u4e00\u4e2a\u8d77\u70b9\u5c31\u597d dis [ 1 ] = 0 ; vis [ 1 ] = 1 ; //\u5165\u961f\u5217 mark [ 1 ] ++ ; while ( ! q . empty ()) { int u = q . front (); q . pop (); vis [ u ] = 0 ; //\u51fa\u961f\u5217 for ( int i = head [ u ]; i != -1 ; i = edge [ i ]. next ) { int v = edge [ i ]. v ; if ( dis [ v ] > dis [ u ] + edge [ i ]. w ) { dis [ v ] = dis [ u ] + edge [ i ]. w ; if ( ! vis [ v ]) //\u4e0d\u5728\u961f\u5217\u4e2d\u7684\u65f6\u5019\u51fa\u961f { q . push ( v ); mark [ v ] ++ ; vis [ v ] = 1 ; } if ( mark [ v ] >= n ) //\u5982\u679c\u4e0d\u5b58\u5728\u8d1f\u73af\uff0c\u90a3\u4e48\u6700\u591a\u66f4\u65b0n-1\u6b21\u5c31\u53ef\u4ee5\u5f97\u5230\u6700\u7ec8\u7684\u7b54\u6848\uff0c\u56e0\u4e3a\u4e00\u6b21\u6700\u5c11\u66f4\u65b0\u4e00\u4e2a\u8282\u70b9\uff0c\u90a3\u4e48\u5982\u679c\u51fa\u73b0\u4e86\u66f4\u65b0n\u6b21\uff0c\u90a3\u4e48\u5c31\u4e00\u5b9a\u51fa\u73b0\u4e86\u8d1f\u73af return false ; } } } return true ; } int main () { int T ; scanf ( \"%d\" , & T ); while ( T -- ) { Init (); int u , v , z ; scanf ( \"%d%d%d\" , & n , & m , & w ); for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d%d\" , & u , & v , & z ); Add_edge ( u , v , z ); Add_edge ( v , u , z ); } for ( int i = 0 ; i < w ; i ++ ) { scanf ( \"%d%d%d\" , & u , & v , & z ); Add_edge ( u , v , - z ); } if ( ! SPFA ()) printf ( \"YES \\n \" ); else printf ( \"NO \\n \" ); } return 0 ; } dijikastra\u7b2ck\u77ed\u8def \u00b6 #include <iostream> #include <cstdio> #include <cstring> #include <queue> using namespace std ; const int INF = 0x3f3f3f3f ; const int MAX = 1005 ; int n , m ; int start , end , k ; struct Edge { int w ; int to ; int next ; }; Edge e [ 100005 ]; int head [ MAX ], edgeNum ; int dis [ MAX ]; //dis[i]\u8868\u793a\u4ecei\u70b9\u5230end\u7684\u6700\u77ed\u8ddd\u79bb bool vis [ MAX ]; int cnt [ MAX ]; vector < Edge > opp_Graph [ MAX ]; struct Node { int f , g ; //f = g+dis[v] int v ; //\u5f53\u524d\u5230\u8fbe\u7684\u8282\u70b9 Node ( int a , int b , int c ) : f ( a ), g ( b ), v ( c ){} bool operator < ( const Node & a ) const { return a . f < f ; } }; void addEdge ( int from , int to , int w ) { e [ edgeNum ]. to = to ; e [ edgeNum ]. w = w ; e [ edgeNum ]. next = head [ from ]; head [ from ] = edgeNum ++ ; } void dijikastra ( int start ) { int i ; memset ( vis , 0 , sizeof ( vis )); for ( i = 1 ; i <= n ; i ++ ) dis [ i ] = INF ; dis [ start ] = 0 ; priority_queue < Node > que ; que . push ( Node ( 0 , 0 , start )); Node next ( 0 , 0 , 0 ); while ( ! que . empty ()) { Node now = que . top (); que . pop (); if ( vis [ now . v ]) //\u4ece\u96c6\u5408T\u4e2d\u9009\u53d6\u5177\u6709\u6700\u77ed\u8ddd\u79bb\u7684\u8282\u70b9 continue ; vis [ now . v ] = true ; //\u6807\u8bb0\u8282\u70b9\u5df2\u4ece\u96c6\u5408T\u52a0\u5165\u5230\u96c6\u5408S\u4e2d for ( i = 0 ; i < opp_Graph [ now . v ]. size (); i ++ ) //\u66f4\u65b0\u4ece\u6e90\u70b9\u5230\u5176\u5b83\u8282\u70b9(\u96c6\u5408T\u4e2d)\u7684\u6700\u77ed\u8ddd\u79bb { Edge edge = opp_Graph [ now . v ][ i ]; if ( ! vis [ edge . to ] && dis [ now . v ] + edge . w < dis [ edge . to ]) //\u52a0\u4e0d\u52a0\u524d\u9762\u7684\u5224\u65ad\u65e0\u6240\u8c13 { dis [ edge . to ] = dis [ now . v ] + edge . w ; next . f = dis [ edge . to ]; next . v = edge . to ; que . push ( next ); } } } } int A_Star () { int i ; priority_queue < Node > que ; if ( dis [ start ] == INF ) return -1 ; que . push ( Node ( dis [ start ], 0 , start )); Node next ( 0 , 0 , 0 ); while ( ! que . empty ()) { Node now = que . top (); que . pop (); cnt [ now . v ] ++ ; if ( cnt [ end ] == k ) return now . f ; if ( cnt [ now . v ] > k ) continue ; for ( i = head [ now . v ]; i != -1 ; i = e [ i ]. next ) { next . v = e [ i ]. to ; next . g = now . g + e [ i ]. w ; next . f = next . g + dis [ e [ i ]. to ]; que . push ( next ); } } return -1 ; } int main () { int i ; int from , to , w ; edgeNum = 0 ; memset ( head , -1 , sizeof ( head )); memset ( opp_Graph , 0 , sizeof ( opp_Graph )); memset ( cnt , 0 , sizeof ( cnt )); scanf ( \"%d %d\" , & n , & m ); Edge edge ; for ( i = 1 ; i <= m ; i ++ ) { scanf ( \"%d %d %d\" , & from , & to , & w ); addEdge ( from , to , w ); edge . to = from ; edge . w = w ; opp_Graph [ to ]. push_back ( edge ); } scanf ( \"%d %d %d\" , & start , & end , & k ); if ( start == end ) k ++ ; dijikastra ( end ); int result = A_Star (); printf ( \"%d \\n \" , result ); return 0 ; } LCA+ST\u500d\u589e\u7b97\u6cd5 \u00b6 #include <bits/stdc++.h> using namespace std ; //lca\u677f\u5b50\u9898,\u6c42\u4fe9\u4e2a\u70b9\u6700\u77ed\u8ddd\u79bb //\u6811\u4e0a\u4e24\u70b9\u6700\u77ed\u8def\u5f84:\u4ece\u6839\u8282\u70b9\u51fa\u53d1dis[u]+dis[v]-dis[lca]*2 struct node { int to , next ; }; int tot = 0 ; node edge [ 1000500 ] = { 0 }; int head [ 500500 ] = { 0 }; int fa [ 500500 ][ 18 ] = { 0 }; int dep [ 500500 ] = { 0 }; void add ( int from , int to ) { edge [ ++ tot ]. next = head [ from ]; edge [ tot ]. to = to ; head [ from ] = tot ; } void dfs ( int now , int fa1 ) { dep [ now ] = dep [ fa1 ] + 1 ; fa [ now ][ 0 ] = fa1 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to != fa1 ) dfs ( to , now ); } } int lca ( int x , int y ) { if ( dep [ x ] < dep [ y ]) swap ( x , y ); for ( int j = 17 ; j >= 0 ; j -- ) { if ( dep [ fa [ x ][ j ]] >= dep [ y ]) x = fa [ x ][ j ]; } if ( x == y ) return x ; for ( int j = 17 ; j >= 0 ; j -- ) { if ( fa [ x ][ j ] != fa [ y ][ j ]) x = fa [ x ][ j ], y = fa [ y ][ j ]; } return fa [ x ][ 0 ]; } int main () { int n , m , s , f , t ; scanf ( \"%d%d%d\" , & n , & m , & s ); ///s\u4e3a\u6839\u8282\u70b9 for ( int i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%d%d\" , & f , & t ); add ( f , t ); add ( t , f ); } dfs ( s , 0 ); for ( int j = 1 ; j <= 17 ; j ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { fa [ i ][ j ] = fa [ fa [ i ][ j - 1 ]][ j - 1 ]; } } for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & f , & t ); printf ( \"%d \\n \" , lca ( f , t )); } } \u6811\u7684\u76f4\u5f84 \u00b6 #include <bits/stdc++.h> using namespace std ; struct node { int to , val , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }; int cnt = 0 ; int add_edge ( int from , int to , int val ) { edge [ ++ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. val = val ; head [ from ] = cnt ; } int dp [ 200500 ][ 4 ] = { 0 }; int down [ 200500 ] = { 0 }; int up [ 200500 ] = { 0 }; int len [ 200500 ][ 3 ] = { 0 }; int dfs1 ( int now , int fa ) { for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to , val = edge [ i ]. val ; if ( to == fa ) continue ; dfs1 ( to , now ); int tmp = dp [ to ][ 0 ] + val ; if ( tmp > dp [ now ][ 0 ]) swap ( dp [ now ][ 0 ], tmp ); if ( tmp > dp [ now ][ 1 ]) swap ( dp [ now ][ 1 ], tmp ); if ( tmp > dp [ now ][ 2 ]) swap ( dp [ now ][ 2 ], tmp ); down [ now ] = max ( down [ now ], down [ to ]); } down [ now ] = max ( down [ now ], dp [ now ][ 0 ] + dp [ now ][ 1 ]); } int dfs2 ( int now , int fa ) { for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { if ( edge [ i ]. to == fa ) continue ; int tem = down [ edge [ i ]. to ]; if ( tem > len [ now ][ 0 ]) swap ( tem , len [ now ][ 0 ]); if ( tem > len [ now ][ 1 ]) swap ( tem , len [ now ][ 1 ]); } for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to , val = edge [ i ]. val ; if ( to == fa ) continue ; if ( dp [ now ][ 0 ] == dp [ to ][ 0 ] + val ) { dp [ to ][ 3 ] = max ( dp [ now ][ 1 ], dp [ now ][ 3 ]) + val ; up [ to ] = max ( dp [ now ][ 2 ], dp [ now ][ 3 ]) + dp [ now ][ 1 ]; } else if ( dp [ now ][ 1 ] == dp [ to ][ 0 ] + val ) { dp [ to ][ 3 ] = max ( dp [ now ][ 0 ], dp [ now ][ 3 ]) + val ; up [ to ] = max ( dp [ now ][ 2 ], dp [ now ][ 3 ]) + dp [ now ][ 0 ]; } else { dp [ to ][ 3 ] = max ( dp [ now ][ 0 ], dp [ now ][ 3 ]) + val ; up [ to ] = max ( dp [ now ][ 1 ], dp [ now ][ 3 ]) + dp [ now ][ 0 ]; } if ( len [ now ][ 0 ] == down [ to ]) up [ to ] = max ( up [ to ], len [ now ][ 1 ]); else up [ to ] = max ( up [ to ], len [ now ][ 0 ]); dfs2 ( to , now ); } } int main () { int n , from , to , val ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n -1 ; i ++ ) { scanf ( \"%d%d%d\" , & from , & to , & val ); add_edge ( from , to , val ); add_edge ( to , from , val ); } dfs1 ( 1 , -1 ); dfs2 ( 1 , -1 ); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans = max ( ans , up [ i ] + down [ i ]); cout << ans << endl ; } \u6700\u5927\u6d41\u7b97\u6cd5 \u00b6 EK\u7b97\u6cd5\uff1a #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll to , val , next ; }; node edge [ 805 ] = { 0 }; ll head [ 205 ] = { 0 }; ll cnt = 0 ; ll s = 1 , e = 1 ; void add_edge ( ll from , ll to , ll val ) { edge [ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. val = val ; head [ from ] = cnt ++ ; } ll pre [ 205 ] = { 0 }, tag [ 205 ] = { 0 }, vis [ 205 ] = { 0 }; ll bfs () { queue < ll > que ; memset ( tag , 0 , sizeof ( tag )); memset ( pre , 0 , sizeof ( pre )); memset ( vis , 0 , sizeof ( vis )); que . push ( s ); vis [ s ] = 1 ; while ( ! que . empty ()) { ll now = que . front (); que . pop (); for ( ll i = head [ now ]; i != -1 ; i = edge [ i ]. next ) { ll to = edge [ i ]. to , val = edge [ i ]. val ; if ( ! vis [ to ] && val > 0 ) { vis [ to ] = 1 ; pre [ to ] = now ; tag [ to ] = i ; if ( to == e ) return 1 ; que . push ( to ); } } } return 0 ; } ll EK () { ll ans = 0 ; while ( bfs ()) { ll min1 = inf ; for ( ll i = e ; i != s ; i = pre [ i ]) { min1 = min ( min1 , edge [ tag [ i ]]. val ); } for ( ll i = e ; i != s ; i = pre [ i ]) { edge [ tag [ i ]]. val -= min1 ; edge [ tag [ i ] ^ 1 ]. val += min1 ; } ans += min1 ; } return ans ; } int main () { ll n , m , from , to , val ; while ( scanf ( \"%lld%lld\" , & m , & n ) == 2 && n ){ e = n ; cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) head [ i ] = -1 ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld%lld\" , & from , & to , & val ); add_edge ( from , to , val ); add_edge ( to , from , 0 ); } printf ( \"%lld \\n \" , EK ()); } } \u4f18\u5316\u7248Dinic\u7b97\u6cd5\uff1a #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define INF 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct Edge { ll from , to , cap , flow , index ; Edge ( ll from , ll to , ll cap , ll flow , ll index ) : from ( from ), to ( to ), cap ( cap ), flow ( flow ), index ( index ) {} }; struct Dinic { ll N ; vector < vector < Edge >> G ; vector < Edge *> dad ; vector < ll > Q ; Dinic ( ll N ) : N ( N ), G ( N ), dad ( N ), Q ( N ) {} void AddEdge ( ll from , ll to , ll cap ) { G [ from ]. push_back ( Edge ( from , to , cap , 0 , G [ to ]. size ())); if ( from == to ) G [ from ]. back (). index ++ ; G [ to ]. push_back ( Edge ( to , from , 0 , 0 , G [ from ]. size () - 1 )); } ll BlockingFlow ( ll s , ll t ) { fill ( dad . begin (), dad . end (), ( Edge * ) NULL ); dad [ s ] = & G [ 0 ][ 0 ] - 1 ; ll head = 0 , tail = 0 ; Q [ tail ++ ] = s ; while ( head < tail ) { ll x = Q [ head ++ ]; for ( ll i = 0 ; i < G [ x ]. size (); i ++ ) { Edge & e = G [ x ][ i ]; if ( ! dad [ e . to ] && e . cap - e . flow > 0 ) { dad [ e . to ] = & G [ x ][ i ]; Q [ tail ++ ] = e . to ; } } } if ( ! dad [ t ]) return 0 ; ll totflow = 0 ; for ( ll i = 0 ; i < G [ t ]. size (); i ++ ) { Edge * start = & G [ G [ t ][ i ]. to ][ G [ t ][ i ]. index ]; ll amt = INF ; for ( Edge * e = start ; amt && e != dad [ s ]; e = dad [ e -> from ]) { if ( ! e ) { amt = 0 ; break ; } amt = min ( amt , e -> cap - e -> flow ); } if ( amt == 0 ) continue ; for ( Edge * e = start ; amt && e != dad [ s ]; e = dad [ e -> from ]) { e -> flow += amt ; G [ e -> to ][ e -> index ]. flow -= amt ; } totflow += amt ; } return totflow ; } ll GetMaxFlow ( ll s , ll t ) { ll totflow = 0 ; while ( ll flow = BlockingFlow ( s , t )) totflow += flow ; return totflow ; } }; int main () { ll n , m , f , t , v , s , e ; scanf ( \"%lld%lld\" , & n , & m ); scanf ( \"%lld%lld\" , & s , & e ); Dinic dinic ( n + 10 ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld%lld\" , & f , & t , & v ); dinic . AddEdge ( f , t , v ); } printf ( \"%lld \\n \" , dinic . GetMaxFlow ( s , e )); } \u666e\u901a\u7248\u672cdinic\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll INF = 1e18 ; const int N = 5e2 + 7 ; const int M = 2e5 + 7 ; int head [ N ], nex [ M ], ver [ M ], tot = 1 ; ll edge [ M ]; int n , m , s , t ; ll maxflow ; ll deep [ N ]; //\u5c42\u7ea7\u6570\uff0c\u5176\u5b9e\u5e94\u8be5\u662flevel int now [ M ]; //\u5f53\u524d\u5f27\u4f18\u5316 queue < int > q ; inline void add ( int x , int y , int z ) { //\u5efa\u6b63\u8fb9\u548c\u53cd\u5411\u8fb9 ver [ ++ tot ] = y ; edge [ tot ] = z ; nex [ tot ] = head [ x ]; head [ x ] = tot ; ver [ ++ tot ] = x ; edge [ tot ] = 0 ; nex [ tot ] = head [ y ]; head [ y ] = tot ; } inline bool bfs () { //\u5728\u6b8b\u91cf\u7f51\u7edc\u4e2d\u6784\u9020\u5206\u5c42\u56fe for ( int i = 1 ; i <= n ; i ++ ) deep [ i ] = INF ; while ( ! q . empty ()) q . pop (); q . push ( s ); deep [ s ] = 0 ; now [ s ] = head [ s ]; //\u4e00\u4e9b\u521d\u59cb\u5316 while ( ! q . empty ()) { int x = q . front (); q . pop (); for ( int i = head [ x ]; i ; i = nex [ i ]) { int y = ver [ i ]; if ( edge [ i ] > 0 && deep [ y ] == INF ) { //\u6ca1\u8d70\u8fc7\u4e14\u5269\u4f59\u5bb9\u91cf\u5927\u4e8e0 q . push ( y ); now [ y ] = head [ y ]; //\u5148\u521d\u59cb\u5316\uff0c\u6682\u65f6\u90fd\u4e00\u6837 deep [ y ] = deep [ x ] + 1 ; if ( y == t ) return 1 ; //\u627e\u5230\u4e86 } } } return 0 ; } //flow\u662f\u6574\u6761\u589e\u5e7f\u8def\u5bf9\u6700\u5927\u6d41\u7684\u8d21\u732e\uff0crest\u662f\u5f53\u524d\u6700\u5c0f\u5269\u4f59\u5bb9\u91cf\uff0c\u7528rest\u53bb\u66f4\u65b0flow ll dfs ( int x , ll flow ) { //\u5728\u5f53\u524d\u5206\u5c42\u56fe\u4e0a\u589e\u5e7f if ( x == t ) return flow ; ll ans = 0 , k , i ; for ( i = now [ x ]; i && flow ; i = nex [ i ]) { now [ x ] = i ; //\u5f53\u524d\u5f27\u4f18\u5316\uff08\u907f\u514d\u91cd\u590d\u904d\u5386\u4ecex\u51fa\u53d1\u7684\u4e0d\u53ef\u62d3\u5c55\u7684\u8fb9\uff09 int y = ver [ i ]; if ( edge [ i ] > 0 && ( deep [ y ] == deep [ x ] + 1 )) { //\u5fc5\u987b\u662f\u4e0b\u4e00\u5c42\u5e76\u4e14\u5269\u4f59\u5bb9\u91cf\u5927\u4e8e0 k = dfs ( y , min ( flow , edge [ i ])); //\u53d6\u6700\u5c0f if ( ! k ) deep [ y ] = INF ; //\u526a\u679d\uff0c\u53bb\u6389\u589e\u5e7f\u5b8c\u6bd5\u7684\u70b9 edge [ i ] -= k ; //\u56de\u6eaf\u65f6\u66f4\u65b0 edge [ i ^ 1 ] += k ; //\u6210\u5bf9\u53d8\u6362 ans += k ; flow -= k ; } } return ans ; } void dinic () { while ( bfs ()) maxflow += dfs ( s , INF ); } int main () { scanf ( \"%d%d%d%d\" , & n , & m , & s , & t ); tot = 1 ; for ( ll i = 1 ; i <= m ; i ++ ) { int x , y , z ; scanf ( \"%d%d%d\" , & x , & y , & z ); add ( x , y , z ); } dinic (); printf ( \"%lld \\n \" , maxflow ); return 0 ; } \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u7b97\u6cd5 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int next ; int flow ; int dis ; int to ; }; int head [ 100500 ] = { 0 }; node edge [ 100500 ] = { 0 }; int dis [ 100500 ] = { 0 }; int pre [ 100500 ] = { 0 }; int vis [ 100500 ] = { 0 }; int last [ 100500 ] = { 0 }; int flow [ 100500 ] = { 0 }; char g [ 1000 ][ 1000 ] = { 0 }; int n , m , s , t , cnt = -1 , maxflow = 0 , mincost = 0 ; int num ( int i , int j ) { return i * m + j ; } int add ( int from , int to , int flow , int dis ) { edge [ ++ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. flow = flow ; edge [ cnt ]. dis = dis ; head [ from ] = cnt ; } queue < int > w ; bool spfa ( int start , int end1 ) { w . push ( start ); memset ( dis , 0x3f3f3f , sizeof ( dis )); memset ( vis , 0 , sizeof ( vis )); memset ( flow , 0x3f3f3f , sizeof ( flow )); pre [ end1 ] = -1 ; vis [ start ] = 1 ; dis [ start ] = 0 ; while ( ! w . empty ()) { int now = w . front (); w . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i != -1 ; i = edge [ i ]. next ) { //cout<<i<<endl; if ( edge [ i ]. flow > 0 && dis [ edge [ i ]. to ] > dis [ now ] + edge [ i ]. dis ) { dis [ edge [ i ]. to ] = dis [ now ] + edge [ i ]. dis ; pre [ edge [ i ]. to ] = now ; last [ edge [ i ]. to ] = i ; flow [ edge [ i ]. to ] = min ( flow [ now ], edge [ i ]. flow ); if ( ! vis [ edge [ i ]. to ]) { vis [ edge [ i ]. to ] = 1 ; w . push ( edge [ i ]. to ); } } } } return pre [ end1 ] != -1 ; } int MCMF () { while ( spfa ( s , t )) { maxflow += flow [ t ]; mincost += dis [ t ] * flow [ t ]; int now = t ; while ( now != s ) { edge [ last [ now ]]. flow -= flow [ t ]; edge [ last [ now ] ^ 1 ]. flow += flow [ t ]; now = pre [ now ]; } } } int main () { memset ( head , -1 , sizeof ( head )); scanf ( \"%d%d\" , & n , & m ); s = n * m + 200 , t = n * m + 100 ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , g [ i ] + 1 ); } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( g [ i ][ j ] == 'x' ) continue ; if ( j > 1 && g [ i ][ j -1 ] != 'x' ) { add ( num ( i , j ), num ( i , j -1 ), 1 , 1 ); add ( num ( i , j -1 ), num ( i , j ), 0 , -1 ); } if ( i > 1 && g [ i -1 ][ j ] != 'x' ) { add ( num ( i , j ), num ( i -1 , j ), 1 , 1 ); add ( num ( i -1 , j ), num ( i , j ), 0 , -1 ); } if ( j < m && g [ i ][ j + 1 ] != 'x' ) { add ( num ( i , j ), num ( i , j + 1 ), 1 , 1 ); add ( num ( i , j + 1 ), num ( i , j ), 0 , -1 ); } if ( i < n && g [ i + 1 ][ j ] != 'x' ) { add ( num ( i , j ), num ( i + 1 , j ), 1 , 1 ); add ( num ( i + 1 , j ), num ( i , j ), 0 , -1 ); } if ( g [ i ][ j ] == 'F' ) { add ( s , num ( i , j ), 2 , 0 ); add ( num ( i , j ), s , 0 , 0 ); } if ( g [ i ][ j ] == 'C' || g [ i ][ j ] == 'B' ) { add ( num ( i , j ), t , 1 , 0 ); add ( t , num ( i , j ), 0 , 0 ); } } } MCMF (); // cout<<maxflow<<\" \"<<mincost<<endl; if ( maxflow != 2 ) printf ( \"-1 \\n \" ); else printf ( \"%d \\n \" , mincost ); } \u4e8c\u5206\u56fe\u6a21\u677f \u00b6 \u9898\u610f\uff1a\u7ed9\u4f60n\u4e2a\u957f\u5ea6\u76f8\u540c\uff0c\u5305\u542b\u5b57\u6bcd\u79cd\u7c7b\u76f8\u540c\uff0c\u6bcf\u79cd\u5b57\u6bcd\u6570\u91cf\u76f8\u540c\uff0c\u8ba9\u4f60\u786e\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\u96c6\u5408\uff0c\u96c6\u5408\u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u4e32\u4e0d\u80fd\u901a\u8fc7\u4ea4\u6362\u4efb\u610f\u4e24\u4e2a\u4e0d\u540c\u7684\u4f4d\u7f6e\u53d8\u6210\u96c6\u5408\u4e2d\u7684\u53e6\u4e00\u4e2a\u4e32\uff0c\u95ee\u4f60\u96c6\u5408\u6700\u5927\u6709\u591a\u4e2a\u5b57\u7b26\u4e32\u3002 \u601d\u8def\uff1a \u6211\u4eec\u5bf9\u4e8e\u4e24\u4e2a\u4e00\u6b21\u64cd\u4f5c\uff08\u4ea4\u6362\u4e24\u4e2a\u4e0d\u540c\u4f4d\u7f6e\uff09\u4e0d\u80fd\u4e92\u76f8\u53d8\u6362\u7684\u4e32\u5efa\u8fb9\uff0c\u90a3\u4e48\u7b54\u6848\u5c31\u662f\u8fd9\u4e2a\u56fe\u7684\u6700\u5927\u56e2\u3002 \u4e00\u4e2a\u56fe\u7684\u6700\u5927\u56e2\u7b49\u4e8e\u8fd9\u4e2a\u56fe\u8865\u56fe\u7684\u6700\u5927\u72ec\u7acb\u96c6\uff0c\u90a3\u4e48\u6211\u4eec\u8981\u5efa\u8fd9\u4e2a\u56fe\u7684\u8865\u56fe\u3002 \u8fd9\u4e2a\u56fe\u7684\u8865\u56fe\u5c31\u662f\u5bf9\u80fd\u591f\u4e00\u6b21\u64cd\u4f5c\u4e92\u76f8\u53d8\u6362\u7684\u4e24\u4e2a\u4e32\u5efa\u8fb9\u3002 \u90a3\u4e48\u73b0\u5728\u7b54\u6848\u5c31\u662f\u8fd9\u4e2a\u8865\u56fe\u7684\u6700\u5927\u72ec\u7acb\u96c6\u3002 \u8fd9\u4e2a\u8865\u56fe\u4e00\u5b9a\u662f\u4e00\u4e2a\u4e8c\u5206\u56fe\u3002 \u4e8c\u5206\u56fe\u7684\u6700\u5927\u72ec\u7acb\u96c6\u7b49\u4e8e\u56fe\u4e2d\u70b9\u7684\u4e2a\u6570 - \u6700\u5927\u5339\u914d\u6570\u3002 \u6240\u4ee5\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u5bf9\u8fd9\u4e2a\u4e8c\u5206\u56fe\u6c42\u4e00\u4e2a\u6700\u5927\u5339\u914d\u3002 #include <bits/stdc++.h> using namespace std ; char a [ 1000 ][ 300 ] = { 0 }; int mp [ 1000 ][ 1000 ] = { 0 }; map < int , int > mp1 , vis ; int n ; int dfs ( int k ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( mp [ i ][ k ] &&! vis [ i ]) { vis [ i ] = 1 ; if ( mp1 [ i ] == 0 || dfs ( mp1 [ i ])) { mp1 [ i ] = k ; return 1 ; } } } return 0 ; } int main () { scanf ( \"%d\" , & n ); ///\u4e24\u4e2a\u5b57\u7b26\u4e32\u4e2d\u4e0d\u80fd\u6709\u4e24\u4e2a\u5b57\u7b26\u76f8\u540c\uff0c\u95ee\u81f3\u5c11\u9700\u8981\u5206\u4e3a\u591a\u5c11\u7ec4 for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int sum = 0 ; for ( int k = 1 ; a [ i ][ k ]; k ++ ) { if ( a [ i ][ k ] != a [ j ][ k ]) sum ++ ; } if ( sum == 2 ) mp [ i ][ j ] = 1 ; } } //cout<<mp[1][2]<<endl; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { vis . clear (); ans += dfs ( i ); } cout << n - ans / 2 << endl ; } \u4e8c\u5206\u56fe\u5224\u65ad #include <bits/stdc++.h> using namespace std ; vector < int > v [ 100500 ]; int color [ 100500 ] = { 0 }; int bfs ( int i ) { queue < int > que ; que . push ( i ); while ( ! que . empty ()) { int now = que . front (); que . pop (); for ( int i : v [ now ]) { if ( color [ i ] == 0 ) { color [ i ] = 3 - color [ now ]; que . push ( i ); } else { if ( color [ i ] == color [ now ]) return 0 ; } } } return 1 ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int from , to ; scanf ( \"%d %d\" , & from , & to ); v [ from ]. push_back ( to ); v [ to ]. push_back ( from ); } for ( int i = 1 ; i <= m ; i ++ ) { if ( color [ i ] == 0 ) { int tmp = bfs ( i ); if ( tmp == 0 ) { puts ( \"No\" ); return 0 ; } } } puts ( \"Yes\" ); } /* \u8f93\u5165\uff1a 7 6 1 2 1 3 2 4 2 5 3 6 3 7 \u8f93\u51fa\uff1a Yes \u8f93\u5165\uff1a 3 3 1 2 2 3 1 3 \u8f93\u51fa\uff1a No */ \u4e8c\u5206\u56fe\u6700\u5927\u5339\u914d #include <bits/stdc++.h> using namespace std ; vector < int > v [ 100500 ]; map < int , int > mp , vis , mp1 ; int dfs ( int now ) { for ( int i = 0 ; i < v [ now ]. size (); i ++ ) { int to = v [ now ][ i ]; if ( ! vis [ to ]) { vis [ to ] = 1 ; if ( mp [ to ] == 0 || dfs ( mp [ to ])) { mp [ to ] = now ; mp1 [ now ] = to ; return 1 ; } } } return 0 ; } int main () { int n1 , n2 , m ; scanf ( \"%d%d%d\" , & n1 , & n2 , & m ); int from , to ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); to += n1 ; v [ from ]. push_back ( to ); v [ to ]. push_back ( from ); } int ans = 0 ; for ( int i = 1 ; i <= n1 ; i ++ ) { vis . clear (); ans += dfs ( i ); } cout << ans << endl ; for ( int i = 1 ; i <= n1 ; i ++ ) cout << max ( 0 , mp1 [ i ] - n1 ) << ' ' ; } \u4e8c\u5206\u56fe\u6700\u5927\u72ec\u7acb\u96c6\uff1a \u9009\u6700\u591a\u7684\u70b9\uff0c\u6ee1\u8db3\u4e24\u4e24\u4e4b\u95f4\u6ca1\u6709\u8fb9\u76f8\u8fde\u3002 \u4e8c\u5206\u56fe\u4e2d\uff0c\u6700\u5927\u72ec\u7acb\u96c6 =n- \u6700\u5927\u5339\u914d\u3002 \u4e8c\u5206\u56fe\u6700\u5c0f\u70b9\u8986\u76d6\uff1a \u9009\u6700\u5c11\u7684\u70b9\uff0c\u6ee1\u8db3\u6bcf\u6761\u8fb9\u81f3\u5c11\u6709\u4e00\u4e2a\u7aef\u70b9\u88ab\u9009\uff0c\u4e0d\u96be\u53d1\u73b0\u8865\u96c6\u662f\u72ec\u7acb\u96c6\u3002 \u4e8c\u5206\u56fe\u4e2d\uff0c\u6700\u5c0f\u70b9\u8986\u76d6 =n- \u6700\u5927\u72ec\u7acb\u96c6\u3002 \u4e8c\u5206\u56fe\u6709\u5411\u65e0\u5411\u5efa\u56fe\u89c4\u5219\uff1a \u6709\u5de6\u53f3\u4e4b\u5206\u5efa\u5355\u5411\u8fb9\uff0c\u65e0\u5de6\u53f3\u4e4b\u5206\u5efa\u65e0\u5411\u8fb9 \u7b54\u6848\u96642 \u4e00\u5207\u6811\u5747\u4e3a\u4e8c\u5206\u56fe \u4e8c\u5206\u56fe\u6700\u5927\u6743\u5339\u914d\uff1a \u9898\u76ee\uff1a https://uoj.ac/problem/80 \u9898\u89e3\uff1a https://blog.csdn.net/weixin_30528371/article/details/99263983 \u8bb2\u89e3\uff1a https://www.cnblogs.com/wenruo/p/5264235.html #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; int n , m , q ; int w [ 405 ] = { 0 }, v [ 405 ] = { 0 }; int vl [ 405 ] = { 0 }, vr [ 405 ] = { 0 }, c [ 405 ] = { 0 }; int a [ 405 ][ 405 ] = { 0 }, ans [ 405 ] = { 0 }, b [ 405 ] = { 0 }; int tim = 0 ; int dfs ( int x ) { vl [ x ] = tim ; for ( int i = 1 ; i <= m ; i ++ ) { if ( vr [ i ] == tim ) continue ; int d = w [ x ] + v [ i ] - a [ x ][ i ]; if ( d == 0 ) { vr [ i ] = tim ; if ( ! b [ i ] || dfs ( b [ i ])) { b [ i ] = x ; return 1 ; } } else { c [ i ] = min ( c [ i ], d ); } } return 0 ; } void km () { for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) w [ i ] = max ( w [ i ], a [ i ][ j ]); for ( int i = 1 ; i <= n ; i ++ ) { memset ( c , inf , sizeof ( c )); tim += 1 ; if ( dfs ( i )) continue ; while ( 1 ) { int d = inf , y = 0 ; for ( int j = 1 ; j <= m ; j ++ ) if ( vr [ j ] != tim ) d = min ( d , c [ j ]); for ( int j = 1 ; j <= n ; j ++ ) if ( vl [ j ] == tim ) w [ j ] -= d ; for ( int j = 1 ; j <= m ; j ++ ) { if ( vr [ j ] == tim ) v [ j ] += d ; else if ( ! ( c [ j ] -= d )) y = j ; } if ( ! b [ y ]) break ; int x = b [ y ]; vl [ x ] = vr [ y ] = tim ; for ( int j = 1 ; j <= m ; j ++ ) c [ j ] = min ( c [ j ], w [ x ] + v [ j ] - a [ x ][ j ]); } tim += 1 ; dfs ( i ); } ll ans1 = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans1 += a [ b [ i ]][ i ]; printf ( \"%lld \\n \" , ans1 ); for ( int i = 1 ; i <= m ; i ++ ) { if ( a [ b [ i ]][ i ]) ans [ b [ i ]] = i ; } for ( int i = 1 ; i <= n ; i ++ ) printf ( \"%d \" , ans [ i ]); } int main () { scanf ( \"%d%d%d\" , & n , & m , & q ); m = max ( m , n ); for ( int i = 1 ; i <= q ; i ++ ) { int x , y , v ; scanf ( \"%d%d%d\" , & x , & y , & v ); a [ x ][ y ] = v ; } km (); } Tarjan\u7b97\u6cd5 \u00b6 Tarjan \u7b97\u6cd5\u53ca\u5176\u5e94\u7528 \u6c42\u5272\u8fb9 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int to , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }, dfn [ 200500 ] = { 0 }, low [ 200500 ] = { 0 }, bridge [ 200500 ] = { 0 }; int cnt = 1 , tot = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } void tarjan ( int x , int in_edge ) { dfn [ x ] = low [ x ] = ++ tot ; for ( int i = head [ x ]; i ; i = edge [ i ]. next ) { int y = edge [ i ]. to ; if ( ! dfn [ y ]) { tarjan ( y , i ); low [ x ] = min ( low [ x ], low [ y ]); if ( low [ y ] > dfn [ x ]) bridge [ i ] = bridge [ i ^ 1 ] = 1 ; ///\u6865 } else if ( i != ( in_edge ^ 1 )) low [ x ] = min ( low [ x ], dfn [ y ]); } } int main () { int n , m , from , to ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! dfn [ i ]) tarjan ( i , 0 ); } for ( int i = 2 ; i <= cnt ; i += 2 ) { if ( bridge [ i ]) { printf ( \"%d %d \\n \" , edge [ i ^ 1 ]. to , edge [ i ]. to ); } } } \u7f29\u70b9\u6c42\u5c06\u56fe\u8f6c\u53d8\u4e3a\u5f3a\u8fde\u901a\u56fe\u9700\u8981\u52a0\u8fb9\u7684\u6570\u76ee \u9898\u76ee\u6765\u6e90\uff1aPOJ 2767 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int to , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }, dfn [ 200500 ] = { 0 }, low [ 200500 ] = { 0 }; int stack1 [ 200500 ] = { 0 }, vis [ 200500 ] = { 0 }, color [ 200500 ] = { 0 }; bool in [ 200500 ] = { 0 }, out [ 200500 ] = { 0 }; int cnt = 0 , tot = 0 , top = 0 , color_num = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } void tarjan ( int now ) { stack1 [ ++ top ] = now ; vis [ now ] = 1 ; dfn [ now ] = low [ now ] = ++ tot ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int y = edge [ i ]. to ; if ( ! dfn [ y ]) { tarjan ( y ); low [ now ] = min ( low [ now ], low [ y ]); } else if ( vis [ y ]) low [ now ] = min ( low [ now ], dfn [ y ]); } if ( dfn [ now ] == low [ now ]) ///\u5f3a\u8fde\u901a\u5757 { color [ now ] = ++ color_num ; vis [ now ] = 0 ; while ( stack1 [ top ] != now ) { color [ stack1 [ top ]] = color_num ; vis [ stack1 [ top -- ]] = 0 ; } vis [ stack1 [ top ]] = 0 ; top -- ; } } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m , from , to ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n + 1 ; i ++ ) in [ i ] = out [ i ] = head [ i ] = dfn [ i ] = low [ i ] = stack1 [ i ] = vis [ i ] = color [ i ] = 0 ; cnt = 0 , tot = 0 , top = 0 , color_num = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); add_edge ( from , to ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! dfn [ i ]) tarjan ( i ); } if ( color_num == 1 ) { printf ( \"0 \\n \" ); continue ; } int in_num = color_num , out_num = color_num ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = head [ i ]; j ; j = edge [ j ]. next ) { int to = edge [ j ]. to ; if ( color [ to ] != color [ i ]) { if ( ! in [ color [ to ]]) { in_num -- ; in [ color [ to ]] = 1 ; } if ( ! out [ color [ i ]]) { out_num -- ; out [ color [ i ]] = 1 ; } } } } printf ( \"%d \\n \" , max ( out_num , in_num )); } } \u6c42\u5272\u70b9 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int to , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }, dfn [ 200500 ] = { 0 }, low [ 200500 ] = { 0 }, cut [ 200500 ] = { 0 }; int cnt = 0 , tot = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } void tarjan ( int now , int root ) { dfn [ now ] = low [ now ] = ++ tot ; int ct = 0 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int y = edge [ i ]. to ; ct ++ ; if ( ! dfn [ y ]) { tarjan ( y , root ); low [ now ] = min ( low [ now ], low [ y ]); if ( now != root && low [ y ] >= dfn [ now ]) cut [ now ] = 1 ; if ( now == root && ct > 1 ) cut [ now ] = 1 ; } else low [ now ] = min ( low [ now ], dfn [ y ]); } } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m , from , to ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n + 1 ; i ++ ) head [ i ] = dfn [ i ] = low [ i ] = cut [ i ] = 0 ; cnt = 0 , tot = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! dfn [ i ]) tarjan ( i , i ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( cut [ i ]) printf ( \"%d \" , i ); } printf ( \" \\n \" ); } } /* \u8f93\u5165\uff1a 1 7 7 1 2 1 5 5 6 5 7 2 3 2 4 3 4 \u5272\u70b9\u4e3a\uff1a 1 2 5 */ \u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811 \u00b6 https://oi-wiki.org/graph/hld/#_4 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll sum [ 400500 ] = { 0 }, lazy [ 400500 ] = { 0 }; ll dep [ 200500 ] = { 0 }, size1 [ 200500 ] = { 0 }, son [ 200500 ] = { 0 }, f [ 200500 ] = { 0 }, id [ 200500 ] = { 0 }, top [ 200500 ] = { 0 }; struct node { ll to , next ; }; node edge [ 400500 ] = { 0 }; ll head [ 400500 ] = { 0 }; ll num = 0 , cnt = 0 ; void add_edge ( ll from , ll to ) { edge [ ++ num ] = { to , head [ from ]}; head [ from ] = num ; } void dfs1 ( ll now , ll fa ) { size1 [ now ] = 1 ; for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == fa ) continue ; f [ to ] = now ; dep [ to ] = dep [ now ] + 1 ; dfs1 ( to , now ); size1 [ now ] += size1 [ to ]; if ( size1 [ to ] > size1 [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( ll now , ll fa ) { id [ now ] = ++ cnt ; top [ now ] = fa ; if ( son [ now ]) dfs2 ( son [ now ], fa ); for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == f [ now ] || to == son [ now ]) continue ; dfs2 ( to , to ); } } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t + 1 ] += lazy [ t ]; lazy [ 2 * t ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += ( mid - l + 1 ) * lazy [ t ]; sum [ 2 * t + 1 ] += ( r - mid ) * lazy [ t ]; lazy [ t ] = 0 ; } void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { lazy [ t ] += add ; sum [ t ] += add * ( R - L + 1 ); return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query ( ll t , ll l , ll r , ll L , ll R ) { if ( l <= L && R <= r ) return sum [ t ]; push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; ll ans = 0 ; if ( l <= mid ) ans += query ( 2 * t , l , r , L , mid ); if ( mid < r ) ans += query ( 2 * t + 1 , l , r , mid + 1 , R ); return ans ; } void update_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ]; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); update ( 1 , id [ fx ], id [ x ], 1 , cnt , 1 ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); update ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt , 1 ); } ll query_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ], ans = 0 ; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); ans += query ( 1 , id [ fx ], id [ x ], 1 , cnt ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); ans += query ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt ); return ans ; } int main () { ll n , m , from , to ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } f [ 1 ] = 0 , dep [ 1 ] = 1 ; dfs1 ( 1 , 0 ), dfs2 ( 1 , 1 ); char c [ 10 ]; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , c + 1 , & from , & to ); if ( c [ 1 ] == 'P' ) update_chain ( from , to ); else printf ( \"%lld \\n \" , query_chain ( from , to )); } } \u5206\u5c42\u6700\u77ed\u8def \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef pair < int , int > pii ; const int N = 100000 + 5 ; const int K = 10 + 5 ; const ll inf = 0x3f3f3f3f3f3f3f3f ; vector < pii > e [ N ]; struct Info { int pos , num ; ll val ; inline Info (){} inline Info ( int _pos , int _num , ll _val ) { pos = _pos , num = _num , val = _val ; } inline bool operator < ( const Info & b ) const { return val > b . val ; } }; ll f [ N ][ K ]; bool vis [ N ][ K ]; priority_queue < Info > q ; class TaskL { public : void solve ( std :: istream & in , std :: ostream & out ) { int T ; in >> T ; while ( T -- ) { int n , m , k ; in >> n >> m >> k ; while ( q . size ()) q . pop (); for ( int i = 1 ; i <= n ; ++ i ) { e [ i ]. clear (); for ( int j = 0 ; j <= k ; ++ j ) { f [ i ][ j ] = inf ; vis [ i ][ j ] = false ; } } for ( int i = 1 , x , y , z ; i <= m ; ++ i ) { in >> x >> y >> z ; e [ x ]. push_back ({ y , z }); } f [ 1 ][ 0 ] = 0 ; q . push ( Info ( 1 , 0 , 0 )); while ( q . size ()) { Info now = q . top (); q . pop (); if ( vis [ now . pos ][ now . num ] == true ) continue ; vis [ now . pos ][ now . num ] = true ; for ( int i = 0 ; i < e [ now . pos ]. size (); ++ i ) { int to = e [ now . pos ][ i ]. first , val = e [ now . pos ][ i ]. second ; if ( f [ to ][ now . num ] > f [ now . pos ][ now . num ] + val ) { f [ to ][ now . num ] = f [ now . pos ][ now . num ] + val ; q . push ( Info ( to , now . num , f [ to ][ now . num ])); } if ( now . num < k && f [ to ][ now . num + 1 ] > f [ now . pos ][ now . num ]) { f [ to ][ now . num + 1 ] = f [ now . pos ][ now . num ]; q . push ( Info ( to , now . num + 1 , f [ to ][ now . num + 1 ])); } } } ll ans = inf ; for ( int i = 0 ; i <= k ; ++ i ) { ans = min ( ans , f [ n ][ i ]); } out << ans << endl ; } } }; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); TaskL solver ; std :: istream & in ( std :: cin ); std :: ostream & out ( std :: cout ); solver . solve ( in , out ); return 0 ; } LCT \u52a8\u6001\u6811 \u00b6 \u53c2\u8003\u94fe\u63a5\uff1a https://www.luogu.com.cn/problem/P3690 https://www.cnblogs.com/zwfymqz/p/7896036.html#!comments https://www.cnblogs.com/zzy2005/p/10312977.html https://www.cnblogs.com/JeremyGJY/p/5921594.html https://blog.csdn.net/qq_36551189/article/details/79152612 #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll f [ 100500 ] = { 0 }, c [ 100500 ][ 2 ] = { 0 }, v [ 100500 ] = { 0 }, s [ 100500 ] = { 0 }, st [ 100500 ] = { 0 }; bool r [ 100500 ] = { 0 }; //\u5224\u65ad\u8282\u70b9\u662f\u5426\u4e3a\u4e00\u4e2aSplay\u7684\u6839 inline bool nroot ( register ll x ) { return c [ f [ x ]][ 0 ] == x || c [ f [ x ]][ 1 ] == x ; //\u539f\u7406\u4e3a\u5982\u679c\u8fde\u7684\u662f\u8f7b\u8fb9\uff0c\u4ed6\u7684\u7236\u4eb2\u7684\u513f\u5b50\u91cc\u6ca1\u6709\u5b83 } //\u4e0a\u4f20\u4fe1\u606f inline void pushup ( ll x ) { s [ x ] = s [ c [ x ][ 0 ]] ^ s [ c [ x ][ 1 ]] ^ v [ x ]; } //\u7ffb\u8f6c\u64cd\u4f5c inline void pushr ( register ll x ) { register ll t = c [ x ][ 0 ]; c [ x ][ 0 ] = c [ x ][ 1 ]; c [ x ][ 1 ] = t ; r [ x ] ^= 1 ; } //\u5224\u65ad\u5e76\u91ca\u653e\u61d2\u6807\u8bb0 inline void pushdown ( register ll x ) { if ( r [ x ]) { if ( c [ x ][ 0 ]) pushr ( c [ x ][ 0 ]); if ( c [ x ][ 1 ]) pushr ( c [ x ][ 1 ]); r [ x ] = 0 ; } } //\u4e00\u6b21\u65cb\u8f6c inline void rotate ( register ll x ) { register ll y = f [ x ], z = f [ y ], k = c [ y ][ 1 ] == x , w = c [ x ][ ! k ]; if ( nroot ( y )) c [ z ][ c [ z ][ 1 ] == y ] = x ; c [ x ][ ! k ] = y ; c [ y ][ k ] = w ; if ( w ) f [ w ] = y ; f [ y ] = x ; f [ x ] = z ; pushup ( y ); } //\u53ea\u4f20\u4e86\u4e00\u4e2a\u53c2\u6570\uff0c\u56e0\u4e3a\u6240\u6709\u64cd\u4f5c\u7684\u76ee\u6807\u90fd\u662f\u8be5Splay\u7684\u6839 inline void splay ( register ll x ) { register ll y = x , z = 0 ; st [ ++ z ] = y ; //st\u4e3a\u6808\uff0c\u6682\u5b58\u5f53\u524d\u70b9\u5230\u6839\u7684\u6574\u6761\u8def\u5f84\uff0cpushdown\u65f6\u4e00\u5b9a\u8981\u4ece\u4e0a\u5f80\u4e0b\u653e\u6807\u8bb0 while ( nroot ( y )) st [ ++ z ] = y = f [ y ]; while ( z ) pushdown ( st [ z -- ]); while ( nroot ( x )) { y = f [ x ]; z = f [ y ]; if ( nroot ( y )) rotate (( c [ y ][ 0 ] == x ) ^ ( c [ z ][ 0 ] == y ) ? x : y ); rotate ( x ); } pushup ( x ); } //\u8bbf\u95ee inline void access ( register ll x ) { for ( register ll y = 0 ; x ; x = f [ y = x ]) splay ( x ), c [ x ][ 1 ] = y , pushup ( x ); } //\u6362\u6839 inline void makeroot ( register ll x ) { access ( x ); splay ( x ); pushr ( x ); } //\u627e\u6839\uff08\u5728\u771f\u5b9e\u7684\u6811\u4e2d\u7684\uff09 inline ll findroot ( register ll x ) { access ( x ); splay ( x ); while ( c [ x ][ 0 ]) pushdown ( x ), x = c [ x ][ 0 ]; splay ( x ); return x ; } //\u63d0\u53d6\u8def\u5f84 inline void split ( register ll x , register ll y ) { makeroot ( x ); access ( y ); splay ( y ); } //\u8fde\u8fb9 inline void link ( register ll x , register ll y ) { makeroot ( x ); if ( findroot ( y ) != x ) f [ x ] = y ; } //\u65ad\u8fb9 void cut ( register ll x , register ll y ) { makeroot ( x ); if ( findroot ( y ) == x && f [ y ] == x && ! c [ y ][ 0 ]) { f [ y ] = c [ x ][ 1 ] = 0 ; pushup ( x ); } } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) //\u7ed9\u5b9a n \u4e2a\u70b9\u4ee5\u53ca\u6bcf\u4e2a\u70b9\u7684\u6743\u503c scanf ( \"%d\" , & v [ i ]); for ( int i = 1 ; i <= m ; i ++ ) { int opt , x , y ; scanf ( \"%d%d%d\" , & opt , & x , & y ); if ( opt == 0 ) //\u4ee3\u8868\u8be2\u95ee\u4ece x \u5230 y \u7684\u8def\u5f84\u4e0a\u7684\u70b9\u7684\u6743\u503c\u7684 xor \u548c\u3002\u4fdd\u8bc1 x \u5230 y \u662f\u8054\u901a\u7684\u3002 { split ( x , y ); printf ( \"%d \\n \" , s [ y ]); } else if ( opt == 1 ) //\u4ee3\u8868\u8fde\u63a5 x \u5230 y\uff0c\u82e5 x \u5230 y \u5df2\u7ecf\u8054\u901a\u5219\u65e0\u9700\u8fde\u63a5\u3002 { link ( x , y ); } else if ( opt == 2 ) //\u4ee3\u8868\u5220\u9664\u8fb9 (x,y)\uff0c\u4e0d\u4fdd\u8bc1\u8fb9 (x,y) \u5b58\u5728\u3002 { cut ( x , y ); } else if ( opt == 3 ) //\u4ee3\u8868\u5c06\u70b9 x \u4e0a\u7684\u6743\u503c\u53d8\u6210 y\u3002 { splay ( x ); v [ x ] = y ; } } } \u6570\u636e\u7ed3\u6784 \u00b6 \u6811\u72b6\u6570\u7ec4\u524d\u7f00\u548c \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n , m ; ll a [ 100500 ] = { 0 }; ll c [ 100500 ] = { 0 }; ll lowbit ( ll x ) { return x & ( - x ); } ll update ( ll k , ll x ) { for ( ll i = k ; i <= n ; i += lowbit ( i )) c [ i ] += x ; } ll sum1 ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c [ i ]; return ans ; } int main () { ll a1 , b1 , c1 ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld%lld\" , & a1 , & b1 , & c1 ); if ( a1 == 0 ) update ( b1 , c1 ); else printf ( \"%lld \\n \" , sum1 ( c1 ) - sum1 ( b1 -1 )); } } \u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u548c \u00b6 #include <stdio.h> using namespace std ; typedef long long ll ; ll num [ 100500 ] = { 0 }; ll lazy [ 800500 ] = { 0 }; ll sum [ 800500 ] = { 0 }; void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t ] += lazy [ t ]; lazy [ 2 * t + 1 ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += lazy [ t ] * ( mid - l + 1 ); sum [ 2 * t + 1 ] += lazy [ t ] * ( r - mid ); lazy [ t ] = 0 ; } void build ( ll t , ll l , ll r ) { if ( l == r ) { sum [ t ] = num [ l ]; return ; } ll mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); push_up ( t ); } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( l <= L && r >= R ) { sum [ t ] += add * ( R - L + 1 ); lazy [ t ] += add ; return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query_sum ( ll t , ll l , ll r , ll L , ll R ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( l <= L && r >= R ) { return sum [ t ]; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 , sum = 0 ; if ( l <= mid ) sum += query_sum ( 2 * t , l , r , L , mid ); if ( mid < r ) sum += query_sum ( 2 * t + 1 , l , r , mid + 1 , R ); return sum ; } int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & num [ i ]); build ( 1 , 1 , n ); char s [ 10 ]; ll l , r , x ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , s , & l , & r ); if ( s [ 0 ] == 'Q' ) { printf ( \"%lld \\n \" , query_sum ( 1 , l , r , 1 , n )); } else { scanf ( \"%lld\" , & x ); update ( 1 , l , r , 1 , n , x ); } } } \u5212\u5206\u6811\u6c42\u4e2d\u4f4d\u6570 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int tree [ 20 ][ 100500 ] = { 0 }; int to [ 20 ][ 100500 ] = { 0 }; int num [ 100500 ] = { 0 }; int sorted [ 100500 ] = { 0 }; int build ( int l , int r , int deep ) { if ( l == r ) return 0 ; int mid = ( l + r ) / 2 ; int midd = sorted [ mid ]; int suppose = mid - l + 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( tree [ deep ][ i ] < midd ) suppose -- ; } int sleft = l , sright = mid + 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( i == l ) to [ deep ][ l ] = 0 ; else to [ deep ][ i ] = to [ deep ][ i -1 ]; if ( tree [ deep ][ i ] < midd ) { to [ deep ][ i ] ++ ; tree [ deep + 1 ][ sleft ++ ] = tree [ deep ][ i ]; } else if ( tree [ deep ][ i ] == midd && suppose > 0 ) { suppose -- ; to [ deep ][ i ] ++ ; tree [ deep + 1 ][ sleft ++ ] = tree [ deep ][ i ]; } else { tree [ deep + 1 ][ sright ++ ] = tree [ deep ][ i ]; } } build ( l , mid , deep + 1 ); build ( mid + 1 , r , deep + 1 ); } int query ( int l , int r , int L , int R , int k , int deep ) { if ( L == R ) return tree [ deep ][ L ]; int mid = ( l + r ) / 2 ; int lef ; int toleft ; if ( l == L ) lef = 0 , toleft = to [ deep ][ R ]; else lef = to [ deep ][ L -1 ], toleft = to [ deep ][ R ] - lef ; if ( k <= toleft ) { return query ( l , mid , l + lef , l + toleft + lef -1 , k , deep + 1 ); } else { return query ( mid + 1 , r , mid + L - l - lef + 1 , mid + R - l - toleft - lef + 1 , k - toleft , deep + 1 ); } } int main () { int n , m , summ = 0 ; while ( scanf ( \"%d\" , & n ) != EOF ) { summ ++ ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & num [ i ]); sorted [ i ] = num [ i ]; tree [ 0 ][ i ] = num [ i ]; } sort ( sorted + 1 , sorted + n + 1 ); build ( 1 , n , 0 ); printf ( \"Case %d: \\n \" , summ ); scanf ( \"%d\" , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int a , b , c ; /// a,b,c\u4ee3\u8868\u67e5\u8be2a\u5230b\u533a\u95f4\u5185\u7b2cc\u5927\u7684\u6570 scanf ( \"%d%d\" , & a , & b ); c = ( b - a ) / 2 + 1 ; printf ( \"%d \\n \" , query ( 1 , n , a , b , c , 0 )); } } } \u5355\u8c03\u6808 \u00b6 \u5355\u8c03\u6808 \u662f\u5728\u6808\u7684**\u5148\u8fdb\u540e\u51fa**\u57fa\u7840\u4e4b\u4e0a\u989d\u5916\u6dfb\u52a0\u4e00\u4e2a\u7279\u6027\uff1a**\u4ece\u6808\u9876\u5230\u6808\u5e95**\u7684\u5143\u7d20\u662f\u4e25\u683c\u9012\u589e\u6216\u9012\u51cf\u3002 \u4e3a\u4e86\u7ef4\u62a4\u6808\u7684\u5355\u8c03\u6027\uff0c\u5728\u8fdb\u6808\u8fc7\u7a0b\u4e2d\u9700\u8981\u8fdb\u884c\u5224\u65ad\uff0c\u5177\u4f53\u8fdb\u6808\u8fc7\u7a0b\u5982\u4e0b\uff1a\u5047\u8bbe\u5f53\u524d\u8fdb\u6808\u5143\u7d20\u4e3a e\uff0c \u5bf9\u4e8e\u5355\u8c03\u9012\u589e\u6808\uff0c\u4ece\u6808\u9876\u5f00\u59cb\u904d\u5386\u5143\u7d20\uff0c\u628a\u5c0f\u4e8e e \u6216\u8005\u7b49\u4e8e e \u7684\u5143\u7d20\u5f39\u51fa\u6808\uff0c\u76f4\u81f3\u9047\u89c1\u4e00\u4e2a\u5927\u4e8e e \u7684\u5143\u7d20\u6216\u8005\u6808\u4e3a\u7a7a\u4e3a\u6b62\uff0c\u7136\u540e\u518d\u628a e \u538b\u5165\u6808\u4e2d\uff0c\u8fd9\u6837\u5c31\u80fd\u6ee1\u8db3\u4ece\u6808\u9876\u5230\u6808\u5e95\u7684\u5143\u7d20\u662f\u9012\u589e\u7684 \u5bf9\u4e8e\u5355\u8c03\u9012\u51cf\u6808\uff0c\u5219\u6bcf\u6b21\u5f39\u51fa\u7684\u662f\u5927\u4e8e e \u6216\u8005\u7b49\u4e8e e \u7684\u5143\u7d20\uff0c\u76f4\u81f3\u9047\u89c1\u4e00\u4e2a\u5c0f\u4e8ee\u7684\u5143\u7d20\u6216\u8005\u6808\u4e3a\u7a7a\u4e3a\u6b62 \u5355\u8c03\u6808\u7684\u4f5c\u7528\u5728\u4e8e \u5355\u8c03\u9012\u589e\u6808\u4ece\u6808\u9876\u5230\u6808\u5e95\u662f\u9012\u589e\u7684\uff0c\u6808\u4e2d\u4fdd\u7559\u7684\u90fd\u662f\u6bd4\u5f53\u524d\u5165\u6808\u5143\u7d20\u5927\u7684\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5feb\u901f\u627e\u5230\u5165\u6808\u5143\u7d20\u5de6\u8fb9\u6bd4\u4ed6\u5927\u7684\u5143\u7d20 \u5355\u8c03\u9012\u51cf\u6808\u4ece\u6808\u9876\u5230\u6808\u5e95\u662f\u9012\u51cf\u7684\uff0c\u6808\u4e2d\u4fdd\u7559\u7684\u90fd\u662f\u6bd4\u5f53\u524d\u5165\u6808\u5143\u7d20\u5c0f\u7684\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5feb\u901f\u627e\u5230\u5165\u6808\u5143\u7d20\u5de6\u8fb9\u6bd4\u4ed6\u5c0f\u7684\u5143\u7d20 \u5355\u8c03\u6808\u6c42\u533a\u95f4\u957f\u5ea6\u548c\u533a\u95f4\u6700\u5c0f\u503c\u4e58\u79ef\u6700\u5927\u503c\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll pos , val ; }; node s [ 2005000 ] = { 0 }; ll a [ 2005000 ] = { 0 }; int main () { ll n , top = 0 , ans = 0 ; scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); for ( int j = 1 ; j <= n + 1 ; j ++ ) { if ( top == 0 ) { s [ ++ top ] = { j , a [ j ]}; } else { while ( s [ top ]. val > a [ j ]) ///\u9012\u589e\u6808 { ll tmp = ( j - s [ top - 1 ]. pos - 1 ) * s [ top ]. val ; ans = max ( ans , tmp ); top -- ; } s [ ++ top ] = { j , a [ j ]}; } } printf ( \"%lld \\n \" , ans ); return 0 ; } \u7ebf\u6027\u57fa \u00b6 \u7ebf\u6027\u57fa\u6c42\u4ea4\uff0c\u53c2\u8003\u4e0e\uff1a https://blog.csdn.net/qcwlmqy/article/details/97584411 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; const int maxn = 50500 ; typedef long long ll ; class Bit_Set { public : ll d [ 32 ]; Bit_Set () { memset ( d , 0 , sizeof ( d )); } Bit_Set ( const Bit_Set & t ) { for ( int i = 0 ; i <= 31 ; i ++ ) d [ i ] = t . d [ i ]; } void clear () { memset ( d , 0 , sizeof ( d )); } void insert ( ll x ) { for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( ll ( 1 ) << i )) { if ( ! d [ i ]) { d [ i ] = x ; return ; } x ^= d [ i ]; } } } bool check ( ll x ) { for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( ll ( 1 ) << i )) { if ( ! d [ i ]) return false ; x ^= d [ i ]; } } return true ; } void show () { for ( int i = 0 ; i <= 31 ; i ++ ) cout << i << ' ' << d [ i ] << endl ; } friend Bit_Set operator + ( const Bit_Set & a , const Bit_Set & b ) { Bit_Set a_b ( a ), c , res ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( b . d [ i ]) { ll x = b . d [ i ], k = ll ( 1 ) << i ; bool flag = true ; for ( int j = 31 ; j >= 0 ; j -- ) { if ( x & ( ll ( 1 ) << j )) { if ( a_b . d [ j ]) { x ^= a_b . d [ j ]; k ^= c . d [ j ]; //\u5c06\u7528\u4e0a\u7684b\u5143\u7d20\u8ba1\u5165k } else { flag = false ; //\u82e5\u4e0d\u80fd\u88aba_b\u8868\u793a\uff0c\u5c06b[i]\u52a0\u5165\u6570\u7ec4 a_b . d [ j ] = x ; c . d [ j ] ^= k ; //\u5c06a_b\u4e2db\u5143\u7d20\u6807\u8bb0 break ; } } } if ( flag ) { ll x = 0 ; for ( int j = 31 ; j >= 0 ; j -- ) { if ( k & ( ll ( 1 ) << j )) x ^= b . d [ j ]; //\u5c06\u7528\u4e0a\u7684b\u5143\u7d20\u548c\u672c\u8eab\u7684b[i]\u5f02\u6216\u5728\u4e00\u8d77\uff0c //\u7531(a[argv---]^b[argv---]^b[i]==0),\u6240\u5f97\u5373\u4e3aV1\u7684\u8d21\u732e } res . insert ( x ); } } } return res ; } }; Bit_Set tree [ maxn << 2 ]; void build ( ll t , ll l , ll r ) { if ( l == r ) { int k ; ll x ; scanf ( \"%d\" , & k ); while ( k -- ) { scanf ( \"%lld\" , & x ); tree [ t ]. insert ( x ); } return ; } int mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); tree [ t ] = tree [ 2 * t ] + tree [ 2 * t + 1 ]; } int query ( ll t , ll l , ll r , ll L , ll R , ll x ) { if ( l <= L && R <= r ) { return tree [ t ]. check ( x ); } int flag = 1 ; int mid = ( L + R ) / 2 ; if ( l <= mid ) flag &= query ( 2 * t , l , r , L , mid , x ); if ( r > mid ) flag &= query ( 2 * t + 1 , l , r , mid + 1 , R , x ); return flag ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); build ( 1 , 1 , n ); while ( m -- ) { int l , r , x ; scanf ( \"%d%d%d\" , & l , & r , & x ); if ( query ( 1 , l , r , 1 , n , x )) puts ( \"YES\" ); else puts ( \"NO\" ); } } \u7ebf\u6027\u57fa\u57fa\u7840 \u6027\u8d28 \u5bf9\u4e8e\u4e00\u4e2a\u6570\u7ec4\uff0c\u5b58\u5728\u4e00\u4e9b\u6570\u6784\u6210\u8be5\u6570\u7ec4\u7684\u7ebf\u6027\u57fa \u7ebf\u6027\u57fa\u6709\u4e09\u5927\u5f88\u4f18\u7f8e\u7684\u6027\u8d28 \u6570\u7ec4\u4e2d\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531\u7ebf\u6027\u57fa\u4e2d\u90e8\u5206\u6570\u5f02\u6216\u5f97\u5230 \u6570\u7ec4\u4e2d\u6240\u6709\u6570\u5f02\u6216\u51fa\u6765\u5747\u4e0d\u4e3a0 \u5bf9\u4e8e\u540c\u4e00\u6570\u7ec4\u7ebf\u6027\u57fa\u4e2a\u6570\u552f\u4e00 \u4f8b\u5982 2 \uff0c4 \uff0c 5 \uff0c 6 ,\u7531\u7ebf\u6027\u57fa ,\u7531\u7ebf\u6027\u57fa 1 , 2 , 4 1 , 2 , 4 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 1,2,41,2,4 2 \uff0c4 \uff0c 5 \uff0c 6 <span class=\"arithmatex\"><span class=\"MathJax_Preview\">,\u7531\u7ebf\u6027\u57fa</span><script type=\"math/tex\">,\u7531\u7ebf\u6027\u57fa 1 , 2 , 4 1 , 2 , 4 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 1,2,41,2,4 \u5f02\u6216\u5f97\u5230 \u7ebf\u6027\u57fa\u6784\u9020 \u6570\u7ec4\u6bcf\u52a0\u5165\u4e00\u4e2a\u6570\uff0c\u5bf9\u7ebf\u6027\u57fa\u8fdb\u884c\u4fee\u6539 \u4ee4\u7ebf\u6027\u57fa\u4e3ad[32] ,\u6570\u7ec4\u957f\u5ea6\u4e3amax(a[i])\u7684\u6700\u5927\u4e8c\u8fdb\u5236\uff08\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531$ 1 , 2 , 4 \u22ef ,2^n$ \u8868\u793a\uff09 void add ( int x ) { for ( int i = 31 ; i >= 0 ; i -- ) { //i\u4e3a\u7ebf\u6027\u57fa\u4e0b\u6807 if ( x & ( 1 << i )) { if ( d [ i ]) x ^= d [ i ]; //\u82e5\u8be5\u4e8c\u8fdb\u5236\u4f4d\u5df2\u6709\u503c\uff0c\u5f02\u6216\u5bfb\u627e\u7ebf\u6027\u57fa\u80fd\u5426\u8868\u8fbex^d[i] else { d [ i ] = x ; //\u82e5\u4e8c\u8fdb\u5236\u4f4d\u6ca1\u6709\u503c\uff0c\u8bf4\u660ex\u4e0d\u80fd\u88ab\u7ebf\u6027\u57fa\u8868\u8fbe\uff0c\u4ee4d[i]=x break ; //\u8bb0\u5f97\u5982\u679c\u63d2\u5165\u6210\u529f\u4e00\u5b9a\u8981\u9000\u51fa } } } } \u6784\u9020\u5408\u7406\u6027\uff1a \u82e5\u80fd\u63d2\u5165x \uff0c\u5219\u5c06d[i] =x\uff0cx\u53ef\u4ee5\u7531\u7ebf\u6027\u57fa\u8868\u8fbe \u82e5\u4e0d\u80fd\u63d2\u5165x\uff0c\u5219x\u6700\u7ec8\u5f02\u6216\u4e3a0\uff0c\u5373\u53ef\u4ee5\u7531\u7ebf\u6027\u57fa\u8868\u8fbe \u533a\u95f4\u5f02\u6216\u6700\u5927\u503c \u6570\u7ec4 ( L , R ) ( L , R ) \u5185\u53d6\u82e5\u5e72\u4e2a\u6570\uff0c\u4f7f\u8fd9\u4e9b\u6570\u5f02\u6216\u540e\u5f97\u5230\u7684\u503c\u6700\u5927 \u4ee4 d [ 32 ] \u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c \u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c p [ 32 ]p [ 32 ] d [ 32 ] <span class=\"arithmatex\"><span class=\"MathJax_Preview\">\u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c</span><script type=\"math/tex\">\u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c p [ 32 ]p [ 32 ] \u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u4f4d\u7f6e\uff08\u4e3a\u4e86\u4fbf\u4e8e\u8be2\u95ee\uff0c\u4f4d\u7f6e\u5c3d\u91cf\u5b58\u504f\u53f3\u7684\uff09 int ask ( int l , int r ){ int res = 0 ; for \uff08 int i = 31 ; i >= 0 ; i -- \uff09 if ( p [ i ] >= l && ( res ^ d [ i ]) > res ) res ^= d [ i ]; return res ; } \u8d2a\u5fc3\uff1a\u9ad8\u4f4d\u80fd\u53d8\u62101\uff0c\u5c31\u53d8\u62101\uff08\u9ad8\u4f4d1\u6bd4\u4f4e\u4f4d\u90fd\u53d8\u62101\u90fd\u6709\u4ef7\u503c\uff09 \u533a\u95f4\u5f02\u6216\u7b2ck\u5927 \u5148\u5c06\u7ebf\u6027\u57fa\u5904\u7406\u6210$ 1 , 2 , 4 , \u22ef ,2^n$ \u7684\u4e8c\u8fdb\u5236\u8868\u8fbe\u5f62\u5f0f \u53bb\u9664\u4e3a0\u7684\u5f02\u6216\u503c\uff0c\u6bcf\u4e00\u4f4dd[i] =1 \u76f8\u5f53\u4e8e\u53ef\u4ee5\u8868\u8fbe\u7684\u4e8c\u8fdb\u5236\u4f4d\u6570\u589e\u52a0\u4e00\u4f4d void work () { //\u5c06\u7ebf\u6027\u57fa\u8f6c\u5316\u4e3a2\u8fdb\u5236 for ( int i = 1 ; i <= 31 ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) if ( d [ i ] & ( 1 << ( j -1 ))) d [ i ] ^= d [ j -1 ]; } int k_th ( int k ) { if ( k == 1 && tot < n ) return 0 ; //\u7279\u5224\u4e00\u4e0b\uff0c\u5047\u5982k=1\uff0c\u5e76\u4e14\u539f\u6765\u7684\u5e8f\u5217\u53ef\u4ee5\u5f02\u6216\u51fa0\uff0c\u5c31\u8981\u8fd4\u56de0\uff0c //tot\u8868\u793a\u7ebf\u6027\u57fa\u4e2d\u7684\u5143\u7d20\u4e2a\u6570\uff0cn\u8868\u793a\u5e8f\u5217\u957f\u5ea6 if ( tot < n ) k -- ; //\u7c7b\u4f3c\u4e0a\u9762\uff0c\u53bb\u63890\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a\u7ebf\u6027\u57fa\u4e2d\u53ea\u80fd\u5f02\u6216\u51fa\u4e0d\u4e3a0\u7684\u89e3 work (); int ans = 0 ; for ( int i = 0 ; i <= 31 ; i ++ ) if ( d [ i ] != 0 ) { if ( k & 1 ) ans ^= d [ i ]; k >>= 1 ; } } \u4e3b\u5e2d\u6811 \u00b6 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/zuzhiang/article/details/78173412 https://www.cnblogs.com/s1124yy/p/6258026.html https://blog.csdn.net/tianwei0822/article/details/79439054 \u4e3b\u5e2d\u6811\u7ef4\u62a4\u533a\u95f4\u7b2ck\u5927\u6570 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; int L [ 3200500 ] = { 0 }, R [ 3200500 ] = { 0 }, sum [ 3200500 ] = { 0 }; int tot = 0 ; int a [ 3200500 ] = { 0 }, hash1 [ 3200500 ] = { 0 }, T [ 3200500 ] = { 0 }; int build ( int l , int r ) { int root = ++ tot ; sum [ root ] = 0 ; if ( l < r ) { int mid = ( l + r ) / 2 ; L [ root ] = build ( l , mid ); R [ root ] = build ( mid + 1 , r ); } return root ; } int update ( int pre , int l , int r , int pos ) { int root = ++ tot ; L [ root ] = L [ pre ]; R [ root ] = R [ pre ]; sum [ root ] = sum [ pre ] + 1 ; if ( l < r ) { int mid = ( l + r ) / 2 ; if ( pos <= mid ) L [ root ] = update ( L [ pre ], l , mid , pos ); else R [ root ] = update ( R [ pre ], mid + 1 , r , pos ); } return root ; } int query ( int l1 , int r1 , int l , int r , int k ) //\u53c2\u6570\u5206\u522b\u4e3a\uff1a\u4e24\u9897\u7ebf\u6bb5\u6811\u6839\u8282\u70b9\u7684\u7f16\u53f7\uff0c\u5de6\u53f3\u7aef\u70b9\uff0c\u7b2ck\u5927 { if ( l >= r ) return l ; int mid = ( l + r ) / 2 ; int num = sum [ L [ r1 ]] - sum [ L [ l1 ]]; if ( num >= k ) return query ( L [ l1 ], L [ r1 ], l , mid , k ); else return query ( R [ l1 ], R [ r1 ], mid + 1 , r , k - num ); } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { tot = 0 ; int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]), hash1 [ i ] = a [ i ]; sort ( hash1 + 1 , hash1 + n + 1 ); int d = unique ( hash1 + 1 , hash1 + n + 1 ) - hash1 - 1 ; T [ 0 ] = build ( 1 , d ); for ( int i = 1 ; i <= n ; i ++ ) { int pos = lower_bound ( hash1 + 1 , hash1 + d + 1 , a [ i ]) - hash1 ; T [ i ] = update ( T [ i - 1 ], 1 , d , pos ); } for ( int i = 1 ; i <= m ; i ++ ) { int l , r , k ; scanf ( \"%d%d%d\" , & l , & r , & k ); int pos = query ( T [ l - 1 ], T [ r ], 1 , d , k ); printf ( \"%d \\n \" , hash1 [ pos ]); } } } \u67e5\u8be2\u533a\u95f4\u5185\u5c0f\u4e8e\u7b49\u4e8e\u7ed9\u5b9a\u7684K\u7684\u6570\u7684\u4e2a\u6570 \u9898\u76ee\u94fe\u63a5\uff1a https://acm.hdu.edu.cn/showproblem.php?pid=4417 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; int L [ 3200500 ] = { 0 }, R [ 3200500 ] = { 0 }, sum [ 3200500 ] = { 0 }; int tot = 0 ; int a [ 3200500 ] = { 0 }, hash1 [ 3200500 ] = { 0 }, T [ 3200500 ] = { 0 }; int build ( int l , int r ) { int root = ++ tot ; sum [ root ] = 0 ; if ( l < r ) { int mid = ( l + r ) / 2 ; L [ root ] = build ( l , mid ); R [ root ] = build ( mid + 1 , r ); } return root ; } int update ( int pre , int l , int r , int pos ) { int root = ++ tot ; L [ root ] = L [ pre ]; R [ root ] = R [ pre ]; sum [ root ] = sum [ pre ] + 1 ; if ( l < r ) { int mid = ( l + r ) / 2 ; if ( pos <= mid ) L [ root ] = update ( L [ pre ], l , mid , pos ); else R [ root ] = update ( R [ pre ], mid + 1 , r , pos ); } return root ; } int query ( int l1 , int r1 , int l , int r , int k ) { if ( k < hash1 [ l ]) return 0 ; if ( hash1 [ r ] <= k ) return sum [ r1 ] - sum [ l1 ]; int mid = ( l + r ) / 2 ; if ( k <= hash1 [ mid ]) { return query ( L [ l1 ], L [ r1 ], l , mid , k ); } else { int num = 0 ; num += sum [ L [ r1 ]] - sum [ L [ l1 ]]; num += query ( R [ l1 ], R [ r1 ], mid + 1 , r , k ); return num ; } } int main () { int t ; scanf ( \"%d\" , & t ); for ( int t1 = 1 ; t1 <= t ; t1 ++ ) { tot = 0 ; int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]), hash1 [ i ] = a [ i ]; sort ( hash1 + 1 , hash1 + n + 1 ); int d = unique ( hash1 + 1 , hash1 + n + 1 ) - hash1 - 1 ; T [ 0 ] = build ( 1 , d ); for ( int i = 1 ; i <= n ; i ++ ) { int pos = lower_bound ( hash1 + 1 , hash1 + d + 1 , a [ i ]) - hash1 ; T [ i ] = update ( T [ i - 1 ], 1 , d , pos ); } printf ( \"Case %d: \\n \" , t1 ); for ( int i = 1 ; i <= m ; i ++ ) { int l , r , k ; scanf ( \"%d%d%d\" , & l , & r , & k ); int ans = query ( T [ l ], T [ r + 1 ], 1 , d , k ); printf ( \"%d \\n \" , ans ); } } } ST\u8868 \u00b6 ST \u8868\u662f\u7528\u4e8e\u89e3\u51b3 \u53ef\u91cd\u590d\u8d21\u732e\u95ee\u9898 \u7684\u6570\u636e\u7ed3\u6784\u3002 \u53ef\u91cd\u590d\u8d21\u732e\u95ee\u9898 \u662f\u6307\u5bf9\u4e8e\u8fd0\u7b97 opt opt \uff0c\u6ee1\u8db3 x\\quad opt\\quad x = x x\\quad opt\\quad x = x \uff0c\u5219\u5bf9\u5e94\u7684\u533a\u95f4\u8be2\u95ee\u5c31\u662f\u4e00\u4e2a\u53ef\u91cd\u590d\u8d21\u732e\u95ee\u9898\u3002\u4f8b\u5982\uff0c\u6700\u5927\u503c\u6709 max(x,x)=x max(x,x)=x \uff0cgcd \u6709 gcd(x,x)=x gcd(x,x)=x \uff0c\u6240\u4ee5 RMQ \u548c\u533a\u95f4 GCD \u5c31\u662f\u4e00\u4e2a\u53ef\u91cd\u590d\u8d21\u732e\u95ee\u9898\u3002\u50cf\u533a\u95f4\u548c\u5c31\u4e0d\u5177\u6709\u8fd9\u4e2a\u6027\u8d28\uff0c\u5982\u679c\u6c42\u533a\u95f4\u548c\u7684\u65f6\u5019\u91c7\u7528\u7684\u9884\u5904\u7406\u533a\u95f4\u91cd\u53e0\u4e86\uff0c\u5219\u4f1a\u5bfc\u81f4\u91cd\u53e0\u90e8\u5206\u88ab\u8ba1\u7b97\u4e24\u6b21\uff0c\u8fd9\u662f\u6211\u4eec\u6240\u4e0d\u613f\u610f\u770b\u5230\u7684\u3002\u53e6\u5916\uff0c opt opt \u8fd8\u5fc5\u987b\u6ee1\u8db3\u7ed3\u5408\u5f8b\u624d\u80fd\u4f7f\u7528 ST \u8868\u6c42\u89e3\u3002 \u4e00\u7ef4ST\u8868\u6a21\u677f #include <stdio.h> #include <math.h> #define max(a, b) (a > b ? a : b) #define min(a, b) (a < b ? a : b) using namespace std ; int a [ 50050 ] = { 0 }, dp_max [ 50050 ][ 30 ] = { 0 }, dp_min [ 50050 ][ 30 ] = { 0 }; int n , m ; void st () { for ( int i = 1 ; i <= n ; i ++ ) dp_max [ i ][ 0 ] = dp_min [ i ][ 0 ] = a [ i ]; for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 1 ; i + ( 1 << j ) - 1 <= n ; i ++ ) { dp_max [ i ][ j ] = max ( dp_max [ i ][ j - 1 ], dp_max [ i + ( 1 << ( j - 1 ))][ j - 1 ]); dp_min [ i ][ j ] = min ( dp_min [ i ][ j - 1 ], dp_min [ i + ( 1 << ( j - 1 ))][ j - 1 ]); } } } int query_max ( int l , int r ) { int k = log2 ( r - l + 1 ); return max ( dp_max [ l ][ k ], dp_max [ r - ( 1 << k ) + 1 ][ k ]); } int query_min ( int l , int r ) { int k = log2 ( r - l + 1 ); return min ( dp_min [ l ][ k ], dp_min [ r - ( 1 << k ) + 1 ][ k ]); } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); st (); while ( m -- ) { int l , r ; scanf ( \"%d%d\" , & l , & r ); printf ( \"%d \\n \" , query_max ( l , r ) - query_min ( l , r )); } } \u4e00\u7ef4ST\u7ef4\u62a4GCD\u6a21\u677f \u9898\u76ee\u5927\u610f\u4e3a\u7ed9\u5b9a\u957f\u5ea6\u4e3an\u7684\u5e8f\u5217\uff0c\u540e\u9762\u53c8m\u6b21\u8be2\u95ee\uff0c\u8be2\u95ee\u6ee1\u8db3\u533a\u95f4gcd\u4e3a\u7ed9\u5b9a\u6570\u503c\u7684\u4e2a\u6570\u3002 \u7b97\u6cd5\u4e3a\u4e8c\u5206+ST\u8868\uff0c\u7531\u4e8e\u533a\u95f4\u4e2d\u4e0d\u540cGCD\u4e2a\u6570\u6700\u591a\u4e3alog\u4e2a\uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6 nlog(n) nlog(n) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }, dp [ 100500 ][ 30 ] = { 0 }; map < ll , ll > mp ; ll n , m , k ; void st () { for ( ll i = 1 ; i <= n ; i ++ ) dp [ i ][ 0 ] = a [ i ]; for ( ll j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( ll i = 1 ; i + ( 1 << j ) - 1 <= n ; i ++ ) { dp [ i ][ j ] = __gcd ( dp [ i ][ j - 1 ], dp [ i + ( 1 << ( j - 1 ))][ j - 1 ]); } } } ll query ( ll l , ll r ) { ll k = log2 ( r - l + 1 ); return __gcd ( dp [ l ][ k ], dp [ r - ( 1 << k ) + 1 ][ k ]); } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); st (); for ( ll i = 1 ; i <= n ; i ++ ) { ll cur = i , gc = a [ i ]; while ( cur <= n ) { ll l = cur , r = n ; while ( l < r ) { ll mid = ( l + r + 1 ) / 2 ; if ( query ( cur , mid ) == gc ) l = mid ; else r = mid - 1 ; } if ( mp . count ( gc ) == 0 ) mp [ gc ] = ( l - cur + 1 ); else mp [ gc ] += ( l - cur + 1 ); cur = l + 1 ; if ( cur <= n ) gc = __gcd ( gc , a [ cur ]); } } scanf ( \"%lld\" , & m ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & k ); printf ( \"%lld \\n \" , mp [ k ]); } return 0 ; } \u4e8c\u7ef4ST\u8868\u6a21\u677f #include <bits/stdc++.h> using namespace std ; int dp_max [ 300 ][ 300 ][ 20 ] = { 0 }; int dp_min [ 300 ][ 300 ][ 30 ] = { 0 }; int a [ 300 ][ 300 ] = { 0 }; int n , m ; void st () { for ( int i = 1 ; i <= n ; i ++ ) { for ( int k = 0 ; ( 1 << k ) <= m ; k ++ ) { for ( int j = 1 ; j + ( 1 << k ) - 1 <= m ; j ++ ) { if ( k == 0 ) dp_max [ i ][ j ][ k ] = dp_min [ i ][ j ][ k ] = a [ i ][ j ]; else { dp_max [ i ][ j ][ k ] = max ( dp_max [ i ][ j ][ k - 1 ], dp_max [ i ][ j + ( 1 << ( k - 1 ))][ k - 1 ]); dp_min [ i ][ j ][ k ] = min ( dp_min [ i ][ j ][ k - 1 ], dp_min [ i ][ j + ( 1 << ( k - 1 ))][ k - 1 ]); } } } } } int query_max ( int x , int y , int xx , int yy ) { int k = log2 ( yy - y + 1 ); int mm = 0 ; for ( int i = x ; i <= xx ; i ++ ) mm = max ( mm , max ( dp_max [ i ][ y ][ k ], dp_max [ i ][ yy - ( 1 << k ) + 1 ][ k ])); return mm ; } int query_min ( int x , int y , int xx , int yy ) { int k = log2 ( yy - y + 1 ); int mm = 0x3f3f3f3f ; for ( int i = x ; i <= xx ; i ++ ) mm = min ( mm , min ( dp_min [ i ][ y ][ k ], dp_min [ i ][ yy - ( 1 << k ) + 1 ][ k ])); return mm ; } int main () { int b , k ; scanf ( \"%d%d%d\" , & n , & b , & k ); m = n ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) scanf ( \"%d\" , & a [ i ][ j ]); st (); while ( k -- ) { int p , q ; scanf ( \"%d%d\" , & p , & q ); int ans1 = query_max ( p , q , p + b - 1 , q + b - 1 ); int ans2 = query_min ( p , q , p + b - 1 , q + b - 1 ); printf ( \"%d \\n \" , ans1 - ans2 ); } return 0 ; } \u5b57\u7b26\u4e32 \u00b6 KMP\u7b97\u6cd5 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; const ll N = 1005000 ; ll Next [ N ]; char s [ N ]; char t [ N ]; ll tlen , len ; void getNext ( char s [ N ]) { ll j = 0 , k = -1 ; Next [ 0 ] = -1 ; while ( j < tlen ) { if ( k == -1 || s [ j ] == s [ k ]) { Next [ ++ j ] =++ k ; } else k = Next [ k ]; } } int main () { while ( 1 ) { scanf ( \"%s\" , s ); if ( s [ 0 ] == '.' ) break ; tlen = strlen ( s ); len = tlen ; getNext ( s ); ll kk = tlen - Next [ tlen ]; if ( strlen ( s ) % kk == 0 ) { printf ( \"%d \\n \" , strlen ( s ) / kk ); } else { printf ( \"1 \\n \" ); //\u5982\u679c\u4e0d\u80fd\u9664\u5c3d\uff0c\u8bf4\u660e\u6709\u540e\u7f00\uff0c\u4f8b\u5982abababa\uff0c\u8fd9\u79cd\u60c5\u51b5\u53ea\u80fd\u4e3a1 } } return 0 ; } \u5b57\u7b26\u4e32\u54c8\u5e0c \u00b6 \u7ed9\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u5b57\u7b26\u4e32(1<=n<=200000),\u4ed6\u53ea\u5305\u542b**\u5c0f\u5199**\u5b57\u6bcd \u627e\u5230\u8fd9\u4e2a\u5b57\u7b26\u4e32\u591a\u5c11\u4e2a\u524d\u7f00\u662fM\u5f62\u5b57\u7b26\u4e32. M\u5f62\u5b57\u7b26\u4e32\u5b9a\u4e49\u5982\u4e0b: \u4ed6\u7531\u4e24\u4e2a\u76f8\u540c\u7684\u56de\u6587\u4e32\u62fc\u63a5\u800c\u6765,\u7b2c\u4e00\u4e2a\u56de\u6587\u4e32\u7684\u7ed3\u5c3e\u5b57\u7b26\u548c\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u4e32\u7684\u5f00\u59cb\u5b57\u7b26\u53ef\u4ee5\u91cd\u53e0,\u4e5f\u5c31\u662f\u4ee5\u4e0b\u90fd\u662fM \u5f62\u5b57\u7b26\u4e32. abccbaabccba(\u7531abccba+abccba\u7ec4\u6210) abcbaabcba(\u6709abcba+abcba\u7ec4\u6210) abccbabccba(\u7531abccba+abccba\u7ec4\u6210\u7ec4\u6210,\u4f46\u662f\u4e2d\u95f4\u76841\u662f\u5171\u7528\u7684) a(\u4e00\u4e2a\u5355\u72ec\u5b57\u7b26\u4e5f\u7b97) #include <bits/stdc++.h> using namespace std ; typedef unsigned long long int ULL ; const int N = 200010 ; int P = 131 ; ULL p [ N ], h [ N ], ed [ N ]; int ask1 ( int l , int r ) { return h [ r ] - h [ l - 1 ] * p [ r - l + 1 ]; } int ask2 ( int l , int r ) { return ed [ l ] - ed [ r + 1 ] * p [ r - l + 1 ]; } int main () { int ans = 0 ; char str [ N ]; cin >> str + 1 ; int n = strlen ( str + 1 ); p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { h [ i ] = h [ i - 1 ] * P + str [ i ]; p [ i ] = p [ i - 1 ] * P ; } for ( int i = n ; i >= 0 ; i -- ) { ed [ i ] = ed [ i + 1 ] * P + str [ i ]; } for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) { int x = ( i + 1 ) / 2 ; if ( ask1 ( 1 , x ) == ask1 ( x , i ) && ask1 ( 1 , x ) == ask2 ( 1 , x )) ans ++ ; } else { int x = i / 2 ; if ( ask1 ( 1 , x ) == ask1 ( x + 1 , i ) && ask1 ( 1 , x ) == ask2 ( 1 , x )) ans ++ ; } } cout << ans ; } \u56de\u6587\u4e32\u5339\u914d\u7b97\u6cd5\uff08\u9a6c\u62c9\u8f66\u7b97\u6cd5\uff09 \u00b6 #include <bits/stdc++.h> ///\u6c42\u89e3\u6700\u957f\u56de\u6587\u4e32\uff0c\u5bf9p[i]/2\u6c42\u548c\u5373\u53ef\u5f97\u56de\u6587\u4e32\u4e2a\u6570 using namespace std ; typedef long long ll ; char a [ 500500 ] = { 0 }; int l [ 500500 ] = { 0 }; int r [ 500500 ] = { 0 }; string str = \"$#\" ; vector < int > p ; void manacher ( char * c ) { int max_id = 0 , id = 0 ; for ( int i = 1 ; c [ i ]; i ++ ) str += c [ i ], str += \"#\" ; p . push_back ( 1 ); for ( int i = 1 ; i < ( int ) str . size (); i ++ ) { if ( max_id > i ) p . push_back ( min ( max_id - i , p [ 2 * id - i ])); else p . push_back ( 1 ); while ( i + p [ i ] < ( int ) str . size () && str [ i + p [ i ]] == str [ i - p [ i ]]) p [ i ] ++ ; if ( i + p [ i ] > max_id ){ max_id = i + p [ i ], id = i ; } } } int main () { scanf ( \"%s\" , a + 1 ); manacher ( a ); int now = 0 , n = str . size (), ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , p [ i ] -1 ); printf ( \"%d\" , ans ); } \u5b57\u5178\u6811 \u00b6 \u4ece\u4e00\u7ec4\u6570\u636e\u4e2d\u9009\u53d6\u4e24\u4e2a\u6570\u6c42\u6700\u5927\u5f02\u6216\u503c\u3002 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 1005000 ] = { 0 }; int tree [ 5000500 ][ 3 ] = { 0 }; int tot = 1 ; ///\u5fc5\u987b\u4ece1\u5f00\u59cb int in ( int x ) { int p = 1 ; for ( int i = 30 ; i >= 0 ; i -- ) { int k = x >> i & 1 ; if ( tree [ p ][ k ] == 0 ) tree [ p ][ k ] =++ tot ; p = tree [ p ][ k ]; } } int out ( int x ) { int p = 1 , ans = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { int k = x >> i & 1 ; if ( tree [ p ][ ! k ]) { ans = ans * 2 +! k ; p = tree [ p ][ ! k ]; } else { ans = ans * 2 + k ; p = tree [ p ][ k ]; } } return ans ; } int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { in ( a [ i ]); int num = out ( a [ i ]); max1 = max ( max1 , num ^ a [ i ]); } cout << max1 << endl ; return 0 ; } \u6587\u6cd5\u5206\u6790 \u00b6 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/qq_40736036/article/details/89110584 #include <bits/stdc++.h> using namespace std ; typedef unsigned long long ull ; typedef long long ll ; const ll mod = 10000 ; char c [ 5000500 ] = { 0 }; struct grammer { pair < char * , ll > Q ( char * p ) { pair < char * , ll > ans1 = E ( p ); if ( ans1 . first == NULL ) return { NULL , 0 }; ans1 . second %= mod ; return ans1 ; } pair < char * , ll > E ( char * p ) { pair < char * , ll > ans1 = T ( p ); if ( ans1 . first == NULL ) return { NULL , 0 }; while ( * ans1 . first == '+' || * ans1 . first == '-' ) { pair < char * , ll > ans2 = T ( ans1 . first + 1 ); if ( ans2 . first == NULL ) return { NULL , 0 }; if ( * ans1 . first == '+' ) ans1 . second += ans2 . second ; else if ( * ans1 . first == '-' ) ans1 . second -= ans2 . second ; ans1 . second = ( ans1 . second % mod + mod ) % mod ; ans1 . first = ans2 . first ; } return ans1 ; } pair < char * , ll > T ( char * p ) { pair < char * , ll > ans1 = F ( p ); if ( ans1 . first == NULL ) return { NULL , 0 }; while ( * ans1 . first == '*' ) { pair < char * , ll > ans2 = F ( ans1 . first + 1 ); if ( ans2 . first == NULL ) return { NULL , 0 }; ans1 . second *= ans2 . second ; ans1 . second %= mod ; ans1 . first = ans2 . first ; } return ans1 ; } pair < char * , ll > F ( char * p ) { if ( * p >= '0' || * p <= '9' ) { return N ( p ); } else if ( * p == '-' ) { pair < char * , ll > ans1 = F ( p + 1 ); if ( ans1 . first == NULL ) return { NULL , 0 }; return { ans1 . first , ( - ans1 . second % mod + mod ) % mod }; } else if ( * p == '(' ) { pair < char * , ll > ans1 = E ( p + 1 ); if ( ans1 . first == NULL ) return { NULL , 0 }; if ( * ans1 . first == ')' ) return { ans1 . first + 1 , ans1 . second % mod }; else return { NULL , 0 }; } else { return { NULL , 0 }; } } pair < char * , ll > N ( char * p ) { if ( * p == '0' ) { // if (*(p + 1) >= '0' || *(p + 1) <= '9') // return {NULL, 0}; // else return { p + 1 , 0 }; } else if ( * p >= '1' && * p <= '9' ) { pair < char * , ll > ans1 = B ( p ); if ( ans1 . first == NULL ) { return { NULL , 0 }; } return { ans1 . first , ans1 . second % mod }; } else { return { NULL , 0 }; } } pair < char * , ll > B ( char * p ) { ll sum = 0 ; while ( * p >= '0' && * p <= '9' ) { sum = sum * 10 + * p - '0' ; p ++ ; sum %= mod ; } return { p , sum % mod }; } } Grammer ; int main () { scanf ( \"%s\" , c + 1 ); ll ans = ( Grammer . Q ( c + 1 ). second % mod + mod ) % mod ; printf ( \"%lld \\n \" , ans ); } AC\u81ea\u52a8\u673a \u00b6 \u53c2\u8003\u94fe\u63a5\uff1a https://www.cnblogs.com/nullzx/p/7499397.html https://zhuanlan.zhihu.com/p/80325757 https://oi-wiki.org/string/ac-automaton/ AC\u81ea\u52a8\u673a\u6a21\u677f\uff1a \u7ed9\u5b9a n n \u4e2a\u6a21\u5f0f\u4e32 s_i s_i \u548c\u4e00\u4e2a\u6587\u672c\u4e32 t t \uff0c\u6c42\u6709\u591a\u5c11\u4e2a\u4e0d\u540c\u7684\u6a21\u5f0f\u4e32\u5728\u6587\u672c\u4e32\u91cc\u51fa\u73b0\u8fc7\u3002 \u4e24\u4e2a\u6a21\u5f0f\u4e32\u4e0d\u540c\u5f53\u4e14\u4ec5\u5f53\u4ed6\u4eec**\u7f16\u53f7**\u4e0d\u540c\u3002 #include <bits/stdc++.h> using namespace std ; const int N = 1e6 + 6 ; int n ; namespace AC { int tr [ N ][ 26 ], tot ; int e [ N ], fail [ N ]; void insert ( char * s ) { int u = 0 ; for ( int i = 1 ; s [ i ]; i ++ ) { if ( ! tr [ u ][ s [ i ] - 'a' ]) tr [ u ][ s [ i ] - 'a' ] = ++ tot ; //\u5982\u679c\u6ca1\u6709\u5219\u63d2\u5165\u65b0\u8282\u70b9 u = tr [ u ][ s [ i ] - 'a' ]; //\u641c\u7d22\u4e0b\u4e00\u4e2a\u8282\u70b9 } e [ u ] ++ ; //\u5c3e\u4e3a\u8282\u70b9 u \u7684\u4e32\u7684\u4e2a\u6570 } queue < int > q ; void build () { for ( int i = 0 ; i < 26 ; i ++ ) if ( tr [ 0 ][ i ]) q . push ( tr [ 0 ][ i ]); while ( q . size ()) { int u = q . front (); q . pop (); for ( int i = 0 ; i < 26 ; i ++ ) { if ( tr [ u ][ i ]) { fail [ tr [ u ][ i ]] = tr [ fail [ u ]][ i ]; // fail\u6570\u7ec4\uff1a\u540c\u4e00\u5b57\u7b26\u53ef\u4ee5\u5339\u914d\u7684\u5176\u4ed6\u4f4d\u7f6e q . push ( tr [ u ][ i ]); } else tr [ u ][ i ] = tr [ fail [ u ]][ i ]; } } } int query ( char * t ) { int u = 0 , res = 0 ; for ( int i = 1 ; t [ i ]; i ++ ) { u = tr [ u ][ t [ i ] - 'a' ]; // \u8f6c\u79fb for ( int j = u ; j && e [ j ] != -1 ; j = fail [ j ]) { res += e [ j ], e [ j ] = -1 ; } } return res ; } } // namespace AC char s [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , s + 1 ), AC :: insert ( s ); scanf ( \"%s\" , s + 1 ); AC :: build (); printf ( \"%d\" , AC :: query ( s )); return 0 ; } \u6b63\u5219\u8868\u8fbe\u5f0f \u00b6 \u53c2\u8003\u4e8e\uff1a https://www.cnblogs.com/luowentao/p/10332311.html 1.\u89c4\u5219 {n}\u5339\u914d\u786e\u5b9a\u7684n\u6b21 {n,}\u81f3\u5c11\u5339\u914dn\u6b21(\u6ce8:\u8bf7\u4e0d\u8981\u64c5\u81ea\u52a0\u7a7a\u683c\u4e0a\u53bb) {n,m}\u6700\u5c11n\u6b21,\u6700\u591am\u6b21. *\u5339\u914d\u524d\u9762\u7684\u5b50\u8868\u8fbe\u5f0f0\u6b21\u6216\u591a\u6b21 = {0,} +\u5339\u914d\u524d\u9762\u7684\u5b50\u8868\u8fbe\u5f0f1\u6b21\u6216\u591a\u6b21 = {1,} ?\u5339\u914d\u524d\u9762\u7684\u5b50\u8868\u8fbe\u5f0f1\u6b21\u6216\u4e24\u6b21 = {1,2} ()\u8868\u793a\u4e00\u4e2a\u6574\u4f53 []\u8868\u793a\u4e00\u4f4d {}\u8868\u793a\u5339\u914d\u591a\u5c11\u6b21 .\u5339\u914d\u9664\u6362\u884c\u7b26\u4e4b\u5916\u7684\u4efb\u610f\u5b57\u7b26 \\w\u5339\u914d\u5355\u5b57\u5b57\u7b26(a-z,A-Z,0-9\u4ee5\u53ca\u4e0b\u5212\u7ebf) \\W\u5339\u914d\u975e\u5355\u5b57\u5b57\u7b26 \\s\u5339\u914d\u7a7a\u767d\u5b57\u7b26(\u7a7a\u683c,\u5236\u8868\u7b26,\u6362\u884c\u7b26) \\S\u5339\u914d\u975e\u7a7a\u767d\u5b57\u7b26 \\d\u5339\u914d\u6570\u5b57\u5b57\u7b26 \\D\u5339\u914d\u975e\u6570\u5b57\u5b57\u7b26 ^\u6307\u793a\u4ece\u884c\u7684\u5f00\u59cb\u4f4d\u7f6e\u5f00\u59cb\u5339\u914d(\u8fd8\u6709\u58f0\u660e\u4e0d\u5728\u5b57\u7b26\u96c6\u6307\u5b9a\u8303\u56f4\u5185) $\u6307\u793a\u4ece\u884c\u7684\u7ed3\u675f\u4f4d\u7f6e\u5f00\u59cb\u5339\u914d \\b\u5339\u914d\u5355\u8bcd\u7684\u5f00\u59cb\u6216\u7ed3\u675f\u4f4d\u7f6e 2.\u901f\u8bb0\u7406\u89e3 . [ ] ^ $\u56db\u4e2a\u5b57\u7b26\u662f\u6240\u6709\u8bed\u8a00\u90fd\u652f\u6301\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\uff0c\u6240\u4ee5\u8fd9\u56db\u4e2a\u662f\u57fa\u7840\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u3002\u6b63\u5219\u96be\u7406\u89e3\u56e0\u4e3a\u91cc\u9762\u6709\u4e00\u4e2a\u7b49\u4ef7\u7684\u6982\u5ff5\uff0c\u8fd9\u4e2a\u6982\u5ff5\u5927\u5927\u589e\u52a0\u4e86\u7406\u89e3\u96be\u5ea6\uff0c\u8ba9\u5f88\u591a\u521d\u5b66\u8005\u770b\u8d77\u6765\u4f1a\u61f5\uff0c\u5982\u679c\u628a\u7b49\u4ef7\u90fd\u6062\u590d\u6210\u539f\u59cb\u5199\u6cd5\uff0c\u81ea\u5df1\u4e66\u5199\u6b63\u5219\u5c31\u8d85\u7ea7\u7b80\u5355\u4e86\uff0c\u5c31\u50cf\u8bf4\u8bdd\u4e00\u6837\u53bb\u5199\u4f60\u7684\u6b63\u5219\u4e86\uff1a \u7b49\u4ef7\uff1a \u7b49\u4ef7\u662f\u7b49\u540c\u4e8e\u7684\u610f\u601d\uff0c\u8868\u793a\u540c\u6837\u7684\u529f\u80fd\uff0c\u7528\u4e0d\u540c\u7b26\u53f7\u6765\u4e66\u5199\u3002 ?,*,+,\\d,\\w \u90fd\u662f\u7b49\u4ef7\u5b57\u7b26 \u3000\u3000?\u7b49\u4ef7\u4e8e\u5339\u914d\u957f\u5ea6{0,1} \u3000\u3000*\u7b49\u4ef7\u4e8e\u5339\u914d\u957f\u5ea6{0,} \u3000\u3000+\u7b49\u4ef7\u4e8e\u5339\u914d\u957f\u5ea6{1,} \u3000\u3000\\d\u7b49\u4ef7\u4e8e[0-9] \\D\u7b49\u4ef7\u4e8e[^0-9] \\w\u7b49\u4ef7\u4e8e[A-Za-z_0-9] \\W\u7b49\u4ef7\u4e8e[^A-Za-z_0-9]\u3002 \u5e38\u7528\u8fd0\u7b97\u7b26\u4e0e\u8868\u8fbe\u5f0f\uff1a \u3000\u3000^ \u5f00\u59cb \u3000\u3000() \u57df\u6bb5 \u3000\u3000[] \u5305\u542b,\u9ed8\u8ba4\u662f\u4e00\u4e2a\u5b57\u7b26\u957f\u5ea6 \u3000\u3000[^] \u4e0d\u5305\u542b,\u9ed8\u8ba4\u662f\u4e00\u4e2a\u5b57\u7b26\u957f\u5ea6 \u3000\u3000{n,m} \u5339\u914d\u957f\u5ea6 \u3000\u3000. \u4efb\u4f55\u5355\u4e2a\u5b57\u7b26(\\. \u5b57\u7b26\u70b9) \u3000\u3000| \u6216 \u3000\u3000\\ \u8f6c\u4e49 \u3000\u3000$ \u7ed3\u5c3e \u3000\u3000[A-Z] 26\u4e2a\u5927\u5199\u5b57\u6bcd \u3000\u3000[a-z] 26\u4e2a\u5c0f\u5199\u5b57\u6bcd \u3000\u3000[0-9] 0\u81f39\u6570\u5b57 [A-Za-z0-9] 26\u4e2a\u5927\u5199\u5b57\u6bcd\u300126\u4e2a\u5c0f\u5199\u5b57\u6bcd\u548c0\u81f39\u6570\u5b57 , \u5206\u5272 \u3000\u3000\u5206\u5272\u8bed\u6cd5\uff1a \u3000\u3000[A,H,T,W] \u5305\u542bA\u6216H\u6216T\u6216W\u5b57\u6bcd \u3000\u3000[a,h,t,w] \u5305\u542ba\u6216h\u6216t\u6216w\u5b57\u6bcd \u3000\u3000[0,3,6,8] \u5305\u542b0\u62163\u62166\u62168\u6570\u5b57 \u8bed\u6cd5\u4e0e\u91ca\u4e49\uff1a \u3000\u3000\u57fa\u7840\u8bed\u6cd5 \"^([]{})([]{})([]{})$\" \u3000\u3000\u6b63\u5219\u5b57\u7b26\u4e32 = \"\u5f00\u59cb\uff08[\u5305\u542b\u5185\u5bb9]{\u957f\u5ea6}\uff09\uff08[\u5305\u542b\u5185\u5bb9]{\u957f\u5ea6}\uff09\uff08[\u5305\u542b\u5185\u5bb9]{\u957f\u5ea6}\uff09\u7ed3\u675f\" \u3000\u3000 \u3000\u3000?,*,+,\\d,\\w \u8fd9\u4e9b\u90fd\u662f\u7b80\u5199\u7684,\u5b8c\u5168\u53ef\u4ee5\u7528[]\u548c{}\u4ee3\u66ff\uff0c\u5728(?:)(?=)(?!)(?<=)(?<!)(?i)(*?)(+?)\u8fd9\u79cd\u7279\u6b8a\u7ec4\u5408\u60c5\u51b5\u4e0b\u9664\u5916\u3002 \u3000\u3000\u521d\u5b66\u8005\u53ef\u4ee5\u5ffd\u7565?,*,+,\\d,\\w\u4e00\u4e9b\u7b80\u5199\u6807\u793a\u7b26\uff0c\u5b66\u4f1a\u4e86\u57fa\u7840\u4f7f\u7528\u518d\u6309\u8868\u81ea\u5df1\u53bb\u7b49\u4ef7\u66ff\u6362 \u3000\u3000 \u3000\u3000\u5b9e\u4f8b\uff1a \u3000\u3000\u5b57\u7b26\u4e32\uff1btel:086-0666-88810009999 \u3000\u3000\u539f\u59cb\u6b63\u5219\uff1a\"^tel:[0-9]{1,3}-[0][0-9]{2,3}-[0-9]{8,11}$\" \u3000\u3000\u901f\u8bb0\u7406\u89e3\uff1a\u5f00\u59cb \"tel:\u666e\u901a\u6587\u672c\"[0-9\u6570\u5b57]{1\u81f33\u4f4d}\"-\u666e\u901a\u6587\u672c\"[0\u6570\u5b57][0-9\u6570\u5b57]{2\u81f33\u4f4d}\"-\u666e\u901a\u6587\u672c\"[0-9\u6570\u5b57]{8\u81f311\u4f4d} \u7ed3\u675f\" \u3000\u3000\u7b49\u4ef7\u7b80\u5199\u540e\u6b63\u5219\u5199\u6cd5\uff1a\"^tel:\\d{1,3}-[0]\\d{2,3}-\\d{8,11}$\" \uff0c\u7b80\u5199\u8bed\u6cd5\u4e0d\u662f\u6240\u6709\u8bed\u8a00\u90fd\u652f\u6301\u3002 3.\u4ee3\u7801\u5b9e\u4f8b 3.1 \u793a\u4f8b\u4e00 // \u5b9a\u4e49\u4e00\u4e2a\u6b63\u5219\u8868\u8fbe\u5f0f , 4~23 \u4f4d\u6570\u5b57\u548c\u5b57\u6bcd\u7684\u7ec4\u5408 regex repPattern(\"[0-9a-zA-Z]{4,23}\",regex_constants::extended); // \u58f0\u660e\u5339\u914d\u7ed3\u679c\u53d8\u91cf match_results<string::const_iterator> rerResult; // \u5b9a\u4e49\u5f85\u5339\u914d\u7684\u5b57\u7b26\u4e32 string strValue = \"123abc\"; // \u8fdb\u884c\u5339\u914d bool bValid = regex_match(strValue, rerResult, repPattern); if (bValid) { // \u5339\u914d\u6210\u529f } 3.2 \u793a\u4f8b\u4e8c #include <bits/stdc++.h> using namespace std; regex r(\"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5]):(\\\\d|[1-9]\\\\d{1,3}|[1-5]\\\\d{4}|6[0-4]\\\\d{3}|65[0-4]\\\\d{2}|655[0-2]\\\\d|6553[0-5])\"); int main() { String a; cin >> a; if (!regex_match(b, r)) puts(\"No\"); else puts(\"Yes\"); } 4.\u5e38\u7528\u7684\u6b63\u5219\u8868\u8fbe\u5f0f 4.1 \u68c0\u9a8c\u6570\u5b57\u7684\u8868\u8fbe\u5f0f \u6570\u5b57 : ^[0-9]*$ n \u4f4d\u7684\u6570\u5b57 : ^\\d{n}$ \u81f3\u5c11 n \u4f4d\u7684\u6570\u5b57 : ^\\d{n,}$ m-n \u4f4d\u7684\u6570\u5b57 : ^\\d{m,n}$ \u96f6\u548c\u975e\u96f6\u5f00\u5934\u7684\u6570\u5b57 : ^(0|[1-9][0-9]*)$ \u975e\u96f6\u5f00\u5934\u7684\u6700\u591a\u5e26\u4e24\u4f4d\u5c0f\u6570\u7684\u6570\u5b57 : ^([1-9][0-9]*)+(.[0-9]{1,2})?$ \u5e26 1~2 \u4f4d\u5c0f\u6570\u7684\u6b63\u6570\u6216\u8d1f\u6570 : ^(\\-)?\\d+(\\.\\d{1,2})?$ \u6b63\u6570 , \u8d1f\u6570 , \u548c\u5c0f\u6570 : ^(\\-|\\+)?\\d+(\\.\\d+)?$ \u6709\u4e24\u4f4d\u5c0f\u6570\u7684\u6b63\u5b9e\u6570 : ^[0-9]+(.[0-9]{2})?$ \u6709 1~3 \u4f4d\u5c0f\u6570\u7684\u6b63\u5b9e\u6570 : ^[0-9]+(.[0-9]{1,3})?$ \u975e\u96f6\u7684\u6b63\u6574\u6570 : ^[1-9]\\d*$ \u6216 ^([1-9][0-9]*){1,3}$ \u6216 ^\\+?[1-9][0-9]*$ \u975e\u96f6\u7684\u8d1f\u6574\u6570 : ^\\-[1-9][]0-9\u2033*$ \u6216 ^-[1-9]\\d*$ \u975e\u8d1f\u6574\u6570 : ^\\d+$ \u6216 ^[1-9]\\d*|0$ \u975e\u6b63\u6574\u6570 : ^-[1-9]\\d*|0$ \u6216 ^((-\\d+)|(0+))$ \u975e\u8d1f\u6d6e\u70b9\u6570 : ^\\d+(\\.\\d+)?$ \u6216 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ \u975e\u6b63\u6d6e\u70b9\u6570 : ^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ \u6216 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ \u6b63\u6d6e\u70b9\u6570 : ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ \u6216 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ \u8d1f\u6d6e\u70b9\u6570 : ^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ \u6216 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ \u6d6e\u70b9\u6570 : ^(-?\\d+)(\\.\\d+)?$ \u6216 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 4.2 \u68c0\u9a8c\u5b57\u7b26\u7684\u8868\u8fbe\u5f0f \u6c49\u5b57 : ^[\\u4e00-\\u9fa5]{0,}$ \u82f1\u6587\u548c\u6570\u5b57 : ^[A-Za-z0-9]+$ \u6216 ^[A-Za-z0-9]{4,40}$ \u957f\u5ea6\u4e3a 3~20 \u7684\u6240\u6709\u5b57\u7b26 : ^.{3,20}$ \u7531 26 \u4e2a\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32 : ^[A-Za-z]+$ \u7531 26 \u4e2a\u5927\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32 : ^[A-Z]+$ \u7531 26 \u4e2a\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32 : ^[a-z]+$ \u7531\u6570\u5b57\u548c 26 \u4e2a\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32 : ^[A-Za-z0-9]+$ \u7531\u6570\u5b57 , 26 \u4e2a\u82f1\u6587\u5b57\u6bcd\u6216\u8005\u4e0b\u5212\u7ebf\u7ec4\u6210\u7684\u5b57\u7b26\u4e32 : ^\\w+$ \u6216 ^\\w{3,20}$ \u4e2d\u6587 , \u82f1\u6587 , \u6570\u5b57\u5305\u62ec\u4e0b\u5212\u7ebf : ^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ \u4e2d\u6587 , \u82f1\u6587 , \u6570\u5b57\u4f46\u4e0d\u5305\u62ec\u4e0b\u5212\u7ebf\u7b49\u7b26\u53f7 : ^[\\u4E00-\\u9FA5A-Za-z0-9]+$ \u6216 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ \u53ef\u4ee5\u8f93\u5165\u542b\u6709^%&',;=?$\\\"\u7b49\u5b57\u7b26 : [^%&',;=?$\\x22]+ \u7981\u6b62\u8f93\u5165\u542b\u6709 ~ \u7684\u5b57\u7b26 : [^~\\x22]+ 4.3 \u7279\u6b8a\u9700\u6c42\u8868\u8fbe\u5f0f Email \u5730\u5740 : ^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ \u57df\u540d : [a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL : [a-zA-z]+://[^\\s]* \u6216 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$ \u624b\u673a\u53f7\u7801 : ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ \u7535\u8bdd\u53f7\u7801(\"XXX-XXXXXXX\" , \"XXXX-XXXXXXXX\" , \"XXX-XXXXXXX\" , \"XXX-XXXXXXXX\" , \"XXXXXXX\"\u548c\"XXXXXXXX) : ^($$\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ \u56fd\u5185\u7535\u8bdd\u53f7\u7801 (0511-4405222 , 021-87888822) : \\d{3}-\\d{8}|\\d{4}-\\d{7} \u8eab\u4efd\u8bc1\u53f7 (15 \u4f4d , 18 \u4f4d\u6570\u5b57) : ^\\d{15}|\\d{18}$ \u77ed\u8eab\u4efd\u8bc1\u53f7\u7801 (\u6570\u5b57 , \u5b57\u6bcd x \u7ed3\u5c3e) : ^([0-9]){7,18}(x|X)?$ \u6216 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ \u5e10\u53f7\u662f\u5426\u5408\u6cd5(\u5b57\u6bcd\u5f00\u5934\uff0c\u5141\u8bb8 5~16 \u5b57\u8282\uff0c\u5141\u8bb8\u5b57\u6bcd\u6570\u5b57\u4e0b\u5212\u7ebf) : ^[a-zA-Z][a-zA-Z0-9_]{4,15}$ \u5bc6\u7801 (\u4ee5\u5b57\u6bcd\u5f00\u5934\uff0c\u957f\u5ea6\u5728 6~18 \u4e4b\u95f4\uff0c\u53ea\u80fd\u5305\u542b\u5b57\u6bcd , \u6570\u5b57\u548c\u4e0b\u5212\u7ebf) : ^[a-zA-Z]\\w{5,17}$ \u5f3a\u5bc6\u7801 (\u5fc5\u987b\u5305\u542b\u5927\u5c0f\u5199\u5b57\u6bcd\u548c\u6570\u5b57\u7684\u7ec4\u5408\uff0c\u4e0d\u80fd\u4f7f\u7528\u7279\u6b8a\u5b57\u7b26\uff0c\u957f\u5ea6\u5728 8~10 \u4e4b\u95f4) : ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ \u65e5\u671f\u683c\u5f0f : ^\\d{4}-\\d{1,2}-\\d{1,2} \u4e00\u5e74\u7684 12 \u4e2a\u6708(01\uff5e09\u548c1\uff5e12) : ^(0?[1-9]|1[0-2])$ \u4e00\u4e2a\u6708\u7684 31 \u5929(01\uff5e09\u548c1\uff5e31) : ^((0?[1-9])|((1|2)[0-9])|30|31)$ \u6570\u8bba \u00b6 \u6574\u6570\u5206\u5757 \u00b6 \u4ee3\u7801\u5b9e\u73b0\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n , ans = 0 ; scanf ( \"%lld\" , & n ); for ( ll l = 1 , r ; l <= n ; l = r + 1 ) { r = n / ( n / l ); ans += ( r - l + 1 ) * ( n / l ); } printf ( \"%lld \\n \" , ans ); } \u7ebf\u6027\u7b5b\u6c42\u8d28\u56e0\u6570\u7684\u4e2a\u6570 \u00b6 ///\u53c2\u7167\u4e8e\uff1a //https://www.luogu.com.cn/blog/SuuTTT/solution%2Dp1029 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; const ll maxn = 1e7 + 5 ; ll low_prime [ 10050000 ] = { 0 }; ll prime [ 700500 ] = { 0 }; ll cnt = 0 ; int main () { for ( ll i = 2 ; i <= maxn ; i ++ ) { if ( low_prime [ i ] == 0 ) { low_prime [ i ] = i ; prime [ ++ cnt ] = i ; } for ( ll j = 1 ; j <= cnt && prime [ j ] * i <= maxn ; j ++ ) { low_prime [ prime [ j ] * i ] = prime [ j ]; if ( i % prime [ j ] == 0 ) break ; } } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , flag = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { ll m , sum = 0 ; scanf ( \"%lld\" , & m ); while ( m > 1 ) { m /= low_prime [ m ]; sum ++ ; } flag ^= sum ; ///sum\u5373\u4e3a\u8d28\u56e0\u6570\u7684\u4e2a\u6570 } if ( ! flag ) puts ( \"Bob\" ); else puts ( \"Alice\" ); } } \u6b27\u62c9\u51fd\u6570\u6a21\u677f \u00b6 #include <bits/stdc++.h> using namespace std ; int is_prime [ 100500 ] = { 0 }; vector < int > prime ; int oula_table [ 100500 ] = { 0 }; void init ( int n ) ///\u6253\u7d20\u6570\u8868 { for ( int i = 2 ; i <= n ; i ++ ) { if ( ! is_prime [ i ]) prime . push_back ( i ); for ( int j = 0 ; j <= prime . size () && i * prime [ j ] <= n ; j ++ ) { is_prime [ i * prime [ j ]] = 1 ; if ( i % prime [ j ] == 0 ) break ; } } } int oula1 ( int n ) ///\u6839\u636e\u7d20\u6570\u8868\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int ans = n ; for ( int i = 0 ; prime [ i ] * prime [ i ] <= n ; i ++ ) { if ( n % prime [ i ] == 0 ) ans = ans - ans / prime [ i ]; while ( n % prime [ i ] == 0 ) n /= prime [ i ]; } return ans ; } int oula2 ( int n ) ///\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int m = n ; int ans = n ; for ( int i = 2 ; i <= sqrt ( n ); i ++ ) { if ( m % i == 0 ) ans = ans - ans / i ; while ( m % i == 0 ) m /= i ; } if ( m != 1 ) ans = ans - ans / m ; return ans ; } void get_oula_table ( int n ) ///\u6b27\u62c9\u6253\u8868 { for ( int i = 1 ; i <= n ; i ++ ) oula_table [ i ] = 0 ; oula_table [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! oula_table [ i ]) ///\u8bf4\u660ei\u662f\u8d28\u6570 { for ( int j = i ; j <= n ; j += i ) //\u53bb\u627ei\u7684\u500d\u6570 { if ( ! oula_table [ j ]) oula_table [ j ] = j ; oula_table [ j ] = oula_table [ j ] / i * ( i -1 ); } } } } int main () { int n ; cin >> n ; init ( n ); cout << \"\u627e\u7d20\u6570\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula1 ( n ) << endl ; cout << \"\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula2 ( n ) << endl ; get_oula_table ( n ); cout << \"\u6253\u8868\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" ; for ( int i = 1 ; i <= n ; i ++ ) cout << oula_table [ i ] << ' ' ; } \u9006\u5e8f\u5bf9 \u00b6 #include <iostream> #include <bits/stdc++.h> using namespace std ; int a [ 2005000 ] = { 0 }; int b [ 2005000 ] = { 0 }; long long int merge_sort ( long long int l , long long int r ) { if ( l >= r ) return 0 ; long long int mid = ( l + r ) >> 1 , res = 0 ; res += merge_sort ( l , mid ); res += merge_sort ( mid + 1 , r ); long long int i = l , j = mid + 1 , cnt = 0 ; while ( i <= mid && j <= r ) if ( a [ i ] <= a [ j ]) b [ cnt ++ ] = a [ i ++ ]; else { res += mid - i + 1 ; b [ cnt ++ ] = a [ j ++ ]; } while ( i <= mid ) b [ cnt ++ ] = a [ i ++ ]; while ( j <= r ) b [ cnt ++ ] = a [ j ++ ]; for ( long long int i = l , j = 0 ; j < cnt ; ++ i , ++ j ) a [ i ] = b [ j ]; return res ; } int main () { int n ; cin >> n ; for ( long long int i = 0 ; i < n ; i ++ ) { cin >> a [ i ]; } long long int sum = merge_sort ( 0 , n -1 ); cout << sum << endl ; return 0 ; } #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n , m ; ll a [ 100500 ] = { 0 }; ll c [ 100500 ] = { 0 }; ll maxn = 10050 , k , ans = 0 ; ll lowbit ( ll x ) { return x & ( - x ); } ll add ( ll k , ll x ) { for ( ll i = k ; i <= maxn ; i += lowbit ( i )) c [ i ] += x ; } ll getsum ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c [ i ]; return ans ; } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & k ); add ( k , 1 ); ans += i - getsum ( k ); } printf ( \"%d \\n \" , ans ); } \u4e8c\u7ef4\u524d\u7f00\u548c \u00b6 #include <bits/stdc++.h> using namespace std ; const int maxn = 5010 ; int g [ maxn ][ maxn ]; int main ( void ) { int N , R ; cin >> N >> R ; int n = R , m = R ; for ( int i = 0 , x , y , w ; i < N ; ++ i ) { cin >> x >> y >> w ; x ++ , y ++ ; n = max ( n , x ); m = max ( m , y ); g [ x ][ y ] += w ; } for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) g [ i ][ j ] += g [ i -1 ][ j ] + g [ i ][ j -1 ] - g [ i -1 ][ j -1 ]; int ans = 0 ; for ( int i = R ; i <= n ; i ++ ) for ( int j = R ; j <= m ; j ++ ) ans = max ( ans , g [ i ][ j ] - g [ i - R ][ j ] - g [ i ][ j - R ] + g [ i - R ][ j - R ]); cout << ans ; return 0 ; } \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u7406 \u00b6 \u6c42\u89e3$a * x + b * y = gcd(a,b) $\u65b9\u7a0b\u7684\u901a\u89e3x\u548cy #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll N = 1e9 + 7 ; ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll d = exgcd ( b , a % b , x , y ); ll t = x ; x = y ; y = t - ( a / b ) * y ; return d ; } int main () { ll a = 3 , b = 5 , x = 0 , y = 0 ; ll g = exgcd ( a , b , x , y ); cout << \"\u7279\u89e3\u4e3a\" << \"x=\" << x << \",y=\" << y << endl ; for ( int i = 1 ; i <= 5 ; i ++ ) { x += b / g ; y -= a / g ; cout << \"\u901a\u89e3\u4e3a\" << \"x=\" << x << \",y=\" << y << endl ; } return 0 ; } \u6c42\u89e3\u4e00\u822c\u65b9\u7a0b a * x+b * y=c a * x+b * y=c \u7684\u901a\u89e3x\u548cy \u5c06\u65b9\u7a0b\u8f6c\u53d8\u4e3a\uff1a a * x+b * y=gcd(a, b) * c/gcd(a, b); a * x+b * y=gcd(a, b) * c/gcd(a, b); \u6700\u7ec8\u5373\u4e3a\uff1a a * x/(c/gcd(a, b))+b * y/(c/gcd(a, b))=gcd(a, b); a * x/(c/gcd(a, b))+b * y/(c/gcd(a, b))=gcd(a, b); \u5373\u628a\u7ed3\u679c\u8c03\u6574\u4e3a\uff1a x1=x0 * c/gcd(a, b); y1=y0 * c/gcd(a, b); x1=x0 * c/gcd(a, b); y1=y0 * c/gcd(a, b); #include <stdio.h> long long exgcd ( long long a , long long b , long long & x , long long & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } long long r = exgcd ( b , a % b , x , y ), t ; t = x ; x = y ; y = t - ( a / b ) * y ; return r ; } int main () { long long a , b , c , ans , x , y ; while ( scanf ( \"%lld%lld%lld\" , & a , & b , & c ) != EOF ) { ans = exgcd ( a , b , x , y ); if ( c % ans == 0 ) { x =- x * c / ans ; y =- y * c / ans ; printf ( \"%lld %lld \\n \" , x , y ); } else printf ( \"-1 \\n \" ); } return 0 ; } \u9006\u5143 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a , q ; ll ksm ( ll n , ll k ) { ll sum1 = 1 , sum2 = n ; while ( k != 0 ) { if ( k % 2 == 1 ) sum1 = sum1 * sum2 % q ; sum2 = sum2 * sum2 % q ; k /= 2 ; } return sum1 ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; cin >> a >> q ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << ksm ( a , q -2 ) << endl ; } #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll exgcd ( ll a , ll b , ll & x , ll & y ) ///\u540e\u4e24\u4e2a\u53c2\u6570\u4e3a\u5f15\u7528 { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll gcd_ans = exgcd ( b , a % b , x , y ); ll tem = x ; x = y ; y = tem - a / b * y ; return gcd_ans ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; ll a , q , x = 0 , y = 0 ; cin >> a >> q ; ll gcd_ans = exgcd ( q , a , x , y ); ll mul = q / gcd_ans ; y = ( y % mul + mul ) % mul ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << y << endl ; } \u8868\u8fbe\u5f0f\u6c42\u503c\uff08\u4e2d\u7f00\u8868\u8fbe\u5f0f\u8f6c\u540e\u7f00\u8868\u8fbe\u5f0f\uff09 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; stack < char > sc ; stack < ll > sll ; char a [ 100500 ] = { 0 }; inline ll qpow ( ll a , ll b ) { ll ans = 1 ; while ( b ) { if ( b & 1 ) ans *= a ; a *= a , b >>= 1 ; } return ans ; } int cmp1 ( char a1 , char a2 ) { if ( a2 == '(' ) return -1 ; if ( a2 == ')' ) { if ( a1 == '(' ) return 0 ; else if ( a1 == '#' ) return 0 ; else return 1 ; } if ( a2 == '+' || a2 == '-' ) { if ( a1 == '+' || a1 == '-' || a1 == '*' || a1 == '/' || a1 == '^' ) return 1 ; else return -1 ; } if ( a2 == '*' || a2 == '/' ) { if ( a1 == '*' || a1 == '/' || a1 == '^' ) return 1 ; else return -1 ; } if ( a2 == '^' ) { if ( a1 == '^' ) return 1 ; else return -1 ; } if ( a2 == '#' ) { if ( a1 == '#' ) return 0 ; else if ( a1 == '(' || a1 == ')' ) return 0 ; else return 1 ; } return 0 ; } int main () { scanf ( \"%s\" , a + 1 ); a [ strlen ( a + 1 ) + 1 ] = '#' ; ll tem = 0 , tem2 , tem1 ; sll . push ( 0 ); sc . push ( '#' ); for ( int i = 1 ; a [ i ]; i ++ ) { if ( a [ i ] <= '9' && a [ i ] >= '0' ) { tem = tem * 10 + a [ i ] - '0' ; if ( a [ i + 1 ] < '0' || a [ i + 1 ] > '9' ) sll . push ( tem ), tem = 0 ; } else { while ( ! sc . empty ()) { ll tem_cmp = cmp1 ( sc . top (), a [ i ]); if ( tem_cmp == 1 ) { tem2 = sll . top (); sll . pop (); tem1 = sll . top (); sll . pop (); if ( sc . top () == '+' ) sll . push ( tem1 + tem2 ); else if ( sc . top () == '-' ) sll . push ( tem1 - tem2 ); else if ( sc . top () == '*' ) sll . push ( tem1 * tem2 ); else if ( sc . top () == '/' ) sll . push ( tem1 / tem2 ); else if ( sc . top () == '^' ) sll . push (( ll ) qpow ( tem1 , tem2 )); sc . pop (); } else if ( tem_cmp == 0 ) { if ( a [ i ] != ')' || ( a [ i ] == ')' && sc . size () > 1 )) sc . pop (); break ; } else if ( tem_cmp == -1 ) { sc . push ( a [ i ]); break ; } } } } cout << sll . top () << endl ; } \u7ec4\u5408\u6570\u5b66 \u00b6 \u53c2\u8003\u535a\u5ba2\uff1a https://blog.csdn.net/Luoxiaobaia/article/details/107593528 1.\u7403\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u4e0d\u80fd\u7a7a\uff08\u9694\u677f\u6cd5\uff09 \u4e00\u5171\u6709n-1\u4e2a\u7a7a\u9699(\u603b\u5171n+1\u4e2a\u7a7a\u9699\uff0c\u4e0d\u80fd\u7a7a\u8981\u53bb\u6389\u5934\u5c3e=n-1) \uff0c\u8981\u63d2m-1\u4e2a\u677f\uff0c\u7b54\u6848\u4e3a C_{n-1}^{m-1} C_{n-1}^{m-1} \u200b 2.\u7403\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u80fd\u7a7a \u5982\u679c\u7ed9\u6bcf\u4e2a\u76d2\u5b50\u4e00\u4e2a\u7403\uff0c\u5c31\u53ef\u4ee5\u628a\u95ee\u9898\u8f6c\u5316\u4e3a\u4e0d\u80fd\u7a7a\u7684\u60c5\u51b5\u4e86,\u5c31\u76f8\u5f53\u4e8en+m\u4e2a\u5c0f\u7403\u653e\u5165m\u4e2a\u76d2\u5b50\u4e14\u4e0d\u80fd\u7a7a\uff0c\u7b54\u6848\u5c31\u662f C_{n+m-1}^{m-1} C_{n+m-1}^{m-1} 3.\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u80fd\u7a7a\uff08dp\u95ee\u9898\uff09 dp[n][m]\u4ee3\u8868n\u4e2a\u5c0f\u7403\u653e\u5165m\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u4e14\u4e0d\u80fd\u7a7a\u7684\u65b9\u6cd5 \u5f53 i >= 0 \u65f6\uff0cdp[i][i]=1 (i\u4e2a\u5c0f\u7403\u653e\u5165i\u4e2a\u76d2\u5b50\uff0c\u5c31\u53ea\u80fd1\u4e2a\u76d2\u5b50\u653e1\u4e2a) \u5f53 i > 0 \u65f6,dp[i][0]=0(\u90fd\u6ca1\u6709\u76d2\u5b50\u4e86\uff0c\u80af\u5b9a\u65e0\u89e3) dp[i][j] = j * dp[i-1][j] + dp[i-1][j-1] (\u7b2ci\u4e2a\u7403\u53ef\u4ee5\u653e\u5728\u5df2\u7ecf\u6709\u7684j\u4e2a\u76d2\u5b50\u7684\u4e00\u4e2a\uff0c\u6709j\u79cd\u65b9\u6cd5,\u4e5f\u5c31\u662fj*dp[i-1][j], \u4e5f\u53ef\u4ee5\u662f\u653e\u5165\u4e00\u4e2a\u65b0\u7684\u76d2\u5b50,\u5c31\u662fdp[i-1][j-1]) \u6240\u4ee5\u7b54\u6848\u5982\u4e0b\uff1a 4.\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a\uff08\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\uff09 \u90a3\u5c31\u662f3\u7684\u60c5\u51b5(\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u5141\u8bb8\u4e3a\u7a7a)\u75281\u4e2a\u76d2\u5b50+\u75282\u4e2a\u76d2\u5b50+\u2026+m\u4e2a\u76d2\u5b50 5.\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u4e0d\u80fd\u7a7a \u90a3\u5c31\u662f3\u7684\u60c5\u51b5(\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u5141\u8bb8\u4e3a\u7a7a)\u5bf9\u76d2\u5b50\u8fdb\u884c\u5168\u6392\u5217 \u7b54\u6848\u5c31\u662f m!*dp[n][m] (dp[n][m]\u662f\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570) 6.\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u53ef\u4ee5\u7a7a \u6bcf\u4e00\u4e2a\u5c0f\u7403\u90fd\u6709m\u79cd\u65b9\u6cd5\uff0c\u4e14\u76f8\u4e92\u72ec\u7acb\uff0c\u7b54\u6848\u5c31\u662f m^n m^n 7.\u7403\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a\uff08dp\u95ee\u9898\uff09 dp[i][j]\u4ee3\u8868\u7403\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a\u7684\u653e\u6cd5 \u5f53 i>=j \u65f6\uff0cdp[i][j] = dp[i][j-1]+dp[i-j][j] ( \u6211\u4eec\u53ef\u4ee5\u5728\u6240\u6709\u7684\u76d2\u5b50\u4e0a\u653e\u4e00\u4e2a\u7403dp[i-j][j]\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u9009\u62e9\u8fd9\u79cd\u64cd\u4f5c\uff0c\u4f46\u662f\u4ee5\u540e\u90fd\u4e0d\u5bf9\u5176\u4e2d\u4e00\u4e2a\u76d2\u5b50\u8fdb\u884c\u64cd\u4f5c\u4e86\uff0c\u90a3\u5c31\u662fdp[i][j-1] ) \u5f53 i<j \u65f6\uff0cdp[i][i] (\u591a\u4f59\u7684\u76d2\u5b50\u90fd\u6ca1\u6709\u4ec0\u4e48\u5375\u7528\u4e86) \u5f53 j=1 \u65f6\uff0c1(\u53ea\u6709\u4e00\u4e2a\u76d2\u5b50\u4e86\u5c31\u53ea\u80fd\u653e\u5728\u90a3\u4e2a\u76d2\u5b50\u4e86\uff0c\u53ea\u6709\u4e00\u79cd\u653e\u6cd5) \u5f53 i=1 \u65f6\uff0c1(\u53ea\u6709\u4e00\u4e2a\u7403\u4e86\uff0c\u653e\u54ea\u4e2a\u76d2\u5b50\u90fd\u4e00\u6837\uff0c\u53ea\u6709\u4e00\u79cd\u653e\u6cd5) \u5f53 i=0 \u65f6 1(\u6ca1\u6709\u7403\u4e86\uff0c\u4e5f\u662f1\u79cd\u65b9\u6cd5) \u7b54\u6848\u662f 8.\u7403\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u80fd\u7a7a \u90a3\u5c31\u662f7\u7684\u60c5\u51b5(\u7403\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a)\u6bcf\u4e2a\u76d2\u5b50\u5148\u653e\u4e00\u4e2a\u4fdd\u8bc1\u4e0d\u7a7a \u6240\u4ee5\u7b54\u6848\u662f dp[n-m][m] (n>=m) 0 (n<m) \u5176\u4e2ddp\u662f\u60c5\u51b57\u7684dp \u9644\u60c5\u51b57\u7684\u4ee3\u7801\uff1a #include <iostream> int main () { const int N = 11 ; int dp [ N ][ N ] = {}, t , n , m ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 1 ; j < N ; ++ j ) { if ( i <= 1 || j == 1 ) dp [ i ][ j ] = 1 ; else if ( i < j ) dp [ i ][ j ] = dp [ i ][ i ]; else dp [ i ][ j ] = dp [ i ][ j -1 ] + dp [ i - j ][ j ]; } scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & m ); printf ( \"%d \\n \" , dp [ n ][ m ]); } return 0 ; } \u5361\u7279\u5170\u6570 \u00b6 \u53c2\u7167\u535a\u5ba2\uff1a https://zhuanlan.zhihu.com/p/97619085 \u5361\u7279\u5170\u6570\uff08Catalan number\uff09\u662f \u7ec4\u5408\u6570\u5b66 \u4e2d\u4e00\u4e2a\u5e38\u51fa\u73b0\u5728\u5404\u79cd \u8ba1\u6570\u95ee\u9898 \u4e2d\u7684 \u6570\u5217 \u3002 \u6570\u5217\u7684\u524d\u51e0\u9879\u4e3a\uff1a1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862\uff0c... \u5361\u7279\u5170\u6570\u516c\u5f0f\uff1a \u7535\u5f71\u8d2d\u7968\u95ee\u9898 \u7535\u5f71\u7968\u4e00\u5f20 50 coin\uff0c\u4e14\u552e\u7968\u5385\u6ca1\u6709 coin\u3002m \u4e2a\u4eba\u5404\u81ea\u6301\u6709 50 coin\uff0cn \u4e2a\u4eba\u5404\u81ea\u6301\u6709 100 coin\u3002 \u5219\u6709\u591a\u5c11\u79cd\u6392\u961f\u65b9\u5f0f\uff0c\u53ef\u4ee5\u8ba9\u6bcf\u4e2a\u4eba\u90fd\u4e70\u5230\u7535\u5f71\u7968\u3002 \u601d\u8def \u6301\u6709 50 coin \u7684\u4eba\u6bcf\u6b21\u8d2d\u7968\u65f6\u4e0d\u9700\u8981\u627e\u96f6\uff0c\u5e76\u4e14\u53ef\u4ee5\u5e2e\u52a9\u540e\u9762\u6301\u6709 100 coin \u7684\u4eba\u627e\u96f6\uff1b\u800c\u5bf9\u4e8e\u6301\u6709 100 coin \u7684\u4eba\u6bcf\u6b21\u8d2d\u7968\u65f6\u9700\u8981\u627e\u96f6\uff0c\u4f46 100 coin \u5bf9\u540e\u9762\u7684\u627e\u96f6\u6ca1\u6709\u4efb\u4f55\u4f5c\u7528\u3002 \u56e0\u6b64\uff0c\u76f8\u5f53\u4e8e\u6bcf\u4e2a\u6301\u6709 100 coin \u7684\u4eba\u90fd\u9700\u8981\u548c\u4e00\u4e2a\u6301\u6709 50 coin \u7684\u4eba\u8fdb\u884c\u5339\u914d\u3002\u6211\u4eec\u5c06\u6301\u6709 50 coin \u7684\u6807\u8bb0\u4e3a +1\uff0c\u6301\u6709 100 coin \u7684\u6807\u8bb0\u4e3a -1\uff0c\u6b64\u65f6\u53c8\u56de\u5230\u4e86\u8fdb\u51fa\u6808\u95ee\u9898\u3002 \u4e0d\u540c\u7684\u662f\uff0cm \u5e76\u4e00\u5b9a\u7b49\u4e8e n\uff0c\u4e14\u6392\u961f\u5e8f\u5217\u662f\u4e00\u79cd\u6392\u5217\uff0c\u9700\u8981\u8003\u8651\u5148\u540e\u987a\u5e8f\uff0c\u4f8b\u5982\u5404\u81ea\u6301\u6709 50 coin \u7684\u7532\u548c\u4e59\u7684\u524d\u540e\u5173\u7cfb\u4f1a\u9020\u6210\u4e24\u79cd\u4e0d\u540c\u7684\u6392\u961f\u5e8f\u5217\u3002\u6240\u4ee5\uff0c\u5c06\u4f1a\u6709 \u7b2c\u4e8c\u9879\u4e3a\u4ec0\u4e48\u662f \uff0c\u5176\u5b9e\u5f88\u7b80\u5355\uff0c\u6211\u4eec\u6bcf\u6b21\u628a\u7b2c\u4e00\u4e2a\u524d\u7f00\u5c0f\u4e8e0 \u7684\u524d\u7f00\u53d6\u53cd\u540e\uff0c\u4f1a\u9020\u6210 +1 \u591a\u4e86\u4e00\u4e2a\u800c -1 \u5c11\u4e86\u4e00\u4e2a\u3002\u8fd9\u91cc +1 \u6709 m \u4e2a\uff0c-1 \u6709 n \u4e2a\uff0c\u53d6\u53cd\u540e +1 \u53d8\u6210 m + 1 \u4e2a\uff0c-1 \u53d8\u6210 n - 1 \u4e2a\uff0c\u603b\u548c\u4e0d\u53d8\u3002 const int C_maxn = 1e4 + 10 ; ll CatalanNum [ C_maxn ]; ll inv [ C_maxn ]; inline void Catalan_Mod ( int N , LL mod ) { inv [ 1 ] = 1 ; for ( int i = 2 ; i <= N + 1 ; i ++ ) ///\u7ebf\u6027\u9884\u5904\u7406 1 ~ N \u5173\u4e8e mod \u7684\u9006\u5143 inv [ i ] = ( mod - mod / i ) * inv [ mod % i ] % mod ; CatalanNum [ 0 ] = CatalanNum [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) CatalanNum [ i ] = CatalanNum [ i - 1 ] * ( 4 * i - 2 ) % mod * inv [ i + 1 ] % mod ; } \u79ef\u6027\u51fd\u6570 \u00b6 \u79ef\u6027\u51fd\u6570\u662f\u6307\u5bf9\u4e8e\u4efb\u610f\u4e92\u8d28\u7684\u6574\u6570a\u548cb\u6709\u6027\u8d28f(ab)=f(a)f(b)\u7684\u6570\u8bba\u51fd\u6570 \u5e38\u7528\u79ef\u6027\u51fd\u6570\u6709\uff1a \u03c6(n) \uff0d\u6b27\u62c9\u51fd\u6570 \u03bc(n) \uff0d\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\uff0c\u5173\u4e8e\u975e\u5e73\u65b9\u6570\u7684\u8d28\u56e0\u5b50\u6570\u76ee gcd(n,k) \uff0d\u6700\u5927\u516c\u56e0\u5b50\uff0c\u5f53k\u56fa\u5b9a\u7684\u60c5\u51b5 d(n) \uff0dn\u7684\u6b63\u56e0\u5b50\u6570\u76ee \u03c3(n) \uff0dn\u7684\u6240\u6709\u6b63\u56e0\u5b50\u4e4b\u548c \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14 \u00b6 \u53c2\u8003\u4e8e https://zhuanlan.zhihu.com/p/45744228 \u51fd\u6570\u5b9a\u4e49 \u8f85\u52a9\u5b9a\u7406 \u5bf9\u4e8e\u4efb\u610f\u6b63\u6574\u6570 \uff0c\u6052\u6709 \u5176\u6b21\uff0c\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u548c\u6b27\u62c9\u51fd\u6570\u7684\u5173\u7cfb\uff1a \\sum_{d|n}\\frac{\\mu[d]}{d}=\\frac{\\varphi(n)}{n} \\sum_{d|n}\\frac{\\mu[d]}{d}=\\frac{\\varphi(n)}{n} \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u5b9a\u7406 \u548c \u662f\u5b9a\u4e49\u5728\u6b63\u6574\u6570\u96c6\u5408\u4e0a\u7684\u4e24\u4e2a\u51fd\u6570\uff0c\u82e5 \u5219 \u53cd\u4e4b\u4ea6\u7136. \u8bc1\u660e\uff1a \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u5b9e\u9645\u4e0a\u662f\u5bb9\u65a5\u3002 \u5e38\u89c1\u53cd\u6f14 1\u3001 \u6240\u4ee5\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\u672c\u8eab\u4e5f\u53ef\u4ee5\u53cd\u6f14\u3002 2\u3001 \u7ebf\u6027\u9884\u5904\u7406 \u6c42\u89e3\u533a\u95f4 \u548c\u533a\u95f4 \u4e0a\u4e92\u8d28\u7684\u6570\u7684\u4e2a\u6570\u3002 \u4ee3\u7801 void get_mu ( int n ) { mu [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! vis [ i ]){ prim [ ++ cnt ] = i ; mu [ i ] = -1 ;} for ( int j = 1 ; j <= cnt && prim [ j ] * i <= n ; j ++ ) { vis [ prim [ j ] * i ] = 1 ; if ( i % prim [ j ] == 0 ) break ; else mu [ i * prim [ j ]] =- mu [ i ]; } } } FFT\u548cNNT\u6a21\u677f \u00b6 \u53c2\u8003\u94fe\u63a5\uff1a https://www.acwing.com/file_system/file/content/whole/index/content/1563813/ https://blog.csdn.net/hzf0701/article/details/119428159 https://blog.csdn.net/zz_1215/article/details/40430041 https://www.luogu.com.cn/problem/P3803 NTT \u5feb\u901f\u6570\u8bba\u53d8\u6362\u53d6\u6a21\u591a\u9879\u5f0f\u6a21\u677f #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; const ll G = 3 ; ll n , m , L , R [ 6005000 ] = { 0 }; ll a [ 6005000 ] = { 0 }, b [ 6005000 ] = { 0 }, inv [ 6005000 ] = { 0 }; ll qpow ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ans1 * ans2 % mod ; ans2 = ans2 * ans2 % mod ; b /= 2 ; } return ans1 % mod ; } void NTT ( ll * a , ll f ) { for ( ll i = 0 ; i < n ; i ++ ) { if ( i < R [ i ]) swap ( a [ i ], a [ R [ i ]]); } for ( ll i = 1 ; i < n ; i <<= 1 ) { ll gn = qpow ( G , ( mod - 1 ) / ( i << 1 )); for ( ll j = 0 ; j < n ; j += ( i << 1 )) { ll g = 1 ; for ( ll k = 0 ; k < i ; k ++ , g = g * gn % mod ) { ll x = a [ j + k ], y = g * a [ j + k + i ] % mod ; a [ j + k ] = ( x + y ) % mod ; a [ j + k + i ] = ( x - y + mod ) % mod ; } } } if ( f == 1 ) return ; ll inv = qpow ( n , mod - 2 ); reverse ( a + 1 , a + n ); for ( ll i = 0 ; i < n ; i ++ ) a [ i ] = 1l l * a [ i ] * inv % mod ; } void solve ( ll * A , ll * B ) { m = n + m ; for ( n = 1 ; n <= m ; n <<= 1 ) L ++ ; for ( int i = 0 ; i < n ; i ++ ) R [ i ] = ( R [ i >> 1 ] >> 1 ) | (( i & 1 ) << ( L - 1 )); NTT ( A , 1 ); NTT ( B , 1 ); for ( int i = 0 ; i < n ; i ++ ) A [ i ] = ( A [ i ] % mod * B [ i ] % mod + mod ) % mod ; NTT ( A , -1 ); } int main () { scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 0 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); for ( ll i = 0 ; i <= m ; i ++ ) scanf ( \"%lld\" , & b [ i ]); solve ( a , b ); for ( ll i = 0 ; i <= m ; i ++ ) printf ( \"%lld \" , a [ i ]); return 0 ; } FFT\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362\u6a21\u677f #include <bits/stdc++.h> using namespace std ; typedef pair < int , int > pii ; typedef long long ll ; const int N = 6e6 + 10 ; const int P = 1e9 + 7 ; const int INF = 0x3f3f3f3f ; const double PI = acos ( -1.0 ); //\u5706\u5468\u7387PI\u3002 struct Complex { double x , y ; //\u590d\u6570\uff0cx\u4ee3\u8868\u5b9e\u90e8\uff0cy\u4ee3\u8868\u865a\u90e8\u3002 Complex ( double _x = 0 , double _y = 0 ) { x = _x , y = _y ; } } a [ N ], b [ N ]; //\u591a\u9879\u5f0fa\u548cb\uff0c\u76f8\u4e58\u3002 int n , m , l , r [ N ], limit = 1 ; //n\u4e3aa\u7684\u6b21\u6570,m\u4e3ab\u7684\u6b21\u6570\u3002limit\u5373\u4e3a\u6700\u5927\u9650\u5236\u30022^n\u6b21\u65b9\uff0c\u800cl\u4e3a\u4e8c\u8fdb\u5236\u7684\u4f4d\u6570 //\u8fd0\u7b97\u7b26\u91cd\u8f7d\u3002 Complex operator + ( Complex a , Complex b ) { return Complex ( a . x + b . x , a . y + b . y ); } Complex operator - ( Complex a , Complex b ) { return Complex ( a . x - b . x , a . y - b . y ); } //\u590d\u6570\u76f8\u4e58\uff0c\u5219\u6a21\u957f\u76f8\u4e58\uff0c\u5e45\u5ea6\u76f8\u52a0\u3002 Complex operator * ( Complex a , Complex b ) { return Complex ( a . x * b . x - a . y * b . y , a . x * b . y + a . y * b . x ); } void fft ( Complex * A , int type ) { for ( int i = 0 ; i < limit ; ++ i ) { if ( i < r [ i ]) swap ( A [ i ], A [ r [ i ]]); //\u6c42\u51fa\u8981\u8fed\u4ee3\u7684\u533a\u95f4\u3002\u5c0f\u4e8er[i]\u65f6\u624d\u4ea4\u6362\uff0c\u9632\u6b62\u540c\u4e00\u4e2a\u5143\u7d20\u4ea4\u6362\u4e24\u6b21\uff0c\u56de\u5230\u539f\u6765\u7684\u4f4d\u7f6e\u3002 } //\u4ece\u5e95\u5c42\u5f80\u4e0a\u5408\u5e76\u3002 for ( int mid = 1 ; mid < limit ; mid <<= 1 ) { //\u5f85\u5408\u5e76\u533a\u95f4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u6700\u5f00\u59cb\u662f\u4e24\u4e2a\u957f\u5ea6\u4e3a1\u7684\u5e8f\u5217\u5408\u5e76,mid = 1; Complex Wn ( cos ( PI / mid ), type * sin ( PI / mid )); //\u5355\u4f4d\u6839\u3002 for ( int len = mid << 1 , j = 0 ; j < limit ; j += len ) { //len\u662f\u533a\u95f4\u7684\u957f\u5ea6\uff0cj\u662f\u5f53\u524d\u7684\u4f4d\u7f6e\uff0c\u4e5f\u5c31\u662f\u5408\u5e76\u5230\u4e86\u54ea\u4e00\u4f4d\u3002 Complex w ( 1 , 0 ); //\u5e42\uff0c\u4e00\u76f4\u4e58\uff0c\u5f97\u5230\u5e73\u65b9\uff0c\u4e09\u6b21\u65b9\u3002 for ( int k = 0 ; k < mid ; ++ k , w = w * Wn ) { //\u679a\u4e3e\u5de6\u534a\u90e8\u5206\u3002\u8774\u8776\u53d8\u6362\u5f97\u5230\u53f3\u534a\u90e8\u5206\u7684\u7b54\u6848\u3002w\u4e3awn * k Complex x = A [ j + k ], y = w * A [ j + mid + k ]; //\u5de6\u534a\u90e8\u5206\u548c\u53f3\u534a\u90e8\u5206\u3002 A [ j + k ] = x + y ; //\u5de6\u8fb9\u52a0\u3002 A [ j + mid + k ] = x - y ; //\u53f3\u8fb9\u51cf\u3002 } } } if ( type == 1 ) return ; for ( int i = 0 ; i <= limit ; ++ i ) { a [ i ]. x /= limit ; //\u6700\u540e\u9700\u8981\u9664\u4ee5limit\u4e5f\u5c31\u662f\u8865\u6210\u4e862\u7684\u6574\u6570\u5e42\u3002\u5c06\u70b9\u503c\u8f6c\u6362\u4e3a\u7cfb\u6570\u3002 } } void solve () { while ( limit <= n + m ) { limit <<= 1 , l ++ ; } //\u521d\u59cb\u5316r\u6570\u7ec4\u3002 for ( int i = 0 ; i < limit ; ++ i ) { r [ i ] = ( r [ i >> 1 ] >> 1 ) | (( i & 1 ) << ( l - 1 )); } fft ( a , 1 ); //\u5c06a\u7684\u7cfb\u6570\u8f6c\u5316\u4e3a\u70b9\u503c\u8868\u793a\uff0c fft ( b , 1 ); //\u5c06b\u7684\u7cfb\u6570\u8f6c\u5316\u4e3a\u70b9\u503c\u8868\u793a\u3002 for ( int i = 0 ; i <= limit ; ++ i ) { //\u5bf9\u5e94\u9879\u76f8\u4e58\uff0c\u5f97\u5230\u70b9\u503c\u8868\u793a\u7684\u89e3\u3002 a [ i ] = a [ i ] * b [ i ]; } fft ( a , -1 ); for ( int i = 0 ; i <= n + m ; ++ i ) { //\u53d6\u51fa\u6765\u96642\uff0c\u52a0\u4e0a0.5\u56db\u820d\u4e94\u5165\u3002 printf ( \"%d \" , ( int )( a [ i ]. x + 0.5 )); } printf ( \" \\n \" ); } int main () { scanf ( \"%d%d\" , & n , & m ); //\u8bfb\u5165\u591a\u9879\u5f0f\u7684\u6bcf\u4e00\u9879\u3002 for ( int i = 0 ; i <= n ; ++ i ) { scanf ( \"%lf\" , & a [ i ]. x ); } \u00b7 for ( int i = 0 ; i <= m ; ++ i ) { scanf ( \"%lf\" , & b [ i ]. x ); } solve (); return 0 ; } Meissel-Lehmer \u7b97\u6cd5 \u00b6 \u662f\u4e00\u79cd\u80fd\u5728\u4e9a\u7ebf\u6027\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u6c42\u51fa 1\u223cn\u5185\u8d28\u6570\u4e2a\u6570\u7684\u4e00\u79cd\u7b97\u6cd5\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{\\frac{2}{3}}) O(n^{\\frac{2}{3}}) #include <bits/stdc++.h> using namespace std ; using ll = long long ; //\u901a\u8fc7\u77e5\u9053\u524d\u9762\u7684 n^1/3 \u7684\u8d28\u6570\u53ef\u4ee5\u63a8\u65ad\u540e\u9762n^2/3\u7684\u8d28\u6570\u6240\u4ee5\u53ef\u4ee5\u9002\u5f53\u51cf\u5c0f const int N = 9e3 ; const int M = 2 ; //\u4e3a\u4e86\u51cf\u5c0f\u5185\u5b58\u53ef\u4ee5\u4e0d\u8fc7\u662f\u8d28\u6570 const int PM = 2 * 3 * 5 ; //\u4e3a\u4e86\u51cf\u5c0f\u5185\u5b58\u53ef\u4ee5\u4e0d\u8fc7\u8981\u6309\u8d28\u6570\u51cf\u5c0f\u5982\u53bb\u638917 ll n ; bool np [ N ]; int prime [ N ], pi [ N ]; int phi [ PM + 1 ][ M + 1 ], sz [ M + 1 ]; int getprime () { int cnt = 0 ; np [ 0 ] = np [ 1 ] = true ; pi [ 0 ] = pi [ 1 ] = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( ! np [ i ]) prime [ ++ cnt ] = i ; pi [ i ] = cnt ; for ( int j = 1 ; j <= cnt && i * prime [ j ] < N ; ++ j ) { np [ i * prime [ j ]] = true ; if ( i % prime [ j ] == 0 ) break ; } } return cnt ; } void init () { getprime (); sz [ 0 ] = 1 ; for ( int i = 0 ; i <= PM ; ++ i ) phi [ i ][ 0 ] = i ; for ( int i = 1 ; i <= M ; ++ i ) { sz [ i ] = prime [ i ] * sz [ i - 1 ]; for ( int j = 1 ; j <= PM ; ++ j ) phi [ j ][ i ] = phi [ j ][ i - 1 ] - phi [ j / prime [ i ]][ i - 1 ]; } } int sqrt2 ( ll x ) { ll r = ( ll ) sqrt ( x - 0.1 ); while ( r * r <= x ) ++ r ; return int ( r - 1 ); } int sqrt3 ( ll x ) { ll r = ( ll ) cbrt ( x - 0.1 ); while ( r * r * r <= x ) ++ r ; return int ( r - 1 ); } ll getphi ( ll x , int s ) { if ( s == 0 ) return x ; if ( s <= M ) return phi [ x % sz [ s ]][ s ] + ( x / sz [ s ]) * phi [ sz [ s ]][ s ]; if ( x <= prime [ s ] * prime [ s ]) return pi [ x ] - s + 1 ; if ( x <= prime [ s ] * prime [ s ] * prime [ s ] && x < N ) { int s2x = pi [ sqrt2 ( x )]; ll ans = pi [ x ] - ( s2x + s - 2 ) * ( s2x - s + 1 ) / 2 ; for ( int i = s + 1 ; i <= s2x ; ++ i ) ans += pi [ x / prime [ i ]]; return ans ; } return getphi ( x , s - 1 ) - getphi ( x / prime [ s ], s - 1 ); } ll getpi ( ll x ) { if ( x < N ) return pi [ x ]; ll ans = getphi ( x , pi [ sqrt3 ( x )]) + pi [ sqrt3 ( x )] - 1 ; for ( int i = pi [ sqrt3 ( x )] + 1 , ed = pi [ sqrt2 ( x )]; i <= ed ; ++ i ) ans -= getpi ( x / prime [ i ]) - i + 1 ; return ans ; } ll lehmer_pi ( ll x ) { //\u5c0f\u4e8e\u7b49\u4e8en\u7684\u7d20\u6570\u6709\u591a\u5c11\u4e2a if ( x < N ) return pi [ x ]; int a = ( int ) lehmer_pi ( sqrt2 ( sqrt2 ( x ))); int b = ( int ) lehmer_pi ( sqrt2 ( x )); int c = ( int ) lehmer_pi ( sqrt3 ( x )); ll sum = getphi ( x , a ) + ( ll )( b + a - 2 ) * ( b - a + 1 ) / 2 ; for ( int i = a + 1 ; i <= b ; i ++ ) { ll w = x / prime [ i ]; sum -= lehmer_pi ( w ); if ( i > c ) continue ; ll lim = lehmer_pi ( sqrt2 ( w )); for ( int j = i ; j <= lim ; j ++ ) sum -= lehmer_pi ( w / prime [ j ]) - ( j - 1 ); } return sum ; } int main () { ios_base :: sync_with_stdio ( false ), cin . tie ( 0 ); init (); while ( cin >> n && n ) cout << lehmer_pi ( n ) << \" \\n \" ; return 0 ; } Miller Rabin\u7d20\u6570\u5224\u5b9a\u7b97\u6cd5 \u00b6 // C++ Version bool millerRabin ( int n ) { if ( n < 3 || n % 2 == 0 ) return n == 2 ; int a = n - 1 , b = 0 ; while ( a % 2 == 0 ) a /= 2 , ++ b ; // test_time \u4e3a\u6d4b\u8bd5\u6b21\u6570,\u5efa\u8bae\u8bbe\u4e3a\u4e0d\u5c0f\u4e8e 8 // \u7684\u6574\u6570\u4ee5\u4fdd\u8bc1\u6b63\u786e\u7387,\u4f46\u4e5f\u4e0d\u5b9c\u8fc7\u5927,\u5426\u5219\u4f1a\u5f71\u54cd\u6548\u7387 for ( int i = 1 , j ; i <= test_time ; ++ i ) { int x = rand () % ( n - 2 ) + 2 , v = quickPow ( x , a , n ); if ( v == 1 ) continue ; for ( j = 0 ; j < b ; ++ j ) { if ( v == n - 1 ) break ; v = ( long long ) v * v % n ; } if ( j >= b ) return 0 ; } return 1 ; } \u52a8\u6001\u89c4\u5212 \u00b6 \u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217 \u00b6 \u5982\u679c\u4f60\u9700\u8981\u79fb\u52a8\u4e00\u6837\u4e1c\u897f\uff0c\u663e\u7136\u63a5\u89e6\u6216\u8005\u4f7f\u7528\u78c1\u573a\u7535\u573a\u4e4b\u7c7b\u7684\u53ef\u4ee5\u89e3\u51b3\u3002\u4f46\u662f\u6709\u6ca1\u6709\u529e\u6cd5\u8fdb\u884c\u8d85\u8d8a\u8ddd\u79bb\u7684\u968f\u5fc3\u6240\u6b32\u7684\u79fb\u52a8\uff1f \u5bf9\u4e8e\u7269\u4f53\u6216\u8005\u6587\u5b57\u8fdb\u884c\u8d85\u8ddd\u79bb\u79fb\u52a8\u4e00\u76f4\u662f\u4eba\u7c7b\u7684\u68a6\u60f3\uff0c\u6709\u4e00\u5929\u8fd9\u4e2a\u96be\u9898\u7ec8\u4e8e\u88ab\u6211\u4eec\u7684\u5927\u725b\u89e3\u51b3\u4e86\uff01\u4ed6\u73b0\u5728\u9700\u8981\u7684\u5c31\u662f\u6574\u7406\u6570\u5217\u3002\u6570\u5217\u5c31\u662f\u6240\u8c13\u7684\u5199\u5728\u7eb8\u4e0a\u6216\u8005\u5728\u7535\u8111\u54c1\u76ee\u4e0a\u7684\u6570\u5217... \u6574\u7406\u6570\u5217\u9700\u8981\u4e00\u4e2a\u53eb\u505aswap\u7684\u64cd\u4f5c\uff0cswap\u64cd\u4f5c\u5c31\u662f\u6307\u5927\u725b\u901a\u8fc7\u8d85\u8ddd\u79bb\u7684\u63a7\u5236\u628a\u6570\u5217\u4e2d\u7684\u67d0\u4e00\u4f4d\u76f4\u63a5\u63d2\u5165\u67d0\u4e24\u4f4d\u7684\u4e2d\u95f4\u6216\u8005\u6570\u5217\u7684\u5f00\u59cb\u6216\u8005\u7ec8\u6b62\u7684\u64cd\u4f5c\u3002\u8fd9\u4e2a\u64cd\u4f5c\u7684\u5173\u952e\u5728\u4e8e\u8d85\u8ddd\u79bb\u63a7\u5236\uff0c\u663e\u7136\u8fd9\u79cd\u4e8b\u60c5\u4e0d\u80fd\u5e72\u592a\u591a\u6b21\uff0c\u4e0d\u4f46\u964dRP\uff0c\u800c\u4e14\u5f88\u8017\u4f53\u529b\u3002\u4f60\u7684\u4efb\u52a1\u5c31\u662f\u4ece\u521d\u59cb\u72b6\u6001\u5230\u76ee\u6807\u72b6\u6001\u6240\u9700\u8981\u505aswap\u7684\u6700\u5c11\u6b21\u6570\u3002 \u8f93\u5165 \u4e09\u884c\uff0c\u7b2c\u4e00\u884c\u4e00\u4e2a\u6574\u6570 n\uff08n<600000\uff09 \u7b2c\u4e8c\u884c\uff0cn \u4e2a\u6574\u6570\uff081-n\uff09\uff0c\u8868\u793a\u521d\u59cb\u6570\u5217\u3002 \u7b2c\u4e09\u884c\uff0cn \u4e2a\u6574\u6570\uff081-n\uff09\uff0c\u8868\u793a\u76ee\u6807\u6570\u5217\u3002 \u4fdd\u8bc1\u6574\u6570\u4e0d\u91cd\u590d\u3002 \u8f93\u51fa \u4e00\u884c \u8868\u793a\u6700\u5c11swap\u6b21\u6570\u3002 \u6837\u4f8b\u8f93\u5165 10 1 2 3 4 5 6 7 8 9 10 10 9 8 7 6 5 4 3 2 1 \u6837\u4f8b\u8f93\u51fa 9 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <iostream> #include <cstdio> #include <bits/stdc++.h> using namespace std ; const int inf = 0x7fffffff ; int b [ 1005001 ], mp [ 1005001 ], c [ 1005001 ]; int main () { int n , x ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & x ), mp [ x ] = i ; for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & b [ i ]), c [ i ] = inf ; int len = 0 ; c [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int l = 0 , r = len , mid ; if ( mp [ b [ i ]] > c [ len ]) c [ ++ len ] = mp [ b [ i ]]; else { while ( l < r ) { mid = ( l + r ) / 2 ; if ( c [ mid ] > mp [ b [ i ]]) r = mid ; else l = mid + 1 ; } c [ l ] = min ( mp [ b [ i ]], c [ l ]); } } cout << n - len << endl ; return 0 ; } \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217 \u00b6 for ( int i = 1 ; i <= strlen ( a ); i ++ ) for ( int j = 1 ; j <= strlen ( b ); j ++ ) if ( a [ i ] == b [ j ]) dp [ i ][ j ] = dp [ i -1 ][ j -1 ] + 1 ; else dp [ i ][ j ] = max ( dp [ i -1 ][ j ], dp [ i ][ j -1 ]); \u72b6\u538bDP \u00b6 #include <bits/stdc++.h> using namespace std ; typedef unsigned long long ull ; typedef long long ll ; const int inf = 0x3f3f3f3f ; int n , m ; struct node { int cost , num ; } nd [ 100005 ]; int f [ 1005 ][( 1 << 12 ) + 5 ]; //1\u5de6\u79fb12\u4f4d\u518d\u52a05 int main () { cin >> n >> m ; for ( int i = 1 ; i <= m ; i ++ ) { int b ; scanf ( \"%d%d\" , & nd [ i ]. cost , & b ); int t = 0 ; for ( int j = 1 ; j <= b ; j ++ ) { int temp ; scanf ( \"%d\" , & temp ); t |= ( 1 << ( temp -1 )); ///1\u672c\u6765\u5c31\u5728\u7b2c\u4e00\u4e2a\u4f4d\uff0c\u6240\u4ee5\u8981\u5230\u7b2ctemp\u4f4d\uff0c\u53ea\u9700\u8981\u5411\u5de6\u79fb\u52a8temp-1\u4f4d } nd [ i ]. num = t ; } memset ( f , inf , sizeof ( f )); f [ 0 ][ 0 ] = 0 ; ///\u5f88\u91cd\u8981 for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 0 ; j < ( 1 << n ); j ++ ) ///n\u4e2a\u9501 { int kk = j | nd [ i ]. num ; ///\u5bf9\u5e94\u6bcf\u4e2a\u9501\u9009\u4e0d\u9009 f [ i ][ kk ] = min ( f [ i ][ kk ], f [ i -1 ][ j ] + nd [ i ]. cost ); f [ i ][ j ] = min ( f [ i ][ j ], f [ i -1 ][ j ]); /// } } if ( f [ m ][( 1 << n ) -1 ] != inf ) ///1\u5411\u5de6\u79fb\u52a812\uff0c\u76f8\u5f53\u4e8e1000000000000\uff0c\u7136\u800c12\u4e2a\u4f4d\u7f6e\u90fd\u4e3a1\uff0c\u5373(111111111111)=(1000000000000)-1 printf ( \"%d \\n \" , f [ m ][( 1 << n ) -1 ]); else printf ( \"-1\" ); return 0 ; } \u659c\u7387DP \u00b6 \u4f18\u5316$ Dp[i]=min(Dp[i]\uff0cDp[j]+(h[j]-h[i])^2 +m)(m\u4e3a\u5e38\u6570)$ \u9898\u76ee\u94fe\u63a5\uff1a Frog 3-ICPC Frog 3-Atcoder \u53c2\u8003\u94fe\u63a5\uff1a https://www.cnblogs.com/orzzz/p/7885971.html https://blog.csdn.net/mengxiang000000/article/details/78113980 https://blog.csdn.net/bllsll/article/details/78267029 \u516c\u5f0f\u63a8\u5bfc\uff1a \u6211\u4eec\u5047\u8bbe\u5728\u6c42\u89e3 dp[i] dp[i] \u65f6\uff0c\u5b58\u5728 j,k(j>k) j,k(j>k) \u4f7f\u5f97\u4ece j j \u8f6c\u79fb\u6bd4\u4ece k k \u8f6c\u79fb\u66f4\u4f18\uff0c\u90a3\u4e48\u9700\u8981\u6ee1\u8db3\u6761\u4ef6\uff1a dp[j]+(S[i+1]\u2212S[j])^2+M<dp[k]+(S[i+1]\u2212S[k])^2+M dp[j]+(S[i+1]\u2212S[j])^2+M<dp[k]+(S[i+1]\u2212S[k])^2+M \u5c55\u5f00\u4e0a\u5f0f dp[j]+S[i+1]^2\u22122S[i+1]S[j]+S[j]^2+M<dp[k]+S[i+1]^2\u22122S[i+1]S[k]+S[k]^2+M dp[j]+S[i+1]^2\u22122S[i+1]S[j]+S[j]^2+M<dp[k]+S[i+1]^2\u22122S[i+1]S[k]+S[k]^2+M \u79fb\u9879\u5e76\u6d88\u53bb\u518d\u5408\u5e76\u540c\u7c7b\u9879\u5f97 $dp[j]\u2212dp[k]+S[j] 2\u2212S[k] 2<2S[i+1] (S[j]\u2212S[k]) $ \u628aS[j]\u2212S[k]S[j]\u2212S[k]\u9664\u8fc7\u53bb\uff0c\u5f97\u5230 \\frac{dp[j]\u2212dp[k]+S[j]^2\u2212S[k]^2}{S[j]\u2212S[k]}<2S[i+1] \\frac{dp[j]\u2212dp[k]+S[j]^2\u2212S[k]^2}{S[j]\u2212S[k]}<2S[i+1] \u6211\u4eec\u8bbe f[x]=dp[x]+S[x]^2 f[x]=dp[x]+S[x]^2 \uff0c\u5c31\u5316\u6210\u4e86 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \u5373\u5f53 (j>k) (j>k) \u65f6\uff0c\u82e5 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \uff0c\u5219 j j \u5bf9\u66f4\u65b0 dp[i] dp[i] \u6bd4 k k \u66f4\u65b0 dp[i] dp[i] \u4f18\u3002---\u659c\u7387\u3002 \u5f53\u4e00\u4e2a\u6570\u7684dp\u503c\u6c42\u5b8c\u4e86\uff0c\u5b83\u7684f\u503c\u4e5f\u8ddf\u7740\u786e\u5b9a\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5728\u7a7a\u95f4\u4e2d\u7ed8\u5236\u51fa\u70b9(S[i],f[i])\u3002\u8fd9\u4e2a\u70b9\u4ee3\u8868\u5df2\u7ecf\u6c42\u51fadp\u503c\u7684\u4e00\u4e2a\u70b9\u3002 \u5f53\u6211\u4eec\u8981\u6c42\u89e3dp[t]\u65f6\uff0c\u5982\u679c\u53ef\u7528\u7684\u96c6\u5408\u91cc\u5b58\u5728\u8fd9\u6837\u4e09\u4e2a\u70b9\uff0c\u4f4d\u7f6e\u5173\u7cfb\u5982\u56fe\u6240\u793a\uff1a \u90a3\u4e48\u663e\u7136 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \u8fd9\u65f6\u5019\u4ed6\u4eec\u548c2S[t+1]2S[t+1]\u7684\u5173\u7cfb\u67093\u79cd\uff1a \u00b7 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]}>2S[t+1] \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]}>2S[t+1] \u90a3\u4e48j\u6bd4i\u4f18\uff0ck\u6bd4j\u4f18\u3002 \u00b7 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>2S[t+1]>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>2S[t+1]>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \u90a3\u4e48i\u6bd4j\u4f18\uff0ck\u6bd4j\u4f18\u3002 \u00b7 2S[t+1]>\\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} 2S[t+1]>\\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \u90a3\u4e48i\u6bd4j\u4f18\uff0cj\u6bd4k\u4f18\u3002 \u7efc\u4e0a\uff0c\u4e0d\u7ba1\u4ec0\u4e48\u6837\u7684 S[t+1] S[t+1] \uff0c\u4ecej\u8f6c\u79fb\u90fd\u4e0d\u4f1a\u662f\u6700\u4f73\u65b9\u6848\u3002\u90a3\u4e48\u7528\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u4e00\u4e2a\u51f8\u5305\uff08\u4e0b\u51f8\uff09\uff0c\u6bcf\u52a0\u5165\u4e00\u4e2a\u70b9\u5c31\u5220\u53bb\u4e00\u4e9b\u70b9\uff0c\u4f7f\u5176\u7ef4\u6301\u51f8\u5305\u7684\u5f62\u6001\u3002\u6700\u4f18\u8f6c\u79fb\u4e00\u5b9a\u5728\u8fd9\u4e2a\u51f8\u5305\u4e2d\u3002 \u90a3\u4e48\u6839\u636e\u4e0a\u8ff0\uff0c\u6211\u4eec\u53ef\u4ee5\u6709\u4e24\u4e2a\u63a8\u8bba\uff1a 1. G[j\uff0ck]<=S[i] G[j\uff0ck]<=S[i] \uff0c\u90a3\u4e48\u4f4d\u5b50k\u5c31\u53ef\u4ee5\u88ab\u6dd8\u6c70\u3002 2. G[j\uff0ck]<=G[i\uff0cj] G[j\uff0ck]<=G[i\uff0cj] \uff0c\u90a3\u4e48\u8868\u793aj\u6bd4k\u66f4\u4f18\uff0c\u5e76\u4e14i\u6bd4j\u66f4\u4f18\uff0c\u90a3\u4e48\u4f4d\u5b50j\u662f\u53ef\u4ee5\u88ab\u6dd8\u6c70\u7684\u3002 \u4ee3\u7801\uff1a #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll h [ 200500 ] = { 0 }; ll dp [ 200500 ] = { 0 }; deque < ll > que ; double xielv ( ll i , ll j ) { double ans = ( dp [ i ] + h [ i ] * h [ i ] - dp [ j ] - h [ j ] * h [ j ]) * 1.0 / ( 2 * ( h [ i ] - h [ j ])); return ans ; } int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & h [ i ]); que . push_back ( 1 ); dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { while ( que . size () >= 2 && xielv ( que [ 0 ], que [ 1 ]) <= h [ i ]) que . pop_front (); if ( que . size ()) dp [ i ] = dp [ que [ 0 ]] + ( h [ i ] - h [ que [ 0 ]]) * ( h [ i ] - h [ que [ 0 ]]) + m ; while ( que . size () >= 2 && xielv ( que [ que . size () - 2 ], que [ que . size () - 1 ]) > xielv ( que [ que . size () - 1 ], i )) que . pop_back (); que . push_back ( i ); } cout << dp [ n ] << endl ; } \u8d2a\u5fc3 \u00b6 \u533a\u95f4\u8d2a\u5fc3\u95ee\u9898 \u00b6 \u53c2\u8003\u94fe\u63a5\uff1a https://www.cnblogs.com/dchnzlh/p/10427309.html \u533a\u95f4\u9009\u53d6\uff08\u4f1a\u573a\u5b89\u6392\u95ee\u9898\uff09 \uff0c\u7ed9\u4e00\u4e2a\u5927\u533a\u95f4l,r\u7136\u540e\u7ed9\u4f60n\u4e2a\u533a\u95f4\uff0c\u6700\u6700\u591a\u591a\u5c11\u4e2a\u533a\u95f4\u6ca1\u6709\u91cd\u590d\u90e8\u5206 \u4f8b\u5b50\uff1a \u5b66\u6821\u7684\u5c0f\u793c\u5802\u6bcf\u5929\u90fd\u4f1a\u6709\u8bb8\u591a\u6d3b\u52a8\uff0c\u6709\u65f6\u95f4\u8fd9\u4e9b\u6d3b\u52a8\u7684\u8ba1\u5212\u65f6\u95f4\u4f1a\u53d1\u751f\u51b2\u7a81\uff0c\u9700\u8981\u9009\u62e9\u51fa\u4e00\u4e9b\u6d3b\u52a8\u8fdb\u884c\u4e3e\u529e\u3002\u5c0f\u5218\u7684\u5de5\u4f5c\u5c31\u662f\u5b89\u6392\u5b66\u6821\u5c0f\u793c\u5802\u7684\u6d3b\u52a8\uff0c\u6bcf\u4e2a\u65f6\u95f4\u6700\u591a\u5b89\u6392\u4e00\u4e2a\u6d3b\u52a8\u3002\u73b0\u5728\u5c0f\u5218\u6709\u4e00\u4e9b\u6d3b\u52a8\u8ba1\u5212\u7684\u65f6\u95f4\u8868\uff0c\u4ed6\u60f3\u5c3d\u53ef\u80fd\u7684\u5b89\u6392\u66f4\u591a\u7684\u6d3b\u52a8\uff0c\u8bf7\u95ee\u4ed6\u8be5\u5982\u4f55\u5b89\u6392\u3002 \u8f93\u5165\uff1a \u7b2c\u4e00\u884c\u662f\u4e00\u4e2a\u6574\u578b\u6570m(m<100)\u8868\u793a\u5171\u6709m\u7ec4\u6d4b\u8bd5\u6570\u636e\u3002 \u6bcf\u7ec4\u6d4b\u8bd5\u6570\u636e\u7684\u7b2c\u4e00\u884c\u662f\u4e00\u4e2a\u6574\u6570n(1<n<10000)\u8868\u793a\u8be5\u6d4b\u8bd5\u6570\u636e\u5171\u6709n\u4e2a\u6d3b\u52a8\u3002 \u968f\u540e\u7684n\u884c\uff0c\u6bcf\u884c\u6709\u4e24\u4e2a\u6b63\u6574\u6570Bi,Ei(0<=Bi,Ei<10000),\u5206\u522b\u8868\u793a\u7b2ci\u4e2a\u6d3b\u52a8\u7684\u8d77\u59cb\u4e0e\u7ed3\u675f\u65f6\u95f4\uff08Bi<=Ei) \u8f93\u51fa\uff1a \u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u8f93\u5165\uff0c\u8f93\u51fa\u6700\u591a\u80fd\u591f\u5b89\u6392\u7684\u6d3b\u52a8\u6570\u91cf\u3002 \u7b56\u7565\uff1a\u6bcf\u9009\u4e00\u4e2a\u4e4b\u540e\u80fd\u7ed9\u540e\u9762\u7684\u7559\u66f4\u591a\u7684\u65f6\u95f4\uff08\u6548\u679c\uff1a\u6309\u7ed3\u675f\u65f6\u95f4\u6392\u5e8f\uff09 \u90a3\u4e48\u7b2c\u4e00\u4e2a\u65f6\uff0c\u80af\u5b9a\u9009\u6b64\u65f6\u80fd\u9009\u7684\u7ed3\u675f\u65f6\u95f4\u6700\u65e9\u7684\uff0c\u9009\u5176\u4ed6\u7684\u8bdd\u7ed9\u540e\u9762\u7559\u7684\u65f6\u95f4\u90fd\u6bd4\u524d\u8005\u5c0f\uff0c\u6240\u4ee5\u54b1\u4eec\u9009\u7684\u7b2c\u4e00\u4e2a\u80af\u5b9a\u6ca1\u9519\uff0c\u5c31\u662f\u6b64\u65f6\u80fd\u9009\u7684\u7ed3\u675f\u65f6\u95f4\u6700\u65e9\u7684\uff0c\u7136\u540e\u9009\u7b2c\u4e8c\u4e2a\u65f6\uff0c\u4e5f\u662f\u9009\u53ef\u9009\u65f6\u95f4\u4e2d\u7ed3\u675f\u6700\u65e9\u7684\uff0c\u8fd9\u6837\u4fdd\u8bc1\u6709\u5176\u6700\u4f18\u89e3\uff0c\u5f52\u7eb3\u8d77\u6765\u6fc0\u5c31\u662f\uff0c\u6bcf\u4e2a\u6839\u636e\u5f53\u524d\u53ef\u7528\u65f6\u95f4\uff0c\u9009\u53d6\u4e00\u4e2a\u7ed3\u675f\u65f6\u95f4\u6700\u65e9\u7684\uff0c\u505a\u4e3a\u4e0b\u4e00\u4e2a\u4f1a\u573a\u7684\u5b89\u6392\uff0c #include <stdio.h> #include <algorithm> using namespace std ; const int maxn = 10010 ; struct Node { int beg , end ; } node [ maxn ]; bool cmp ( Node a , Node b ) { return a . end < b . end ; } int main () { int t , n , ans ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; ++ i ) //\u8f93\u5165\u533a\u95f4 \u5e76\u5904\u7406 { scanf ( \"%d %d\" , & node [ i ]. beg , & node [ i ]. end ); node [ i ]. end ++ ; //\u5c06\u533a\u95f4\u53d8\u4e3a\u5de6\u95ed\u53f3\u5f00 } sort ( node , node + n , cmp ); //\u5c06\u533a\u95f4\u6309\u53f3\u7aef\u70b9\u6392\u5e8f,\u53f3\u7aef\u70b9\u5c0f\u7684\u5728\u524d\u9762 ans = 0 ; int pos = 0 ; //\u521d\u59cb\u5316 //pos\u610f\u4e3a\u4e0a\u4e00\u4e2a\u9009\u53d6\u7684\u6d3b\u52a8\u7ed3\u675f\u7684\u4f4d\u7f6e,\u82e5\u679cbeg>=pos\u5c31\u53ef\u4ee5\u5b89\u6392 for ( int i = 0 ; i < n ; ++ i ) { if ( node [ i ]. beg >= pos ) { ++ ans ; pos = node [ i ]. end ; } } printf ( \"%d \\n \" , ans ); } } \u533a\u95f4\u9009\u70b9\u95ee\u9898 ,n\u4e2a\u95ed\u533a\u95f4[ai,bi]\uff0c\u8ba9\u4ed6\u53d6\u5c3d\u91cf\u5c11\u7684\u70b9\uff0c\u4f7f\u5f97\u6bcf\u4e2a\u95ed\u533a\u95f4\u5185\u81f3\u5c11\u6709\u4e00\u4e2a\u70b9\u3002 \u8f93\u5165\uff1a n\u4e2a\u95ed\u533a\u95f4\uff0c \u8f93\u51fa\uff1a \u6700\u5c11\u7528\u51e0\u4e2a\u70b9\uff0c\u628a\u6bcf\u4e2a\u533a\u95f4\u90fd\u5305\u542b\u4e00\u4e2a\u70b9 \u7b56\u7565\uff1a\u8ba9\u8fd9\u4e2a\u70b9\u51fa\u73b0\u5728\u4e00\u4e2a\u6ca1\u6709\u70b9\u7684\u533a\u95f4\u4e0a\uff0c\u5c3d\u53ef\u80fd\u8986\u76d6\u591a\u7684\u533a\u95f4\u7684\u5730\u65b9 \uff08\u6548\u679c\uff1a\u6309\u7ed3\u675f\u5904\u6392\u5e8f\uff09 \u9996\u5148\u4e3a\u4e86\u5c06\u6700\u5de6\u8fb9\u7684\u4e00\u4e2a\u533a\u95f4\u8986\u76d6\uff0c\uff08\u6309\u7ed3\u675f\u6392\u5e8f\u5373\u53ef\uff09\u90a3\u4e48\u7b2c\u4e00\u4e2a\u70b9\u5fc5\u987b\u5728\u7b2c\u4e00\u4e2a\u533a\u95f4\u4e0a\uff0c\u90a3\u4e48\u5728\u533a\u95f4\u4e0a\u54ea\u5462\uff1f\u4e3a\u4e86\u8ba9\u8fd9\u4e2a\u70b9\u8ba9\u66f4\u591a\u7684\u533a\u95f4\u7684\u533a\u95f4\u78b0\u5230\uff0c\u8ba9\u8fd9\u4e2a\u70b9\u6700\u9760\u53f3\uff0c\u8fd9\u6837\u7684\u8bdd\u80fd\u4fdd\u8bc1\u8fd9\u4e2a\u70b9\u8986\u76d6\u7684\u5730\u65b9\u6700\u591a\uff0c\u7136\u540e\u4e00\u76f4\u5f80\u540e\u904d\u5386\uff0c\u76f4\u5230\u4e00\u4e2a\u533a\u95f4\u4e0d\u5728\u8fd9\u4e2a\u70b9\u4e0a\u65f6\uff0c\u4e3a\u4e86\u8ba9\u8fd9\u4e2a\u533a\u95f4\u88ab\u8986\u76d6\uff0c\u5fc5\u987b\u5728\u4ece\u8fd9\u4e2a\u533a\u95f4\u4e0a\u627e\u4e00\u70b9\uff0c\uff08\u95ee\u9898\u53d8\u4e3a\u4e86\u524d\u8005\uff09 \u6bcf\u6b21\u4e00\u4e2a\u70b9\u53ef\u4ee5\u89e3\u51b3\u4e00\u4e2a\u533a\u95f4\u6216\u8005\u82e5\u5e72\u4e2a\u533a\u95f4\uff0c\u8fd9\u904d\u5386\u5b8c\u6240\u6709\u533a\u95f4\u5373\u53ef #include <stdio.h> #include <algorithm> using namespace std ; const int maxn = 10010 ; struct Node { int beg , end ; } node [ maxn ]; bool cmp ( Node a , Node b ) { return a . end < b . end ; } int main () { int n , ans ; while ( ~ scanf ( \"%d\" , & n )) { for ( int i = 0 ; i < n ; ++ i ) //\u8f93\u5165\u533a\u95f4 \u5e76\u5904\u7406 { scanf ( \"%d %d\" , & node [ i ]. beg , & node [ i ]. end ); } sort ( node , node + n , cmp ); //\u5c06\u533a\u95f4\u6309\u53f3\u7aef\u70b9\u6392\u5e8f,\u53f3\u7aef\u70b9\u5c0f\u7684\u5728\u524d\u9762 ans = 0 ; int pos = -1 ; //pos\u4ee3\u8868\u7b2c\u4e00\u4e2a\u533a\u95f4\u9009\u53d6\u7684\u70b9 for ( int i = 0 ; i < n ; ++ i ) { if ( node [ i ]. beg > pos ) { pos = node [ i ]. end ; ++ ans ; } } printf ( \"%d \\n \" , ans ); } } \u533a\u95f4\u5b8c\u5168\u8986\u76d6\u95ee\u9898 \u95ee\u9898\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3am\u7684\u533a\u95f4\uff08\u5168\u90e8\u95ed\u5408\uff09\uff0c\u518d\u7ed9\u51fan\u6761\u7ebf\u6bb5\u7684\u8d77\u70b9\u548c\u7ec8\u70b9\uff08\u6ce8\u610f\u8fd9\u91cc\u662f\u95ed\u533a\u95f4\uff09\uff0c\u6c42\u6700\u5c11\u4f7f\u7528\u591a\u5c11\u6761\u7ebf\u6bb5\u53ef\u4ee5\u5c06\u6574\u4e2a\u533a\u95f4\u5b8c\u5168\u8986\u76d6 \u5c06\u6240\u6709\u533a\u95f4\u5316\u4f5c\u6b64\u533a\u95f4\u7684\u533a\u95f4\uff0c\u526a\u8f91\u4e00\u4e0b\uff08\u6ca1\u7528\u7684\u533a\u95f4\u5220\u9664\uff09 \u7b56\u7565\uff1a\u5728\u80fd\u8fde\u63a5\u533a\u95f4\u5de6\u8fb9\u7684\u60c5\u51b5\u4e0b\uff0c\u627e\u5230\u5411\u53f3\u8fb9\u6269\u5c55\u6700\u957f\u7684\u4f4d\u7f6e\u3002\uff08\u6548\u679c\uff1a\u6309\u5f00\u5934\u6392\u5e8f\uff0c\u5f00\u5934\u4e00\u6837\uff0c\u53f3\u8fb9\u6700\u957f\u7684\u9760\u524d\uff09 \u4e3a\u4e86\u8fde\u63a5\u5230\u8fd9\u4e2a**\u9700\u8981\u88ab\u8986\u76d6\u533a\u95f4\u7684\u5de6\u8fb9**\uff0c\u9009\u4e00\u4e2a\u5de6\u7aef\u70b9\u6700\u9760\u524d\u7684\u533a\u95f4\uff0c\u5982\u679c\u5de6\u7aef\u70b9\u76f8\u540c\u8ba9\u53f3\u7aef\u70b9\u5927\u7684\u6392\u5728\u524d\u9762 \u7136\u540e\u5411\u53f3\u626b\u63cf\u533a\u95f4\u2026\uff0c\u5982\u4f55\u627e\u4e0b\u4e00\u4e2a\u9700\u8981\u5b89\u7f6e\u7684\u533a\u95f4\u5462\uff0c\u5373\u76f4\u5230\u627e\u5230\u4e0e\u4e0a\u4e00\u4e2a\u533a\u95f4\u6ca1\u6709\u8fde\u63a5\u7684\u5730\u65b9\uff0c\u8fd9\u65f6\u5019\u5fc5\u987b\u627e\u4e00\u4e2a\u533a\u95f4\u6765\u6765\u4f5c\u4e3a\u4e00\u4e2a\u8fde\u63a5\uff0c\u56e0\u4e3a\u524d\u9762\u533a\u95f4\u90fd\u6ca1\u6709\u65ad\u5f00\uff0c\u6240\u4ee5\u5728\u524d\u9762\u626b\u63cf\u8fc7\u7684\u533a\u95f4\u627e\u5230\u4e00\u4e2a\u7ed3\u675f\u5904\u6700\u5927\u7684\u533a\u95f4\u4f5c\u4e3a\u8fde\u63a5\u5c31\u884c\uff0c\u8bb0\u4e0b\u8fd9\u4e2a\u80fd\u6269\u5c55\u5230\u53f3\u8fb9\u7684\u6700\u5927\u4f4d\u7f6e\uff08\u5176\u5b9e\u8fd9\u4e2a\u8fc7\u7a0b\u662f\u627e\u8fb9\u7684\u8fc7\u7a0b\uff09\u3002\u5982\u679c\u8fd9\u4e2a\u6700\u5927\u4f4d\u7f6e\u90fd\u4e0d\u80fd\u8fde\u7740\uff0c\u8bc1\u660e\u8fd9\u4e2a\u533a\u95f4\u4e0d\u80fd\u88ab\u5b8c\u5168\u8986\u76d6\uff01\u5373\u4e0d\u5b58\u5728\u89e3\u3002 #include <stdio.h> #include <string> #include <string.h> #include <stdlib.h> #include <algorithm> #include <math.h> using namespace std ; const int maxn = 10010 ; struct Node { double beg , end ; } node [ maxn ]; bool cmp ( Node a , Node b ) { if ( a . beg == b . beg ) return a . end > b . end ; return a . beg < b . beg ; } int main () { int t , n , cnt = 0 ; double w , h ; int ans = 0 ; double x , r ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %lf %lf\" , & n , & w , & h ); cnt = 0 ; while ( n -- ) { scanf ( \"%lf %lf\" , & x , & r ); if ( r <= h / 2.0 ) //\u8fc7\u6ee4\u6389\u65e0\u6548\u7684\u55b7\u6c34\u88c5\u7f6e continue ; double ll , rr ; //\u5b58\u4e0b\u8be5\u55b7\u6c34\u88c5\u7f6e\u533a\u95f4\u7684\u8303\u56f4 double mid = sqrt ( r * r - ( h * h / 4.0 )); ll = x - mid ; rr = x + mid ; //\u5c06\u55b7\u6c34\u88c5\u7f6e\u8f6c\u5316\u4e3a\u80fd\u8986\u76d6\u7684\u533a\u95f4 ll = max ( 0.0 , ll ); rr = min (( double ) w , rr ); node [ cnt ]. beg = ll ; node [ cnt ]. end = rr ; ++ cnt ; } /* \u6b64\u65f6\u8f6c\u5316\u4e3a\u4e00\u4e2a\u533a\u95f4\u8986\u76d6\u95ee\u9898 \u5373\u5728\u4e00\u4e2a\u957f\u5ea6\u4e3aw\u7684\u533a\u95f4\u5185 \u9009\u51fa\u6700\u5c11\u7684\u533a\u95f4\u8ba9\u8fd9\u4e2a\u533a\u95f4\u8986\u76d6 */ node [ cnt ]. beg = ( double ) w ; node [ cnt ]. end = ( double ) w ; //\u52a0\u5165\u4e00\u4e2a\u7ec8\u7aef\u533a\u95f4[w,w]\u8fd9\u6837\u904d\u5386\u5230\u6574\u4e2a\u533a\u95f4\u6700\u540e\u4f1a\u627e\u51fa\u6765\u4e00\u4e2a\u5f80\u53f3\u8fb9\u5ef6\u4f38\u5230w\u7684\u4f4d\u7f6e\u7684\u533a\u95f4\uff0c\u5982\u679c\u6ca1\u6709\u5c31\u6ca1\u7b54\u6848 ++ cnt ; sort ( node , node + cnt , cmp ); double maxpos , nowpos ; nowpos = 0.0 ; maxpos = 0.0 ; int flag = 1 ; // ans = 0 ; for ( int i = 0 ; i < cnt ; ++ i ) { if ( node [ i ]. beg <= nowpos ) //\u8fd9\u4e2a\u533a\u95f4\u53ef\u4ee5\u4e0e\u524d\u9762\u7684\u533a\u95f4\u8fde\u7740 maxpos = max ( maxpos , node [ i ]. end ); //\u66f4\u65b0\u8bfe\u6269\u5c55\u7684\u6700\u5927\u533a\u95f4 else { if ( maxpos >= node [ i ]. beg ) //\u9047\u5230\u4e00\u4e2a\u95f4\u9694\u7684 \u9700\u8981\u627e\u4e00\u4e2a\u533a\u95f4\u8865\u4e00\u4e0b { ans ++ ; nowpos = maxpos ; -- i ; } else //\u5982\u679c\u4e0d\u80fd\u8865 { flag = 0 ; break ; //\u65e0\u89e3 } } } if ( flag ) printf ( \"%d \\n \" , ans ); else printf ( \"0 \\n \" ); } } \u8ba1\u7b97\u673a\u56fe\u5f62\u5b66 \u00b6 \u51f8\u5305\u7b97\u6cd5 \u00b6 #include <iostream> #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #define PI 3.1415926535 using namespace std ; struct node { int x , y ; }; node vex [ 1000 ]; //\u5b58\u5165\u7684\u6240\u6709\u7684\u70b9 node stackk [ 1000 ]; //\u51f8\u5305\u4e2d\u6240\u6709\u7684\u70b9 int xx , yy ; bool cmp1 ( node a , node b ) //\u6392\u5e8f\u627e\u7b2c\u4e00\u4e2a\u70b9 { if ( a . y == b . y ) return a . x < b . x ; else return a . y < b . y ; } int cross ( node a , node b , node c ) //\u8ba1\u7b97\u53c9\u79ef { return ( b . x - a . x ) * ( c . y - a . y ) - ( c . x - a . x ) * ( b . y - a . y ); } double dis ( node a , node b ) //\u8ba1\u7b97\u8ddd\u79bb { return sqrt (( a . x - b . x ) * ( a . x - b . x ) * 1.0 + ( a . y - b . y ) * ( a . y - b . y )); } bool cmp2 ( node a , node b ) //\u6781\u89d2\u6392\u5e8f\u53e6\u4e00\u79cd\u65b9\u6cd5\uff0c\u901f\u5ea6\u5feb { if ( atan2 ( a . y - yy , a . x - xx ) != atan2 ( b . y - yy , b . x - xx )) return ( atan2 ( a . y - yy , a . x - xx )) < ( atan2 ( b . y - yy , b . x - xx )); return a . x < b . x ; } bool cmp ( node a , node b ) //\u6781\u89d2\u6392\u5e8f { int m = cross ( vex [ 0 ], a , b ); if ( m > 0 ) return 1 ; else if ( m == 0 && dis ( vex [ 0 ], a ) - dis ( vex [ 0 ], b ) <= 0 ) return 1 ; else return 0 ; /*if(m==0) return dis(vex[0],a)-dis(vex[0],b)<=0?true:false; else return m>0?true:false;*/ } int main () { int t , L ; while ( ~ scanf ( \"%d\" , & t ), t ) { int i ; for ( i = 0 ; i < t ; i ++ ) { scanf ( \"%d%d\" , & vex [ i ]. x , & vex [ i ]. y ); } if ( t == 1 ) printf ( \"%.2f \\n \" , 0.00 ); else if ( t == 2 ) printf ( \"%.2f \\n \" , dis ( vex [ 0 ], vex [ 1 ])); else { memset ( stackk , 0 , sizeof ( stackk )); sort ( vex , vex + t , cmp1 ); stackk [ 0 ] = vex [ 0 ]; xx = stackk [ 0 ]. x ; yy = stackk [ 0 ]. y ; sort ( vex + 1 , vex + t , cmp2 ); //cmp2\u662f\u66f4\u5feb\u7684\uff0ccmp\u66f4\u5bb9\u6613\u7406\u89e3 stackk [ 1 ] = vex [ 1 ]; //\u5c06\u51f8\u5305\u4e2d\u7684\u7b2c\u4e24\u4e2a\u70b9\u5b58\u5165\u51f8\u5305\u7684\u7ed3\u6784\u4f53\u4e2d int top = 1 ; //\u6700\u540e\u51f8\u5305\u4e2d\u62e5\u6709\u70b9\u7684\u4e2a\u6570 for ( i = 2 ; i < t ; i ++ ) { while ( i >= 1 && cross ( stackk [ top -1 ], stackk [ top ], vex [ i ]) < 0 ) //\u5bf9\u4f7f\u7528\u6781\u89d2\u6392\u5e8f\u7684i>=1\u6709\u65f6\u53ef\u4ee5\u4e0d\u7528\uff0c\u4f46\u52a0\u4e0a\u603b\u662f\u597d\u7684 top -- ; stackk [ ++ top ] = vex [ i ]; //\u63a7\u5236<0\u6216<=0\u53ef\u4ee5\u63a7\u5236\u91cd\u70b9\uff0c\u5171\u7ebf\u7684\uff0c\u5177\u4f53\u89c6\u9898\u76ee\u800c\u5b9a\u3002 } double s = 0 ; //for(i=1; i<=top; i++)//\u8f93\u51fa\u51f8\u5305\u4e0a\u7684\u70b9 //cout<<stackk[i].x<<\" \"<<stackk[i].y<<endl; for ( i = 1 ; i <= top ; i ++ ) //\u8ba1\u7b97\u51f8\u5305\u7684\u5468\u957f s += dis ( stackk [ i -1 ], stackk [ i ]); s += dis ( stackk [ top ], vex [ 0 ]); //\u6700\u540e\u4e00\u4e2a\u70b9\u548c\u7b2c\u4e00\u4e2a\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb /*s+=2*PI*L; int ans=s+0.5;//\u56db\u820d\u4e94\u5165 printf(\"%d\\n\",ans);*/ printf ( \"%.2lf \\n \" , s ); } } } \u6c42\u4efb\u610f\u591a\u8fb9\u5f62\u9762\u79ef \u00b6 #include <bits/stdc++.h> using namespace std ; struct Point { double x , y ; } p [ 100500 ]; int n ; double polygonarea () { int i , j ; double area = 0 ; for ( i = 1 ; i <= n ; ++ i ){ if ( i < n ) j = i + 1 ; else j = 1 ; area += p [ i ]. x * p [ j ]. y ; area -= p [ i ]. y * p [ j ]. x ; } area /= 2.0 ; return ( area < 0 ?- area : area ); } int main () { while ( scanf ( \"%d\" , & n ) != EOF && n != 0 ) { for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%lf%lf\" , & p [ i ]. x , & p [ i ]. y ); printf ( \"%.1f \\n \" , polygonarea ()); } } \u626b\u63cf\u7ebf\u7b97\u6cd5 \u00b6 \u7ebf\u6bb5\u6811+\u626b\u63cf\u7ebf\u6c42\u6b63\u65b9\u5f62\u989c\u8272\u53cd\u8f6c \u8f93\u5165\uff1a 1 5 2 2 4 1 3 1 5 3 5 \u4ee3\u88681\u7ec4\u6d4b\u8bd5\u6837\u4f8b\uff0c\u7ed9\u5b9a5*2\u7684\u6b63\u65b9\u5f62\uff0c\u5c062<=x<=4&&1<=y<=3\u7684\u8303\u56f4\u5185\u7684\u5c0f\u6b63\u65b9\u5f62\u8fdb\u884c\u9ed1\u767d\u53cd\u8f6c\uff0c\u6c42\u6700\u7ec8\u9ed1\u8272\u6b63\u65b9\u5f62\u7684\u4e2a\u6570\uff0c\u7b54\u6848\u4e3a18. #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int h , a , b , num ; }; int mark [ 100500 ] = { 0 }; int sum [ 100500 ] = { 0 }; node edge [ 100500 ] = { 0 }; bool cmp ( node a , node b ) { if ( a . h == b . h ) return a . num > b . num ; else return a . h < b . h ; } int nodeupdate ( int root , int l , int r , ll num ) { mark [ root ] ^= 1 ; sum [ root ] = r - l + 1 - sum [ root ]; } int pushdown ( int root , int l , int r ) { if ( mark [ root ] == 0 ) return 0 ; int mid = ( l + r ) / 2 ; nodeupdate ( 2 * root , l , mid , mark [ root ]); nodeupdate ( 2 * root + 1 , mid + 1 , r , mark [ root ]); mark [ root ] = 0 ; } int update ( int root , int l , int r , int L , int R , ll num ) { if ( l >= L && r <= R ) { nodeupdate ( root , l , r , num ); return 0 ; } pushdown ( root , l , r ); int mid = ( l + r ) / 2 ; if ( mid >= L ) update ( root * 2 , l , mid , L , R , num ); if ( mid < R ) update ( root * 2 + 1 , mid + 1 , r , L , R , num ); sum [ root ] = sum [ 2 * root ] + sum [ 2 * root + 1 ]; } int main () { int t , cnt ; scanf ( \"%d\" , & t ); while ( t -- ) { memset ( sum , 0 , sizeof ( sum )); memset ( mark , 0 , sizeof ( mark )); int n , m , ans = 0 ; cnt = 0 ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int x1 , y1 , x2 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & x2 , & y1 , & y2 ); edge [ cnt ++ ] = node { y1 , x1 , x2 , 1 }; edge [ cnt ++ ] = node { y2 , x1 , x2 , -1 }; } sort ( edge , edge + cnt , cmp ); for ( int i = 1 , j = 0 ; i <= n ; i ++ ) { while ( j < cnt && edge [ j ]. h <= i && edge [ j ]. num == 1 ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } ans += sum [ 1 ]; while ( j < cnt && edge [ j ]. h <= i ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } } cout << ans << endl ; } return 0 ; } \u7ebf\u6bb5\u6811\u79bb\u6563\u5316\u6c42\u9762\u79ef\u7684\u5e76\uff1a #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll n ; ll s [ 400500 ] = { 0 }; ll len [ 400500 ] = { 0 }; ll x [ 400500 ] = { 0 }; unordered_map < ll , ll > mpx ; void push_up ( ll t , ll l , ll r ) { if ( s [ t ]) len [ t ] = x [ r + 1 ] - x [ l ]; else if ( l == r ) len [ t ] = 0 ; else len [ t ] = len [ 2 * t + 1 ] + len [ 2 * t ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { s [ t ] += add ; push_up ( t , L , R ); return ; } ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t , L , R ); } struct node1 { ll l , r , h , d ; }; node1 edge [ 200500 ] = { 0 }; bool cmp ( node1 a , node1 b ) { return a . h < b . h ; } int main () { scanf ( \"%lld\" , & n ); ll cnt = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll x1 , x2 , y1 , y2 ; scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); x [ ++ cnt ] = x1 , edge [ cnt ] = { x1 , x2 , y1 , 1 }; x [ ++ cnt ] = x2 , edge [ cnt ] = { x1 , x2 , y2 , -1 }; } sort ( x + 1 , x + cnt + 1 ); sort ( edge + 1 , edge + cnt + 1 , cmp ); ll m = unique ( x + 1 , x + cnt + 1 ) - x -1 ; for ( int i = 1 ; i <= m ; i ++ ) mpx [ x [ i ]] = i ; ll ans = 0 ; for ( ll i = 1 ; i < cnt ; i ++ ) { ll l = mpx [ edge [ i ]. l ], r = mpx [ edge [ i ]. r ]; update ( 1 , l , r -1 , 1 , m , edge [ i ]. d ); ans += len [ 1 ] * ( edge [ i + 1 ]. h - edge [ i ]. h ); } cout << ans << endl ; } \u626b\u63cf\u7ebf\u7ef4\u62a4\u533a\u95f4\u5185\u6240\u6709\u957f\u65b9\u5f62\u8fb9\u957f\u957f\u5ea6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; int n ; int lazy [ 400500 ] = { 0 }; int len [ 400500 ] = { 0 }; int x [ 100500 ] = { 0 }; int vis [ 50050 ] = { 0 }; unordered_map < int , int > mpx ; void push_up ( int t , int l , int r ) { if ( l == r ) len [ t ] = 0 ; else len [ t ] = len [ 2 * t + 1 ] + len [ 2 * t ]; } void push_down ( int t , int l , int r ) { if ( lazy [ t ]) { int mid = ( l + r ) / 2 ; len [ 2 * t ] += lazy [ t ] * ( x [ mid + 1 ] - x [ l ]); len [ 2 * t + 1 ] += lazy [ t ] * ( x [ r + 1 ] - x [ mid + 1 ]); lazy [ 2 * t + 1 ] += lazy [ t ]; lazy [ 2 * t ] += lazy [ t ]; lazy [ t ] = 0 ; } } int query ( int t , int l , int r , int L , int R ) { if ( l <= L && R <= r ) return len [ t ]; push_down ( t , L , R ); int ans = 0 , mid = ( L + R ) / 2 ; if ( l <= mid ) ans += query ( 2 * t , l , r , L , mid ); if ( mid < r ) ans += query ( 2 * t + 1 , l , r , mid + 1 , R ); return ans ; } void update ( int t , int l , int r , int L , int R , int add ) { if ( l <= L && R <= r ) { lazy [ t ] += add ; len [ t ] += add * ( x [ r + 1 ] - x [ l ]); return ; } int mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t , L , R ); } struct node1 { int l , r , h , d , id ; }; node1 edge [ 100500 ] = { 0 }; bool cmp ( node1 a , node1 b ) { return a . h < b . h ; } int main () { scanf ( \"%d\" , & n ); int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int x1 , x2 , y1 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & y1 , & x2 , & y2 ); x [ ++ cnt ] = x1 , edge [ cnt ] = { x1 , x2 , y1 , 1 , i }; x [ ++ cnt ] = x2 , edge [ cnt ] = { x1 , x2 , y2 , -1 , i }; } sort ( x + 1 , x + cnt + 1 ); sort ( edge + 1 , edge + cnt + 1 , cmp ); int m = unique ( x + 1 , x + cnt + 1 ) - x - 1 ; for ( int i = 1 ; i <= m ; i ++ ) mpx [ x [ i ]] = i ; for ( int i = 1 ; i <= cnt ; i ++ ) { int l = mpx [ edge [ i ]. l ], r = mpx [ edge [ i ]. r ]; if ( edge [ i ]. d == 1 && query ( 1 , l , r - 1 , 1 , m ) != 0 ) vis [ edge [ i ]. id ] = 1 ; if ( vis [ edge [ i ]. id ] == 1 ) continue ; update ( 1 , l , r - 1 , 1 , m , edge [ i ]. d ); } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += ( ! vis [ i ]); cout << ans << endl ; } \u535a\u5f08\u8bba \u00b6 \u5df4\u4ec0\u535a\u5f08 \u00b6 \u53ea\u6709\u4e00\u5806n\u4e2a\u7269\u54c1\uff0c\u4e24\u4e2a\u4eba\u4ece\u8f6e\u6d41\u4e2d\u53d6\u51fa\uff081~m\uff09\u4e2a\uff1b\u6700\u540e\u53d6\u5149\u8005\u80dc\u3002 \u82e5n=k*(m+1) \u90a3\u4e48\u5148\u53d6\u8005\u5fc5\u8f93\u3002 int Bash_Game ( int n , int m ) //\u662f\u5426\u5148\u624b\u6709\u5fc5\u8d62\u7b56\u7565 { if ( n % ( m + 1 ) != 0 ) return 1 ; return 0 ; } \u5c3c\u59c6\u535a\u5f08 \u00b6 \u6709\u82e5\u5e72\u5806\u5404\u82e5\u5e72\u4e2a\u7269\u54c1\uff0c\u4e24\u4e2a\u4eba\u8f6e\u6d41\u4ece\u67d0\u4e00\u5806\u53d6\u4efb\u610f\u591a\u7684\u7269\u54c1\uff0c\u89c4\u5b9a\u6bcf\u6b21\u81f3\u5c11\u53d6\u4e00\u4e2a\uff0c\u591a\u8005\u4e0d\u9650\uff0c\u6700\u540e\u53d6\u5149\u8005\u5f97\u80dc\u3002 XOR \u5224\u65ad: int Nimm_Game ( int n ) //\u5047\u8bben\u4e2a\u6570\u5b58\u5728\u6570\u7ec4f[]\u4e2d,\u6709\u5fc5\u80dc\u7b56\u7565\u8fd4\u56de1 { int flag = 0 ; for ( int i = 1 ; i <= n ; i ++ ) flag ^= f [ i ]; if ( flag ) return 1 ; return 0 ; } \u5a01\u4f50\u592b\u535a\u5955 \u00b6 \u6709\u4e24\u5806\u5404\u82e5\u5e72\u4e2a\u7269\u54c1\uff0c\u4e24\u4e2a\u4eba\u8f6e\u6d41\u4ece\u67d0\u4e00\u5806\u6216\u540c\u65f6\u4ece\u4e24\u5806\u4e2d\u53d6\u540c\u6837\u591a\u7684\u7269\u54c1\uff0c\u89c4\u5b9a\u6bcf\u6b21\u81f3\u5c11\u53d6\u4e00\u4e2a\uff0c\u591a\u8005\u4e0d\u9650\uff0c\u6700\u540e\u53d6\u5149\u8005\u5f97\u80dc\u3002 \u5224\u65ad\u662f\u5426\u4e3a\u5947\u5f02\u5c40\u52bf \u8bbex= k=[a*x]\uff0c\u5411\u4e0a\u53d6\u6574 \u5982\u679ca+k=b\uff0c\u5219\uff08a\uff0cb\uff09\u4e3a\u5947\u5f02\u5c40\u52bf\uff0c\u540e\u624b\u80dc\uff0c\u53cd\u4e4b\u4e3a\u5148\u624b\u80dc \u5bf9\u5e94\u7684\u4ee3\u7801\u5728\u8fd9\u91cc\uff1a int Wythoff_Game ( int a , int b ) { if ( a > b ) swap ( a , b ); double x = ( sqrt ( 5.0 ) -1.0 ) / 2.0 ; int k = ceil ( 1.0 * a * x ); if ( a + k == b ) return 0 ; //\u5947\u5f02\u5c40\u52bf\uff0c\u540e\u624b\u80dc\uff01 else return 1 ; //\u975e\u5947\u5f02\u5c40\u52bf\uff0c\u5148\u624b\u80dc\uff01 } SG\u51fd\u6570\u548cNIM\u535a\u5f08 \u00b6 \u9898\u76ee\u9898\u89e3 \u9898\u76ee\u94fe\u63a5 SG\u51fd\u6570\u8be6\u89e3 #include <bits/stdc++.h> using namespace std ; bool vis [ 300 ] = { 0 }; int sg [ 110 ][ 110 ] = { 0 }; void init () { for ( int i = 0 ; i <= 100 ; i ++ ) sg [ i ][ i ] = sg [ i ][ 0 ] = sg [ 0 ][ i ] = 199 ; for ( int i = 0 ; i <= 100 ; i ++ ) { for ( int j = 0 ; j <= 100 ; j ++ ) { if ( i == j || i == 0 || j == 0 ) continue ; memset ( vis , 0 , sizeof ( vis )); for ( int a = 0 ; a < i ; a ++ ) vis [ sg [ a ][ j ]] = 1 ; for ( int b = 0 ; b < j ; b ++ ) vis [ sg [ i ][ b ]] = 1 ; for ( int c = min ( i , j ); c >= 1 ; c -- ) vis [ sg [ i - c ][ j - c ]] = 1 ; for ( int k = 0 ;; k ++ ) { if ( ! vis [ k ]) { sg [ i ][ j ] = k ; break ; } } } } } int main () { int n ; scanf ( \"%d\" , & n ); int a , b ; int nim = 0 ; init (); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d%d\" , & a , & b ); if ( a == b ) { printf ( \"Y \\n \" ); return 0 ; } nim ^= sg [ a ][ b ]; } if ( nim != 0 ) printf ( \"Y \\n \" ); else printf ( \"N \\n \" ); }","title":"\u4e2a\u4eba\u6a21\u677f"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_1","text":"","title":"\u6742\u9879"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#o2","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #define inf1 0x3f3f3f3f #define inf2 0x3f3f3f3f3f3f3f3f const double Pi = acos ( -1 ); std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( 0 ); cout << fixed << setprecision ( 20 ) << ans << endl ;","title":"\u5feb\u8bfb&amp;O2\u4f18\u5316"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#read","text":"inline int read () { int z = 0 , flag = 1 ; char ch = getchar (); while ( ch < '0' || ch > '9' ) { if ( ch == '-' ) flag = -1 ; ch = getchar (); } while ( ch >= '0' && ch <= '9' ) { z = z * 10 + ch - '0' ; ch = getchar (); } return z * flag ; }","title":"read\u51fd\u6570\u5feb\u8bfb"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#__int128","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; __int128 int128read () { __int128 x = 0 ; int flag = 1 ; string a ; cin >> a ; for ( char c : a ) { if ( c == '-' ) flag = -1 ; else x = x * 10 + c - '0' ; } return flag * x ; } void int128print ( __int128 x ) { if ( x < 0 ) { putchar ( '-' ); x =- x ; } if ( x > 9 ) int128print ( x / 10 ); putchar ( x % 10 + '0' ); } int main () { __int128 a = int128read (), b = int128read (); int128print ( a + b ); }","title":"\u51fd\u6570\u5f0f__int128 \u8f93\u5165\u548c\u8f93\u51fa"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#__int128_1","text":"#include <bits/stdc++.h> using namespace std ; istream & operator >> ( istream & in , __int128 & x ) { x = 0 ; int flag = 1 ; string a ; in >> a ; for ( char c : a ) { if ( c == '-' ) flag = -1 ; else x = x * 10 + c - '0' ; } x = flag * x ; return in ; } ostream & operator << ( ostream & out , __int128 & x ) { if ( x < 0 ) { out << '-' ; x = - x ; } stack < int > s ; while ( x ) { s . push ( x % 10 ); x /= 10 ; } while ( ! s . empty ()) { out << s . top (); s . pop (); } return out ; } int main () { __int128 a , b ; cin >> a >> b ; cout << a << ' ' << b << endl ; return 0 ; }","title":"\u91cd\u8f7d\u5f0f __int128 \u8f93\u5165\u548c\u8f93\u51fa"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#java-acm","text":"import java.io.* ; import java.math.* ; import java.util.* ; public class Main { public static void main ( String args [] ) { //BigDecimal\u5927\u6570Double\u7c7b //\u8bfb\u5165 Scanner cin = new Scanner ( new BufferedInputStream ( System . in )); int a ; double b ; BigInteger c ; String d ; a = cin . nextInt (); b = cin . nextDouble (); c = cin . nextBigInteger (); d = cin . nextLine (); // \u6bcf\u79cd\u7c7b\u578b\u90fd\u6709\u76f8\u5e94\u7684\u8f93\u5165\u51fd\u6570. System . out . printf ( \"\u8f93\u5165\u7684\u4e3a%d %f %s %s\\n\" , a , b , c . toString (), d ); c = cin . nextBigInteger ( 2 ); //\u5927\u6570\u4ee52\u8fdb\u5236\u8bfb\u5165 String tmp = c . toString ( 2 ); ///\u5c06\u5927\u6570\u4ee5\u4e8c\u8fdb\u5236\u5f62\u5f0f\u8f93\u51fa System . out . print ( 1 ); // cout << \u2026; System . out . println ( 1 ); // cout << \u2026 << endl; System . out . printf ( \"%d\" , 1 ); // \u4e0eC\u4e2d\u7684printf\u7528\u6cd5\u7c7b\u4f3c. ///\u5b57\u7b26\u4e32\u5904\u7406 String st = \"abcdefg\" ; System . out . println ( st . charAt ( 0 )); // st.charAt(i)\u5c31\u76f8\u5f53\u4e8est[i]. char [] ch ; ch = st . toCharArray (); // \u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u5b57\u7b26\u6570\u7ec4. for ( int i = 0 ; i < ch . length ; i ++ ) ch [ i ] += 1 ; System . out . println ( ch ); // \u8f93\u5165\u4e3a\u201cbcdefgh\u201d. if ( st . startsWith ( \"a\" )) // \u5982\u679c\u5b57\u7b26\u4e32\u4ee5'0'\u5f00\u5934. st = st . substring ( 1 ); // \u5219\u4ece\u7b2c1\u4f4d\u5f00\u59cbcopy(\u5f00\u5934\u4e3a\u7b2c0\u4f4d). ///\u8fdb\u5236\u8f6c\u5316 int num = 15 , base = 2 ; System . out . printf ( \"15\u8f6c2\u8fdb\u5236\u4e3a%s\\n\" , Integer . toString ( num , base )); st = \"1111\" ; System . out . printf ( \"2\u8fdb\u5236\u76841111\u8f6c10\u8fdb\u5236\u4e3a%d\\n\" , Integer . parseInt ( st , base )); // \u628ast\u5f53\u505abase\u8fdb\u5236\uff0c\u8f6c\u621010\u8fdb\u5236\u7684int(parseInt\u6709\u4e24\u4e2a\u53c2\u6570,\u7b2c\u4e00\u4e2a\u4e3a\u8981\u8f6c\u7684\u5b57\u7b26\u4e32,\u7b2c\u4e8c\u4e2a\u4e3a\u8fdb\u5236). BigInteger m = new BigInteger ( st , base ); // st\u662f\u5b57\u7b26\u4e32\uff0cbase\u662fst\u7684\u8fdb\u5236. ///\u6392\u5e8f int n = cin . nextInt (); Integer [] arr = new Integer [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ]= cin . nextInt (); Arrays . sort ( arr , new Comparator < Integer > () { @Override public int compare ( Integer o1 , Integer o2 ) { return o2 - o1 ; ///\u4ece\u5927\u5230\u5c0f\u6392\u5e8f } }); for ( int i = 0 ; i < n ; i ++ ) System . out . printf ( \"%d \" , arr [ i ] ); System . out . println (); ///\u6e05\u7a7a Arrays . fill ( arr , 5 ); for ( int i = 0 ; i < n ; i ++ ) System . out . printf ( \"%d \" , arr [ i ] ); System . out . println (); ///\u4e8c\u5206\u67e5\u627e System . out . println ( Arrays . binarySearch ( arr , 5 )); ///\u5982\u679ckey\u5728\u6570\u7ec4\u4e2d\uff0c\u5219\u8fd4\u56de\u641c\u7d22\u503c\u7684\u7d22\u5f15\uff1b\u5426\u5219\u8fd4\u56de-1\u6216\u8005\u201d-\u201c(\u63d2\u5165\u70b9)\u3002 ///\u63d2\u5165\u70b9\u662f\u7d22\u5f15\u952e\u5c06\u8981\u63d2\u5165\u6570\u7ec4\u7684\u90a3\u4e00\u70b9\uff0c\u5373\u7b2c\u4e00\u4e2a\u5927\u4e8e\u8be5\u952e\u7684\u5143\u7d20\u7d22\u5f15\u3002 } }","title":"java ACM \u57fa\u7840"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#java-biginteger","text":"import java.io.* ; import java.math.* ; import java.util.* ; public class Main { public static void main ( String args [] ) { Scanner cin = new Scanner ( System . in ); while ( cin . hasNext ()) ///\u76f8\u5f53\u4e8e scanf()!=EOF { BigInteger a , b , c ; //\u5927\u6570\u521d\u59cb\u5316 //1.\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32 BigInteger interNum1 = new BigInteger ( \"1011100111\" , 2 ); //2.\u5341\u8fdb\u5236\u5b57\u7b26\u4e32 BigInteger interNum2 = new BigInteger ( \"123456\" ); //3.\u5341\u8fdb\u5236\u6570\u5b57 BigInteger interNum3 = BigInteger . valueOf ( 8 ); //\u5927\u6570\u8bfb\u5165 a = cin . nextBigInteger (); b = cin . nextBigInteger (); //\u57fa\u672c\u8fd0\u7b97 //1.\u628aa\u4e0eb\u76f8\u52a0\u5e76\u8d4b\u7ed9c c = a . add ( b ); //2.\u628aa\u4e0eb\u76f8\u51cf\u5e76\u8d4b\u7ed9c c = a . subtract ( b ); //3.\u628aa\u4e0eb\u76f8\u4e58\u5e76\u8d4b\u7ed9c c = a . multiply ( b ); //4.\u628aa\u4e0eb\u76f8\u9664\u5e76\u8d4b\u7ed9c c = a . divide ( b ); //5.\u53d6\u6a21\uff0c(\u9700 b > 0\uff0c\u5426\u5219\u51fa\u73b0\u5f02\u5e38\uff1aArithmeticException(\"BigInteger: modulus not positive\")) c = a . mod ( b ); //6.\u6c42\u4f59 c = a . remainder ( b ); //7.\u76f8\u5f53\u4e8ea^b c = a . pow ( 2 ); //8.\u6839\u636e\u8be5\u6570\u503c\u662f\u5c0f\u4e8e\u3001\u7b49\u4e8e\u3001\u6216\u5927\u4e8ea \u8fd4\u56de -1\u30010 \u6216 1 int ans1 = a . compareTo ( b ); //9.\u5224\u65ad\u4e24\u6570\u662f\u5426\u76f8\u7b49\uff0c\u4e5f\u53ef\u4ee5\u7528compareTo\u6765\u4ee3\u66ff boolean ans2 = a . equals ( b ); //10.\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c c = a . min ( b ); c = a . max ( b ); //\u7c7b\u578b\u8f6c\u6362 //1.\u8f6c\u6362\u4e3abigNum\u7684\u4e8c\u8fdb\u5236\u8865\u7801\u5f62\u5f0f byte [] num1 = a . toByteArray (); //2.\u8f6c\u6362\u4e3abigNum\u7684\u5341\u8fdb\u5236\u5b57\u7b26\u4e32\u5f62\u5f0f String num2 = a . toString (); //3.\u8f6c\u6362\u4e3abigNum\u7684radix\u8fdb\u5236\u5b57\u7b26\u4e32\u5f62\u5f0f String num3 = a . toString ( 2 ); //4.\u5c06bigNum\u8f6c\u6362\u4e3aint int num4 = a . intValue (); //5.\u5c06bigNum\u8f6c\u6362\u4e3along long num5 = a . longValue (); //6.\u5c06bigNum\u8f6c\u6362\u4e3afloat float num6 = a . floatValue (); //7.\u5c06bigNum\u8f6c\u6362\u4e3adouble double num7 = a . doubleValue (); //\u4e8c\u8fdb\u5236\u8fd0\u7b97 //1.\u4e0e\uff1aa&b BigInteger bigNum1 = a . and ( b ); //2.\u6216\uff1aa|b BigInteger bigNum2 = a . or ( b ); //3.\u5f02\u6216\uff1aa^b BigInteger bigNum3 = a . xor ( b ); //4.\u53d6\u53cd\uff1a~a BigInteger bigNum4 = a . not (); //5.\u5de6\u79fbn\u4f4d\uff1a (a << n) BigInteger bigNum5 = a . shiftLeft ( 3 ); //6.\u53f3\u79fbn\u4f4d\uff1a (a >> n) BigInteger bigNum6 = a . shiftRight ( 3 ); } } }","title":"java BigInteger \u8fd0\u7b97"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#java-bigdecimal","text":"import java.io.* ; import java.math.* ; import java.util.* ; public class Main { public static void main ( String args [] ) { Scanner cin = new Scanner ( System . in ); while ( cin . hasNext ()) ///\u76f8\u5f53\u4e8e scanf()!=EOF { BigDecimal a , b , c ; //\u5927\u6570\u521d\u59cb\u5316 //1.\u5341\u8fdb\u5236\u5b57\u7b26\u4e32 BigDecimal interNum1 = new BigDecimal ( \"0.005\" ); //2.\u5341\u8fdb\u5236\u6570\u5b57 BigDecimal interNum2 = new BigDecimal ( 0.000005 ); BigDecimal interNum3 = BigDecimal . valueOf ( 0.000005 ); //\u5927\u6570\u8bfb\u5165 a = cin . nextBigDecimal (); b = cin . nextBigDecimal (); //\u5927\u6570\u4fdd\u7559\u5c0f\u6570\u4f4d\u8f93\u51fa BigDecimal d = a . setScale ( 10 , RoundingMode . HALF_UP ); //\u4fdd\u7559\u5341\u4f4d\u5c0f\u6570 System . out . println ( d ); //\u57fa\u672c\u8fd0\u7b97 //1.\u628aa\u4e0eb\u76f8\u52a0\u5e76\u8d4b\u7ed9c c = a . add ( b ); //2.\u628aa\u4e0eb\u76f8\u51cf\u5e76\u8d4b\u7ed9c c = a . subtract ( b ); //3.\u628aa\u4e0eb\u76f8\u4e58\u5e76\u8d4b\u7ed9c c = a . multiply ( b ); //4.\u628aa\u4e0eb\u76f8\u9664\u5e76\u8d4b\u7ed9c c = a . divide ( b , 10 , BigDecimal . ROUND_UP ); //\u820d\u5165\u8fdc\u79bb\u96f6\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_DOWN ); //\u63a5\u8fd1\u96f6\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_CEILING ); //\u63a5\u8fd1\u6b63\u65e0\u7a77\u5927\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_FLOOR ); //\u63a5\u8fd1\u8d1f\u65e0\u7a77\u5927\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_HALF_UP ); //\u5411\u201c\u6700\u63a5\u8fd1\u7684\u201d\u6570\u5b57\u820d\u5165\uff0c\u5982\u679c\u4e0e\u4e24\u4e2a\u76f8\u90bb\u6570\u5b57\u7684\u8ddd\u79bb\u76f8\u7b49\uff0c\u5219\u4e3a\u5411\u4e0a\u820d\u5165\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_HALF_DOWN ); //\u5411\u201c\u6700\u63a5\u8fd1\u7684\u201d\u6570\u5b57\u820d\u5165\uff0c\u5982\u679c\u4e0e\u4e24\u4e2a\u76f8\u90bb\u6570\u5b57\u7684\u8ddd\u79bb\u76f8\u7b49\uff0c\u5219\u4e3a\u4e0a\u820d\u5165\u7684\u820d\u5165\u6a21\u5f0f\u3002 c = a . divide ( b , 10 , BigDecimal . ROUND_HALF_EVEN ); //\u5411\u201c\u6700\u63a5\u8fd1\u7684\u201d\u6570\u5b57\u820d\u5165\uff0c\u5982\u679c\u4e0e\u4e24\u4e2a\u76f8\u90bb\u6570\u5b57\u7684\u8ddd\u79bb\u76f8\u7b49\uff0c\u5219\u5411\u76f8\u90bb\u7684\u5076\u6570\u820d\u5165\u3002 //5.\u6c42\u4f59 c = a . remainder ( b ); //6.\u76f8\u5f53\u4e8ea^b c = a . pow ( 2 ); //7.\u6839\u636e\u8be5\u6570\u503c\u662f\u5c0f\u4e8e\u3001\u7b49\u4e8e\u3001\u6216\u5927\u4e8ea \u8fd4\u56de -1\u30010 \u6216 1 int ans1 = a . compareTo ( b ); //8.\u5224\u65ad\u4e24\u6570\u662f\u5426\u76f8\u7b49\uff0c\u4e5f\u53ef\u4ee5\u7528compareTo\u6765\u4ee3\u66ff boolean ans2 = a . equals ( b ); //9.\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c c = a . min ( b ); c = a . max ( b ); //10.\u7edd\u5bf9\u503c c = a . abs (); //\u7c7b\u578b\u8f6c\u6362 //1.\u8f6c\u6362\u4e3abigNum\u7684\u5341\u8fdb\u5236\u5b57\u7b26\u4e32\u5f62\u5f0f String num2 = a . toString (); //2.\u5c06bigNum\u8f6c\u6362\u4e3aint int num4 = a . intValue (); //3.\u5c06bigNum\u8f6c\u6362\u4e3along long num5 = a . longValue (); //4.\u5c06bigNum\u8f6c\u6362\u4e3afloat float num6 = a . floatValue (); //5.\u5c06bigNum\u8f6c\u6362\u4e3adouble double num7 = a . doubleValue (); } } }","title":"java BigDecimal \u8fd0\u7b97"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_2","text":"int getWeek ( int y , int m , int d ) { if ( m == 1 || m == 2 ) { m += 12 ; y -- ; } int week = ( d + 1 + 2 * m + 3 * ( m + 1 ) / 5 + y + y / 4 - y / 100 + y / 400 ) % 7 ; return week ; }","title":"\u5224\u65ad\u5468\u51e0"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_3","text":"","title":"\u7ec4\u5408\u6570\u5947\u5076\u5224\u65ad"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_4","text":"","title":"\u56fe\u8bba"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#prim","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; struct node { int to , val ; }; vector < node > v [ 100500 ]; struct node1 { int now , val ; bool operator < ( const node1 & a ) const { return a . val < val ; } }; priority_queue < node1 > que ; int dis [ 100500 ] = { 0 }; void prim () { memset ( dis , -1 , sizeof ( dis )); que . push ({ 1 , 0 }); while ( ! que . empty ()) { node1 now = que . top (); que . pop (); if ( dis [ now . now ] != -1 ) continue ; dis [ now . now ] = now . val ; for ( int i = 0 ; i < v [ now . now ]. size (); i ++ ) { int to = v [ now . now ][ i ]. to ; int val = v [ now . now ][ i ]. val ; if ( dis [ to ] != -1 ) continue ; que . push ({ to , val }); } } } int main () { int n , m , from , to , val ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d%d\" , & from , & to , & val ); v [ from ]. push_back ({ to , val }); v [ to ]. push_back ({ from , val }); } prim (); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { if ( dis [ i ] == -1 ) return 0 * puts ( \"orz\" ); ///\u4e0d\u8fde\u901a ans += dis [ i ]; } cout << ans << endl ; } ```` #### SPFA\u5224\u65ad\u8d1f\u73af ``` c ++ #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <queue> #include <algorithm> #define INF 0x3f3f3f3f using namespace std ; const int MAXN = 5500 ; int n , m , w ; struct Edge { int v , w , next ; } edge [ MAXN ]; int head [ MAXN ], dis [ MAXN ], vis [ MAXN ], t ; void Init () { memset ( head , -1 , sizeof ( head )); t = 0 ; } void Add_edge ( int u , int v , int w ) { edge [ t ]. v = v ; edge [ t ]. w = w ; edge [ t ]. next = head [ u ]; head [ u ] = t ++ ; } bool SPFA () { int mark [ MAXN ]; //\u8bb0\u5f55\u6bcf\u4e2a\u70b9\u5982\u961f\u5217\u7684\u6b21\u6570 for ( int i = 1 ; i <= n ; i ++ ) { mark [ i ] = 0 ; dis [ i ] = INF ; vis [ i ] = 0 ; } queue < int > q ; q . push ( 1 ); //\u6211\u4eec\u53ea\u9700\u8981\u5224\u65ad\u8d1f\u73af\uff0c\u968f\u4fbf\u627e\u4e00\u4e2a\u8d77\u70b9\u5c31\u597d dis [ 1 ] = 0 ; vis [ 1 ] = 1 ; //\u5165\u961f\u5217 mark [ 1 ] ++ ; while ( ! q . empty ()) { int u = q . front (); q . pop (); vis [ u ] = 0 ; //\u51fa\u961f\u5217 for ( int i = head [ u ]; i != -1 ; i = edge [ i ]. next ) { int v = edge [ i ]. v ; if ( dis [ v ] > dis [ u ] + edge [ i ]. w ) { dis [ v ] = dis [ u ] + edge [ i ]. w ; if ( ! vis [ v ]) //\u4e0d\u5728\u961f\u5217\u4e2d\u7684\u65f6\u5019\u51fa\u961f { q . push ( v ); mark [ v ] ++ ; vis [ v ] = 1 ; } if ( mark [ v ] >= n ) //\u5982\u679c\u4e0d\u5b58\u5728\u8d1f\u73af\uff0c\u90a3\u4e48\u6700\u591a\u66f4\u65b0n-1\u6b21\u5c31\u53ef\u4ee5\u5f97\u5230\u6700\u7ec8\u7684\u7b54\u6848\uff0c\u56e0\u4e3a\u4e00\u6b21\u6700\u5c11\u66f4\u65b0\u4e00\u4e2a\u8282\u70b9\uff0c\u90a3\u4e48\u5982\u679c\u51fa\u73b0\u4e86\u66f4\u65b0n\u6b21\uff0c\u90a3\u4e48\u5c31\u4e00\u5b9a\u51fa\u73b0\u4e86\u8d1f\u73af return false ; } } } return true ; } int main () { int T ; scanf ( \"%d\" , & T ); while ( T -- ) { Init (); int u , v , z ; scanf ( \"%d%d%d\" , & n , & m , & w ); for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d%d\" , & u , & v , & z ); Add_edge ( u , v , z ); Add_edge ( v , u , z ); } for ( int i = 0 ; i < w ; i ++ ) { scanf ( \"%d%d%d\" , & u , & v , & z ); Add_edge ( u , v , - z ); } if ( ! SPFA ()) printf ( \"YES \\n \" ); else printf ( \"NO \\n \" ); } return 0 ; }","title":"\u5806\u4f18\u5316prim\u7b97\u6cd5"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#dijikastrak","text":"#include <iostream> #include <cstdio> #include <cstring> #include <queue> using namespace std ; const int INF = 0x3f3f3f3f ; const int MAX = 1005 ; int n , m ; int start , end , k ; struct Edge { int w ; int to ; int next ; }; Edge e [ 100005 ]; int head [ MAX ], edgeNum ; int dis [ MAX ]; //dis[i]\u8868\u793a\u4ecei\u70b9\u5230end\u7684\u6700\u77ed\u8ddd\u79bb bool vis [ MAX ]; int cnt [ MAX ]; vector < Edge > opp_Graph [ MAX ]; struct Node { int f , g ; //f = g+dis[v] int v ; //\u5f53\u524d\u5230\u8fbe\u7684\u8282\u70b9 Node ( int a , int b , int c ) : f ( a ), g ( b ), v ( c ){} bool operator < ( const Node & a ) const { return a . f < f ; } }; void addEdge ( int from , int to , int w ) { e [ edgeNum ]. to = to ; e [ edgeNum ]. w = w ; e [ edgeNum ]. next = head [ from ]; head [ from ] = edgeNum ++ ; } void dijikastra ( int start ) { int i ; memset ( vis , 0 , sizeof ( vis )); for ( i = 1 ; i <= n ; i ++ ) dis [ i ] = INF ; dis [ start ] = 0 ; priority_queue < Node > que ; que . push ( Node ( 0 , 0 , start )); Node next ( 0 , 0 , 0 ); while ( ! que . empty ()) { Node now = que . top (); que . pop (); if ( vis [ now . v ]) //\u4ece\u96c6\u5408T\u4e2d\u9009\u53d6\u5177\u6709\u6700\u77ed\u8ddd\u79bb\u7684\u8282\u70b9 continue ; vis [ now . v ] = true ; //\u6807\u8bb0\u8282\u70b9\u5df2\u4ece\u96c6\u5408T\u52a0\u5165\u5230\u96c6\u5408S\u4e2d for ( i = 0 ; i < opp_Graph [ now . v ]. size (); i ++ ) //\u66f4\u65b0\u4ece\u6e90\u70b9\u5230\u5176\u5b83\u8282\u70b9(\u96c6\u5408T\u4e2d)\u7684\u6700\u77ed\u8ddd\u79bb { Edge edge = opp_Graph [ now . v ][ i ]; if ( ! vis [ edge . to ] && dis [ now . v ] + edge . w < dis [ edge . to ]) //\u52a0\u4e0d\u52a0\u524d\u9762\u7684\u5224\u65ad\u65e0\u6240\u8c13 { dis [ edge . to ] = dis [ now . v ] + edge . w ; next . f = dis [ edge . to ]; next . v = edge . to ; que . push ( next ); } } } } int A_Star () { int i ; priority_queue < Node > que ; if ( dis [ start ] == INF ) return -1 ; que . push ( Node ( dis [ start ], 0 , start )); Node next ( 0 , 0 , 0 ); while ( ! que . empty ()) { Node now = que . top (); que . pop (); cnt [ now . v ] ++ ; if ( cnt [ end ] == k ) return now . f ; if ( cnt [ now . v ] > k ) continue ; for ( i = head [ now . v ]; i != -1 ; i = e [ i ]. next ) { next . v = e [ i ]. to ; next . g = now . g + e [ i ]. w ; next . f = next . g + dis [ e [ i ]. to ]; que . push ( next ); } } return -1 ; } int main () { int i ; int from , to , w ; edgeNum = 0 ; memset ( head , -1 , sizeof ( head )); memset ( opp_Graph , 0 , sizeof ( opp_Graph )); memset ( cnt , 0 , sizeof ( cnt )); scanf ( \"%d %d\" , & n , & m ); Edge edge ; for ( i = 1 ; i <= m ; i ++ ) { scanf ( \"%d %d %d\" , & from , & to , & w ); addEdge ( from , to , w ); edge . to = from ; edge . w = w ; opp_Graph [ to ]. push_back ( edge ); } scanf ( \"%d %d %d\" , & start , & end , & k ); if ( start == end ) k ++ ; dijikastra ( end ); int result = A_Star (); printf ( \"%d \\n \" , result ); return 0 ; }","title":"dijikastra\u7b2ck\u77ed\u8def"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#lcast","text":"#include <bits/stdc++.h> using namespace std ; //lca\u677f\u5b50\u9898,\u6c42\u4fe9\u4e2a\u70b9\u6700\u77ed\u8ddd\u79bb //\u6811\u4e0a\u4e24\u70b9\u6700\u77ed\u8def\u5f84:\u4ece\u6839\u8282\u70b9\u51fa\u53d1dis[u]+dis[v]-dis[lca]*2 struct node { int to , next ; }; int tot = 0 ; node edge [ 1000500 ] = { 0 }; int head [ 500500 ] = { 0 }; int fa [ 500500 ][ 18 ] = { 0 }; int dep [ 500500 ] = { 0 }; void add ( int from , int to ) { edge [ ++ tot ]. next = head [ from ]; edge [ tot ]. to = to ; head [ from ] = tot ; } void dfs ( int now , int fa1 ) { dep [ now ] = dep [ fa1 ] + 1 ; fa [ now ][ 0 ] = fa1 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to != fa1 ) dfs ( to , now ); } } int lca ( int x , int y ) { if ( dep [ x ] < dep [ y ]) swap ( x , y ); for ( int j = 17 ; j >= 0 ; j -- ) { if ( dep [ fa [ x ][ j ]] >= dep [ y ]) x = fa [ x ][ j ]; } if ( x == y ) return x ; for ( int j = 17 ; j >= 0 ; j -- ) { if ( fa [ x ][ j ] != fa [ y ][ j ]) x = fa [ x ][ j ], y = fa [ y ][ j ]; } return fa [ x ][ 0 ]; } int main () { int n , m , s , f , t ; scanf ( \"%d%d%d\" , & n , & m , & s ); ///s\u4e3a\u6839\u8282\u70b9 for ( int i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%d%d\" , & f , & t ); add ( f , t ); add ( t , f ); } dfs ( s , 0 ); for ( int j = 1 ; j <= 17 ; j ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { fa [ i ][ j ] = fa [ fa [ i ][ j - 1 ]][ j - 1 ]; } } for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & f , & t ); printf ( \"%d \\n \" , lca ( f , t )); } }","title":"LCA+ST\u500d\u589e\u7b97\u6cd5"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_5","text":"#include <bits/stdc++.h> using namespace std ; struct node { int to , val , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }; int cnt = 0 ; int add_edge ( int from , int to , int val ) { edge [ ++ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. val = val ; head [ from ] = cnt ; } int dp [ 200500 ][ 4 ] = { 0 }; int down [ 200500 ] = { 0 }; int up [ 200500 ] = { 0 }; int len [ 200500 ][ 3 ] = { 0 }; int dfs1 ( int now , int fa ) { for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to , val = edge [ i ]. val ; if ( to == fa ) continue ; dfs1 ( to , now ); int tmp = dp [ to ][ 0 ] + val ; if ( tmp > dp [ now ][ 0 ]) swap ( dp [ now ][ 0 ], tmp ); if ( tmp > dp [ now ][ 1 ]) swap ( dp [ now ][ 1 ], tmp ); if ( tmp > dp [ now ][ 2 ]) swap ( dp [ now ][ 2 ], tmp ); down [ now ] = max ( down [ now ], down [ to ]); } down [ now ] = max ( down [ now ], dp [ now ][ 0 ] + dp [ now ][ 1 ]); } int dfs2 ( int now , int fa ) { for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { if ( edge [ i ]. to == fa ) continue ; int tem = down [ edge [ i ]. to ]; if ( tem > len [ now ][ 0 ]) swap ( tem , len [ now ][ 0 ]); if ( tem > len [ now ][ 1 ]) swap ( tem , len [ now ][ 1 ]); } for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to , val = edge [ i ]. val ; if ( to == fa ) continue ; if ( dp [ now ][ 0 ] == dp [ to ][ 0 ] + val ) { dp [ to ][ 3 ] = max ( dp [ now ][ 1 ], dp [ now ][ 3 ]) + val ; up [ to ] = max ( dp [ now ][ 2 ], dp [ now ][ 3 ]) + dp [ now ][ 1 ]; } else if ( dp [ now ][ 1 ] == dp [ to ][ 0 ] + val ) { dp [ to ][ 3 ] = max ( dp [ now ][ 0 ], dp [ now ][ 3 ]) + val ; up [ to ] = max ( dp [ now ][ 2 ], dp [ now ][ 3 ]) + dp [ now ][ 0 ]; } else { dp [ to ][ 3 ] = max ( dp [ now ][ 0 ], dp [ now ][ 3 ]) + val ; up [ to ] = max ( dp [ now ][ 1 ], dp [ now ][ 3 ]) + dp [ now ][ 0 ]; } if ( len [ now ][ 0 ] == down [ to ]) up [ to ] = max ( up [ to ], len [ now ][ 1 ]); else up [ to ] = max ( up [ to ], len [ now ][ 0 ]); dfs2 ( to , now ); } } int main () { int n , from , to , val ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n -1 ; i ++ ) { scanf ( \"%d%d%d\" , & from , & to , & val ); add_edge ( from , to , val ); add_edge ( to , from , val ); } dfs1 ( 1 , -1 ); dfs2 ( 1 , -1 ); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans = max ( ans , up [ i ] + down [ i ]); cout << ans << endl ; }","title":"\u6811\u7684\u76f4\u5f84"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_6","text":"EK\u7b97\u6cd5\uff1a #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll to , val , next ; }; node edge [ 805 ] = { 0 }; ll head [ 205 ] = { 0 }; ll cnt = 0 ; ll s = 1 , e = 1 ; void add_edge ( ll from , ll to , ll val ) { edge [ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. val = val ; head [ from ] = cnt ++ ; } ll pre [ 205 ] = { 0 }, tag [ 205 ] = { 0 }, vis [ 205 ] = { 0 }; ll bfs () { queue < ll > que ; memset ( tag , 0 , sizeof ( tag )); memset ( pre , 0 , sizeof ( pre )); memset ( vis , 0 , sizeof ( vis )); que . push ( s ); vis [ s ] = 1 ; while ( ! que . empty ()) { ll now = que . front (); que . pop (); for ( ll i = head [ now ]; i != -1 ; i = edge [ i ]. next ) { ll to = edge [ i ]. to , val = edge [ i ]. val ; if ( ! vis [ to ] && val > 0 ) { vis [ to ] = 1 ; pre [ to ] = now ; tag [ to ] = i ; if ( to == e ) return 1 ; que . push ( to ); } } } return 0 ; } ll EK () { ll ans = 0 ; while ( bfs ()) { ll min1 = inf ; for ( ll i = e ; i != s ; i = pre [ i ]) { min1 = min ( min1 , edge [ tag [ i ]]. val ); } for ( ll i = e ; i != s ; i = pre [ i ]) { edge [ tag [ i ]]. val -= min1 ; edge [ tag [ i ] ^ 1 ]. val += min1 ; } ans += min1 ; } return ans ; } int main () { ll n , m , from , to , val ; while ( scanf ( \"%lld%lld\" , & m , & n ) == 2 && n ){ e = n ; cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) head [ i ] = -1 ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld%lld\" , & from , & to , & val ); add_edge ( from , to , val ); add_edge ( to , from , 0 ); } printf ( \"%lld \\n \" , EK ()); } } \u4f18\u5316\u7248Dinic\u7b97\u6cd5\uff1a #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define INF 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct Edge { ll from , to , cap , flow , index ; Edge ( ll from , ll to , ll cap , ll flow , ll index ) : from ( from ), to ( to ), cap ( cap ), flow ( flow ), index ( index ) {} }; struct Dinic { ll N ; vector < vector < Edge >> G ; vector < Edge *> dad ; vector < ll > Q ; Dinic ( ll N ) : N ( N ), G ( N ), dad ( N ), Q ( N ) {} void AddEdge ( ll from , ll to , ll cap ) { G [ from ]. push_back ( Edge ( from , to , cap , 0 , G [ to ]. size ())); if ( from == to ) G [ from ]. back (). index ++ ; G [ to ]. push_back ( Edge ( to , from , 0 , 0 , G [ from ]. size () - 1 )); } ll BlockingFlow ( ll s , ll t ) { fill ( dad . begin (), dad . end (), ( Edge * ) NULL ); dad [ s ] = & G [ 0 ][ 0 ] - 1 ; ll head = 0 , tail = 0 ; Q [ tail ++ ] = s ; while ( head < tail ) { ll x = Q [ head ++ ]; for ( ll i = 0 ; i < G [ x ]. size (); i ++ ) { Edge & e = G [ x ][ i ]; if ( ! dad [ e . to ] && e . cap - e . flow > 0 ) { dad [ e . to ] = & G [ x ][ i ]; Q [ tail ++ ] = e . to ; } } } if ( ! dad [ t ]) return 0 ; ll totflow = 0 ; for ( ll i = 0 ; i < G [ t ]. size (); i ++ ) { Edge * start = & G [ G [ t ][ i ]. to ][ G [ t ][ i ]. index ]; ll amt = INF ; for ( Edge * e = start ; amt && e != dad [ s ]; e = dad [ e -> from ]) { if ( ! e ) { amt = 0 ; break ; } amt = min ( amt , e -> cap - e -> flow ); } if ( amt == 0 ) continue ; for ( Edge * e = start ; amt && e != dad [ s ]; e = dad [ e -> from ]) { e -> flow += amt ; G [ e -> to ][ e -> index ]. flow -= amt ; } totflow += amt ; } return totflow ; } ll GetMaxFlow ( ll s , ll t ) { ll totflow = 0 ; while ( ll flow = BlockingFlow ( s , t )) totflow += flow ; return totflow ; } }; int main () { ll n , m , f , t , v , s , e ; scanf ( \"%lld%lld\" , & n , & m ); scanf ( \"%lld%lld\" , & s , & e ); Dinic dinic ( n + 10 ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld%lld\" , & f , & t , & v ); dinic . AddEdge ( f , t , v ); } printf ( \"%lld \\n \" , dinic . GetMaxFlow ( s , e )); } \u666e\u901a\u7248\u672cdinic\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll INF = 1e18 ; const int N = 5e2 + 7 ; const int M = 2e5 + 7 ; int head [ N ], nex [ M ], ver [ M ], tot = 1 ; ll edge [ M ]; int n , m , s , t ; ll maxflow ; ll deep [ N ]; //\u5c42\u7ea7\u6570\uff0c\u5176\u5b9e\u5e94\u8be5\u662flevel int now [ M ]; //\u5f53\u524d\u5f27\u4f18\u5316 queue < int > q ; inline void add ( int x , int y , int z ) { //\u5efa\u6b63\u8fb9\u548c\u53cd\u5411\u8fb9 ver [ ++ tot ] = y ; edge [ tot ] = z ; nex [ tot ] = head [ x ]; head [ x ] = tot ; ver [ ++ tot ] = x ; edge [ tot ] = 0 ; nex [ tot ] = head [ y ]; head [ y ] = tot ; } inline bool bfs () { //\u5728\u6b8b\u91cf\u7f51\u7edc\u4e2d\u6784\u9020\u5206\u5c42\u56fe for ( int i = 1 ; i <= n ; i ++ ) deep [ i ] = INF ; while ( ! q . empty ()) q . pop (); q . push ( s ); deep [ s ] = 0 ; now [ s ] = head [ s ]; //\u4e00\u4e9b\u521d\u59cb\u5316 while ( ! q . empty ()) { int x = q . front (); q . pop (); for ( int i = head [ x ]; i ; i = nex [ i ]) { int y = ver [ i ]; if ( edge [ i ] > 0 && deep [ y ] == INF ) { //\u6ca1\u8d70\u8fc7\u4e14\u5269\u4f59\u5bb9\u91cf\u5927\u4e8e0 q . push ( y ); now [ y ] = head [ y ]; //\u5148\u521d\u59cb\u5316\uff0c\u6682\u65f6\u90fd\u4e00\u6837 deep [ y ] = deep [ x ] + 1 ; if ( y == t ) return 1 ; //\u627e\u5230\u4e86 } } } return 0 ; } //flow\u662f\u6574\u6761\u589e\u5e7f\u8def\u5bf9\u6700\u5927\u6d41\u7684\u8d21\u732e\uff0crest\u662f\u5f53\u524d\u6700\u5c0f\u5269\u4f59\u5bb9\u91cf\uff0c\u7528rest\u53bb\u66f4\u65b0flow ll dfs ( int x , ll flow ) { //\u5728\u5f53\u524d\u5206\u5c42\u56fe\u4e0a\u589e\u5e7f if ( x == t ) return flow ; ll ans = 0 , k , i ; for ( i = now [ x ]; i && flow ; i = nex [ i ]) { now [ x ] = i ; //\u5f53\u524d\u5f27\u4f18\u5316\uff08\u907f\u514d\u91cd\u590d\u904d\u5386\u4ecex\u51fa\u53d1\u7684\u4e0d\u53ef\u62d3\u5c55\u7684\u8fb9\uff09 int y = ver [ i ]; if ( edge [ i ] > 0 && ( deep [ y ] == deep [ x ] + 1 )) { //\u5fc5\u987b\u662f\u4e0b\u4e00\u5c42\u5e76\u4e14\u5269\u4f59\u5bb9\u91cf\u5927\u4e8e0 k = dfs ( y , min ( flow , edge [ i ])); //\u53d6\u6700\u5c0f if ( ! k ) deep [ y ] = INF ; //\u526a\u679d\uff0c\u53bb\u6389\u589e\u5e7f\u5b8c\u6bd5\u7684\u70b9 edge [ i ] -= k ; //\u56de\u6eaf\u65f6\u66f4\u65b0 edge [ i ^ 1 ] += k ; //\u6210\u5bf9\u53d8\u6362 ans += k ; flow -= k ; } } return ans ; } void dinic () { while ( bfs ()) maxflow += dfs ( s , INF ); } int main () { scanf ( \"%d%d%d%d\" , & n , & m , & s , & t ); tot = 1 ; for ( ll i = 1 ; i <= m ; i ++ ) { int x , y , z ; scanf ( \"%d%d%d\" , & x , & y , & z ); add ( x , y , z ); } dinic (); printf ( \"%lld \\n \" , maxflow ); return 0 ; }","title":"\u6700\u5927\u6d41\u7b97\u6cd5"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_7","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int next ; int flow ; int dis ; int to ; }; int head [ 100500 ] = { 0 }; node edge [ 100500 ] = { 0 }; int dis [ 100500 ] = { 0 }; int pre [ 100500 ] = { 0 }; int vis [ 100500 ] = { 0 }; int last [ 100500 ] = { 0 }; int flow [ 100500 ] = { 0 }; char g [ 1000 ][ 1000 ] = { 0 }; int n , m , s , t , cnt = -1 , maxflow = 0 , mincost = 0 ; int num ( int i , int j ) { return i * m + j ; } int add ( int from , int to , int flow , int dis ) { edge [ ++ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. flow = flow ; edge [ cnt ]. dis = dis ; head [ from ] = cnt ; } queue < int > w ; bool spfa ( int start , int end1 ) { w . push ( start ); memset ( dis , 0x3f3f3f , sizeof ( dis )); memset ( vis , 0 , sizeof ( vis )); memset ( flow , 0x3f3f3f , sizeof ( flow )); pre [ end1 ] = -1 ; vis [ start ] = 1 ; dis [ start ] = 0 ; while ( ! w . empty ()) { int now = w . front (); w . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i != -1 ; i = edge [ i ]. next ) { //cout<<i<<endl; if ( edge [ i ]. flow > 0 && dis [ edge [ i ]. to ] > dis [ now ] + edge [ i ]. dis ) { dis [ edge [ i ]. to ] = dis [ now ] + edge [ i ]. dis ; pre [ edge [ i ]. to ] = now ; last [ edge [ i ]. to ] = i ; flow [ edge [ i ]. to ] = min ( flow [ now ], edge [ i ]. flow ); if ( ! vis [ edge [ i ]. to ]) { vis [ edge [ i ]. to ] = 1 ; w . push ( edge [ i ]. to ); } } } } return pre [ end1 ] != -1 ; } int MCMF () { while ( spfa ( s , t )) { maxflow += flow [ t ]; mincost += dis [ t ] * flow [ t ]; int now = t ; while ( now != s ) { edge [ last [ now ]]. flow -= flow [ t ]; edge [ last [ now ] ^ 1 ]. flow += flow [ t ]; now = pre [ now ]; } } } int main () { memset ( head , -1 , sizeof ( head )); scanf ( \"%d%d\" , & n , & m ); s = n * m + 200 , t = n * m + 100 ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , g [ i ] + 1 ); } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( g [ i ][ j ] == 'x' ) continue ; if ( j > 1 && g [ i ][ j -1 ] != 'x' ) { add ( num ( i , j ), num ( i , j -1 ), 1 , 1 ); add ( num ( i , j -1 ), num ( i , j ), 0 , -1 ); } if ( i > 1 && g [ i -1 ][ j ] != 'x' ) { add ( num ( i , j ), num ( i -1 , j ), 1 , 1 ); add ( num ( i -1 , j ), num ( i , j ), 0 , -1 ); } if ( j < m && g [ i ][ j + 1 ] != 'x' ) { add ( num ( i , j ), num ( i , j + 1 ), 1 , 1 ); add ( num ( i , j + 1 ), num ( i , j ), 0 , -1 ); } if ( i < n && g [ i + 1 ][ j ] != 'x' ) { add ( num ( i , j ), num ( i + 1 , j ), 1 , 1 ); add ( num ( i + 1 , j ), num ( i , j ), 0 , -1 ); } if ( g [ i ][ j ] == 'F' ) { add ( s , num ( i , j ), 2 , 0 ); add ( num ( i , j ), s , 0 , 0 ); } if ( g [ i ][ j ] == 'C' || g [ i ][ j ] == 'B' ) { add ( num ( i , j ), t , 1 , 0 ); add ( t , num ( i , j ), 0 , 0 ); } } } MCMF (); // cout<<maxflow<<\" \"<<mincost<<endl; if ( maxflow != 2 ) printf ( \"-1 \\n \" ); else printf ( \"%d \\n \" , mincost ); }","title":"\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u7b97\u6cd5"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_8","text":"\u9898\u610f\uff1a\u7ed9\u4f60n\u4e2a\u957f\u5ea6\u76f8\u540c\uff0c\u5305\u542b\u5b57\u6bcd\u79cd\u7c7b\u76f8\u540c\uff0c\u6bcf\u79cd\u5b57\u6bcd\u6570\u91cf\u76f8\u540c\uff0c\u8ba9\u4f60\u786e\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\u96c6\u5408\uff0c\u96c6\u5408\u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u4e32\u4e0d\u80fd\u901a\u8fc7\u4ea4\u6362\u4efb\u610f\u4e24\u4e2a\u4e0d\u540c\u7684\u4f4d\u7f6e\u53d8\u6210\u96c6\u5408\u4e2d\u7684\u53e6\u4e00\u4e2a\u4e32\uff0c\u95ee\u4f60\u96c6\u5408\u6700\u5927\u6709\u591a\u4e2a\u5b57\u7b26\u4e32\u3002 \u601d\u8def\uff1a \u6211\u4eec\u5bf9\u4e8e\u4e24\u4e2a\u4e00\u6b21\u64cd\u4f5c\uff08\u4ea4\u6362\u4e24\u4e2a\u4e0d\u540c\u4f4d\u7f6e\uff09\u4e0d\u80fd\u4e92\u76f8\u53d8\u6362\u7684\u4e32\u5efa\u8fb9\uff0c\u90a3\u4e48\u7b54\u6848\u5c31\u662f\u8fd9\u4e2a\u56fe\u7684\u6700\u5927\u56e2\u3002 \u4e00\u4e2a\u56fe\u7684\u6700\u5927\u56e2\u7b49\u4e8e\u8fd9\u4e2a\u56fe\u8865\u56fe\u7684\u6700\u5927\u72ec\u7acb\u96c6\uff0c\u90a3\u4e48\u6211\u4eec\u8981\u5efa\u8fd9\u4e2a\u56fe\u7684\u8865\u56fe\u3002 \u8fd9\u4e2a\u56fe\u7684\u8865\u56fe\u5c31\u662f\u5bf9\u80fd\u591f\u4e00\u6b21\u64cd\u4f5c\u4e92\u76f8\u53d8\u6362\u7684\u4e24\u4e2a\u4e32\u5efa\u8fb9\u3002 \u90a3\u4e48\u73b0\u5728\u7b54\u6848\u5c31\u662f\u8fd9\u4e2a\u8865\u56fe\u7684\u6700\u5927\u72ec\u7acb\u96c6\u3002 \u8fd9\u4e2a\u8865\u56fe\u4e00\u5b9a\u662f\u4e00\u4e2a\u4e8c\u5206\u56fe\u3002 \u4e8c\u5206\u56fe\u7684\u6700\u5927\u72ec\u7acb\u96c6\u7b49\u4e8e\u56fe\u4e2d\u70b9\u7684\u4e2a\u6570 - \u6700\u5927\u5339\u914d\u6570\u3002 \u6240\u4ee5\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u5bf9\u8fd9\u4e2a\u4e8c\u5206\u56fe\u6c42\u4e00\u4e2a\u6700\u5927\u5339\u914d\u3002 #include <bits/stdc++.h> using namespace std ; char a [ 1000 ][ 300 ] = { 0 }; int mp [ 1000 ][ 1000 ] = { 0 }; map < int , int > mp1 , vis ; int n ; int dfs ( int k ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( mp [ i ][ k ] &&! vis [ i ]) { vis [ i ] = 1 ; if ( mp1 [ i ] == 0 || dfs ( mp1 [ i ])) { mp1 [ i ] = k ; return 1 ; } } } return 0 ; } int main () { scanf ( \"%d\" , & n ); ///\u4e24\u4e2a\u5b57\u7b26\u4e32\u4e2d\u4e0d\u80fd\u6709\u4e24\u4e2a\u5b57\u7b26\u76f8\u540c\uff0c\u95ee\u81f3\u5c11\u9700\u8981\u5206\u4e3a\u591a\u5c11\u7ec4 for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int sum = 0 ; for ( int k = 1 ; a [ i ][ k ]; k ++ ) { if ( a [ i ][ k ] != a [ j ][ k ]) sum ++ ; } if ( sum == 2 ) mp [ i ][ j ] = 1 ; } } //cout<<mp[1][2]<<endl; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { vis . clear (); ans += dfs ( i ); } cout << n - ans / 2 << endl ; } \u4e8c\u5206\u56fe\u5224\u65ad #include <bits/stdc++.h> using namespace std ; vector < int > v [ 100500 ]; int color [ 100500 ] = { 0 }; int bfs ( int i ) { queue < int > que ; que . push ( i ); while ( ! que . empty ()) { int now = que . front (); que . pop (); for ( int i : v [ now ]) { if ( color [ i ] == 0 ) { color [ i ] = 3 - color [ now ]; que . push ( i ); } else { if ( color [ i ] == color [ now ]) return 0 ; } } } return 1 ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int from , to ; scanf ( \"%d %d\" , & from , & to ); v [ from ]. push_back ( to ); v [ to ]. push_back ( from ); } for ( int i = 1 ; i <= m ; i ++ ) { if ( color [ i ] == 0 ) { int tmp = bfs ( i ); if ( tmp == 0 ) { puts ( \"No\" ); return 0 ; } } } puts ( \"Yes\" ); } /* \u8f93\u5165\uff1a 7 6 1 2 1 3 2 4 2 5 3 6 3 7 \u8f93\u51fa\uff1a Yes \u8f93\u5165\uff1a 3 3 1 2 2 3 1 3 \u8f93\u51fa\uff1a No */ \u4e8c\u5206\u56fe\u6700\u5927\u5339\u914d #include <bits/stdc++.h> using namespace std ; vector < int > v [ 100500 ]; map < int , int > mp , vis , mp1 ; int dfs ( int now ) { for ( int i = 0 ; i < v [ now ]. size (); i ++ ) { int to = v [ now ][ i ]; if ( ! vis [ to ]) { vis [ to ] = 1 ; if ( mp [ to ] == 0 || dfs ( mp [ to ])) { mp [ to ] = now ; mp1 [ now ] = to ; return 1 ; } } } return 0 ; } int main () { int n1 , n2 , m ; scanf ( \"%d%d%d\" , & n1 , & n2 , & m ); int from , to ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); to += n1 ; v [ from ]. push_back ( to ); v [ to ]. push_back ( from ); } int ans = 0 ; for ( int i = 1 ; i <= n1 ; i ++ ) { vis . clear (); ans += dfs ( i ); } cout << ans << endl ; for ( int i = 1 ; i <= n1 ; i ++ ) cout << max ( 0 , mp1 [ i ] - n1 ) << ' ' ; } \u4e8c\u5206\u56fe\u6700\u5927\u72ec\u7acb\u96c6\uff1a \u9009\u6700\u591a\u7684\u70b9\uff0c\u6ee1\u8db3\u4e24\u4e24\u4e4b\u95f4\u6ca1\u6709\u8fb9\u76f8\u8fde\u3002 \u4e8c\u5206\u56fe\u4e2d\uff0c\u6700\u5927\u72ec\u7acb\u96c6 =n- \u6700\u5927\u5339\u914d\u3002 \u4e8c\u5206\u56fe\u6700\u5c0f\u70b9\u8986\u76d6\uff1a \u9009\u6700\u5c11\u7684\u70b9\uff0c\u6ee1\u8db3\u6bcf\u6761\u8fb9\u81f3\u5c11\u6709\u4e00\u4e2a\u7aef\u70b9\u88ab\u9009\uff0c\u4e0d\u96be\u53d1\u73b0\u8865\u96c6\u662f\u72ec\u7acb\u96c6\u3002 \u4e8c\u5206\u56fe\u4e2d\uff0c\u6700\u5c0f\u70b9\u8986\u76d6 =n- \u6700\u5927\u72ec\u7acb\u96c6\u3002 \u4e8c\u5206\u56fe\u6709\u5411\u65e0\u5411\u5efa\u56fe\u89c4\u5219\uff1a \u6709\u5de6\u53f3\u4e4b\u5206\u5efa\u5355\u5411\u8fb9\uff0c\u65e0\u5de6\u53f3\u4e4b\u5206\u5efa\u65e0\u5411\u8fb9 \u7b54\u6848\u96642 \u4e00\u5207\u6811\u5747\u4e3a\u4e8c\u5206\u56fe \u4e8c\u5206\u56fe\u6700\u5927\u6743\u5339\u914d\uff1a \u9898\u76ee\uff1a https://uoj.ac/problem/80 \u9898\u89e3\uff1a https://blog.csdn.net/weixin_30528371/article/details/99263983 \u8bb2\u89e3\uff1a https://www.cnblogs.com/wenruo/p/5264235.html #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; int n , m , q ; int w [ 405 ] = { 0 }, v [ 405 ] = { 0 }; int vl [ 405 ] = { 0 }, vr [ 405 ] = { 0 }, c [ 405 ] = { 0 }; int a [ 405 ][ 405 ] = { 0 }, ans [ 405 ] = { 0 }, b [ 405 ] = { 0 }; int tim = 0 ; int dfs ( int x ) { vl [ x ] = tim ; for ( int i = 1 ; i <= m ; i ++ ) { if ( vr [ i ] == tim ) continue ; int d = w [ x ] + v [ i ] - a [ x ][ i ]; if ( d == 0 ) { vr [ i ] = tim ; if ( ! b [ i ] || dfs ( b [ i ])) { b [ i ] = x ; return 1 ; } } else { c [ i ] = min ( c [ i ], d ); } } return 0 ; } void km () { for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) w [ i ] = max ( w [ i ], a [ i ][ j ]); for ( int i = 1 ; i <= n ; i ++ ) { memset ( c , inf , sizeof ( c )); tim += 1 ; if ( dfs ( i )) continue ; while ( 1 ) { int d = inf , y = 0 ; for ( int j = 1 ; j <= m ; j ++ ) if ( vr [ j ] != tim ) d = min ( d , c [ j ]); for ( int j = 1 ; j <= n ; j ++ ) if ( vl [ j ] == tim ) w [ j ] -= d ; for ( int j = 1 ; j <= m ; j ++ ) { if ( vr [ j ] == tim ) v [ j ] += d ; else if ( ! ( c [ j ] -= d )) y = j ; } if ( ! b [ y ]) break ; int x = b [ y ]; vl [ x ] = vr [ y ] = tim ; for ( int j = 1 ; j <= m ; j ++ ) c [ j ] = min ( c [ j ], w [ x ] + v [ j ] - a [ x ][ j ]); } tim += 1 ; dfs ( i ); } ll ans1 = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans1 += a [ b [ i ]][ i ]; printf ( \"%lld \\n \" , ans1 ); for ( int i = 1 ; i <= m ; i ++ ) { if ( a [ b [ i ]][ i ]) ans [ b [ i ]] = i ; } for ( int i = 1 ; i <= n ; i ++ ) printf ( \"%d \" , ans [ i ]); } int main () { scanf ( \"%d%d%d\" , & n , & m , & q ); m = max ( m , n ); for ( int i = 1 ; i <= q ; i ++ ) { int x , y , v ; scanf ( \"%d%d%d\" , & x , & y , & v ); a [ x ][ y ] = v ; } km (); }","title":"\u4e8c\u5206\u56fe\u6a21\u677f"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#tarjan","text":"Tarjan \u7b97\u6cd5\u53ca\u5176\u5e94\u7528 \u6c42\u5272\u8fb9 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int to , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }, dfn [ 200500 ] = { 0 }, low [ 200500 ] = { 0 }, bridge [ 200500 ] = { 0 }; int cnt = 1 , tot = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } void tarjan ( int x , int in_edge ) { dfn [ x ] = low [ x ] = ++ tot ; for ( int i = head [ x ]; i ; i = edge [ i ]. next ) { int y = edge [ i ]. to ; if ( ! dfn [ y ]) { tarjan ( y , i ); low [ x ] = min ( low [ x ], low [ y ]); if ( low [ y ] > dfn [ x ]) bridge [ i ] = bridge [ i ^ 1 ] = 1 ; ///\u6865 } else if ( i != ( in_edge ^ 1 )) low [ x ] = min ( low [ x ], dfn [ y ]); } } int main () { int n , m , from , to ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! dfn [ i ]) tarjan ( i , 0 ); } for ( int i = 2 ; i <= cnt ; i += 2 ) { if ( bridge [ i ]) { printf ( \"%d %d \\n \" , edge [ i ^ 1 ]. to , edge [ i ]. to ); } } } \u7f29\u70b9\u6c42\u5c06\u56fe\u8f6c\u53d8\u4e3a\u5f3a\u8fde\u901a\u56fe\u9700\u8981\u52a0\u8fb9\u7684\u6570\u76ee \u9898\u76ee\u6765\u6e90\uff1aPOJ 2767 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int to , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }, dfn [ 200500 ] = { 0 }, low [ 200500 ] = { 0 }; int stack1 [ 200500 ] = { 0 }, vis [ 200500 ] = { 0 }, color [ 200500 ] = { 0 }; bool in [ 200500 ] = { 0 }, out [ 200500 ] = { 0 }; int cnt = 0 , tot = 0 , top = 0 , color_num = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } void tarjan ( int now ) { stack1 [ ++ top ] = now ; vis [ now ] = 1 ; dfn [ now ] = low [ now ] = ++ tot ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int y = edge [ i ]. to ; if ( ! dfn [ y ]) { tarjan ( y ); low [ now ] = min ( low [ now ], low [ y ]); } else if ( vis [ y ]) low [ now ] = min ( low [ now ], dfn [ y ]); } if ( dfn [ now ] == low [ now ]) ///\u5f3a\u8fde\u901a\u5757 { color [ now ] = ++ color_num ; vis [ now ] = 0 ; while ( stack1 [ top ] != now ) { color [ stack1 [ top ]] = color_num ; vis [ stack1 [ top -- ]] = 0 ; } vis [ stack1 [ top ]] = 0 ; top -- ; } } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m , from , to ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n + 1 ; i ++ ) in [ i ] = out [ i ] = head [ i ] = dfn [ i ] = low [ i ] = stack1 [ i ] = vis [ i ] = color [ i ] = 0 ; cnt = 0 , tot = 0 , top = 0 , color_num = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); add_edge ( from , to ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! dfn [ i ]) tarjan ( i ); } if ( color_num == 1 ) { printf ( \"0 \\n \" ); continue ; } int in_num = color_num , out_num = color_num ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = head [ i ]; j ; j = edge [ j ]. next ) { int to = edge [ j ]. to ; if ( color [ to ] != color [ i ]) { if ( ! in [ color [ to ]]) { in_num -- ; in [ color [ to ]] = 1 ; } if ( ! out [ color [ i ]]) { out_num -- ; out [ color [ i ]] = 1 ; } } } } printf ( \"%d \\n \" , max ( out_num , in_num )); } } \u6c42\u5272\u70b9 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int to , next ; }; node edge [ 200500 ] = { 0 }; int head [ 200500 ] = { 0 }, dfn [ 200500 ] = { 0 }, low [ 200500 ] = { 0 }, cut [ 200500 ] = { 0 }; int cnt = 0 , tot = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } void tarjan ( int now , int root ) { dfn [ now ] = low [ now ] = ++ tot ; int ct = 0 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int y = edge [ i ]. to ; ct ++ ; if ( ! dfn [ y ]) { tarjan ( y , root ); low [ now ] = min ( low [ now ], low [ y ]); if ( now != root && low [ y ] >= dfn [ now ]) cut [ now ] = 1 ; if ( now == root && ct > 1 ) cut [ now ] = 1 ; } else low [ now ] = min ( low [ now ], dfn [ y ]); } } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m , from , to ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n + 1 ; i ++ ) head [ i ] = dfn [ i ] = low [ i ] = cut [ i ] = 0 ; cnt = 0 , tot = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! dfn [ i ]) tarjan ( i , i ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( cut [ i ]) printf ( \"%d \" , i ); } printf ( \" \\n \" ); } } /* \u8f93\u5165\uff1a 1 7 7 1 2 1 5 5 6 5 7 2 3 2 4 3 4 \u5272\u70b9\u4e3a\uff1a 1 2 5 */","title":"Tarjan\u7b97\u6cd5"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_9","text":"https://oi-wiki.org/graph/hld/#_4 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll sum [ 400500 ] = { 0 }, lazy [ 400500 ] = { 0 }; ll dep [ 200500 ] = { 0 }, size1 [ 200500 ] = { 0 }, son [ 200500 ] = { 0 }, f [ 200500 ] = { 0 }, id [ 200500 ] = { 0 }, top [ 200500 ] = { 0 }; struct node { ll to , next ; }; node edge [ 400500 ] = { 0 }; ll head [ 400500 ] = { 0 }; ll num = 0 , cnt = 0 ; void add_edge ( ll from , ll to ) { edge [ ++ num ] = { to , head [ from ]}; head [ from ] = num ; } void dfs1 ( ll now , ll fa ) { size1 [ now ] = 1 ; for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == fa ) continue ; f [ to ] = now ; dep [ to ] = dep [ now ] + 1 ; dfs1 ( to , now ); size1 [ now ] += size1 [ to ]; if ( size1 [ to ] > size1 [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( ll now , ll fa ) { id [ now ] = ++ cnt ; top [ now ] = fa ; if ( son [ now ]) dfs2 ( son [ now ], fa ); for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == f [ now ] || to == son [ now ]) continue ; dfs2 ( to , to ); } } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t + 1 ] += lazy [ t ]; lazy [ 2 * t ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += ( mid - l + 1 ) * lazy [ t ]; sum [ 2 * t + 1 ] += ( r - mid ) * lazy [ t ]; lazy [ t ] = 0 ; } void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { lazy [ t ] += add ; sum [ t ] += add * ( R - L + 1 ); return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query ( ll t , ll l , ll r , ll L , ll R ) { if ( l <= L && R <= r ) return sum [ t ]; push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; ll ans = 0 ; if ( l <= mid ) ans += query ( 2 * t , l , r , L , mid ); if ( mid < r ) ans += query ( 2 * t + 1 , l , r , mid + 1 , R ); return ans ; } void update_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ]; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); update ( 1 , id [ fx ], id [ x ], 1 , cnt , 1 ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); update ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt , 1 ); } ll query_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ], ans = 0 ; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); ans += query ( 1 , id [ fx ], id [ x ], 1 , cnt ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); ans += query ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt ); return ans ; } int main () { ll n , m , from , to ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } f [ 1 ] = 0 , dep [ 1 ] = 1 ; dfs1 ( 1 , 0 ), dfs2 ( 1 , 1 ); char c [ 10 ]; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , c + 1 , & from , & to ); if ( c [ 1 ] == 'P' ) update_chain ( from , to ); else printf ( \"%lld \\n \" , query_chain ( from , to )); } }","title":"\u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_10","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef pair < int , int > pii ; const int N = 100000 + 5 ; const int K = 10 + 5 ; const ll inf = 0x3f3f3f3f3f3f3f3f ; vector < pii > e [ N ]; struct Info { int pos , num ; ll val ; inline Info (){} inline Info ( int _pos , int _num , ll _val ) { pos = _pos , num = _num , val = _val ; } inline bool operator < ( const Info & b ) const { return val > b . val ; } }; ll f [ N ][ K ]; bool vis [ N ][ K ]; priority_queue < Info > q ; class TaskL { public : void solve ( std :: istream & in , std :: ostream & out ) { int T ; in >> T ; while ( T -- ) { int n , m , k ; in >> n >> m >> k ; while ( q . size ()) q . pop (); for ( int i = 1 ; i <= n ; ++ i ) { e [ i ]. clear (); for ( int j = 0 ; j <= k ; ++ j ) { f [ i ][ j ] = inf ; vis [ i ][ j ] = false ; } } for ( int i = 1 , x , y , z ; i <= m ; ++ i ) { in >> x >> y >> z ; e [ x ]. push_back ({ y , z }); } f [ 1 ][ 0 ] = 0 ; q . push ( Info ( 1 , 0 , 0 )); while ( q . size ()) { Info now = q . top (); q . pop (); if ( vis [ now . pos ][ now . num ] == true ) continue ; vis [ now . pos ][ now . num ] = true ; for ( int i = 0 ; i < e [ now . pos ]. size (); ++ i ) { int to = e [ now . pos ][ i ]. first , val = e [ now . pos ][ i ]. second ; if ( f [ to ][ now . num ] > f [ now . pos ][ now . num ] + val ) { f [ to ][ now . num ] = f [ now . pos ][ now . num ] + val ; q . push ( Info ( to , now . num , f [ to ][ now . num ])); } if ( now . num < k && f [ to ][ now . num + 1 ] > f [ now . pos ][ now . num ]) { f [ to ][ now . num + 1 ] = f [ now . pos ][ now . num ]; q . push ( Info ( to , now . num + 1 , f [ to ][ now . num + 1 ])); } } } ll ans = inf ; for ( int i = 0 ; i <= k ; ++ i ) { ans = min ( ans , f [ n ][ i ]); } out << ans << endl ; } } }; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); TaskL solver ; std :: istream & in ( std :: cin ); std :: ostream & out ( std :: cout ); solver . solve ( in , out ); return 0 ; }","title":"\u5206\u5c42\u6700\u77ed\u8def"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#lct","text":"\u53c2\u8003\u94fe\u63a5\uff1a https://www.luogu.com.cn/problem/P3690 https://www.cnblogs.com/zwfymqz/p/7896036.html#!comments https://www.cnblogs.com/zzy2005/p/10312977.html https://www.cnblogs.com/JeremyGJY/p/5921594.html https://blog.csdn.net/qq_36551189/article/details/79152612 #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll f [ 100500 ] = { 0 }, c [ 100500 ][ 2 ] = { 0 }, v [ 100500 ] = { 0 }, s [ 100500 ] = { 0 }, st [ 100500 ] = { 0 }; bool r [ 100500 ] = { 0 }; //\u5224\u65ad\u8282\u70b9\u662f\u5426\u4e3a\u4e00\u4e2aSplay\u7684\u6839 inline bool nroot ( register ll x ) { return c [ f [ x ]][ 0 ] == x || c [ f [ x ]][ 1 ] == x ; //\u539f\u7406\u4e3a\u5982\u679c\u8fde\u7684\u662f\u8f7b\u8fb9\uff0c\u4ed6\u7684\u7236\u4eb2\u7684\u513f\u5b50\u91cc\u6ca1\u6709\u5b83 } //\u4e0a\u4f20\u4fe1\u606f inline void pushup ( ll x ) { s [ x ] = s [ c [ x ][ 0 ]] ^ s [ c [ x ][ 1 ]] ^ v [ x ]; } //\u7ffb\u8f6c\u64cd\u4f5c inline void pushr ( register ll x ) { register ll t = c [ x ][ 0 ]; c [ x ][ 0 ] = c [ x ][ 1 ]; c [ x ][ 1 ] = t ; r [ x ] ^= 1 ; } //\u5224\u65ad\u5e76\u91ca\u653e\u61d2\u6807\u8bb0 inline void pushdown ( register ll x ) { if ( r [ x ]) { if ( c [ x ][ 0 ]) pushr ( c [ x ][ 0 ]); if ( c [ x ][ 1 ]) pushr ( c [ x ][ 1 ]); r [ x ] = 0 ; } } //\u4e00\u6b21\u65cb\u8f6c inline void rotate ( register ll x ) { register ll y = f [ x ], z = f [ y ], k = c [ y ][ 1 ] == x , w = c [ x ][ ! k ]; if ( nroot ( y )) c [ z ][ c [ z ][ 1 ] == y ] = x ; c [ x ][ ! k ] = y ; c [ y ][ k ] = w ; if ( w ) f [ w ] = y ; f [ y ] = x ; f [ x ] = z ; pushup ( y ); } //\u53ea\u4f20\u4e86\u4e00\u4e2a\u53c2\u6570\uff0c\u56e0\u4e3a\u6240\u6709\u64cd\u4f5c\u7684\u76ee\u6807\u90fd\u662f\u8be5Splay\u7684\u6839 inline void splay ( register ll x ) { register ll y = x , z = 0 ; st [ ++ z ] = y ; //st\u4e3a\u6808\uff0c\u6682\u5b58\u5f53\u524d\u70b9\u5230\u6839\u7684\u6574\u6761\u8def\u5f84\uff0cpushdown\u65f6\u4e00\u5b9a\u8981\u4ece\u4e0a\u5f80\u4e0b\u653e\u6807\u8bb0 while ( nroot ( y )) st [ ++ z ] = y = f [ y ]; while ( z ) pushdown ( st [ z -- ]); while ( nroot ( x )) { y = f [ x ]; z = f [ y ]; if ( nroot ( y )) rotate (( c [ y ][ 0 ] == x ) ^ ( c [ z ][ 0 ] == y ) ? x : y ); rotate ( x ); } pushup ( x ); } //\u8bbf\u95ee inline void access ( register ll x ) { for ( register ll y = 0 ; x ; x = f [ y = x ]) splay ( x ), c [ x ][ 1 ] = y , pushup ( x ); } //\u6362\u6839 inline void makeroot ( register ll x ) { access ( x ); splay ( x ); pushr ( x ); } //\u627e\u6839\uff08\u5728\u771f\u5b9e\u7684\u6811\u4e2d\u7684\uff09 inline ll findroot ( register ll x ) { access ( x ); splay ( x ); while ( c [ x ][ 0 ]) pushdown ( x ), x = c [ x ][ 0 ]; splay ( x ); return x ; } //\u63d0\u53d6\u8def\u5f84 inline void split ( register ll x , register ll y ) { makeroot ( x ); access ( y ); splay ( y ); } //\u8fde\u8fb9 inline void link ( register ll x , register ll y ) { makeroot ( x ); if ( findroot ( y ) != x ) f [ x ] = y ; } //\u65ad\u8fb9 void cut ( register ll x , register ll y ) { makeroot ( x ); if ( findroot ( y ) == x && f [ y ] == x && ! c [ y ][ 0 ]) { f [ y ] = c [ x ][ 1 ] = 0 ; pushup ( x ); } } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) //\u7ed9\u5b9a n \u4e2a\u70b9\u4ee5\u53ca\u6bcf\u4e2a\u70b9\u7684\u6743\u503c scanf ( \"%d\" , & v [ i ]); for ( int i = 1 ; i <= m ; i ++ ) { int opt , x , y ; scanf ( \"%d%d%d\" , & opt , & x , & y ); if ( opt == 0 ) //\u4ee3\u8868\u8be2\u95ee\u4ece x \u5230 y \u7684\u8def\u5f84\u4e0a\u7684\u70b9\u7684\u6743\u503c\u7684 xor \u548c\u3002\u4fdd\u8bc1 x \u5230 y \u662f\u8054\u901a\u7684\u3002 { split ( x , y ); printf ( \"%d \\n \" , s [ y ]); } else if ( opt == 1 ) //\u4ee3\u8868\u8fde\u63a5 x \u5230 y\uff0c\u82e5 x \u5230 y \u5df2\u7ecf\u8054\u901a\u5219\u65e0\u9700\u8fde\u63a5\u3002 { link ( x , y ); } else if ( opt == 2 ) //\u4ee3\u8868\u5220\u9664\u8fb9 (x,y)\uff0c\u4e0d\u4fdd\u8bc1\u8fb9 (x,y) \u5b58\u5728\u3002 { cut ( x , y ); } else if ( opt == 3 ) //\u4ee3\u8868\u5c06\u70b9 x \u4e0a\u7684\u6743\u503c\u53d8\u6210 y\u3002 { splay ( x ); v [ x ] = y ; } } }","title":"LCT \u52a8\u6001\u6811"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_11","text":"","title":"\u6570\u636e\u7ed3\u6784"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_12","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n , m ; ll a [ 100500 ] = { 0 }; ll c [ 100500 ] = { 0 }; ll lowbit ( ll x ) { return x & ( - x ); } ll update ( ll k , ll x ) { for ( ll i = k ; i <= n ; i += lowbit ( i )) c [ i ] += x ; } ll sum1 ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c [ i ]; return ans ; } int main () { ll a1 , b1 , c1 ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld%lld\" , & a1 , & b1 , & c1 ); if ( a1 == 0 ) update ( b1 , c1 ); else printf ( \"%lld \\n \" , sum1 ( c1 ) - sum1 ( b1 -1 )); } }","title":"\u6811\u72b6\u6570\u7ec4\u524d\u7f00\u548c"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_13","text":"#include <stdio.h> using namespace std ; typedef long long ll ; ll num [ 100500 ] = { 0 }; ll lazy [ 800500 ] = { 0 }; ll sum [ 800500 ] = { 0 }; void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t ] += lazy [ t ]; lazy [ 2 * t + 1 ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += lazy [ t ] * ( mid - l + 1 ); sum [ 2 * t + 1 ] += lazy [ t ] * ( r - mid ); lazy [ t ] = 0 ; } void build ( ll t , ll l , ll r ) { if ( l == r ) { sum [ t ] = num [ l ]; return ; } ll mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); push_up ( t ); } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( l <= L && r >= R ) { sum [ t ] += add * ( R - L + 1 ); lazy [ t ] += add ; return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query_sum ( ll t , ll l , ll r , ll L , ll R ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( l <= L && r >= R ) { return sum [ t ]; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 , sum = 0 ; if ( l <= mid ) sum += query_sum ( 2 * t , l , r , L , mid ); if ( mid < r ) sum += query_sum ( 2 * t + 1 , l , r , mid + 1 , R ); return sum ; } int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & num [ i ]); build ( 1 , 1 , n ); char s [ 10 ]; ll l , r , x ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , s , & l , & r ); if ( s [ 0 ] == 'Q' ) { printf ( \"%lld \\n \" , query_sum ( 1 , l , r , 1 , n )); } else { scanf ( \"%lld\" , & x ); update ( 1 , l , r , 1 , n , x ); } } }","title":"\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u548c"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_14","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int tree [ 20 ][ 100500 ] = { 0 }; int to [ 20 ][ 100500 ] = { 0 }; int num [ 100500 ] = { 0 }; int sorted [ 100500 ] = { 0 }; int build ( int l , int r , int deep ) { if ( l == r ) return 0 ; int mid = ( l + r ) / 2 ; int midd = sorted [ mid ]; int suppose = mid - l + 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( tree [ deep ][ i ] < midd ) suppose -- ; } int sleft = l , sright = mid + 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( i == l ) to [ deep ][ l ] = 0 ; else to [ deep ][ i ] = to [ deep ][ i -1 ]; if ( tree [ deep ][ i ] < midd ) { to [ deep ][ i ] ++ ; tree [ deep + 1 ][ sleft ++ ] = tree [ deep ][ i ]; } else if ( tree [ deep ][ i ] == midd && suppose > 0 ) { suppose -- ; to [ deep ][ i ] ++ ; tree [ deep + 1 ][ sleft ++ ] = tree [ deep ][ i ]; } else { tree [ deep + 1 ][ sright ++ ] = tree [ deep ][ i ]; } } build ( l , mid , deep + 1 ); build ( mid + 1 , r , deep + 1 ); } int query ( int l , int r , int L , int R , int k , int deep ) { if ( L == R ) return tree [ deep ][ L ]; int mid = ( l + r ) / 2 ; int lef ; int toleft ; if ( l == L ) lef = 0 , toleft = to [ deep ][ R ]; else lef = to [ deep ][ L -1 ], toleft = to [ deep ][ R ] - lef ; if ( k <= toleft ) { return query ( l , mid , l + lef , l + toleft + lef -1 , k , deep + 1 ); } else { return query ( mid + 1 , r , mid + L - l - lef + 1 , mid + R - l - toleft - lef + 1 , k - toleft , deep + 1 ); } } int main () { int n , m , summ = 0 ; while ( scanf ( \"%d\" , & n ) != EOF ) { summ ++ ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & num [ i ]); sorted [ i ] = num [ i ]; tree [ 0 ][ i ] = num [ i ]; } sort ( sorted + 1 , sorted + n + 1 ); build ( 1 , n , 0 ); printf ( \"Case %d: \\n \" , summ ); scanf ( \"%d\" , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int a , b , c ; /// a,b,c\u4ee3\u8868\u67e5\u8be2a\u5230b\u533a\u95f4\u5185\u7b2cc\u5927\u7684\u6570 scanf ( \"%d%d\" , & a , & b ); c = ( b - a ) / 2 + 1 ; printf ( \"%d \\n \" , query ( 1 , n , a , b , c , 0 )); } } }","title":"\u5212\u5206\u6811\u6c42\u4e2d\u4f4d\u6570"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_15","text":"\u5355\u8c03\u6808 \u662f\u5728\u6808\u7684**\u5148\u8fdb\u540e\u51fa**\u57fa\u7840\u4e4b\u4e0a\u989d\u5916\u6dfb\u52a0\u4e00\u4e2a\u7279\u6027\uff1a**\u4ece\u6808\u9876\u5230\u6808\u5e95**\u7684\u5143\u7d20\u662f\u4e25\u683c\u9012\u589e\u6216\u9012\u51cf\u3002 \u4e3a\u4e86\u7ef4\u62a4\u6808\u7684\u5355\u8c03\u6027\uff0c\u5728\u8fdb\u6808\u8fc7\u7a0b\u4e2d\u9700\u8981\u8fdb\u884c\u5224\u65ad\uff0c\u5177\u4f53\u8fdb\u6808\u8fc7\u7a0b\u5982\u4e0b\uff1a\u5047\u8bbe\u5f53\u524d\u8fdb\u6808\u5143\u7d20\u4e3a e\uff0c \u5bf9\u4e8e\u5355\u8c03\u9012\u589e\u6808\uff0c\u4ece\u6808\u9876\u5f00\u59cb\u904d\u5386\u5143\u7d20\uff0c\u628a\u5c0f\u4e8e e \u6216\u8005\u7b49\u4e8e e \u7684\u5143\u7d20\u5f39\u51fa\u6808\uff0c\u76f4\u81f3\u9047\u89c1\u4e00\u4e2a\u5927\u4e8e e \u7684\u5143\u7d20\u6216\u8005\u6808\u4e3a\u7a7a\u4e3a\u6b62\uff0c\u7136\u540e\u518d\u628a e \u538b\u5165\u6808\u4e2d\uff0c\u8fd9\u6837\u5c31\u80fd\u6ee1\u8db3\u4ece\u6808\u9876\u5230\u6808\u5e95\u7684\u5143\u7d20\u662f\u9012\u589e\u7684 \u5bf9\u4e8e\u5355\u8c03\u9012\u51cf\u6808\uff0c\u5219\u6bcf\u6b21\u5f39\u51fa\u7684\u662f\u5927\u4e8e e \u6216\u8005\u7b49\u4e8e e \u7684\u5143\u7d20\uff0c\u76f4\u81f3\u9047\u89c1\u4e00\u4e2a\u5c0f\u4e8ee\u7684\u5143\u7d20\u6216\u8005\u6808\u4e3a\u7a7a\u4e3a\u6b62 \u5355\u8c03\u6808\u7684\u4f5c\u7528\u5728\u4e8e \u5355\u8c03\u9012\u589e\u6808\u4ece\u6808\u9876\u5230\u6808\u5e95\u662f\u9012\u589e\u7684\uff0c\u6808\u4e2d\u4fdd\u7559\u7684\u90fd\u662f\u6bd4\u5f53\u524d\u5165\u6808\u5143\u7d20\u5927\u7684\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5feb\u901f\u627e\u5230\u5165\u6808\u5143\u7d20\u5de6\u8fb9\u6bd4\u4ed6\u5927\u7684\u5143\u7d20 \u5355\u8c03\u9012\u51cf\u6808\u4ece\u6808\u9876\u5230\u6808\u5e95\u662f\u9012\u51cf\u7684\uff0c\u6808\u4e2d\u4fdd\u7559\u7684\u90fd\u662f\u6bd4\u5f53\u524d\u5165\u6808\u5143\u7d20\u5c0f\u7684\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5feb\u901f\u627e\u5230\u5165\u6808\u5143\u7d20\u5de6\u8fb9\u6bd4\u4ed6\u5c0f\u7684\u5143\u7d20 \u5355\u8c03\u6808\u6c42\u533a\u95f4\u957f\u5ea6\u548c\u533a\u95f4\u6700\u5c0f\u503c\u4e58\u79ef\u6700\u5927\u503c\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll pos , val ; }; node s [ 2005000 ] = { 0 }; ll a [ 2005000 ] = { 0 }; int main () { ll n , top = 0 , ans = 0 ; scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); for ( int j = 1 ; j <= n + 1 ; j ++ ) { if ( top == 0 ) { s [ ++ top ] = { j , a [ j ]}; } else { while ( s [ top ]. val > a [ j ]) ///\u9012\u589e\u6808 { ll tmp = ( j - s [ top - 1 ]. pos - 1 ) * s [ top ]. val ; ans = max ( ans , tmp ); top -- ; } s [ ++ top ] = { j , a [ j ]}; } } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"\u5355\u8c03\u6808"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_16","text":"\u7ebf\u6027\u57fa\u6c42\u4ea4\uff0c\u53c2\u8003\u4e0e\uff1a https://blog.csdn.net/qcwlmqy/article/details/97584411 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; const int maxn = 50500 ; typedef long long ll ; class Bit_Set { public : ll d [ 32 ]; Bit_Set () { memset ( d , 0 , sizeof ( d )); } Bit_Set ( const Bit_Set & t ) { for ( int i = 0 ; i <= 31 ; i ++ ) d [ i ] = t . d [ i ]; } void clear () { memset ( d , 0 , sizeof ( d )); } void insert ( ll x ) { for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( ll ( 1 ) << i )) { if ( ! d [ i ]) { d [ i ] = x ; return ; } x ^= d [ i ]; } } } bool check ( ll x ) { for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( ll ( 1 ) << i )) { if ( ! d [ i ]) return false ; x ^= d [ i ]; } } return true ; } void show () { for ( int i = 0 ; i <= 31 ; i ++ ) cout << i << ' ' << d [ i ] << endl ; } friend Bit_Set operator + ( const Bit_Set & a , const Bit_Set & b ) { Bit_Set a_b ( a ), c , res ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( b . d [ i ]) { ll x = b . d [ i ], k = ll ( 1 ) << i ; bool flag = true ; for ( int j = 31 ; j >= 0 ; j -- ) { if ( x & ( ll ( 1 ) << j )) { if ( a_b . d [ j ]) { x ^= a_b . d [ j ]; k ^= c . d [ j ]; //\u5c06\u7528\u4e0a\u7684b\u5143\u7d20\u8ba1\u5165k } else { flag = false ; //\u82e5\u4e0d\u80fd\u88aba_b\u8868\u793a\uff0c\u5c06b[i]\u52a0\u5165\u6570\u7ec4 a_b . d [ j ] = x ; c . d [ j ] ^= k ; //\u5c06a_b\u4e2db\u5143\u7d20\u6807\u8bb0 break ; } } } if ( flag ) { ll x = 0 ; for ( int j = 31 ; j >= 0 ; j -- ) { if ( k & ( ll ( 1 ) << j )) x ^= b . d [ j ]; //\u5c06\u7528\u4e0a\u7684b\u5143\u7d20\u548c\u672c\u8eab\u7684b[i]\u5f02\u6216\u5728\u4e00\u8d77\uff0c //\u7531(a[argv---]^b[argv---]^b[i]==0),\u6240\u5f97\u5373\u4e3aV1\u7684\u8d21\u732e } res . insert ( x ); } } } return res ; } }; Bit_Set tree [ maxn << 2 ]; void build ( ll t , ll l , ll r ) { if ( l == r ) { int k ; ll x ; scanf ( \"%d\" , & k ); while ( k -- ) { scanf ( \"%lld\" , & x ); tree [ t ]. insert ( x ); } return ; } int mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); tree [ t ] = tree [ 2 * t ] + tree [ 2 * t + 1 ]; } int query ( ll t , ll l , ll r , ll L , ll R , ll x ) { if ( l <= L && R <= r ) { return tree [ t ]. check ( x ); } int flag = 1 ; int mid = ( L + R ) / 2 ; if ( l <= mid ) flag &= query ( 2 * t , l , r , L , mid , x ); if ( r > mid ) flag &= query ( 2 * t + 1 , l , r , mid + 1 , R , x ); return flag ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); build ( 1 , 1 , n ); while ( m -- ) { int l , r , x ; scanf ( \"%d%d%d\" , & l , & r , & x ); if ( query ( 1 , l , r , 1 , n , x )) puts ( \"YES\" ); else puts ( \"NO\" ); } } \u7ebf\u6027\u57fa\u57fa\u7840 \u6027\u8d28 \u5bf9\u4e8e\u4e00\u4e2a\u6570\u7ec4\uff0c\u5b58\u5728\u4e00\u4e9b\u6570\u6784\u6210\u8be5\u6570\u7ec4\u7684\u7ebf\u6027\u57fa \u7ebf\u6027\u57fa\u6709\u4e09\u5927\u5f88\u4f18\u7f8e\u7684\u6027\u8d28 \u6570\u7ec4\u4e2d\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531\u7ebf\u6027\u57fa\u4e2d\u90e8\u5206\u6570\u5f02\u6216\u5f97\u5230 \u6570\u7ec4\u4e2d\u6240\u6709\u6570\u5f02\u6216\u51fa\u6765\u5747\u4e0d\u4e3a0 \u5bf9\u4e8e\u540c\u4e00\u6570\u7ec4\u7ebf\u6027\u57fa\u4e2a\u6570\u552f\u4e00 \u4f8b\u5982 2 \uff0c4 \uff0c 5 \uff0c 6 ,\u7531\u7ebf\u6027\u57fa ,\u7531\u7ebf\u6027\u57fa 1 , 2 , 4 1 , 2 , 4 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 1,2,41,2,4 2 \uff0c4 \uff0c 5 \uff0c 6 <span class=\"arithmatex\"><span class=\"MathJax_Preview\">,\u7531\u7ebf\u6027\u57fa</span><script type=\"math/tex\">,\u7531\u7ebf\u6027\u57fa 1 , 2 , 4 1 , 2 , 4 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 \u6570\u7ec4\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531 1,2,41,2,4 \u5f02\u6216\u5f97\u5230 \u7ebf\u6027\u57fa\u6784\u9020 \u6570\u7ec4\u6bcf\u52a0\u5165\u4e00\u4e2a\u6570\uff0c\u5bf9\u7ebf\u6027\u57fa\u8fdb\u884c\u4fee\u6539 \u4ee4\u7ebf\u6027\u57fa\u4e3ad[32] ,\u6570\u7ec4\u957f\u5ea6\u4e3amax(a[i])\u7684\u6700\u5927\u4e8c\u8fdb\u5236\uff08\u6240\u6709\u6570\u5747\u53ef\u4ee5\u7531$ 1 , 2 , 4 \u22ef ,2^n$ \u8868\u793a\uff09 void add ( int x ) { for ( int i = 31 ; i >= 0 ; i -- ) { //i\u4e3a\u7ebf\u6027\u57fa\u4e0b\u6807 if ( x & ( 1 << i )) { if ( d [ i ]) x ^= d [ i ]; //\u82e5\u8be5\u4e8c\u8fdb\u5236\u4f4d\u5df2\u6709\u503c\uff0c\u5f02\u6216\u5bfb\u627e\u7ebf\u6027\u57fa\u80fd\u5426\u8868\u8fbex^d[i] else { d [ i ] = x ; //\u82e5\u4e8c\u8fdb\u5236\u4f4d\u6ca1\u6709\u503c\uff0c\u8bf4\u660ex\u4e0d\u80fd\u88ab\u7ebf\u6027\u57fa\u8868\u8fbe\uff0c\u4ee4d[i]=x break ; //\u8bb0\u5f97\u5982\u679c\u63d2\u5165\u6210\u529f\u4e00\u5b9a\u8981\u9000\u51fa } } } } \u6784\u9020\u5408\u7406\u6027\uff1a \u82e5\u80fd\u63d2\u5165x \uff0c\u5219\u5c06d[i] =x\uff0cx\u53ef\u4ee5\u7531\u7ebf\u6027\u57fa\u8868\u8fbe \u82e5\u4e0d\u80fd\u63d2\u5165x\uff0c\u5219x\u6700\u7ec8\u5f02\u6216\u4e3a0\uff0c\u5373\u53ef\u4ee5\u7531\u7ebf\u6027\u57fa\u8868\u8fbe \u533a\u95f4\u5f02\u6216\u6700\u5927\u503c \u6570\u7ec4 ( L , R ) ( L , R ) \u5185\u53d6\u82e5\u5e72\u4e2a\u6570\uff0c\u4f7f\u8fd9\u4e9b\u6570\u5f02\u6216\u540e\u5f97\u5230\u7684\u503c\u6700\u5927 \u4ee4 d [ 32 ] \u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c \u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c p [ 32 ]p [ 32 ] d [ 32 ] <span class=\"arithmatex\"><span class=\"MathJax_Preview\">\u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c</span><script type=\"math/tex\">\u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u503c\uff0c p [ 32 ]p [ 32 ] \u6570\u7ec4\u8868\u793a\u7ebf\u6027\u57fa\u7684\u4f4d\u7f6e\uff08\u4e3a\u4e86\u4fbf\u4e8e\u8be2\u95ee\uff0c\u4f4d\u7f6e\u5c3d\u91cf\u5b58\u504f\u53f3\u7684\uff09 int ask ( int l , int r ){ int res = 0 ; for \uff08 int i = 31 ; i >= 0 ; i -- \uff09 if ( p [ i ] >= l && ( res ^ d [ i ]) > res ) res ^= d [ i ]; return res ; } \u8d2a\u5fc3\uff1a\u9ad8\u4f4d\u80fd\u53d8\u62101\uff0c\u5c31\u53d8\u62101\uff08\u9ad8\u4f4d1\u6bd4\u4f4e\u4f4d\u90fd\u53d8\u62101\u90fd\u6709\u4ef7\u503c\uff09 \u533a\u95f4\u5f02\u6216\u7b2ck\u5927 \u5148\u5c06\u7ebf\u6027\u57fa\u5904\u7406\u6210$ 1 , 2 , 4 , \u22ef ,2^n$ \u7684\u4e8c\u8fdb\u5236\u8868\u8fbe\u5f62\u5f0f \u53bb\u9664\u4e3a0\u7684\u5f02\u6216\u503c\uff0c\u6bcf\u4e00\u4f4dd[i] =1 \u76f8\u5f53\u4e8e\u53ef\u4ee5\u8868\u8fbe\u7684\u4e8c\u8fdb\u5236\u4f4d\u6570\u589e\u52a0\u4e00\u4f4d void work () { //\u5c06\u7ebf\u6027\u57fa\u8f6c\u5316\u4e3a2\u8fdb\u5236 for ( int i = 1 ; i <= 31 ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) if ( d [ i ] & ( 1 << ( j -1 ))) d [ i ] ^= d [ j -1 ]; } int k_th ( int k ) { if ( k == 1 && tot < n ) return 0 ; //\u7279\u5224\u4e00\u4e0b\uff0c\u5047\u5982k=1\uff0c\u5e76\u4e14\u539f\u6765\u7684\u5e8f\u5217\u53ef\u4ee5\u5f02\u6216\u51fa0\uff0c\u5c31\u8981\u8fd4\u56de0\uff0c //tot\u8868\u793a\u7ebf\u6027\u57fa\u4e2d\u7684\u5143\u7d20\u4e2a\u6570\uff0cn\u8868\u793a\u5e8f\u5217\u957f\u5ea6 if ( tot < n ) k -- ; //\u7c7b\u4f3c\u4e0a\u9762\uff0c\u53bb\u63890\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a\u7ebf\u6027\u57fa\u4e2d\u53ea\u80fd\u5f02\u6216\u51fa\u4e0d\u4e3a0\u7684\u89e3 work (); int ans = 0 ; for ( int i = 0 ; i <= 31 ; i ++ ) if ( d [ i ] != 0 ) { if ( k & 1 ) ans ^= d [ i ]; k >>= 1 ; } }","title":"\u7ebf\u6027\u57fa"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_17","text":"\u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/zuzhiang/article/details/78173412 https://www.cnblogs.com/s1124yy/p/6258026.html https://blog.csdn.net/tianwei0822/article/details/79439054 \u4e3b\u5e2d\u6811\u7ef4\u62a4\u533a\u95f4\u7b2ck\u5927\u6570 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; int L [ 3200500 ] = { 0 }, R [ 3200500 ] = { 0 }, sum [ 3200500 ] = { 0 }; int tot = 0 ; int a [ 3200500 ] = { 0 }, hash1 [ 3200500 ] = { 0 }, T [ 3200500 ] = { 0 }; int build ( int l , int r ) { int root = ++ tot ; sum [ root ] = 0 ; if ( l < r ) { int mid = ( l + r ) / 2 ; L [ root ] = build ( l , mid ); R [ root ] = build ( mid + 1 , r ); } return root ; } int update ( int pre , int l , int r , int pos ) { int root = ++ tot ; L [ root ] = L [ pre ]; R [ root ] = R [ pre ]; sum [ root ] = sum [ pre ] + 1 ; if ( l < r ) { int mid = ( l + r ) / 2 ; if ( pos <= mid ) L [ root ] = update ( L [ pre ], l , mid , pos ); else R [ root ] = update ( R [ pre ], mid + 1 , r , pos ); } return root ; } int query ( int l1 , int r1 , int l , int r , int k ) //\u53c2\u6570\u5206\u522b\u4e3a\uff1a\u4e24\u9897\u7ebf\u6bb5\u6811\u6839\u8282\u70b9\u7684\u7f16\u53f7\uff0c\u5de6\u53f3\u7aef\u70b9\uff0c\u7b2ck\u5927 { if ( l >= r ) return l ; int mid = ( l + r ) / 2 ; int num = sum [ L [ r1 ]] - sum [ L [ l1 ]]; if ( num >= k ) return query ( L [ l1 ], L [ r1 ], l , mid , k ); else return query ( R [ l1 ], R [ r1 ], mid + 1 , r , k - num ); } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { tot = 0 ; int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]), hash1 [ i ] = a [ i ]; sort ( hash1 + 1 , hash1 + n + 1 ); int d = unique ( hash1 + 1 , hash1 + n + 1 ) - hash1 - 1 ; T [ 0 ] = build ( 1 , d ); for ( int i = 1 ; i <= n ; i ++ ) { int pos = lower_bound ( hash1 + 1 , hash1 + d + 1 , a [ i ]) - hash1 ; T [ i ] = update ( T [ i - 1 ], 1 , d , pos ); } for ( int i = 1 ; i <= m ; i ++ ) { int l , r , k ; scanf ( \"%d%d%d\" , & l , & r , & k ); int pos = query ( T [ l - 1 ], T [ r ], 1 , d , k ); printf ( \"%d \\n \" , hash1 [ pos ]); } } } \u67e5\u8be2\u533a\u95f4\u5185\u5c0f\u4e8e\u7b49\u4e8e\u7ed9\u5b9a\u7684K\u7684\u6570\u7684\u4e2a\u6570 \u9898\u76ee\u94fe\u63a5\uff1a https://acm.hdu.edu.cn/showproblem.php?pid=4417 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; int L [ 3200500 ] = { 0 }, R [ 3200500 ] = { 0 }, sum [ 3200500 ] = { 0 }; int tot = 0 ; int a [ 3200500 ] = { 0 }, hash1 [ 3200500 ] = { 0 }, T [ 3200500 ] = { 0 }; int build ( int l , int r ) { int root = ++ tot ; sum [ root ] = 0 ; if ( l < r ) { int mid = ( l + r ) / 2 ; L [ root ] = build ( l , mid ); R [ root ] = build ( mid + 1 , r ); } return root ; } int update ( int pre , int l , int r , int pos ) { int root = ++ tot ; L [ root ] = L [ pre ]; R [ root ] = R [ pre ]; sum [ root ] = sum [ pre ] + 1 ; if ( l < r ) { int mid = ( l + r ) / 2 ; if ( pos <= mid ) L [ root ] = update ( L [ pre ], l , mid , pos ); else R [ root ] = update ( R [ pre ], mid + 1 , r , pos ); } return root ; } int query ( int l1 , int r1 , int l , int r , int k ) { if ( k < hash1 [ l ]) return 0 ; if ( hash1 [ r ] <= k ) return sum [ r1 ] - sum [ l1 ]; int mid = ( l + r ) / 2 ; if ( k <= hash1 [ mid ]) { return query ( L [ l1 ], L [ r1 ], l , mid , k ); } else { int num = 0 ; num += sum [ L [ r1 ]] - sum [ L [ l1 ]]; num += query ( R [ l1 ], R [ r1 ], mid + 1 , r , k ); return num ; } } int main () { int t ; scanf ( \"%d\" , & t ); for ( int t1 = 1 ; t1 <= t ; t1 ++ ) { tot = 0 ; int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]), hash1 [ i ] = a [ i ]; sort ( hash1 + 1 , hash1 + n + 1 ); int d = unique ( hash1 + 1 , hash1 + n + 1 ) - hash1 - 1 ; T [ 0 ] = build ( 1 , d ); for ( int i = 1 ; i <= n ; i ++ ) { int pos = lower_bound ( hash1 + 1 , hash1 + d + 1 , a [ i ]) - hash1 ; T [ i ] = update ( T [ i - 1 ], 1 , d , pos ); } printf ( \"Case %d: \\n \" , t1 ); for ( int i = 1 ; i <= m ; i ++ ) { int l , r , k ; scanf ( \"%d%d%d\" , & l , & r , & k ); int ans = query ( T [ l ], T [ r + 1 ], 1 , d , k ); printf ( \"%d \\n \" , ans ); } } }","title":"\u4e3b\u5e2d\u6811"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#st","text":"ST \u8868\u662f\u7528\u4e8e\u89e3\u51b3 \u53ef\u91cd\u590d\u8d21\u732e\u95ee\u9898 \u7684\u6570\u636e\u7ed3\u6784\u3002 \u53ef\u91cd\u590d\u8d21\u732e\u95ee\u9898 \u662f\u6307\u5bf9\u4e8e\u8fd0\u7b97 opt opt \uff0c\u6ee1\u8db3 x\\quad opt\\quad x = x x\\quad opt\\quad x = x \uff0c\u5219\u5bf9\u5e94\u7684\u533a\u95f4\u8be2\u95ee\u5c31\u662f\u4e00\u4e2a\u53ef\u91cd\u590d\u8d21\u732e\u95ee\u9898\u3002\u4f8b\u5982\uff0c\u6700\u5927\u503c\u6709 max(x,x)=x max(x,x)=x \uff0cgcd \u6709 gcd(x,x)=x gcd(x,x)=x \uff0c\u6240\u4ee5 RMQ \u548c\u533a\u95f4 GCD \u5c31\u662f\u4e00\u4e2a\u53ef\u91cd\u590d\u8d21\u732e\u95ee\u9898\u3002\u50cf\u533a\u95f4\u548c\u5c31\u4e0d\u5177\u6709\u8fd9\u4e2a\u6027\u8d28\uff0c\u5982\u679c\u6c42\u533a\u95f4\u548c\u7684\u65f6\u5019\u91c7\u7528\u7684\u9884\u5904\u7406\u533a\u95f4\u91cd\u53e0\u4e86\uff0c\u5219\u4f1a\u5bfc\u81f4\u91cd\u53e0\u90e8\u5206\u88ab\u8ba1\u7b97\u4e24\u6b21\uff0c\u8fd9\u662f\u6211\u4eec\u6240\u4e0d\u613f\u610f\u770b\u5230\u7684\u3002\u53e6\u5916\uff0c opt opt \u8fd8\u5fc5\u987b\u6ee1\u8db3\u7ed3\u5408\u5f8b\u624d\u80fd\u4f7f\u7528 ST \u8868\u6c42\u89e3\u3002 \u4e00\u7ef4ST\u8868\u6a21\u677f #include <stdio.h> #include <math.h> #define max(a, b) (a > b ? a : b) #define min(a, b) (a < b ? a : b) using namespace std ; int a [ 50050 ] = { 0 }, dp_max [ 50050 ][ 30 ] = { 0 }, dp_min [ 50050 ][ 30 ] = { 0 }; int n , m ; void st () { for ( int i = 1 ; i <= n ; i ++ ) dp_max [ i ][ 0 ] = dp_min [ i ][ 0 ] = a [ i ]; for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 1 ; i + ( 1 << j ) - 1 <= n ; i ++ ) { dp_max [ i ][ j ] = max ( dp_max [ i ][ j - 1 ], dp_max [ i + ( 1 << ( j - 1 ))][ j - 1 ]); dp_min [ i ][ j ] = min ( dp_min [ i ][ j - 1 ], dp_min [ i + ( 1 << ( j - 1 ))][ j - 1 ]); } } } int query_max ( int l , int r ) { int k = log2 ( r - l + 1 ); return max ( dp_max [ l ][ k ], dp_max [ r - ( 1 << k ) + 1 ][ k ]); } int query_min ( int l , int r ) { int k = log2 ( r - l + 1 ); return min ( dp_min [ l ][ k ], dp_min [ r - ( 1 << k ) + 1 ][ k ]); } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); st (); while ( m -- ) { int l , r ; scanf ( \"%d%d\" , & l , & r ); printf ( \"%d \\n \" , query_max ( l , r ) - query_min ( l , r )); } } \u4e00\u7ef4ST\u7ef4\u62a4GCD\u6a21\u677f \u9898\u76ee\u5927\u610f\u4e3a\u7ed9\u5b9a\u957f\u5ea6\u4e3an\u7684\u5e8f\u5217\uff0c\u540e\u9762\u53c8m\u6b21\u8be2\u95ee\uff0c\u8be2\u95ee\u6ee1\u8db3\u533a\u95f4gcd\u4e3a\u7ed9\u5b9a\u6570\u503c\u7684\u4e2a\u6570\u3002 \u7b97\u6cd5\u4e3a\u4e8c\u5206+ST\u8868\uff0c\u7531\u4e8e\u533a\u95f4\u4e2d\u4e0d\u540cGCD\u4e2a\u6570\u6700\u591a\u4e3alog\u4e2a\uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6 nlog(n) nlog(n) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }, dp [ 100500 ][ 30 ] = { 0 }; map < ll , ll > mp ; ll n , m , k ; void st () { for ( ll i = 1 ; i <= n ; i ++ ) dp [ i ][ 0 ] = a [ i ]; for ( ll j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( ll i = 1 ; i + ( 1 << j ) - 1 <= n ; i ++ ) { dp [ i ][ j ] = __gcd ( dp [ i ][ j - 1 ], dp [ i + ( 1 << ( j - 1 ))][ j - 1 ]); } } } ll query ( ll l , ll r ) { ll k = log2 ( r - l + 1 ); return __gcd ( dp [ l ][ k ], dp [ r - ( 1 << k ) + 1 ][ k ]); } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); st (); for ( ll i = 1 ; i <= n ; i ++ ) { ll cur = i , gc = a [ i ]; while ( cur <= n ) { ll l = cur , r = n ; while ( l < r ) { ll mid = ( l + r + 1 ) / 2 ; if ( query ( cur , mid ) == gc ) l = mid ; else r = mid - 1 ; } if ( mp . count ( gc ) == 0 ) mp [ gc ] = ( l - cur + 1 ); else mp [ gc ] += ( l - cur + 1 ); cur = l + 1 ; if ( cur <= n ) gc = __gcd ( gc , a [ cur ]); } } scanf ( \"%lld\" , & m ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & k ); printf ( \"%lld \\n \" , mp [ k ]); } return 0 ; } \u4e8c\u7ef4ST\u8868\u6a21\u677f #include <bits/stdc++.h> using namespace std ; int dp_max [ 300 ][ 300 ][ 20 ] = { 0 }; int dp_min [ 300 ][ 300 ][ 30 ] = { 0 }; int a [ 300 ][ 300 ] = { 0 }; int n , m ; void st () { for ( int i = 1 ; i <= n ; i ++ ) { for ( int k = 0 ; ( 1 << k ) <= m ; k ++ ) { for ( int j = 1 ; j + ( 1 << k ) - 1 <= m ; j ++ ) { if ( k == 0 ) dp_max [ i ][ j ][ k ] = dp_min [ i ][ j ][ k ] = a [ i ][ j ]; else { dp_max [ i ][ j ][ k ] = max ( dp_max [ i ][ j ][ k - 1 ], dp_max [ i ][ j + ( 1 << ( k - 1 ))][ k - 1 ]); dp_min [ i ][ j ][ k ] = min ( dp_min [ i ][ j ][ k - 1 ], dp_min [ i ][ j + ( 1 << ( k - 1 ))][ k - 1 ]); } } } } } int query_max ( int x , int y , int xx , int yy ) { int k = log2 ( yy - y + 1 ); int mm = 0 ; for ( int i = x ; i <= xx ; i ++ ) mm = max ( mm , max ( dp_max [ i ][ y ][ k ], dp_max [ i ][ yy - ( 1 << k ) + 1 ][ k ])); return mm ; } int query_min ( int x , int y , int xx , int yy ) { int k = log2 ( yy - y + 1 ); int mm = 0x3f3f3f3f ; for ( int i = x ; i <= xx ; i ++ ) mm = min ( mm , min ( dp_min [ i ][ y ][ k ], dp_min [ i ][ yy - ( 1 << k ) + 1 ][ k ])); return mm ; } int main () { int b , k ; scanf ( \"%d%d%d\" , & n , & b , & k ); m = n ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) scanf ( \"%d\" , & a [ i ][ j ]); st (); while ( k -- ) { int p , q ; scanf ( \"%d%d\" , & p , & q ); int ans1 = query_max ( p , q , p + b - 1 , q + b - 1 ); int ans2 = query_min ( p , q , p + b - 1 , q + b - 1 ); printf ( \"%d \\n \" , ans1 - ans2 ); } return 0 ; }","title":"ST\u8868"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_18","text":"","title":"\u5b57\u7b26\u4e32"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#kmp","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; const ll N = 1005000 ; ll Next [ N ]; char s [ N ]; char t [ N ]; ll tlen , len ; void getNext ( char s [ N ]) { ll j = 0 , k = -1 ; Next [ 0 ] = -1 ; while ( j < tlen ) { if ( k == -1 || s [ j ] == s [ k ]) { Next [ ++ j ] =++ k ; } else k = Next [ k ]; } } int main () { while ( 1 ) { scanf ( \"%s\" , s ); if ( s [ 0 ] == '.' ) break ; tlen = strlen ( s ); len = tlen ; getNext ( s ); ll kk = tlen - Next [ tlen ]; if ( strlen ( s ) % kk == 0 ) { printf ( \"%d \\n \" , strlen ( s ) / kk ); } else { printf ( \"1 \\n \" ); //\u5982\u679c\u4e0d\u80fd\u9664\u5c3d\uff0c\u8bf4\u660e\u6709\u540e\u7f00\uff0c\u4f8b\u5982abababa\uff0c\u8fd9\u79cd\u60c5\u51b5\u53ea\u80fd\u4e3a1 } } return 0 ; }","title":"KMP\u7b97\u6cd5"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_19","text":"\u7ed9\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u5b57\u7b26\u4e32(1<=n<=200000),\u4ed6\u53ea\u5305\u542b**\u5c0f\u5199**\u5b57\u6bcd \u627e\u5230\u8fd9\u4e2a\u5b57\u7b26\u4e32\u591a\u5c11\u4e2a\u524d\u7f00\u662fM\u5f62\u5b57\u7b26\u4e32. M\u5f62\u5b57\u7b26\u4e32\u5b9a\u4e49\u5982\u4e0b: \u4ed6\u7531\u4e24\u4e2a\u76f8\u540c\u7684\u56de\u6587\u4e32\u62fc\u63a5\u800c\u6765,\u7b2c\u4e00\u4e2a\u56de\u6587\u4e32\u7684\u7ed3\u5c3e\u5b57\u7b26\u548c\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u4e32\u7684\u5f00\u59cb\u5b57\u7b26\u53ef\u4ee5\u91cd\u53e0,\u4e5f\u5c31\u662f\u4ee5\u4e0b\u90fd\u662fM \u5f62\u5b57\u7b26\u4e32. abccbaabccba(\u7531abccba+abccba\u7ec4\u6210) abcbaabcba(\u6709abcba+abcba\u7ec4\u6210) abccbabccba(\u7531abccba+abccba\u7ec4\u6210\u7ec4\u6210,\u4f46\u662f\u4e2d\u95f4\u76841\u662f\u5171\u7528\u7684) a(\u4e00\u4e2a\u5355\u72ec\u5b57\u7b26\u4e5f\u7b97) #include <bits/stdc++.h> using namespace std ; typedef unsigned long long int ULL ; const int N = 200010 ; int P = 131 ; ULL p [ N ], h [ N ], ed [ N ]; int ask1 ( int l , int r ) { return h [ r ] - h [ l - 1 ] * p [ r - l + 1 ]; } int ask2 ( int l , int r ) { return ed [ l ] - ed [ r + 1 ] * p [ r - l + 1 ]; } int main () { int ans = 0 ; char str [ N ]; cin >> str + 1 ; int n = strlen ( str + 1 ); p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { h [ i ] = h [ i - 1 ] * P + str [ i ]; p [ i ] = p [ i - 1 ] * P ; } for ( int i = n ; i >= 0 ; i -- ) { ed [ i ] = ed [ i + 1 ] * P + str [ i ]; } for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) { int x = ( i + 1 ) / 2 ; if ( ask1 ( 1 , x ) == ask1 ( x , i ) && ask1 ( 1 , x ) == ask2 ( 1 , x )) ans ++ ; } else { int x = i / 2 ; if ( ask1 ( 1 , x ) == ask1 ( x + 1 , i ) && ask1 ( 1 , x ) == ask2 ( 1 , x )) ans ++ ; } } cout << ans ; }","title":"\u5b57\u7b26\u4e32\u54c8\u5e0c"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_20","text":"#include <bits/stdc++.h> ///\u6c42\u89e3\u6700\u957f\u56de\u6587\u4e32\uff0c\u5bf9p[i]/2\u6c42\u548c\u5373\u53ef\u5f97\u56de\u6587\u4e32\u4e2a\u6570 using namespace std ; typedef long long ll ; char a [ 500500 ] = { 0 }; int l [ 500500 ] = { 0 }; int r [ 500500 ] = { 0 }; string str = \"$#\" ; vector < int > p ; void manacher ( char * c ) { int max_id = 0 , id = 0 ; for ( int i = 1 ; c [ i ]; i ++ ) str += c [ i ], str += \"#\" ; p . push_back ( 1 ); for ( int i = 1 ; i < ( int ) str . size (); i ++ ) { if ( max_id > i ) p . push_back ( min ( max_id - i , p [ 2 * id - i ])); else p . push_back ( 1 ); while ( i + p [ i ] < ( int ) str . size () && str [ i + p [ i ]] == str [ i - p [ i ]]) p [ i ] ++ ; if ( i + p [ i ] > max_id ){ max_id = i + p [ i ], id = i ; } } } int main () { scanf ( \"%s\" , a + 1 ); manacher ( a ); int now = 0 , n = str . size (), ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , p [ i ] -1 ); printf ( \"%d\" , ans ); }","title":"\u56de\u6587\u4e32\u5339\u914d\u7b97\u6cd5\uff08\u9a6c\u62c9\u8f66\u7b97\u6cd5\uff09"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_21","text":"\u4ece\u4e00\u7ec4\u6570\u636e\u4e2d\u9009\u53d6\u4e24\u4e2a\u6570\u6c42\u6700\u5927\u5f02\u6216\u503c\u3002 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 1005000 ] = { 0 }; int tree [ 5000500 ][ 3 ] = { 0 }; int tot = 1 ; ///\u5fc5\u987b\u4ece1\u5f00\u59cb int in ( int x ) { int p = 1 ; for ( int i = 30 ; i >= 0 ; i -- ) { int k = x >> i & 1 ; if ( tree [ p ][ k ] == 0 ) tree [ p ][ k ] =++ tot ; p = tree [ p ][ k ]; } } int out ( int x ) { int p = 1 , ans = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { int k = x >> i & 1 ; if ( tree [ p ][ ! k ]) { ans = ans * 2 +! k ; p = tree [ p ][ ! k ]; } else { ans = ans * 2 + k ; p = tree [ p ][ k ]; } } return ans ; } int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { in ( a [ i ]); int num = out ( a [ i ]); max1 = max ( max1 , num ^ a [ i ]); } cout << max1 << endl ; return 0 ; }","title":"\u5b57\u5178\u6811"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_22","text":"\u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/qq_40736036/article/details/89110584 #include <bits/stdc++.h> using namespace std ; typedef unsigned long long ull ; typedef long long ll ; const ll mod = 10000 ; char c [ 5000500 ] = { 0 }; struct grammer { pair < char * , ll > Q ( char * p ) { pair < char * , ll > ans1 = E ( p ); if ( ans1 . first == NULL ) return { NULL , 0 }; ans1 . second %= mod ; return ans1 ; } pair < char * , ll > E ( char * p ) { pair < char * , ll > ans1 = T ( p ); if ( ans1 . first == NULL ) return { NULL , 0 }; while ( * ans1 . first == '+' || * ans1 . first == '-' ) { pair < char * , ll > ans2 = T ( ans1 . first + 1 ); if ( ans2 . first == NULL ) return { NULL , 0 }; if ( * ans1 . first == '+' ) ans1 . second += ans2 . second ; else if ( * ans1 . first == '-' ) ans1 . second -= ans2 . second ; ans1 . second = ( ans1 . second % mod + mod ) % mod ; ans1 . first = ans2 . first ; } return ans1 ; } pair < char * , ll > T ( char * p ) { pair < char * , ll > ans1 = F ( p ); if ( ans1 . first == NULL ) return { NULL , 0 }; while ( * ans1 . first == '*' ) { pair < char * , ll > ans2 = F ( ans1 . first + 1 ); if ( ans2 . first == NULL ) return { NULL , 0 }; ans1 . second *= ans2 . second ; ans1 . second %= mod ; ans1 . first = ans2 . first ; } return ans1 ; } pair < char * , ll > F ( char * p ) { if ( * p >= '0' || * p <= '9' ) { return N ( p ); } else if ( * p == '-' ) { pair < char * , ll > ans1 = F ( p + 1 ); if ( ans1 . first == NULL ) return { NULL , 0 }; return { ans1 . first , ( - ans1 . second % mod + mod ) % mod }; } else if ( * p == '(' ) { pair < char * , ll > ans1 = E ( p + 1 ); if ( ans1 . first == NULL ) return { NULL , 0 }; if ( * ans1 . first == ')' ) return { ans1 . first + 1 , ans1 . second % mod }; else return { NULL , 0 }; } else { return { NULL , 0 }; } } pair < char * , ll > N ( char * p ) { if ( * p == '0' ) { // if (*(p + 1) >= '0' || *(p + 1) <= '9') // return {NULL, 0}; // else return { p + 1 , 0 }; } else if ( * p >= '1' && * p <= '9' ) { pair < char * , ll > ans1 = B ( p ); if ( ans1 . first == NULL ) { return { NULL , 0 }; } return { ans1 . first , ans1 . second % mod }; } else { return { NULL , 0 }; } } pair < char * , ll > B ( char * p ) { ll sum = 0 ; while ( * p >= '0' && * p <= '9' ) { sum = sum * 10 + * p - '0' ; p ++ ; sum %= mod ; } return { p , sum % mod }; } } Grammer ; int main () { scanf ( \"%s\" , c + 1 ); ll ans = ( Grammer . Q ( c + 1 ). second % mod + mod ) % mod ; printf ( \"%lld \\n \" , ans ); }","title":"\u6587\u6cd5\u5206\u6790"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#ac","text":"\u53c2\u8003\u94fe\u63a5\uff1a https://www.cnblogs.com/nullzx/p/7499397.html https://zhuanlan.zhihu.com/p/80325757 https://oi-wiki.org/string/ac-automaton/ AC\u81ea\u52a8\u673a\u6a21\u677f\uff1a \u7ed9\u5b9a n n \u4e2a\u6a21\u5f0f\u4e32 s_i s_i \u548c\u4e00\u4e2a\u6587\u672c\u4e32 t t \uff0c\u6c42\u6709\u591a\u5c11\u4e2a\u4e0d\u540c\u7684\u6a21\u5f0f\u4e32\u5728\u6587\u672c\u4e32\u91cc\u51fa\u73b0\u8fc7\u3002 \u4e24\u4e2a\u6a21\u5f0f\u4e32\u4e0d\u540c\u5f53\u4e14\u4ec5\u5f53\u4ed6\u4eec**\u7f16\u53f7**\u4e0d\u540c\u3002 #include <bits/stdc++.h> using namespace std ; const int N = 1e6 + 6 ; int n ; namespace AC { int tr [ N ][ 26 ], tot ; int e [ N ], fail [ N ]; void insert ( char * s ) { int u = 0 ; for ( int i = 1 ; s [ i ]; i ++ ) { if ( ! tr [ u ][ s [ i ] - 'a' ]) tr [ u ][ s [ i ] - 'a' ] = ++ tot ; //\u5982\u679c\u6ca1\u6709\u5219\u63d2\u5165\u65b0\u8282\u70b9 u = tr [ u ][ s [ i ] - 'a' ]; //\u641c\u7d22\u4e0b\u4e00\u4e2a\u8282\u70b9 } e [ u ] ++ ; //\u5c3e\u4e3a\u8282\u70b9 u \u7684\u4e32\u7684\u4e2a\u6570 } queue < int > q ; void build () { for ( int i = 0 ; i < 26 ; i ++ ) if ( tr [ 0 ][ i ]) q . push ( tr [ 0 ][ i ]); while ( q . size ()) { int u = q . front (); q . pop (); for ( int i = 0 ; i < 26 ; i ++ ) { if ( tr [ u ][ i ]) { fail [ tr [ u ][ i ]] = tr [ fail [ u ]][ i ]; // fail\u6570\u7ec4\uff1a\u540c\u4e00\u5b57\u7b26\u53ef\u4ee5\u5339\u914d\u7684\u5176\u4ed6\u4f4d\u7f6e q . push ( tr [ u ][ i ]); } else tr [ u ][ i ] = tr [ fail [ u ]][ i ]; } } } int query ( char * t ) { int u = 0 , res = 0 ; for ( int i = 1 ; t [ i ]; i ++ ) { u = tr [ u ][ t [ i ] - 'a' ]; // \u8f6c\u79fb for ( int j = u ; j && e [ j ] != -1 ; j = fail [ j ]) { res += e [ j ], e [ j ] = -1 ; } } return res ; } } // namespace AC char s [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , s + 1 ), AC :: insert ( s ); scanf ( \"%s\" , s + 1 ); AC :: build (); printf ( \"%d\" , AC :: query ( s )); return 0 ; }","title":"AC\u81ea\u52a8\u673a"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_23","text":"\u53c2\u8003\u4e8e\uff1a https://www.cnblogs.com/luowentao/p/10332311.html 1.\u89c4\u5219 {n}\u5339\u914d\u786e\u5b9a\u7684n\u6b21 {n,}\u81f3\u5c11\u5339\u914dn\u6b21(\u6ce8:\u8bf7\u4e0d\u8981\u64c5\u81ea\u52a0\u7a7a\u683c\u4e0a\u53bb) {n,m}\u6700\u5c11n\u6b21,\u6700\u591am\u6b21. *\u5339\u914d\u524d\u9762\u7684\u5b50\u8868\u8fbe\u5f0f0\u6b21\u6216\u591a\u6b21 = {0,} +\u5339\u914d\u524d\u9762\u7684\u5b50\u8868\u8fbe\u5f0f1\u6b21\u6216\u591a\u6b21 = {1,} ?\u5339\u914d\u524d\u9762\u7684\u5b50\u8868\u8fbe\u5f0f1\u6b21\u6216\u4e24\u6b21 = {1,2} ()\u8868\u793a\u4e00\u4e2a\u6574\u4f53 []\u8868\u793a\u4e00\u4f4d {}\u8868\u793a\u5339\u914d\u591a\u5c11\u6b21 .\u5339\u914d\u9664\u6362\u884c\u7b26\u4e4b\u5916\u7684\u4efb\u610f\u5b57\u7b26 \\w\u5339\u914d\u5355\u5b57\u5b57\u7b26(a-z,A-Z,0-9\u4ee5\u53ca\u4e0b\u5212\u7ebf) \\W\u5339\u914d\u975e\u5355\u5b57\u5b57\u7b26 \\s\u5339\u914d\u7a7a\u767d\u5b57\u7b26(\u7a7a\u683c,\u5236\u8868\u7b26,\u6362\u884c\u7b26) \\S\u5339\u914d\u975e\u7a7a\u767d\u5b57\u7b26 \\d\u5339\u914d\u6570\u5b57\u5b57\u7b26 \\D\u5339\u914d\u975e\u6570\u5b57\u5b57\u7b26 ^\u6307\u793a\u4ece\u884c\u7684\u5f00\u59cb\u4f4d\u7f6e\u5f00\u59cb\u5339\u914d(\u8fd8\u6709\u58f0\u660e\u4e0d\u5728\u5b57\u7b26\u96c6\u6307\u5b9a\u8303\u56f4\u5185) $\u6307\u793a\u4ece\u884c\u7684\u7ed3\u675f\u4f4d\u7f6e\u5f00\u59cb\u5339\u914d \\b\u5339\u914d\u5355\u8bcd\u7684\u5f00\u59cb\u6216\u7ed3\u675f\u4f4d\u7f6e 2.\u901f\u8bb0\u7406\u89e3 . [ ] ^ $\u56db\u4e2a\u5b57\u7b26\u662f\u6240\u6709\u8bed\u8a00\u90fd\u652f\u6301\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\uff0c\u6240\u4ee5\u8fd9\u56db\u4e2a\u662f\u57fa\u7840\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u3002\u6b63\u5219\u96be\u7406\u89e3\u56e0\u4e3a\u91cc\u9762\u6709\u4e00\u4e2a\u7b49\u4ef7\u7684\u6982\u5ff5\uff0c\u8fd9\u4e2a\u6982\u5ff5\u5927\u5927\u589e\u52a0\u4e86\u7406\u89e3\u96be\u5ea6\uff0c\u8ba9\u5f88\u591a\u521d\u5b66\u8005\u770b\u8d77\u6765\u4f1a\u61f5\uff0c\u5982\u679c\u628a\u7b49\u4ef7\u90fd\u6062\u590d\u6210\u539f\u59cb\u5199\u6cd5\uff0c\u81ea\u5df1\u4e66\u5199\u6b63\u5219\u5c31\u8d85\u7ea7\u7b80\u5355\u4e86\uff0c\u5c31\u50cf\u8bf4\u8bdd\u4e00\u6837\u53bb\u5199\u4f60\u7684\u6b63\u5219\u4e86\uff1a \u7b49\u4ef7\uff1a \u7b49\u4ef7\u662f\u7b49\u540c\u4e8e\u7684\u610f\u601d\uff0c\u8868\u793a\u540c\u6837\u7684\u529f\u80fd\uff0c\u7528\u4e0d\u540c\u7b26\u53f7\u6765\u4e66\u5199\u3002 ?,*,+,\\d,\\w \u90fd\u662f\u7b49\u4ef7\u5b57\u7b26 \u3000\u3000?\u7b49\u4ef7\u4e8e\u5339\u914d\u957f\u5ea6{0,1} \u3000\u3000*\u7b49\u4ef7\u4e8e\u5339\u914d\u957f\u5ea6{0,} \u3000\u3000+\u7b49\u4ef7\u4e8e\u5339\u914d\u957f\u5ea6{1,} \u3000\u3000\\d\u7b49\u4ef7\u4e8e[0-9] \\D\u7b49\u4ef7\u4e8e[^0-9] \\w\u7b49\u4ef7\u4e8e[A-Za-z_0-9] \\W\u7b49\u4ef7\u4e8e[^A-Za-z_0-9]\u3002 \u5e38\u7528\u8fd0\u7b97\u7b26\u4e0e\u8868\u8fbe\u5f0f\uff1a \u3000\u3000^ \u5f00\u59cb \u3000\u3000() \u57df\u6bb5 \u3000\u3000[] \u5305\u542b,\u9ed8\u8ba4\u662f\u4e00\u4e2a\u5b57\u7b26\u957f\u5ea6 \u3000\u3000[^] \u4e0d\u5305\u542b,\u9ed8\u8ba4\u662f\u4e00\u4e2a\u5b57\u7b26\u957f\u5ea6 \u3000\u3000{n,m} \u5339\u914d\u957f\u5ea6 \u3000\u3000. \u4efb\u4f55\u5355\u4e2a\u5b57\u7b26(\\. \u5b57\u7b26\u70b9) \u3000\u3000| \u6216 \u3000\u3000\\ \u8f6c\u4e49 \u3000\u3000$ \u7ed3\u5c3e \u3000\u3000[A-Z] 26\u4e2a\u5927\u5199\u5b57\u6bcd \u3000\u3000[a-z] 26\u4e2a\u5c0f\u5199\u5b57\u6bcd \u3000\u3000[0-9] 0\u81f39\u6570\u5b57 [A-Za-z0-9] 26\u4e2a\u5927\u5199\u5b57\u6bcd\u300126\u4e2a\u5c0f\u5199\u5b57\u6bcd\u548c0\u81f39\u6570\u5b57 , \u5206\u5272 \u3000\u3000\u5206\u5272\u8bed\u6cd5\uff1a \u3000\u3000[A,H,T,W] \u5305\u542bA\u6216H\u6216T\u6216W\u5b57\u6bcd \u3000\u3000[a,h,t,w] \u5305\u542ba\u6216h\u6216t\u6216w\u5b57\u6bcd \u3000\u3000[0,3,6,8] \u5305\u542b0\u62163\u62166\u62168\u6570\u5b57 \u8bed\u6cd5\u4e0e\u91ca\u4e49\uff1a \u3000\u3000\u57fa\u7840\u8bed\u6cd5 \"^([]{})([]{})([]{})$\" \u3000\u3000\u6b63\u5219\u5b57\u7b26\u4e32 = \"\u5f00\u59cb\uff08[\u5305\u542b\u5185\u5bb9]{\u957f\u5ea6}\uff09\uff08[\u5305\u542b\u5185\u5bb9]{\u957f\u5ea6}\uff09\uff08[\u5305\u542b\u5185\u5bb9]{\u957f\u5ea6}\uff09\u7ed3\u675f\" \u3000\u3000 \u3000\u3000?,*,+,\\d,\\w \u8fd9\u4e9b\u90fd\u662f\u7b80\u5199\u7684,\u5b8c\u5168\u53ef\u4ee5\u7528[]\u548c{}\u4ee3\u66ff\uff0c\u5728(?:)(?=)(?!)(?<=)(?<!)(?i)(*?)(+?)\u8fd9\u79cd\u7279\u6b8a\u7ec4\u5408\u60c5\u51b5\u4e0b\u9664\u5916\u3002 \u3000\u3000\u521d\u5b66\u8005\u53ef\u4ee5\u5ffd\u7565?,*,+,\\d,\\w\u4e00\u4e9b\u7b80\u5199\u6807\u793a\u7b26\uff0c\u5b66\u4f1a\u4e86\u57fa\u7840\u4f7f\u7528\u518d\u6309\u8868\u81ea\u5df1\u53bb\u7b49\u4ef7\u66ff\u6362 \u3000\u3000 \u3000\u3000\u5b9e\u4f8b\uff1a \u3000\u3000\u5b57\u7b26\u4e32\uff1btel:086-0666-88810009999 \u3000\u3000\u539f\u59cb\u6b63\u5219\uff1a\"^tel:[0-9]{1,3}-[0][0-9]{2,3}-[0-9]{8,11}$\" \u3000\u3000\u901f\u8bb0\u7406\u89e3\uff1a\u5f00\u59cb \"tel:\u666e\u901a\u6587\u672c\"[0-9\u6570\u5b57]{1\u81f33\u4f4d}\"-\u666e\u901a\u6587\u672c\"[0\u6570\u5b57][0-9\u6570\u5b57]{2\u81f33\u4f4d}\"-\u666e\u901a\u6587\u672c\"[0-9\u6570\u5b57]{8\u81f311\u4f4d} \u7ed3\u675f\" \u3000\u3000\u7b49\u4ef7\u7b80\u5199\u540e\u6b63\u5219\u5199\u6cd5\uff1a\"^tel:\\d{1,3}-[0]\\d{2,3}-\\d{8,11}$\" \uff0c\u7b80\u5199\u8bed\u6cd5\u4e0d\u662f\u6240\u6709\u8bed\u8a00\u90fd\u652f\u6301\u3002 3.\u4ee3\u7801\u5b9e\u4f8b 3.1 \u793a\u4f8b\u4e00 // \u5b9a\u4e49\u4e00\u4e2a\u6b63\u5219\u8868\u8fbe\u5f0f , 4~23 \u4f4d\u6570\u5b57\u548c\u5b57\u6bcd\u7684\u7ec4\u5408 regex repPattern(\"[0-9a-zA-Z]{4,23}\",regex_constants::extended); // \u58f0\u660e\u5339\u914d\u7ed3\u679c\u53d8\u91cf match_results<string::const_iterator> rerResult; // \u5b9a\u4e49\u5f85\u5339\u914d\u7684\u5b57\u7b26\u4e32 string strValue = \"123abc\"; // \u8fdb\u884c\u5339\u914d bool bValid = regex_match(strValue, rerResult, repPattern); if (bValid) { // \u5339\u914d\u6210\u529f } 3.2 \u793a\u4f8b\u4e8c #include <bits/stdc++.h> using namespace std; regex r(\"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5]):(\\\\d|[1-9]\\\\d{1,3}|[1-5]\\\\d{4}|6[0-4]\\\\d{3}|65[0-4]\\\\d{2}|655[0-2]\\\\d|6553[0-5])\"); int main() { String a; cin >> a; if (!regex_match(b, r)) puts(\"No\"); else puts(\"Yes\"); } 4.\u5e38\u7528\u7684\u6b63\u5219\u8868\u8fbe\u5f0f 4.1 \u68c0\u9a8c\u6570\u5b57\u7684\u8868\u8fbe\u5f0f \u6570\u5b57 : ^[0-9]*$ n \u4f4d\u7684\u6570\u5b57 : ^\\d{n}$ \u81f3\u5c11 n \u4f4d\u7684\u6570\u5b57 : ^\\d{n,}$ m-n \u4f4d\u7684\u6570\u5b57 : ^\\d{m,n}$ \u96f6\u548c\u975e\u96f6\u5f00\u5934\u7684\u6570\u5b57 : ^(0|[1-9][0-9]*)$ \u975e\u96f6\u5f00\u5934\u7684\u6700\u591a\u5e26\u4e24\u4f4d\u5c0f\u6570\u7684\u6570\u5b57 : ^([1-9][0-9]*)+(.[0-9]{1,2})?$ \u5e26 1~2 \u4f4d\u5c0f\u6570\u7684\u6b63\u6570\u6216\u8d1f\u6570 : ^(\\-)?\\d+(\\.\\d{1,2})?$ \u6b63\u6570 , \u8d1f\u6570 , \u548c\u5c0f\u6570 : ^(\\-|\\+)?\\d+(\\.\\d+)?$ \u6709\u4e24\u4f4d\u5c0f\u6570\u7684\u6b63\u5b9e\u6570 : ^[0-9]+(.[0-9]{2})?$ \u6709 1~3 \u4f4d\u5c0f\u6570\u7684\u6b63\u5b9e\u6570 : ^[0-9]+(.[0-9]{1,3})?$ \u975e\u96f6\u7684\u6b63\u6574\u6570 : ^[1-9]\\d*$ \u6216 ^([1-9][0-9]*){1,3}$ \u6216 ^\\+?[1-9][0-9]*$ \u975e\u96f6\u7684\u8d1f\u6574\u6570 : ^\\-[1-9][]0-9\u2033*$ \u6216 ^-[1-9]\\d*$ \u975e\u8d1f\u6574\u6570 : ^\\d+$ \u6216 ^[1-9]\\d*|0$ \u975e\u6b63\u6574\u6570 : ^-[1-9]\\d*|0$ \u6216 ^((-\\d+)|(0+))$ \u975e\u8d1f\u6d6e\u70b9\u6570 : ^\\d+(\\.\\d+)?$ \u6216 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ \u975e\u6b63\u6d6e\u70b9\u6570 : ^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ \u6216 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ \u6b63\u6d6e\u70b9\u6570 : ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ \u6216 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ \u8d1f\u6d6e\u70b9\u6570 : ^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ \u6216 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ \u6d6e\u70b9\u6570 : ^(-?\\d+)(\\.\\d+)?$ \u6216 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 4.2 \u68c0\u9a8c\u5b57\u7b26\u7684\u8868\u8fbe\u5f0f \u6c49\u5b57 : ^[\\u4e00-\\u9fa5]{0,}$ \u82f1\u6587\u548c\u6570\u5b57 : ^[A-Za-z0-9]+$ \u6216 ^[A-Za-z0-9]{4,40}$ \u957f\u5ea6\u4e3a 3~20 \u7684\u6240\u6709\u5b57\u7b26 : ^.{3,20}$ \u7531 26 \u4e2a\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32 : ^[A-Za-z]+$ \u7531 26 \u4e2a\u5927\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32 : ^[A-Z]+$ \u7531 26 \u4e2a\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32 : ^[a-z]+$ \u7531\u6570\u5b57\u548c 26 \u4e2a\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32 : ^[A-Za-z0-9]+$ \u7531\u6570\u5b57 , 26 \u4e2a\u82f1\u6587\u5b57\u6bcd\u6216\u8005\u4e0b\u5212\u7ebf\u7ec4\u6210\u7684\u5b57\u7b26\u4e32 : ^\\w+$ \u6216 ^\\w{3,20}$ \u4e2d\u6587 , \u82f1\u6587 , \u6570\u5b57\u5305\u62ec\u4e0b\u5212\u7ebf : ^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ \u4e2d\u6587 , \u82f1\u6587 , \u6570\u5b57\u4f46\u4e0d\u5305\u62ec\u4e0b\u5212\u7ebf\u7b49\u7b26\u53f7 : ^[\\u4E00-\\u9FA5A-Za-z0-9]+$ \u6216 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ \u53ef\u4ee5\u8f93\u5165\u542b\u6709^%&',;=?$\\\"\u7b49\u5b57\u7b26 : [^%&',;=?$\\x22]+ \u7981\u6b62\u8f93\u5165\u542b\u6709 ~ \u7684\u5b57\u7b26 : [^~\\x22]+ 4.3 \u7279\u6b8a\u9700\u6c42\u8868\u8fbe\u5f0f Email \u5730\u5740 : ^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ \u57df\u540d : [a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL : [a-zA-z]+://[^\\s]* \u6216 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$ \u624b\u673a\u53f7\u7801 : ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ \u7535\u8bdd\u53f7\u7801(\"XXX-XXXXXXX\" , \"XXXX-XXXXXXXX\" , \"XXX-XXXXXXX\" , \"XXX-XXXXXXXX\" , \"XXXXXXX\"\u548c\"XXXXXXXX) : ^($$\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ \u56fd\u5185\u7535\u8bdd\u53f7\u7801 (0511-4405222 , 021-87888822) : \\d{3}-\\d{8}|\\d{4}-\\d{7} \u8eab\u4efd\u8bc1\u53f7 (15 \u4f4d , 18 \u4f4d\u6570\u5b57) : ^\\d{15}|\\d{18}$ \u77ed\u8eab\u4efd\u8bc1\u53f7\u7801 (\u6570\u5b57 , \u5b57\u6bcd x \u7ed3\u5c3e) : ^([0-9]){7,18}(x|X)?$ \u6216 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ \u5e10\u53f7\u662f\u5426\u5408\u6cd5(\u5b57\u6bcd\u5f00\u5934\uff0c\u5141\u8bb8 5~16 \u5b57\u8282\uff0c\u5141\u8bb8\u5b57\u6bcd\u6570\u5b57\u4e0b\u5212\u7ebf) : ^[a-zA-Z][a-zA-Z0-9_]{4,15}$ \u5bc6\u7801 (\u4ee5\u5b57\u6bcd\u5f00\u5934\uff0c\u957f\u5ea6\u5728 6~18 \u4e4b\u95f4\uff0c\u53ea\u80fd\u5305\u542b\u5b57\u6bcd , \u6570\u5b57\u548c\u4e0b\u5212\u7ebf) : ^[a-zA-Z]\\w{5,17}$ \u5f3a\u5bc6\u7801 (\u5fc5\u987b\u5305\u542b\u5927\u5c0f\u5199\u5b57\u6bcd\u548c\u6570\u5b57\u7684\u7ec4\u5408\uff0c\u4e0d\u80fd\u4f7f\u7528\u7279\u6b8a\u5b57\u7b26\uff0c\u957f\u5ea6\u5728 8~10 \u4e4b\u95f4) : ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ \u65e5\u671f\u683c\u5f0f : ^\\d{4}-\\d{1,2}-\\d{1,2} \u4e00\u5e74\u7684 12 \u4e2a\u6708(01\uff5e09\u548c1\uff5e12) : ^(0?[1-9]|1[0-2])$ \u4e00\u4e2a\u6708\u7684 31 \u5929(01\uff5e09\u548c1\uff5e31) : ^((0?[1-9])|((1|2)[0-9])|30|31)$","title":"\u6b63\u5219\u8868\u8fbe\u5f0f"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_24","text":"","title":"\u6570\u8bba"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_25","text":"\u4ee3\u7801\u5b9e\u73b0\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n , ans = 0 ; scanf ( \"%lld\" , & n ); for ( ll l = 1 , r ; l <= n ; l = r + 1 ) { r = n / ( n / l ); ans += ( r - l + 1 ) * ( n / l ); } printf ( \"%lld \\n \" , ans ); }","title":"\u6574\u6570\u5206\u5757"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_26","text":"///\u53c2\u7167\u4e8e\uff1a //https://www.luogu.com.cn/blog/SuuTTT/solution%2Dp1029 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; const ll maxn = 1e7 + 5 ; ll low_prime [ 10050000 ] = { 0 }; ll prime [ 700500 ] = { 0 }; ll cnt = 0 ; int main () { for ( ll i = 2 ; i <= maxn ; i ++ ) { if ( low_prime [ i ] == 0 ) { low_prime [ i ] = i ; prime [ ++ cnt ] = i ; } for ( ll j = 1 ; j <= cnt && prime [ j ] * i <= maxn ; j ++ ) { low_prime [ prime [ j ] * i ] = prime [ j ]; if ( i % prime [ j ] == 0 ) break ; } } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , flag = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { ll m , sum = 0 ; scanf ( \"%lld\" , & m ); while ( m > 1 ) { m /= low_prime [ m ]; sum ++ ; } flag ^= sum ; ///sum\u5373\u4e3a\u8d28\u56e0\u6570\u7684\u4e2a\u6570 } if ( ! flag ) puts ( \"Bob\" ); else puts ( \"Alice\" ); } }","title":"\u7ebf\u6027\u7b5b\u6c42\u8d28\u56e0\u6570\u7684\u4e2a\u6570"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_27","text":"#include <bits/stdc++.h> using namespace std ; int is_prime [ 100500 ] = { 0 }; vector < int > prime ; int oula_table [ 100500 ] = { 0 }; void init ( int n ) ///\u6253\u7d20\u6570\u8868 { for ( int i = 2 ; i <= n ; i ++ ) { if ( ! is_prime [ i ]) prime . push_back ( i ); for ( int j = 0 ; j <= prime . size () && i * prime [ j ] <= n ; j ++ ) { is_prime [ i * prime [ j ]] = 1 ; if ( i % prime [ j ] == 0 ) break ; } } } int oula1 ( int n ) ///\u6839\u636e\u7d20\u6570\u8868\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int ans = n ; for ( int i = 0 ; prime [ i ] * prime [ i ] <= n ; i ++ ) { if ( n % prime [ i ] == 0 ) ans = ans - ans / prime [ i ]; while ( n % prime [ i ] == 0 ) n /= prime [ i ]; } return ans ; } int oula2 ( int n ) ///\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int m = n ; int ans = n ; for ( int i = 2 ; i <= sqrt ( n ); i ++ ) { if ( m % i == 0 ) ans = ans - ans / i ; while ( m % i == 0 ) m /= i ; } if ( m != 1 ) ans = ans - ans / m ; return ans ; } void get_oula_table ( int n ) ///\u6b27\u62c9\u6253\u8868 { for ( int i = 1 ; i <= n ; i ++ ) oula_table [ i ] = 0 ; oula_table [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! oula_table [ i ]) ///\u8bf4\u660ei\u662f\u8d28\u6570 { for ( int j = i ; j <= n ; j += i ) //\u53bb\u627ei\u7684\u500d\u6570 { if ( ! oula_table [ j ]) oula_table [ j ] = j ; oula_table [ j ] = oula_table [ j ] / i * ( i -1 ); } } } } int main () { int n ; cin >> n ; init ( n ); cout << \"\u627e\u7d20\u6570\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula1 ( n ) << endl ; cout << \"\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula2 ( n ) << endl ; get_oula_table ( n ); cout << \"\u6253\u8868\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" ; for ( int i = 1 ; i <= n ; i ++ ) cout << oula_table [ i ] << ' ' ; }","title":"\u6b27\u62c9\u51fd\u6570\u6a21\u677f"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_28","text":"#include <iostream> #include <bits/stdc++.h> using namespace std ; int a [ 2005000 ] = { 0 }; int b [ 2005000 ] = { 0 }; long long int merge_sort ( long long int l , long long int r ) { if ( l >= r ) return 0 ; long long int mid = ( l + r ) >> 1 , res = 0 ; res += merge_sort ( l , mid ); res += merge_sort ( mid + 1 , r ); long long int i = l , j = mid + 1 , cnt = 0 ; while ( i <= mid && j <= r ) if ( a [ i ] <= a [ j ]) b [ cnt ++ ] = a [ i ++ ]; else { res += mid - i + 1 ; b [ cnt ++ ] = a [ j ++ ]; } while ( i <= mid ) b [ cnt ++ ] = a [ i ++ ]; while ( j <= r ) b [ cnt ++ ] = a [ j ++ ]; for ( long long int i = l , j = 0 ; j < cnt ; ++ i , ++ j ) a [ i ] = b [ j ]; return res ; } int main () { int n ; cin >> n ; for ( long long int i = 0 ; i < n ; i ++ ) { cin >> a [ i ]; } long long int sum = merge_sort ( 0 , n -1 ); cout << sum << endl ; return 0 ; } #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n , m ; ll a [ 100500 ] = { 0 }; ll c [ 100500 ] = { 0 }; ll maxn = 10050 , k , ans = 0 ; ll lowbit ( ll x ) { return x & ( - x ); } ll add ( ll k , ll x ) { for ( ll i = k ; i <= maxn ; i += lowbit ( i )) c [ i ] += x ; } ll getsum ( ll k ) { ll ans = 0 ; for ( ll i = k ; i >= 1 ; i -= lowbit ( i )) ans += c [ i ]; return ans ; } int main () { scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & k ); add ( k , 1 ); ans += i - getsum ( k ); } printf ( \"%d \\n \" , ans ); }","title":"\u9006\u5e8f\u5bf9"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_29","text":"#include <bits/stdc++.h> using namespace std ; const int maxn = 5010 ; int g [ maxn ][ maxn ]; int main ( void ) { int N , R ; cin >> N >> R ; int n = R , m = R ; for ( int i = 0 , x , y , w ; i < N ; ++ i ) { cin >> x >> y >> w ; x ++ , y ++ ; n = max ( n , x ); m = max ( m , y ); g [ x ][ y ] += w ; } for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) g [ i ][ j ] += g [ i -1 ][ j ] + g [ i ][ j -1 ] - g [ i -1 ][ j -1 ]; int ans = 0 ; for ( int i = R ; i <= n ; i ++ ) for ( int j = R ; j <= m ; j ++ ) ans = max ( ans , g [ i ][ j ] - g [ i - R ][ j ] - g [ i ][ j - R ] + g [ i - R ][ j - R ]); cout << ans ; return 0 ; }","title":"\u4e8c\u7ef4\u524d\u7f00\u548c"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_30","text":"\u6c42\u89e3$a * x + b * y = gcd(a,b) $\u65b9\u7a0b\u7684\u901a\u89e3x\u548cy #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll N = 1e9 + 7 ; ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll d = exgcd ( b , a % b , x , y ); ll t = x ; x = y ; y = t - ( a / b ) * y ; return d ; } int main () { ll a = 3 , b = 5 , x = 0 , y = 0 ; ll g = exgcd ( a , b , x , y ); cout << \"\u7279\u89e3\u4e3a\" << \"x=\" << x << \",y=\" << y << endl ; for ( int i = 1 ; i <= 5 ; i ++ ) { x += b / g ; y -= a / g ; cout << \"\u901a\u89e3\u4e3a\" << \"x=\" << x << \",y=\" << y << endl ; } return 0 ; } \u6c42\u89e3\u4e00\u822c\u65b9\u7a0b a * x+b * y=c a * x+b * y=c \u7684\u901a\u89e3x\u548cy \u5c06\u65b9\u7a0b\u8f6c\u53d8\u4e3a\uff1a a * x+b * y=gcd(a, b) * c/gcd(a, b); a * x+b * y=gcd(a, b) * c/gcd(a, b); \u6700\u7ec8\u5373\u4e3a\uff1a a * x/(c/gcd(a, b))+b * y/(c/gcd(a, b))=gcd(a, b); a * x/(c/gcd(a, b))+b * y/(c/gcd(a, b))=gcd(a, b); \u5373\u628a\u7ed3\u679c\u8c03\u6574\u4e3a\uff1a x1=x0 * c/gcd(a, b); y1=y0 * c/gcd(a, b); x1=x0 * c/gcd(a, b); y1=y0 * c/gcd(a, b); #include <stdio.h> long long exgcd ( long long a , long long b , long long & x , long long & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } long long r = exgcd ( b , a % b , x , y ), t ; t = x ; x = y ; y = t - ( a / b ) * y ; return r ; } int main () { long long a , b , c , ans , x , y ; while ( scanf ( \"%lld%lld%lld\" , & a , & b , & c ) != EOF ) { ans = exgcd ( a , b , x , y ); if ( c % ans == 0 ) { x =- x * c / ans ; y =- y * c / ans ; printf ( \"%lld %lld \\n \" , x , y ); } else printf ( \"-1 \\n \" ); } return 0 ; }","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u7406"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_31","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a , q ; ll ksm ( ll n , ll k ) { ll sum1 = 1 , sum2 = n ; while ( k != 0 ) { if ( k % 2 == 1 ) sum1 = sum1 * sum2 % q ; sum2 = sum2 * sum2 % q ; k /= 2 ; } return sum1 ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; cin >> a >> q ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << ksm ( a , q -2 ) << endl ; } #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll exgcd ( ll a , ll b , ll & x , ll & y ) ///\u540e\u4e24\u4e2a\u53c2\u6570\u4e3a\u5f15\u7528 { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll gcd_ans = exgcd ( b , a % b , x , y ); ll tem = x ; x = y ; y = tem - a / b * y ; return gcd_ans ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; ll a , q , x = 0 , y = 0 ; cin >> a >> q ; ll gcd_ans = exgcd ( q , a , x , y ); ll mul = q / gcd_ans ; y = ( y % mul + mul ) % mul ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << y << endl ; }","title":"\u9006\u5143"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_32","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; stack < char > sc ; stack < ll > sll ; char a [ 100500 ] = { 0 }; inline ll qpow ( ll a , ll b ) { ll ans = 1 ; while ( b ) { if ( b & 1 ) ans *= a ; a *= a , b >>= 1 ; } return ans ; } int cmp1 ( char a1 , char a2 ) { if ( a2 == '(' ) return -1 ; if ( a2 == ')' ) { if ( a1 == '(' ) return 0 ; else if ( a1 == '#' ) return 0 ; else return 1 ; } if ( a2 == '+' || a2 == '-' ) { if ( a1 == '+' || a1 == '-' || a1 == '*' || a1 == '/' || a1 == '^' ) return 1 ; else return -1 ; } if ( a2 == '*' || a2 == '/' ) { if ( a1 == '*' || a1 == '/' || a1 == '^' ) return 1 ; else return -1 ; } if ( a2 == '^' ) { if ( a1 == '^' ) return 1 ; else return -1 ; } if ( a2 == '#' ) { if ( a1 == '#' ) return 0 ; else if ( a1 == '(' || a1 == ')' ) return 0 ; else return 1 ; } return 0 ; } int main () { scanf ( \"%s\" , a + 1 ); a [ strlen ( a + 1 ) + 1 ] = '#' ; ll tem = 0 , tem2 , tem1 ; sll . push ( 0 ); sc . push ( '#' ); for ( int i = 1 ; a [ i ]; i ++ ) { if ( a [ i ] <= '9' && a [ i ] >= '0' ) { tem = tem * 10 + a [ i ] - '0' ; if ( a [ i + 1 ] < '0' || a [ i + 1 ] > '9' ) sll . push ( tem ), tem = 0 ; } else { while ( ! sc . empty ()) { ll tem_cmp = cmp1 ( sc . top (), a [ i ]); if ( tem_cmp == 1 ) { tem2 = sll . top (); sll . pop (); tem1 = sll . top (); sll . pop (); if ( sc . top () == '+' ) sll . push ( tem1 + tem2 ); else if ( sc . top () == '-' ) sll . push ( tem1 - tem2 ); else if ( sc . top () == '*' ) sll . push ( tem1 * tem2 ); else if ( sc . top () == '/' ) sll . push ( tem1 / tem2 ); else if ( sc . top () == '^' ) sll . push (( ll ) qpow ( tem1 , tem2 )); sc . pop (); } else if ( tem_cmp == 0 ) { if ( a [ i ] != ')' || ( a [ i ] == ')' && sc . size () > 1 )) sc . pop (); break ; } else if ( tem_cmp == -1 ) { sc . push ( a [ i ]); break ; } } } } cout << sll . top () << endl ; }","title":"\u8868\u8fbe\u5f0f\u6c42\u503c\uff08\u4e2d\u7f00\u8868\u8fbe\u5f0f\u8f6c\u540e\u7f00\u8868\u8fbe\u5f0f\uff09"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_33","text":"\u53c2\u8003\u535a\u5ba2\uff1a https://blog.csdn.net/Luoxiaobaia/article/details/107593528 1.\u7403\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u4e0d\u80fd\u7a7a\uff08\u9694\u677f\u6cd5\uff09 \u4e00\u5171\u6709n-1\u4e2a\u7a7a\u9699(\u603b\u5171n+1\u4e2a\u7a7a\u9699\uff0c\u4e0d\u80fd\u7a7a\u8981\u53bb\u6389\u5934\u5c3e=n-1) \uff0c\u8981\u63d2m-1\u4e2a\u677f\uff0c\u7b54\u6848\u4e3a C_{n-1}^{m-1} C_{n-1}^{m-1} \u200b 2.\u7403\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u80fd\u7a7a \u5982\u679c\u7ed9\u6bcf\u4e2a\u76d2\u5b50\u4e00\u4e2a\u7403\uff0c\u5c31\u53ef\u4ee5\u628a\u95ee\u9898\u8f6c\u5316\u4e3a\u4e0d\u80fd\u7a7a\u7684\u60c5\u51b5\u4e86,\u5c31\u76f8\u5f53\u4e8en+m\u4e2a\u5c0f\u7403\u653e\u5165m\u4e2a\u76d2\u5b50\u4e14\u4e0d\u80fd\u7a7a\uff0c\u7b54\u6848\u5c31\u662f C_{n+m-1}^{m-1} C_{n+m-1}^{m-1} 3.\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u80fd\u7a7a\uff08dp\u95ee\u9898\uff09 dp[n][m]\u4ee3\u8868n\u4e2a\u5c0f\u7403\u653e\u5165m\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u4e14\u4e0d\u80fd\u7a7a\u7684\u65b9\u6cd5 \u5f53 i >= 0 \u65f6\uff0cdp[i][i]=1 (i\u4e2a\u5c0f\u7403\u653e\u5165i\u4e2a\u76d2\u5b50\uff0c\u5c31\u53ea\u80fd1\u4e2a\u76d2\u5b50\u653e1\u4e2a) \u5f53 i > 0 \u65f6,dp[i][0]=0(\u90fd\u6ca1\u6709\u76d2\u5b50\u4e86\uff0c\u80af\u5b9a\u65e0\u89e3) dp[i][j] = j * dp[i-1][j] + dp[i-1][j-1] (\u7b2ci\u4e2a\u7403\u53ef\u4ee5\u653e\u5728\u5df2\u7ecf\u6709\u7684j\u4e2a\u76d2\u5b50\u7684\u4e00\u4e2a\uff0c\u6709j\u79cd\u65b9\u6cd5,\u4e5f\u5c31\u662fj*dp[i-1][j], \u4e5f\u53ef\u4ee5\u662f\u653e\u5165\u4e00\u4e2a\u65b0\u7684\u76d2\u5b50,\u5c31\u662fdp[i-1][j-1]) \u6240\u4ee5\u7b54\u6848\u5982\u4e0b\uff1a 4.\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a\uff08\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\uff09 \u90a3\u5c31\u662f3\u7684\u60c5\u51b5(\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u5141\u8bb8\u4e3a\u7a7a)\u75281\u4e2a\u76d2\u5b50+\u75282\u4e2a\u76d2\u5b50+\u2026+m\u4e2a\u76d2\u5b50 5.\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u4e0d\u80fd\u7a7a \u90a3\u5c31\u662f3\u7684\u60c5\u51b5(\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u5141\u8bb8\u4e3a\u7a7a)\u5bf9\u76d2\u5b50\u8fdb\u884c\u5168\u6392\u5217 \u7b54\u6848\u5c31\u662f m!*dp[n][m] (dp[n][m]\u662f\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570) 6.\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u53ef\u4ee5\u7a7a \u6bcf\u4e00\u4e2a\u5c0f\u7403\u90fd\u6709m\u79cd\u65b9\u6cd5\uff0c\u4e14\u76f8\u4e92\u72ec\u7acb\uff0c\u7b54\u6848\u5c31\u662f m^n m^n 7.\u7403\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a\uff08dp\u95ee\u9898\uff09 dp[i][j]\u4ee3\u8868\u7403\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a\u7684\u653e\u6cd5 \u5f53 i>=j \u65f6\uff0cdp[i][j] = dp[i][j-1]+dp[i-j][j] ( \u6211\u4eec\u53ef\u4ee5\u5728\u6240\u6709\u7684\u76d2\u5b50\u4e0a\u653e\u4e00\u4e2a\u7403dp[i-j][j]\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u9009\u62e9\u8fd9\u79cd\u64cd\u4f5c\uff0c\u4f46\u662f\u4ee5\u540e\u90fd\u4e0d\u5bf9\u5176\u4e2d\u4e00\u4e2a\u76d2\u5b50\u8fdb\u884c\u64cd\u4f5c\u4e86\uff0c\u90a3\u5c31\u662fdp[i][j-1] ) \u5f53 i<j \u65f6\uff0cdp[i][i] (\u591a\u4f59\u7684\u76d2\u5b50\u90fd\u6ca1\u6709\u4ec0\u4e48\u5375\u7528\u4e86) \u5f53 j=1 \u65f6\uff0c1(\u53ea\u6709\u4e00\u4e2a\u76d2\u5b50\u4e86\u5c31\u53ea\u80fd\u653e\u5728\u90a3\u4e2a\u76d2\u5b50\u4e86\uff0c\u53ea\u6709\u4e00\u79cd\u653e\u6cd5) \u5f53 i=1 \u65f6\uff0c1(\u53ea\u6709\u4e00\u4e2a\u7403\u4e86\uff0c\u653e\u54ea\u4e2a\u76d2\u5b50\u90fd\u4e00\u6837\uff0c\u53ea\u6709\u4e00\u79cd\u653e\u6cd5) \u5f53 i=0 \u65f6 1(\u6ca1\u6709\u7403\u4e86\uff0c\u4e5f\u662f1\u79cd\u65b9\u6cd5) \u7b54\u6848\u662f 8.\u7403\u540c\uff0c\u76d2\u540c\uff0c\u4e0d\u80fd\u7a7a \u90a3\u5c31\u662f7\u7684\u60c5\u51b5(\u7403\u540c\uff0c\u76d2\u540c\uff0c\u53ef\u4ee5\u7a7a)\u6bcf\u4e2a\u76d2\u5b50\u5148\u653e\u4e00\u4e2a\u4fdd\u8bc1\u4e0d\u7a7a \u6240\u4ee5\u7b54\u6848\u662f dp[n-m][m] (n>=m) 0 (n<m) \u5176\u4e2ddp\u662f\u60c5\u51b57\u7684dp \u9644\u60c5\u51b57\u7684\u4ee3\u7801\uff1a #include <iostream> int main () { const int N = 11 ; int dp [ N ][ N ] = {}, t , n , m ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 1 ; j < N ; ++ j ) { if ( i <= 1 || j == 1 ) dp [ i ][ j ] = 1 ; else if ( i < j ) dp [ i ][ j ] = dp [ i ][ i ]; else dp [ i ][ j ] = dp [ i ][ j -1 ] + dp [ i - j ][ j ]; } scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & m ); printf ( \"%d \\n \" , dp [ n ][ m ]); } return 0 ; }","title":"\u7ec4\u5408\u6570\u5b66"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_34","text":"\u53c2\u7167\u535a\u5ba2\uff1a https://zhuanlan.zhihu.com/p/97619085 \u5361\u7279\u5170\u6570\uff08Catalan number\uff09\u662f \u7ec4\u5408\u6570\u5b66 \u4e2d\u4e00\u4e2a\u5e38\u51fa\u73b0\u5728\u5404\u79cd \u8ba1\u6570\u95ee\u9898 \u4e2d\u7684 \u6570\u5217 \u3002 \u6570\u5217\u7684\u524d\u51e0\u9879\u4e3a\uff1a1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862\uff0c... \u5361\u7279\u5170\u6570\u516c\u5f0f\uff1a \u7535\u5f71\u8d2d\u7968\u95ee\u9898 \u7535\u5f71\u7968\u4e00\u5f20 50 coin\uff0c\u4e14\u552e\u7968\u5385\u6ca1\u6709 coin\u3002m \u4e2a\u4eba\u5404\u81ea\u6301\u6709 50 coin\uff0cn \u4e2a\u4eba\u5404\u81ea\u6301\u6709 100 coin\u3002 \u5219\u6709\u591a\u5c11\u79cd\u6392\u961f\u65b9\u5f0f\uff0c\u53ef\u4ee5\u8ba9\u6bcf\u4e2a\u4eba\u90fd\u4e70\u5230\u7535\u5f71\u7968\u3002 \u601d\u8def \u6301\u6709 50 coin \u7684\u4eba\u6bcf\u6b21\u8d2d\u7968\u65f6\u4e0d\u9700\u8981\u627e\u96f6\uff0c\u5e76\u4e14\u53ef\u4ee5\u5e2e\u52a9\u540e\u9762\u6301\u6709 100 coin \u7684\u4eba\u627e\u96f6\uff1b\u800c\u5bf9\u4e8e\u6301\u6709 100 coin \u7684\u4eba\u6bcf\u6b21\u8d2d\u7968\u65f6\u9700\u8981\u627e\u96f6\uff0c\u4f46 100 coin \u5bf9\u540e\u9762\u7684\u627e\u96f6\u6ca1\u6709\u4efb\u4f55\u4f5c\u7528\u3002 \u56e0\u6b64\uff0c\u76f8\u5f53\u4e8e\u6bcf\u4e2a\u6301\u6709 100 coin \u7684\u4eba\u90fd\u9700\u8981\u548c\u4e00\u4e2a\u6301\u6709 50 coin \u7684\u4eba\u8fdb\u884c\u5339\u914d\u3002\u6211\u4eec\u5c06\u6301\u6709 50 coin \u7684\u6807\u8bb0\u4e3a +1\uff0c\u6301\u6709 100 coin \u7684\u6807\u8bb0\u4e3a -1\uff0c\u6b64\u65f6\u53c8\u56de\u5230\u4e86\u8fdb\u51fa\u6808\u95ee\u9898\u3002 \u4e0d\u540c\u7684\u662f\uff0cm \u5e76\u4e00\u5b9a\u7b49\u4e8e n\uff0c\u4e14\u6392\u961f\u5e8f\u5217\u662f\u4e00\u79cd\u6392\u5217\uff0c\u9700\u8981\u8003\u8651\u5148\u540e\u987a\u5e8f\uff0c\u4f8b\u5982\u5404\u81ea\u6301\u6709 50 coin \u7684\u7532\u548c\u4e59\u7684\u524d\u540e\u5173\u7cfb\u4f1a\u9020\u6210\u4e24\u79cd\u4e0d\u540c\u7684\u6392\u961f\u5e8f\u5217\u3002\u6240\u4ee5\uff0c\u5c06\u4f1a\u6709 \u7b2c\u4e8c\u9879\u4e3a\u4ec0\u4e48\u662f \uff0c\u5176\u5b9e\u5f88\u7b80\u5355\uff0c\u6211\u4eec\u6bcf\u6b21\u628a\u7b2c\u4e00\u4e2a\u524d\u7f00\u5c0f\u4e8e0 \u7684\u524d\u7f00\u53d6\u53cd\u540e\uff0c\u4f1a\u9020\u6210 +1 \u591a\u4e86\u4e00\u4e2a\u800c -1 \u5c11\u4e86\u4e00\u4e2a\u3002\u8fd9\u91cc +1 \u6709 m \u4e2a\uff0c-1 \u6709 n \u4e2a\uff0c\u53d6\u53cd\u540e +1 \u53d8\u6210 m + 1 \u4e2a\uff0c-1 \u53d8\u6210 n - 1 \u4e2a\uff0c\u603b\u548c\u4e0d\u53d8\u3002 const int C_maxn = 1e4 + 10 ; ll CatalanNum [ C_maxn ]; ll inv [ C_maxn ]; inline void Catalan_Mod ( int N , LL mod ) { inv [ 1 ] = 1 ; for ( int i = 2 ; i <= N + 1 ; i ++ ) ///\u7ebf\u6027\u9884\u5904\u7406 1 ~ N \u5173\u4e8e mod \u7684\u9006\u5143 inv [ i ] = ( mod - mod / i ) * inv [ mod % i ] % mod ; CatalanNum [ 0 ] = CatalanNum [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) CatalanNum [ i ] = CatalanNum [ i - 1 ] * ( 4 * i - 2 ) % mod * inv [ i + 1 ] % mod ; }","title":"\u5361\u7279\u5170\u6570"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_35","text":"\u79ef\u6027\u51fd\u6570\u662f\u6307\u5bf9\u4e8e\u4efb\u610f\u4e92\u8d28\u7684\u6574\u6570a\u548cb\u6709\u6027\u8d28f(ab)=f(a)f(b)\u7684\u6570\u8bba\u51fd\u6570 \u5e38\u7528\u79ef\u6027\u51fd\u6570\u6709\uff1a \u03c6(n) \uff0d\u6b27\u62c9\u51fd\u6570 \u03bc(n) \uff0d\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\uff0c\u5173\u4e8e\u975e\u5e73\u65b9\u6570\u7684\u8d28\u56e0\u5b50\u6570\u76ee gcd(n,k) \uff0d\u6700\u5927\u516c\u56e0\u5b50\uff0c\u5f53k\u56fa\u5b9a\u7684\u60c5\u51b5 d(n) \uff0dn\u7684\u6b63\u56e0\u5b50\u6570\u76ee \u03c3(n) \uff0dn\u7684\u6240\u6709\u6b63\u56e0\u5b50\u4e4b\u548c","title":"\u79ef\u6027\u51fd\u6570"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_36","text":"\u53c2\u8003\u4e8e https://zhuanlan.zhihu.com/p/45744228 \u51fd\u6570\u5b9a\u4e49 \u8f85\u52a9\u5b9a\u7406 \u5bf9\u4e8e\u4efb\u610f\u6b63\u6574\u6570 \uff0c\u6052\u6709 \u5176\u6b21\uff0c\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u548c\u6b27\u62c9\u51fd\u6570\u7684\u5173\u7cfb\uff1a \\sum_{d|n}\\frac{\\mu[d]}{d}=\\frac{\\varphi(n)}{n} \\sum_{d|n}\\frac{\\mu[d]}{d}=\\frac{\\varphi(n)}{n} \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u5b9a\u7406 \u548c \u662f\u5b9a\u4e49\u5728\u6b63\u6574\u6570\u96c6\u5408\u4e0a\u7684\u4e24\u4e2a\u51fd\u6570\uff0c\u82e5 \u5219 \u53cd\u4e4b\u4ea6\u7136. \u8bc1\u660e\uff1a \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u5b9e\u9645\u4e0a\u662f\u5bb9\u65a5\u3002 \u5e38\u89c1\u53cd\u6f14 1\u3001 \u6240\u4ee5\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\u672c\u8eab\u4e5f\u53ef\u4ee5\u53cd\u6f14\u3002 2\u3001 \u7ebf\u6027\u9884\u5904\u7406 \u6c42\u89e3\u533a\u95f4 \u548c\u533a\u95f4 \u4e0a\u4e92\u8d28\u7684\u6570\u7684\u4e2a\u6570\u3002 \u4ee3\u7801 void get_mu ( int n ) { mu [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! vis [ i ]){ prim [ ++ cnt ] = i ; mu [ i ] = -1 ;} for ( int j = 1 ; j <= cnt && prim [ j ] * i <= n ; j ++ ) { vis [ prim [ j ] * i ] = 1 ; if ( i % prim [ j ] == 0 ) break ; else mu [ i * prim [ j ]] =- mu [ i ]; } } }","title":"\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#fftnnt","text":"\u53c2\u8003\u94fe\u63a5\uff1a https://www.acwing.com/file_system/file/content/whole/index/content/1563813/ https://blog.csdn.net/hzf0701/article/details/119428159 https://blog.csdn.net/zz_1215/article/details/40430041 https://www.luogu.com.cn/problem/P3803 NTT \u5feb\u901f\u6570\u8bba\u53d8\u6362\u53d6\u6a21\u591a\u9879\u5f0f\u6a21\u677f #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; const ll G = 3 ; ll n , m , L , R [ 6005000 ] = { 0 }; ll a [ 6005000 ] = { 0 }, b [ 6005000 ] = { 0 }, inv [ 6005000 ] = { 0 }; ll qpow ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ans1 * ans2 % mod ; ans2 = ans2 * ans2 % mod ; b /= 2 ; } return ans1 % mod ; } void NTT ( ll * a , ll f ) { for ( ll i = 0 ; i < n ; i ++ ) { if ( i < R [ i ]) swap ( a [ i ], a [ R [ i ]]); } for ( ll i = 1 ; i < n ; i <<= 1 ) { ll gn = qpow ( G , ( mod - 1 ) / ( i << 1 )); for ( ll j = 0 ; j < n ; j += ( i << 1 )) { ll g = 1 ; for ( ll k = 0 ; k < i ; k ++ , g = g * gn % mod ) { ll x = a [ j + k ], y = g * a [ j + k + i ] % mod ; a [ j + k ] = ( x + y ) % mod ; a [ j + k + i ] = ( x - y + mod ) % mod ; } } } if ( f == 1 ) return ; ll inv = qpow ( n , mod - 2 ); reverse ( a + 1 , a + n ); for ( ll i = 0 ; i < n ; i ++ ) a [ i ] = 1l l * a [ i ] * inv % mod ; } void solve ( ll * A , ll * B ) { m = n + m ; for ( n = 1 ; n <= m ; n <<= 1 ) L ++ ; for ( int i = 0 ; i < n ; i ++ ) R [ i ] = ( R [ i >> 1 ] >> 1 ) | (( i & 1 ) << ( L - 1 )); NTT ( A , 1 ); NTT ( B , 1 ); for ( int i = 0 ; i < n ; i ++ ) A [ i ] = ( A [ i ] % mod * B [ i ] % mod + mod ) % mod ; NTT ( A , -1 ); } int main () { scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 0 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); for ( ll i = 0 ; i <= m ; i ++ ) scanf ( \"%lld\" , & b [ i ]); solve ( a , b ); for ( ll i = 0 ; i <= m ; i ++ ) printf ( \"%lld \" , a [ i ]); return 0 ; } FFT\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362\u6a21\u677f #include <bits/stdc++.h> using namespace std ; typedef pair < int , int > pii ; typedef long long ll ; const int N = 6e6 + 10 ; const int P = 1e9 + 7 ; const int INF = 0x3f3f3f3f ; const double PI = acos ( -1.0 ); //\u5706\u5468\u7387PI\u3002 struct Complex { double x , y ; //\u590d\u6570\uff0cx\u4ee3\u8868\u5b9e\u90e8\uff0cy\u4ee3\u8868\u865a\u90e8\u3002 Complex ( double _x = 0 , double _y = 0 ) { x = _x , y = _y ; } } a [ N ], b [ N ]; //\u591a\u9879\u5f0fa\u548cb\uff0c\u76f8\u4e58\u3002 int n , m , l , r [ N ], limit = 1 ; //n\u4e3aa\u7684\u6b21\u6570,m\u4e3ab\u7684\u6b21\u6570\u3002limit\u5373\u4e3a\u6700\u5927\u9650\u5236\u30022^n\u6b21\u65b9\uff0c\u800cl\u4e3a\u4e8c\u8fdb\u5236\u7684\u4f4d\u6570 //\u8fd0\u7b97\u7b26\u91cd\u8f7d\u3002 Complex operator + ( Complex a , Complex b ) { return Complex ( a . x + b . x , a . y + b . y ); } Complex operator - ( Complex a , Complex b ) { return Complex ( a . x - b . x , a . y - b . y ); } //\u590d\u6570\u76f8\u4e58\uff0c\u5219\u6a21\u957f\u76f8\u4e58\uff0c\u5e45\u5ea6\u76f8\u52a0\u3002 Complex operator * ( Complex a , Complex b ) { return Complex ( a . x * b . x - a . y * b . y , a . x * b . y + a . y * b . x ); } void fft ( Complex * A , int type ) { for ( int i = 0 ; i < limit ; ++ i ) { if ( i < r [ i ]) swap ( A [ i ], A [ r [ i ]]); //\u6c42\u51fa\u8981\u8fed\u4ee3\u7684\u533a\u95f4\u3002\u5c0f\u4e8er[i]\u65f6\u624d\u4ea4\u6362\uff0c\u9632\u6b62\u540c\u4e00\u4e2a\u5143\u7d20\u4ea4\u6362\u4e24\u6b21\uff0c\u56de\u5230\u539f\u6765\u7684\u4f4d\u7f6e\u3002 } //\u4ece\u5e95\u5c42\u5f80\u4e0a\u5408\u5e76\u3002 for ( int mid = 1 ; mid < limit ; mid <<= 1 ) { //\u5f85\u5408\u5e76\u533a\u95f4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u6700\u5f00\u59cb\u662f\u4e24\u4e2a\u957f\u5ea6\u4e3a1\u7684\u5e8f\u5217\u5408\u5e76,mid = 1; Complex Wn ( cos ( PI / mid ), type * sin ( PI / mid )); //\u5355\u4f4d\u6839\u3002 for ( int len = mid << 1 , j = 0 ; j < limit ; j += len ) { //len\u662f\u533a\u95f4\u7684\u957f\u5ea6\uff0cj\u662f\u5f53\u524d\u7684\u4f4d\u7f6e\uff0c\u4e5f\u5c31\u662f\u5408\u5e76\u5230\u4e86\u54ea\u4e00\u4f4d\u3002 Complex w ( 1 , 0 ); //\u5e42\uff0c\u4e00\u76f4\u4e58\uff0c\u5f97\u5230\u5e73\u65b9\uff0c\u4e09\u6b21\u65b9\u3002 for ( int k = 0 ; k < mid ; ++ k , w = w * Wn ) { //\u679a\u4e3e\u5de6\u534a\u90e8\u5206\u3002\u8774\u8776\u53d8\u6362\u5f97\u5230\u53f3\u534a\u90e8\u5206\u7684\u7b54\u6848\u3002w\u4e3awn * k Complex x = A [ j + k ], y = w * A [ j + mid + k ]; //\u5de6\u534a\u90e8\u5206\u548c\u53f3\u534a\u90e8\u5206\u3002 A [ j + k ] = x + y ; //\u5de6\u8fb9\u52a0\u3002 A [ j + mid + k ] = x - y ; //\u53f3\u8fb9\u51cf\u3002 } } } if ( type == 1 ) return ; for ( int i = 0 ; i <= limit ; ++ i ) { a [ i ]. x /= limit ; //\u6700\u540e\u9700\u8981\u9664\u4ee5limit\u4e5f\u5c31\u662f\u8865\u6210\u4e862\u7684\u6574\u6570\u5e42\u3002\u5c06\u70b9\u503c\u8f6c\u6362\u4e3a\u7cfb\u6570\u3002 } } void solve () { while ( limit <= n + m ) { limit <<= 1 , l ++ ; } //\u521d\u59cb\u5316r\u6570\u7ec4\u3002 for ( int i = 0 ; i < limit ; ++ i ) { r [ i ] = ( r [ i >> 1 ] >> 1 ) | (( i & 1 ) << ( l - 1 )); } fft ( a , 1 ); //\u5c06a\u7684\u7cfb\u6570\u8f6c\u5316\u4e3a\u70b9\u503c\u8868\u793a\uff0c fft ( b , 1 ); //\u5c06b\u7684\u7cfb\u6570\u8f6c\u5316\u4e3a\u70b9\u503c\u8868\u793a\u3002 for ( int i = 0 ; i <= limit ; ++ i ) { //\u5bf9\u5e94\u9879\u76f8\u4e58\uff0c\u5f97\u5230\u70b9\u503c\u8868\u793a\u7684\u89e3\u3002 a [ i ] = a [ i ] * b [ i ]; } fft ( a , -1 ); for ( int i = 0 ; i <= n + m ; ++ i ) { //\u53d6\u51fa\u6765\u96642\uff0c\u52a0\u4e0a0.5\u56db\u820d\u4e94\u5165\u3002 printf ( \"%d \" , ( int )( a [ i ]. x + 0.5 )); } printf ( \" \\n \" ); } int main () { scanf ( \"%d%d\" , & n , & m ); //\u8bfb\u5165\u591a\u9879\u5f0f\u7684\u6bcf\u4e00\u9879\u3002 for ( int i = 0 ; i <= n ; ++ i ) { scanf ( \"%lf\" , & a [ i ]. x ); } \u00b7 for ( int i = 0 ; i <= m ; ++ i ) { scanf ( \"%lf\" , & b [ i ]. x ); } solve (); return 0 ; }","title":"FFT\u548cNNT\u6a21\u677f"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#meissel-lehmer","text":"\u662f\u4e00\u79cd\u80fd\u5728\u4e9a\u7ebf\u6027\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u6c42\u51fa 1\u223cn\u5185\u8d28\u6570\u4e2a\u6570\u7684\u4e00\u79cd\u7b97\u6cd5\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{\\frac{2}{3}}) O(n^{\\frac{2}{3}}) #include <bits/stdc++.h> using namespace std ; using ll = long long ; //\u901a\u8fc7\u77e5\u9053\u524d\u9762\u7684 n^1/3 \u7684\u8d28\u6570\u53ef\u4ee5\u63a8\u65ad\u540e\u9762n^2/3\u7684\u8d28\u6570\u6240\u4ee5\u53ef\u4ee5\u9002\u5f53\u51cf\u5c0f const int N = 9e3 ; const int M = 2 ; //\u4e3a\u4e86\u51cf\u5c0f\u5185\u5b58\u53ef\u4ee5\u4e0d\u8fc7\u662f\u8d28\u6570 const int PM = 2 * 3 * 5 ; //\u4e3a\u4e86\u51cf\u5c0f\u5185\u5b58\u53ef\u4ee5\u4e0d\u8fc7\u8981\u6309\u8d28\u6570\u51cf\u5c0f\u5982\u53bb\u638917 ll n ; bool np [ N ]; int prime [ N ], pi [ N ]; int phi [ PM + 1 ][ M + 1 ], sz [ M + 1 ]; int getprime () { int cnt = 0 ; np [ 0 ] = np [ 1 ] = true ; pi [ 0 ] = pi [ 1 ] = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( ! np [ i ]) prime [ ++ cnt ] = i ; pi [ i ] = cnt ; for ( int j = 1 ; j <= cnt && i * prime [ j ] < N ; ++ j ) { np [ i * prime [ j ]] = true ; if ( i % prime [ j ] == 0 ) break ; } } return cnt ; } void init () { getprime (); sz [ 0 ] = 1 ; for ( int i = 0 ; i <= PM ; ++ i ) phi [ i ][ 0 ] = i ; for ( int i = 1 ; i <= M ; ++ i ) { sz [ i ] = prime [ i ] * sz [ i - 1 ]; for ( int j = 1 ; j <= PM ; ++ j ) phi [ j ][ i ] = phi [ j ][ i - 1 ] - phi [ j / prime [ i ]][ i - 1 ]; } } int sqrt2 ( ll x ) { ll r = ( ll ) sqrt ( x - 0.1 ); while ( r * r <= x ) ++ r ; return int ( r - 1 ); } int sqrt3 ( ll x ) { ll r = ( ll ) cbrt ( x - 0.1 ); while ( r * r * r <= x ) ++ r ; return int ( r - 1 ); } ll getphi ( ll x , int s ) { if ( s == 0 ) return x ; if ( s <= M ) return phi [ x % sz [ s ]][ s ] + ( x / sz [ s ]) * phi [ sz [ s ]][ s ]; if ( x <= prime [ s ] * prime [ s ]) return pi [ x ] - s + 1 ; if ( x <= prime [ s ] * prime [ s ] * prime [ s ] && x < N ) { int s2x = pi [ sqrt2 ( x )]; ll ans = pi [ x ] - ( s2x + s - 2 ) * ( s2x - s + 1 ) / 2 ; for ( int i = s + 1 ; i <= s2x ; ++ i ) ans += pi [ x / prime [ i ]]; return ans ; } return getphi ( x , s - 1 ) - getphi ( x / prime [ s ], s - 1 ); } ll getpi ( ll x ) { if ( x < N ) return pi [ x ]; ll ans = getphi ( x , pi [ sqrt3 ( x )]) + pi [ sqrt3 ( x )] - 1 ; for ( int i = pi [ sqrt3 ( x )] + 1 , ed = pi [ sqrt2 ( x )]; i <= ed ; ++ i ) ans -= getpi ( x / prime [ i ]) - i + 1 ; return ans ; } ll lehmer_pi ( ll x ) { //\u5c0f\u4e8e\u7b49\u4e8en\u7684\u7d20\u6570\u6709\u591a\u5c11\u4e2a if ( x < N ) return pi [ x ]; int a = ( int ) lehmer_pi ( sqrt2 ( sqrt2 ( x ))); int b = ( int ) lehmer_pi ( sqrt2 ( x )); int c = ( int ) lehmer_pi ( sqrt3 ( x )); ll sum = getphi ( x , a ) + ( ll )( b + a - 2 ) * ( b - a + 1 ) / 2 ; for ( int i = a + 1 ; i <= b ; i ++ ) { ll w = x / prime [ i ]; sum -= lehmer_pi ( w ); if ( i > c ) continue ; ll lim = lehmer_pi ( sqrt2 ( w )); for ( int j = i ; j <= lim ; j ++ ) sum -= lehmer_pi ( w / prime [ j ]) - ( j - 1 ); } return sum ; } int main () { ios_base :: sync_with_stdio ( false ), cin . tie ( 0 ); init (); while ( cin >> n && n ) cout << lehmer_pi ( n ) << \" \\n \" ; return 0 ; }","title":"Meissel-Lehmer \u7b97\u6cd5"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#miller-rabin","text":"// C++ Version bool millerRabin ( int n ) { if ( n < 3 || n % 2 == 0 ) return n == 2 ; int a = n - 1 , b = 0 ; while ( a % 2 == 0 ) a /= 2 , ++ b ; // test_time \u4e3a\u6d4b\u8bd5\u6b21\u6570,\u5efa\u8bae\u8bbe\u4e3a\u4e0d\u5c0f\u4e8e 8 // \u7684\u6574\u6570\u4ee5\u4fdd\u8bc1\u6b63\u786e\u7387,\u4f46\u4e5f\u4e0d\u5b9c\u8fc7\u5927,\u5426\u5219\u4f1a\u5f71\u54cd\u6548\u7387 for ( int i = 1 , j ; i <= test_time ; ++ i ) { int x = rand () % ( n - 2 ) + 2 , v = quickPow ( x , a , n ); if ( v == 1 ) continue ; for ( j = 0 ; j < b ; ++ j ) { if ( v == n - 1 ) break ; v = ( long long ) v * v % n ; } if ( j >= b ) return 0 ; } return 1 ; }","title":"Miller Rabin\u7d20\u6570\u5224\u5b9a\u7b97\u6cd5"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_37","text":"","title":"\u52a8\u6001\u89c4\u5212"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_38","text":"\u5982\u679c\u4f60\u9700\u8981\u79fb\u52a8\u4e00\u6837\u4e1c\u897f\uff0c\u663e\u7136\u63a5\u89e6\u6216\u8005\u4f7f\u7528\u78c1\u573a\u7535\u573a\u4e4b\u7c7b\u7684\u53ef\u4ee5\u89e3\u51b3\u3002\u4f46\u662f\u6709\u6ca1\u6709\u529e\u6cd5\u8fdb\u884c\u8d85\u8d8a\u8ddd\u79bb\u7684\u968f\u5fc3\u6240\u6b32\u7684\u79fb\u52a8\uff1f \u5bf9\u4e8e\u7269\u4f53\u6216\u8005\u6587\u5b57\u8fdb\u884c\u8d85\u8ddd\u79bb\u79fb\u52a8\u4e00\u76f4\u662f\u4eba\u7c7b\u7684\u68a6\u60f3\uff0c\u6709\u4e00\u5929\u8fd9\u4e2a\u96be\u9898\u7ec8\u4e8e\u88ab\u6211\u4eec\u7684\u5927\u725b\u89e3\u51b3\u4e86\uff01\u4ed6\u73b0\u5728\u9700\u8981\u7684\u5c31\u662f\u6574\u7406\u6570\u5217\u3002\u6570\u5217\u5c31\u662f\u6240\u8c13\u7684\u5199\u5728\u7eb8\u4e0a\u6216\u8005\u5728\u7535\u8111\u54c1\u76ee\u4e0a\u7684\u6570\u5217... \u6574\u7406\u6570\u5217\u9700\u8981\u4e00\u4e2a\u53eb\u505aswap\u7684\u64cd\u4f5c\uff0cswap\u64cd\u4f5c\u5c31\u662f\u6307\u5927\u725b\u901a\u8fc7\u8d85\u8ddd\u79bb\u7684\u63a7\u5236\u628a\u6570\u5217\u4e2d\u7684\u67d0\u4e00\u4f4d\u76f4\u63a5\u63d2\u5165\u67d0\u4e24\u4f4d\u7684\u4e2d\u95f4\u6216\u8005\u6570\u5217\u7684\u5f00\u59cb\u6216\u8005\u7ec8\u6b62\u7684\u64cd\u4f5c\u3002\u8fd9\u4e2a\u64cd\u4f5c\u7684\u5173\u952e\u5728\u4e8e\u8d85\u8ddd\u79bb\u63a7\u5236\uff0c\u663e\u7136\u8fd9\u79cd\u4e8b\u60c5\u4e0d\u80fd\u5e72\u592a\u591a\u6b21\uff0c\u4e0d\u4f46\u964dRP\uff0c\u800c\u4e14\u5f88\u8017\u4f53\u529b\u3002\u4f60\u7684\u4efb\u52a1\u5c31\u662f\u4ece\u521d\u59cb\u72b6\u6001\u5230\u76ee\u6807\u72b6\u6001\u6240\u9700\u8981\u505aswap\u7684\u6700\u5c11\u6b21\u6570\u3002 \u8f93\u5165 \u4e09\u884c\uff0c\u7b2c\u4e00\u884c\u4e00\u4e2a\u6574\u6570 n\uff08n<600000\uff09 \u7b2c\u4e8c\u884c\uff0cn \u4e2a\u6574\u6570\uff081-n\uff09\uff0c\u8868\u793a\u521d\u59cb\u6570\u5217\u3002 \u7b2c\u4e09\u884c\uff0cn \u4e2a\u6574\u6570\uff081-n\uff09\uff0c\u8868\u793a\u76ee\u6807\u6570\u5217\u3002 \u4fdd\u8bc1\u6574\u6570\u4e0d\u91cd\u590d\u3002 \u8f93\u51fa \u4e00\u884c \u8868\u793a\u6700\u5c11swap\u6b21\u6570\u3002 \u6837\u4f8b\u8f93\u5165 10 1 2 3 4 5 6 7 8 9 10 10 9 8 7 6 5 4 3 2 1 \u6837\u4f8b\u8f93\u51fa 9 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <iostream> #include <cstdio> #include <bits/stdc++.h> using namespace std ; const int inf = 0x7fffffff ; int b [ 1005001 ], mp [ 1005001 ], c [ 1005001 ]; int main () { int n , x ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & x ), mp [ x ] = i ; for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & b [ i ]), c [ i ] = inf ; int len = 0 ; c [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int l = 0 , r = len , mid ; if ( mp [ b [ i ]] > c [ len ]) c [ ++ len ] = mp [ b [ i ]]; else { while ( l < r ) { mid = ( l + r ) / 2 ; if ( c [ mid ] > mp [ b [ i ]]) r = mid ; else l = mid + 1 ; } c [ l ] = min ( mp [ b [ i ]], c [ l ]); } } cout << n - len << endl ; return 0 ; }","title":"\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_39","text":"for ( int i = 1 ; i <= strlen ( a ); i ++ ) for ( int j = 1 ; j <= strlen ( b ); j ++ ) if ( a [ i ] == b [ j ]) dp [ i ][ j ] = dp [ i -1 ][ j -1 ] + 1 ; else dp [ i ][ j ] = max ( dp [ i -1 ][ j ], dp [ i ][ j -1 ]);","title":"\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#dp","text":"#include <bits/stdc++.h> using namespace std ; typedef unsigned long long ull ; typedef long long ll ; const int inf = 0x3f3f3f3f ; int n , m ; struct node { int cost , num ; } nd [ 100005 ]; int f [ 1005 ][( 1 << 12 ) + 5 ]; //1\u5de6\u79fb12\u4f4d\u518d\u52a05 int main () { cin >> n >> m ; for ( int i = 1 ; i <= m ; i ++ ) { int b ; scanf ( \"%d%d\" , & nd [ i ]. cost , & b ); int t = 0 ; for ( int j = 1 ; j <= b ; j ++ ) { int temp ; scanf ( \"%d\" , & temp ); t |= ( 1 << ( temp -1 )); ///1\u672c\u6765\u5c31\u5728\u7b2c\u4e00\u4e2a\u4f4d\uff0c\u6240\u4ee5\u8981\u5230\u7b2ctemp\u4f4d\uff0c\u53ea\u9700\u8981\u5411\u5de6\u79fb\u52a8temp-1\u4f4d } nd [ i ]. num = t ; } memset ( f , inf , sizeof ( f )); f [ 0 ][ 0 ] = 0 ; ///\u5f88\u91cd\u8981 for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 0 ; j < ( 1 << n ); j ++ ) ///n\u4e2a\u9501 { int kk = j | nd [ i ]. num ; ///\u5bf9\u5e94\u6bcf\u4e2a\u9501\u9009\u4e0d\u9009 f [ i ][ kk ] = min ( f [ i ][ kk ], f [ i -1 ][ j ] + nd [ i ]. cost ); f [ i ][ j ] = min ( f [ i ][ j ], f [ i -1 ][ j ]); /// } } if ( f [ m ][( 1 << n ) -1 ] != inf ) ///1\u5411\u5de6\u79fb\u52a812\uff0c\u76f8\u5f53\u4e8e1000000000000\uff0c\u7136\u800c12\u4e2a\u4f4d\u7f6e\u90fd\u4e3a1\uff0c\u5373(111111111111)=(1000000000000)-1 printf ( \"%d \\n \" , f [ m ][( 1 << n ) -1 ]); else printf ( \"-1\" ); return 0 ; }","title":"\u72b6\u538bDP"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#dp_1","text":"\u4f18\u5316$ Dp[i]=min(Dp[i]\uff0cDp[j]+(h[j]-h[i])^2 +m)(m\u4e3a\u5e38\u6570)$ \u9898\u76ee\u94fe\u63a5\uff1a Frog 3-ICPC Frog 3-Atcoder \u53c2\u8003\u94fe\u63a5\uff1a https://www.cnblogs.com/orzzz/p/7885971.html https://blog.csdn.net/mengxiang000000/article/details/78113980 https://blog.csdn.net/bllsll/article/details/78267029 \u516c\u5f0f\u63a8\u5bfc\uff1a \u6211\u4eec\u5047\u8bbe\u5728\u6c42\u89e3 dp[i] dp[i] \u65f6\uff0c\u5b58\u5728 j,k(j>k) j,k(j>k) \u4f7f\u5f97\u4ece j j \u8f6c\u79fb\u6bd4\u4ece k k \u8f6c\u79fb\u66f4\u4f18\uff0c\u90a3\u4e48\u9700\u8981\u6ee1\u8db3\u6761\u4ef6\uff1a dp[j]+(S[i+1]\u2212S[j])^2+M<dp[k]+(S[i+1]\u2212S[k])^2+M dp[j]+(S[i+1]\u2212S[j])^2+M<dp[k]+(S[i+1]\u2212S[k])^2+M \u5c55\u5f00\u4e0a\u5f0f dp[j]+S[i+1]^2\u22122S[i+1]S[j]+S[j]^2+M<dp[k]+S[i+1]^2\u22122S[i+1]S[k]+S[k]^2+M dp[j]+S[i+1]^2\u22122S[i+1]S[j]+S[j]^2+M<dp[k]+S[i+1]^2\u22122S[i+1]S[k]+S[k]^2+M \u79fb\u9879\u5e76\u6d88\u53bb\u518d\u5408\u5e76\u540c\u7c7b\u9879\u5f97 $dp[j]\u2212dp[k]+S[j] 2\u2212S[k] 2<2S[i+1] (S[j]\u2212S[k]) $ \u628aS[j]\u2212S[k]S[j]\u2212S[k]\u9664\u8fc7\u53bb\uff0c\u5f97\u5230 \\frac{dp[j]\u2212dp[k]+S[j]^2\u2212S[k]^2}{S[j]\u2212S[k]}<2S[i+1] \\frac{dp[j]\u2212dp[k]+S[j]^2\u2212S[k]^2}{S[j]\u2212S[k]}<2S[i+1] \u6211\u4eec\u8bbe f[x]=dp[x]+S[x]^2 f[x]=dp[x]+S[x]^2 \uff0c\u5c31\u5316\u6210\u4e86 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \u5373\u5f53 (j>k) (j>k) \u65f6\uff0c\u82e5 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}<2S[i+1] \uff0c\u5219 j j \u5bf9\u66f4\u65b0 dp[i] dp[i] \u6bd4 k k \u66f4\u65b0 dp[i] dp[i] \u4f18\u3002---\u659c\u7387\u3002 \u5f53\u4e00\u4e2a\u6570\u7684dp\u503c\u6c42\u5b8c\u4e86\uff0c\u5b83\u7684f\u503c\u4e5f\u8ddf\u7740\u786e\u5b9a\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5728\u7a7a\u95f4\u4e2d\u7ed8\u5236\u51fa\u70b9(S[i],f[i])\u3002\u8fd9\u4e2a\u70b9\u4ee3\u8868\u5df2\u7ecf\u6c42\u51fadp\u503c\u7684\u4e00\u4e2a\u70b9\u3002 \u5f53\u6211\u4eec\u8981\u6c42\u89e3dp[t]\u65f6\uff0c\u5982\u679c\u53ef\u7528\u7684\u96c6\u5408\u91cc\u5b58\u5728\u8fd9\u6837\u4e09\u4e2a\u70b9\uff0c\u4f4d\u7f6e\u5173\u7cfb\u5982\u56fe\u6240\u793a\uff1a \u90a3\u4e48\u663e\u7136 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \u8fd9\u65f6\u5019\u4ed6\u4eec\u548c2S[t+1]2S[t+1]\u7684\u5173\u7cfb\u67093\u79cd\uff1a \u00b7 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]}>2S[t+1] \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]}>2S[t+1] \u90a3\u4e48j\u6bd4i\u4f18\uff0ck\u6bd4j\u4f18\u3002 \u00b7 \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>2S[t+1]>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>2S[t+1]>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \u90a3\u4e48i\u6bd4j\u4f18\uff0ck\u6bd4j\u4f18\u3002 \u00b7 2S[t+1]>\\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} 2S[t+1]>\\frac{f[j]\u2212f[k]}{S[j]\u2212S[k]}>\\frac{f[i]\u2212f[j]}{S[i]\u2212S[j]} \u90a3\u4e48i\u6bd4j\u4f18\uff0cj\u6bd4k\u4f18\u3002 \u7efc\u4e0a\uff0c\u4e0d\u7ba1\u4ec0\u4e48\u6837\u7684 S[t+1] S[t+1] \uff0c\u4ecej\u8f6c\u79fb\u90fd\u4e0d\u4f1a\u662f\u6700\u4f73\u65b9\u6848\u3002\u90a3\u4e48\u7528\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u4e00\u4e2a\u51f8\u5305\uff08\u4e0b\u51f8\uff09\uff0c\u6bcf\u52a0\u5165\u4e00\u4e2a\u70b9\u5c31\u5220\u53bb\u4e00\u4e9b\u70b9\uff0c\u4f7f\u5176\u7ef4\u6301\u51f8\u5305\u7684\u5f62\u6001\u3002\u6700\u4f18\u8f6c\u79fb\u4e00\u5b9a\u5728\u8fd9\u4e2a\u51f8\u5305\u4e2d\u3002 \u90a3\u4e48\u6839\u636e\u4e0a\u8ff0\uff0c\u6211\u4eec\u53ef\u4ee5\u6709\u4e24\u4e2a\u63a8\u8bba\uff1a 1. G[j\uff0ck]<=S[i] G[j\uff0ck]<=S[i] \uff0c\u90a3\u4e48\u4f4d\u5b50k\u5c31\u53ef\u4ee5\u88ab\u6dd8\u6c70\u3002 2. G[j\uff0ck]<=G[i\uff0cj] G[j\uff0ck]<=G[i\uff0cj] \uff0c\u90a3\u4e48\u8868\u793aj\u6bd4k\u66f4\u4f18\uff0c\u5e76\u4e14i\u6bd4j\u66f4\u4f18\uff0c\u90a3\u4e48\u4f4d\u5b50j\u662f\u53ef\u4ee5\u88ab\u6dd8\u6c70\u7684\u3002 \u4ee3\u7801\uff1a #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll h [ 200500 ] = { 0 }; ll dp [ 200500 ] = { 0 }; deque < ll > que ; double xielv ( ll i , ll j ) { double ans = ( dp [ i ] + h [ i ] * h [ i ] - dp [ j ] - h [ j ] * h [ j ]) * 1.0 / ( 2 * ( h [ i ] - h [ j ])); return ans ; } int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & h [ i ]); que . push_back ( 1 ); dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { while ( que . size () >= 2 && xielv ( que [ 0 ], que [ 1 ]) <= h [ i ]) que . pop_front (); if ( que . size ()) dp [ i ] = dp [ que [ 0 ]] + ( h [ i ] - h [ que [ 0 ]]) * ( h [ i ] - h [ que [ 0 ]]) + m ; while ( que . size () >= 2 && xielv ( que [ que . size () - 2 ], que [ que . size () - 1 ]) > xielv ( que [ que . size () - 1 ], i )) que . pop_back (); que . push_back ( i ); } cout << dp [ n ] << endl ; }","title":"\u659c\u7387DP"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_40","text":"","title":"\u8d2a\u5fc3"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_41","text":"\u53c2\u8003\u94fe\u63a5\uff1a https://www.cnblogs.com/dchnzlh/p/10427309.html \u533a\u95f4\u9009\u53d6\uff08\u4f1a\u573a\u5b89\u6392\u95ee\u9898\uff09 \uff0c\u7ed9\u4e00\u4e2a\u5927\u533a\u95f4l,r\u7136\u540e\u7ed9\u4f60n\u4e2a\u533a\u95f4\uff0c\u6700\u6700\u591a\u591a\u5c11\u4e2a\u533a\u95f4\u6ca1\u6709\u91cd\u590d\u90e8\u5206 \u4f8b\u5b50\uff1a \u5b66\u6821\u7684\u5c0f\u793c\u5802\u6bcf\u5929\u90fd\u4f1a\u6709\u8bb8\u591a\u6d3b\u52a8\uff0c\u6709\u65f6\u95f4\u8fd9\u4e9b\u6d3b\u52a8\u7684\u8ba1\u5212\u65f6\u95f4\u4f1a\u53d1\u751f\u51b2\u7a81\uff0c\u9700\u8981\u9009\u62e9\u51fa\u4e00\u4e9b\u6d3b\u52a8\u8fdb\u884c\u4e3e\u529e\u3002\u5c0f\u5218\u7684\u5de5\u4f5c\u5c31\u662f\u5b89\u6392\u5b66\u6821\u5c0f\u793c\u5802\u7684\u6d3b\u52a8\uff0c\u6bcf\u4e2a\u65f6\u95f4\u6700\u591a\u5b89\u6392\u4e00\u4e2a\u6d3b\u52a8\u3002\u73b0\u5728\u5c0f\u5218\u6709\u4e00\u4e9b\u6d3b\u52a8\u8ba1\u5212\u7684\u65f6\u95f4\u8868\uff0c\u4ed6\u60f3\u5c3d\u53ef\u80fd\u7684\u5b89\u6392\u66f4\u591a\u7684\u6d3b\u52a8\uff0c\u8bf7\u95ee\u4ed6\u8be5\u5982\u4f55\u5b89\u6392\u3002 \u8f93\u5165\uff1a \u7b2c\u4e00\u884c\u662f\u4e00\u4e2a\u6574\u578b\u6570m(m<100)\u8868\u793a\u5171\u6709m\u7ec4\u6d4b\u8bd5\u6570\u636e\u3002 \u6bcf\u7ec4\u6d4b\u8bd5\u6570\u636e\u7684\u7b2c\u4e00\u884c\u662f\u4e00\u4e2a\u6574\u6570n(1<n<10000)\u8868\u793a\u8be5\u6d4b\u8bd5\u6570\u636e\u5171\u6709n\u4e2a\u6d3b\u52a8\u3002 \u968f\u540e\u7684n\u884c\uff0c\u6bcf\u884c\u6709\u4e24\u4e2a\u6b63\u6574\u6570Bi,Ei(0<=Bi,Ei<10000),\u5206\u522b\u8868\u793a\u7b2ci\u4e2a\u6d3b\u52a8\u7684\u8d77\u59cb\u4e0e\u7ed3\u675f\u65f6\u95f4\uff08Bi<=Ei) \u8f93\u51fa\uff1a \u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u8f93\u5165\uff0c\u8f93\u51fa\u6700\u591a\u80fd\u591f\u5b89\u6392\u7684\u6d3b\u52a8\u6570\u91cf\u3002 \u7b56\u7565\uff1a\u6bcf\u9009\u4e00\u4e2a\u4e4b\u540e\u80fd\u7ed9\u540e\u9762\u7684\u7559\u66f4\u591a\u7684\u65f6\u95f4\uff08\u6548\u679c\uff1a\u6309\u7ed3\u675f\u65f6\u95f4\u6392\u5e8f\uff09 \u90a3\u4e48\u7b2c\u4e00\u4e2a\u65f6\uff0c\u80af\u5b9a\u9009\u6b64\u65f6\u80fd\u9009\u7684\u7ed3\u675f\u65f6\u95f4\u6700\u65e9\u7684\uff0c\u9009\u5176\u4ed6\u7684\u8bdd\u7ed9\u540e\u9762\u7559\u7684\u65f6\u95f4\u90fd\u6bd4\u524d\u8005\u5c0f\uff0c\u6240\u4ee5\u54b1\u4eec\u9009\u7684\u7b2c\u4e00\u4e2a\u80af\u5b9a\u6ca1\u9519\uff0c\u5c31\u662f\u6b64\u65f6\u80fd\u9009\u7684\u7ed3\u675f\u65f6\u95f4\u6700\u65e9\u7684\uff0c\u7136\u540e\u9009\u7b2c\u4e8c\u4e2a\u65f6\uff0c\u4e5f\u662f\u9009\u53ef\u9009\u65f6\u95f4\u4e2d\u7ed3\u675f\u6700\u65e9\u7684\uff0c\u8fd9\u6837\u4fdd\u8bc1\u6709\u5176\u6700\u4f18\u89e3\uff0c\u5f52\u7eb3\u8d77\u6765\u6fc0\u5c31\u662f\uff0c\u6bcf\u4e2a\u6839\u636e\u5f53\u524d\u53ef\u7528\u65f6\u95f4\uff0c\u9009\u53d6\u4e00\u4e2a\u7ed3\u675f\u65f6\u95f4\u6700\u65e9\u7684\uff0c\u505a\u4e3a\u4e0b\u4e00\u4e2a\u4f1a\u573a\u7684\u5b89\u6392\uff0c #include <stdio.h> #include <algorithm> using namespace std ; const int maxn = 10010 ; struct Node { int beg , end ; } node [ maxn ]; bool cmp ( Node a , Node b ) { return a . end < b . end ; } int main () { int t , n , ans ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; ++ i ) //\u8f93\u5165\u533a\u95f4 \u5e76\u5904\u7406 { scanf ( \"%d %d\" , & node [ i ]. beg , & node [ i ]. end ); node [ i ]. end ++ ; //\u5c06\u533a\u95f4\u53d8\u4e3a\u5de6\u95ed\u53f3\u5f00 } sort ( node , node + n , cmp ); //\u5c06\u533a\u95f4\u6309\u53f3\u7aef\u70b9\u6392\u5e8f,\u53f3\u7aef\u70b9\u5c0f\u7684\u5728\u524d\u9762 ans = 0 ; int pos = 0 ; //\u521d\u59cb\u5316 //pos\u610f\u4e3a\u4e0a\u4e00\u4e2a\u9009\u53d6\u7684\u6d3b\u52a8\u7ed3\u675f\u7684\u4f4d\u7f6e,\u82e5\u679cbeg>=pos\u5c31\u53ef\u4ee5\u5b89\u6392 for ( int i = 0 ; i < n ; ++ i ) { if ( node [ i ]. beg >= pos ) { ++ ans ; pos = node [ i ]. end ; } } printf ( \"%d \\n \" , ans ); } } \u533a\u95f4\u9009\u70b9\u95ee\u9898 ,n\u4e2a\u95ed\u533a\u95f4[ai,bi]\uff0c\u8ba9\u4ed6\u53d6\u5c3d\u91cf\u5c11\u7684\u70b9\uff0c\u4f7f\u5f97\u6bcf\u4e2a\u95ed\u533a\u95f4\u5185\u81f3\u5c11\u6709\u4e00\u4e2a\u70b9\u3002 \u8f93\u5165\uff1a n\u4e2a\u95ed\u533a\u95f4\uff0c \u8f93\u51fa\uff1a \u6700\u5c11\u7528\u51e0\u4e2a\u70b9\uff0c\u628a\u6bcf\u4e2a\u533a\u95f4\u90fd\u5305\u542b\u4e00\u4e2a\u70b9 \u7b56\u7565\uff1a\u8ba9\u8fd9\u4e2a\u70b9\u51fa\u73b0\u5728\u4e00\u4e2a\u6ca1\u6709\u70b9\u7684\u533a\u95f4\u4e0a\uff0c\u5c3d\u53ef\u80fd\u8986\u76d6\u591a\u7684\u533a\u95f4\u7684\u5730\u65b9 \uff08\u6548\u679c\uff1a\u6309\u7ed3\u675f\u5904\u6392\u5e8f\uff09 \u9996\u5148\u4e3a\u4e86\u5c06\u6700\u5de6\u8fb9\u7684\u4e00\u4e2a\u533a\u95f4\u8986\u76d6\uff0c\uff08\u6309\u7ed3\u675f\u6392\u5e8f\u5373\u53ef\uff09\u90a3\u4e48\u7b2c\u4e00\u4e2a\u70b9\u5fc5\u987b\u5728\u7b2c\u4e00\u4e2a\u533a\u95f4\u4e0a\uff0c\u90a3\u4e48\u5728\u533a\u95f4\u4e0a\u54ea\u5462\uff1f\u4e3a\u4e86\u8ba9\u8fd9\u4e2a\u70b9\u8ba9\u66f4\u591a\u7684\u533a\u95f4\u7684\u533a\u95f4\u78b0\u5230\uff0c\u8ba9\u8fd9\u4e2a\u70b9\u6700\u9760\u53f3\uff0c\u8fd9\u6837\u7684\u8bdd\u80fd\u4fdd\u8bc1\u8fd9\u4e2a\u70b9\u8986\u76d6\u7684\u5730\u65b9\u6700\u591a\uff0c\u7136\u540e\u4e00\u76f4\u5f80\u540e\u904d\u5386\uff0c\u76f4\u5230\u4e00\u4e2a\u533a\u95f4\u4e0d\u5728\u8fd9\u4e2a\u70b9\u4e0a\u65f6\uff0c\u4e3a\u4e86\u8ba9\u8fd9\u4e2a\u533a\u95f4\u88ab\u8986\u76d6\uff0c\u5fc5\u987b\u5728\u4ece\u8fd9\u4e2a\u533a\u95f4\u4e0a\u627e\u4e00\u70b9\uff0c\uff08\u95ee\u9898\u53d8\u4e3a\u4e86\u524d\u8005\uff09 \u6bcf\u6b21\u4e00\u4e2a\u70b9\u53ef\u4ee5\u89e3\u51b3\u4e00\u4e2a\u533a\u95f4\u6216\u8005\u82e5\u5e72\u4e2a\u533a\u95f4\uff0c\u8fd9\u904d\u5386\u5b8c\u6240\u6709\u533a\u95f4\u5373\u53ef #include <stdio.h> #include <algorithm> using namespace std ; const int maxn = 10010 ; struct Node { int beg , end ; } node [ maxn ]; bool cmp ( Node a , Node b ) { return a . end < b . end ; } int main () { int n , ans ; while ( ~ scanf ( \"%d\" , & n )) { for ( int i = 0 ; i < n ; ++ i ) //\u8f93\u5165\u533a\u95f4 \u5e76\u5904\u7406 { scanf ( \"%d %d\" , & node [ i ]. beg , & node [ i ]. end ); } sort ( node , node + n , cmp ); //\u5c06\u533a\u95f4\u6309\u53f3\u7aef\u70b9\u6392\u5e8f,\u53f3\u7aef\u70b9\u5c0f\u7684\u5728\u524d\u9762 ans = 0 ; int pos = -1 ; //pos\u4ee3\u8868\u7b2c\u4e00\u4e2a\u533a\u95f4\u9009\u53d6\u7684\u70b9 for ( int i = 0 ; i < n ; ++ i ) { if ( node [ i ]. beg > pos ) { pos = node [ i ]. end ; ++ ans ; } } printf ( \"%d \\n \" , ans ); } } \u533a\u95f4\u5b8c\u5168\u8986\u76d6\u95ee\u9898 \u95ee\u9898\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3am\u7684\u533a\u95f4\uff08\u5168\u90e8\u95ed\u5408\uff09\uff0c\u518d\u7ed9\u51fan\u6761\u7ebf\u6bb5\u7684\u8d77\u70b9\u548c\u7ec8\u70b9\uff08\u6ce8\u610f\u8fd9\u91cc\u662f\u95ed\u533a\u95f4\uff09\uff0c\u6c42\u6700\u5c11\u4f7f\u7528\u591a\u5c11\u6761\u7ebf\u6bb5\u53ef\u4ee5\u5c06\u6574\u4e2a\u533a\u95f4\u5b8c\u5168\u8986\u76d6 \u5c06\u6240\u6709\u533a\u95f4\u5316\u4f5c\u6b64\u533a\u95f4\u7684\u533a\u95f4\uff0c\u526a\u8f91\u4e00\u4e0b\uff08\u6ca1\u7528\u7684\u533a\u95f4\u5220\u9664\uff09 \u7b56\u7565\uff1a\u5728\u80fd\u8fde\u63a5\u533a\u95f4\u5de6\u8fb9\u7684\u60c5\u51b5\u4e0b\uff0c\u627e\u5230\u5411\u53f3\u8fb9\u6269\u5c55\u6700\u957f\u7684\u4f4d\u7f6e\u3002\uff08\u6548\u679c\uff1a\u6309\u5f00\u5934\u6392\u5e8f\uff0c\u5f00\u5934\u4e00\u6837\uff0c\u53f3\u8fb9\u6700\u957f\u7684\u9760\u524d\uff09 \u4e3a\u4e86\u8fde\u63a5\u5230\u8fd9\u4e2a**\u9700\u8981\u88ab\u8986\u76d6\u533a\u95f4\u7684\u5de6\u8fb9**\uff0c\u9009\u4e00\u4e2a\u5de6\u7aef\u70b9\u6700\u9760\u524d\u7684\u533a\u95f4\uff0c\u5982\u679c\u5de6\u7aef\u70b9\u76f8\u540c\u8ba9\u53f3\u7aef\u70b9\u5927\u7684\u6392\u5728\u524d\u9762 \u7136\u540e\u5411\u53f3\u626b\u63cf\u533a\u95f4\u2026\uff0c\u5982\u4f55\u627e\u4e0b\u4e00\u4e2a\u9700\u8981\u5b89\u7f6e\u7684\u533a\u95f4\u5462\uff0c\u5373\u76f4\u5230\u627e\u5230\u4e0e\u4e0a\u4e00\u4e2a\u533a\u95f4\u6ca1\u6709\u8fde\u63a5\u7684\u5730\u65b9\uff0c\u8fd9\u65f6\u5019\u5fc5\u987b\u627e\u4e00\u4e2a\u533a\u95f4\u6765\u6765\u4f5c\u4e3a\u4e00\u4e2a\u8fde\u63a5\uff0c\u56e0\u4e3a\u524d\u9762\u533a\u95f4\u90fd\u6ca1\u6709\u65ad\u5f00\uff0c\u6240\u4ee5\u5728\u524d\u9762\u626b\u63cf\u8fc7\u7684\u533a\u95f4\u627e\u5230\u4e00\u4e2a\u7ed3\u675f\u5904\u6700\u5927\u7684\u533a\u95f4\u4f5c\u4e3a\u8fde\u63a5\u5c31\u884c\uff0c\u8bb0\u4e0b\u8fd9\u4e2a\u80fd\u6269\u5c55\u5230\u53f3\u8fb9\u7684\u6700\u5927\u4f4d\u7f6e\uff08\u5176\u5b9e\u8fd9\u4e2a\u8fc7\u7a0b\u662f\u627e\u8fb9\u7684\u8fc7\u7a0b\uff09\u3002\u5982\u679c\u8fd9\u4e2a\u6700\u5927\u4f4d\u7f6e\u90fd\u4e0d\u80fd\u8fde\u7740\uff0c\u8bc1\u660e\u8fd9\u4e2a\u533a\u95f4\u4e0d\u80fd\u88ab\u5b8c\u5168\u8986\u76d6\uff01\u5373\u4e0d\u5b58\u5728\u89e3\u3002 #include <stdio.h> #include <string> #include <string.h> #include <stdlib.h> #include <algorithm> #include <math.h> using namespace std ; const int maxn = 10010 ; struct Node { double beg , end ; } node [ maxn ]; bool cmp ( Node a , Node b ) { if ( a . beg == b . beg ) return a . end > b . end ; return a . beg < b . beg ; } int main () { int t , n , cnt = 0 ; double w , h ; int ans = 0 ; double x , r ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %lf %lf\" , & n , & w , & h ); cnt = 0 ; while ( n -- ) { scanf ( \"%lf %lf\" , & x , & r ); if ( r <= h / 2.0 ) //\u8fc7\u6ee4\u6389\u65e0\u6548\u7684\u55b7\u6c34\u88c5\u7f6e continue ; double ll , rr ; //\u5b58\u4e0b\u8be5\u55b7\u6c34\u88c5\u7f6e\u533a\u95f4\u7684\u8303\u56f4 double mid = sqrt ( r * r - ( h * h / 4.0 )); ll = x - mid ; rr = x + mid ; //\u5c06\u55b7\u6c34\u88c5\u7f6e\u8f6c\u5316\u4e3a\u80fd\u8986\u76d6\u7684\u533a\u95f4 ll = max ( 0.0 , ll ); rr = min (( double ) w , rr ); node [ cnt ]. beg = ll ; node [ cnt ]. end = rr ; ++ cnt ; } /* \u6b64\u65f6\u8f6c\u5316\u4e3a\u4e00\u4e2a\u533a\u95f4\u8986\u76d6\u95ee\u9898 \u5373\u5728\u4e00\u4e2a\u957f\u5ea6\u4e3aw\u7684\u533a\u95f4\u5185 \u9009\u51fa\u6700\u5c11\u7684\u533a\u95f4\u8ba9\u8fd9\u4e2a\u533a\u95f4\u8986\u76d6 */ node [ cnt ]. beg = ( double ) w ; node [ cnt ]. end = ( double ) w ; //\u52a0\u5165\u4e00\u4e2a\u7ec8\u7aef\u533a\u95f4[w,w]\u8fd9\u6837\u904d\u5386\u5230\u6574\u4e2a\u533a\u95f4\u6700\u540e\u4f1a\u627e\u51fa\u6765\u4e00\u4e2a\u5f80\u53f3\u8fb9\u5ef6\u4f38\u5230w\u7684\u4f4d\u7f6e\u7684\u533a\u95f4\uff0c\u5982\u679c\u6ca1\u6709\u5c31\u6ca1\u7b54\u6848 ++ cnt ; sort ( node , node + cnt , cmp ); double maxpos , nowpos ; nowpos = 0.0 ; maxpos = 0.0 ; int flag = 1 ; // ans = 0 ; for ( int i = 0 ; i < cnt ; ++ i ) { if ( node [ i ]. beg <= nowpos ) //\u8fd9\u4e2a\u533a\u95f4\u53ef\u4ee5\u4e0e\u524d\u9762\u7684\u533a\u95f4\u8fde\u7740 maxpos = max ( maxpos , node [ i ]. end ); //\u66f4\u65b0\u8bfe\u6269\u5c55\u7684\u6700\u5927\u533a\u95f4 else { if ( maxpos >= node [ i ]. beg ) //\u9047\u5230\u4e00\u4e2a\u95f4\u9694\u7684 \u9700\u8981\u627e\u4e00\u4e2a\u533a\u95f4\u8865\u4e00\u4e0b { ans ++ ; nowpos = maxpos ; -- i ; } else //\u5982\u679c\u4e0d\u80fd\u8865 { flag = 0 ; break ; //\u65e0\u89e3 } } } if ( flag ) printf ( \"%d \\n \" , ans ); else printf ( \"0 \\n \" ); } }","title":"\u533a\u95f4\u8d2a\u5fc3\u95ee\u9898"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_42","text":"","title":"\u8ba1\u7b97\u673a\u56fe\u5f62\u5b66"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_43","text":"#include <iostream> #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #define PI 3.1415926535 using namespace std ; struct node { int x , y ; }; node vex [ 1000 ]; //\u5b58\u5165\u7684\u6240\u6709\u7684\u70b9 node stackk [ 1000 ]; //\u51f8\u5305\u4e2d\u6240\u6709\u7684\u70b9 int xx , yy ; bool cmp1 ( node a , node b ) //\u6392\u5e8f\u627e\u7b2c\u4e00\u4e2a\u70b9 { if ( a . y == b . y ) return a . x < b . x ; else return a . y < b . y ; } int cross ( node a , node b , node c ) //\u8ba1\u7b97\u53c9\u79ef { return ( b . x - a . x ) * ( c . y - a . y ) - ( c . x - a . x ) * ( b . y - a . y ); } double dis ( node a , node b ) //\u8ba1\u7b97\u8ddd\u79bb { return sqrt (( a . x - b . x ) * ( a . x - b . x ) * 1.0 + ( a . y - b . y ) * ( a . y - b . y )); } bool cmp2 ( node a , node b ) //\u6781\u89d2\u6392\u5e8f\u53e6\u4e00\u79cd\u65b9\u6cd5\uff0c\u901f\u5ea6\u5feb { if ( atan2 ( a . y - yy , a . x - xx ) != atan2 ( b . y - yy , b . x - xx )) return ( atan2 ( a . y - yy , a . x - xx )) < ( atan2 ( b . y - yy , b . x - xx )); return a . x < b . x ; } bool cmp ( node a , node b ) //\u6781\u89d2\u6392\u5e8f { int m = cross ( vex [ 0 ], a , b ); if ( m > 0 ) return 1 ; else if ( m == 0 && dis ( vex [ 0 ], a ) - dis ( vex [ 0 ], b ) <= 0 ) return 1 ; else return 0 ; /*if(m==0) return dis(vex[0],a)-dis(vex[0],b)<=0?true:false; else return m>0?true:false;*/ } int main () { int t , L ; while ( ~ scanf ( \"%d\" , & t ), t ) { int i ; for ( i = 0 ; i < t ; i ++ ) { scanf ( \"%d%d\" , & vex [ i ]. x , & vex [ i ]. y ); } if ( t == 1 ) printf ( \"%.2f \\n \" , 0.00 ); else if ( t == 2 ) printf ( \"%.2f \\n \" , dis ( vex [ 0 ], vex [ 1 ])); else { memset ( stackk , 0 , sizeof ( stackk )); sort ( vex , vex + t , cmp1 ); stackk [ 0 ] = vex [ 0 ]; xx = stackk [ 0 ]. x ; yy = stackk [ 0 ]. y ; sort ( vex + 1 , vex + t , cmp2 ); //cmp2\u662f\u66f4\u5feb\u7684\uff0ccmp\u66f4\u5bb9\u6613\u7406\u89e3 stackk [ 1 ] = vex [ 1 ]; //\u5c06\u51f8\u5305\u4e2d\u7684\u7b2c\u4e24\u4e2a\u70b9\u5b58\u5165\u51f8\u5305\u7684\u7ed3\u6784\u4f53\u4e2d int top = 1 ; //\u6700\u540e\u51f8\u5305\u4e2d\u62e5\u6709\u70b9\u7684\u4e2a\u6570 for ( i = 2 ; i < t ; i ++ ) { while ( i >= 1 && cross ( stackk [ top -1 ], stackk [ top ], vex [ i ]) < 0 ) //\u5bf9\u4f7f\u7528\u6781\u89d2\u6392\u5e8f\u7684i>=1\u6709\u65f6\u53ef\u4ee5\u4e0d\u7528\uff0c\u4f46\u52a0\u4e0a\u603b\u662f\u597d\u7684 top -- ; stackk [ ++ top ] = vex [ i ]; //\u63a7\u5236<0\u6216<=0\u53ef\u4ee5\u63a7\u5236\u91cd\u70b9\uff0c\u5171\u7ebf\u7684\uff0c\u5177\u4f53\u89c6\u9898\u76ee\u800c\u5b9a\u3002 } double s = 0 ; //for(i=1; i<=top; i++)//\u8f93\u51fa\u51f8\u5305\u4e0a\u7684\u70b9 //cout<<stackk[i].x<<\" \"<<stackk[i].y<<endl; for ( i = 1 ; i <= top ; i ++ ) //\u8ba1\u7b97\u51f8\u5305\u7684\u5468\u957f s += dis ( stackk [ i -1 ], stackk [ i ]); s += dis ( stackk [ top ], vex [ 0 ]); //\u6700\u540e\u4e00\u4e2a\u70b9\u548c\u7b2c\u4e00\u4e2a\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb /*s+=2*PI*L; int ans=s+0.5;//\u56db\u820d\u4e94\u5165 printf(\"%d\\n\",ans);*/ printf ( \"%.2lf \\n \" , s ); } } }","title":"\u51f8\u5305\u7b97\u6cd5"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_44","text":"#include <bits/stdc++.h> using namespace std ; struct Point { double x , y ; } p [ 100500 ]; int n ; double polygonarea () { int i , j ; double area = 0 ; for ( i = 1 ; i <= n ; ++ i ){ if ( i < n ) j = i + 1 ; else j = 1 ; area += p [ i ]. x * p [ j ]. y ; area -= p [ i ]. y * p [ j ]. x ; } area /= 2.0 ; return ( area < 0 ?- area : area ); } int main () { while ( scanf ( \"%d\" , & n ) != EOF && n != 0 ) { for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%lf%lf\" , & p [ i ]. x , & p [ i ]. y ); printf ( \"%.1f \\n \" , polygonarea ()); } }","title":"\u6c42\u4efb\u610f\u591a\u8fb9\u5f62\u9762\u79ef"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_45","text":"\u7ebf\u6bb5\u6811+\u626b\u63cf\u7ebf\u6c42\u6b63\u65b9\u5f62\u989c\u8272\u53cd\u8f6c \u8f93\u5165\uff1a 1 5 2 2 4 1 3 1 5 3 5 \u4ee3\u88681\u7ec4\u6d4b\u8bd5\u6837\u4f8b\uff0c\u7ed9\u5b9a5*2\u7684\u6b63\u65b9\u5f62\uff0c\u5c062<=x<=4&&1<=y<=3\u7684\u8303\u56f4\u5185\u7684\u5c0f\u6b63\u65b9\u5f62\u8fdb\u884c\u9ed1\u767d\u53cd\u8f6c\uff0c\u6c42\u6700\u7ec8\u9ed1\u8272\u6b63\u65b9\u5f62\u7684\u4e2a\u6570\uff0c\u7b54\u6848\u4e3a18. #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int h , a , b , num ; }; int mark [ 100500 ] = { 0 }; int sum [ 100500 ] = { 0 }; node edge [ 100500 ] = { 0 }; bool cmp ( node a , node b ) { if ( a . h == b . h ) return a . num > b . num ; else return a . h < b . h ; } int nodeupdate ( int root , int l , int r , ll num ) { mark [ root ] ^= 1 ; sum [ root ] = r - l + 1 - sum [ root ]; } int pushdown ( int root , int l , int r ) { if ( mark [ root ] == 0 ) return 0 ; int mid = ( l + r ) / 2 ; nodeupdate ( 2 * root , l , mid , mark [ root ]); nodeupdate ( 2 * root + 1 , mid + 1 , r , mark [ root ]); mark [ root ] = 0 ; } int update ( int root , int l , int r , int L , int R , ll num ) { if ( l >= L && r <= R ) { nodeupdate ( root , l , r , num ); return 0 ; } pushdown ( root , l , r ); int mid = ( l + r ) / 2 ; if ( mid >= L ) update ( root * 2 , l , mid , L , R , num ); if ( mid < R ) update ( root * 2 + 1 , mid + 1 , r , L , R , num ); sum [ root ] = sum [ 2 * root ] + sum [ 2 * root + 1 ]; } int main () { int t , cnt ; scanf ( \"%d\" , & t ); while ( t -- ) { memset ( sum , 0 , sizeof ( sum )); memset ( mark , 0 , sizeof ( mark )); int n , m , ans = 0 ; cnt = 0 ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int x1 , y1 , x2 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & x2 , & y1 , & y2 ); edge [ cnt ++ ] = node { y1 , x1 , x2 , 1 }; edge [ cnt ++ ] = node { y2 , x1 , x2 , -1 }; } sort ( edge , edge + cnt , cmp ); for ( int i = 1 , j = 0 ; i <= n ; i ++ ) { while ( j < cnt && edge [ j ]. h <= i && edge [ j ]. num == 1 ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } ans += sum [ 1 ]; while ( j < cnt && edge [ j ]. h <= i ) { update ( 1 , 1 , n , edge [ j ]. a , edge [ j ]. b , 1 ); j ++ ; } } cout << ans << endl ; } return 0 ; } \u7ebf\u6bb5\u6811\u79bb\u6563\u5316\u6c42\u9762\u79ef\u7684\u5e76\uff1a #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll n ; ll s [ 400500 ] = { 0 }; ll len [ 400500 ] = { 0 }; ll x [ 400500 ] = { 0 }; unordered_map < ll , ll > mpx ; void push_up ( ll t , ll l , ll r ) { if ( s [ t ]) len [ t ] = x [ r + 1 ] - x [ l ]; else if ( l == r ) len [ t ] = 0 ; else len [ t ] = len [ 2 * t + 1 ] + len [ 2 * t ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { s [ t ] += add ; push_up ( t , L , R ); return ; } ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t , L , R ); } struct node1 { ll l , r , h , d ; }; node1 edge [ 200500 ] = { 0 }; bool cmp ( node1 a , node1 b ) { return a . h < b . h ; } int main () { scanf ( \"%lld\" , & n ); ll cnt = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll x1 , x2 , y1 , y2 ; scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); x [ ++ cnt ] = x1 , edge [ cnt ] = { x1 , x2 , y1 , 1 }; x [ ++ cnt ] = x2 , edge [ cnt ] = { x1 , x2 , y2 , -1 }; } sort ( x + 1 , x + cnt + 1 ); sort ( edge + 1 , edge + cnt + 1 , cmp ); ll m = unique ( x + 1 , x + cnt + 1 ) - x -1 ; for ( int i = 1 ; i <= m ; i ++ ) mpx [ x [ i ]] = i ; ll ans = 0 ; for ( ll i = 1 ; i < cnt ; i ++ ) { ll l = mpx [ edge [ i ]. l ], r = mpx [ edge [ i ]. r ]; update ( 1 , l , r -1 , 1 , m , edge [ i ]. d ); ans += len [ 1 ] * ( edge [ i + 1 ]. h - edge [ i ]. h ); } cout << ans << endl ; } \u626b\u63cf\u7ebf\u7ef4\u62a4\u533a\u95f4\u5185\u6240\u6709\u957f\u65b9\u5f62\u8fb9\u957f\u957f\u5ea6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; int n ; int lazy [ 400500 ] = { 0 }; int len [ 400500 ] = { 0 }; int x [ 100500 ] = { 0 }; int vis [ 50050 ] = { 0 }; unordered_map < int , int > mpx ; void push_up ( int t , int l , int r ) { if ( l == r ) len [ t ] = 0 ; else len [ t ] = len [ 2 * t + 1 ] + len [ 2 * t ]; } void push_down ( int t , int l , int r ) { if ( lazy [ t ]) { int mid = ( l + r ) / 2 ; len [ 2 * t ] += lazy [ t ] * ( x [ mid + 1 ] - x [ l ]); len [ 2 * t + 1 ] += lazy [ t ] * ( x [ r + 1 ] - x [ mid + 1 ]); lazy [ 2 * t + 1 ] += lazy [ t ]; lazy [ 2 * t ] += lazy [ t ]; lazy [ t ] = 0 ; } } int query ( int t , int l , int r , int L , int R ) { if ( l <= L && R <= r ) return len [ t ]; push_down ( t , L , R ); int ans = 0 , mid = ( L + R ) / 2 ; if ( l <= mid ) ans += query ( 2 * t , l , r , L , mid ); if ( mid < r ) ans += query ( 2 * t + 1 , l , r , mid + 1 , R ); return ans ; } void update ( int t , int l , int r , int L , int R , int add ) { if ( l <= L && R <= r ) { lazy [ t ] += add ; len [ t ] += add * ( x [ r + 1 ] - x [ l ]); return ; } int mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t , L , R ); } struct node1 { int l , r , h , d , id ; }; node1 edge [ 100500 ] = { 0 }; bool cmp ( node1 a , node1 b ) { return a . h < b . h ; } int main () { scanf ( \"%d\" , & n ); int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int x1 , x2 , y1 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & y1 , & x2 , & y2 ); x [ ++ cnt ] = x1 , edge [ cnt ] = { x1 , x2 , y1 , 1 , i }; x [ ++ cnt ] = x2 , edge [ cnt ] = { x1 , x2 , y2 , -1 , i }; } sort ( x + 1 , x + cnt + 1 ); sort ( edge + 1 , edge + cnt + 1 , cmp ); int m = unique ( x + 1 , x + cnt + 1 ) - x - 1 ; for ( int i = 1 ; i <= m ; i ++ ) mpx [ x [ i ]] = i ; for ( int i = 1 ; i <= cnt ; i ++ ) { int l = mpx [ edge [ i ]. l ], r = mpx [ edge [ i ]. r ]; if ( edge [ i ]. d == 1 && query ( 1 , l , r - 1 , 1 , m ) != 0 ) vis [ edge [ i ]. id ] = 1 ; if ( vis [ edge [ i ]. id ] == 1 ) continue ; update ( 1 , l , r - 1 , 1 , m , edge [ i ]. d ); } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += ( ! vis [ i ]); cout << ans << endl ; }","title":"\u626b\u63cf\u7ebf\u7b97\u6cd5"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_46","text":"","title":"\u535a\u5f08\u8bba"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_47","text":"\u53ea\u6709\u4e00\u5806n\u4e2a\u7269\u54c1\uff0c\u4e24\u4e2a\u4eba\u4ece\u8f6e\u6d41\u4e2d\u53d6\u51fa\uff081~m\uff09\u4e2a\uff1b\u6700\u540e\u53d6\u5149\u8005\u80dc\u3002 \u82e5n=k*(m+1) \u90a3\u4e48\u5148\u53d6\u8005\u5fc5\u8f93\u3002 int Bash_Game ( int n , int m ) //\u662f\u5426\u5148\u624b\u6709\u5fc5\u8d62\u7b56\u7565 { if ( n % ( m + 1 ) != 0 ) return 1 ; return 0 ; }","title":"\u5df4\u4ec0\u535a\u5f08"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_48","text":"\u6709\u82e5\u5e72\u5806\u5404\u82e5\u5e72\u4e2a\u7269\u54c1\uff0c\u4e24\u4e2a\u4eba\u8f6e\u6d41\u4ece\u67d0\u4e00\u5806\u53d6\u4efb\u610f\u591a\u7684\u7269\u54c1\uff0c\u89c4\u5b9a\u6bcf\u6b21\u81f3\u5c11\u53d6\u4e00\u4e2a\uff0c\u591a\u8005\u4e0d\u9650\uff0c\u6700\u540e\u53d6\u5149\u8005\u5f97\u80dc\u3002 XOR \u5224\u65ad: int Nimm_Game ( int n ) //\u5047\u8bben\u4e2a\u6570\u5b58\u5728\u6570\u7ec4f[]\u4e2d,\u6709\u5fc5\u80dc\u7b56\u7565\u8fd4\u56de1 { int flag = 0 ; for ( int i = 1 ; i <= n ; i ++ ) flag ^= f [ i ]; if ( flag ) return 1 ; return 0 ; }","title":"\u5c3c\u59c6\u535a\u5f08"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#_49","text":"\u6709\u4e24\u5806\u5404\u82e5\u5e72\u4e2a\u7269\u54c1\uff0c\u4e24\u4e2a\u4eba\u8f6e\u6d41\u4ece\u67d0\u4e00\u5806\u6216\u540c\u65f6\u4ece\u4e24\u5806\u4e2d\u53d6\u540c\u6837\u591a\u7684\u7269\u54c1\uff0c\u89c4\u5b9a\u6bcf\u6b21\u81f3\u5c11\u53d6\u4e00\u4e2a\uff0c\u591a\u8005\u4e0d\u9650\uff0c\u6700\u540e\u53d6\u5149\u8005\u5f97\u80dc\u3002 \u5224\u65ad\u662f\u5426\u4e3a\u5947\u5f02\u5c40\u52bf \u8bbex= k=[a*x]\uff0c\u5411\u4e0a\u53d6\u6574 \u5982\u679ca+k=b\uff0c\u5219\uff08a\uff0cb\uff09\u4e3a\u5947\u5f02\u5c40\u52bf\uff0c\u540e\u624b\u80dc\uff0c\u53cd\u4e4b\u4e3a\u5148\u624b\u80dc \u5bf9\u5e94\u7684\u4ee3\u7801\u5728\u8fd9\u91cc\uff1a int Wythoff_Game ( int a , int b ) { if ( a > b ) swap ( a , b ); double x = ( sqrt ( 5.0 ) -1.0 ) / 2.0 ; int k = ceil ( 1.0 * a * x ); if ( a + k == b ) return 0 ; //\u5947\u5f02\u5c40\u52bf\uff0c\u540e\u624b\u80dc\uff01 else return 1 ; //\u975e\u5947\u5f02\u5c40\u52bf\uff0c\u5148\u624b\u80dc\uff01 }","title":"\u5a01\u4f50\u592b\u535a\u5955"},{"location":"icpc/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/#sgnim","text":"\u9898\u76ee\u9898\u89e3 \u9898\u76ee\u94fe\u63a5 SG\u51fd\u6570\u8be6\u89e3 #include <bits/stdc++.h> using namespace std ; bool vis [ 300 ] = { 0 }; int sg [ 110 ][ 110 ] = { 0 }; void init () { for ( int i = 0 ; i <= 100 ; i ++ ) sg [ i ][ i ] = sg [ i ][ 0 ] = sg [ 0 ][ i ] = 199 ; for ( int i = 0 ; i <= 100 ; i ++ ) { for ( int j = 0 ; j <= 100 ; j ++ ) { if ( i == j || i == 0 || j == 0 ) continue ; memset ( vis , 0 , sizeof ( vis )); for ( int a = 0 ; a < i ; a ++ ) vis [ sg [ a ][ j ]] = 1 ; for ( int b = 0 ; b < j ; b ++ ) vis [ sg [ i ][ b ]] = 1 ; for ( int c = min ( i , j ); c >= 1 ; c -- ) vis [ sg [ i - c ][ j - c ]] = 1 ; for ( int k = 0 ;; k ++ ) { if ( ! vis [ k ]) { sg [ i ][ j ] = k ; break ; } } } } } int main () { int n ; scanf ( \"%d\" , & n ); int a , b ; int nim = 0 ; init (); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d%d\" , & a , & b ); if ( a == b ) { printf ( \"Y \\n \" ); return 0 ; } nim ^= sg [ a ][ b ]; } if ( nim != 0 ) printf ( \"Y \\n \" ); else printf ( \"N \\n \" ); }","title":"SG\u51fd\u6570\u548cNIM\u535a\u5f08"},{"location":"problem/","text":"\u9898\u89e3\u7cfb\u5217","title":"Index"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"A\u9898 \u00b6 \u9898\u89e3 \u00b6 \u7b7e\u5230\u9898\u76ee\uff0c\u7ed9\u5b9a\u4e09\u4e2a\u6570a,b\u548cc\uff0c\u9009\u62e9\u4e00\u4e2a\u6570x\uff0c\u4f7f\u5f97x-2<=a\uff0cx-1<=b\u4e14x<=c\uff0c\u6c423*x-3\u7684\u6700\u5927\u503c\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; int main () { int a , b , c ; cin >> a >> b >> c ; int min1 = min ( a + 2 , min ( b + 1 , c )); cout << min1 + min1 -1 + min1 -2 << endl ; } B\u9898 \u00b6 \u9898\u89e3 \u00b6 \u7ed9\u5b9a2 * n\u4e2a\u70b9\uff0c\u5728\u524dn\u4e2a\u70b9\u4e2d\u9009\u4e00\u4e2a\u70b9i\uff0c\u5728\u540en\u4e2a\u70b9\u4e2d\u9009\u4e00\u4e2a\u70b9j\uff0c\u6784\u9020\u4e00\u79cd\u5339\u914d\u65b9\u5f0f\u4f7f\u5f97\u4efb\u610f\u4e24\u70b9\u6a2a\u7eb5\u5750\u6807\u548c(xi+xj,yi+yj)\u5747\u76f8\u540c\u3002\u7531\u4e8exi+xj\u5747\u76f8\u540c\uff0c\u53ef\u4ee5\u628a\u8fd92 * n\u4e2a\u70b9\u7684x\u5750\u6807\u8fdb\u884c\u6c42\u548c\u7136\u540e\u5e73\u5747\u5206\u914d\u6210n\u4efd\uff0c\u8fd9\u6837\u5c31\u5f97\u5230\u4e86xi+xj\u7684\u5b9a\u503c\uff0cy\u5750\u6807\u540c\u7406\u3002\uff08\u6ce8\u610f\u5f00long long\uff09 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n ; scanf ( \"%lld\" , & n ); ll sum1 = 0 , sum2 = 0 , x , y ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { scanf ( \"%lld%lld\" , & x , & y ); sum1 += x , sum2 += y ; } sum1 /= n , sum2 /= n ; cout << sum1 << ' ' << sum2 << endl ; } C\u9898 \u00b6 \u9898\u89e3 \u00b6 \u8be5\u9898\u4e3a\u6253\u8868\u627e\u89c4\u5f8b\u6240\u505a\u51fa\u6765\u7684\uff0c\u5bb9\u6613\u53d1\u73b0\u8fd9\u4e9b\u6700\u5c0f\u503c\u6240\u5bf9\u5e94\u7684k\u53ef\u4ee5\u548cn\u7684\u56e0\u6570\u4e00\u4e00\u5bf9\u5e94\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u679a\u4e3en\u7684\u56e0\u6570\u7136\u540e\u6c42\u51fa\u7ed3\u679c\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; set < ll > s ; ll n ; ll cal ( ll x ) { ll size1 = n / x ; ll ans = size1 + size1 * ( size1 -1 ) / 2 * x ; return ans ; } int main () { scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { s . insert ( cal ( i )); s . insert ( cal ( n / i )); } } set < ll > :: iterator it = s . begin (); while ( it != s . end ()) { cout <<* it << ' ' ; it ++ ; } cout << endl ; } D\u9898 \u00b6 \u9898\u89e3 \u00b6 \u8fd9\u91cc\u4ee5n=4\u4e3a\u4f8b 1 2 3 4 2 1 3 4 3 1 2 4 4 1 2 3 1 2 4 3 2 1 4 3 3 1 4 2 4 1 3 2 1 3 2 4 2 3 1 4 3 2 1 4 4 2 1 3 1 3 4 2 2 3 4 1 3 2 4 1 4 2 3 1 1 4 2 3 2 4 1 3 3 4 1 2 4 3 1 2 1 4 3 2 2 4 3 1 3 4 2 1 4 3 2 1 \u56db\u4e2a\u6570\u4e00\u7ec4\uff0c\u53ef\u4ee5\u7ec4\u62104! \u4e2a\u7b54\u6848 \u7b2c\u4e00\u6392\u5f53\u4e2d \u6bcf\u4e00\u5bf9\u6570\u540e\u4e09\u4e2a \u548c \u4e0b\u4e00\u5bf9\u6570\u7684\u7b2c\u4e00\u4e2a \u7ec4\u6210\u4e00\u4e2a\u7b54\u6848\uff0c\u800c\u7b2c\u4e00\u6392\u4e2d\u6070\u67093! \u5bf9\u6570\uff0c\u6240\u4ee5\u7b54\u6848\u4e3a(3! - 1)*4 \u7b2c\u4e00\u6392\u6709\u516d\u5bf9\u6570\uff0c\u53ef\u4ee5\u5212\u5206\u4e3a3\u7ec4\uff0c\u6bcf\u7ec4\u4e24\u4e2a\uff0c\u4e14\u6bcf\u7ec4\u4e2d \u4e0a\u4e00\u5bf9\u6570\u7684\u540e\u4e24\u4e2a \u548c \u4e0b\u4e00\u5bf9\u6570\u7684\u524d\u4e24\u4e2a \u7ec4\u6210\u7b54\u6848\uff0c\u6240\u4ee5\u7b54\u6848\u53c8\u5e94\u5f53\u52a0\u4e0a(2! - 1) * 4 * 3 \u7efc\u4e0a\u7b54\u6848\u4e3a4! + (3! - 1) * 4 + (2! - 1) * 4 * 3 =56 \u540c\u7406\uff0c5\u7684\u7b54\u6848\u4e3a\uff1a5! + (4! - 1) * 5 + (3! - 1) * 5 * 4 + (2! - 1) * 5 * 4 * 3 = 4 *5! - 5 - 5 *4 - 5 *4 *3 = 395 \u6ce8\u610f\u7279\u52241 \uff01\uff01\uff01 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n ; const ll mod = 998244353 ; int main () { scanf ( \"%lld\" , & n ); if ( n == 1 ) { cout << 1 << endl ; return 0 ; } ll ans = 1 ; for ( ll i = 1 ; i <= n ; i ++ ) { ans = ans * i ; ans %= mod ; } ans = ans * ( n -1 ); ans %= mod ; ll sum1 = 1 ; for ( ll i = n ; i >= 3 ; i -- ) { sum1 *= i ; sum1 %= mod ; ans = ans - sum1 ; ans = ( ans % mod + mod ) % mod ; } ans = ( ans % mod + mod ) % mod ; cout << ans << endl ; } I\u9898 \u00b6 \u9898\u89e3 \u00b6 \u56fe\u8bba\u9898\u76ee\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u8be5\u70b9\u5230\u6839\u8282\u70b9\u7684\u6743\u503c\u6700\u5c0f\u503c\u5373\u4e3a\u5b50\u8282\u70b9\u6743\u503c\u7684\u6700\u5c0f\u503c\uff0c\u6240\u4ee5\u5148dfs\u786e\u5b9a-1\u70b9\u7684\u6743\u503cs[i]\uff0c\u7136\u540e\u6839\u636e\u5f97\u51fa\u7684\u6743\u503c\u8be5\u70b9\u6743\u503cs[i]\u548c\u7236\u8282\u70b9\u6743\u503cs[i]\u5224\u65ad\u662f\u5426\u7b26\u5408\u6761\u4ef6\u5e76\u6c42\u548c\u5f97\u51fa\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; vector < ll > v [ 100500 ]; ll s [ 100500 ] = { 0 }; ll fa [ 100500 ] = { 0 }; ll dfs ( ll k , ll fa ) { ll min1 = inf ; for ( int i : v [ k ]) { if ( i != fa ) { if ( dfs ( i , k ) == -1 ) return -1 ; if ( s [ i ] != -1 ) min1 = min ( min1 , s [ i ]); } } if ( s [ k ] == -1 ) { if ( min1 != inf ) s [ k ] = min1 ; } else { if ( s [ k ] > min1 ) return -1 ; } return 0 ; } ll ans = 0 ; ll dfs1 ( ll k , ll fa , ll sum ) { if ( s [ k ] == -1 ) return 0 ; if ( s [ k ] < sum ) return -1 ; sum = max ( sum , s [ k ]); ans = ans + s [ k ] - s [ fa ]; for ( int i : v [ k ]) { if ( i != fa ) { if ( dfs1 ( i , k , sum ) == -1 ) return -1 ; } } return 0 ; } int main () { ll n , m ; scanf ( \"%lld\" , & n ); fa [ 1 ] = 0 ; for ( ll i = 2 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & m ); fa [ i ] = m ; v [ i ]. push_back ( m ); v [ m ]. push_back ( i ); } for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & s [ i ]); s [ 0 ] = 0 ; if ( dfs ( 1 , -1 ) == -1 ) { printf ( \"-1 \\n \" ); return 0 ; } if ( dfs1 ( 1 , 0 , 0 ) == -1 ) { printf ( \"-1 \\n \" ); return 0 ; } cout << ans << endl ; }","title":"2021-02-02-2\u67082\u65e5\u9898\u89e3"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#a","text":"","title":"A\u9898"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u7b7e\u5230\u9898\u76ee\uff0c\u7ed9\u5b9a\u4e09\u4e2a\u6570a,b\u548cc\uff0c\u9009\u62e9\u4e00\u4e2a\u6570x\uff0c\u4f7f\u5f97x-2<=a\uff0cx-1<=b\u4e14x<=c\uff0c\u6c423*x-3\u7684\u6700\u5927\u503c\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#include <bits/stdc++.h> using namespace std ; int main () { int a , b , c ; cin >> a >> b >> c ; int min1 = min ( a + 2 , min ( b + 1 , c )); cout << min1 + min1 -1 + min1 -2 << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#b","text":"","title":"B\u9898"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u7ed9\u5b9a2 * n\u4e2a\u70b9\uff0c\u5728\u524dn\u4e2a\u70b9\u4e2d\u9009\u4e00\u4e2a\u70b9i\uff0c\u5728\u540en\u4e2a\u70b9\u4e2d\u9009\u4e00\u4e2a\u70b9j\uff0c\u6784\u9020\u4e00\u79cd\u5339\u914d\u65b9\u5f0f\u4f7f\u5f97\u4efb\u610f\u4e24\u70b9\u6a2a\u7eb5\u5750\u6807\u548c(xi+xj,yi+yj)\u5747\u76f8\u540c\u3002\u7531\u4e8exi+xj\u5747\u76f8\u540c\uff0c\u53ef\u4ee5\u628a\u8fd92 * n\u4e2a\u70b9\u7684x\u5750\u6807\u8fdb\u884c\u6c42\u548c\u7136\u540e\u5e73\u5747\u5206\u914d\u6210n\u4efd\uff0c\u8fd9\u6837\u5c31\u5f97\u5230\u4e86xi+xj\u7684\u5b9a\u503c\uff0cy\u5750\u6807\u540c\u7406\u3002\uff08\u6ce8\u610f\u5f00long long\uff09","title":"\u9898\u89e3"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n ; scanf ( \"%lld\" , & n ); ll sum1 = 0 , sum2 = 0 , x , y ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { scanf ( \"%lld%lld\" , & x , & y ); sum1 += x , sum2 += y ; } sum1 /= n , sum2 /= n ; cout << sum1 << ' ' << sum2 << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#c","text":"","title":"C\u9898"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u8be5\u9898\u4e3a\u6253\u8868\u627e\u89c4\u5f8b\u6240\u505a\u51fa\u6765\u7684\uff0c\u5bb9\u6613\u53d1\u73b0\u8fd9\u4e9b\u6700\u5c0f\u503c\u6240\u5bf9\u5e94\u7684k\u53ef\u4ee5\u548cn\u7684\u56e0\u6570\u4e00\u4e00\u5bf9\u5e94\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u679a\u4e3en\u7684\u56e0\u6570\u7136\u540e\u6c42\u51fa\u7ed3\u679c\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; set < ll > s ; ll n ; ll cal ( ll x ) { ll size1 = n / x ; ll ans = size1 + size1 * ( size1 -1 ) / 2 * x ; return ans ; } int main () { scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { s . insert ( cal ( i )); s . insert ( cal ( n / i )); } } set < ll > :: iterator it = s . begin (); while ( it != s . end ()) { cout <<* it << ' ' ; it ++ ; } cout << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#d","text":"","title":"D\u9898"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"\u8fd9\u91cc\u4ee5n=4\u4e3a\u4f8b 1 2 3 4 2 1 3 4 3 1 2 4 4 1 2 3 1 2 4 3 2 1 4 3 3 1 4 2 4 1 3 2 1 3 2 4 2 3 1 4 3 2 1 4 4 2 1 3 1 3 4 2 2 3 4 1 3 2 4 1 4 2 3 1 1 4 2 3 2 4 1 3 3 4 1 2 4 3 1 2 1 4 3 2 2 4 3 1 3 4 2 1 4 3 2 1 \u56db\u4e2a\u6570\u4e00\u7ec4\uff0c\u53ef\u4ee5\u7ec4\u62104! \u4e2a\u7b54\u6848 \u7b2c\u4e00\u6392\u5f53\u4e2d \u6bcf\u4e00\u5bf9\u6570\u540e\u4e09\u4e2a \u548c \u4e0b\u4e00\u5bf9\u6570\u7684\u7b2c\u4e00\u4e2a \u7ec4\u6210\u4e00\u4e2a\u7b54\u6848\uff0c\u800c\u7b2c\u4e00\u6392\u4e2d\u6070\u67093! \u5bf9\u6570\uff0c\u6240\u4ee5\u7b54\u6848\u4e3a(3! - 1)*4 \u7b2c\u4e00\u6392\u6709\u516d\u5bf9\u6570\uff0c\u53ef\u4ee5\u5212\u5206\u4e3a3\u7ec4\uff0c\u6bcf\u7ec4\u4e24\u4e2a\uff0c\u4e14\u6bcf\u7ec4\u4e2d \u4e0a\u4e00\u5bf9\u6570\u7684\u540e\u4e24\u4e2a \u548c \u4e0b\u4e00\u5bf9\u6570\u7684\u524d\u4e24\u4e2a \u7ec4\u6210\u7b54\u6848\uff0c\u6240\u4ee5\u7b54\u6848\u53c8\u5e94\u5f53\u52a0\u4e0a(2! - 1) * 4 * 3 \u7efc\u4e0a\u7b54\u6848\u4e3a4! + (3! - 1) * 4 + (2! - 1) * 4 * 3 =56 \u540c\u7406\uff0c5\u7684\u7b54\u6848\u4e3a\uff1a5! + (4! - 1) * 5 + (3! - 1) * 5 * 4 + (2! - 1) * 5 * 4 * 3 = 4 *5! - 5 - 5 *4 - 5 *4 *3 = 395 \u6ce8\u610f\u7279\u52241 \uff01\uff01\uff01","title":"\u9898\u89e3"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n ; const ll mod = 998244353 ; int main () { scanf ( \"%lld\" , & n ); if ( n == 1 ) { cout << 1 << endl ; return 0 ; } ll ans = 1 ; for ( ll i = 1 ; i <= n ; i ++ ) { ans = ans * i ; ans %= mod ; } ans = ans * ( n -1 ); ans %= mod ; ll sum1 = 1 ; for ( ll i = n ; i >= 3 ; i -- ) { sum1 *= i ; sum1 %= mod ; ans = ans - sum1 ; ans = ( ans % mod + mod ) % mod ; } ans = ( ans % mod + mod ) % mod ; cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#i","text":"","title":"I\u9898"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"\u56fe\u8bba\u9898\u76ee\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u8be5\u70b9\u5230\u6839\u8282\u70b9\u7684\u6743\u503c\u6700\u5c0f\u503c\u5373\u4e3a\u5b50\u8282\u70b9\u6743\u503c\u7684\u6700\u5c0f\u503c\uff0c\u6240\u4ee5\u5148dfs\u786e\u5b9a-1\u70b9\u7684\u6743\u503cs[i]\uff0c\u7136\u540e\u6839\u636e\u5f97\u51fa\u7684\u6743\u503c\u8be5\u70b9\u6743\u503cs[i]\u548c\u7236\u8282\u70b9\u6743\u503cs[i]\u5224\u65ad\u662f\u5426\u7b26\u5408\u6761\u4ef6\u5e76\u6c42\u548c\u5f97\u51fa\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-02-2%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_10","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; vector < ll > v [ 100500 ]; ll s [ 100500 ] = { 0 }; ll fa [ 100500 ] = { 0 }; ll dfs ( ll k , ll fa ) { ll min1 = inf ; for ( int i : v [ k ]) { if ( i != fa ) { if ( dfs ( i , k ) == -1 ) return -1 ; if ( s [ i ] != -1 ) min1 = min ( min1 , s [ i ]); } } if ( s [ k ] == -1 ) { if ( min1 != inf ) s [ k ] = min1 ; } else { if ( s [ k ] > min1 ) return -1 ; } return 0 ; } ll ans = 0 ; ll dfs1 ( ll k , ll fa , ll sum ) { if ( s [ k ] == -1 ) return 0 ; if ( s [ k ] < sum ) return -1 ; sum = max ( sum , s [ k ]); ans = ans + s [ k ] - s [ fa ]; for ( int i : v [ k ]) { if ( i != fa ) { if ( dfs1 ( i , k , sum ) == -1 ) return -1 ; } } return 0 ; } int main () { ll n , m ; scanf ( \"%lld\" , & n ); fa [ 1 ] = 0 ; for ( ll i = 2 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & m ); fa [ i ] = m ; v [ i ]. push_back ( m ); v [ m ]. push_back ( i ); } for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & s [ i ]); s [ 0 ] = 0 ; if ( dfs ( 1 , -1 ) == -1 ) { printf ( \"-1 \\n \" ); return 0 ; } if ( dfs1 ( 1 , 0 , 0 ) == -1 ) { printf ( \"-1 \\n \" ); return 0 ; } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-07-2%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"\u9898\u89e3 \u00b6 \u8be5\u9898\u4e3a\u62ec\u53f7\u5339\u914d\u95ee\u9898\uff0c\u6c42\u6700\u591a\u80fd\u591f\u5339\u914d\u7684\u5bf9\u6570\uff0c\u53ef\u4ee5\u53d1\u73b0 )(\uff0c\u8fd9\u79cd\u60c5\u51b5\u7684\u62ec\u53f7\u4e00\u5b9a\u4e0d\u80fd\u591f\u53c2\u4e0e\u5339\u914d\uff0c\u53ea\u6709\u53bb\u9664\u5339\u914d\u62ec\u53f7\u540e\u5269\u4f59\u5168\u90e8\u4e3a\u5de6\u62ec\u53f7\u6216\u53f3\u62ec\u53f7\u624d\u80fd\u591f\u53c2\u4e0e\u5339\u914d\uff0c\u4e0e\u5176\u4ed6\u7684\u7ec4\u6210\u5b8c\u6574\u7684\u62ec\u53f7\u5e8f\u5217\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char a [ 500500 ] = { 0 }; int num [ 500500 ] = { 0 }; int b [ 100500 ] = { 0 }; stack < char > s ; int main () { int n ; scanf ( \"%d\" , & n ); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , a + 1 ); for ( int j = 1 ; a [ j ]; j ++ ) { if ( s . empty ()) { s . push ( a [ j ]); } else { if ( a [ j ] == ')' && s . top () == '(' ) s . pop (); else s . push ( a [ j ]); } } int sum1 = 0 , flag = 1 ; while ( ! s . empty ()) { if ( s . top () == ')' ) { s . pop (); if ( sum1 > 0 ) flag = 0 ; else sum1 -- ; } else { s . pop (); if ( sum1 < 0 ) flag = 0 ; else sum1 ++ ; } } if ( flag ) { if ( sum1 < 0 ) num [ - sum1 ] ++ ; b [ i ] = sum1 ; if ( sum1 == 0 ) ans ++ ; } } ans /= 2 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( b [ i ] <= 0 ) continue ; else { if ( num [ b [ i ]] != 0 ) num [ b [ i ]] -- , ans ++ ; } } cout << ans << endl ; }","title":"2021-02-07-2\u67087\u65e5\u9898\u89e3"},{"location":"problem/2021-02-07-2%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u8be5\u9898\u4e3a\u62ec\u53f7\u5339\u914d\u95ee\u9898\uff0c\u6c42\u6700\u591a\u80fd\u591f\u5339\u914d\u7684\u5bf9\u6570\uff0c\u53ef\u4ee5\u53d1\u73b0 )(\uff0c\u8fd9\u79cd\u60c5\u51b5\u7684\u62ec\u53f7\u4e00\u5b9a\u4e0d\u80fd\u591f\u53c2\u4e0e\u5339\u914d\uff0c\u53ea\u6709\u53bb\u9664\u5339\u914d\u62ec\u53f7\u540e\u5269\u4f59\u5168\u90e8\u4e3a\u5de6\u62ec\u53f7\u6216\u53f3\u62ec\u53f7\u624d\u80fd\u591f\u53c2\u4e0e\u5339\u914d\uff0c\u4e0e\u5176\u4ed6\u7684\u7ec4\u6210\u5b8c\u6574\u7684\u62ec\u53f7\u5e8f\u5217\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-07-2%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char a [ 500500 ] = { 0 }; int num [ 500500 ] = { 0 }; int b [ 100500 ] = { 0 }; stack < char > s ; int main () { int n ; scanf ( \"%d\" , & n ); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , a + 1 ); for ( int j = 1 ; a [ j ]; j ++ ) { if ( s . empty ()) { s . push ( a [ j ]); } else { if ( a [ j ] == ')' && s . top () == '(' ) s . pop (); else s . push ( a [ j ]); } } int sum1 = 0 , flag = 1 ; while ( ! s . empty ()) { if ( s . top () == ')' ) { s . pop (); if ( sum1 > 0 ) flag = 0 ; else sum1 -- ; } else { s . pop (); if ( sum1 < 0 ) flag = 0 ; else sum1 ++ ; } } if ( flag ) { if ( sum1 < 0 ) num [ - sum1 ] ++ ; b [ i ] = sum1 ; if ( sum1 == 0 ) ans ++ ; } } ans /= 2 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( b [ i ] <= 0 ) continue ; else { if ( num [ b [ i ]] != 0 ) num [ b [ i ]] -- , ans ++ ; } } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-08-2%E6%9C%888%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"\u9898\u89e3 \u00b6 \u5148\u8fdb\u884cLCA\u7b97\u6cd5\uff0c\u8ba1\u7b97\u51fa\u6bcf\u4e2a\u70b9\u7684\u6df1\u5ea6\u3001\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\u7b49\uff0c\u7136\u540e\u5bf9\u4e94\u4e2a\u70b9\uff08\u5206\u522b\u4e3as1,s2,s3,s4,s5\uff09\u8fdb\u884c\u5904\u7406\uff1a \u5c06\u7b2cs1\u52a0\u5165\u56fe\u4e2d\uff0c\u5982\u56fe\uff0c\u589e\u52a0\u7684\u6743\u503c\u4e3adis[s1] \u5c06s2\u52a0\u5165\u56fe\u4e2d\uff0c\u5047\u5982s1\u548cs2\u7684\u6700\u5c0f\u516c\u5171\u7956\u5148\u4e3afa1\u5373\u4e3alca(s1,s2)\uff0c\u5219\u589e\u52a0\u7684\u6743\u503c\u4e3adis[s2]-dis[fa1] \u5c06s3\u52a0\u5165\u56fe\u4e2d\uff0c\u5047\u8bbes1\u548cs3\u7684\u6700\u5c0f\u516c\u5171\u7956\u5148\u4e3afa2\uff0cs2\u548cs3\u7684\u6700\u5c0f\u516c\u5171\u6700\u5148\u4e3afa1\uff0c\u5047\u8bbefa1\u7684\u6df1\u5ea6\u5c0f\u4e8efa2\u7684\u6df1\u5ea6\uff0c\u5219\u589e\u52a0\u7684\u6743\u503c\u4e3adis[s3]-dis[fa2] \u91cd\u590d\u7b2c3\u8fc7\u7a0b\uff0c\u5c06s4,s5\u4e24\u4e2a\u70b9\u52a0\u5165\u5230\u56fe\u5f53\u4e2d\uff0c\u6700\u540e\u6743\u503c\u548c\u51cf\u53bb\u6240\u6709\u70b9\u7684\u6700\u5c0f\u516c\u5171\u7956\u5148\u5230\u6839\u8282\u70b91\u7684\u8ddd\u79bb\u5373\u4e3a\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #include <cstdio> #include <cstring> #include <algorithm> #include <bits/stdc++.h> using namespace std ; const int maxn = 1e5 + 500 ; struct node { int to , nex , w ; } road [ maxn * 2 ]; int n , q , cnt ; int pre [ maxn ][ 32 ], head [ maxn ], depth [ maxn ]; int dis [ maxn ]; void add ( int u , int v , int w ) { road [ cnt ]. to = v ; road [ cnt ]. w = w ; road [ cnt ]. nex = head [ u ]; head [ u ] = cnt ++ ; } void dfs ( int u , int fa ) { pre [ u ][ 0 ] = fa ; depth [ u ] = depth [ fa ] + 1 ; for ( int i = 1 ; ( 1 << i ) <= depth [ u ]; i ++ ) //\u500d\u589e pre [ u ][ i ] = pre [ pre [ u ][ i -1 ]][ i -1 ]; for ( int i = head [ u ]; ~ i ; i = road [ i ]. nex ) { int v = road [ i ]. to ; if ( v != fa ) { dis [ v ] = dis [ u ] + road [ i ]. w ; dfs ( v , u ); } } } int lca ( int u , int v ) { if ( depth [ u ] < depth [ v ]) { swap ( u , v ); } int i = -1 , j ; while (( 1 << ( i + 1 )) <= depth [ u ]) i ++ ; for ( j = i ; j >= 0 ; j -- ) { if ( depth [ u ] - ( 1 << j ) >= depth [ v ]) { u = pre [ u ][ j ]; } } if ( u == v ) return u ; for ( int j = i ; j >= 0 ; j -- ) { if ( pre [ u ][ j ] != pre [ v ][ j ]) { u = pre [ u ][ j ]; v = pre [ v ][ j ]; } } return pre [ u ][ 0 ]; } int main () { scanf ( \"%d\" , & n ); memset ( head , -1 , sizeof ( head )); memset ( depth , 0 , sizeof ( depth )); cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int u , v , w ; scanf ( \"%d %d %d\" , & u , & v , & w ); add ( u + 1 , v + 1 , w ); add ( v + 1 , u + 1 , w ); } dis [ 1 ] = 0 ; dfs ( 1 , 0 ); scanf ( \"%d\" , & q ); while ( q -- ) { int point [ 10 ] = { 0 }; for ( int i = 1 ; i <= 5 ; i ++ ) scanf ( \"%d\" , & point [ i ]), point [ i ] ++ ; int ans = 0 ; for ( int i = 1 ; i <= 5 ; i ++ ) { int dep = 1 ; for ( int j = 1 ; j < i ; j ++ ) { int fa = lca ( point [ i ], point [ j ]); if ( depth [ fa ] > depth [ dep ]) dep = fa ; } ans += dis [ point [ i ]]; ans -= dis [ dep ]; } int dep = point [ 1 ]; for ( int i = 1 ; i <= 5 ; i ++ ) dep = lca ( point [ i ], dep ); ans -= dis [ dep ]; cout << ans << endl ; } } \u9898\u89e3 \u00b6 \u8be5\u9898\u70b9\u6570\u8f83\u5c11\uff0c\u53ef\u4ee5\u76f4\u63a5\u66b4\u529b\u505a\uff0c\u4f46\u662fdfs\u4f1a\u8d85\u65f6\uff0c\u6539\u7528bfs\u5373\u53ef\uff0c\u8be6\u7ec6\u89c1\u4ee3\u7801\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; vector < ll > v [ 100500 ]; //\u5b58\u56fe\u7528 ll vis [ 5050 ] = { 0 }; ///\u8bb0\u5f55\u8ddd\u79bb\u7528 ll to [ 5050 ] = { 0 }; ///\u5230\u8be5\u70b9\u7684\u9053\u8def\u4e2a\u6570 ll sum_vis [ 5050 ] = { 0 }; ///bfs\u7edf\u8ba1\u7528 long double val_all [ 5050 ] = { 0 }; ///\u7edf\u8ba1\u6743\u503c\u7528 ll s , e ; ///\u5f00\u59cb\u7ed3\u5c3e ll sum_size = 0 ; struct node { ll pos , val ; }; void bfs () { queue < node > que ; que . push ({ s , 0 }); vis [ s ] = 0 ; to [ s ] = 1 ; while ( ! que . empty ()) { node now = que . front (); que . pop (); vis [ now . pos ] = min ( vis [ now . pos ], now . val ); for ( ll i : v [ now . pos ]) { if ( vis [ i ] > now . val + 1 ) { vis [ i ] = now . val + 1 ; to [ i ] = to [ now . pos ]; que . push ({ i , now . val + 1 }); } else if ( vis [ i ] == now . val + 1 ) { to [ i ] += to [ now . pos ]; } } } sum_size = to [ e ]; } void bfs1 () { queue < int > que ; que . push ( e ); while ( ! que . empty ()) { int now = que . front (); que . pop (); sum_vis [ vis [ now ]] += to [ now ]; for ( int i : v [ now ]) { if ( vis [ i ] == vis [ now ] -1 ) que . push ( i ); } } que . push ( e ); while ( ! que . empty ()) { int now = que . front (); que . pop (); val_all [ now ] += to [ now ] * 1.0 / sum_vis [ vis [ now ]]; ///\u5230\u8be5\u70b9\u8def\u7684\u6761\u6570\u5360\u76f8\u540c\u957f\u5ea6\u6761\u6570\u7684\u6bd4\u4f8b for ( int i : v [ now ]) { if ( vis [ i ] == vis [ now ] -1 ) { que . push ( i ); } } } } ll dfs ( ll k , ll sum ) { if ( k == e ) { if ( sum == vis [ k ]) sum_size ++ ; else if ( sum < vis [ k ]) vis [ k ] = sum , sum_size = 1 ; } vis [ k ] = min ( vis [ k ], sum ); for ( ll i : v [ k ]) { if ( vis [ i ] >= sum + 1 ) dfs ( i , sum + 1 ); } return 0 ; } long double dfs1 ( ll k , ll sum ) { if ( sum > vis [ e ]) return 0 ; if ( k == e ) { val_all [ k ] += 1.0 / sum_size ; return 1.0 / sum_size ; } long double val = 0 ; for ( ll i : v [ k ]) { if ( vis [ i ] == vis [ k ] + 1 ) val += dfs1 ( i , sum + 1 ); } val_all [ k ] += val ; return val ; } int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld\" , & s , & e ); v [ s ]. push_back ( e ); v [ e ]. push_back ( s ); } ll k ; scanf ( \"%lld\" , & k ); for ( ll i = 1 ; i <= k ; i ++ ) { scanf ( \"%lld%lld\" , & s , & e ); memset ( vis , inf , sizeof ( vis )); memset ( to , 0 , sizeof ( to )); memset ( sum_vis , 0 , sizeof ( sum_vis )); bfs (); //dfs(s,0) ///\u8fd9\u91ccdfs\u4e5f\u53ef\u4ee5\u5f97\u51fa\u6b63\u786e\u7b54\u6848\uff0c\u4f46\u662f\u65f6\u95f4\u4f1a\u8d85,qwq bfs1 (); //dfs1(s,0); ///bfs\u548cdfs\u5747\u53ef\uff0cbfs\u66f4\u5feb\u4e00\u70b9\uff0cdfs\u66f4\u597d\u7406\u89e3\u4e00\u70b9\uff0c\u8fd9\u91cc\u7528dfs\u65f6\u95f4\u4e0d\u4f1a\u8d85 } ll max1 = 0 ; for ( ll i = 0 ; i < n ; i ++ ) { if ( val_all [ i ] > val_all [ max1 ]) max1 = i ; } cout << max1 << endl ; } \u9898\u89e3 \u00b6 \u8be5\u9898\u76ee\u53c2\u7167\u535a\u5ba2https://m-sea-blog.com/archives/2139\uff0c\u9644\u4e00\u5f20\u56fe\uff1a \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u53d6\u4f59\u540e\u7684\u7ed3\u679c\u4e3a\u5468\u671f\u4e3aa\u7684\u5468\u671f\u51fd\u6570\uff0c\u4efb\u53d6\u4e00\u70b9k\uff0c\u5982\u679c(2 * k)%a <= k%a\uff0c\u5219\u4e00\u5b9a\u6709k < a <= 2 * k\uff0c\u9884\u5148\u7f29\u5c0f\u8303\u56f4\u7136\u540e\u4e8c\u5206\u5373\u53ef\u5f97\u5230\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char query ( int x , int y ) { cout << \"? \" << x << \" \" << y << endl ; cout . flush (); char ans ; cin >> ans ; return ans ; } int main () { while ( 1 ) { string s ; cin >> s ; if ( s == \"end\" ) break ; ll l , r ; for ( ll i = 1 ;; i = i * 2 ) { l = i , r = min ( i * 2 ,( ll ) 2e9 ); char ans = query ( l , r ); if ( ans == 'x' ) { l = i , r = min ( i * 2 ,( ll ) 1e9 ); break ; } } while ( l < r ) { int mid = ( l + r ) / 2 ; char ans = query ( mid * 2 , mid ); if ( ans == 'x' ) r = mid ; else l = mid + 1 ; } if ( l == 2 ) { char ans = query ( 2 , 1 ); if ( ans == 'x' ) { cout << \"! 1\" << endl ; cout . flush (); continue ; } else { cout << \"! 2\" << endl ; cout . flush (); continue ; } } cout << \"! \" << l << endl ; cout . flush (); } }","title":"2021-02-08-2\u67088\u65e5\u9898\u89e3"},{"location":"problem/2021-02-08-2%E6%9C%888%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u5148\u8fdb\u884cLCA\u7b97\u6cd5\uff0c\u8ba1\u7b97\u51fa\u6bcf\u4e2a\u70b9\u7684\u6df1\u5ea6\u3001\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\u7b49\uff0c\u7136\u540e\u5bf9\u4e94\u4e2a\u70b9\uff08\u5206\u522b\u4e3as1,s2,s3,s4,s5\uff09\u8fdb\u884c\u5904\u7406\uff1a \u5c06\u7b2cs1\u52a0\u5165\u56fe\u4e2d\uff0c\u5982\u56fe\uff0c\u589e\u52a0\u7684\u6743\u503c\u4e3adis[s1] \u5c06s2\u52a0\u5165\u56fe\u4e2d\uff0c\u5047\u5982s1\u548cs2\u7684\u6700\u5c0f\u516c\u5171\u7956\u5148\u4e3afa1\u5373\u4e3alca(s1,s2)\uff0c\u5219\u589e\u52a0\u7684\u6743\u503c\u4e3adis[s2]-dis[fa1] \u5c06s3\u52a0\u5165\u56fe\u4e2d\uff0c\u5047\u8bbes1\u548cs3\u7684\u6700\u5c0f\u516c\u5171\u7956\u5148\u4e3afa2\uff0cs2\u548cs3\u7684\u6700\u5c0f\u516c\u5171\u6700\u5148\u4e3afa1\uff0c\u5047\u8bbefa1\u7684\u6df1\u5ea6\u5c0f\u4e8efa2\u7684\u6df1\u5ea6\uff0c\u5219\u589e\u52a0\u7684\u6743\u503c\u4e3adis[s3]-dis[fa2] \u91cd\u590d\u7b2c3\u8fc7\u7a0b\uff0c\u5c06s4,s5\u4e24\u4e2a\u70b9\u52a0\u5165\u5230\u56fe\u5f53\u4e2d\uff0c\u6700\u540e\u6743\u503c\u548c\u51cf\u53bb\u6240\u6709\u70b9\u7684\u6700\u5c0f\u516c\u5171\u7956\u5148\u5230\u6839\u8282\u70b91\u7684\u8ddd\u79bb\u5373\u4e3a\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-08-2%E6%9C%888%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#include <cstdio> #include <cstring> #include <algorithm> #include <bits/stdc++.h> using namespace std ; const int maxn = 1e5 + 500 ; struct node { int to , nex , w ; } road [ maxn * 2 ]; int n , q , cnt ; int pre [ maxn ][ 32 ], head [ maxn ], depth [ maxn ]; int dis [ maxn ]; void add ( int u , int v , int w ) { road [ cnt ]. to = v ; road [ cnt ]. w = w ; road [ cnt ]. nex = head [ u ]; head [ u ] = cnt ++ ; } void dfs ( int u , int fa ) { pre [ u ][ 0 ] = fa ; depth [ u ] = depth [ fa ] + 1 ; for ( int i = 1 ; ( 1 << i ) <= depth [ u ]; i ++ ) //\u500d\u589e pre [ u ][ i ] = pre [ pre [ u ][ i -1 ]][ i -1 ]; for ( int i = head [ u ]; ~ i ; i = road [ i ]. nex ) { int v = road [ i ]. to ; if ( v != fa ) { dis [ v ] = dis [ u ] + road [ i ]. w ; dfs ( v , u ); } } } int lca ( int u , int v ) { if ( depth [ u ] < depth [ v ]) { swap ( u , v ); } int i = -1 , j ; while (( 1 << ( i + 1 )) <= depth [ u ]) i ++ ; for ( j = i ; j >= 0 ; j -- ) { if ( depth [ u ] - ( 1 << j ) >= depth [ v ]) { u = pre [ u ][ j ]; } } if ( u == v ) return u ; for ( int j = i ; j >= 0 ; j -- ) { if ( pre [ u ][ j ] != pre [ v ][ j ]) { u = pre [ u ][ j ]; v = pre [ v ][ j ]; } } return pre [ u ][ 0 ]; } int main () { scanf ( \"%d\" , & n ); memset ( head , -1 , sizeof ( head )); memset ( depth , 0 , sizeof ( depth )); cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int u , v , w ; scanf ( \"%d %d %d\" , & u , & v , & w ); add ( u + 1 , v + 1 , w ); add ( v + 1 , u + 1 , w ); } dis [ 1 ] = 0 ; dfs ( 1 , 0 ); scanf ( \"%d\" , & q ); while ( q -- ) { int point [ 10 ] = { 0 }; for ( int i = 1 ; i <= 5 ; i ++ ) scanf ( \"%d\" , & point [ i ]), point [ i ] ++ ; int ans = 0 ; for ( int i = 1 ; i <= 5 ; i ++ ) { int dep = 1 ; for ( int j = 1 ; j < i ; j ++ ) { int fa = lca ( point [ i ], point [ j ]); if ( depth [ fa ] > depth [ dep ]) dep = fa ; } ans += dis [ point [ i ]]; ans -= dis [ dep ]; } int dep = point [ 1 ]; for ( int i = 1 ; i <= 5 ; i ++ ) dep = lca ( point [ i ], dep ); ans -= dis [ dep ]; cout << ans << endl ; } }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-08-2%E6%9C%888%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u8be5\u9898\u70b9\u6570\u8f83\u5c11\uff0c\u53ef\u4ee5\u76f4\u63a5\u66b4\u529b\u505a\uff0c\u4f46\u662fdfs\u4f1a\u8d85\u65f6\uff0c\u6539\u7528bfs\u5373\u53ef\uff0c\u8be6\u7ec6\u89c1\u4ee3\u7801\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-08-2%E6%9C%888%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; vector < ll > v [ 100500 ]; //\u5b58\u56fe\u7528 ll vis [ 5050 ] = { 0 }; ///\u8bb0\u5f55\u8ddd\u79bb\u7528 ll to [ 5050 ] = { 0 }; ///\u5230\u8be5\u70b9\u7684\u9053\u8def\u4e2a\u6570 ll sum_vis [ 5050 ] = { 0 }; ///bfs\u7edf\u8ba1\u7528 long double val_all [ 5050 ] = { 0 }; ///\u7edf\u8ba1\u6743\u503c\u7528 ll s , e ; ///\u5f00\u59cb\u7ed3\u5c3e ll sum_size = 0 ; struct node { ll pos , val ; }; void bfs () { queue < node > que ; que . push ({ s , 0 }); vis [ s ] = 0 ; to [ s ] = 1 ; while ( ! que . empty ()) { node now = que . front (); que . pop (); vis [ now . pos ] = min ( vis [ now . pos ], now . val ); for ( ll i : v [ now . pos ]) { if ( vis [ i ] > now . val + 1 ) { vis [ i ] = now . val + 1 ; to [ i ] = to [ now . pos ]; que . push ({ i , now . val + 1 }); } else if ( vis [ i ] == now . val + 1 ) { to [ i ] += to [ now . pos ]; } } } sum_size = to [ e ]; } void bfs1 () { queue < int > que ; que . push ( e ); while ( ! que . empty ()) { int now = que . front (); que . pop (); sum_vis [ vis [ now ]] += to [ now ]; for ( int i : v [ now ]) { if ( vis [ i ] == vis [ now ] -1 ) que . push ( i ); } } que . push ( e ); while ( ! que . empty ()) { int now = que . front (); que . pop (); val_all [ now ] += to [ now ] * 1.0 / sum_vis [ vis [ now ]]; ///\u5230\u8be5\u70b9\u8def\u7684\u6761\u6570\u5360\u76f8\u540c\u957f\u5ea6\u6761\u6570\u7684\u6bd4\u4f8b for ( int i : v [ now ]) { if ( vis [ i ] == vis [ now ] -1 ) { que . push ( i ); } } } } ll dfs ( ll k , ll sum ) { if ( k == e ) { if ( sum == vis [ k ]) sum_size ++ ; else if ( sum < vis [ k ]) vis [ k ] = sum , sum_size = 1 ; } vis [ k ] = min ( vis [ k ], sum ); for ( ll i : v [ k ]) { if ( vis [ i ] >= sum + 1 ) dfs ( i , sum + 1 ); } return 0 ; } long double dfs1 ( ll k , ll sum ) { if ( sum > vis [ e ]) return 0 ; if ( k == e ) { val_all [ k ] += 1.0 / sum_size ; return 1.0 / sum_size ; } long double val = 0 ; for ( ll i : v [ k ]) { if ( vis [ i ] == vis [ k ] + 1 ) val += dfs1 ( i , sum + 1 ); } val_all [ k ] += val ; return val ; } int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld\" , & s , & e ); v [ s ]. push_back ( e ); v [ e ]. push_back ( s ); } ll k ; scanf ( \"%lld\" , & k ); for ( ll i = 1 ; i <= k ; i ++ ) { scanf ( \"%lld%lld\" , & s , & e ); memset ( vis , inf , sizeof ( vis )); memset ( to , 0 , sizeof ( to )); memset ( sum_vis , 0 , sizeof ( sum_vis )); bfs (); //dfs(s,0) ///\u8fd9\u91ccdfs\u4e5f\u53ef\u4ee5\u5f97\u51fa\u6b63\u786e\u7b54\u6848\uff0c\u4f46\u662f\u65f6\u95f4\u4f1a\u8d85,qwq bfs1 (); //dfs1(s,0); ///bfs\u548cdfs\u5747\u53ef\uff0cbfs\u66f4\u5feb\u4e00\u70b9\uff0cdfs\u66f4\u597d\u7406\u89e3\u4e00\u70b9\uff0c\u8fd9\u91cc\u7528dfs\u65f6\u95f4\u4e0d\u4f1a\u8d85 } ll max1 = 0 ; for ( ll i = 0 ; i < n ; i ++ ) { if ( val_all [ i ] > val_all [ max1 ]) max1 = i ; } cout << max1 << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-08-2%E6%9C%888%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u8be5\u9898\u76ee\u53c2\u7167\u535a\u5ba2https://m-sea-blog.com/archives/2139\uff0c\u9644\u4e00\u5f20\u56fe\uff1a \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u53d6\u4f59\u540e\u7684\u7ed3\u679c\u4e3a\u5468\u671f\u4e3aa\u7684\u5468\u671f\u51fd\u6570\uff0c\u4efb\u53d6\u4e00\u70b9k\uff0c\u5982\u679c(2 * k)%a <= k%a\uff0c\u5219\u4e00\u5b9a\u6709k < a <= 2 * k\uff0c\u9884\u5148\u7f29\u5c0f\u8303\u56f4\u7136\u540e\u4e8c\u5206\u5373\u53ef\u5f97\u5230\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-08-2%E6%9C%888%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char query ( int x , int y ) { cout << \"? \" << x << \" \" << y << endl ; cout . flush (); char ans ; cin >> ans ; return ans ; } int main () { while ( 1 ) { string s ; cin >> s ; if ( s == \"end\" ) break ; ll l , r ; for ( ll i = 1 ;; i = i * 2 ) { l = i , r = min ( i * 2 ,( ll ) 2e9 ); char ans = query ( l , r ); if ( ans == 'x' ) { l = i , r = min ( i * 2 ,( ll ) 1e9 ); break ; } } while ( l < r ) { int mid = ( l + r ) / 2 ; char ans = query ( mid * 2 , mid ); if ( ans == 'x' ) r = mid ; else l = mid + 1 ; } if ( l == 2 ) { char ans = query ( 2 , 1 ); if ( ans == 'x' ) { cout << \"! 1\" << endl ; cout . flush (); continue ; } else { cout << \"! 2\" << endl ; cout . flush (); continue ; } } cout << \"! \" << l << endl ; cout . flush (); } }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"\u9898\u89e3 \u00b6 \u7528\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\u67d0\u4e00\u533a\u95f4\u7684\u6700\u5c0f\u503c\uff0c\u7136\u540e\u5bf9 (0,n-1) \u6bcf\u4e00\u4e2a\u6570\u8fdb\u884c\u67e5\u8be2\uff0c\u5b9a\u4f4d\u5230\u8be5\u6570\u6240\u5728\u7684\u6700\u5c0f\u533a\u95f4\uff08\u6ce8\u610f\u7279\u5224\u4e00\u4e2a\u6700\u5c0f\u503c\u5bf9\u5e94\u591a\u4e2a\u533a\u95f4\u8fd9\u79cd\u60c5\u51b5\uff09\uff0c\u7136\u540e\u5bf9\u8be5\u533a\u95f4\u7684\u6700\u5c0f\u503c\u7684 \u6700\u5c0f\u503c \u8fdb\u884c\u67e5\u8be2\uff0c\u5982\u679c\u8fd9\u4e2a\u533a\u95f4\u7684\u6700\u5c0f\u503c\u90fd\u6bd4\u8be5\u503c\u5927\uff0c\u5219\u8f93\u51fa-1\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll l , r , pos , min1 , add ; }; ll n , q ; node tree [ 400500 ] = { 0 }; struct node1 { ll l , r ; }; vector < node1 > v [ 100500 ]; ll num [ 100500 ] = { 0 }; void build ( ll t , ll l , ll r ) { tree [ t ]. pos = l ; tree [ t ]. l = l ; tree [ t ]. r = r ; tree [ t ]. min1 = -1 ; tree [ t ]. add = -1 ; if ( l == r ) return ; ll mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); return ; } void push_up ( ll p ) { if ( tree [ p * 2 ]. min1 < tree [ p * 2 + 1 ]. min1 ){ tree [ p ]. min1 = tree [ p * 2 ]. min1 ; tree [ p ]. pos = tree [ p * 2 ]. pos ; } else { tree [ p ]. min1 = tree [ p * 2 + 1 ]. min1 ; tree [ p ]. pos = tree [ p * 2 + 1 ]. pos ; } return ; } void push_down ( ll t ) { if ( tree [ t ]. add == -1 ) return ; tree [ 2 * t ]. add = max ( tree [ t ]. add , tree [ 2 * t ]. add ); ///\u6700\u5c0f\u503c\u4e2d\u53d6\u6700\u5927 tree [ 2 * t + 1 ]. add = max ( tree [ t ]. add , tree [ 2 * t + 1 ]. add ); tree [ 2 * t ]. min1 = max ( tree [ t ]. min1 , tree [ 2 * t ]. min1 ); tree [ 2 * t + 1 ]. min1 = max ( tree [ t ]. min1 , tree [ 2 * t + 1 ]. min1 ); tree [ t ]. add = -1 ; return ; } void update ( ll t , ll l , ll r , ll x ) { if ( l == tree [ t ]. l && r == tree [ t ]. r ) { tree [ t ]. add = max ( tree [ t ]. add , x ); tree [ t ]. min1 = max ( tree [ t ]. min1 , x ); return ; } push_down ( t ); ll mid = ( tree [ t ]. l + tree [ t ]. r ) / 2 ; if ( r <= mid ) update ( 2 * t , l , r , x ); else if ( l > mid ) update ( 2 * t + 1 , l , r , x ); else { update ( 2 * t , l , mid , x ); update ( 2 * t + 1 , mid + 1 , r , x ); } push_up ( t ); return ; } void update ( ll t , ll pos ) { if ( tree [ t ]. l == tree [ t ]. r ) { tree [ t ]. min1 = 1e9 ; return ; } push_down ( t ); ll mid = ( tree [ t ]. l + tree [ t ]. r ) / 2 ; if ( pos <= mid ) update ( 2 * t , pos ); if ( pos > mid ) update ( 2 * t + 1 , pos ); push_up ( t ); return ; } node query ( ll t , ll l , ll r ) { if ( tree [ t ]. l == l && tree [ t ]. r == r ) { return tree [ t ]; } push_down ( t ); ll mid = ( tree [ t ]. l + tree [ t ]. r ) / 2 ; if ( r <= mid ) return query ( 2 * t , l , r ); else if ( mid < l ) return query ( 2 * t + 1 , l , r ); else { node tree1 = query ( 2 * t , l , mid ); node tree2 = query ( 2 * t + 1 , mid + 1 , r ); if ( tree1 . min1 < tree2 . min1 ) return tree1 ; else return tree2 ; } } int main () { scanf ( \"%lld%lld\" , & n , & q ); build ( 1 , 1 , n ); for ( ll i = 1 ; i <= q ; i ++ ) { ll l , r , x ; scanf ( \"%lld%lld%lld\" , & l , & r , & x ); l ++ , r ++ , x ++ ; update ( 1 , l , r , x ); v [ x ]. push_back ({ l , r }); } ll flag = 1 ; for ( ll x = 1 ; x <= n && flag ; x ++ ) { ll l = 1 , r = n ; for ( int i = 0 ; i < v [ x ]. size (); i ++ ) { l = max ( l , v [ x ][ i ]. l ); r = min ( r , v [ x ][ i ]. r ); } if ( l > r ) ///\u4e00\u4e2a\u6700\u5c0f\u503c\u5bf9\u5e94\u591a\u4e2a\u533a\u95f4\u7684\u60c5\u51b5 { flag = 0 ; break ; } node ans = query ( 1 , l , r ); if ( ans . min1 > x ) { flag = 0 ; break ; } ll pos = ans . pos ; num [ pos ] = x -1 ; update ( 1 , pos ); } if ( ! flag ) { for ( ll i = 1 ; i <= n ; i ++ ) { printf ( \"-1 \" ); } printf ( \" \\n \" ); } else { for ( ll i = 1 ; i <= n ; i ++ ) { printf ( \"%d \" , num [ i ]); } printf ( \" \\n \" ); } return 0 ; } \u9898\u89e3 \u00b6 \u8def\u5f84\u53ef\u4ee5\u62fc\u51d1\u6210\u4e00\u4e2a\u957f\u65b9\u5f62\uff0c\u53ea\u9700\u8981\u66b4\u529b\u627e\u5230\u8fd9\u4e2a\u957f\u65b9\u5f62\u5373\u53ef\uff0c\u6ce8\u610f\u5982\u679c\u4e24\u4e2a\u70b9\u5728\u540c\u4e00\u6761\u76f4\u7ebf\u4e0a\u5219\u9700\u8981\u5c06\u4e24\u4e2a\u70b9\u9519\u5f00\u3002 \u4ee3\u7801 \u00b6 #include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; int x1 , x2 , y1 , y2 ; int px , py , dis = 0 ; int judge1 ( int x , int y ) { int dis1 = abs ( x1 - x ) + abs ( y1 - y ); if ( dis1 > dis ) px = x , py = y , dis = dis1 ; } int main () { scanf ( \"%d%d%d%d\" , & x1 , & y1 , & x2 , & y2 ); if ( x1 == x2 ) x1 ++ ; if ( y1 == y2 ) y1 ++ ; judge1 ( x2 + 1 , y2 + 1 ); judge1 ( x2 + 1 , y2 ); judge1 ( x2 + 1 , y2 -1 ); judge1 ( x2 , y2 + 1 ); judge1 ( x2 , y2 -1 ); judge1 ( x2 -1 , y2 + 1 ); judge1 ( x2 -1 , y2 ); judge1 ( x2 -1 , y2 -1 ); printf ( \"%d \\n \" , dis * 2 ); } \u9898\u89e3 \u00b6 \u6839\u636e\u9898\u610f\u76f4\u63a5\u6807\u8bb0\u6a21\u62df\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; char a [ 2000 ] = { 0 }; map < char , int > s ; map < int , int > k ; char b [ 2000 ][ 2000 ] = { 0 }; map < char , int > mp1 ; map < char , int > mp ; int main () { int n ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , a + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] == '*' ) k [ i ] = 1 ; else s [ a [ i ]] = 1 ; } int m ; scanf ( \"%d\" , & m ); int sum = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%s\" , b [ ++ sum ] + 1 ); int flag = 1 ; for ( int j = 1 ; j <= n && flag ; j ++ ) { if ( k [ j ] && s [ b [ sum ][ j ]]) flag = 0 ; else if ( ! k [ j ] && b [ sum ][ j ] != a [ j ]) flag = 0 ; } if ( ! flag ) sum -- ; } for ( int i = 1 ; i <= sum ; i ++ ) { mp . clear (); for ( int j = 1 ; j <= n ; j ++ ) { if ( k [ j ]) { if ( ! mp [ b [ i ][ j ]]) { mp [ b [ i ][ j ]] = 1 ; mp1 [ b [ i ][ j ]] ++ ; } } } } int ans = 0 ; for ( char i = 'a' ; i <= 'z' ; i ++ ) { if ( mp1 [ i ] == sum ) ans ++ ; } cout << ans << endl ; } \u9898\u89e3 \u00b6 \u5c06u\u66ff\u6362\u4e3aoo\uff0ckh\u66ff\u6362\u4e3ah\uff0c\u7136\u540e\u627e\u76f8\u540c\u7684\u5b57\u7b26\u4e32\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; char a [ 500 ][ 500 ] = { 0 }; int ans [ 500 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , a [ i ] + 1 ); } for ( int i = 1 ; i <= n ; i ++ ) { stack < char > s ; for ( int j = 1 ; a [ i ][ j ]; j ++ ) { if ( a [ i ][ j ] == 'u' ) { s . push ( 'o' ); s . push ( 'o' ); } else if ( a [ i ][ j ] == 'h' ) { while ( ! s . empty () && s . top () == 'k' ) s . pop (); s . push ( 'h' ); } else { s . push ( a [ i ][ j ]); } } int sum = 0 ; while ( ! s . empty ()) { a [ i ][ ++ sum ] = s . top (); s . pop (); } a [ i ][ ++ sum ] = '\\0' ; } int ans1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ans [ i ]) continue ; for ( int j = i + 1 ; j <= n ; j ++ ) { if ( strcmp ( a [ i ] + 1 , a [ j ] + 1 ) == 0 ) { ans [ j ] = 1 ; ans1 ++ ; } } } cout << n - ans1 << endl ; } \u9898\u89e3 \u00b6 \u627e\u6700\u5927\u76f8\u540c\u957f\u5ea6\u7684\u56de\u6587\u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u53d1\u73b0\u6784\u9020 abcba \u8fd9\u79cd\u5b57\u7b26\u4e32\uff08\u4e24\u8fb9\u4e3a\u80fd\u591f\u5339\u914d\u7684\u5b57\u6bcd\uff0c\u4e2d\u95f4\u4e3a\u4e0d\u80fd\u5339\u914d\u7684\uff09\u80fd\u591f\u6700\u5c0f\u7a0b\u5ea6\u7684\u51cf\u5c11\u5757\u6570\uff0c\u63d0\u9ad8\u957f\u5ea6\uff0c\u7528\u5806\u6808\u6765\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; char a [ 400500 ] = { 0 }; map < char , int > mp ; stack < char > s1 , s2 ; queue < char > que2 ; int main () { int n ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , a + 1 ); for ( int i = 1 ; i <= n ; i ++ ) mp [ a [ i ]] ++ ; for ( char i = 'a' ; i <= 'z' ; i ++ ) { if ( mp [ i ] % 2 == 1 ) que2 . push ( i ); for ( int j = 1 ; j <= mp [ i ] / 2 ; j ++ ) { s1 . push ( i ); s2 . push ( i ); } } for ( char i = '0' ; i <= '9' ; i ++ ) { if ( mp [ i ] % 2 == 1 ) que2 . push ( i ); for ( int j = 1 ; j <= mp [ i ] / 2 ; j ++ ) { s1 . push ( i ); s2 . push ( i ); } } for ( char i = 'A' ; i <= 'Z' ; i ++ ) { if ( mp [ i ] % 2 == 1 ) que2 . push ( i ); for ( int j = 1 ; j <= mp [ i ] / 2 ; j ++ ) { s1 . push ( i ); s2 . push ( i ); } } if ( que2 . size () == 0 ) { printf ( \"%d \\n \" , 1 ); stack < char > s ; while ( ! s1 . empty ()) s . push ( s1 . top ()), s1 . pop (); while ( ! s . empty ()) printf ( \"%c\" , s . top ()), s . pop (); while ( ! s2 . empty ()) printf ( \"%c\" , s2 . top ()), s2 . pop (); } else { while ( s1 . size () % que2 . size () != 0 ) { que2 . push ( s1 . top ()); s1 . pop (); que2 . push ( s2 . top ()); s2 . pop (); } printf ( \"%d \\n \" , que2 . size ()); int size1 = s1 . size () / que2 . size (); while ( ! que2 . empty ()) { stack < char > s ; for ( int i = 0 ; i < size1 ; i ++ ) s . push ( s1 . top ()), s1 . pop (); while ( ! s . empty ()) printf ( \"%c\" , s . top ()), s . pop (); printf ( \"%c\" , que2 . front ()), que2 . pop (); for ( int i = 0 ; i < size1 ; i ++ ) printf ( \"%c\" , s2 . top ()), s2 . pop (); printf ( \" \" ); } } } \u9898\u89e3 \u00b6 \u4e8c\u5206\u6700\u5927\u5dee\u503c\uff0c\u7136\u540e\u7528dp\u6765\u8fdb\u884ccheck() \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 300500 ] = { 0 }; int dp [ 300500 ] = { 0 }; int n , m ; int check ( ll k ) { for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 1 ; int last = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { while ( a [ i ] - a [ last ] > k ) last ++ ; for ( int j = last ; j + m <= i + 1 ; j ++ ) { if ( dp [ j -1 ]) { dp [ i ] = 1 ; break ; } else { last ++ ; } } } return dp [ n ]; } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); sort ( a + 1 , a + n + 1 ); ll l = 0 , r = 2e9 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( check ( mid )) r = mid ; else l = mid + 1 ; } cout << l << endl ; }","title":"2021-02-09-2\u67089\u65e5\u9898\u89e3"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u7528\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\u67d0\u4e00\u533a\u95f4\u7684\u6700\u5c0f\u503c\uff0c\u7136\u540e\u5bf9 (0,n-1) \u6bcf\u4e00\u4e2a\u6570\u8fdb\u884c\u67e5\u8be2\uff0c\u5b9a\u4f4d\u5230\u8be5\u6570\u6240\u5728\u7684\u6700\u5c0f\u533a\u95f4\uff08\u6ce8\u610f\u7279\u5224\u4e00\u4e2a\u6700\u5c0f\u503c\u5bf9\u5e94\u591a\u4e2a\u533a\u95f4\u8fd9\u79cd\u60c5\u51b5\uff09\uff0c\u7136\u540e\u5bf9\u8be5\u533a\u95f4\u7684\u6700\u5c0f\u503c\u7684 \u6700\u5c0f\u503c \u8fdb\u884c\u67e5\u8be2\uff0c\u5982\u679c\u8fd9\u4e2a\u533a\u95f4\u7684\u6700\u5c0f\u503c\u90fd\u6bd4\u8be5\u503c\u5927\uff0c\u5219\u8f93\u51fa-1\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll l , r , pos , min1 , add ; }; ll n , q ; node tree [ 400500 ] = { 0 }; struct node1 { ll l , r ; }; vector < node1 > v [ 100500 ]; ll num [ 100500 ] = { 0 }; void build ( ll t , ll l , ll r ) { tree [ t ]. pos = l ; tree [ t ]. l = l ; tree [ t ]. r = r ; tree [ t ]. min1 = -1 ; tree [ t ]. add = -1 ; if ( l == r ) return ; ll mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); return ; } void push_up ( ll p ) { if ( tree [ p * 2 ]. min1 < tree [ p * 2 + 1 ]. min1 ){ tree [ p ]. min1 = tree [ p * 2 ]. min1 ; tree [ p ]. pos = tree [ p * 2 ]. pos ; } else { tree [ p ]. min1 = tree [ p * 2 + 1 ]. min1 ; tree [ p ]. pos = tree [ p * 2 + 1 ]. pos ; } return ; } void push_down ( ll t ) { if ( tree [ t ]. add == -1 ) return ; tree [ 2 * t ]. add = max ( tree [ t ]. add , tree [ 2 * t ]. add ); ///\u6700\u5c0f\u503c\u4e2d\u53d6\u6700\u5927 tree [ 2 * t + 1 ]. add = max ( tree [ t ]. add , tree [ 2 * t + 1 ]. add ); tree [ 2 * t ]. min1 = max ( tree [ t ]. min1 , tree [ 2 * t ]. min1 ); tree [ 2 * t + 1 ]. min1 = max ( tree [ t ]. min1 , tree [ 2 * t + 1 ]. min1 ); tree [ t ]. add = -1 ; return ; } void update ( ll t , ll l , ll r , ll x ) { if ( l == tree [ t ]. l && r == tree [ t ]. r ) { tree [ t ]. add = max ( tree [ t ]. add , x ); tree [ t ]. min1 = max ( tree [ t ]. min1 , x ); return ; } push_down ( t ); ll mid = ( tree [ t ]. l + tree [ t ]. r ) / 2 ; if ( r <= mid ) update ( 2 * t , l , r , x ); else if ( l > mid ) update ( 2 * t + 1 , l , r , x ); else { update ( 2 * t , l , mid , x ); update ( 2 * t + 1 , mid + 1 , r , x ); } push_up ( t ); return ; } void update ( ll t , ll pos ) { if ( tree [ t ]. l == tree [ t ]. r ) { tree [ t ]. min1 = 1e9 ; return ; } push_down ( t ); ll mid = ( tree [ t ]. l + tree [ t ]. r ) / 2 ; if ( pos <= mid ) update ( 2 * t , pos ); if ( pos > mid ) update ( 2 * t + 1 , pos ); push_up ( t ); return ; } node query ( ll t , ll l , ll r ) { if ( tree [ t ]. l == l && tree [ t ]. r == r ) { return tree [ t ]; } push_down ( t ); ll mid = ( tree [ t ]. l + tree [ t ]. r ) / 2 ; if ( r <= mid ) return query ( 2 * t , l , r ); else if ( mid < l ) return query ( 2 * t + 1 , l , r ); else { node tree1 = query ( 2 * t , l , mid ); node tree2 = query ( 2 * t + 1 , mid + 1 , r ); if ( tree1 . min1 < tree2 . min1 ) return tree1 ; else return tree2 ; } } int main () { scanf ( \"%lld%lld\" , & n , & q ); build ( 1 , 1 , n ); for ( ll i = 1 ; i <= q ; i ++ ) { ll l , r , x ; scanf ( \"%lld%lld%lld\" , & l , & r , & x ); l ++ , r ++ , x ++ ; update ( 1 , l , r , x ); v [ x ]. push_back ({ l , r }); } ll flag = 1 ; for ( ll x = 1 ; x <= n && flag ; x ++ ) { ll l = 1 , r = n ; for ( int i = 0 ; i < v [ x ]. size (); i ++ ) { l = max ( l , v [ x ][ i ]. l ); r = min ( r , v [ x ][ i ]. r ); } if ( l > r ) ///\u4e00\u4e2a\u6700\u5c0f\u503c\u5bf9\u5e94\u591a\u4e2a\u533a\u95f4\u7684\u60c5\u51b5 { flag = 0 ; break ; } node ans = query ( 1 , l , r ); if ( ans . min1 > x ) { flag = 0 ; break ; } ll pos = ans . pos ; num [ pos ] = x -1 ; update ( 1 , pos ); } if ( ! flag ) { for ( ll i = 1 ; i <= n ; i ++ ) { printf ( \"-1 \" ); } printf ( \" \\n \" ); } else { for ( ll i = 1 ; i <= n ; i ++ ) { printf ( \"%d \" , num [ i ]); } printf ( \" \\n \" ); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u8def\u5f84\u53ef\u4ee5\u62fc\u51d1\u6210\u4e00\u4e2a\u957f\u65b9\u5f62\uff0c\u53ea\u9700\u8981\u66b4\u529b\u627e\u5230\u8fd9\u4e2a\u957f\u65b9\u5f62\u5373\u53ef\uff0c\u6ce8\u610f\u5982\u679c\u4e24\u4e2a\u70b9\u5728\u540c\u4e00\u6761\u76f4\u7ebf\u4e0a\u5219\u9700\u8981\u5c06\u4e24\u4e2a\u70b9\u9519\u5f00\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"#include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; int x1 , x2 , y1 , y2 ; int px , py , dis = 0 ; int judge1 ( int x , int y ) { int dis1 = abs ( x1 - x ) + abs ( y1 - y ); if ( dis1 > dis ) px = x , py = y , dis = dis1 ; } int main () { scanf ( \"%d%d%d%d\" , & x1 , & y1 , & x2 , & y2 ); if ( x1 == x2 ) x1 ++ ; if ( y1 == y2 ) y1 ++ ; judge1 ( x2 + 1 , y2 + 1 ); judge1 ( x2 + 1 , y2 ); judge1 ( x2 + 1 , y2 -1 ); judge1 ( x2 , y2 + 1 ); judge1 ( x2 , y2 -1 ); judge1 ( x2 -1 , y2 + 1 ); judge1 ( x2 -1 , y2 ); judge1 ( x2 -1 , y2 -1 ); printf ( \"%d \\n \" , dis * 2 ); }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u6839\u636e\u9898\u610f\u76f4\u63a5\u6807\u8bb0\u6a21\u62df\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"#include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; char a [ 2000 ] = { 0 }; map < char , int > s ; map < int , int > k ; char b [ 2000 ][ 2000 ] = { 0 }; map < char , int > mp1 ; map < char , int > mp ; int main () { int n ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , a + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] == '*' ) k [ i ] = 1 ; else s [ a [ i ]] = 1 ; } int m ; scanf ( \"%d\" , & m ); int sum = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%s\" , b [ ++ sum ] + 1 ); int flag = 1 ; for ( int j = 1 ; j <= n && flag ; j ++ ) { if ( k [ j ] && s [ b [ sum ][ j ]]) flag = 0 ; else if ( ! k [ j ] && b [ sum ][ j ] != a [ j ]) flag = 0 ; } if ( ! flag ) sum -- ; } for ( int i = 1 ; i <= sum ; i ++ ) { mp . clear (); for ( int j = 1 ; j <= n ; j ++ ) { if ( k [ j ]) { if ( ! mp [ b [ i ][ j ]]) { mp [ b [ i ][ j ]] = 1 ; mp1 [ b [ i ][ j ]] ++ ; } } } } int ans = 0 ; for ( char i = 'a' ; i <= 'z' ; i ++ ) { if ( mp1 [ i ] == sum ) ans ++ ; } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"\u5c06u\u66ff\u6362\u4e3aoo\uff0ckh\u66ff\u6362\u4e3ah\uff0c\u7136\u540e\u627e\u76f8\u540c\u7684\u5b57\u7b26\u4e32\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"#include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; char a [ 500 ][ 500 ] = { 0 }; int ans [ 500 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , a [ i ] + 1 ); } for ( int i = 1 ; i <= n ; i ++ ) { stack < char > s ; for ( int j = 1 ; a [ i ][ j ]; j ++ ) { if ( a [ i ][ j ] == 'u' ) { s . push ( 'o' ); s . push ( 'o' ); } else if ( a [ i ][ j ] == 'h' ) { while ( ! s . empty () && s . top () == 'k' ) s . pop (); s . push ( 'h' ); } else { s . push ( a [ i ][ j ]); } } int sum = 0 ; while ( ! s . empty ()) { a [ i ][ ++ sum ] = s . top (); s . pop (); } a [ i ][ ++ sum ] = '\\0' ; } int ans1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ans [ i ]) continue ; for ( int j = i + 1 ; j <= n ; j ++ ) { if ( strcmp ( a [ i ] + 1 , a [ j ] + 1 ) == 0 ) { ans [ j ] = 1 ; ans1 ++ ; } } } cout << n - ans1 << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"\u627e\u6700\u5927\u76f8\u540c\u957f\u5ea6\u7684\u56de\u6587\u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u53d1\u73b0\u6784\u9020 abcba \u8fd9\u79cd\u5b57\u7b26\u4e32\uff08\u4e24\u8fb9\u4e3a\u80fd\u591f\u5339\u914d\u7684\u5b57\u6bcd\uff0c\u4e2d\u95f4\u4e3a\u4e0d\u80fd\u5339\u914d\u7684\uff09\u80fd\u591f\u6700\u5c0f\u7a0b\u5ea6\u7684\u51cf\u5c11\u5757\u6570\uff0c\u63d0\u9ad8\u957f\u5ea6\uff0c\u7528\u5806\u6808\u6765\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_10","text":"#include <stdio.h> #include <math.h> #include <bits/stdc++.h> using namespace std ; char a [ 400500 ] = { 0 }; map < char , int > mp ; stack < char > s1 , s2 ; queue < char > que2 ; int main () { int n ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , a + 1 ); for ( int i = 1 ; i <= n ; i ++ ) mp [ a [ i ]] ++ ; for ( char i = 'a' ; i <= 'z' ; i ++ ) { if ( mp [ i ] % 2 == 1 ) que2 . push ( i ); for ( int j = 1 ; j <= mp [ i ] / 2 ; j ++ ) { s1 . push ( i ); s2 . push ( i ); } } for ( char i = '0' ; i <= '9' ; i ++ ) { if ( mp [ i ] % 2 == 1 ) que2 . push ( i ); for ( int j = 1 ; j <= mp [ i ] / 2 ; j ++ ) { s1 . push ( i ); s2 . push ( i ); } } for ( char i = 'A' ; i <= 'Z' ; i ++ ) { if ( mp [ i ] % 2 == 1 ) que2 . push ( i ); for ( int j = 1 ; j <= mp [ i ] / 2 ; j ++ ) { s1 . push ( i ); s2 . push ( i ); } } if ( que2 . size () == 0 ) { printf ( \"%d \\n \" , 1 ); stack < char > s ; while ( ! s1 . empty ()) s . push ( s1 . top ()), s1 . pop (); while ( ! s . empty ()) printf ( \"%c\" , s . top ()), s . pop (); while ( ! s2 . empty ()) printf ( \"%c\" , s2 . top ()), s2 . pop (); } else { while ( s1 . size () % que2 . size () != 0 ) { que2 . push ( s1 . top ()); s1 . pop (); que2 . push ( s2 . top ()); s2 . pop (); } printf ( \"%d \\n \" , que2 . size ()); int size1 = s1 . size () / que2 . size (); while ( ! que2 . empty ()) { stack < char > s ; for ( int i = 0 ; i < size1 ; i ++ ) s . push ( s1 . top ()), s1 . pop (); while ( ! s . empty ()) printf ( \"%c\" , s . top ()), s . pop (); printf ( \"%c\" , que2 . front ()), que2 . pop (); for ( int i = 0 ; i < size1 ; i ++ ) printf ( \"%c\" , s2 . top ()), s2 . pop (); printf ( \" \" ); } } }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_11","text":"\u4e8c\u5206\u6700\u5927\u5dee\u503c\uff0c\u7136\u540e\u7528dp\u6765\u8fdb\u884ccheck()","title":"\u9898\u89e3"},{"location":"problem/2021-02-09-2%E6%9C%889%E6%97%A5%E9%A2%98%E8%A7%A3/#_12","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 300500 ] = { 0 }; int dp [ 300500 ] = { 0 }; int n , m ; int check ( ll k ) { for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 1 ; int last = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { while ( a [ i ] - a [ last ] > k ) last ++ ; for ( int j = last ; j + m <= i + 1 ; j ++ ) { if ( dp [ j -1 ]) { dp [ i ] = 1 ; break ; } else { last ++ ; } } } return dp [ n ]; } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); sort ( a + 1 , a + n + 1 ); ll l = 0 , r = 2e9 ; while ( l < r ) { ll mid = ( l + r ) / 2 ; if ( check ( mid )) r = mid ; else l = mid + 1 ; } cout << l << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/","text":"\u4e2d\u56fd\u77f3\u6cb9\u5927\u5b66\u4e13\u7528\u8bfe\u8868 \u00b6 \u7efc\u8ff0 \u00b6 \u4ee3\u7801\u5206\u4e3a\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u7aef\u4e24\u90e8\u5206\uff0c\u5ba2\u6237\u7aef\u4e3aJava\u5f00\u53d1\u7684\u5b89\u5353app\uff0c\u9879\u76ee\u5730\u5740\u4e3ahttps://github.com/WCX1024979076/upc_course_schedule\uff1b\u670d\u52a1\u7aef\u4e3apython\u5f00\u53d1\u7684qq\u673a\u5668\u4eba\uff0c\u9879\u76ee\u5730\u5740\u4e3ahttps://github.com/WCX1024979076/upc_course_schedule_service \u5ba2\u6237\u7aef\u4ee3\u7801\u6ce8\u89e3 \u00b6 \u4ee3\u7801\u7ed3\u6784\u56fe \u00b6 \u53c2\u8003\u4e8e\uff1a \u00b6 \u8bfe\u8868\u63d0\u9192app \u754c\u9762\u8df3\u8f6c \u8bfe\u8868ui U\u8bfe\u8868 \u670d\u52a1\u7aef\u4ee3\u7801\u6ce8\u89e3 \u00b6 \u670d\u52a1\u7aef\u4ee3\u7801\u7ed3\u6784\u56fe \u00b6 \u6ce8\uff1a\u8fd9\u91cc\u8fdb\u5c55\u793a\u8bfe\u8868\u63d0\u9192\u6a21\u5757\uff0c\u5176\u4f59\u8bf7\u53c2\u7167https://github.com/beiyuouo/plugins-for-nonebot2 \u53c2\u8003\u4e8e\uff1a \u00b6 https://github.com/beiyuouo/plugins-for-nonebot2","title":"2021-02-12-\u5b89\u5353\u8bfe\u8868\u5ba2\u6237\u7aef+\u670d\u52a1\u7aef\u6ce8\u89e3"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_1","text":"","title":"\u4e2d\u56fd\u77f3\u6cb9\u5927\u5b66\u4e13\u7528\u8bfe\u8868"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_2","text":"\u4ee3\u7801\u5206\u4e3a\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u7aef\u4e24\u90e8\u5206\uff0c\u5ba2\u6237\u7aef\u4e3aJava\u5f00\u53d1\u7684\u5b89\u5353app\uff0c\u9879\u76ee\u5730\u5740\u4e3ahttps://github.com/WCX1024979076/upc_course_schedule\uff1b\u670d\u52a1\u7aef\u4e3apython\u5f00\u53d1\u7684qq\u673a\u5668\u4eba\uff0c\u9879\u76ee\u5730\u5740\u4e3ahttps://github.com/WCX1024979076/upc_course_schedule_service","title":"\u7efc\u8ff0"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_3","text":"","title":"\u5ba2\u6237\u7aef\u4ee3\u7801\u6ce8\u89e3"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_4","text":"","title":"\u4ee3\u7801\u7ed3\u6784\u56fe"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_5","text":"\u8bfe\u8868\u63d0\u9192app \u754c\u9762\u8df3\u8f6c \u8bfe\u8868ui U\u8bfe\u8868","title":"\u53c2\u8003\u4e8e\uff1a"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_6","text":"","title":"\u670d\u52a1\u7aef\u4ee3\u7801\u6ce8\u89e3"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_7","text":"\u6ce8\uff1a\u8fd9\u91cc\u8fdb\u5c55\u793a\u8bfe\u8868\u63d0\u9192\u6a21\u5757\uff0c\u5176\u4f59\u8bf7\u53c2\u7167https://github.com/beiyuouo/plugins-for-nonebot2","title":"\u670d\u52a1\u7aef\u4ee3\u7801\u7ed3\u6784\u56fe"},{"location":"problem/2021-02-12-%E5%AE%89%E5%8D%93%E8%AF%BE%E8%A1%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E8%A7%A3/#_8","text":"https://github.com/beiyuouo/plugins-for-nonebot2","title":"\u53c2\u8003\u4e8e\uff1a"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"A\u9898 \u00b6 \u9898\u89e3 \u00b6 \u7ed9\u9664\u6307\u5b9a\u4e0b\u6807\u4ee5\u5916\u7684\u6570\u505a\u52a0\u6cd5\uff0c\u76f8\u5f53\u4e8e\u7ed9\u8fd9\u4e2a\u6570\u505a\u51cf\u6cd5\uff0c\u6240\u4ee5\u5c06\u8fd9\u4e9b\u6570\u5168\u53d8\u4e3a0\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); printf ( \"%d \\n \" , n ); for ( int i = 1 ; i <= n ; i ++ ) printf ( \"%d \" , i ); printf ( \" \\n \" ); } return 0 ; } B\u9898 \u00b6 \u9898\u89e3 \u00b6 \u6539\u53d8\u76f8\u90bb\u4e24\u4e2a\u6570\u7684\u6b63\u8d1f\u53f7\uff0c\u6c42\u6c42\u548c\u540e\u7684\u6700\u5927\u503c\uff0c\u53ef\u4ee5\u53d1\u73b0\uff0c\u5982\u679c\u6709\u5076\u6570\u4e2a\u8d1f\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u5168\u90e8\u8f6c\u4e3a\u6b63\u6570\uff0c\u5982\u679c\u6709\u5947\u6570\u4e2a\u8d1f\u6570\uff0c\u5219\u4e00\u5b9a\u4f1a\u6709\u4e00\u4e2a\u8d1f\u6570\uff0c\u5c06\u8fd9\u4e2a\u8d1f\u6570\u63a7\u5236\u4e3a\u6700\u5c0f\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 30 ][ 30 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); int sum = 0 , min1 = 99999999 , ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]), ans += ( int ) abs ( a [ i ][ j ]); if ( a [ i ][ j ] < 0 ) sum ++ ; min1 = min ( min1 ,( int ) fabs ( a [ i ][ j ])); } } if ( sum % 2 == 0 ) printf ( \"%d \\n \" , ans ); else { ans -= 2 * min1 ; printf ( \"%d \\n \" , ans ); } } return 0 ; } C\u9898 \u00b6 \u9898\u89e3 \u00b6 \u53ef\u4ee5\u53d1\u73b0\u5982\u679c\u539f\u6570\u7ec4\u4e2d\u6709\u5927\u4e8eW/2\u4e14\u5c0f\u4e8eW\u7684\u6570\u65f6\u53ef\u4ee5\u76f4\u63a5\u5c06\u5176\u8f93\u51fa\uff0c\u53cd\u4e4b\u5219\u6392\u5e8f\u540e\u4ece\u5c0f\u5230\u5927\u76f8\u52a0\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll n , val ; }; node a [ 200500 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); ll mid = m / 2 ; if ( m % 2 != 0 ) mid ++ ; ll flag = -1 ; for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]. val ); a [ i ]. n = i ; if ( a [ i ]. val >= mid && a [ i ]. val <= m ) flag = i ; } if ( flag != -1 ) { printf ( \"1 \\n %lld \\n \" , flag ); continue ; } sort ( a + 1 , a + n + 1 ,[]( node a , node b ){ return a . val < b . val ;}); ll sum = 0 ; flag = -1 ; for ( ll i = 1 ; i <= n ; i ++ ) { sum += a [ i ]. val ; if ( sum >= mid && sum <= m ) { flag = i ; break ; } if ( sum > m ) break ; } if ( flag != -1 ) { printf ( \"%lld \\n \" , flag ); for ( ll i = 1 ; i <= flag ; i ++ ) { printf ( \"%lld \" , a [ i ]. n ); } printf ( \" \\n \" ); } else { printf ( \"-1 \\n \" ); } } return 0 ; } D\u9898 \u00b6 \u9898\u89e3 \u00b6 \u52a8\u6001\u89c4\u5212\uff0cdp[i][j]\u4ee3\u8868\u6700\u540e\u4e00\u4e2a\u5b57\u6bcd\u4e3aa[i]\u548cb[j]\u65f6\u7684\u6700\u5927\u503c\uff0c\u5219\u53ef\u4ee5\u5f97\u5230\u4ee5\u4e0b\u9012\u63a8\u516c\u5f0f if a[i]==b[j] : \u200b dp[i][j]=max(dp[i-1][j-1]+2,dp[i][j]) \\\\\u76f8\u540c\u65f6LSA\u52a01\uff0c\u540c\u65f6\u4e24\u4e2a\u4e32\u7684\u957f\u5ea6\u589e\u52a01 else : \u200b dp[i][j]=max(dp[i][j-1]-1,dp[i-1][j]-1) \\\\\u4e0d\u540c\u65f6\u53ea\u80fd\u7531\u4e24\u8fb9\u8f6c\u79fb\u8fc7\u6765\uff0c\u5e76\u4e14\u957f\u5ea6\u52a01 \u5176\u4e2ddp[i][j]\u6700\u5c0f\u4e3a0\uff0c\u6700\u540e\u53d6\u6700\u5927\u503c\u5373\u4e3a\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int dp [ 5050 ][ 5050 ] = { 0 }; char a [ 5050 ] = { 0 }; char b [ 5050 ] = { 0 }; int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); scanf ( \"%s%s\" , a + 1 , b + 1 ); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ] == b [ j ]) dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i -1 ][ j -1 ] + 2 ); else dp [ i ][ j ] = max ( dp [ i ][ j -1 ], dp [ i -1 ][ j ]) -1 ; dp [ i ][ j ] = max ( dp [ i ][ j ], 0 ); } } int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { max1 = max ( max1 , dp [ i ][ j ]); } } printf ( \"%d \\n \" , max1 ); return 0 ; } H\u9898 \u00b6 \u9898\u89e3 \u00b6 \u5947\u5076\u77e9\u9635\uff08\u6bd4\u8d5b\u65f6\u5dee\u4e00\u70b9\u60f3\u51fa\uff0c\u4f46\u662f\u8fd8\u5dee\u4e00\u70b9\u70b9\uff0c\u989d\uff09 \u53ef\u4ee5\u53d1\u73b0\u5982\u679c\u63a7\u5236\u6807\u8bb0\u7684\u70b9\u4e0e\u5468\u56f4\u7684\u70b9\u6570\u503c\u4e0d\u540c\u65f6\u5373\u53ef\u6ee1\u8db3\u9898\u76ee\u7684\u8981\u6c42\uff08\u6bcf\u5bf9\u76f8\u90bb\u7684\u70b9\u6570\u503c\u5404\u4e0d\u76f8\u540c\uff09\u3002 \u5bb9\u6613\u53d1\u73b0\u8fd9\u4e9b\u6807\u6ce8\u7684\u70b9\u6a2a\u7eb5\u5750\u6807\u4e4b\u548c\u5747\u4e3a\u5076\u6570\uff0c\u5176\u4f59\u672a\u6807\u6ce8\u7684\u70b9\u548c\u5747\u4e3a\u5947\u6570\u3002 \u8fd9\u662f\u6211\u4eec\u53ea\u9700\u8981\u63a7\u5236\u6807\u6ce8\u7684\u70b9\u6240\u5bf9\u5e94\u7684\u6570\u503c\u5747\u4e3a\u5076\u6570\uff0c\u672a\u6807\u8bb0\u70b9\u7684\u6570\u503c\u5747\u4e3a\u5947\u6570\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5b9e\u73b0\u5404\u4e0d\u76f8\u540c\u4e86\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 200 ][ 200 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]); } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if (( i + j ) % 2 != a [ i ][ j ] % 2 ) a [ i ][ j ] ++ ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { printf ( \"%d \" , a [ i ][ j ]); } printf ( \" \\n \" ); } } return 0 ; }","title":"2021-02-16-2\u670816\u65e5\u9898\u89e3"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#a","text":"","title":"A\u9898"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u7ed9\u9664\u6307\u5b9a\u4e0b\u6807\u4ee5\u5916\u7684\u6570\u505a\u52a0\u6cd5\uff0c\u76f8\u5f53\u4e8e\u7ed9\u8fd9\u4e2a\u6570\u505a\u51cf\u6cd5\uff0c\u6240\u4ee5\u5c06\u8fd9\u4e9b\u6570\u5168\u53d8\u4e3a0\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); printf ( \"%d \\n \" , n ); for ( int i = 1 ; i <= n ; i ++ ) printf ( \"%d \" , i ); printf ( \" \\n \" ); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#b","text":"","title":"B\u9898"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u6539\u53d8\u76f8\u90bb\u4e24\u4e2a\u6570\u7684\u6b63\u8d1f\u53f7\uff0c\u6c42\u6c42\u548c\u540e\u7684\u6700\u5927\u503c\uff0c\u53ef\u4ee5\u53d1\u73b0\uff0c\u5982\u679c\u6709\u5076\u6570\u4e2a\u8d1f\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u5168\u90e8\u8f6c\u4e3a\u6b63\u6570\uff0c\u5982\u679c\u6709\u5947\u6570\u4e2a\u8d1f\u6570\uff0c\u5219\u4e00\u5b9a\u4f1a\u6709\u4e00\u4e2a\u8d1f\u6570\uff0c\u5c06\u8fd9\u4e2a\u8d1f\u6570\u63a7\u5236\u4e3a\u6700\u5c0f\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 30 ][ 30 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); int sum = 0 , min1 = 99999999 , ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]), ans += ( int ) abs ( a [ i ][ j ]); if ( a [ i ][ j ] < 0 ) sum ++ ; min1 = min ( min1 ,( int ) fabs ( a [ i ][ j ])); } } if ( sum % 2 == 0 ) printf ( \"%d \\n \" , ans ); else { ans -= 2 * min1 ; printf ( \"%d \\n \" , ans ); } } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#c","text":"","title":"C\u9898"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u53ef\u4ee5\u53d1\u73b0\u5982\u679c\u539f\u6570\u7ec4\u4e2d\u6709\u5927\u4e8eW/2\u4e14\u5c0f\u4e8eW\u7684\u6570\u65f6\u53ef\u4ee5\u76f4\u63a5\u5c06\u5176\u8f93\u51fa\uff0c\u53cd\u4e4b\u5219\u6392\u5e8f\u540e\u4ece\u5c0f\u5230\u5927\u76f8\u52a0\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll n , val ; }; node a [ 200500 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); ll mid = m / 2 ; if ( m % 2 != 0 ) mid ++ ; ll flag = -1 ; for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]. val ); a [ i ]. n = i ; if ( a [ i ]. val >= mid && a [ i ]. val <= m ) flag = i ; } if ( flag != -1 ) { printf ( \"1 \\n %lld \\n \" , flag ); continue ; } sort ( a + 1 , a + n + 1 ,[]( node a , node b ){ return a . val < b . val ;}); ll sum = 0 ; flag = -1 ; for ( ll i = 1 ; i <= n ; i ++ ) { sum += a [ i ]. val ; if ( sum >= mid && sum <= m ) { flag = i ; break ; } if ( sum > m ) break ; } if ( flag != -1 ) { printf ( \"%lld \\n \" , flag ); for ( ll i = 1 ; i <= flag ; i ++ ) { printf ( \"%lld \" , a [ i ]. n ); } printf ( \" \\n \" ); } else { printf ( \"-1 \\n \" ); } } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#d","text":"","title":"D\u9898"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"\u52a8\u6001\u89c4\u5212\uff0cdp[i][j]\u4ee3\u8868\u6700\u540e\u4e00\u4e2a\u5b57\u6bcd\u4e3aa[i]\u548cb[j]\u65f6\u7684\u6700\u5927\u503c\uff0c\u5219\u53ef\u4ee5\u5f97\u5230\u4ee5\u4e0b\u9012\u63a8\u516c\u5f0f if a[i]==b[j] : \u200b dp[i][j]=max(dp[i-1][j-1]+2,dp[i][j]) \\\\\u76f8\u540c\u65f6LSA\u52a01\uff0c\u540c\u65f6\u4e24\u4e2a\u4e32\u7684\u957f\u5ea6\u589e\u52a01 else : \u200b dp[i][j]=max(dp[i][j-1]-1,dp[i-1][j]-1) \\\\\u4e0d\u540c\u65f6\u53ea\u80fd\u7531\u4e24\u8fb9\u8f6c\u79fb\u8fc7\u6765\uff0c\u5e76\u4e14\u957f\u5ea6\u52a01 \u5176\u4e2ddp[i][j]\u6700\u5c0f\u4e3a0\uff0c\u6700\u540e\u53d6\u6700\u5927\u503c\u5373\u4e3a\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int dp [ 5050 ][ 5050 ] = { 0 }; char a [ 5050 ] = { 0 }; char b [ 5050 ] = { 0 }; int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); scanf ( \"%s%s\" , a + 1 , b + 1 ); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ] == b [ j ]) dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i -1 ][ j -1 ] + 2 ); else dp [ i ][ j ] = max ( dp [ i ][ j -1 ], dp [ i -1 ][ j ]) -1 ; dp [ i ][ j ] = max ( dp [ i ][ j ], 0 ); } } int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { max1 = max ( max1 , dp [ i ][ j ]); } } printf ( \"%d \\n \" , max1 ); return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#h","text":"","title":"H\u9898"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"\u5947\u5076\u77e9\u9635\uff08\u6bd4\u8d5b\u65f6\u5dee\u4e00\u70b9\u60f3\u51fa\uff0c\u4f46\u662f\u8fd8\u5dee\u4e00\u70b9\u70b9\uff0c\u989d\uff09 \u53ef\u4ee5\u53d1\u73b0\u5982\u679c\u63a7\u5236\u6807\u8bb0\u7684\u70b9\u4e0e\u5468\u56f4\u7684\u70b9\u6570\u503c\u4e0d\u540c\u65f6\u5373\u53ef\u6ee1\u8db3\u9898\u76ee\u7684\u8981\u6c42\uff08\u6bcf\u5bf9\u76f8\u90bb\u7684\u70b9\u6570\u503c\u5404\u4e0d\u76f8\u540c\uff09\u3002 \u5bb9\u6613\u53d1\u73b0\u8fd9\u4e9b\u6807\u6ce8\u7684\u70b9\u6a2a\u7eb5\u5750\u6807\u4e4b\u548c\u5747\u4e3a\u5076\u6570\uff0c\u5176\u4f59\u672a\u6807\u6ce8\u7684\u70b9\u548c\u5747\u4e3a\u5947\u6570\u3002 \u8fd9\u662f\u6211\u4eec\u53ea\u9700\u8981\u63a7\u5236\u6807\u6ce8\u7684\u70b9\u6240\u5bf9\u5e94\u7684\u6570\u503c\u5747\u4e3a\u5076\u6570\uff0c\u672a\u6807\u8bb0\u70b9\u7684\u6570\u503c\u5747\u4e3a\u5947\u6570\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5b9e\u73b0\u5404\u4e0d\u76f8\u540c\u4e86\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-16-2%E6%9C%8816%E6%97%A5%E9%A2%98%E8%A7%A3/#_10","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 200 ][ 200 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]); } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if (( i + j ) % 2 != a [ i ][ j ] % 2 ) a [ i ][ j ] ++ ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { printf ( \"%d \" , a [ i ][ j ]); } printf ( \" \\n \" ); } } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"A\u9898 \u00b6 \u9898\u89e3 \u00b6 \u6570\u636e\u91cf\u6bd4\u8f83\u5c11\uff0c\u66b4\u529b\u505a\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int a [ 4 ][ 1000 ] = { 0 }; int p [ 2000 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ 1 ][ i ]); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ 2 ][ i ]); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ 3 ][ i ]); for ( int i = 1 ; i <= n ; i ++ ) { if ( i != n ) { for ( int j = 1 ; j <= 3 ; j ++ ) { if ( a [ j ][ i ] != p [ i -1 ]) { p [ i ] = a [ j ][ i ]; break ; } } } else { for ( int j = 1 ; j <= 3 ; j ++ ) { if ( a [ j ][ i ] != p [ i -1 ] && a [ j ][ i ] != p [ 1 ]) { p [ i ] = a [ j ][ i ]; break ; } } } } for ( int i = 1 ; i <= n ; i ++ ) printf ( \"%d \" , p [ i ]); printf ( \" \\n \" ); } return 0 ; } B\u9898 \u00b6 \u9898\u89e3 \u00b6 \u627e\u89c4\u5f8b\uff0c\u5bb9\u6613\u53d1\u73b0b\u6570\u7ec4\u7684\u6700\u5c11\u4e2a\u6570\u548ca\u6570\u7ec4\u4e2d\u6570\u5b57\u8df3\u8dc3\u7684\u6b21\u6570\u6709\u5173\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int a [ 1005 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , k , sum = 0 ; scanf ( \"%d%d\" , & n , & k ); a [ 0 ] = -1 ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); if ( a [ i ] != a [ i -1 ]) sum ++ ; } if ( sum <= k ) { printf ( \"1 \\n \" ); continue ; } else { sum -= k ; k -- ; if ( k == 0 ) { printf ( \"-1 \\n \" ); continue ; } else { int ans = sum / k ; ans ++ ; if ( sum % k != 0 ) ans ++ ; printf ( \"%d \\n \" , ans ); } } } return 0 ; } C\u9898 \u00b6 \u9898\u89e3 \u00b6 \u4e8c\u5206\u7b54\u6848\uff0c\u4e8c\u5206\u4e24\u8f86\u8f66\u6700\u7ec8\u76f8\u9047\u7684\u4f4d\u7f6e\uff0c\u8ba1\u7b97\u4e24\u8f66\u6240\u7528\u7684\u65f6\u95f4\u3002\u6ce8\u610f\u4e8c\u5206\u7684\u7cbe\u5ea6\uff01\uff01\uff01 \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; int n , k ; int a [ 100500 ] = { 0 }; int check ( double mid ) { double t1 = 0 , t2 = 0 ; int s1 = 1 , s2 = 1 , last1 = 1 , last2 = k + 1 ; for ( int i = 1 ; a [ i ] <= mid && i <= n ; i ++ ) { if ( a [ i ] <= mid ) { t1 += ( a [ i ] - last1 ) * 1.0 / s1 ; s1 ++ ; last1 = a [ i ]; } } if ( last1 <= mid ) { t1 += ( mid - last1 ) * 1.0 / s1 ; } for ( int i = n ; a [ i ] >= mid && i >= 1 ; i -- ) { if ( a [ i ] >= mid ) { t2 += ( last2 - a [ i ]) * 1.0 / s2 ; s2 ++ ; last2 = a [ i ]; } } if ( last2 >= mid ) { t2 += ( last2 - mid ) * 1.0 / s2 ; } if ( t1 > t2 ) return 1 ; else return 0 ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & k ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); a [ i ] ++ ; } double l = 1 , r = k + 1 ; while ( abs ( r - l ) > 0.00001 ) { double mid = ( l + r ) / 2 ; if ( check ( mid )) r = mid ; else l = mid + 0.000001 ; } double t = 0 ; int s1 = 1 , last1 = 1 ; for ( int i = 1 ; a [ i ] < l && i <= n ; i ++ ) { t += ( a [ i ] - last1 ) * 1.0 / s1 ; s1 ++ ; last1 = a [ i ]; } if ( last1 < l ) { t += ( l - last1 ) * 1.0 / s1 ; } printf ( \"%.15f \\n \" , t ); } return 0 ; } D\u9898 \u00b6 \u9898\u89e3 \u00b6 \u7531\u4e8ex\u7684\u8303\u56f4\u4e3a1e6\uff0c\u53ef\u4ee5 \u901a\u8fc7 \u679a\u4e3e\u5de6\u79fb\u7684\u6570\u91cf \u5e76 \u8ba1\u7b97\u4e0a\u79fb\u7684\u6570\u91cf \u6c42\u548c\u53d6\u6700\u5c0f \u6765\u786e\u5b9a\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll x , y ; }; node a [ 2050 ] = { 0 }; node b [ 2050 ] = { 0 }; ll ans [ 1005000 ] = { 0 }; int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld%lld\" , & a [ i ]. x , & a [ i ]. y ); for ( ll j = 1 ; j <= m ; j ++ ) scanf ( \"%lld%lld\" , & b [ j ]. x , & b [ j ]. y ); for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 1 ; j <= m ; j ++ ) { ll x = b [ j ]. x - a [ i ]. x ; ll y = b [ j ]. y - a [ i ]. y ; if ( x >= 0 && y >= 0 ) { ans [ x ] = max ( ans [ x ], y + 1 ); } } } ll min1 = 999999999 , max1 = -10000000 ; for ( ll i = 1000500 ; i >= 0 ; i -- ) { max1 = max ( max1 , ans [ i ]); ///ans\u6570\u7ec4\u80af\u5b9a\u662f\u4e0d\u51cf\u7684\uff0c\u679a\u4e3e\u8ddd\u79bb\u5373\u53ef\u3002 min1 = min ( min1 , max1 + i ); } cout << min1 << endl ; } I\u9898 \u00b6 \u9898\u89e3 \u00b6 \u7531\u4e8e\u64cd\u4f5c\u6b21\u6570\u4e0a\u9650\u4e3a3 * n * m\u6b21\uff0c\u6240\u4ee5\u53ef\u4ee5\u901a\u8fc7\u679a\u4e3e\u6bcf\u4e2a\u5c0f\u77e9\u9635\uff0c\u8ba9\u6bcf\u4e2a\u5c0f\u77e9\u9635\u53d8\u4e3a0\uff0c\u6700\u540e\u4fbf\u53ef\u4ee5\u8ba9\u6574\u4e2a\u77e9\u9635\u53d8\u4e3a0\u3002\u4f46\u662fJ\u9898\u8981\u6c42\u4e0a\u9650\u4e3an*m\u6b21\uff0c\u65e0\u6cd5\u901a\u8fc7\uff0c\u989d\u3002 \u53e6\uff1a\u4ee3\u7801\u5199\u5f97\u6bd4\u8f83\u6076\u5fc3\uff0c\u989d\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; int a [ 200 ][ 200 ] = { 0 }; int dx [ 5 ] = { 0 , 0 , 1 , 0 , 1 }; int dy [ 5 ] = { 0 , 0 , 0 , 1 , 1 }; struct node { int p [ 10 ]; }; vector < node > ans ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%1d\" , & a [ i ][ j ]); } } for ( int i = 1 ; i <= n -1 ; i ++ ) { for ( int j = 1 ; j <= m -1 ; j ++ ) { int sum = 0 ; for ( int k = 1 ; k <= 4 ; k ++ ) { int x = i + dx [ k ], y = j + dy [ k ]; if ( a [ x ][ y ] == 1 ) sum ++ ; } if ( sum == 3 ) { node z ; int id = 0 ; for ( int k = 1 ; k <= 4 ; k ++ ) { int x = i + dx [ k ], y = j + dy [ k ]; if ( a [ x ][ y ] == 1 ) z . p [ ++ id ] = x , z . p [ ++ id ] = y ; } ans . push_back ( z ); } else if ( sum == 4 ) { node z ; z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( sum == 2 ) { node z ; if ( a [ i + 1 ][ j ] == 1 && a [ i ][ j ] == 1 ) { z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i ][ j + 1 ] == 1 && a [ i ][ j ] == 1 ) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ] == 1 && a [ i ][ j + 1 ] == 1 ) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ] == 1 && a [ i + 1 ][ j ] == 1 ) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ] && a [ i ][ j ]) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i ][ j + 1 ] && a [ i + 1 ][ j ]) { z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } } else if ( sum == 1 ) { if ( a [ i ][ j ]) { node z ; z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j ]) { node z ; z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ]) { node z ; z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i ][ j + 1 ]) { node z ; z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } } for ( int k = 1 ; k <= 4 ; k ++ ) { int x = i + dx [ k ], y = j + dy [ k ]; a [ x ][ y ] = 0 ; } } } printf ( \"%d \\n \" , ans . size ()); for ( node i : ans ) { for ( int j = 1 ; j <= 6 ; j ++ ) { printf ( \"%d \" , i . p [ j ]); } printf ( \" \\n \" ); } ans . clear (); } return 0 ; }","title":"2021-02-19-2\u670819\u65e5\u9898\u89e3"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#a","text":"","title":"A\u9898"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u6570\u636e\u91cf\u6bd4\u8f83\u5c11\uff0c\u66b4\u529b\u505a\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int a [ 4 ][ 1000 ] = { 0 }; int p [ 2000 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ 1 ][ i ]); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ 2 ][ i ]); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ 3 ][ i ]); for ( int i = 1 ; i <= n ; i ++ ) { if ( i != n ) { for ( int j = 1 ; j <= 3 ; j ++ ) { if ( a [ j ][ i ] != p [ i -1 ]) { p [ i ] = a [ j ][ i ]; break ; } } } else { for ( int j = 1 ; j <= 3 ; j ++ ) { if ( a [ j ][ i ] != p [ i -1 ] && a [ j ][ i ] != p [ 1 ]) { p [ i ] = a [ j ][ i ]; break ; } } } } for ( int i = 1 ; i <= n ; i ++ ) printf ( \"%d \" , p [ i ]); printf ( \" \\n \" ); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#b","text":"","title":"B\u9898"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u627e\u89c4\u5f8b\uff0c\u5bb9\u6613\u53d1\u73b0b\u6570\u7ec4\u7684\u6700\u5c11\u4e2a\u6570\u548ca\u6570\u7ec4\u4e2d\u6570\u5b57\u8df3\u8dc3\u7684\u6b21\u6570\u6709\u5173\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int a [ 1005 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , k , sum = 0 ; scanf ( \"%d%d\" , & n , & k ); a [ 0 ] = -1 ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); if ( a [ i ] != a [ i -1 ]) sum ++ ; } if ( sum <= k ) { printf ( \"1 \\n \" ); continue ; } else { sum -= k ; k -- ; if ( k == 0 ) { printf ( \"-1 \\n \" ); continue ; } else { int ans = sum / k ; ans ++ ; if ( sum % k != 0 ) ans ++ ; printf ( \"%d \\n \" , ans ); } } } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#c","text":"","title":"C\u9898"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u4e8c\u5206\u7b54\u6848\uff0c\u4e8c\u5206\u4e24\u8f86\u8f66\u6700\u7ec8\u76f8\u9047\u7684\u4f4d\u7f6e\uff0c\u8ba1\u7b97\u4e24\u8f66\u6240\u7528\u7684\u65f6\u95f4\u3002\u6ce8\u610f\u4e8c\u5206\u7684\u7cbe\u5ea6\uff01\uff01\uff01","title":"\u9898\u89e3"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; int n , k ; int a [ 100500 ] = { 0 }; int check ( double mid ) { double t1 = 0 , t2 = 0 ; int s1 = 1 , s2 = 1 , last1 = 1 , last2 = k + 1 ; for ( int i = 1 ; a [ i ] <= mid && i <= n ; i ++ ) { if ( a [ i ] <= mid ) { t1 += ( a [ i ] - last1 ) * 1.0 / s1 ; s1 ++ ; last1 = a [ i ]; } } if ( last1 <= mid ) { t1 += ( mid - last1 ) * 1.0 / s1 ; } for ( int i = n ; a [ i ] >= mid && i >= 1 ; i -- ) { if ( a [ i ] >= mid ) { t2 += ( last2 - a [ i ]) * 1.0 / s2 ; s2 ++ ; last2 = a [ i ]; } } if ( last2 >= mid ) { t2 += ( last2 - mid ) * 1.0 / s2 ; } if ( t1 > t2 ) return 1 ; else return 0 ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & k ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); a [ i ] ++ ; } double l = 1 , r = k + 1 ; while ( abs ( r - l ) > 0.00001 ) { double mid = ( l + r ) / 2 ; if ( check ( mid )) r = mid ; else l = mid + 0.000001 ; } double t = 0 ; int s1 = 1 , last1 = 1 ; for ( int i = 1 ; a [ i ] < l && i <= n ; i ++ ) { t += ( a [ i ] - last1 ) * 1.0 / s1 ; s1 ++ ; last1 = a [ i ]; } if ( last1 < l ) { t += ( l - last1 ) * 1.0 / s1 ; } printf ( \"%.15f \\n \" , t ); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#d","text":"","title":"D\u9898"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"\u7531\u4e8ex\u7684\u8303\u56f4\u4e3a1e6\uff0c\u53ef\u4ee5 \u901a\u8fc7 \u679a\u4e3e\u5de6\u79fb\u7684\u6570\u91cf \u5e76 \u8ba1\u7b97\u4e0a\u79fb\u7684\u6570\u91cf \u6c42\u548c\u53d6\u6700\u5c0f \u6765\u786e\u5b9a\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll x , y ; }; node a [ 2050 ] = { 0 }; node b [ 2050 ] = { 0 }; ll ans [ 1005000 ] = { 0 }; int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld%lld\" , & a [ i ]. x , & a [ i ]. y ); for ( ll j = 1 ; j <= m ; j ++ ) scanf ( \"%lld%lld\" , & b [ j ]. x , & b [ j ]. y ); for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 1 ; j <= m ; j ++ ) { ll x = b [ j ]. x - a [ i ]. x ; ll y = b [ j ]. y - a [ i ]. y ; if ( x >= 0 && y >= 0 ) { ans [ x ] = max ( ans [ x ], y + 1 ); } } } ll min1 = 999999999 , max1 = -10000000 ; for ( ll i = 1000500 ; i >= 0 ; i -- ) { max1 = max ( max1 , ans [ i ]); ///ans\u6570\u7ec4\u80af\u5b9a\u662f\u4e0d\u51cf\u7684\uff0c\u679a\u4e3e\u8ddd\u79bb\u5373\u53ef\u3002 min1 = min ( min1 , max1 + i ); } cout << min1 << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#i","text":"","title":"I\u9898"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"\u7531\u4e8e\u64cd\u4f5c\u6b21\u6570\u4e0a\u9650\u4e3a3 * n * m\u6b21\uff0c\u6240\u4ee5\u53ef\u4ee5\u901a\u8fc7\u679a\u4e3e\u6bcf\u4e2a\u5c0f\u77e9\u9635\uff0c\u8ba9\u6bcf\u4e2a\u5c0f\u77e9\u9635\u53d8\u4e3a0\uff0c\u6700\u540e\u4fbf\u53ef\u4ee5\u8ba9\u6574\u4e2a\u77e9\u9635\u53d8\u4e3a0\u3002\u4f46\u662fJ\u9898\u8981\u6c42\u4e0a\u9650\u4e3an*m\u6b21\uff0c\u65e0\u6cd5\u901a\u8fc7\uff0c\u989d\u3002 \u53e6\uff1a\u4ee3\u7801\u5199\u5f97\u6bd4\u8f83\u6076\u5fc3\uff0c\u989d\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-19-2%E6%9C%8819%E6%97%A5%E9%A2%98%E8%A7%A3/#_10","text":"#include <bits/stdc++.h> using namespace std ; int a [ 200 ][ 200 ] = { 0 }; int dx [ 5 ] = { 0 , 0 , 1 , 0 , 1 }; int dy [ 5 ] = { 0 , 0 , 0 , 1 , 1 }; struct node { int p [ 10 ]; }; vector < node > ans ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%1d\" , & a [ i ][ j ]); } } for ( int i = 1 ; i <= n -1 ; i ++ ) { for ( int j = 1 ; j <= m -1 ; j ++ ) { int sum = 0 ; for ( int k = 1 ; k <= 4 ; k ++ ) { int x = i + dx [ k ], y = j + dy [ k ]; if ( a [ x ][ y ] == 1 ) sum ++ ; } if ( sum == 3 ) { node z ; int id = 0 ; for ( int k = 1 ; k <= 4 ; k ++ ) { int x = i + dx [ k ], y = j + dy [ k ]; if ( a [ x ][ y ] == 1 ) z . p [ ++ id ] = x , z . p [ ++ id ] = y ; } ans . push_back ( z ); } else if ( sum == 4 ) { node z ; z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( sum == 2 ) { node z ; if ( a [ i + 1 ][ j ] == 1 && a [ i ][ j ] == 1 ) { z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i ][ j + 1 ] == 1 && a [ i ][ j ] == 1 ) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ] == 1 && a [ i ][ j + 1 ] == 1 ) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ] == 1 && a [ i + 1 ][ j ] == 1 ) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ] && a [ i ][ j ]) { z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i ][ j + 1 ] && a [ i + 1 ][ j ]) { z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } } else if ( sum == 1 ) { if ( a [ i ][ j ]) { node z ; z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j ]) { node z ; z . p [ 1 ] = i + 1 , z . p [ 2 ] = j , z . p [ 3 ] = i , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i + 1 ][ j + 1 ]) { node z ; z . p [ 1 ] = i , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i + 1 , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } else if ( a [ i ][ j + 1 ]) { node z ; z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i + 1 , z . p [ 2 ] = j + 1 , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); z . p [ 1 ] = i , z . p [ 2 ] = j , z . p [ 3 ] = i + 1 , z . p [ 4 ] = j + 1 , z . p [ 5 ] = i , z . p [ 6 ] = j + 1 ; ans . push_back ( z ); } } for ( int k = 1 ; k <= 4 ; k ++ ) { int x = i + dx [ k ], y = j + dy [ k ]; a [ x ][ y ] = 0 ; } } } printf ( \"%d \\n \" , ans . size ()); for ( node i : ans ) { for ( int j = 1 ; j <= 6 ; j ++ ) { printf ( \"%d \" , i . p [ j ]); } printf ( \" \\n \" ); } ans . clear (); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"\u95ee\u9898E \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2723&pid=4 \u7c7b\u4f3c\u95ee\u9898\uff1a https://www.luogu.com.cn/problem/P2145 \u9898\u76ee\u63cf\u8ff0 \u00b6 Playing games is fun. For programmers, however, playing games with programs is even more fun. Consider a simple single-user tabletop game as follows. Given a row of sticks, each of which is in one of the seven colors, red (R), green (G), blue (B), cyan (C), magenta (M), yellow (Y), and key (K), the goal of the game is to eliminate all the sticks by repeating the following rules. \u2022 Consecutive sticks with the same color can be eliminated if the size of them is not less than m . \u2022 The remaining sticks will move closer together. For the case where the row is BBBRRRRRRGGGB and m is 3, all the sticks can be successfully eliminated as the following steps: BBBRRRRRRGGGB BBBGGGB (By eliminating all red sticks) BBBB (By eliminating all green sticks) (By eliminating all blue sticks) For the same row of sticks with m = 4, however, it is no way to eliminate all the sticks. Given a row of n sticks and the value of m , your task is to determine if it is possible to eliminate all the sticks. \u8f93\u5165 \u00b6 Each test case is given as a string that is the row of sticks and an integer m . \u8f93\u51fa \u00b6 Output Yes if it is possible to eliminate all the sticks. Otherwise, output No. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 BBBRRRRRRGGGB 3 \u3010\u6837\u4f8b2\u3011 BBBRRRRRRGGGB 4 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 Yes \u3010\u6837\u4f8b2\u3011 No \u63d0\u793a \u00b6 \u2022 0 <n,m \u2264 500 \u9898\u89e3 \u00b6 \u9898\u610f\uff1a\u7ed9\u5b9a7\u79cd\u5b57\u7b26 \u6bcf\u6709\u4e00\u6bb5\u8fde\u7eed\u7684\u957f\u5ea6\u5927\u4e8em\u7684\u76f8\u540c\u5b57\u7b26\u5c31\u80fd\u6d88\u53bb \u95ee\u6700\u7ec8\u6574\u6bb5\u5b57\u7b26\u4e32\u80fd\u5426\u6d88\u53bb dp[i][j][k] \u4ee3\u8868 i\u5230j\u533a\u95f4 \u79cd\u7c7b\u4e3ak\u7684\u6570\u6700\u5927\u8fde\u7eed\u5b50\u4e32\u7684\u957f\u5ea6 dp[i][j][k]\u5168\u90e8\u521d\u59cb\u5316\u4e3a-1e9\uff0c\u4ee3\u8868\u6ca1\u6709\u4efb\u4f55\u8fde\u7eed\u5b50\u4e32\u3002 \u90a3\u4e48\u6bcf\u6b21\u533a\u95f4\u5408\u5e76\u7684\u65f6\u5019 dp[i][j][k]=max(dp[i][l][k]+dp[l+1][j][k],dp[i][j][k]) \u5982\u679c\u5f53\u524d\u7684\u533a\u95f4\u6bb5\u6709\u80fd\u591f\u5220\u9664\u7684\u6bb5\uff0c\u90a3\u4e48\u5176\u4ed6\u7684\u5b57\u7b26\u4e32\u7684\u5f53\u524d\u533a\u95f4\u6bb5\u7684\u6570\u7684\u975e\u6cd5\u72b6\u6001\u5c31\u53ef\u4ee5\u7f6e\u4e3a0\uff0c\u4fdd\u8bc1\u80fd\u628a\u65ad\u5f00\u7684\u5b57\u7b26\u4e32\u63a5\u8d77\u6765\u3002\uff08\u4ee3\u8868\u6d88\u9664\u76f8\u540c\u7684\u5143\u7d20\uff0c\u8be5\u4e32\u957f\u5ea6\u4e3a0\uff09 \u7ecf\u8fc7\u5220\u9664\u5408\u5e76\u6700\u540e\u5982\u679c\u5269\u4f59\u4e00\u4e2a\u957f\u5ea6\u5927\u4e8em\u7684\u5b50\u4e32\u5219\u8f93\u51fayes\uff0c\u53cd\u4e4b\u8f93\u51fano \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int dp [ 600 ][ 600 ][ 8 ] = { 0 }; ///dp[i][j][k] \u4ee3\u8868\u4ecei\u5230j\u503c\u4e3ak\u7684\u8fde\u7eed\u4e2a\u6570 map < char , int > mp ; char c [ 600 ] = { 0 }; int main () { int n , m ; scanf ( \"%s%d\" , c + 1 , & m ); n = strlen ( c + 1 ); if ( m == 1 ) { printf ( \"Yes \\n \" ); return 0 ; } mp [ 'R' ] = 1 ; mp [ 'G' ] = 2 ; mp [ 'B' ] = 3 ; mp [ 'C' ] = 4 ; mp [ 'M' ] = 5 ; mp [ 'Y' ] = 6 ; mp [ 'K' ] = 7 ; for ( int i = 0 ; i < n + 10 ; i ++ ) for ( int j = 0 ; j < n + 10 ; j ++ ) for ( int k = 0 ; k < 8 ; k ++ ) dp [ i ][ j ][ k ] = -1e9 ; for ( int i = 1 ; c [ i ]; i ++ ) dp [ i ][ i ][ mp [ c [ i ]]] = 1 ; for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 1 ; i + len -1 <= n ; i ++ ) { int j = i + len -1 ; int flag = 0 ; for ( int l = i ; l < j ; l ++ ) { for ( int k = 1 ; k <= 7 ; k ++ ) { dp [ i ][ j ][ k ] = max ( dp [ i ][ j ][ k ], dp [ i ][ l ][ k ] + dp [ l + 1 ][ j ][ k ]); if ( dp [ i ][ j ][ k ] >= m ) flag = 1 ; } } if ( flag ) { for ( int k = 1 ; k <= 7 ; k ++ ) { if ( dp [ i ][ j ][ k ] < 0 ) dp [ i ][ j ][ k ] = 0 ; } } } } for ( int k = 1 ; k <= 7 ; k ++ ) { if ( dp [ 1 ][ n ][ k ] >= m ) { printf ( \"Yes \\n \" ); return 0 ; } } printf ( \"No \\n \" ); return 0 ; } \u95ee\u9898 F \u00b6 \u95ee\u9898\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2723&pid=5 \u9898\u76ee\u63cf\u8ff0 \u00b6 A company ICPC (International Cable Protection Company) produces a cable protection tool that can be installed in a network switch to monitor whether all cable links connected to it are working properly. Because the protection tool would cause transmission delay, it is not suitable for installation on every switch. Usually network topology consists of two parts: a backbone and several subnets. The switches on the backbone are linked as a ring structure and each backbone switch is treated as a root of a subnet in which the switches are linked as a tree structure. We call such topology as unicyclic topology. Figure 2 shows an example of a unicyclic topology. Suppose there are n backbone switches and m subnet switches. The switches are numbered by integers from 0 to m + n \u2212 1. Backbone switches are numbered from 0 to n \u2212 1 in clockwise order and the subnet switches are numbered from n to n + m \u2212 1 where the index of each subnet switch is larger than the index of its parent in the rooted tree structure of the subnet it belongs. Figure 3 shows an example of switch numbering. Please write a program for ICPC to decide the minimum number of switches selected for installing cable protection tools that can monitor all the cable links. Figure 4 shows an optimum solution (circled by ellipses) for the given network. \u8f93\u5165 \u00b6 The first line of the input file contains two integers n and m , separated by a space, indicating the numbers of backbone switches and subnet switches respectively. Each of the next n+m lines consists of two integers, separated by a space, indicating the indices of the two end switches of a link. \u8f93\u51fa \u00b6 Output the minimum number of switches selected for installing cable protection tools that can monitor all the cable links. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 3 2 0 1 1 2 0 2 1 3 2 4 \u3010\u6837\u4f8b2\u3011 4 11 0 1 0 3 0 4 0 5 1 2 1 6 2 3 2 9 3 12 6 7 6 8 9 10 10 11 12 13 12 14 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 2 \u3010\u6837\u4f8b2\u3011 5 \u63d0\u793a \u00b6 \u2022 3 \u2264 n \u2264 100000 \u2022 1 \u2264 m \u2264 100000 \u9898\u89e3 \u00b6 \u6811\u4e0aDP\uff0c\u7531\u4e8e\u4e2d\u5fc3\u5904\u4e3a\u4e00\u4e2a\u73af\uff0c\u53ef\u4ee5\u53bb\u9664\u4e00\u6761\u8fb9\u4f7f\u5176\u53d8\u4e3a\u4e00\u68f5\u6811\uff0c\u7136\u540e\u901a\u8fc7DP\u6765\u8fdb\u884c\u6c42\u89e3\u7b54\u6848\u3002 \u7531\u4e8e\u53bb\u6389\u4e86\u4e00\u6761\u8fb9\uff0c\u5982\u679c\u662f\u8fd9\u6761\u8fb9\uff08\u5047\u8bbe\u8be5\u8fb9\u4e24\u7aef\u70b9\u4e3ax\u548cy\uff09\u80fd\u591f\u88ab\u8986\u76d6\uff0c\u5219\u5206\u4e3a\u4e24\u79cd\u60c5\u51b5\uff0cx\u70b9\u88ab\u9009\u62e9\u548cy\u70b9\u88ab\u9009\u62e9\uff0c\u4e24\u79cd\u60c5\u51b5\u53d6\u6700\u5c0f\u5373\u4e3a\u7b54\u6848\u3002 dp[i][0]\u4ee3\u8868\u8be5\u70b9\u88ab\u9009\u62e9\uff0cdp[i][i]\u4ee3\u8868\u8be5\u70b9\u4e0d\u88ab\u9009\u62e9\uff0c\u5219\u6709\u5982\u4e0b\u7684\u9012\u63a8\u516c\u5f0f dp[i][0]=min(dp[i][0],dp[i][1])+1,dp[i][1]=dp[i][0]+1 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int to , next ; }; node edge [ 400500 ] = { 0 }; int head [ 400500 ] = { 0 }; int flag = 0 , x , y , sum = 0 ; int dp [ 400500 ][ 2 ] = { 0 }; ///\u6811\u4e0aDP\uff0cdp[i][0]\u4ee3\u8868\u8be5\u70b9\u88ab\u9009\u62e9\uff0cdp[i][1]\u4ee3\u8868\u8be5\u70b9\u6ca1\u6709\u88ab\u9009\u62e9 void add ( int from , int to ) { edge [ ++ sum ]. next = head [ from ]; edge [ sum ]. to = to ; head [ from ] = sum ; } void dfs ( int now , int fa ) { dp [ now ][ 0 ] = dp [ now ][ 1 ] = 0 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { if ( edge [ i ]. to != fa ) { dfs ( edge [ i ]. to , now ); dp [ now ][ 0 ] += min ( dp [ edge [ i ]. to ][ 0 ], dp [ edge [ i ]. to ][ 1 ]); dp [ now ][ 1 ] += dp [ edge [ i ]. to ][ 0 ]; } } dp [ now ][ 0 ] ++ ; if ( now == y && flag == 2 ) dp [ now ][ 1 ] ++ ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n + m ; i ++ ) { int s , e ; scanf ( \"%d%d\" , & s , & e ); if ( ! flag && s < n && e < n ) ///\u5728\u4e2d\u5fc3\u73af\u4e0a\uff0c\u9009\u53d6\u4e00\u6761\u8fb9\u5c06\u5176\u65ad\u6389\uff0c\u4f7f\u5176\u53d8\u4e3a\u4e00\u68f5\u6811 { x = s , y = e , flag = 1 ; continue ; } add ( s , e ); add ( e , s ); } int ans = 999999999 ; dfs ( x , -1 ); ///\u4ee3\u8868x\u70b9\u88ab\u6807\u8bb0\uff0c\u90a3\u4e48x\u5230y\u8fd9\u6761\u8fb9\u4e00\u5b9a\u6ee1\u8db3\u6761\u4ef6 ans = min ( ans , dp [ x ][ 0 ]); flag = 2 ; dfs ( x , -1 ); ///\u4ee3\u8868y\u70b9\u88ab\u6807\u8bb0\uff0c\u90a3\u4e48x\u5230y\u8fd9\u6761\u8fb9\u4e00\u5b9a\u6ee1\u8db3\u6761\u4ef6 ans = min ( ans , min ( dp [ x ][ 0 ], dp [ x ][ 1 ])); printf ( \"%d \\n \" , ans ); }","title":"2021-02-20-2\u670820\u65e5\u9898\u89e3"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#e","text":"","title":"\u95ee\u9898E"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"http://icpc.upc.edu.cn/problem.php?cid=2723&pid=4 \u7c7b\u4f3c\u95ee\u9898\uff1a https://www.luogu.com.cn/problem/P2145","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"Playing games is fun. For programmers, however, playing games with programs is even more fun. Consider a simple single-user tabletop game as follows. Given a row of sticks, each of which is in one of the seven colors, red (R), green (G), blue (B), cyan (C), magenta (M), yellow (Y), and key (K), the goal of the game is to eliminate all the sticks by repeating the following rules. \u2022 Consecutive sticks with the same color can be eliminated if the size of them is not less than m . \u2022 The remaining sticks will move closer together. For the case where the row is BBBRRRRRRGGGB and m is 3, all the sticks can be successfully eliminated as the following steps: BBBRRRRRRGGGB BBBGGGB (By eliminating all red sticks) BBBB (By eliminating all green sticks) (By eliminating all blue sticks) For the same row of sticks with m = 4, however, it is no way to eliminate all the sticks. Given a row of n sticks and the value of m , your task is to determine if it is possible to eliminate all the sticks.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"Each test case is given as a string that is the row of sticks and an integer m .","title":"\u8f93\u5165"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"Output Yes if it is possible to eliminate all the sticks. Otherwise, output No.","title":"\u8f93\u51fa"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u3010\u6837\u4f8b1\u3011 BBBRRRRRRGGGB 3 \u3010\u6837\u4f8b2\u3011 BBBRRRRRRGGGB 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"\u3010\u6837\u4f8b1\u3011 Yes \u3010\u6837\u4f8b2\u3011 No","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"\u2022 0 <n,m \u2264 500","title":"\u63d0\u793a"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"\u9898\u610f\uff1a\u7ed9\u5b9a7\u79cd\u5b57\u7b26 \u6bcf\u6709\u4e00\u6bb5\u8fde\u7eed\u7684\u957f\u5ea6\u5927\u4e8em\u7684\u76f8\u540c\u5b57\u7b26\u5c31\u80fd\u6d88\u53bb \u95ee\u6700\u7ec8\u6574\u6bb5\u5b57\u7b26\u4e32\u80fd\u5426\u6d88\u53bb dp[i][j][k] \u4ee3\u8868 i\u5230j\u533a\u95f4 \u79cd\u7c7b\u4e3ak\u7684\u6570\u6700\u5927\u8fde\u7eed\u5b50\u4e32\u7684\u957f\u5ea6 dp[i][j][k]\u5168\u90e8\u521d\u59cb\u5316\u4e3a-1e9\uff0c\u4ee3\u8868\u6ca1\u6709\u4efb\u4f55\u8fde\u7eed\u5b50\u4e32\u3002 \u90a3\u4e48\u6bcf\u6b21\u533a\u95f4\u5408\u5e76\u7684\u65f6\u5019 dp[i][j][k]=max(dp[i][l][k]+dp[l+1][j][k],dp[i][j][k]) \u5982\u679c\u5f53\u524d\u7684\u533a\u95f4\u6bb5\u6709\u80fd\u591f\u5220\u9664\u7684\u6bb5\uff0c\u90a3\u4e48\u5176\u4ed6\u7684\u5b57\u7b26\u4e32\u7684\u5f53\u524d\u533a\u95f4\u6bb5\u7684\u6570\u7684\u975e\u6cd5\u72b6\u6001\u5c31\u53ef\u4ee5\u7f6e\u4e3a0\uff0c\u4fdd\u8bc1\u80fd\u628a\u65ad\u5f00\u7684\u5b57\u7b26\u4e32\u63a5\u8d77\u6765\u3002\uff08\u4ee3\u8868\u6d88\u9664\u76f8\u540c\u7684\u5143\u7d20\uff0c\u8be5\u4e32\u957f\u5ea6\u4e3a0\uff09 \u7ecf\u8fc7\u5220\u9664\u5408\u5e76\u6700\u540e\u5982\u679c\u5269\u4f59\u4e00\u4e2a\u957f\u5ea6\u5927\u4e8em\u7684\u5b50\u4e32\u5219\u8f93\u51fayes\uff0c\u53cd\u4e4b\u8f93\u51fano","title":"\u9898\u89e3"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int dp [ 600 ][ 600 ][ 8 ] = { 0 }; ///dp[i][j][k] \u4ee3\u8868\u4ecei\u5230j\u503c\u4e3ak\u7684\u8fde\u7eed\u4e2a\u6570 map < char , int > mp ; char c [ 600 ] = { 0 }; int main () { int n , m ; scanf ( \"%s%d\" , c + 1 , & m ); n = strlen ( c + 1 ); if ( m == 1 ) { printf ( \"Yes \\n \" ); return 0 ; } mp [ 'R' ] = 1 ; mp [ 'G' ] = 2 ; mp [ 'B' ] = 3 ; mp [ 'C' ] = 4 ; mp [ 'M' ] = 5 ; mp [ 'Y' ] = 6 ; mp [ 'K' ] = 7 ; for ( int i = 0 ; i < n + 10 ; i ++ ) for ( int j = 0 ; j < n + 10 ; j ++ ) for ( int k = 0 ; k < 8 ; k ++ ) dp [ i ][ j ][ k ] = -1e9 ; for ( int i = 1 ; c [ i ]; i ++ ) dp [ i ][ i ][ mp [ c [ i ]]] = 1 ; for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 1 ; i + len -1 <= n ; i ++ ) { int j = i + len -1 ; int flag = 0 ; for ( int l = i ; l < j ; l ++ ) { for ( int k = 1 ; k <= 7 ; k ++ ) { dp [ i ][ j ][ k ] = max ( dp [ i ][ j ][ k ], dp [ i ][ l ][ k ] + dp [ l + 1 ][ j ][ k ]); if ( dp [ i ][ j ][ k ] >= m ) flag = 1 ; } } if ( flag ) { for ( int k = 1 ; k <= 7 ; k ++ ) { if ( dp [ i ][ j ][ k ] < 0 ) dp [ i ][ j ][ k ] = 0 ; } } } } for ( int k = 1 ; k <= 7 ; k ++ ) { if ( dp [ 1 ][ n ][ k ] >= m ) { printf ( \"Yes \\n \" ); return 0 ; } } printf ( \"No \\n \" ); return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#f","text":"","title":"\u95ee\u9898 F"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_10","text":"http://icpc.upc.edu.cn/problem.php?cid=2723&pid=5","title":"\u95ee\u9898\u94fe\u63a5"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_11","text":"A company ICPC (International Cable Protection Company) produces a cable protection tool that can be installed in a network switch to monitor whether all cable links connected to it are working properly. Because the protection tool would cause transmission delay, it is not suitable for installation on every switch. Usually network topology consists of two parts: a backbone and several subnets. The switches on the backbone are linked as a ring structure and each backbone switch is treated as a root of a subnet in which the switches are linked as a tree structure. We call such topology as unicyclic topology. Figure 2 shows an example of a unicyclic topology. Suppose there are n backbone switches and m subnet switches. The switches are numbered by integers from 0 to m + n \u2212 1. Backbone switches are numbered from 0 to n \u2212 1 in clockwise order and the subnet switches are numbered from n to n + m \u2212 1 where the index of each subnet switch is larger than the index of its parent in the rooted tree structure of the subnet it belongs. Figure 3 shows an example of switch numbering. Please write a program for ICPC to decide the minimum number of switches selected for installing cable protection tools that can monitor all the cable links. Figure 4 shows an optimum solution (circled by ellipses) for the given network.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_12","text":"The first line of the input file contains two integers n and m , separated by a space, indicating the numbers of backbone switches and subnet switches respectively. Each of the next n+m lines consists of two integers, separated by a space, indicating the indices of the two end switches of a link.","title":"\u8f93\u5165"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_13","text":"Output the minimum number of switches selected for installing cable protection tools that can monitor all the cable links.","title":"\u8f93\u51fa"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_14","text":"\u3010\u6837\u4f8b1\u3011 3 2 0 1 1 2 0 2 1 3 2 4 \u3010\u6837\u4f8b2\u3011 4 11 0 1 0 3 0 4 0 5 1 2 1 6 2 3 2 9 3 12 6 7 6 8 9 10 10 11 12 13 12 14","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_15","text":"\u3010\u6837\u4f8b1\u3011 2 \u3010\u6837\u4f8b2\u3011 5","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_16","text":"\u2022 3 \u2264 n \u2264 100000 \u2022 1 \u2264 m \u2264 100000","title":"\u63d0\u793a"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_17","text":"\u6811\u4e0aDP\uff0c\u7531\u4e8e\u4e2d\u5fc3\u5904\u4e3a\u4e00\u4e2a\u73af\uff0c\u53ef\u4ee5\u53bb\u9664\u4e00\u6761\u8fb9\u4f7f\u5176\u53d8\u4e3a\u4e00\u68f5\u6811\uff0c\u7136\u540e\u901a\u8fc7DP\u6765\u8fdb\u884c\u6c42\u89e3\u7b54\u6848\u3002 \u7531\u4e8e\u53bb\u6389\u4e86\u4e00\u6761\u8fb9\uff0c\u5982\u679c\u662f\u8fd9\u6761\u8fb9\uff08\u5047\u8bbe\u8be5\u8fb9\u4e24\u7aef\u70b9\u4e3ax\u548cy\uff09\u80fd\u591f\u88ab\u8986\u76d6\uff0c\u5219\u5206\u4e3a\u4e24\u79cd\u60c5\u51b5\uff0cx\u70b9\u88ab\u9009\u62e9\u548cy\u70b9\u88ab\u9009\u62e9\uff0c\u4e24\u79cd\u60c5\u51b5\u53d6\u6700\u5c0f\u5373\u4e3a\u7b54\u6848\u3002 dp[i][0]\u4ee3\u8868\u8be5\u70b9\u88ab\u9009\u62e9\uff0cdp[i][i]\u4ee3\u8868\u8be5\u70b9\u4e0d\u88ab\u9009\u62e9\uff0c\u5219\u6709\u5982\u4e0b\u7684\u9012\u63a8\u516c\u5f0f dp[i][0]=min(dp[i][0],dp[i][1])+1,dp[i][1]=dp[i][0]+1","title":"\u9898\u89e3"},{"location":"problem/2021-02-20-2%E6%9C%8820%E6%97%A5%E9%A2%98%E8%A7%A3/#_18","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { int to , next ; }; node edge [ 400500 ] = { 0 }; int head [ 400500 ] = { 0 }; int flag = 0 , x , y , sum = 0 ; int dp [ 400500 ][ 2 ] = { 0 }; ///\u6811\u4e0aDP\uff0cdp[i][0]\u4ee3\u8868\u8be5\u70b9\u88ab\u9009\u62e9\uff0cdp[i][1]\u4ee3\u8868\u8be5\u70b9\u6ca1\u6709\u88ab\u9009\u62e9 void add ( int from , int to ) { edge [ ++ sum ]. next = head [ from ]; edge [ sum ]. to = to ; head [ from ] = sum ; } void dfs ( int now , int fa ) { dp [ now ][ 0 ] = dp [ now ][ 1 ] = 0 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { if ( edge [ i ]. to != fa ) { dfs ( edge [ i ]. to , now ); dp [ now ][ 0 ] += min ( dp [ edge [ i ]. to ][ 0 ], dp [ edge [ i ]. to ][ 1 ]); dp [ now ][ 1 ] += dp [ edge [ i ]. to ][ 0 ]; } } dp [ now ][ 0 ] ++ ; if ( now == y && flag == 2 ) dp [ now ][ 1 ] ++ ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n + m ; i ++ ) { int s , e ; scanf ( \"%d%d\" , & s , & e ); if ( ! flag && s < n && e < n ) ///\u5728\u4e2d\u5fc3\u73af\u4e0a\uff0c\u9009\u53d6\u4e00\u6761\u8fb9\u5c06\u5176\u65ad\u6389\uff0c\u4f7f\u5176\u53d8\u4e3a\u4e00\u68f5\u6811 { x = s , y = e , flag = 1 ; continue ; } add ( s , e ); add ( e , s ); } int ans = 999999999 ; dfs ( x , -1 ); ///\u4ee3\u8868x\u70b9\u88ab\u6807\u8bb0\uff0c\u90a3\u4e48x\u5230y\u8fd9\u6761\u8fb9\u4e00\u5b9a\u6ee1\u8db3\u6761\u4ef6 ans = min ( ans , dp [ x ][ 0 ]); flag = 2 ; dfs ( x , -1 ); ///\u4ee3\u8868y\u70b9\u88ab\u6807\u8bb0\uff0c\u90a3\u4e48x\u5230y\u8fd9\u6761\u8fb9\u4e00\u5b9a\u6ee1\u8db3\u6761\u4ef6 ans = min ( ans , min ( dp [ x ][ 0 ], dp [ x ][ 1 ])); printf ( \"%d \\n \" , ans ); }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"A\u9898 \u00b6 \u9898\u89e3 \u00b6 \u6784\u9020\u7531n-1\u4e2a2\u548c\u4e00\u4e2a3\u6216\u8005n-2\u4e2a2\u548c\u4e24\u4e2a3\u7684\u6570\uff0c\u4f7f\u5176\u65e0\u6cd5\u88ab2\u548c3\u6574\u9664\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); if ( n == 1 ) printf ( \"-1 \\n \" ); else { int sum = 0 ; for ( int i = 1 ; i <= n -1 ; i ++ ) { if ( i != n -1 ) { sum += 2 ; sum %= 3 ; printf ( \"2\" ); } else { if ( sum == 0 ) printf ( \"23 \\n \" ); else if ( sum == 1 ) printf ( \"33 \\n \" ); else if ( sum == 2 ) printf ( \"23 \\n \" ); } } } } return 0 ; } B\u9898 \u00b6 \u9898\u89e3 \u00b6 \u6a21\u62df\uff0ca[1]\u4e00\u5b9a\u548cb[1]\u76f8\u540c\uff0cx[1]\u4e00\u5b9a\u4e3a0\uff0c\u7136\u540e\u6a21\u62df\u6c422~n\u4e2a\u6570\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int b [ 200500 ] = { 0 }; int a [ 200500 ] = { 0 }; int main () { ll sum = 0 ; int n , m ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & b [ i ]); } int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = b [ i ] + max1 ; max1 = max ( max1 , a [ i ]); } for ( int i = 1 ; i <= n ; i ++ ) { printf ( \"%d \" , a [ i ]); } return 0 ; } C\u9898 \u00b6 \u9898\u89e3 \u00b6 \u5bb9\u6613\u53d1\u73b0\u5982\u679c\u4f7f\u6c42\u548c\u6700\u5927\uff0c\u5219\u6bcf\u4e00\u5757\u5e94\u8be5\u5305\u542b\u4e00\u4e2a\u6700\u5927\u503c\uff0c\u627e\u51fa\u524dk\u4e2a\u6700\u5927\u503c\u6c42\u548c\u5373\u4e3a\u7b54\u6848\uff0c\u7136\u540e\u5bf9\u6bcf\u4e2a\u6700\u5927\u503c\u7684\u4e0b\u6807\u8fdb\u884c\u505a\u5dee\u6c42\u79ef\u5373\u4e3a\u7b2c\u4e8c\u4e2a\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const long long mod = 998244353 ; struct node { int x , p ; }; node a [ 200500 ] = { 0 }; int main () { int n , k ; scanf ( \"%d%d\" , & n , & k ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]. x ), a [ i ]. p = i ; sort ( a + 1 , a + n + 1 ,[]( node a , node b ){ if ( a . x != b . x ) return a . x > b . x ; else return a . p < b . p ;}); long long ans1 = 0 , ans2 = 1 ; vector < int > v ; for ( int i = 1 ; i <= k ; i ++ ) { ans1 += a [ i ]. x ; v . push_back ( a [ i ]. p ); } sort ( v . begin (), v . end (),[]( int a , int b ){ return a < b ;}); for ( int i = 1 ; i < v . size (); i ++ ) { ans2 = ans2 * ( v [ i ] - v [ i -1 ]); ans2 %= mod ; } printf ( \"%lld %lld \\n \" , ans1 , ans2 ); return 0 ; } D\u9898/E\u9898 \u00b6 \u9898\u89e3 \u00b6 \u53ef\u4ee5\u9884\u5904\u7406\u524d\u7f00\u548c\u540e\u7f00\u76f8\u540c\u7684\u90e8\u5206\uff0c\u7136\u540e\u5bf9\u5269\u4f59\u90e8\u5206\u8fdb\u884cmanacher\u7b97\u6cd5\uff0c\u6c42\u6700\u957f\u7684\u56de\u6587\u4e32\uff0c\u6ce8\uff1a\u8be5\u56de\u6587\u4e32\u5fc5\u987b\u4f4d\u4e8e\u5f00\u5934\u6216\u7ed3\u5c3e\u3002 \u53c2\u7167\u94fe\u63a5\uff1a https://www.luogu.com.cn/blog/xht37/solution-cf1326d2 https://zhuanlan.zhihu.com/p/137172524 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; char a [ 1005000 ] = { 0 }; char t [ 1005000 ] = { 0 }; int manacher ( char * c ) { int max_id = 0 , ans = 1 , id = 0 ; string str = \"$#\" ; for ( int i = 1 ; c [ i ]; i ++ ) str += c [ i ], str += \"#\" ; vector < int > p ; p . push_back ( 1 ); for ( int i = 1 ; i < ( int ) str . size (); i ++ ) { if ( max_id > i ) p . push_back ( min ( max_id - i , p [ 2 * id - i ])); else p . push_back ( 1 ); while ( i + p [ i ] < ( int ) str . size () && str [ i + p [ i ]] == str [ i - p [ i ]]) p [ i ] ++ ; if ( i == p [ i ]) ///i==p[i]\uff0c\u4ee3\u8868\u8be5\u56de\u6587\u4e32\u4f4d\u4e8e\u5f00\u5934 ans = max ( ans , p [ i ]); if ( i + p [ i ] > max_id ){ max_id = i + p [ i ], id = i ; } } return ans -1 ; } int main () { int time ; scanf ( \"%d\" , & time ); while ( time -- ) { scanf ( \"%s\" , a + 1 ); int n = strlen ( a + 1 ), sum = 1 ; while ( sum <= n && a [ sum ] == a [ n - sum + 1 ]) sum ++ ; if ( sum == n + 1 ) { printf ( \"%s \\n \" , a + 1 ); continue ; } int m = 0 ; for ( int i = sum ; i <= n - sum + 1 ; i ++ ) t [ ++ m ] = a [ i ]; t [ m + 1 ] = '\\0' ; int l_ans = manacher ( t ); reverse ( t + 1 , t + m + 1 ); int r_ans = manacher ( t ); reverse ( t + 1 , t + m + 1 ); if ( l_ans < r_ans ) reverse ( t + 1 , t + m + 1 ), swap ( l_ans , r_ans ); for ( int i = 1 ; i < sum ; i ++ ) printf ( \"%c\" , a [ i ]); for ( int i = 1 ; i <= l_ans ; i ++ ) printf ( \"%c\" , t [ i ]); for ( int i = sum -1 ; i >= 1 ; i -- ) printf ( \"%c\" , a [ i ]); printf ( \" \\n \" ); } return 0 ; } \u7ec4\u961f\u8bad\u7ec3\u8d5bA\u9898 Comic Binge \u00b6 \u9898\u89e3 \u00b6 \u7531\u4e8eA\u5fc5\u987b\u7b49B\u8bfb\u5b8c\u540e\u624d\u8bfb\uff0c\u90a3\u4e48\u4e00\u79cd\u53ef\u884c\u7684\u6761\u4ef6\u4fbf\u662fB\u628a\u6240\u6709\u7684\u4e66\u8bfb\u5b8c\u540eA\u518d\u53bb\u8bfb\u6240\u6709\u7684\u4e66\uff0c\u8fd9\u6837\u603b\u65f6\u957f\u662f\u6700\u5927\u7684\uff0c\u4e14A\u548cB\u7684\u91cd\u5408\u8bfb\u4e66\u65f6\u95f4\u4e3a0\u3002\u5982\u679c\u8981\u4f7f\u603b\u65f6\u95f4\u6700\u77ed\uff0c\u90a3\u4e48\u5e94\u5f53\u5c3d\u53ef\u80fd\u589e\u5927\u4e8c\u8005\u7684\u91cd\u5408\u8bfb\u4e66\u65f6\u95f4\uff0c\u52a8\u6001\u89c4\u5212\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const long long mod = 998244353 ; int dp [ 1050 ][ 10050 ] = { 0 }; ///dp[i][j]\u4ee3\u8868B\u5728\u65f6\u95f4j\u8bfb\u5b8c\u524di-1\u672c\u4e66\u4e8c\u8005\u6700\u5927\u91cd\u5408\u8bfb\u4e66\u65f6\u95f4 int sum_a [ 1050 ] = { 0 }; int a [ 1050 ] = { 0 }, b [ 1050 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]), sum_a [ i ] = sum_a [ i -1 ] + a [ i ]; for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & b [ i ]); int max_b = n * 10 ; ///B\u6700\u5927\u7684\u65f6\u95f4 for ( int i = 1 ; i <= n + 1 ; i ++ ) for ( int j = 0 ; j <= max_b ; j ++ ) dp [ i ][ j ] = -1 ; dp [ 1 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) { for ( int j = 0 ; j <= max_b ; j ++ ) { if ( dp [ i ][ j ] == -1 ) continue ; if ( i <= n && j + b [ i ] <= max_b ) { dp [ i + 1 ][ j + b [ i ]] = max ( dp [ i + 1 ][ j + b [ i ]], min ( dp [ i ][ j ] + b [ i ], sum_a [ i -1 ])); ///B\u8bfbi\u4e66\uff0cB\u8bfb\u5b8c\u524di\u672c\u4e66\u91cd\u5408\u65f6\u95f4\u6700\u5927\u503c //\u6ce8\u610f\u5e94\u5f53\u548csum_a[i-1]\u53d6\u6700\u5c0f\u503c\uff0c\u7531\u4e8eA\u843d\u540e\u4e8eB\u4e00\u672c\u4e66 } if ( i > 1 && i + 1 <= n && j + b [ i + 1 ] <= max_b ) ///B\u8bfbi+1\u4e66\uff0c\u4e0d\u8981\u5fd8\u8bb0i>1\u7684\u6761\u4ef6\uff0cB\u5fc5\u987b\u8bfb\u7b2c\u4e00\u672c\u4e66 dp [ i + 2 ][ j + b [ i + 1 ]] = max ( dp [ i + 2 ][ j + b [ i + 1 ]], min ( dp [ i ][ j ] + b [ i + 1 ], sum_a [ i ])); } } int min1 = 999999999 ; for ( int j = 0 ; j <= max_b ; j ++ ) { if ( dp [ n + 1 ][ j ] != -1 ) min1 = min ( min1 , j - dp [ n + 1 ][ j ] + sum_a [ n ]); } printf ( \"%d \\n \" , min1 ); return 0 ; } \u7ec4\u961f\u8bad\u7ec3\u8d5bC\u9898 Cul-De-Sac Parades \u00b6 \u9898\u89e3 \u00b6 \u6811\u4e0aDP\uff0c\u5bf9\u6bcf\u4e2a\u7236\u8282\u70b9\u7684\u7684\u8fb9\u8fdb\u884c\u679a\u4e3e\u9009\u62e9\uff0c\u662f\u5426\u4f7f\u7528\u8fd9\u4e2a\u8fb9\uff08\u5047\u8bbe\u4e3a\u8fb9A\uff09\uff0c\u5982\u679c\u4f7f\u7528\u8fd9\u6761\u8fb9A\uff0c\u5219\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9\uff0c\u627e\u51fa\u8fde\u63a5\u5b50\u8282\u70b9\u6240\u6709\u8fb9\u4e2d\u6743\u503c\u6700\u5927\u7684\u8fb9\uff0c\u5c06\u5176\u4e0e\u8fb9A\u8fdb\u884c\u8fde\u63a5\uff0c\u7ec4\u6210\u4e00\u6761\u901a\u8def\uff0c\u5176\u4f59\u5b50\u8282\u70b9\u4e0a\u7684\u8fb9\u8fdb\u884c\u4e24\u4e24\u5339\u914d\u7ec4\u6210\u901a\u8def\uff1b\u53cd\u4e4b\u5982\u679c\u4e0d\u4f7f\u7528\u8fd9\u6761\u8fb9A\uff0c\u5219\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9\uff0c\u8ba9\u5b50\u8282\u70b9\u7684\u8fb9\u8fdb\u884c\u4e24\u4e24\u5339\u914d\uff0c\u7ec4\u6210\u901a\u8def\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll to , val ; }; struct node1 { ll yes , no ; }; vector < node > v [ 100500 ]; vector < node > chr [ 100500 ]; ll dp [ 100500 ][ 2 ] = { 0 }; void dfs ( ll now , ll fa ) ///\u7528\u4e8e\u627e\u8fd9\u4e2a\u70b9\u7684\u5b50\u8282\u70b9 { for ( node i : v [ now ]) { if ( i . to == fa ) continue ; chr [ now ]. push_back ( i ); dfs ( i . to , now ); } } ll work ( ll now , ll has_path ) ///has_path\u4ee3\u8868\u662f\u5426\u4f7f\u7528\u8fd9\u6761\u8fb9 { if ( chr [ now ]. empty ()) return 0 ; if ( dp [ now ][ has_path ] != -1 ) return dp [ now ][ has_path ]; vector < node1 > data ; ll & ans = dp [ now ][ has_path ] = 0 ; for ( node i : chr [ now ]) { node1 data1 ; data1 . yes = work ( i . to , true ) + i . val ; //\u4f7f\u7528\u8fd9\u6761\u8fb9\uff0c\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9 data1 . no = work ( i . to , false ); ///\u4e0d\u4f7f\u7528\u8fd9\u6761\u8fb9\uff0c\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9 data . push_back ( data1 ); } sort ( data . begin (), data . end (),[]( node1 a , node1 b ){ return a . yes - a . no > b . yes - b . no ;}); for ( node1 i : data ) ans += i . no ; ///\u5148\u5bf9\u4e0d\u4f7f\u7528\u8fd9\u4e9b\u8fb9\u7684\u6743\u503c\u6c42\u548c if ( has_path ) ans += data [ 0 ]. yes - data [ 0 ]. no ; ///\u5982\u679c\u7236\u8282\u70b9\u4f7f\u7528\u8fd9\u6761\u8fb9\uff0c\u5219\u5e94\u5f53\u627e\u4e00\u6761\u6743\u503c\u6700\u5927\u7684\u8fb9\u4e0e\u4e4b\u8fde\u63a5 for ( ll i = has_path ; i + 1 < ( ll ) data . size (); i += 2 ) { ll yes = data [ i ]. yes + data [ i + 1 ]. yes ; ll no = data [ i ]. no + data [ i + 1 ]. no ; if ( yes < no ) break ; else { ans += yes - no ; ///\u4ee3\u8868\u4f7f\u7528\u8fd9\u4e24\u6761\u8fb9\u5e76\u7ec4\u6210\u4e00\u4e2a\u901a\u8def } } return ans ; } int main () { ll n , s , e , val ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n -1 ; i ++ ) { scanf ( \"%lld%lld%lld\" , & s , & e , & val ); v [ s ]. push_back ({ e , val }); v [ e ]. push_back ({ s , val }); } memset ( dp , -1 , sizeof ( dp )); dfs ( 1 , -1 ); ll ans = work ( 1 , false ); if ( chr [ 1 ]. size () == 1 ) ///1\u4e3a\u6839\u8282\u70b9\uff0c\u8fd9\u6761\u8fb9\u5fc5\u987b\u4f7f\u7528 ans = max ( ans , work ( 1 , true )); cout << ans << endl ; }","title":"2021-02-22-2\u670822\u65e5\u9898\u89e3"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#a","text":"","title":"A\u9898"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u6784\u9020\u7531n-1\u4e2a2\u548c\u4e00\u4e2a3\u6216\u8005n-2\u4e2a2\u548c\u4e24\u4e2a3\u7684\u6570\uff0c\u4f7f\u5176\u65e0\u6cd5\u88ab2\u548c3\u6574\u9664\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); if ( n == 1 ) printf ( \"-1 \\n \" ); else { int sum = 0 ; for ( int i = 1 ; i <= n -1 ; i ++ ) { if ( i != n -1 ) { sum += 2 ; sum %= 3 ; printf ( \"2\" ); } else { if ( sum == 0 ) printf ( \"23 \\n \" ); else if ( sum == 1 ) printf ( \"33 \\n \" ); else if ( sum == 2 ) printf ( \"23 \\n \" ); } } } } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#b","text":"","title":"B\u9898"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u6a21\u62df\uff0ca[1]\u4e00\u5b9a\u548cb[1]\u76f8\u540c\uff0cx[1]\u4e00\u5b9a\u4e3a0\uff0c\u7136\u540e\u6a21\u62df\u6c422~n\u4e2a\u6570\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int b [ 200500 ] = { 0 }; int a [ 200500 ] = { 0 }; int main () { ll sum = 0 ; int n , m ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & b [ i ]); } int max1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = b [ i ] + max1 ; max1 = max ( max1 , a [ i ]); } for ( int i = 1 ; i <= n ; i ++ ) { printf ( \"%d \" , a [ i ]); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#c","text":"","title":"C\u9898"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u5bb9\u6613\u53d1\u73b0\u5982\u679c\u4f7f\u6c42\u548c\u6700\u5927\uff0c\u5219\u6bcf\u4e00\u5757\u5e94\u8be5\u5305\u542b\u4e00\u4e2a\u6700\u5927\u503c\uff0c\u627e\u51fa\u524dk\u4e2a\u6700\u5927\u503c\u6c42\u548c\u5373\u4e3a\u7b54\u6848\uff0c\u7136\u540e\u5bf9\u6bcf\u4e2a\u6700\u5927\u503c\u7684\u4e0b\u6807\u8fdb\u884c\u505a\u5dee\u6c42\u79ef\u5373\u4e3a\u7b2c\u4e8c\u4e2a\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const long long mod = 998244353 ; struct node { int x , p ; }; node a [ 200500 ] = { 0 }; int main () { int n , k ; scanf ( \"%d%d\" , & n , & k ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]. x ), a [ i ]. p = i ; sort ( a + 1 , a + n + 1 ,[]( node a , node b ){ if ( a . x != b . x ) return a . x > b . x ; else return a . p < b . p ;}); long long ans1 = 0 , ans2 = 1 ; vector < int > v ; for ( int i = 1 ; i <= k ; i ++ ) { ans1 += a [ i ]. x ; v . push_back ( a [ i ]. p ); } sort ( v . begin (), v . end (),[]( int a , int b ){ return a < b ;}); for ( int i = 1 ; i < v . size (); i ++ ) { ans2 = ans2 * ( v [ i ] - v [ i -1 ]); ans2 %= mod ; } printf ( \"%lld %lld \\n \" , ans1 , ans2 ); return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#de","text":"","title":"D\u9898/E\u9898"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"\u53ef\u4ee5\u9884\u5904\u7406\u524d\u7f00\u548c\u540e\u7f00\u76f8\u540c\u7684\u90e8\u5206\uff0c\u7136\u540e\u5bf9\u5269\u4f59\u90e8\u5206\u8fdb\u884cmanacher\u7b97\u6cd5\uff0c\u6c42\u6700\u957f\u7684\u56de\u6587\u4e32\uff0c\u6ce8\uff1a\u8be5\u56de\u6587\u4e32\u5fc5\u987b\u4f4d\u4e8e\u5f00\u5934\u6216\u7ed3\u5c3e\u3002 \u53c2\u7167\u94fe\u63a5\uff1a https://www.luogu.com.cn/blog/xht37/solution-cf1326d2 https://zhuanlan.zhihu.com/p/137172524","title":"\u9898\u89e3"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; char a [ 1005000 ] = { 0 }; char t [ 1005000 ] = { 0 }; int manacher ( char * c ) { int max_id = 0 , ans = 1 , id = 0 ; string str = \"$#\" ; for ( int i = 1 ; c [ i ]; i ++ ) str += c [ i ], str += \"#\" ; vector < int > p ; p . push_back ( 1 ); for ( int i = 1 ; i < ( int ) str . size (); i ++ ) { if ( max_id > i ) p . push_back ( min ( max_id - i , p [ 2 * id - i ])); else p . push_back ( 1 ); while ( i + p [ i ] < ( int ) str . size () && str [ i + p [ i ]] == str [ i - p [ i ]]) p [ i ] ++ ; if ( i == p [ i ]) ///i==p[i]\uff0c\u4ee3\u8868\u8be5\u56de\u6587\u4e32\u4f4d\u4e8e\u5f00\u5934 ans = max ( ans , p [ i ]); if ( i + p [ i ] > max_id ){ max_id = i + p [ i ], id = i ; } } return ans -1 ; } int main () { int time ; scanf ( \"%d\" , & time ); while ( time -- ) { scanf ( \"%s\" , a + 1 ); int n = strlen ( a + 1 ), sum = 1 ; while ( sum <= n && a [ sum ] == a [ n - sum + 1 ]) sum ++ ; if ( sum == n + 1 ) { printf ( \"%s \\n \" , a + 1 ); continue ; } int m = 0 ; for ( int i = sum ; i <= n - sum + 1 ; i ++ ) t [ ++ m ] = a [ i ]; t [ m + 1 ] = '\\0' ; int l_ans = manacher ( t ); reverse ( t + 1 , t + m + 1 ); int r_ans = manacher ( t ); reverse ( t + 1 , t + m + 1 ); if ( l_ans < r_ans ) reverse ( t + 1 , t + m + 1 ), swap ( l_ans , r_ans ); for ( int i = 1 ; i < sum ; i ++ ) printf ( \"%c\" , a [ i ]); for ( int i = 1 ; i <= l_ans ; i ++ ) printf ( \"%c\" , t [ i ]); for ( int i = sum -1 ; i >= 1 ; i -- ) printf ( \"%c\" , a [ i ]); printf ( \" \\n \" ); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#a-comic-binge","text":"","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5bA\u9898 Comic Binge"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"\u7531\u4e8eA\u5fc5\u987b\u7b49B\u8bfb\u5b8c\u540e\u624d\u8bfb\uff0c\u90a3\u4e48\u4e00\u79cd\u53ef\u884c\u7684\u6761\u4ef6\u4fbf\u662fB\u628a\u6240\u6709\u7684\u4e66\u8bfb\u5b8c\u540eA\u518d\u53bb\u8bfb\u6240\u6709\u7684\u4e66\uff0c\u8fd9\u6837\u603b\u65f6\u957f\u662f\u6700\u5927\u7684\uff0c\u4e14A\u548cB\u7684\u91cd\u5408\u8bfb\u4e66\u65f6\u95f4\u4e3a0\u3002\u5982\u679c\u8981\u4f7f\u603b\u65f6\u95f4\u6700\u77ed\uff0c\u90a3\u4e48\u5e94\u5f53\u5c3d\u53ef\u80fd\u589e\u5927\u4e8c\u8005\u7684\u91cd\u5408\u8bfb\u4e66\u65f6\u95f4\uff0c\u52a8\u6001\u89c4\u5212\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_10","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const long long mod = 998244353 ; int dp [ 1050 ][ 10050 ] = { 0 }; ///dp[i][j]\u4ee3\u8868B\u5728\u65f6\u95f4j\u8bfb\u5b8c\u524di-1\u672c\u4e66\u4e8c\u8005\u6700\u5927\u91cd\u5408\u8bfb\u4e66\u65f6\u95f4 int sum_a [ 1050 ] = { 0 }; int a [ 1050 ] = { 0 }, b [ 1050 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]), sum_a [ i ] = sum_a [ i -1 ] + a [ i ]; for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & b [ i ]); int max_b = n * 10 ; ///B\u6700\u5927\u7684\u65f6\u95f4 for ( int i = 1 ; i <= n + 1 ; i ++ ) for ( int j = 0 ; j <= max_b ; j ++ ) dp [ i ][ j ] = -1 ; dp [ 1 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) { for ( int j = 0 ; j <= max_b ; j ++ ) { if ( dp [ i ][ j ] == -1 ) continue ; if ( i <= n && j + b [ i ] <= max_b ) { dp [ i + 1 ][ j + b [ i ]] = max ( dp [ i + 1 ][ j + b [ i ]], min ( dp [ i ][ j ] + b [ i ], sum_a [ i -1 ])); ///B\u8bfbi\u4e66\uff0cB\u8bfb\u5b8c\u524di\u672c\u4e66\u91cd\u5408\u65f6\u95f4\u6700\u5927\u503c //\u6ce8\u610f\u5e94\u5f53\u548csum_a[i-1]\u53d6\u6700\u5c0f\u503c\uff0c\u7531\u4e8eA\u843d\u540e\u4e8eB\u4e00\u672c\u4e66 } if ( i > 1 && i + 1 <= n && j + b [ i + 1 ] <= max_b ) ///B\u8bfbi+1\u4e66\uff0c\u4e0d\u8981\u5fd8\u8bb0i>1\u7684\u6761\u4ef6\uff0cB\u5fc5\u987b\u8bfb\u7b2c\u4e00\u672c\u4e66 dp [ i + 2 ][ j + b [ i + 1 ]] = max ( dp [ i + 2 ][ j + b [ i + 1 ]], min ( dp [ i ][ j ] + b [ i + 1 ], sum_a [ i ])); } } int min1 = 999999999 ; for ( int j = 0 ; j <= max_b ; j ++ ) { if ( dp [ n + 1 ][ j ] != -1 ) min1 = min ( min1 , j - dp [ n + 1 ][ j ] + sum_a [ n ]); } printf ( \"%d \\n \" , min1 ); return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#c-cul-de-sac-parades","text":"","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5bC\u9898 Cul-De-Sac Parades"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_11","text":"\u6811\u4e0aDP\uff0c\u5bf9\u6bcf\u4e2a\u7236\u8282\u70b9\u7684\u7684\u8fb9\u8fdb\u884c\u679a\u4e3e\u9009\u62e9\uff0c\u662f\u5426\u4f7f\u7528\u8fd9\u4e2a\u8fb9\uff08\u5047\u8bbe\u4e3a\u8fb9A\uff09\uff0c\u5982\u679c\u4f7f\u7528\u8fd9\u6761\u8fb9A\uff0c\u5219\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9\uff0c\u627e\u51fa\u8fde\u63a5\u5b50\u8282\u70b9\u6240\u6709\u8fb9\u4e2d\u6743\u503c\u6700\u5927\u7684\u8fb9\uff0c\u5c06\u5176\u4e0e\u8fb9A\u8fdb\u884c\u8fde\u63a5\uff0c\u7ec4\u6210\u4e00\u6761\u901a\u8def\uff0c\u5176\u4f59\u5b50\u8282\u70b9\u4e0a\u7684\u8fb9\u8fdb\u884c\u4e24\u4e24\u5339\u914d\u7ec4\u6210\u901a\u8def\uff1b\u53cd\u4e4b\u5982\u679c\u4e0d\u4f7f\u7528\u8fd9\u6761\u8fb9A\uff0c\u5219\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9\uff0c\u8ba9\u5b50\u8282\u70b9\u7684\u8fb9\u8fdb\u884c\u4e24\u4e24\u5339\u914d\uff0c\u7ec4\u6210\u901a\u8def\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-22-2%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/#_12","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll to , val ; }; struct node1 { ll yes , no ; }; vector < node > v [ 100500 ]; vector < node > chr [ 100500 ]; ll dp [ 100500 ][ 2 ] = { 0 }; void dfs ( ll now , ll fa ) ///\u7528\u4e8e\u627e\u8fd9\u4e2a\u70b9\u7684\u5b50\u8282\u70b9 { for ( node i : v [ now ]) { if ( i . to == fa ) continue ; chr [ now ]. push_back ( i ); dfs ( i . to , now ); } } ll work ( ll now , ll has_path ) ///has_path\u4ee3\u8868\u662f\u5426\u4f7f\u7528\u8fd9\u6761\u8fb9 { if ( chr [ now ]. empty ()) return 0 ; if ( dp [ now ][ has_path ] != -1 ) return dp [ now ][ has_path ]; vector < node1 > data ; ll & ans = dp [ now ][ has_path ] = 0 ; for ( node i : chr [ now ]) { node1 data1 ; data1 . yes = work ( i . to , true ) + i . val ; //\u4f7f\u7528\u8fd9\u6761\u8fb9\uff0c\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9 data1 . no = work ( i . to , false ); ///\u4e0d\u4f7f\u7528\u8fd9\u6761\u8fb9\uff0c\u7ee7\u7eed\u641c\u7d22\u5b50\u8282\u70b9 data . push_back ( data1 ); } sort ( data . begin (), data . end (),[]( node1 a , node1 b ){ return a . yes - a . no > b . yes - b . no ;}); for ( node1 i : data ) ans += i . no ; ///\u5148\u5bf9\u4e0d\u4f7f\u7528\u8fd9\u4e9b\u8fb9\u7684\u6743\u503c\u6c42\u548c if ( has_path ) ans += data [ 0 ]. yes - data [ 0 ]. no ; ///\u5982\u679c\u7236\u8282\u70b9\u4f7f\u7528\u8fd9\u6761\u8fb9\uff0c\u5219\u5e94\u5f53\u627e\u4e00\u6761\u6743\u503c\u6700\u5927\u7684\u8fb9\u4e0e\u4e4b\u8fde\u63a5 for ( ll i = has_path ; i + 1 < ( ll ) data . size (); i += 2 ) { ll yes = data [ i ]. yes + data [ i + 1 ]. yes ; ll no = data [ i ]. no + data [ i + 1 ]. no ; if ( yes < no ) break ; else { ans += yes - no ; ///\u4ee3\u8868\u4f7f\u7528\u8fd9\u4e24\u6761\u8fb9\u5e76\u7ec4\u6210\u4e00\u4e2a\u901a\u8def } } return ans ; } int main () { ll n , s , e , val ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n -1 ; i ++ ) { scanf ( \"%lld%lld%lld\" , & s , & e , & val ); v [ s ]. push_back ({ e , val }); v [ e ]. push_back ({ s , val }); } memset ( dp , -1 , sizeof ( dp )); dfs ( 1 , -1 ); ll ans = work ( 1 , false ); if ( chr [ 1 ]. size () == 1 ) ///1\u4e3a\u6839\u8282\u70b9\uff0c\u8fd9\u6761\u8fb9\u5fc5\u987b\u4f7f\u7528 ans = max ( ans , work ( 1 , true )); cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-24-2%E6%9C%8824%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"E\u9898 Social Distancing \u00b6 \u9898\u89e3 \u00b6 \u5207\u6bd4\u96ea\u592b\u8ddd\u79bb\u548c\u66fc\u54c8\u987f\u8ddd\u79bb\u76f8\u4e92\u8f6c\u53d8 \u6839\u636e\u4e0a\u8ff0\u6027\u8d28\uff0c\u53ef\u4ee5\u5c06\u6c42\u5207\u6bd4\u96ea\u592b\u4e0d\u7b49\u5f0f\u6700\u5c0f\u503c\u8f6c\u5316\u4e3a\u6c42\u66fc\u54c8\u987f\u8ddd\u79bb\u7684\u6700\u5c0f\u503c\u3002 \u4e8c\u7ef4\u77e9\u9635\u6c42\u66fc\u54c8\u987f\u8ddd\u79bb\u53ef\u4ee5\u6839\u636e\u524d\u7f00\u548c\u6765\u51cf\u5c11\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u5982\u679c\u8be5\u70b9\u975e\u75c5\u4eba\uff0c\u6807\u8bb0\u4e3a1\uff0c\u4ee3\u8868\u8be5\u70b9\u6743\u503c\u4e3a1\uff1b\u53cd\u4e4b\u5219\u6807\u8bb0\u4e3a-1\uff0c\u540e\u671f\u6c42\u524d\u7f00\u548c\u65f6\u8be5\u70b9\u6743\u503c\u5b9a\u4e3a0\uff1b\u7136\u540e\u5206\u522b\u6cbf\u56db\u4e2a\u65b9\u5411\u6c42\u524d\u7f00\u548c\uff0c\u53d6\u6700\u5c0f\u503c\u5373\u4e3a\u6bcf\u4e2a\u70b9\u7684\u6700\u5c0f\u66fc\u54c8\u987f\u8ddd\u79bb\u3002 \u6700\u540e\u6839\u636e\u6700\u5c0f\u66fc\u54c8\u987f\u8ddd\u79bbdfs\u8fdb\u884c\u641c\u7d22\u5373\u53ef\u5f97\u51fa\u7b54\u6848\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(2) #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char a [ 505 ][ 505 ] = { 0 }; int ans1 [ 505 ][ 505 ] = { 0 }; int dis [ 505 ][ 505 ] = { 0 }; int sx , sy , ex , ey ; struct node { int x , y , val ; }; int dx [] = { 0 , 1 , -1 , 0 , 0 }; int dy [] = { 0 , 0 , 0 , 1 , -1 }; int n , m ; int ans = -1 ; int dfs ( int x , int y , int val ) { if ( ans >= val ) return 0 ; if ( x == ex && y == ey ) { ans = max ( ans , val ); return 0 ; } for ( int i = 1 ; i <= 4 ; i ++ ) { int xx = x + dx [ i ], yy = y + dy [ i ]; if ( xx < 1 || xx > n || yy < 1 || yy > m ) continue ; if ( a [ xx ][ yy ] == '#' ) continue ; int val1 = min ( val , dis [ xx ][ yy ]); if ( ans1 [ xx ][ yy ] >= val1 ) continue ; ans1 [ xx ][ yy ] = val1 ; dfs ( xx , yy , val1 ); } return 0 ; } int mp [ 1050 ][ 1050 ] = { 0 }; int mp_sum1 [ 1050 ][ 1050 ] = { 0 }; int mp_sum2 [ 1050 ][ 1050 ] = { 0 }; int mp_sum3 [ 1050 ][ 1050 ] = { 0 }; int mp_sum4 [ 1050 ][ 1050 ] = { 0 }; int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dis [ i ][ j ] = inf ; } } for ( int i = 0 ; i < 1050 ; i ++ ) for ( int j = 0 ; j < 1050 ; j ++ ) mp_sum1 [ i ][ j ] = mp_sum2 [ i ][ j ] = mp_sum3 [ i ][ j ] = mp_sum4 [ i ][ j ] = inf ; int sum = 0 ; for ( int i = 0 ; i <= n + 1 ; i ++ ) { int j = 0 ; mp [ i + j ][ i - j + 500 ] = inf ; j = m + 1 ; mp [ i + j ][ i - j + 500 ] = inf ; } for ( int j = 0 ; j <= m + 1 ; j ++ ) { int i = 0 ; mp [ i + j ][ i - j + 500 ] = inf ; i = n + 1 ; mp [ i + j ][ i - j + 500 ] = inf ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ][ j ] == '*' ) { sum ++ ; mp [ i + j ][ i - j + 500 ] = -1 ; } else { mp [ i + j ][ i - j + 500 ] = 1 ; } if ( a [ i ][ j ] == 'S' ) sx = i , sy = j ; if ( a [ i ][ j ] == 'E' ) ex = i , ey = j ; } } for ( int i = 1 ; i < 1050 ; i ++ ) { for ( int j = 1 ; j < 1050 ; j ++ ) { if ( mp [ i ][ j ] == -1 ) mp_sum1 [ i ][ j ] = 0 ; else mp_sum1 [ i ][ j ] = min ( mp_sum1 [ i ][ j ], min ( mp_sum1 [ i -1 ][ j ], mp_sum1 [ i ][ j -1 ]) + mp [ i ][ j ]); } } for ( int i = 1 ; i < 1050 ; i ++ ) { for ( int j = 1049 ; j >= 1 ; j -- ) { if ( mp [ i ][ j ] == -1 ) mp_sum2 [ i ][ j ] = 0 ; else mp_sum2 [ i ][ j ] = min ( mp_sum2 [ i ][ j ], min ( mp_sum2 [ i -1 ][ j ], mp_sum2 [ i ][ j + 1 ]) + mp [ i ][ j ]); } } for ( int i = 1049 ; i >= 1 ; i -- ) { for ( int j = 1 ; j < 1050 ; j ++ ) { if ( mp [ i ][ j ] == -1 ) mp_sum3 [ i ][ j ] = 0 ; else mp_sum3 [ i ][ j ] = min ( mp_sum3 [ i ][ j ], min ( mp_sum3 [ i + 1 ][ j ], mp_sum3 [ i ][ j -1 ]) + mp [ i ][ j ]); } } for ( int i = 1049 ; i >= 1 ; i -- ) { for ( int j = 1049 ; j >= 1 ; j -- ) { if ( mp [ i ][ j ] == -1 ) mp_sum4 [ i ][ j ] = 0 ; else mp_sum4 [ i ][ j ] = min ( mp_sum4 [ i ][ j ], min ( mp_sum4 [ i + 1 ][ j ], mp_sum4 [ i ][ j + 1 ]) + mp [ i ][ j ]); } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int xx = i + j , yy = i - j + 500 ; dis [ i ][ j ] = min ( min ( mp_sum1 [ xx ][ yy ], mp_sum2 [ xx ][ yy ]), min ( mp_sum3 [ xx ][ yy ], mp_sum4 [ xx ][ yy ])); } } dfs ( sx , sy , dis [ sx ][ sy ]); if ( ans != -1 && sum == 0 ) { printf ( \"safe \\n \" ); return 0 ; } printf ( \"%d \\n \" , ans ); }","title":"2021-02-24-2\u670824\u65e5\u9898\u89e3"},{"location":"problem/2021-02-24-2%E6%9C%8824%E6%97%A5%E9%A2%98%E8%A7%A3/#e-social-distancing","text":"","title":"E\u9898 Social Distancing"},{"location":"problem/2021-02-24-2%E6%9C%8824%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u5207\u6bd4\u96ea\u592b\u8ddd\u79bb\u548c\u66fc\u54c8\u987f\u8ddd\u79bb\u76f8\u4e92\u8f6c\u53d8 \u6839\u636e\u4e0a\u8ff0\u6027\u8d28\uff0c\u53ef\u4ee5\u5c06\u6c42\u5207\u6bd4\u96ea\u592b\u4e0d\u7b49\u5f0f\u6700\u5c0f\u503c\u8f6c\u5316\u4e3a\u6c42\u66fc\u54c8\u987f\u8ddd\u79bb\u7684\u6700\u5c0f\u503c\u3002 \u4e8c\u7ef4\u77e9\u9635\u6c42\u66fc\u54c8\u987f\u8ddd\u79bb\u53ef\u4ee5\u6839\u636e\u524d\u7f00\u548c\u6765\u51cf\u5c11\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u5982\u679c\u8be5\u70b9\u975e\u75c5\u4eba\uff0c\u6807\u8bb0\u4e3a1\uff0c\u4ee3\u8868\u8be5\u70b9\u6743\u503c\u4e3a1\uff1b\u53cd\u4e4b\u5219\u6807\u8bb0\u4e3a-1\uff0c\u540e\u671f\u6c42\u524d\u7f00\u548c\u65f6\u8be5\u70b9\u6743\u503c\u5b9a\u4e3a0\uff1b\u7136\u540e\u5206\u522b\u6cbf\u56db\u4e2a\u65b9\u5411\u6c42\u524d\u7f00\u548c\uff0c\u53d6\u6700\u5c0f\u503c\u5373\u4e3a\u6bcf\u4e2a\u70b9\u7684\u6700\u5c0f\u66fc\u54c8\u987f\u8ddd\u79bb\u3002 \u6700\u540e\u6839\u636e\u6700\u5c0f\u66fc\u54c8\u987f\u8ddd\u79bbdfs\u8fdb\u884c\u641c\u7d22\u5373\u53ef\u5f97\u51fa\u7b54\u6848\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-24-2%E6%9C%8824%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#pragma GCC optimize(2) #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char a [ 505 ][ 505 ] = { 0 }; int ans1 [ 505 ][ 505 ] = { 0 }; int dis [ 505 ][ 505 ] = { 0 }; int sx , sy , ex , ey ; struct node { int x , y , val ; }; int dx [] = { 0 , 1 , -1 , 0 , 0 }; int dy [] = { 0 , 0 , 0 , 1 , -1 }; int n , m ; int ans = -1 ; int dfs ( int x , int y , int val ) { if ( ans >= val ) return 0 ; if ( x == ex && y == ey ) { ans = max ( ans , val ); return 0 ; } for ( int i = 1 ; i <= 4 ; i ++ ) { int xx = x + dx [ i ], yy = y + dy [ i ]; if ( xx < 1 || xx > n || yy < 1 || yy > m ) continue ; if ( a [ xx ][ yy ] == '#' ) continue ; int val1 = min ( val , dis [ xx ][ yy ]); if ( ans1 [ xx ][ yy ] >= val1 ) continue ; ans1 [ xx ][ yy ] = val1 ; dfs ( xx , yy , val1 ); } return 0 ; } int mp [ 1050 ][ 1050 ] = { 0 }; int mp_sum1 [ 1050 ][ 1050 ] = { 0 }; int mp_sum2 [ 1050 ][ 1050 ] = { 0 }; int mp_sum3 [ 1050 ][ 1050 ] = { 0 }; int mp_sum4 [ 1050 ][ 1050 ] = { 0 }; int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dis [ i ][ j ] = inf ; } } for ( int i = 0 ; i < 1050 ; i ++ ) for ( int j = 0 ; j < 1050 ; j ++ ) mp_sum1 [ i ][ j ] = mp_sum2 [ i ][ j ] = mp_sum3 [ i ][ j ] = mp_sum4 [ i ][ j ] = inf ; int sum = 0 ; for ( int i = 0 ; i <= n + 1 ; i ++ ) { int j = 0 ; mp [ i + j ][ i - j + 500 ] = inf ; j = m + 1 ; mp [ i + j ][ i - j + 500 ] = inf ; } for ( int j = 0 ; j <= m + 1 ; j ++ ) { int i = 0 ; mp [ i + j ][ i - j + 500 ] = inf ; i = n + 1 ; mp [ i + j ][ i - j + 500 ] = inf ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ][ j ] == '*' ) { sum ++ ; mp [ i + j ][ i - j + 500 ] = -1 ; } else { mp [ i + j ][ i - j + 500 ] = 1 ; } if ( a [ i ][ j ] == 'S' ) sx = i , sy = j ; if ( a [ i ][ j ] == 'E' ) ex = i , ey = j ; } } for ( int i = 1 ; i < 1050 ; i ++ ) { for ( int j = 1 ; j < 1050 ; j ++ ) { if ( mp [ i ][ j ] == -1 ) mp_sum1 [ i ][ j ] = 0 ; else mp_sum1 [ i ][ j ] = min ( mp_sum1 [ i ][ j ], min ( mp_sum1 [ i -1 ][ j ], mp_sum1 [ i ][ j -1 ]) + mp [ i ][ j ]); } } for ( int i = 1 ; i < 1050 ; i ++ ) { for ( int j = 1049 ; j >= 1 ; j -- ) { if ( mp [ i ][ j ] == -1 ) mp_sum2 [ i ][ j ] = 0 ; else mp_sum2 [ i ][ j ] = min ( mp_sum2 [ i ][ j ], min ( mp_sum2 [ i -1 ][ j ], mp_sum2 [ i ][ j + 1 ]) + mp [ i ][ j ]); } } for ( int i = 1049 ; i >= 1 ; i -- ) { for ( int j = 1 ; j < 1050 ; j ++ ) { if ( mp [ i ][ j ] == -1 ) mp_sum3 [ i ][ j ] = 0 ; else mp_sum3 [ i ][ j ] = min ( mp_sum3 [ i ][ j ], min ( mp_sum3 [ i + 1 ][ j ], mp_sum3 [ i ][ j -1 ]) + mp [ i ][ j ]); } } for ( int i = 1049 ; i >= 1 ; i -- ) { for ( int j = 1049 ; j >= 1 ; j -- ) { if ( mp [ i ][ j ] == -1 ) mp_sum4 [ i ][ j ] = 0 ; else mp_sum4 [ i ][ j ] = min ( mp_sum4 [ i ][ j ], min ( mp_sum4 [ i + 1 ][ j ], mp_sum4 [ i ][ j + 1 ]) + mp [ i ][ j ]); } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int xx = i + j , yy = i - j + 500 ; dis [ i ][ j ] = min ( min ( mp_sum1 [ xx ][ yy ], mp_sum2 [ xx ][ yy ]), min ( mp_sum3 [ xx ][ yy ], mp_sum4 [ xx ][ yy ])); } } dfs ( sx , sy , dis [ sx ][ sy ]); if ( ans != -1 && sum == 0 ) { printf ( \"safe \\n \" ); return 0 ; } printf ( \"%d \\n \" , ans ); }","title":"\u4ee3\u7801"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"USACO 2021 February Contest, Bronze Problem 3. Clockwise Fence \u00b6 The fence surrounding Farmer John's largest pasture has fallen into disrepair, and he has finally decided to replace it with a new fence. Unfortunately, as Farmer John is laying out the new fence, a large bee ends up chasing him around the pasture, and as a result, the fence ends up following a rather irregular path. The fence can be described by a string of characters, each either \"N\" (north), \"E\" (east), \"S\" (south), or \"W\" (west). Each character describes a 1-meter run of the fence. For example, if the string is NESW, this means the fence starts by moving north for 1 meter, then east for 1 meter, then south for 1 meter, then west for 1 meter, returning to its starting point. The fence ends at the position where it started, and this is the only point visited more than once by the path of the fence (and the starting point is only re-visited once, at the end). As a result, the fence does indeed enclose a single connected region of the grassy pasture, even though this region could have a rather strange shape. Farmer John is curious if the path in which he laid the fence traveled clockwise (with the enclosed region on the right side of the fence as one walks along the path of the fence in the order specified by the string) or counter-clockwise (with the enclosed region on the left side of the fence). INPUT FORMAT (input arrives from the terminal / stdin): \u00b6 The first line of input contains an integer NN (1\u2264N\u2264201\u2264N\u226420). Each of the next NN lines contains a string of length at least 4 and at most 100, describing a single fence path. OUTPUT FORMAT (print output to the terminal / stdout): \u00b6 For each of the NN fence paths described in the input, output a line containing either \"CW\" (clockwise) or \"CCW\" (counterclockwise). SAMPLE INPUT: \u00b6 2 NESW WSSSEENWNEESSENNNNWWWS SAMPLE OUTPUT: \u00b6 CW CCW The two fence paths with denoting the starting point: *>* ^ v <* *<*<*<* v ^ *< * v ^ * *>*>* * v ^ v ^ * *<* * * v ^ v ^ *>*>* *>* Problem credits: Brian Dean \u9898\u89e3 \u00b6 \u53c2\u7167\u4e8e\uff1a \u7a7a\u95f4\u591a\u8fb9\u5f62\u987a\u9006\u65f6\u9488\u7684\u5224\u65ad \u6839\u636e\u5b57\u7b26\u4e32\u6a21\u62df\u8fd0\u52a8\u65b9\u5411\uff0c\u6839\u636e\u5411\u91cf\u5224\u65ad\u987a\u9006\u65f6\u9488\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; char a [ 200 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , a + 1 ); int x = 0 , y = 0 , sumz = 0 , sumf = 0 ; for ( int j = 1 ; a [ j ]; j ++ ) { int xx , yy ; if ( a [ j ] == 'N' ) yy = y -1 ; else if ( a [ j ] == 'S' ) yy = y + 1 ; else if ( a [ j ] == 'W' ) xx = x -1 ; else if ( a [ j ] == 'E' ) xx = x + 1 ; int val = x * yy - xx * y ; if ( val > 0 ) sumz ++ ; else if ( val < 0 ) sumf ++ ; x = xx , y = yy ; } if ( sumz < sumf ) printf ( \"CCW \\n \" ); else printf ( \"CW \\n \" ); } }","title":"2021-02-28-2\u670828\u65e5\u9898\u89e3"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/#usaco-2021-february-contest-bronze-problem-3-clockwise-fence","text":"The fence surrounding Farmer John's largest pasture has fallen into disrepair, and he has finally decided to replace it with a new fence. Unfortunately, as Farmer John is laying out the new fence, a large bee ends up chasing him around the pasture, and as a result, the fence ends up following a rather irregular path. The fence can be described by a string of characters, each either \"N\" (north), \"E\" (east), \"S\" (south), or \"W\" (west). Each character describes a 1-meter run of the fence. For example, if the string is NESW, this means the fence starts by moving north for 1 meter, then east for 1 meter, then south for 1 meter, then west for 1 meter, returning to its starting point. The fence ends at the position where it started, and this is the only point visited more than once by the path of the fence (and the starting point is only re-visited once, at the end). As a result, the fence does indeed enclose a single connected region of the grassy pasture, even though this region could have a rather strange shape. Farmer John is curious if the path in which he laid the fence traveled clockwise (with the enclosed region on the right side of the fence as one walks along the path of the fence in the order specified by the string) or counter-clockwise (with the enclosed region on the left side of the fence).","title":"USACO 2021 February Contest, Bronze Problem 3. Clockwise Fence"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/#input-format-input-arrives-from-the-terminal-stdin","text":"The first line of input contains an integer NN (1\u2264N\u2264201\u2264N\u226420). Each of the next NN lines contains a string of length at least 4 and at most 100, describing a single fence path.","title":"INPUT FORMAT (input arrives from the terminal / stdin):"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/#output-format-print-output-to-the-terminal-stdout","text":"For each of the NN fence paths described in the input, output a line containing either \"CW\" (clockwise) or \"CCW\" (counterclockwise).","title":"OUTPUT FORMAT (print output to the terminal / stdout):"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/#sample-input","text":"2 NESW WSSSEENWNEESSENNNNWWWS","title":"SAMPLE INPUT:"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/#sample-output","text":"CW CCW The two fence paths with denoting the starting point: *>* ^ v <* *<*<*<* v ^ *< * v ^ * *>*>* * v ^ v ^ * *<* * * v ^ v ^ *>*>* *>* Problem credits: Brian Dean","title":"SAMPLE OUTPUT:"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u53c2\u7167\u4e8e\uff1a \u7a7a\u95f4\u591a\u8fb9\u5f62\u987a\u9006\u65f6\u9488\u7684\u5224\u65ad \u6839\u636e\u5b57\u7b26\u4e32\u6a21\u62df\u8fd0\u52a8\u65b9\u5411\uff0c\u6839\u636e\u5411\u91cf\u5224\u65ad\u987a\u9006\u65f6\u9488\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-02-28-2%E6%9C%8828%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#include <bits/stdc++.h> using namespace std ; char a [ 200 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%s\" , a + 1 ); int x = 0 , y = 0 , sumz = 0 , sumf = 0 ; for ( int j = 1 ; a [ j ]; j ++ ) { int xx , yy ; if ( a [ j ] == 'N' ) yy = y -1 ; else if ( a [ j ] == 'S' ) yy = y + 1 ; else if ( a [ j ] == 'W' ) xx = x -1 ; else if ( a [ j ] == 'E' ) xx = x + 1 ; int val = x * yy - xx * y ; if ( val > 0 ) sumz ++ ; else if ( val < 0 ) sumf ++ ; x = xx , y = yy ; } if ( sumz < sumf ) printf ( \"CCW \\n \" ); else printf ( \"CW \\n \" ); } }","title":"\u4ee3\u7801"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"Codeforces Global Round 13 \u00b6 C\u9898 \u00b6 \u9898\u89e3 \u00b6 \u8d2a\u5fc3\uff0cPekora \u4e00\u5b9a\u4ece\u7b2c\u4e00\u4e2a\u5f00\u59cb\u8df3\uff0c\u76f4\u5230\u628a\u7b2c\u4e00\u4e2a\u53d8\u4e3a1\uff0c\u7136\u540e\u8df3\u5230\u7b2c2\u4e2a\uff0c\u8fd9\u6837\u80fd\u591f\u8fbe\u5230\u6700\u4f18\u89e3\u3002 \u5728\u628a\u4e00\u4e2a\u4f4d\u7f6e\u4e3ai\u4e14\u9ad8\u5ea6\u4e3acur\u7684\u8e66\u5e8a\u53d8\u4e3a1\u65f6\uff0c\u4ece[i+2,cur+i]\u8fd9\u4e2a\u533a\u95f4\u5185\u6240\u6709\u8e66\u5e8a\u7684\u9ad8\u5ea6\u5c06\u51cf\u5c111\u3002 \u5982\u679c\u4f4d\u7f6ei\u7684\u8e66\u5e8a\u9ad8\u5ea6\u5df2\u7ecf\u4e3a1\uff0c\u5219\u5e94\u5f53\u8f6c\u79fb\u5230\u7b2ci+1\u4e2a\u4e0a\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 6000 ] = { 0 }, cur [ 6000 ] = { 0 }; int main () { ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); cur [ i ] = 0 ; } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll now = cur [ i ]; if ( now < a [ i ] -1 ) { ans += a [ i ] - now -1 ; now += a [ i ] - now -1 ; } cur [ i + 1 ] += now - a [ i ] + 1 ; ///\u591a\u51fa\u6765\u7684\u8df3\u5230\u4e0b\u4e00\u4e2a for ( ll j = i + 2 ; j <= min ( n , i + a [ i ]); j ++ ) cur [ j ] += 1 ; } printf ( \"%lld \\n \" , ans ); } } D\u9898 \u00b6 \u9898\u89e3 \u00b6 \u5bb9\u6613\u53d1\u73b0\u5982\u679c\u4e00\u4e2a\u6570u\u4e8c\u8fdb\u5236\u67d0\u4e00\u4f4d\u4e3a1\uff0c\u5219\u53ef\u4ee5\u4e14\u4e00\u4e2a\u5176\u4f59\u5168\u4e3a0\uff0c\u53ea\u6709\u8be5\u4f4d\u7f6e\u4e3a1\u7684\u53e6\u4e00\u4e2a\u6570v\u5e76\u4e14\u7ed3\u679c\u4f9d\u7136\u4e3av\uff0c\u5c06v\u52a0\u5230u\u4e0a\u4fbf\u53ef\u4ee5\u628au\u76841\u524d\u79fb\u4e00\u4f4d\uff0c\u7528\u524d\u7f00\u548c\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <stdio.h> using namespace std ; int a [ 50 ] = { 0 }; int b [ 50 ] = { 0 }; int sum1 [ 50 ] = { 0 }; int sum2 [ 50 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { long long u , v ; scanf ( \"%lld%lld\" , & u , & v ); if ( v < u ) { printf ( \"NO \\n \" ); continue ; } for ( int i = 1 ; i <= 40 ; i ++ ) { a [ i ] = u % 2 , u /= 2 ; sum1 [ i ] = sum1 [ i -1 ] + a [ i ]; } for ( int i = 1 ; i <= 40 ; i ++ ) { b [ i ] = v % 2 , v /= 2 ; sum2 [ i ] = sum2 [ i -1 ] + b [ i ]; } int flag = 1 ; for ( int i = 1 ; i <= 40 ; i ++ ) { if ( sum1 [ i ] < sum2 [ i ]) flag = 0 ; } if ( flag ) printf ( \"YES \\n \" ); else printf ( \"NO \\n \" ); } }","title":"2021-03-02-3\u67082\u65e5\u9898\u89e3"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#codeforces-global-round-13","text":"","title":"Codeforces Global Round 13"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#c","text":"","title":"C\u9898"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"\u8d2a\u5fc3\uff0cPekora \u4e00\u5b9a\u4ece\u7b2c\u4e00\u4e2a\u5f00\u59cb\u8df3\uff0c\u76f4\u5230\u628a\u7b2c\u4e00\u4e2a\u53d8\u4e3a1\uff0c\u7136\u540e\u8df3\u5230\u7b2c2\u4e2a\uff0c\u8fd9\u6837\u80fd\u591f\u8fbe\u5230\u6700\u4f18\u89e3\u3002 \u5728\u628a\u4e00\u4e2a\u4f4d\u7f6e\u4e3ai\u4e14\u9ad8\u5ea6\u4e3acur\u7684\u8e66\u5e8a\u53d8\u4e3a1\u65f6\uff0c\u4ece[i+2,cur+i]\u8fd9\u4e2a\u533a\u95f4\u5185\u6240\u6709\u8e66\u5e8a\u7684\u9ad8\u5ea6\u5c06\u51cf\u5c111\u3002 \u5982\u679c\u4f4d\u7f6ei\u7684\u8e66\u5e8a\u9ad8\u5ea6\u5df2\u7ecf\u4e3a1\uff0c\u5219\u5e94\u5f53\u8f6c\u79fb\u5230\u7b2ci+1\u4e2a\u4e0a\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 6000 ] = { 0 }, cur [ 6000 ] = { 0 }; int main () { ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); cur [ i ] = 0 ; } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll now = cur [ i ]; if ( now < a [ i ] -1 ) { ans += a [ i ] - now -1 ; now += a [ i ] - now -1 ; } cur [ i + 1 ] += now - a [ i ] + 1 ; ///\u591a\u51fa\u6765\u7684\u8df3\u5230\u4e0b\u4e00\u4e2a for ( ll j = i + 2 ; j <= min ( n , i + a [ i ]); j ++ ) cur [ j ] += 1 ; } printf ( \"%lld \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#d","text":"","title":"D\u9898"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u5bb9\u6613\u53d1\u73b0\u5982\u679c\u4e00\u4e2a\u6570u\u4e8c\u8fdb\u5236\u67d0\u4e00\u4f4d\u4e3a1\uff0c\u5219\u53ef\u4ee5\u4e14\u4e00\u4e2a\u5176\u4f59\u5168\u4e3a0\uff0c\u53ea\u6709\u8be5\u4f4d\u7f6e\u4e3a1\u7684\u53e6\u4e00\u4e2a\u6570v\u5e76\u4e14\u7ed3\u679c\u4f9d\u7136\u4e3av\uff0c\u5c06v\u52a0\u5230u\u4e0a\u4fbf\u53ef\u4ee5\u628au\u76841\u524d\u79fb\u4e00\u4f4d\uff0c\u7528\u524d\u7f00\u548c\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-03-02-3%E6%9C%882%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"#include <stdio.h> using namespace std ; int a [ 50 ] = { 0 }; int b [ 50 ] = { 0 }; int sum1 [ 50 ] = { 0 }; int sum2 [ 50 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { long long u , v ; scanf ( \"%lld%lld\" , & u , & v ); if ( v < u ) { printf ( \"NO \\n \" ); continue ; } for ( int i = 1 ; i <= 40 ; i ++ ) { a [ i ] = u % 2 , u /= 2 ; sum1 [ i ] = sum1 [ i -1 ] + a [ i ]; } for ( int i = 1 ; i <= 40 ; i ++ ) { b [ i ] = v % 2 , v /= 2 ; sum2 [ i ] = sum2 [ i -1 ] + b [ i ]; } int flag = 1 ; for ( int i = 1 ; i <= 40 ; i ++ ) { if ( sum1 [ i ] < sum2 [ i ]) flag = 0 ; } if ( flag ) printf ( \"YES \\n \" ); else printf ( \"NO \\n \" ); } }","title":"\u4ee3\u7801"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"\u95ee\u9898E Group Project \u00b6 \u9898\u76ee\u63cf\u8ff0 \u00b6 The big day has finally arrived: today you are going to form groups of two in which you will do the end-of-the-year project. When you arrive at school, you learn that the teacher of the other class is sick, and that your teacher, Mr. B.A.P. Cee, will also have to make groups for the other class. Mr. B.A.P. Cee is a smart guy and realizes that he can use these unfortunate circumstances to his advantage. Ending up with groups of one should be avoided at all cost, so mixing the students of the two classes may avoid this situation. However, while it is easy to pair up two students from the same class, it is more difficult to match up students from different classes. Throughout the years there has been a lot of rivalry between the two groups, and many students dislike students in the other class. Mr. B.A.P. Cee knows which pairs of students will result in a fight and a failed project. You are given a list of pairs of students who cannot work together. How many disjoint groups of two can Mr. B.A.P. Cee make that will not result in a failed project? \u8f93\u5165 \u00b6 The input consists of: \u2022 A line with two integers n (1 \u2264 n \u2264 105 ), the number of students, and m (0 \u2264 m \u2264 2 \u00b7 105 ),the number of pairs of students who cannot work together. \u2022 m lines, each with two distinct integers i and j (1 \u2264 i, j \u2264 n , i \u2260 j ), giving a pair of students who cannot work together. Students are identified by the numbers 1 through n . It is guaranteed that it is possible to split the students into two classes in such a way that all students from the same class get along. \u8f93\u51fa \u00b6 Output the number of pairs of students Mr. B.A.P. Cee can make without making any pair of students who cannot work together. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 3 2 1 2 3 1 \u3010\u6837\u4f8b2\u3011 5 6 1 4 2 4 3 4 1 5 2 5 3 5 \u3010\u6837\u4f8b3\u3011 6 6 1 4 2 5 3 6 1 5 3 5 2 6 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 2 \u3010\u6837\u4f8b3\u3011 3 \u9898\u89e3 \u00b6 \u9898\u76ee\u5927\u610f\u4e3a\u4e24\u4e2a\u73ed\u4e4b\u95f4\u8981\u8fdb\u884c\u4e24\u4e24\u7ec4\u961f\u5408\u4f5c\uff0c\u5176\u4e2d\u6709\u4e9b\u4eba\u4e0d\u80fd\u548c\u53e6\u4e00\u73ed\u7ea7\u4e2d\u4e00\u4e9b\u4eba\u8fdb\u884c\u7ec4\u961f\uff0c\u5e76\u4e14\u73ed\u7ea7\u5185\u90e8\u90fd\u53ef\u4ee5\u8fdb\u884c\u7ec4\u961f\uff0c\u95ee\u6700\u591a\u53ef\u4ee5\u7ec4\u961f\u7684\u961f\u6570\u3002 \u5148\u7528DFS\u5212\u5206\u51fa\u4e24\u4e2a\u73ed\u7684\u4eba\uff0c\u7136\u540e\u5224\u65ad\u4e24\u4e2a\u73ed\u7ea7\u4e4b\u95f4\u662f\u5426\u4e24\u4e24\u90fd\u6709\u77db\u76fe\uff0c\u5206\u4e24\u79cd\u60c5\u51b5\u8ba8\u8bba\u3002 \u5982\u679c\u4efb\u4f55\u4e24\u4e2a\u4eba\u90fd\u6709\u77db\u76fe\uff0c\u5219\u5e94\u5f53\u73ed\u7ea7\u5185\u90e8\u8fdb\u884c\u5206\u7ec4\u5408\u4f5c\u3002 \u5982\u679c\u4e0d\u662f\u6240\u6709\u4eba\u4e4b\u95f4\u90fd\u6709\u77db\u76fe\uff0c\u5219\u7b54\u6848\u5e94\u4e3a\u603b\u4eba\u6570\u9664\u4ee52\uff0c\u5206\u4ee5\u4e0b\u4e09\u79cd\u60c5\u51b5\u8ba8\u8bba\uff1a \u4e24\u4e2a\u73ed\u4e2d\u4eba\u6570\u5747\u4e3a\u5076\u6570\uff0c\u5219\u4e24\u4e2a\u73ed\u7ea7\u5185\u90e8\u4e4b\u95f4\u76f4\u63a5\u8fdb\u884c\u5206\u7ec4\uff0c\u7b54\u6848\u4e3an/2 \u4e24\u4e2a\u73ed\u4e2d\u4eba\u6570\u4e00\u5947\u4e00\u5076\uff0c\u4e24\u4e2a\u73ed\u7ea7\u5185\u90e8\u76f4\u63a5\u5206\u7ec4\uff0c\u7b54\u6848\u4ecd\u4e3an/2 \u4e24\u4e2a\u73ed\u4e2d\u4eba\u6570\u5747\u4e3a\u5947\u6570\uff0c\u5219\u4e24\u4e2a\u73ed\u7ea7\u4e4b\u95f4\u80af\u5b9a\u5b58\u5728\u4e00\u5bf9\u8de8\u73ed\u7ea7\u7684\u4eba\u6ca1\u6709\u77db\u76fe\uff0c\u53ef\u4ee5\u7ec4\u6210\u4e00\u5bf9\uff0c\u5176\u4ed6\u5185\u90e8\u4e4b\u95f4\u5206\u7ec4\uff0c\u7b54\u6848\u4ecd\u672an/2 \u7efc\u4e0a\uff0c\u7b54\u6848\u4e3a\u603b\u4eba\u6570\u9664\u4ee52\uff0c\u5373\u4e3an/2 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; vector < int > edge [ 100500 ]; int depth [ 100500 ] = { 0 }; int vis [ 100500 ] = { 0 }; int dfs ( int k , int dep ) { depth [ k ] = dep ; for ( int to : edge [ k ]) { if ( depth [ to ] == 0 ) { dfs ( to , 3 - dep ); } } return 0 ; } int main () { int n , m , s , e ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & s , & e ); edge [ s ]. push_back ( e ); edge [ e ]. push_back ( s ); } dfs ( 1 , 1 ); int sum1 = 0 , sum2 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( depth [ i ] == 1 ) sum1 ++ ; if ( depth [ i ] == 2 ) sum2 ++ ; } if ( sum1 + sum2 == n && sum1 * sum2 == m ) printf ( \"%d \\n \" , sum1 / 2 + sum2 / 2 ); else printf ( \"%d \\n \" , n / 2 ); } \u9898\u89e3 \u00b6 \u7528multiset\u7ef4\u62a4\u8d28\u56e0\u6570\u4e2a\u6570\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; ll qpow ( ll a , ll n ) { ll r = 1 ; while ( n ) { if ( n & 1 ) r = ( r * a ) % mod ; n >>= 1 ; a = ( a * a ) % mod ; } return r ; } multiset < ll > st [ 200500 ]; map < ll , ll > mp [ 200500 ]; vector < ll > prime ; int vis [ 200500 ] = { 0 }; ll last [ 200500 ] = { 0 }; int main () { ll n , m , k , pos ; scanf ( \"%lld%lld\" , & n , & k ); for ( int i = 2 ; i <= 200000 ; i ++ ) { if ( ! vis [ i ]) prime . push_back ( i ); for ( int j = 2 ; j * i <= 200000 ; j ++ ) vis [ i * j ] = 1 ; } for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & m ); for ( ll j : prime ) { if ( m == 1 ) break ; if ( ! vis [ m ]) { mp [ i ][ m ] = 1 ; st [ m ]. insert ( 1 ); break ; } ll t = 0 ; while ( m % j == 0 ) { m /= j ; t ++ ; } if ( t ) { mp [ i ][ j ] = t ; st [ j ]. insert ( t ); } } } ll ans = 1 ; for ( ll j : prime ) { if ( st [ j ]. size () == n ) { int tem = * st [ j ]. begin (); if ( tem != last [ j ]) { ans = ans * qpow ( j , tem - last [ j ]) % mod ; last [ j ] = tem ; } } } while ( k -- ) { scanf ( \"%lld%lld\" , & pos , & m ); for ( ll j : prime ) { if ( m == 1 ) break ; if ( ! vis [ m ]) { ll & tem = mp [ pos ][ m ]; if ( tem ) st [ m ]. erase ( st [ m ]. lower_bound ( tem )); tem ++ ; st [ m ]. insert ( tem ); if ( st [ m ]. size () == n ) { int tem1 = * st [ m ]. begin (); if ( tem1 != last [ m ]) { ans = ans * qpow ( m , tem1 - last [ m ]) % mod ; last [ m ] = tem1 ; } } break ; } ll t = 0 ; while ( m % j == 0 ) { m /= j ; t ++ ; } if ( t ) { ll & tem = mp [ pos ][ j ]; if ( tem ) st [ j ]. erase ( st [ j ]. lower_bound ( tem )); tem += t ; st [ j ]. insert ( tem ); if ( st [ j ]. size () == n ) { int tem1 = * st [ j ]. begin (); if ( tem1 != last [ j ]) { ans = ans * qpow ( j , tem1 - last [ j ]) % mod ; last [ j ] = tem1 ; } } } } printf ( \"%lld \\n \" , ans ); } }","title":"2021-03-07-3\u67087\u65e5\u9898\u89e3"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#e-group-project","text":"","title":"\u95ee\u9898E Group Project"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"The big day has finally arrived: today you are going to form groups of two in which you will do the end-of-the-year project. When you arrive at school, you learn that the teacher of the other class is sick, and that your teacher, Mr. B.A.P. Cee, will also have to make groups for the other class. Mr. B.A.P. Cee is a smart guy and realizes that he can use these unfortunate circumstances to his advantage. Ending up with groups of one should be avoided at all cost, so mixing the students of the two classes may avoid this situation. However, while it is easy to pair up two students from the same class, it is more difficult to match up students from different classes. Throughout the years there has been a lot of rivalry between the two groups, and many students dislike students in the other class. Mr. B.A.P. Cee knows which pairs of students will result in a fight and a failed project. You are given a list of pairs of students who cannot work together. How many disjoint groups of two can Mr. B.A.P. Cee make that will not result in a failed project?","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"The input consists of: \u2022 A line with two integers n (1 \u2264 n \u2264 105 ), the number of students, and m (0 \u2264 m \u2264 2 \u00b7 105 ),the number of pairs of students who cannot work together. \u2022 m lines, each with two distinct integers i and j (1 \u2264 i, j \u2264 n , i \u2260 j ), giving a pair of students who cannot work together. Students are identified by the numbers 1 through n . It is guaranteed that it is possible to split the students into two classes in such a way that all students from the same class get along.","title":"\u8f93\u5165"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"Output the number of pairs of students Mr. B.A.P. Cee can make without making any pair of students who cannot work together.","title":"\u8f93\u51fa"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"\u3010\u6837\u4f8b1\u3011 3 2 1 2 3 1 \u3010\u6837\u4f8b2\u3011 5 6 1 4 2 4 3 4 1 5 2 5 3 5 \u3010\u6837\u4f8b3\u3011 6 6 1 4 2 5 3 6 1 5 3 5 2 6","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 2 \u3010\u6837\u4f8b3\u3011 3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"\u9898\u76ee\u5927\u610f\u4e3a\u4e24\u4e2a\u73ed\u4e4b\u95f4\u8981\u8fdb\u884c\u4e24\u4e24\u7ec4\u961f\u5408\u4f5c\uff0c\u5176\u4e2d\u6709\u4e9b\u4eba\u4e0d\u80fd\u548c\u53e6\u4e00\u73ed\u7ea7\u4e2d\u4e00\u4e9b\u4eba\u8fdb\u884c\u7ec4\u961f\uff0c\u5e76\u4e14\u73ed\u7ea7\u5185\u90e8\u90fd\u53ef\u4ee5\u8fdb\u884c\u7ec4\u961f\uff0c\u95ee\u6700\u591a\u53ef\u4ee5\u7ec4\u961f\u7684\u961f\u6570\u3002 \u5148\u7528DFS\u5212\u5206\u51fa\u4e24\u4e2a\u73ed\u7684\u4eba\uff0c\u7136\u540e\u5224\u65ad\u4e24\u4e2a\u73ed\u7ea7\u4e4b\u95f4\u662f\u5426\u4e24\u4e24\u90fd\u6709\u77db\u76fe\uff0c\u5206\u4e24\u79cd\u60c5\u51b5\u8ba8\u8bba\u3002 \u5982\u679c\u4efb\u4f55\u4e24\u4e2a\u4eba\u90fd\u6709\u77db\u76fe\uff0c\u5219\u5e94\u5f53\u73ed\u7ea7\u5185\u90e8\u8fdb\u884c\u5206\u7ec4\u5408\u4f5c\u3002 \u5982\u679c\u4e0d\u662f\u6240\u6709\u4eba\u4e4b\u95f4\u90fd\u6709\u77db\u76fe\uff0c\u5219\u7b54\u6848\u5e94\u4e3a\u603b\u4eba\u6570\u9664\u4ee52\uff0c\u5206\u4ee5\u4e0b\u4e09\u79cd\u60c5\u51b5\u8ba8\u8bba\uff1a \u4e24\u4e2a\u73ed\u4e2d\u4eba\u6570\u5747\u4e3a\u5076\u6570\uff0c\u5219\u4e24\u4e2a\u73ed\u7ea7\u5185\u90e8\u4e4b\u95f4\u76f4\u63a5\u8fdb\u884c\u5206\u7ec4\uff0c\u7b54\u6848\u4e3an/2 \u4e24\u4e2a\u73ed\u4e2d\u4eba\u6570\u4e00\u5947\u4e00\u5076\uff0c\u4e24\u4e2a\u73ed\u7ea7\u5185\u90e8\u76f4\u63a5\u5206\u7ec4\uff0c\u7b54\u6848\u4ecd\u4e3an/2 \u4e24\u4e2a\u73ed\u4e2d\u4eba\u6570\u5747\u4e3a\u5947\u6570\uff0c\u5219\u4e24\u4e2a\u73ed\u7ea7\u4e4b\u95f4\u80af\u5b9a\u5b58\u5728\u4e00\u5bf9\u8de8\u73ed\u7ea7\u7684\u4eba\u6ca1\u6709\u77db\u76fe\uff0c\u53ef\u4ee5\u7ec4\u6210\u4e00\u5bf9\uff0c\u5176\u4ed6\u5185\u90e8\u4e4b\u95f4\u5206\u7ec4\uff0c\u7b54\u6848\u4ecd\u672an/2 \u7efc\u4e0a\uff0c\u7b54\u6848\u4e3a\u603b\u4eba\u6570\u9664\u4ee52\uff0c\u5373\u4e3an/2","title":"\u9898\u89e3"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"#include <bits/stdc++.h> using namespace std ; vector < int > edge [ 100500 ]; int depth [ 100500 ] = { 0 }; int vis [ 100500 ] = { 0 }; int dfs ( int k , int dep ) { depth [ k ] = dep ; for ( int to : edge [ k ]) { if ( depth [ to ] == 0 ) { dfs ( to , 3 - dep ); } } return 0 ; } int main () { int n , m , s , e ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d%d\" , & s , & e ); edge [ s ]. push_back ( e ); edge [ e ]. push_back ( s ); } dfs ( 1 , 1 ); int sum1 = 0 , sum2 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( depth [ i ] == 1 ) sum1 ++ ; if ( depth [ i ] == 2 ) sum2 ++ ; } if ( sum1 + sum2 == n && sum1 * sum2 == m ) printf ( \"%d \\n \" , sum1 / 2 + sum2 / 2 ); else printf ( \"%d \\n \" , n / 2 ); }","title":"\u4ee3\u7801"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"\u7528multiset\u7ef4\u62a4\u8d28\u56e0\u6570\u4e2a\u6570\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-03-07-3%E6%9C%887%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; ll qpow ( ll a , ll n ) { ll r = 1 ; while ( n ) { if ( n & 1 ) r = ( r * a ) % mod ; n >>= 1 ; a = ( a * a ) % mod ; } return r ; } multiset < ll > st [ 200500 ]; map < ll , ll > mp [ 200500 ]; vector < ll > prime ; int vis [ 200500 ] = { 0 }; ll last [ 200500 ] = { 0 }; int main () { ll n , m , k , pos ; scanf ( \"%lld%lld\" , & n , & k ); for ( int i = 2 ; i <= 200000 ; i ++ ) { if ( ! vis [ i ]) prime . push_back ( i ); for ( int j = 2 ; j * i <= 200000 ; j ++ ) vis [ i * j ] = 1 ; } for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & m ); for ( ll j : prime ) { if ( m == 1 ) break ; if ( ! vis [ m ]) { mp [ i ][ m ] = 1 ; st [ m ]. insert ( 1 ); break ; } ll t = 0 ; while ( m % j == 0 ) { m /= j ; t ++ ; } if ( t ) { mp [ i ][ j ] = t ; st [ j ]. insert ( t ); } } } ll ans = 1 ; for ( ll j : prime ) { if ( st [ j ]. size () == n ) { int tem = * st [ j ]. begin (); if ( tem != last [ j ]) { ans = ans * qpow ( j , tem - last [ j ]) % mod ; last [ j ] = tem ; } } } while ( k -- ) { scanf ( \"%lld%lld\" , & pos , & m ); for ( ll j : prime ) { if ( m == 1 ) break ; if ( ! vis [ m ]) { ll & tem = mp [ pos ][ m ]; if ( tem ) st [ m ]. erase ( st [ m ]. lower_bound ( tem )); tem ++ ; st [ m ]. insert ( tem ); if ( st [ m ]. size () == n ) { int tem1 = * st [ m ]. begin (); if ( tem1 != last [ m ]) { ans = ans * qpow ( m , tem1 - last [ m ]) % mod ; last [ m ] = tem1 ; } } break ; } ll t = 0 ; while ( m % j == 0 ) { m /= j ; t ++ ; } if ( t ) { ll & tem = mp [ pos ][ j ]; if ( tem ) st [ j ]. erase ( st [ j ]. lower_bound ( tem )); tem += t ; st [ j ]. insert ( tem ); if ( st [ j ]. size () == n ) { int tem1 = * st [ j ]. begin (); if ( tem1 != last [ j ]) { ans = ans * qpow ( j , tem1 - last [ j ]) % mod ; last [ j ] = tem1 ; } } } } printf ( \"%lld \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/2021-03-09-%E6%95%B0%E8%AE%BA/","text":"\u53c2\u8003\u94fe\u63a5 \u00b6 \u4e58\u6cd5\u9006\u5143 \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u7406 \u6b27\u62c9\u51fd\u6570\u63a8\u5bfc \u6b27\u62c9\u51fd\u6570\u4ee3\u7801 \u6b27\u62c9\u51fd\u6570\u8be6\u7ec6\u63a8\u5bfc \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u6c42\u9006\u5143 \u00b6 \u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll exgcd ( ll a , ll b , ll & x , ll & y ) ///\u540e\u4e24\u4e2a\u53c2\u6570\u4e3a\u5f15\u7528 { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll gcd_ans = exgcd ( b , a % b , x , y ); ll tem = x ; x = y ; y = tem - a / b * y ; return gcd_ans ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; ll a , q , x = 0 , y = 0 ; cin >> a >> q ; ll gcd_ans = exgcd ( q , a , x , y ); ll mul = q / gcd_ans ; y = ( y % mul + mul ) % mul ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << y << endl ; } \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u8fd8\u6709\u5176\u4ed6\u5e94\u7528\uff0c\u4f8b\u5982\u6c42\u89e3\u540c\u4f59\u65b9\u7a0b\uff0c\u5176\u4f59\u8bf7\u53c2\u8003 \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u7406 \u535a\u5ba2\u3002 \u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u89e3\u9006\u5143 \u00b6 \u53ea\u9002\u7528\u4e8eq\u4e3a\u8d28\u6570\u65f6\uff0c\u53ef\u4ee5\u6c42\u89e3\u9006\u5143\u3002 \u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a , q ; ll ksm ( ll n , ll k ) { ll sum1 = 1 , sum2 = n ; while ( k != 0 ) { if ( k % 2 == 1 ) sum1 = sum1 * sum2 % q ; sum2 = sum2 * sum2 % q ; k /= 2 ; } return sum1 ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; cin >> a >> q ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << ksm ( a , q -2 ) << endl ; } \u8d39\u9a6c\u5c0f\u5b9a\u7406\u4e58\u6cd5\u9006\u5143\u4e00\u4e2a\u5e94\u7528\u4fbf\u662f\u6c42\u7ec4\u5408\u6570\uff0c\u4e00\u822c\u5bf91e9+7\u8fdb\u884c\u53d6\u4f59\uff0c\u800c1e9+7\u662f\u4e00\u4e2a\u8d28\u6570\uff0c\u53ef\u4ee5\u7528\u5c0f\u8d39\u9a6c\u5b9a\u7406\u6765\u6c42\u9006\u5143\uff0c\u4ee3\u7801\u4e3a\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll mod = 1e9 + 7 ; ll jc [ 100500 ] = { 0 }; ll ny [ 100500 ] = { 0 }; ll ksm ( ll n , ll k ) { ll sum1 = 1 , sum2 = n ; while ( k != 0 ) { if ( k % 2 == 1 ) sum1 = sum1 * sum2 % mod ; sum2 = sum2 * sum2 % mod ; k /= 2 ; } return sum1 ; } ll c ( ll n , ll m ) { if ( n < m ) swap ( n , m ); return ( jc [ n ] % mod * ny [ m ] % mod ) % mod * ny [ n - m ] % mod ; } int main () { jc [ 0 ] = 1 ; for ( int i = 1 ; i <= 100000 ; i ++ ) { jc [ i ] = jc [ i -1 ] * i ; ny [ i ] = ksm ( jc [ i ], mod -2 ); } int n , m ; cin >> n >> m ; cout << c ( n , m ) << endl ; } \u6b27\u62c9\u51fd\u6570 \u00b6 \u6b27\u62c9\u51fd\u6570\u7528\u6765\u6c42\u6bd4n\u5c0f\u4e14\u548cn\u4e92\u8d28\u5143\u7d20\u4e2a\u6570\u3002 \u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; int is_prime [ 100500 ] = { 0 }; vector < int > prime ; int oula_table [ 100500 ] = { 0 }; void init ( int n ) ///\u6253\u7d20\u6570\u8868 { for ( int i = 2 ; i <= n ; i ++ ) { if ( ! is_prime [ i ]) prime . push_back ( i ); for ( int j = 0 ; j <= prime . size () && i * prime [ j ] <= n ; j ++ ) { is_prime [ i * prime [ j ]] = 1 ; if ( i % prime [ j ] == 0 ) break ; } } } int oula1 ( int n ) ///\u6839\u636e\u7d20\u6570\u8868\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int ans = n ; for ( int i = 0 ; prime [ i ] * prime [ i ] <= n ; i ++ ) { if ( n % prime [ i ] == 0 ) ans = ans - ans / prime [ i ]; while ( n % prime [ i ] == 0 ) n /= prime [ i ]; } return ans ; } int oula2 ( int n ) ///\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int m = n ; int ans = n ; for ( int i = 2 ; i <= sqrt ( n ); i ++ ) { if ( m % i == 0 ) ans = ans - ans / i ; while ( m % i == 0 ) m /= i ; } if ( m != 1 ) ans = ans - ans / m ; return ans ; } void get_oula_table ( int n ) ///\u6b27\u62c9\u6253\u8868 { for ( int i = 1 ; i <= n ; i ++ ) oula_table [ i ] = 0 ; oula_table [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! oula_table [ i ]) ///\u8bf4\u660ei\u662f\u8d28\u6570 { for ( int j = i ; j <= n ; j += i ) //\u53bb\u627ei\u7684\u500d\u6570 { if ( ! oula_table [ j ]) oula_table [ j ] = j ; oula_table [ j ] = oula_table [ j ] / i * ( i -1 ); } } } } int main () { int n ; cin >> n ; init ( n ); cout << \"\u627e\u7d20\u6570\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula1 ( n ) << endl ; cout << \"\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula2 ( n ) << endl ; get_oula_table ( n ); cout << \"\u6253\u8868\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" ; for ( int i = 1 ; i <= n ; i ++ ) cout << oula_table [ i ] << ' ' ; } \u6b27\u62c9\u51fd\u6570\u7684\u5e94\u7528 \u8fb9\u585e\u4efb\u52a1 \u4f60\u7684\u8981\u585e\u2fa5\u6709N\u540d\u968f\u4ece\uff0c\u6bcf\u540d\u968f\u4ece\u6709\u2f00\u4e2a\u6218\u2f43\u2f12\u503cAi\uff0c\u4e0d\u540c\u968f\u4ece\u7684\u6218\u2f43\u2f12\u53ef\u4ee5\u76f8\u540c\uff0c\u4e14\u6c38\u8fdc\u4e0d\u8d85\u8fc7N\u3002\u2f00\u4e2a\u8981\u585e\u4efb\u52a1\u9700\u8981\u6070\u597dM\u4e2a\u968f\u4ece\u53c2\u4e0e\u3002 \u8981\u585e\u4efb\u52a1\u7684\u5956\u52b1\u53d6\u51b3\u4e8e\u968f\u4ece\u4eec\u914d\u5408\u7684\u7a0b\u5ea6\u3002\uff08\u663e\u2f7d\u6613\u89c1\u5730\uff09\uff0cM\u4e2a\u968f\u4ece\u7684\u8054\u5408\u6218\u2f43\u2f12A\u4e3a\u5b83\u4eec\u6218\u2f43\u2f12\u7684\u6700\u2f24\u516c\u7ea6\u6570\uff0c\u2f7d\u4efb\u52a1\u7684\u5956\u52b1\u5206\u6570\u5b9a\u4e49\u4e3a\u03d5(A)\u3002 \u6c42\u6700\u2f24\u53ef\u80fd\u7684\u5956\u52b1\u5206\u6570\u3002 \u8f93\u5165 \u672c\u9898\u6709\u591a\u7ec4\u6570\u636e\uff0c\u7b2c\u2f00\u2f8f\u4e3a\u6570\u636e\u7ec4\u6570T\uff08T\u226410\uff09\u3002 \u63a5\u4e0b\u6765\u6bcf\u7ec4\u6570\u636e\u6709\u4e24\u2f8f\uff0c\u7b2c\u2f00\u2f8f\u4e24\u4e2a\u6574\u6570N\uff0cM\uff0c\u7b2c\u2f06\u2f8fN\u4e2a\u6574\u6570Ai\uff08N\uff0cM\uff0cAi\u2264100000\uff09\u3002 \u8f93\u51fa \u6700\u591a\u7684\u5956\u52b1\u5206\u6570\u3002 \u6837\u4f8b\u8f93\u5165 1 5 2 1 4 6 9 12 \u6837\u4f8b\u8f93\u51fa 2 \u63d0\u793a \u6837\u4f8b\u89e3\u91ca\uff1a\u6d3e\u51fa\u7f16\u53f7\u4e3a6\u548c12\u7684\u968f\u4ece\uff0c\u8054\u5408\u6218\u2f43\u2f12\u4e3a3\uff0c\u5956\u52b1\u5206\u65702\u3002 \u4ee3\u7801 #include <iostream> #include <bits/stdc++.h> using namespace std ; const int N = 100000 ; typedef long long int ll ; int pd [ 100500 ] = { 0 }; //01\u6570\u7ec4\u5b58\u653e\u662f\u5426\u4e3a\u8d28\u6570 int b [ 100500 ] = { 0 }; //\u5b58\u653e\u7684\u8d28\u6570\u6570\u5217 int out [ 100500 ] = { 0 }; //\u6b27\u62c9\u51fd\u6570 \u03c6(A) int num [ 100500 ] = { 0 }; //\u8ba1\u6570\u7528\u7684 void init () { //\u6b27\u62c9\u7b5b\u6cd5 int sum = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( ! pd [ i ]) { b [ ++ sum ] = i ; out [ i ] = i - 1 ; } for ( int j = 1 ; b [ j ] * i <= N ; j ++ ) { pd [ b [ j ] * i ] = 1 ; if ( i % b [ j ] == 0 ) break ; } } //\u6c42\u03c6(A) out [ 1 ] = 1 ; int t ; for ( int i = 2 ; i <= N ; i ++ ) { if ( pd [ i ]) { out [ i ] = i ; t = i ; for ( int j = 1 ; j <= sum && t > 1 ; j ++ ) { if ( i % b [ j ] == 0 ) { out [ i ] = out [ i ] * ( b [ j ] - 1 ) / b [ j ]; //\u5957\u7528\u516c\u5f0f while ( t % b [ j ] == 0 ) { t = t / b [ j ]; } } if ( b [ j ] * 2 > i ) break ; } } } } int main () { init (); int t ; scanf ( \"%d\" , & t ); for ( int k1 = 0 ; k1 < t ; k1 ++ ) { int n , k ; int ans = -1 ; memset ( num , 0 , sizeof ( num )); //\u6e05\u7a7a\uff0c\u52ff\u5fd8@\uff01\uff01\uff01 scanf ( \"%d%d\" , & n , & k ); ll max1 = -1 ; for ( int i = 0 ; i < n ; i ++ ) { ll x ; scanf ( \"%lld\" , & x ); num [ x ] ++ ; //\u8ba1\u6570 max1 = max ( max1 , x ); } for ( int i = 1 ; i <= max1 ; i ++ ) { ll tot = 0 ; for ( int j = i ; j <= max1 ; j = j + i ) //j\u6bcf\u4e00\u6b21\u9012\u589ei\u5219\u8fd9\u4e9b\u6570\u80af\u5b9a\u6709\u4e00\u4e2a\u516c\u7ea6\u6570i { tot += num [ j ]; //\u8ba1\u6570 } if ( tot >= k ) //\u5982\u679c\u6570\u76ee\u5927\u4e8ek { ans = max ( ans , out [ i ]); //\u8ba1\u7b97 \u03c6(A) \u5e76\u6c42\u6700\u5927\u503c } } cout << ans << endl ; } return 0 ; }","title":"2021-03-09-\u6570\u8bba"},{"location":"problem/2021-03-09-%E6%95%B0%E8%AE%BA/#_1","text":"\u4e58\u6cd5\u9006\u5143 \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u7406 \u6b27\u62c9\u51fd\u6570\u63a8\u5bfc \u6b27\u62c9\u51fd\u6570\u4ee3\u7801 \u6b27\u62c9\u51fd\u6570\u8be6\u7ec6\u63a8\u5bfc \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406","title":"\u53c2\u8003\u94fe\u63a5"},{"location":"problem/2021-03-09-%E6%95%B0%E8%AE%BA/#_2","text":"\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll exgcd ( ll a , ll b , ll & x , ll & y ) ///\u540e\u4e24\u4e2a\u53c2\u6570\u4e3a\u5f15\u7528 { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll gcd_ans = exgcd ( b , a % b , x , y ); ll tem = x ; x = y ; y = tem - a / b * y ; return gcd_ans ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; ll a , q , x = 0 , y = 0 ; cin >> a >> q ; ll gcd_ans = exgcd ( q , a , x , y ); ll mul = q / gcd_ans ; y = ( y % mul + mul ) % mul ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << y << endl ; } \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u8fd8\u6709\u5176\u4ed6\u5e94\u7528\uff0c\u4f8b\u5982\u6c42\u89e3\u540c\u4f59\u65b9\u7a0b\uff0c\u5176\u4f59\u8bf7\u53c2\u8003 \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u7406 \u535a\u5ba2\u3002","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u6c42\u9006\u5143"},{"location":"problem/2021-03-09-%E6%95%B0%E8%AE%BA/#_3","text":"\u53ea\u9002\u7528\u4e8eq\u4e3a\u8d28\u6570\u65f6\uff0c\u53ef\u4ee5\u6c42\u89e3\u9006\u5143\u3002 \u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a , q ; ll ksm ( ll n , ll k ) { ll sum1 = 1 , sum2 = n ; while ( k != 0 ) { if ( k % 2 == 1 ) sum1 = sum1 * sum2 % q ; sum2 = sum2 * sum2 % q ; k /= 2 ; } return sum1 ; } int main () { cout << \"\u8bf7\u8f93\u5165a\u548cq\u7684\u503c\" << endl ; cin >> a >> q ; cout << \"a\u5173\u4e8e\u6a21q\u7684\u9006\u5143\u4e3a\" << ksm ( a , q -2 ) << endl ; } \u8d39\u9a6c\u5c0f\u5b9a\u7406\u4e58\u6cd5\u9006\u5143\u4e00\u4e2a\u5e94\u7528\u4fbf\u662f\u6c42\u7ec4\u5408\u6570\uff0c\u4e00\u822c\u5bf91e9+7\u8fdb\u884c\u53d6\u4f59\uff0c\u800c1e9+7\u662f\u4e00\u4e2a\u8d28\u6570\uff0c\u53ef\u4ee5\u7528\u5c0f\u8d39\u9a6c\u5b9a\u7406\u6765\u6c42\u9006\u5143\uff0c\u4ee3\u7801\u4e3a\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll mod = 1e9 + 7 ; ll jc [ 100500 ] = { 0 }; ll ny [ 100500 ] = { 0 }; ll ksm ( ll n , ll k ) { ll sum1 = 1 , sum2 = n ; while ( k != 0 ) { if ( k % 2 == 1 ) sum1 = sum1 * sum2 % mod ; sum2 = sum2 * sum2 % mod ; k /= 2 ; } return sum1 ; } ll c ( ll n , ll m ) { if ( n < m ) swap ( n , m ); return ( jc [ n ] % mod * ny [ m ] % mod ) % mod * ny [ n - m ] % mod ; } int main () { jc [ 0 ] = 1 ; for ( int i = 1 ; i <= 100000 ; i ++ ) { jc [ i ] = jc [ i -1 ] * i ; ny [ i ] = ksm ( jc [ i ], mod -2 ); } int n , m ; cin >> n >> m ; cout << c ( n , m ) << endl ; }","title":"\u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u89e3\u9006\u5143"},{"location":"problem/2021-03-09-%E6%95%B0%E8%AE%BA/#_4","text":"\u6b27\u62c9\u51fd\u6570\u7528\u6765\u6c42\u6bd4n\u5c0f\u4e14\u548cn\u4e92\u8d28\u5143\u7d20\u4e2a\u6570\u3002 \u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; int is_prime [ 100500 ] = { 0 }; vector < int > prime ; int oula_table [ 100500 ] = { 0 }; void init ( int n ) ///\u6253\u7d20\u6570\u8868 { for ( int i = 2 ; i <= n ; i ++ ) { if ( ! is_prime [ i ]) prime . push_back ( i ); for ( int j = 0 ; j <= prime . size () && i * prime [ j ] <= n ; j ++ ) { is_prime [ i * prime [ j ]] = 1 ; if ( i % prime [ j ] == 0 ) break ; } } } int oula1 ( int n ) ///\u6839\u636e\u7d20\u6570\u8868\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int ans = n ; for ( int i = 0 ; prime [ i ] * prime [ i ] <= n ; i ++ ) { if ( n % prime [ i ] == 0 ) ans = ans - ans / prime [ i ]; while ( n % prime [ i ] == 0 ) n /= prime [ i ]; } return ans ; } int oula2 ( int n ) ///\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570 { int m = n ; int ans = n ; for ( int i = 2 ; i <= sqrt ( n ); i ++ ) { if ( m % i == 0 ) ans = ans - ans / i ; while ( m % i == 0 ) m /= i ; } if ( m != 1 ) ans = ans - ans / m ; return ans ; } void get_oula_table ( int n ) ///\u6b27\u62c9\u6253\u8868 { for ( int i = 1 ; i <= n ; i ++ ) oula_table [ i ] = 0 ; oula_table [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! oula_table [ i ]) ///\u8bf4\u660ei\u662f\u8d28\u6570 { for ( int j = i ; j <= n ; j += i ) //\u53bb\u627ei\u7684\u500d\u6570 { if ( ! oula_table [ j ]) oula_table [ j ] = j ; oula_table [ j ] = oula_table [ j ] / i * ( i -1 ); } } } } int main () { int n ; cin >> n ; init ( n ); cout << \"\u627e\u7d20\u6570\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula1 ( n ) << endl ; cout << \"\u5206\u89e3\u8d28\u56e0\u6570\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" << oula2 ( n ) << endl ; get_oula_table ( n ); cout << \"\u6253\u8868\u6cd5\u6c42\u89e3\u6b27\u62c9\u51fd\u6570\u503c\u4e3a\" ; for ( int i = 1 ; i <= n ; i ++ ) cout << oula_table [ i ] << ' ' ; } \u6b27\u62c9\u51fd\u6570\u7684\u5e94\u7528 \u8fb9\u585e\u4efb\u52a1 \u4f60\u7684\u8981\u585e\u2fa5\u6709N\u540d\u968f\u4ece\uff0c\u6bcf\u540d\u968f\u4ece\u6709\u2f00\u4e2a\u6218\u2f43\u2f12\u503cAi\uff0c\u4e0d\u540c\u968f\u4ece\u7684\u6218\u2f43\u2f12\u53ef\u4ee5\u76f8\u540c\uff0c\u4e14\u6c38\u8fdc\u4e0d\u8d85\u8fc7N\u3002\u2f00\u4e2a\u8981\u585e\u4efb\u52a1\u9700\u8981\u6070\u597dM\u4e2a\u968f\u4ece\u53c2\u4e0e\u3002 \u8981\u585e\u4efb\u52a1\u7684\u5956\u52b1\u53d6\u51b3\u4e8e\u968f\u4ece\u4eec\u914d\u5408\u7684\u7a0b\u5ea6\u3002\uff08\u663e\u2f7d\u6613\u89c1\u5730\uff09\uff0cM\u4e2a\u968f\u4ece\u7684\u8054\u5408\u6218\u2f43\u2f12A\u4e3a\u5b83\u4eec\u6218\u2f43\u2f12\u7684\u6700\u2f24\u516c\u7ea6\u6570\uff0c\u2f7d\u4efb\u52a1\u7684\u5956\u52b1\u5206\u6570\u5b9a\u4e49\u4e3a\u03d5(A)\u3002 \u6c42\u6700\u2f24\u53ef\u80fd\u7684\u5956\u52b1\u5206\u6570\u3002 \u8f93\u5165 \u672c\u9898\u6709\u591a\u7ec4\u6570\u636e\uff0c\u7b2c\u2f00\u2f8f\u4e3a\u6570\u636e\u7ec4\u6570T\uff08T\u226410\uff09\u3002 \u63a5\u4e0b\u6765\u6bcf\u7ec4\u6570\u636e\u6709\u4e24\u2f8f\uff0c\u7b2c\u2f00\u2f8f\u4e24\u4e2a\u6574\u6570N\uff0cM\uff0c\u7b2c\u2f06\u2f8fN\u4e2a\u6574\u6570Ai\uff08N\uff0cM\uff0cAi\u2264100000\uff09\u3002 \u8f93\u51fa \u6700\u591a\u7684\u5956\u52b1\u5206\u6570\u3002 \u6837\u4f8b\u8f93\u5165 1 5 2 1 4 6 9 12 \u6837\u4f8b\u8f93\u51fa 2 \u63d0\u793a \u6837\u4f8b\u89e3\u91ca\uff1a\u6d3e\u51fa\u7f16\u53f7\u4e3a6\u548c12\u7684\u968f\u4ece\uff0c\u8054\u5408\u6218\u2f43\u2f12\u4e3a3\uff0c\u5956\u52b1\u5206\u65702\u3002 \u4ee3\u7801 #include <iostream> #include <bits/stdc++.h> using namespace std ; const int N = 100000 ; typedef long long int ll ; int pd [ 100500 ] = { 0 }; //01\u6570\u7ec4\u5b58\u653e\u662f\u5426\u4e3a\u8d28\u6570 int b [ 100500 ] = { 0 }; //\u5b58\u653e\u7684\u8d28\u6570\u6570\u5217 int out [ 100500 ] = { 0 }; //\u6b27\u62c9\u51fd\u6570 \u03c6(A) int num [ 100500 ] = { 0 }; //\u8ba1\u6570\u7528\u7684 void init () { //\u6b27\u62c9\u7b5b\u6cd5 int sum = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( ! pd [ i ]) { b [ ++ sum ] = i ; out [ i ] = i - 1 ; } for ( int j = 1 ; b [ j ] * i <= N ; j ++ ) { pd [ b [ j ] * i ] = 1 ; if ( i % b [ j ] == 0 ) break ; } } //\u6c42\u03c6(A) out [ 1 ] = 1 ; int t ; for ( int i = 2 ; i <= N ; i ++ ) { if ( pd [ i ]) { out [ i ] = i ; t = i ; for ( int j = 1 ; j <= sum && t > 1 ; j ++ ) { if ( i % b [ j ] == 0 ) { out [ i ] = out [ i ] * ( b [ j ] - 1 ) / b [ j ]; //\u5957\u7528\u516c\u5f0f while ( t % b [ j ] == 0 ) { t = t / b [ j ]; } } if ( b [ j ] * 2 > i ) break ; } } } } int main () { init (); int t ; scanf ( \"%d\" , & t ); for ( int k1 = 0 ; k1 < t ; k1 ++ ) { int n , k ; int ans = -1 ; memset ( num , 0 , sizeof ( num )); //\u6e05\u7a7a\uff0c\u52ff\u5fd8@\uff01\uff01\uff01 scanf ( \"%d%d\" , & n , & k ); ll max1 = -1 ; for ( int i = 0 ; i < n ; i ++ ) { ll x ; scanf ( \"%lld\" , & x ); num [ x ] ++ ; //\u8ba1\u6570 max1 = max ( max1 , x ); } for ( int i = 1 ; i <= max1 ; i ++ ) { ll tot = 0 ; for ( int j = i ; j <= max1 ; j = j + i ) //j\u6bcf\u4e00\u6b21\u9012\u589ei\u5219\u8fd9\u4e9b\u6570\u80af\u5b9a\u6709\u4e00\u4e2a\u516c\u7ea6\u6570i { tot += num [ j ]; //\u8ba1\u6570 } if ( tot >= k ) //\u5982\u679c\u6570\u76ee\u5927\u4e8ek { ans = max ( ans , out [ i ]); //\u8ba1\u7b97 \u03c6(A) \u5e76\u6c42\u6700\u5927\u503c } } cout << ans << endl ; } return 0 ; }","title":"\u6b27\u62c9\u51fd\u6570"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/","text":"6\u67085\u65e5\u9898\u89e3 \u00b6 \u4ea4\u6362 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2828&pid=9 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u7ed9\u51fa\u4e00\u4e2a\u5e8f\u5217A\uff0c\u5176\u4e2d\u7b2ci\u4e2a\u6570\u5b57\u4e3aai\uff0c\u4f60\u6bcf\u6b21\u53ef\u4ee5\u9009\u62e9\u4e00\u4e2a\u6570\u5b57\u4e0d\u53d8\uff0c\u5c06\u5176\u4ed6\u6570\u5b57\u5168\u90e8\u4e58\u4ee5x\u3002\u5176\u4e2dx\u4e3a\u4efb\u610f\u7d20\u6570\u3002 \u65e0\u9700\u8003\u8651\u8fd9\u4e9b\u6570\u5b57\u5728\u53d8\u6362\u8fc7\u7a0b\u4e2d\u662f\u5426\u8d85\u8fc7long long\u7684\u5b58\u50a8\u8303\u56f4\u3002\u8bf7\u56de\u7b54\uff1a\u6700\u5c11\u7ecf\u8fc7\u591a\u5c11\u6b21\u64cd\u4f5c\uff0c\u53ef\u4ee5\u4f7f\u5f97\u5e8f\u5217\u4e2d\u6240\u6709\u6570\u5b57\u5168\u90e8\u76f8\u540c\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u5305\u542b\u4e00\u4e2a\u6b63\u6574\u6570n\uff0c\u4ee3\u8868\u5e8f\u5217\u957f\u5ea6\u3002 \u63a5\u4e0b\u6765\u4e00\u884c\u5305\u542bn\u4e2a\u6b63\u6574\u6570\uff0c\u63cf\u8ff0\u5e8f\u5217\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5143\u7d20\u3002 \u8f93\u51fa \u00b6 \u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570\u8868\u793a\u7b54\u6848\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 2 5 7 \u6837\u4f8b\u8f93\u51fa \u00b6 2 \u63d0\u793a \u00b6 \u6837\u4f8b\u8bf4\u660e\uff1a \u53ef\u4ee5\u9009\u4e2d\u7b2c\u4e8c\u4e2a\u6570\u5b57\u4e0d\u53d8\uff0c\u5c06\u7b2c\u4e00\u4e2a\u6570\u5b57\u9664\u4ee55\uff0c\u7136\u540e\u9009\u4e2d\u7b2c\u4e00\u4e2a\u6570\u5b57\u4e0d\u53d8\uff0c\u5c06\u7b2c\u4e8c\u4e2a\u6570\u5b57\u9664\u4ee57\u3002\u4e24\u6b21\u64cd\u4f5c\u540e\uff0c\u6570\u7ec4\u4e2d\u6240\u6709\u6570\u5b57\u5747\u53d8\u4e3a1\u3002\u5f53\u7136\u8fd8\u6709\u5176\u4ed6\u65b9\u6cd5\uff0c\u5982\u5c06\u4e24\u4e2a\u6570\u5b57\u6700\u7ec8\u90fd\u53d8\u4e3a35\u4e5f\u53ea\u9700\u89812\u6b21\u64cd\u4f5c\u3002 \u3010\u6570\u636e\u8303\u56f4\u3011 \u5bf9\u4e8e20%\u7684\u6570\u636e\uff0c\u6ee1\u8db3n=2,ai\u2264106 \u5bf9\u4e8e40%\u7684\u6570\u636e\uff0c\u6ee1\u8db3n\u226410,ai\u2264106 \u5bf9\u4e8e\u53e6\u591620%\u7684\u6570\u636e\uff0c\u6ee1\u8db3n\u22644\u2217104,ai\u226420 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c\u6ee1\u8db31\u2264n\u2264106,1\u2264ai\u2264106 \u9898\u89e3 \u00b6 \u5bf9\u5176\u4ed6\u6570\u8fdb\u884c\u505a\u4e58\u6cd5\u76f8\u5f53\u4e8e\u5bf9\u81ea\u5df1\u505a\u4e58\u6cd5\uff0c\u53ef\u4ee5\u5bf9\u6bcf\u4e00\u4e2a\u6570\u9664\u6389\u6700\u5927\u516c\u7ea6\u6570\u4e92\u8d28\u540e\uff0c\u7edf\u8ba1\u548c\u8ba1\u7b97\u8d28\u56e0\u6570\u7684\u4e2a\u6570\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 1005000 ] = { 0 }; ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ); } ll prime [ 1005000 ] = { 0 }; ll is_prime [ 1005000 ] = { 0 }; int main () { ll cnt = 0 ; for ( ll i = 2 ; i <= 1e6 ; i ++ ) { if ( ! is_prime [ i ]) prime [ ++ cnt ] = i ; for ( ll j = 1 ; j <= cnt ; j ++ ) { if ( i * prime [ j ] > 1e6 ) break ; is_prime [ i * prime [ j ]] = 1 ; if ( i % prime [ j ] == 0 ) break ; } } ll n , m = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); m = gcd ( a [ i ], m ); } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { a [ i ] /= m ; for ( ll j = 1 ; j <= cnt && prime [ j ] * prime [ j ] <= a [ i ]; j ++ ) { while ( a [ i ] % prime [ j ] == 0 ) { ans ++ ; a [ i ] /= prime [ j ]; } } if ( a [ i ] != 1 ) ans ++ ; } printf ( \"%lld \\n \" , ans ); } Disjoint Set of Common Divisors \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2826&pid=4 \u9898\u76ee\u63cf\u8ff0 \u00b6 Given are positive integers A and B. Let us choose some number of positive common divisors of A and B. Here, any two of the chosen divisors must be coprime. At most, how many divisors can we choose? \u2192Definition of common divisor \u00b7An integer d is said to be a common divisor of integers x and y when d divides both x and y. \u2192Definition of being coprime \u00b7Integers x and y are said to be coprime when x and y have no positive common divisors other than 1. \u2192Definition of dividing \u00b7An integer x is said to divide another integer y when there exists an integer \u03b1 such that y=\u03b1x. Constraints \u00b7All values in input are integers. \u00b71\u2264A,B\u22641012 \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: A B \u8f93\u51fa \u00b6 Print the maximum number of divisors that can be chosen to satisfy the condition. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 12 18 \u3010\u6837\u4f8b2\u3011 420 660 \u3010\u6837\u4f8b3\u3011 1 2019 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 3 \u3010\u6837\u4f8b2\u3011 4 \u3010\u6837\u4f8b3\u3011 1 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca 12 and 18 have the following positive common divisors: 1, 2, 3, and 6. 1 and 2 are coprime, 2 and 3 are coprime, and 3 and 1 are coprime, so we can choose 1, 2, and 3, which achieve the maximum result. \u6837\u4f8b3\u89e3\u91ca 1 and 2019 have no positive common divisors other than 1. \u9898\u89e3 \u00b6 \u6c42gcd(A,B)\u7684\u8d28\u56e0\u6570\u6709\u591a\u5c11\u4e2a\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n , m ; cin >> n >> m ; ll k = __gcd ( n , m ); ll ans = 1 ; for ( ll i = 2 ; i * i <= k ; i ++ ) { if ( k % i == 0 ) ans ++ ; while ( k % i == 0 ) k /= i ; } if ( k != 1 ) ans ++ ; cout << ans << endl ; return 0 ; } \u725b\u725b\u7684\u6ed1\u52a8\u7a97\u53e3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2826&pid=9 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u725b\u725b\u6700\u8fd1\u5b66\u4e60\u4e86\u6ed1\u52a8\u7a97\u53e3\u7c7b\u7684\u7b97\u6cd5\uff0c\u6ed1\u52a8\u7a97\u53e3\u7b97\u6cd5\u53ef\u4ee5\u89e3\u51b3\u4e00\u4e9b\u7ebf\u6027\u6570\u7ec4\u7684\u79bb\u7ebf\u9759\u6001\u533a\u95f4\u67e5\u8be2\u7c7b\u95ee\u9898\u3002 \u5177\u4f53\u6765\u8bf4\uff0c\u5047\u8bbe\u5bf9\u4e8e\u4e00\u4e2a\u6570\u7ec4\u8fdb\u884cm\u6b21\u9759\u6001\u533a\u95f4\u67e5\u8be2\u95ee\u9898\u3002\u5982\u679c\u8fd9\u4e9b\u67e5\u8be2\u6ee1\u8db3\u6761\u4ef6\uff1a\u2200i,j\u5f53li\u2264lj\u65f6\uff0c\u603b\u6709ri\u2264rj\u3002\uff08i,j\u8868\u793a\u67e5\u8be2\u7684\u7f16\u53f7\uff0cl,r\u8868\u793a\u67e5\u8be2\u7684\u5de6\u53f3\u7aef\u70b9\uff09 \u63a5\u4e0b\u6765\u53ea\u8981\u67e5\u8be2\u7684\u95ee\u9898\u6ee1\u8db3\u53ef\u4ee5\u5feb\u901f\u63d2\u5165\u548c\u5220\u9664\u5355\u70b9\uff0c\u5c31\u53ef\u4ee5\u4f7f\u7528\u6ed1\u52a8\u7a97\u53e3\u4f18\u5316\uff0c\u5c06\u8fd9m\u6b21\u67e5\u8be2\u7684\u590d\u6742\u5ea6\u964d\u4f4e\u5230O(n)\u3002 \u663e\u7136\uff0c\u5982\u679c\u5bf9\u4e8e\u4e00\u4e2a\u6570\u7ec4\u7684\u533a\u95f4\u67e5\u8be2\u95ee\u9898\uff0c\u67e5\u8be2\u7684\u533a\u95f4\u957f\u5ea6\u7ed9\u5b9a\u4e3ak\u65f6\uff0c\u603b\u662f\u6ee1\u8db3\u2200i,j\u5f53li\u2008\u2264\u2008lj\u65f6\uff0c\u603b\u6709ri\u2264rj\u8fd9\u4e00\u6761\u4ef6\u7684\u3002 \u725b\u725b\u63a5\u4e0b\u6765\u60f3\u8981\u95ee\u4f60\u7684\u95ee\u9898\u4e5f\u548c\u5b9a\u957f\u6ed1\u52a8\u7a97\u53e3\u6709\u5173\u3002 \u4f17\u6240\u5468\u77e5\uff0c\u957f\u5ea6\u4e3ak\u7684\u6ed1\u52a8\u7a97\u53e3\u4ece\u5de6\u5230\u53f3\u53bb\u622a\u53d6\u4e00\u4e2a\u957f\u5ea6\u5927\u5c0f\u4e3an\u7684\u6570\u7ec4\u65f6\uff0c\u4e00\u5171\u53ef\u4ee5\u622a\u53d6\u5230n-k+1\u4e2a\u5b50\u6570\u7ec4\u3002 \u725b\u725b\u5c06\u8fd9n-k+1\u4e2a\u5b50\u6570\u7ec4\u7684\u6781\u5927\u503c\u4e0e\u6781\u5c0f\u503c\u7684\u4e58\u79ef\u6c42\u548c\u79f0\u4e3a\u8be5\u6570\u7ec4\u7684\"\u7b2ck\u7a97\u53e3\u503c\"\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5047\u8bbe\u957f\u5ea6\u4e3a5\u7684\u6570\u7ec4\u4e3a[1,5,2,4,3]\uff0c\u957f\u5ea6\u4e3a3\u7684\u6ed1\u52a8\u7a97\u53e3\u53ef\u4ee5\u622a\u53d6\u4e09\u4e2a\u5b50\u6570\u7ec4\uff0c\u5b83\u4eec\u5206\u522b\u4e3a[1,5,2],[5,2,4],[2,4,3]\u3002 \u6240\u4ee5\u8be5\u6570\u7ec4\u7684\u201c\u7b2c3\u7a97\u53e3\u503c\u201d\u4e3a1*5+2*5+2*4=23\u3002 \u5bf9\u4e8e\u4e00\u4e2a\u7ed9\u5b9a\u5927\u5c0f\u7684\u6570\u7ec4n\uff0c\u725b\u725b\u73b0\u5728\u60f3\u8981\u77e5\u9053\u5b83\u7684\u7b2c1,2,3,4,5...n\u7a97\u53e3\u503c\u5404\u662f\u591a\u5c11\uff0c\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u89e3\u51b3\u4ed6\u7684\u95ee\u9898\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u8f93\u5165\u4e00\u4e2a\u6b63\u6574\u6570n\uff0c\u8868\u793a\u6570\u7ec4\u7684\u5927\u5c0f\u3002 \u63a5\u4e0b\u6765\u4e00\u884c\u8f93\u5165n\u4e2a\u6b63\u6574\u6570ai\uff0c\u8868\u793a\u6570\u7ec4\u7684\u5185\u5bb9 \u8f93\u51fa \u00b6 \u8f93\u51fa\u4e00\u884cn\u4e2a\u6b63\u6574\u6570\uff0c\u8868\u793a\u6ed1\u52a8\u7a97\u53e3\u7684\u957f\u5ea6\u5206\u522b\u4e3a1,2,3,4,5...n\u65f6\uff0c\u95ee\u9898\u7684\u7b54\u6848\u3002 \u8f93\u51fa\u7684\u6574\u6570\u4e4b\u95f4\u7528\u7a7a\u683c\u9694\u5f00\uff0c\u884c\u672b\u4e0d\u5141\u8bb8\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 5 1 5 2 4 3 \u6837\u4f8b\u8f93\u51fa \u00b6 55 35 23 15 5 \u63d0\u793a \u00b6 \u6837\u4f8b\u89e3\u91ca\uff1a \u7b2c1\u7a97\u53e3\u503c=1*1+5*5+2*2+4*4+3*3=55 \u7b2c2\u7a97\u53e3\u503c=5*1+5*2+4*2+4*3=35 \u7b2c3\u7a97\u53e3\u503c=5*1+5*2+4*2=23 \u7b2c4\u7a97\u53e3\u503c=5*1+5*2=15 \u7b2c5\u7a97\u53e3\u503c=5*1=5 \u5bf9\u4e8e10%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u226410 \u5bf9\u4e8e20%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u2264100 \u5bf9\u4e8e30%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u22641000 \u5bf9\u4e8e50%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u22646000 \u5bf9\u4e8e\u53e6\u591610%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264ai\u226410 \u5bf9\u4e8e100%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u2264105,1\u2264ai\u2264100 \u9898\u89e3 \u00b6 \u6682\u672a\u60f3\u51fa\uff0c\u601d\u8def\u4e3a\u5355\u8c03\u6808\uff0c\u5f85\u8865\uff01\uff01\uff01 https://blog.csdn.net/weixin_43346722/article/details/109151074 \u4ee3\u7801 \u00b6 #include <cstdio> #include <iostream> using namespace std ; struct node { int x , num ; } bigstack [ 101 ], smallstack [ 101 ]; int n , a [ 100001 ], ans [ 100001 ], bigtop , smalltop , maxn , minn ; int lft , bignow , smallnow ; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); for ( int i = 1 ; i <= n ; i ++ ) { while ( bigtop && bigstack [ bigtop ]. x <= a [ i ]) bigtop -- ; while ( smalltop && smallstack [ smalltop ]. x >= a [ i ]) smalltop -- ; //\u6808\u7684\u5f39\u51fa bigstack [ ++ bigtop ] = ( node ){ a [ i ], i }; //\u63d2\u5165 smallstack [ ++ smalltop ] = ( node ){ a [ i ], i }; maxn = minn = a [ i ]; lft = i ; bignow = bigtop - 1 ; smallnow = smalltop - 1 ; while ( bignow || smallnow ) { //\u4e00\u70b9\u4e00\u70b9\u5f80\u540e\u79fb\uff0c\u7b97\u8d21\u732e if ( bignow && smallnow ) { if ( bigstack [ bignow ]. num >= smallstack [ smallnow ]. num ) { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - bigstack [ bignow ]. num + 1 ] -= maxn * minn ; lft = bigstack [ bignow ]. num ; maxn = bigstack [ bignow ]. x ; bignow -- ; } else { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - smallstack [ smallnow ]. num + 1 ] -= maxn * minn ; lft = smallstack [ smallnow ]. num ; minn = smallstack [ smallnow ]. x ; smallnow -- ; } continue ; } if ( bignow ) { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - bigstack [ bignow ]. num + 1 ] -= maxn * minn ; lft = bigstack [ bignow ]. num ; maxn = bigstack [ bignow ]. x ; bignow -- ; } else { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - smallstack [ smallnow ]. num + 1 ] -= maxn * minn ; lft = smallstack [ smallnow ]. num ; minn = smallstack [ smallnow ]. x ; smallnow -- ; } } ans [ i - lft + 1 ] += maxn * minn ; ans [ i + 1 ] -= maxn * minn ; } for ( int i = 1 ; i <= n ; i ++ ) { ans [ i ] += ans [ i - 1 ]; //\u56e0\u4e3a\u662f\u5dee\u5206\uff0c\u6240\u4ee5\u8981\u52a0\u4e0a\u524d\u9762\u7684 printf ( \"%d \" , ans [ i ]); } return 0 ; } \u7b49\u5dee\u5e8f\u5217\u524d\u7f00\u548c\uff08\u53cc\u524d\u7f00\u548c\uff09 \u00b6 \u542c\u8bf4\u7f57\u7fd4\u8001\u5e08\u6700\u8fd1\u5f88\u706b\u3002 \u5f20\u4e09\u4eca\u5929\u8feb\u4e0d\u53ca\u5f85\u60f3\u72af\u7f6a\u3002\u5c31\u51b3\u5b9a\u662f\u7206\u70b8\u7f6a\u4e86\uff0c\u6b63\u597d\u7f57\u8001\u5e08\u8bb2\u4e86\u8fd9\u4e2a\u6848\u4f8b\u3002 \u4ed6\u4e00\u773c\u5c31\u770b\u4e0a\u4e86 CaPeF_Yyx \u7684\u5bb6 \uff08\u6216\u8bb8\u662f\u4ed6\u592a duliu \u4e86\uff09 \u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u86ee\u4e0d\u8bb2\u7406\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u4f1a\u6ce2\u53ca\u90e8\u5206\u8857\u9053\u3002\u6bcf\u6b21\u7206\u70b8\u4f1a\u9020\u6210\u4e00\u5b9a\u7684\u635f\u574f\u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u51fa\u4eba\u610f\u6599\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u6ce2\u53ca\u7684\u8303\u56f4\u6bcf\u6b21\u90fd\u4e0d\u4e00\u6837\u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u5341\u6076\u4e0d\u8d66\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u4f1a\u8fdb\u884cm \u6b21 \uff08CaPeF_Yyx \u7684\u5bb6\u4e5f\u592a\u575a\u56fa\u4e86\u5427\uff09 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u4e95\u4e95\u6709\u6761\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u6ce2\u53ca\u7684\u8303\u56f4\u662f\u4e00\u4e2a\u95ed\u533a\u95f4\u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u7cbe\u76ca\u6c42\u7cbe\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u4ee5\u7b49\u5dee\u6570\u5217\u7684\u65b9\u5f0f\u9020\u6210\u4f24\u5bb3\u3002 CaPeF_Yyx \u5bb6\u5728\u504f\u8fdc\u89d2\u843d\uff0c\u8857\u9053\u7f16\u53f7\u4ece1~n \u3002 CaPeF_Yyx \u8857\u9053\u521a\u7ffb\u65b0\uff0c\u6bcf\u95f4\u623f\u5c4b\u7834\u574f\u7a0b\u5ea6\u90fd\u4e3a0\u3002 \u7f57\u7fd4\u8001\u5e08\u53ef\u4ee5\u9884\u6d4b\u6bcf\u6b21\u7206\u70b8\u7684\u8303\u56f4\u3002\u4f1a\u7ed9\u5230 CaPeF_Yyx \u5f62\u5982[l,r] \u7684\u95ed\u533a\u95f4\u3002 \u7f57\u7fd4\u8001\u5e08\u53ef\u4ee5\u9884\u6d4b\u6bcf\u6b21\u7206\u70b8\u7684\u4f24\u5bb3\u3002\u4f1a\u7ed9\u5230 CaPeF_Yyx \u5f62\u5982l,r,bg,ed \u7684 4 \u4e2a\u6570\u3002 \u8868\u793a\u5f62\u5982{ql,ql+1,...,qr-1,qr},ql=bg,qr=ed\u7684\u7b49\u5dee\u6570\u5217\uff0c\u5bf9\u4e8e\u8857\u9053ai(l\u2264i\u2264r)\uff0c\u9020\u6210qi\u7684\u4f24\u5bb3\u3002 CaPeF_Yyx \u627e\u5230\u4e86 Rainy7 \u4fee\u590d\u8857\u9053\u3002\u53ef\u662f\u5979\u5fc5\u987b\u5148\u77e5\u9053\u8857\u9053\u5230\u5e95\u635f\u574f\u4e86\u591a\u5c11\u3002 \u5979\u8fd8\u5fd9\u7740\u62ef\u6551\u4e16\u754c\u5462\uff0cCaPeF_Yyx \u88ab\u5413\u5f97\u4e0d\u8f7b\uff0c\u4e8e\u662f\u53ea\u80fd\u8ba9\u4f60\u5e2e\u52a9\u5979\u4e86\u3002 \u51fa\u9898\u4eba\u4e0d\u60f3\u592a duliu \uff0c\u5979\u8ba9\u4f60\u53ea\u8981\u8f93\u51fa\u6240\u6709\u623f\u5c4b\u635f\u5bb3\u7a0b\u5ea6\u7684\u6700\u5927\u503c\u548c\u5f02\u6216\u548c\u3002 Q\uff1a\u8bdd\u8bf4\u4e3a\u4ec0\u4e48\u4e0d\u76f4\u63a5\u7528\u9b54\u6cd5\u963b\u6b62\u5f20\u4e09\uff1f A\uff1a\u56e0\u4e3a \u552f\u6211\u6cd5\u5916\u72c2\u5f92\u5f20\u4e09\u6c38\u4e16\u957f\u5b58 !!! \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\uff0c\u4e24\u4e2a\u6574\u6570n,m\u8868\u793a\u623f\u5c4b\u7684\u6570\u91cf\uff0c\u548c\u7206\u70b8\u6b21\u6570\u3002 \u63a5\u4e0b\u6765m\u884c\uff0c\u6bcf\u884c\u56db\u4e2a\u6574\u6570l,r,bg,ed\uff0c\u5206\u522b\u8868\u793a\u7b49\u5dee\u6570\u5217\u7684\u9996\u9879\u6807\u53f7\uff0c\u672b\u9879\u6807\u53f7\uff0c\u9996\u9879\u503c\uff0c\u672b\u9879\u503c\u3002 \u8f93\u51fa \u00b6 \u4e00\u884c\uff0c\u4e24\u4e2a\u6570\uff0c\u5206\u522b\u8868\u793a\u6240\u6709\u623f\u5c4b\u635f\u5bb3\u7a0b\u5ea6\u7684\u6700\u5927\u503c\u548c\u5f02\u6216\u548c\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 5 2 1 5 2 10 2 4 1 1 \u3010\u6837\u4f8b2\u3011 6 2 1 5 2 10 2 4 1 1 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 3 10 \u3010\u6837\u4f8b2\u3011 3 10 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca: \u7b2c\u4e00\u6b21\u7206\u70b8\u4ea7\u751f\u7684\u4f24\u5bb3\uff1a[2,4,6,8,10]\u3002 \u7b2c\u4e8c\u6b21\u7206\u70b8\u4ea7\u751f\u7684\u4f24\u5bb3\uff1a[0,1,1,1,0]\u3002 \u6240\u6709\u7206\u70b8\u7ed3\u675f\u540e\u6bcf\u4e2a\u623f\u5c4b\u7684\u635f\u4f24\u7a0b\u5ea6\uff1a[2,5,7,9,10]\u3002 \u8f93\u51fa\u5f02\u6216\u548c\uff1a \u3002 \u8f93\u51fa\u6700\u5927\u503c\uff1a \u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; const long long int N = 1e7 + 500 ; long long int out [ N ] = { 0 }; int main () { std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( 0 ); register long long int n , m , l , r , ks , e1 , dc , tmp = 0 ; register long long int max1 = 0 , ans = 0 ; cin >> n >> m ; register long long int i ; for ( i = 1 ; i <= m ; i ++ ) { cin >> l >> r >> ks >> e1 ; dc = ( e1 - ks ) / ( r - l ); out [ l ] = out [ l ] + ks ; out [ l + 1 ] = out [ l + 1 ] + dc - ks ; out [ r + 1 ] = out [ r + 1 ] - dc - e1 ; out [ r + 2 ] = out [ r + 2 ] + e1 ; } for ( i = 1 ; i <= n ; i ++ ) { out [ i ] = out [ i - 1 ] + out [ i ]; tmp += out [ i ]; max1 = max ( max1 , tmp ); ans = ans ^ tmp ; } cout << ans << ' ' << max1 << endl ; return 0 ; }","title":"2021-06-05-6\u67085\u65e5\u9898\u89e3"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#65","text":"","title":"6\u67085\u65e5\u9898\u89e3"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_1","text":"","title":"\u4ea4\u6362"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_2","text":"http://icpc.upc.edu.cn/problem.php?cid=2828&pid=9","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_3","text":"\u7ed9\u51fa\u4e00\u4e2a\u5e8f\u5217A\uff0c\u5176\u4e2d\u7b2ci\u4e2a\u6570\u5b57\u4e3aai\uff0c\u4f60\u6bcf\u6b21\u53ef\u4ee5\u9009\u62e9\u4e00\u4e2a\u6570\u5b57\u4e0d\u53d8\uff0c\u5c06\u5176\u4ed6\u6570\u5b57\u5168\u90e8\u4e58\u4ee5x\u3002\u5176\u4e2dx\u4e3a\u4efb\u610f\u7d20\u6570\u3002 \u65e0\u9700\u8003\u8651\u8fd9\u4e9b\u6570\u5b57\u5728\u53d8\u6362\u8fc7\u7a0b\u4e2d\u662f\u5426\u8d85\u8fc7long long\u7684\u5b58\u50a8\u8303\u56f4\u3002\u8bf7\u56de\u7b54\uff1a\u6700\u5c11\u7ecf\u8fc7\u591a\u5c11\u6b21\u64cd\u4f5c\uff0c\u53ef\u4ee5\u4f7f\u5f97\u5e8f\u5217\u4e2d\u6240\u6709\u6570\u5b57\u5168\u90e8\u76f8\u540c\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_4","text":"\u7b2c\u4e00\u884c\u5305\u542b\u4e00\u4e2a\u6b63\u6574\u6570n\uff0c\u4ee3\u8868\u5e8f\u5217\u957f\u5ea6\u3002 \u63a5\u4e0b\u6765\u4e00\u884c\u5305\u542bn\u4e2a\u6b63\u6574\u6570\uff0c\u63cf\u8ff0\u5e8f\u5217\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5143\u7d20\u3002","title":"\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_5","text":"\u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570\u8868\u793a\u7b54\u6848\u3002","title":"\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_6","text":"2 5 7","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_7","text":"2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_8","text":"\u6837\u4f8b\u8bf4\u660e\uff1a \u53ef\u4ee5\u9009\u4e2d\u7b2c\u4e8c\u4e2a\u6570\u5b57\u4e0d\u53d8\uff0c\u5c06\u7b2c\u4e00\u4e2a\u6570\u5b57\u9664\u4ee55\uff0c\u7136\u540e\u9009\u4e2d\u7b2c\u4e00\u4e2a\u6570\u5b57\u4e0d\u53d8\uff0c\u5c06\u7b2c\u4e8c\u4e2a\u6570\u5b57\u9664\u4ee57\u3002\u4e24\u6b21\u64cd\u4f5c\u540e\uff0c\u6570\u7ec4\u4e2d\u6240\u6709\u6570\u5b57\u5747\u53d8\u4e3a1\u3002\u5f53\u7136\u8fd8\u6709\u5176\u4ed6\u65b9\u6cd5\uff0c\u5982\u5c06\u4e24\u4e2a\u6570\u5b57\u6700\u7ec8\u90fd\u53d8\u4e3a35\u4e5f\u53ea\u9700\u89812\u6b21\u64cd\u4f5c\u3002 \u3010\u6570\u636e\u8303\u56f4\u3011 \u5bf9\u4e8e20%\u7684\u6570\u636e\uff0c\u6ee1\u8db3n=2,ai\u2264106 \u5bf9\u4e8e40%\u7684\u6570\u636e\uff0c\u6ee1\u8db3n\u226410,ai\u2264106 \u5bf9\u4e8e\u53e6\u591620%\u7684\u6570\u636e\uff0c\u6ee1\u8db3n\u22644\u2217104,ai\u226420 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c\u6ee1\u8db31\u2264n\u2264106,1\u2264ai\u2264106","title":"\u63d0\u793a"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_9","text":"\u5bf9\u5176\u4ed6\u6570\u8fdb\u884c\u505a\u4e58\u6cd5\u76f8\u5f53\u4e8e\u5bf9\u81ea\u5df1\u505a\u4e58\u6cd5\uff0c\u53ef\u4ee5\u5bf9\u6bcf\u4e00\u4e2a\u6570\u9664\u6389\u6700\u5927\u516c\u7ea6\u6570\u4e92\u8d28\u540e\uff0c\u7edf\u8ba1\u548c\u8ba1\u7b97\u8d28\u56e0\u6570\u7684\u4e2a\u6570\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_10","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 1005000 ] = { 0 }; ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ); } ll prime [ 1005000 ] = { 0 }; ll is_prime [ 1005000 ] = { 0 }; int main () { ll cnt = 0 ; for ( ll i = 2 ; i <= 1e6 ; i ++ ) { if ( ! is_prime [ i ]) prime [ ++ cnt ] = i ; for ( ll j = 1 ; j <= cnt ; j ++ ) { if ( i * prime [ j ] > 1e6 ) break ; is_prime [ i * prime [ j ]] = 1 ; if ( i % prime [ j ] == 0 ) break ; } } ll n , m = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); m = gcd ( a [ i ], m ); } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { a [ i ] /= m ; for ( ll j = 1 ; j <= cnt && prime [ j ] * prime [ j ] <= a [ i ]; j ++ ) { while ( a [ i ] % prime [ j ] == 0 ) { ans ++ ; a [ i ] /= prime [ j ]; } } if ( a [ i ] != 1 ) ans ++ ; } printf ( \"%lld \\n \" , ans ); }","title":"\u4ee3\u7801"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#disjoint-set-of-common-divisors","text":"","title":"Disjoint Set of Common Divisors"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_11","text":"http://icpc.upc.edu.cn/problem.php?cid=2826&pid=4","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_12","text":"Given are positive integers A and B. Let us choose some number of positive common divisors of A and B. Here, any two of the chosen divisors must be coprime. At most, how many divisors can we choose? \u2192Definition of common divisor \u00b7An integer d is said to be a common divisor of integers x and y when d divides both x and y. \u2192Definition of being coprime \u00b7Integers x and y are said to be coprime when x and y have no positive common divisors other than 1. \u2192Definition of dividing \u00b7An integer x is said to divide another integer y when there exists an integer \u03b1 such that y=\u03b1x. Constraints \u00b7All values in input are integers. \u00b71\u2264A,B\u22641012","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_13","text":"Input is given from Standard Input in the following format: A B","title":"\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_14","text":"Print the maximum number of divisors that can be chosen to satisfy the condition.","title":"\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_15","text":"\u3010\u6837\u4f8b1\u3011 12 18 \u3010\u6837\u4f8b2\u3011 420 660 \u3010\u6837\u4f8b3\u3011 1 2019","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_16","text":"\u3010\u6837\u4f8b1\u3011 3 \u3010\u6837\u4f8b2\u3011 4 \u3010\u6837\u4f8b3\u3011 1","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_17","text":"\u6837\u4f8b1\u89e3\u91ca 12 and 18 have the following positive common divisors: 1, 2, 3, and 6. 1 and 2 are coprime, 2 and 3 are coprime, and 3 and 1 are coprime, so we can choose 1, 2, and 3, which achieve the maximum result. \u6837\u4f8b3\u89e3\u91ca 1 and 2019 have no positive common divisors other than 1.","title":"\u63d0\u793a"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_18","text":"\u6c42gcd(A,B)\u7684\u8d28\u56e0\u6570\u6709\u591a\u5c11\u4e2a\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_19","text":"#include <iostream> #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll n , m ; cin >> n >> m ; ll k = __gcd ( n , m ); ll ans = 1 ; for ( ll i = 2 ; i * i <= k ; i ++ ) { if ( k % i == 0 ) ans ++ ; while ( k % i == 0 ) k /= i ; } if ( k != 1 ) ans ++ ; cout << ans << endl ; return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_20","text":"","title":"\u725b\u725b\u7684\u6ed1\u52a8\u7a97\u53e3"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_21","text":"http://icpc.upc.edu.cn/problem.php?cid=2826&pid=9","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_22","text":"\u725b\u725b\u6700\u8fd1\u5b66\u4e60\u4e86\u6ed1\u52a8\u7a97\u53e3\u7c7b\u7684\u7b97\u6cd5\uff0c\u6ed1\u52a8\u7a97\u53e3\u7b97\u6cd5\u53ef\u4ee5\u89e3\u51b3\u4e00\u4e9b\u7ebf\u6027\u6570\u7ec4\u7684\u79bb\u7ebf\u9759\u6001\u533a\u95f4\u67e5\u8be2\u7c7b\u95ee\u9898\u3002 \u5177\u4f53\u6765\u8bf4\uff0c\u5047\u8bbe\u5bf9\u4e8e\u4e00\u4e2a\u6570\u7ec4\u8fdb\u884cm\u6b21\u9759\u6001\u533a\u95f4\u67e5\u8be2\u95ee\u9898\u3002\u5982\u679c\u8fd9\u4e9b\u67e5\u8be2\u6ee1\u8db3\u6761\u4ef6\uff1a\u2200i,j\u5f53li\u2264lj\u65f6\uff0c\u603b\u6709ri\u2264rj\u3002\uff08i,j\u8868\u793a\u67e5\u8be2\u7684\u7f16\u53f7\uff0cl,r\u8868\u793a\u67e5\u8be2\u7684\u5de6\u53f3\u7aef\u70b9\uff09 \u63a5\u4e0b\u6765\u53ea\u8981\u67e5\u8be2\u7684\u95ee\u9898\u6ee1\u8db3\u53ef\u4ee5\u5feb\u901f\u63d2\u5165\u548c\u5220\u9664\u5355\u70b9\uff0c\u5c31\u53ef\u4ee5\u4f7f\u7528\u6ed1\u52a8\u7a97\u53e3\u4f18\u5316\uff0c\u5c06\u8fd9m\u6b21\u67e5\u8be2\u7684\u590d\u6742\u5ea6\u964d\u4f4e\u5230O(n)\u3002 \u663e\u7136\uff0c\u5982\u679c\u5bf9\u4e8e\u4e00\u4e2a\u6570\u7ec4\u7684\u533a\u95f4\u67e5\u8be2\u95ee\u9898\uff0c\u67e5\u8be2\u7684\u533a\u95f4\u957f\u5ea6\u7ed9\u5b9a\u4e3ak\u65f6\uff0c\u603b\u662f\u6ee1\u8db3\u2200i,j\u5f53li\u2008\u2264\u2008lj\u65f6\uff0c\u603b\u6709ri\u2264rj\u8fd9\u4e00\u6761\u4ef6\u7684\u3002 \u725b\u725b\u63a5\u4e0b\u6765\u60f3\u8981\u95ee\u4f60\u7684\u95ee\u9898\u4e5f\u548c\u5b9a\u957f\u6ed1\u52a8\u7a97\u53e3\u6709\u5173\u3002 \u4f17\u6240\u5468\u77e5\uff0c\u957f\u5ea6\u4e3ak\u7684\u6ed1\u52a8\u7a97\u53e3\u4ece\u5de6\u5230\u53f3\u53bb\u622a\u53d6\u4e00\u4e2a\u957f\u5ea6\u5927\u5c0f\u4e3an\u7684\u6570\u7ec4\u65f6\uff0c\u4e00\u5171\u53ef\u4ee5\u622a\u53d6\u5230n-k+1\u4e2a\u5b50\u6570\u7ec4\u3002 \u725b\u725b\u5c06\u8fd9n-k+1\u4e2a\u5b50\u6570\u7ec4\u7684\u6781\u5927\u503c\u4e0e\u6781\u5c0f\u503c\u7684\u4e58\u79ef\u6c42\u548c\u79f0\u4e3a\u8be5\u6570\u7ec4\u7684\"\u7b2ck\u7a97\u53e3\u503c\"\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5047\u8bbe\u957f\u5ea6\u4e3a5\u7684\u6570\u7ec4\u4e3a[1,5,2,4,3]\uff0c\u957f\u5ea6\u4e3a3\u7684\u6ed1\u52a8\u7a97\u53e3\u53ef\u4ee5\u622a\u53d6\u4e09\u4e2a\u5b50\u6570\u7ec4\uff0c\u5b83\u4eec\u5206\u522b\u4e3a[1,5,2],[5,2,4],[2,4,3]\u3002 \u6240\u4ee5\u8be5\u6570\u7ec4\u7684\u201c\u7b2c3\u7a97\u53e3\u503c\u201d\u4e3a1*5+2*5+2*4=23\u3002 \u5bf9\u4e8e\u4e00\u4e2a\u7ed9\u5b9a\u5927\u5c0f\u7684\u6570\u7ec4n\uff0c\u725b\u725b\u73b0\u5728\u60f3\u8981\u77e5\u9053\u5b83\u7684\u7b2c1,2,3,4,5...n\u7a97\u53e3\u503c\u5404\u662f\u591a\u5c11\uff0c\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u89e3\u51b3\u4ed6\u7684\u95ee\u9898\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_23","text":"\u7b2c\u4e00\u884c\u8f93\u5165\u4e00\u4e2a\u6b63\u6574\u6570n\uff0c\u8868\u793a\u6570\u7ec4\u7684\u5927\u5c0f\u3002 \u63a5\u4e0b\u6765\u4e00\u884c\u8f93\u5165n\u4e2a\u6b63\u6574\u6570ai\uff0c\u8868\u793a\u6570\u7ec4\u7684\u5185\u5bb9","title":"\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_24","text":"\u8f93\u51fa\u4e00\u884cn\u4e2a\u6b63\u6574\u6570\uff0c\u8868\u793a\u6ed1\u52a8\u7a97\u53e3\u7684\u957f\u5ea6\u5206\u522b\u4e3a1,2,3,4,5...n\u65f6\uff0c\u95ee\u9898\u7684\u7b54\u6848\u3002 \u8f93\u51fa\u7684\u6574\u6570\u4e4b\u95f4\u7528\u7a7a\u683c\u9694\u5f00\uff0c\u884c\u672b\u4e0d\u5141\u8bb8\u6709\u591a\u4f59\u7a7a\u683c\u3002","title":"\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_25","text":"5 1 5 2 4 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_26","text":"55 35 23 15 5","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_27","text":"\u6837\u4f8b\u89e3\u91ca\uff1a \u7b2c1\u7a97\u53e3\u503c=1*1+5*5+2*2+4*4+3*3=55 \u7b2c2\u7a97\u53e3\u503c=5*1+5*2+4*2+4*3=35 \u7b2c3\u7a97\u53e3\u503c=5*1+5*2+4*2=23 \u7b2c4\u7a97\u53e3\u503c=5*1+5*2=15 \u7b2c5\u7a97\u53e3\u503c=5*1=5 \u5bf9\u4e8e10%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u226410 \u5bf9\u4e8e20%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u2264100 \u5bf9\u4e8e30%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u22641000 \u5bf9\u4e8e50%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u22646000 \u5bf9\u4e8e\u53e6\u591610%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264ai\u226410 \u5bf9\u4e8e100%\u7684\u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc11\u2264n\u2264105,1\u2264ai\u2264100","title":"\u63d0\u793a"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_28","text":"\u6682\u672a\u60f3\u51fa\uff0c\u601d\u8def\u4e3a\u5355\u8c03\u6808\uff0c\u5f85\u8865\uff01\uff01\uff01 https://blog.csdn.net/weixin_43346722/article/details/109151074","title":"\u9898\u89e3"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_29","text":"#include <cstdio> #include <iostream> using namespace std ; struct node { int x , num ; } bigstack [ 101 ], smallstack [ 101 ]; int n , a [ 100001 ], ans [ 100001 ], bigtop , smalltop , maxn , minn ; int lft , bignow , smallnow ; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); for ( int i = 1 ; i <= n ; i ++ ) { while ( bigtop && bigstack [ bigtop ]. x <= a [ i ]) bigtop -- ; while ( smalltop && smallstack [ smalltop ]. x >= a [ i ]) smalltop -- ; //\u6808\u7684\u5f39\u51fa bigstack [ ++ bigtop ] = ( node ){ a [ i ], i }; //\u63d2\u5165 smallstack [ ++ smalltop ] = ( node ){ a [ i ], i }; maxn = minn = a [ i ]; lft = i ; bignow = bigtop - 1 ; smallnow = smalltop - 1 ; while ( bignow || smallnow ) { //\u4e00\u70b9\u4e00\u70b9\u5f80\u540e\u79fb\uff0c\u7b97\u8d21\u732e if ( bignow && smallnow ) { if ( bigstack [ bignow ]. num >= smallstack [ smallnow ]. num ) { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - bigstack [ bignow ]. num + 1 ] -= maxn * minn ; lft = bigstack [ bignow ]. num ; maxn = bigstack [ bignow ]. x ; bignow -- ; } else { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - smallstack [ smallnow ]. num + 1 ] -= maxn * minn ; lft = smallstack [ smallnow ]. num ; minn = smallstack [ smallnow ]. x ; smallnow -- ; } continue ; } if ( bignow ) { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - bigstack [ bignow ]. num + 1 ] -= maxn * minn ; lft = bigstack [ bignow ]. num ; maxn = bigstack [ bignow ]. x ; bignow -- ; } else { ans [ i - lft + 1 ] += maxn * minn ; ans [ i - smallstack [ smallnow ]. num + 1 ] -= maxn * minn ; lft = smallstack [ smallnow ]. num ; minn = smallstack [ smallnow ]. x ; smallnow -- ; } } ans [ i - lft + 1 ] += maxn * minn ; ans [ i + 1 ] -= maxn * minn ; } for ( int i = 1 ; i <= n ; i ++ ) { ans [ i ] += ans [ i - 1 ]; //\u56e0\u4e3a\u662f\u5dee\u5206\uff0c\u6240\u4ee5\u8981\u52a0\u4e0a\u524d\u9762\u7684 printf ( \"%d \" , ans [ i ]); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_30","text":"\u542c\u8bf4\u7f57\u7fd4\u8001\u5e08\u6700\u8fd1\u5f88\u706b\u3002 \u5f20\u4e09\u4eca\u5929\u8feb\u4e0d\u53ca\u5f85\u60f3\u72af\u7f6a\u3002\u5c31\u51b3\u5b9a\u662f\u7206\u70b8\u7f6a\u4e86\uff0c\u6b63\u597d\u7f57\u8001\u5e08\u8bb2\u4e86\u8fd9\u4e2a\u6848\u4f8b\u3002 \u4ed6\u4e00\u773c\u5c31\u770b\u4e0a\u4e86 CaPeF_Yyx \u7684\u5bb6 \uff08\u6216\u8bb8\u662f\u4ed6\u592a duliu \u4e86\uff09 \u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u86ee\u4e0d\u8bb2\u7406\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u4f1a\u6ce2\u53ca\u90e8\u5206\u8857\u9053\u3002\u6bcf\u6b21\u7206\u70b8\u4f1a\u9020\u6210\u4e00\u5b9a\u7684\u635f\u574f\u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u51fa\u4eba\u610f\u6599\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u6ce2\u53ca\u7684\u8303\u56f4\u6bcf\u6b21\u90fd\u4e0d\u4e00\u6837\u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u5341\u6076\u4e0d\u8d66\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u4f1a\u8fdb\u884cm \u6b21 \uff08CaPeF_Yyx \u7684\u5bb6\u4e5f\u592a\u575a\u56fa\u4e86\u5427\uff09 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u4e95\u4e95\u6709\u6761\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u6ce2\u53ca\u7684\u8303\u56f4\u662f\u4e00\u4e2a\u95ed\u533a\u95f4\u3002 \u4f5c\u4e3a\u5f20\u4e09\uff0c\u5979\u7cbe\u76ca\u6c42\u7cbe\uff0c\u6240\u4ee5\u4ed6\u7684\u7206\u70b8\u4ee5\u7b49\u5dee\u6570\u5217\u7684\u65b9\u5f0f\u9020\u6210\u4f24\u5bb3\u3002 CaPeF_Yyx \u5bb6\u5728\u504f\u8fdc\u89d2\u843d\uff0c\u8857\u9053\u7f16\u53f7\u4ece1~n \u3002 CaPeF_Yyx \u8857\u9053\u521a\u7ffb\u65b0\uff0c\u6bcf\u95f4\u623f\u5c4b\u7834\u574f\u7a0b\u5ea6\u90fd\u4e3a0\u3002 \u7f57\u7fd4\u8001\u5e08\u53ef\u4ee5\u9884\u6d4b\u6bcf\u6b21\u7206\u70b8\u7684\u8303\u56f4\u3002\u4f1a\u7ed9\u5230 CaPeF_Yyx \u5f62\u5982[l,r] \u7684\u95ed\u533a\u95f4\u3002 \u7f57\u7fd4\u8001\u5e08\u53ef\u4ee5\u9884\u6d4b\u6bcf\u6b21\u7206\u70b8\u7684\u4f24\u5bb3\u3002\u4f1a\u7ed9\u5230 CaPeF_Yyx \u5f62\u5982l,r,bg,ed \u7684 4 \u4e2a\u6570\u3002 \u8868\u793a\u5f62\u5982{ql,ql+1,...,qr-1,qr},ql=bg,qr=ed\u7684\u7b49\u5dee\u6570\u5217\uff0c\u5bf9\u4e8e\u8857\u9053ai(l\u2264i\u2264r)\uff0c\u9020\u6210qi\u7684\u4f24\u5bb3\u3002 CaPeF_Yyx \u627e\u5230\u4e86 Rainy7 \u4fee\u590d\u8857\u9053\u3002\u53ef\u662f\u5979\u5fc5\u987b\u5148\u77e5\u9053\u8857\u9053\u5230\u5e95\u635f\u574f\u4e86\u591a\u5c11\u3002 \u5979\u8fd8\u5fd9\u7740\u62ef\u6551\u4e16\u754c\u5462\uff0cCaPeF_Yyx \u88ab\u5413\u5f97\u4e0d\u8f7b\uff0c\u4e8e\u662f\u53ea\u80fd\u8ba9\u4f60\u5e2e\u52a9\u5979\u4e86\u3002 \u51fa\u9898\u4eba\u4e0d\u60f3\u592a duliu \uff0c\u5979\u8ba9\u4f60\u53ea\u8981\u8f93\u51fa\u6240\u6709\u623f\u5c4b\u635f\u5bb3\u7a0b\u5ea6\u7684\u6700\u5927\u503c\u548c\u5f02\u6216\u548c\u3002 Q\uff1a\u8bdd\u8bf4\u4e3a\u4ec0\u4e48\u4e0d\u76f4\u63a5\u7528\u9b54\u6cd5\u963b\u6b62\u5f20\u4e09\uff1f A\uff1a\u56e0\u4e3a \u552f\u6211\u6cd5\u5916\u72c2\u5f92\u5f20\u4e09\u6c38\u4e16\u957f\u5b58 !!!","title":"\u7b49\u5dee\u5e8f\u5217\u524d\u7f00\u548c\uff08\u53cc\u524d\u7f00\u548c\uff09"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_31","text":"\u7b2c\u4e00\u884c\uff0c\u4e24\u4e2a\u6574\u6570n,m\u8868\u793a\u623f\u5c4b\u7684\u6570\u91cf\uff0c\u548c\u7206\u70b8\u6b21\u6570\u3002 \u63a5\u4e0b\u6765m\u884c\uff0c\u6bcf\u884c\u56db\u4e2a\u6574\u6570l,r,bg,ed\uff0c\u5206\u522b\u8868\u793a\u7b49\u5dee\u6570\u5217\u7684\u9996\u9879\u6807\u53f7\uff0c\u672b\u9879\u6807\u53f7\uff0c\u9996\u9879\u503c\uff0c\u672b\u9879\u503c\u3002","title":"\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_32","text":"\u4e00\u884c\uff0c\u4e24\u4e2a\u6570\uff0c\u5206\u522b\u8868\u793a\u6240\u6709\u623f\u5c4b\u635f\u5bb3\u7a0b\u5ea6\u7684\u6700\u5927\u503c\u548c\u5f02\u6216\u548c\u3002","title":"\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_33","text":"\u3010\u6837\u4f8b1\u3011 5 2 1 5 2 10 2 4 1 1 \u3010\u6837\u4f8b2\u3011 6 2 1 5 2 10 2 4 1 1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_34","text":"\u3010\u6837\u4f8b1\u3011 3 10 \u3010\u6837\u4f8b2\u3011 3 10","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_35","text":"\u6837\u4f8b1\u89e3\u91ca: \u7b2c\u4e00\u6b21\u7206\u70b8\u4ea7\u751f\u7684\u4f24\u5bb3\uff1a[2,4,6,8,10]\u3002 \u7b2c\u4e8c\u6b21\u7206\u70b8\u4ea7\u751f\u7684\u4f24\u5bb3\uff1a[0,1,1,1,0]\u3002 \u6240\u6709\u7206\u70b8\u7ed3\u675f\u540e\u6bcf\u4e2a\u623f\u5c4b\u7684\u635f\u4f24\u7a0b\u5ea6\uff1a[2,5,7,9,10]\u3002 \u8f93\u51fa\u5f02\u6216\u548c\uff1a \u3002 \u8f93\u51fa\u6700\u5927\u503c\uff1a \u3002","title":"\u63d0\u793a"},{"location":"problem/2021-06-05-6%E6%9C%885%E6%97%A5%E9%A2%98%E8%A7%A3/#_36","text":"#include <bits/stdc++.h> using namespace std ; const long long int N = 1e7 + 500 ; long long int out [ N ] = { 0 }; int main () { std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( 0 ); register long long int n , m , l , r , ks , e1 , dc , tmp = 0 ; register long long int max1 = 0 , ans = 0 ; cin >> n >> m ; register long long int i ; for ( i = 1 ; i <= m ; i ++ ) { cin >> l >> r >> ks >> e1 ; dc = ( e1 - ks ) / ( r - l ); out [ l ] = out [ l ] + ks ; out [ l + 1 ] = out [ l + 1 ] + dc - ks ; out [ r + 1 ] = out [ r + 1 ] - dc - e1 ; out [ r + 2 ] = out [ r + 2 ] + e1 ; } for ( i = 1 ; i <= n ; i ++ ) { out [ i ] = out [ i - 1 ] + out [ i ]; tmp += out [ i ]; max1 = max ( max1 , tmp ); ans = ans ^ tmp ; } cout << ans << ' ' << max1 << endl ; return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/_coverpage/","text":"Tim-wcx \u00b6 \u4e2a\u4eba\u6587\u6863\u7f51\u7ad9 \u00b6 GitHub Get Started","title":"Tim-wcx"},{"location":"problem/_coverpage/#tim-wcx","text":"","title":"Tim-wcx"},{"location":"problem/_coverpage/#_1","text":"GitHub Get Started","title":"\u4e2a\u4eba\u6587\u6863\u7f51\u7ad9"},{"location":"problem/_sidebar/","text":"\u4e0a\u4e00\u7ea7 ICPC\u9898\u89e3 \u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u56db\uff09 \u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e09\uff09 \u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e8c\uff09 \u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e00\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e94\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u56db\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e09\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e8c\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e00\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e5d\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516b\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e03\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516d\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e94\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u56db\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e09\uff09 \u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e8c\uff09 \u6691\u5047\u96c6\u8bad\u9898\u89e3\u7cfb\u5217\uff08\u4e00\uff09 2021-02-02-2\u67082\u65e5\u9898\u89e3 2021-02-07-2\u67087\u65e5\u9898\u89e3 2021-02-02-2\u67082\u65e5\u9898\u89e3 2021-02-07-2\u67087\u65e5\u9898\u89e3 2021-02-08-2\u67088\u65e5\u9898\u89e3 2021-02-09-2\u67089\u65e5\u9898\u89e3 2021-02-12-\u5b89\u5353\u8bfe\u8868\u5ba2\u6237\u7aef+\u670d\u52a1\u7aef\u6ce8\u89e3 2021-02-16-2\u670816\u65e5\u9898\u89e3 2021-02-19-2\u670819\u65e5\u9898\u89e3 2021-02-20-2\u670820\u65e5\u9898\u89e3 2021-02-22-2\u670822\u65e5\u9898\u89e3 2021-02-24-2\u670824\u65e5\u9898\u89e3 2021-02-28-2\u670828\u65e5\u9898\u89e3 2021-03-02-3\u67082\u65e5\u9898\u89e3 2021-03-07-3\u67087\u65e5\u9898\u89e3 2021-03-09-\u6570\u8bba 2021-06-05-6\u67085\u65e5\u9898\u89e3","title":" sidebar"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e03\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Cow Steeplechase \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has a brilliant idea for the next great spectator sport: Cow Steeplechase! As everyone knows, regular steeplechase involves a group of horses that race around a course filled with obstacles they must jump over.FJ figures the same contest should work with highly-trained cows, as long as the obstacles are made short enough. In order to design his course, FJ makes a diagram of all the N (1 <= N <=250) possible obstacles he could potentially build. Each one is represented by a line segment in the 2D plane that is parallel to the horizontal or vertical axis. Obstacle i has distinct endpoints (X1_i, Y1_i) and (X2_i, Y2_i) (1 <= X1_i, Y1_i, X2_i, Y2_i <= 1,000,000,000). An example is as follows: --+------- -----+----- ---+--- | | | | --+-----+--+- | | | | | | | --+--+--+-+- | | | | | FJ would like to build as many of these obstacles as possible, subject to the constraint that no two of them intersect. Starting with the diagram above, FJ can build 7 obstacles: ---------- ----------- ------- | | | | | | | | | | | | | | | | | | | Two segments are said to intersect if they share any point in common, even an endpoint of one or both of the segments. FJ is certain that no two horizontal segments in the original input diagram will intersect, and that similarly no two vertical segments in the input diagram will intersect. Please help FJ determine the maximum number of obstacles he can build. \u8f93\u5165 \u00b6 Line 1: A single integer: N. Lines 2..N+1: Line i+1 contains four space-separated integers representing an obstacle: X1_i, Y1_i, X2_i, and Y2_i. \u8f93\u51fa \u00b6 Line 1: The maximum number of non-crossing segments FJ can choose. \u6837\u4f8b\u8f93\u5165 \u00b6 3 4 5 10 5 6 2 6 12 8 3 8 5 \u6837\u4f8b\u8f93\u51fa \u00b6 2 \u63d0\u793a \u00b6 There are three potential obstacles. The first is a horizontal segment connecting (4, 5) to (10, 5); the second and third are vertical segments connecting (6, 2) to (6, 12) and (8, 3) to (8, 5).The optimal solution is to choose both vertical segments. \u9898\u89e3 \u00b6 \u7f51\u7edc\u6d41\u7b97\u6cd5\uff0c\u5c06\u6a2a\u5411\u76f4\u7ebf\u6807\u53f7\u5e76\u4e0e\u6e90\u70b9\u5efa\u8fb9\uff0c\u5e76\u8d4b\u6743\u503c1\uff1b\u5c06\u7eb5\u5411\u76f4\u7ebf\u6807\u53f7\u4e0e\u6c47\u70b9\u5efa\u8fb9\uff0c\u8d4b\u6743\u503c1\uff1b\u5c06\u6a2a\u7eb5\u4ea4\u53c9\u7684\u76f4\u7ebf\u5efa\u8fb9\uff0c\u8d4b\u6743\u503c\u4e3a\u6b63\u65e0\u7a77\uff1b\u7531\u6700\u5927\u6d41\u7b49\u4e8e\u6700\u5c0f\u5272\uff0c\u6240\u4ee5\u6839\u636eEK\u7b97\u6cd5\u6216\u8005Dinic\u7b97\u6cd5\u7b97\u51fa\u6700\u5927\u6d41\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll to , val , next ; }; node edge [ 100500 ] = { 0 }; ll head [ 4050 ] = { 0 }; ll cnt = 0 ; ll s = 1 , e = 1 ; void add_edge ( ll from , ll to , ll val ) { edge [ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. val = val ; head [ from ] = cnt ++ ; } ll pre [ 4050 ] = { 0 }, tag [ 4050 ] = { 0 }, vis [ 4050 ] = { 0 }; ll bfs () { queue < ll > que ; memset ( tag , 0 , sizeof ( tag )); memset ( pre , 0 , sizeof ( pre )); memset ( vis , 0 , sizeof ( vis )); que . push ( s ); vis [ s ] = 1 ; while ( ! que . empty ()) { ll now = que . front (); que . pop (); for ( ll i = head [ now ]; i != -1 ; i = edge [ i ]. next ) { ll to = edge [ i ]. to , val = edge [ i ]. val ; if ( ! vis [ to ] && val > 0 ) { vis [ to ] = 1 ; pre [ to ] = now ; tag [ to ] = i ; if ( to == e ) return 1 ; que . push ( to ); } } } return 0 ; } ll EK () { ll ans = 0 ; while ( bfs ()) { ll min1 = inf ; for ( ll i = e ; i != s ; i = pre [ i ]) { min1 = min ( min1 , edge [ tag [ i ]]. val ); } for ( ll i = e ; i != s ; i = pre [ i ]) { edge [ tag [ i ]]. val -= min1 ; edge [ tag [ i ] ^ 1 ]. val += min1 ; } ans += min1 ; } return ans ; } struct node1 { ll x1 , y1 , x2 , y2 , num ; }; node1 a [ 4050 ] = { 0 }, b [ 4050 ] = { 0 }; ll cnta = 0 , cntb = 0 ; int main () { //freopen(\"in.txt\", \"r\", stdin); ll n ; scanf ( \"%lld\" , & n ); ll x1 , x2 , y1 , y2 ; for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); if ( x1 > x2 ) swap ( x1 , x2 ); if ( y1 > y2 ) swap ( y1 , y2 ); if ( x1 == x2 ) a [ ++ cnta ] = { x1 , y1 , x2 , y2 , i }; else b [ ++ cntb ] = { x1 , y1 , x2 , y2 , i }; } for ( ll i = 0 ; i < 4050 ; i ++ ) head [ i ] = -1 ; e = 4000 , s = 0 ; for ( ll i = 1 ; i <= cnta ; i ++ ) { add_edge ( s , a [ i ]. num , 1 ); add_edge ( a [ i ]. num , s , 0 ); //cout << s << ' ' << a[i].num << ' ' << 1 << endl; } for ( ll i = 1 ; i <= cntb ; i ++ ) { add_edge ( e , b [ i ]. num , 0 ); add_edge ( b [ i ]. num , e , 1 ); //cout << e << ' ' << b[i].num << ' ' << 1 << endl; } for ( ll i = 1 ; i <= cnta ; i ++ ) { for ( ll j = 1 ; j <= cntb ; j ++ ) { if (( b [ j ]. x1 <= a [ i ]. x1 && a [ i ]. x1 <= b [ j ]. x2 ) && ( a [ i ]. y1 <= b [ j ]. y1 && b [ j ]. y1 <= a [ i ]. y2 )) { add_edge ( a [ i ]. num , b [ j ]. num , inf ); add_edge ( b [ j ]. num , a [ i ]. num , 0 ); //cout << a[i].num << ' ' << b[j].num << ' ' << inf << endl; } } } printf ( \"%lld \\n \" , n - EK ()); } \u8be5\u9898\u53e6\u5916\u4e00\u79cd\u505a\u6cd5\u4e3a\u4e8c\u5206\u56fe\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; vector < int > v [ 1005 ]; map < int , int > mp , vis , mp1 ; int dfs ( int now ) { for ( int i = 0 ; i < v [ now ]. size (); i ++ ) { int to = v [ now ][ i ]; if ( ! vis [ to ]) { vis [ to ] = 1 ; if ( mp [ to ] == 0 || dfs ( mp [ to ])) { mp [ to ] = now ; mp1 [ now ] = to ; return 1 ; } } } return 0 ; } struct node1 { ll x1 , y1 , x2 , y2 , num ; }; node1 a [ 4050 ] = { 0 }, b [ 4050 ] = { 0 }; ll cnta = 0 , cntb = 0 ; int main () { ll n ; scanf ( \"%lld\" , & n ); ll x1 , x2 , y1 , y2 ; for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); if ( x1 > x2 ) swap ( x1 , x2 ); if ( y1 > y2 ) swap ( y1 , y2 ); if ( x1 == x2 ) { cnta ++ ; a [ cnta ] = { x1 , y1 , x2 , y2 , cnta }; } else { cntb ++ ; b [ cntb ] = { x1 , y1 , x2 , y2 , cntb }; } } for ( ll i = 1 ; i <= cnta ; i ++ ) { for ( ll j = 1 ; j <= cntb ; j ++ ) { if (( b [ j ]. x1 <= a [ i ]. x1 && a [ i ]. x1 <= b [ j ]. x2 ) && ( a [ i ]. y1 <= b [ j ]. y1 && b [ j ]. y1 <= a [ i ]. y2 )) { v [ a [ i ]. num ]. push_back ( b [ j ]. num ); } } } int ans = 0 ; for ( int i = 1 ; i <= cnta ; i ++ ) { vis . clear (); ans += dfs ( i ); } cout << n - ans << endl ; } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Above the Median \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has lined up his N (1 <= N <= 100,000) cows in a row to measure their heights; cow i has height H_i (1 <= H_i <= 1,000,000,000) nanometers--FJ believes in precise measurements! He wants to take a picture of some contiguous subsequence of the cows to submit to a bovine photography contest at the county fair. The fair has a very strange rule about all submitted photos: a photograph is only valid to submit if it depicts a group of cows whose median height is at least a certain threshold X (1 <= X <= 1,000,000,000). For purposes of this problem, we define the median of an array A[0...K] to be A[ceiling(K/2)] after A is sorted, where ceiling(K/2) gives K/2 rounded up to the nearest integer (or K/2 itself, it K/2 is an integer to begin with). For example the median of {7, 3, 2, 6} is 6, and the median of {5, 4, 8} is 5. Please help FJ count the number of different contiguous subsequences of his cows that he could potentially submit to the photography contest. \u8f93\u5165 \u00b6 * Line 1: Two space-separated integers: N and X. * Lines 2..N+1: Line i+1 contains the single integer H_i. \u8f93\u51fa \u00b6 * Line 1: The number of subsequences of FJ's cows that have median at least X. Note this may not fit into a 32-bit integer. \u6837\u4f8b\u8f93\u5165 \u00b6 4 6 10 5 6 2 \u6837\u4f8b\u8f93\u51fa \u00b6 7 \u63d0\u793a \u00b6 FJ's four cows have heights 10, 5, 6, 2. We want to know how many contiguous subsequences have median at least 6.There are 10 possible contiguous subsequences to consider. Of these, only 7 have median at least 6. They are {10}, {6}, {10, 5}, {5, 6}, {6, 2}, {10,5, 6}, {10, 5, 6, 2}. \u9898\u89e3 \u00b6 sum\u6570\u7ec4\u8bb0\u5f55\u6c42\u51fa\u5927\u4e8ek\u7684\u6570\u5b57\u4e2a\u6570\u7684\u524d\u7f00\u548c\uff0c\u5219\u9898\u76ee\u53ef\u4ee5\u8f6c\u53d8\u4e3a\u5bfb\u627e\u533a\u95f4[l,r]\u6ee1\u8db3sum[r]-sum[l-1]>=0\uff0c\u5229\u7528\u6811\u72b6\u6570\u7ec4\u67e5\u627e\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll tree [ 300500 ] = { 0 }; ll maxn = 300500 ; ll lowbit ( ll n ) { return n & ( - n ); } void add ( ll pos , ll val ) { for ( ll i = pos ; i <= maxn ; i += lowbit ( i )) tree [ i ] += val ; } ll query ( ll pos ) { ll ans = 0 ; for ( ll i = pos ; i > 0 ; i -= lowbit ( i )) ans += tree [ i ]; return ans ; } int main () { ll n , m , k , sum = 0 , ans = 0 ; scanf ( \"%lld%lld\" , & n , & k ) add ( n , 1 ); ///\u4e3a\u9632\u6b62\u8d1f\u6570\u51fa\u73b0\uff0c\u7edf\u4e00\u52a0n\uff0c\u8fd9\u91cc\u521d\u59cb\u5316\u589e\u6dfb\u4e00\u4e2a0 for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & m ); if ( m < k ) sum -= 1 ; else sum += 1 ; ans += query ( sum + n ); add ( sum + n , 1 ); } cout << ans << endl ; } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Eddy Walker \u9898\u76ee\u63cf\u8ff0 \u00b6 Eddy likes to walk around. Especially, he likes to walk in a loop called \"Infinite loop\". But, actually, it's just a loop with finite length(Anyway, the name doesn't matter). Eddy can walk in a fixed length. He finds that it takes him N steps to walk through the loop a cycle. Then, he puts N marks on the \"Infinite loop\" labeled with 0,1,\u2026,N\u22121, where i and i+1 are a step away each other, so as 0 and N-1. After that, Eddy stands on the mark labeled 0 and start walking around. For each step, Eddy will independently uniformly randomly choose to move forward or backward. If currently Eddy is on the mark labeled i, he will on the mark labeled i+1 if move forward or i-1 if move backward. If Eddy is on the mark labeled N-1 and moves forward, he will stand on the mark labeled 0. If Eddy is on the mark labeled 0 and moves backward, he will stand on the mark labeled N-1. Although, Eddy likes to walk around. He will get bored after he reaches each mark at least once. After that, Eddy will pick up all the marks, go back to work and stop walking around. You, somehow, notice the weird convention Eddy is doing. And, you record T scenarios that Eddy walks around. For i-th scenario, you record two numbers Ni, Mi, where Ni tells that in the i-th scenario, Eddy can walk through the loop a cycle in exactly Ni steps(Yes! Eddy can walk in different fixed length for different day.). While Mi tells that you found that in the i-th scenario, after Eddy stands on the mark labeled Mi, he reached all the marks. However, when you review your records, you are not sure whether the data is correct or even possible. Thus, you want to know the probability that those scenarios will happen. Precisely, you are going to compute the probability that first i scenarios will happen sequentially for each i. \u8f93\u5165 \u00b6 The first line of input contains an integers T. Following T lines each contains two space-separated integers Ni and Mi. 1\u2264T\u22641021 0\u2264Mi<Ni\u2264109 \u8f93\u51fa \u00b6 Output T lines each contains an integer representing the probability that first i scenarios will happen sequentially. you should output the number module 109+7(1000000007). Suppose the probability is P/Q, the desired output will be P\u00d7Q\u22121 mod 109+7 \u6837\u4f8b\u8f93\u5165 \u00b6 3 1 0 2 1 3 0 \u6837\u4f8b\u8f93\u51fa \u00b6 1 1 0 \u9898\u89e3 \u00b6 \u6253\u8868\u627e\u89c4\u5f8b\uff0c\u6253\u8868\u4ee3\u7801\u5982\u4e0b\uff1a #include <iostream> #include <cstdlib> #include <cstring> #include <ctime> using namespace std ; int num [ 520 ]; bool vis [ 520 ]; int main (){ srand (( unsigned ) time ( NULL )); int n ; while ( cin >> n ){ memset ( num , 0 , sizeof ( num )); for ( int i = 1 ; i <= 10000000 ; i ++ ){ //\u6570\u636e\u5f00\u7684\u5927\uff0c\u8dd1\u5f97\u6162\uff0c\u8010\u5fc3\u7b49\u5f85\uff0c\u53ef\u4ee5\u8c03\u5c0f\u4e00\u70b9 memset ( vis , false , sizeof ( vis )); int pos = 0 ; int cnt = 1 ; vis [ 0 ] = true ; while ( cnt < n ){ int x = rand () % 2 ; if ( ! x ) x = -1 ; pos += x ; pos = ( pos + n ) % n ; if ( ! vis [ pos ]){ vis [ pos ] = true ; cnt ++ ; } if ( cnt == n ){ num [ pos ] ++ ; } } } for ( int i = 0 ; i < n ; i ++ ){ cout << i << \": \" << num [ i ] << endl ; } } return 0 ; } \u9644\uff1a C++\u4ea7\u751f\u4efb\u610f\u533a\u95f4\u7684\u968f\u673a\u6570\uff1anumber = (rand()%(maxValue - minValue +1)) + minValue; rand()\u4f1a\u8fd4\u56de\u4e00\u968f\u673a\u6570\u503c, \u8303\u56f4\u57280\u81f3RAND_MAX \u95f4\u3002RAND_MAX\u5b9a\u4e49\u5728stdlib.h, \u5176\u503c\u4e3a2147483647\u3002 srand()\u53ef\u7528\u6765\u8bbe\u7f6erand()\u4ea7\u751f\u968f\u673a\u6570\u65f6\u7684\u968f\u673a\u6570\u79cd\u5b50\u3002\u901a\u8fc7\u8bbe\u7f6e\u4e0d\u540c\u7684\u79cd\u5b50\uff0c\u6211\u4eec\u53ef\u4ee5\u83b7\u53d6\u4e0d\u540c\u7684\u968f\u673a\u6570\u5e8f\u5217\u3002\u53ef\u4ee5\u5229\u7528srand((int)(time(NULL))\u7684\u65b9\u6cd5\uff0c\u5229\u7528\u7cfb\u7edf\u65f6\u949f\uff0c\u4ea7\u751f\u4e0d\u540c\u7684\u968f\u673a\u6570\u79cd\u5b50\u3002 \u6253\u8868\u7ed3\u8bba\uff1a\u5982\u679cn==1\u663e\u7136\u6982\u7387\u662f1\uff0c\u5982\u679cm==0\uff0c\u4ece\u6837\u4f8b\u53ef\u4ee5\u770b\u51fa\u662f0\uff0c\u5176\u4ed6\u60c5\u51b5\u662f1/(n-1), \u53c2\u8003\u4e8e\uff1a https://blog.csdn.net/lgz0921/article/details/96695326 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b % 2 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } int main () { // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); ll t ; scanf ( \"%lld\" , & t ); ll n , m , ans = 1 ; while ( t -- ) { scanf ( \"%lld%lld\" , & n , & m ); if ( n == 1 ) ans *= 1 ; else if ( m == 0 ) ans = 0 ; else ans = ( ans * ksm ( n - 1 , mod - 2 )) % mod ; printf ( \"%lld \\n \" , ans ); } }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e03\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e03\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_2","text":"Cow Steeplechase","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_3","text":"Farmer John has a brilliant idea for the next great spectator sport: Cow Steeplechase! As everyone knows, regular steeplechase involves a group of horses that race around a course filled with obstacles they must jump over.FJ figures the same contest should work with highly-trained cows, as long as the obstacles are made short enough. In order to design his course, FJ makes a diagram of all the N (1 <= N <=250) possible obstacles he could potentially build. Each one is represented by a line segment in the 2D plane that is parallel to the horizontal or vertical axis. Obstacle i has distinct endpoints (X1_i, Y1_i) and (X2_i, Y2_i) (1 <= X1_i, Y1_i, X2_i, Y2_i <= 1,000,000,000). An example is as follows: --+------- -----+----- ---+--- | | | | --+-----+--+- | | | | | | | --+--+--+-+- | | | | | FJ would like to build as many of these obstacles as possible, subject to the constraint that no two of them intersect. Starting with the diagram above, FJ can build 7 obstacles: ---------- ----------- ------- | | | | | | | | | | | | | | | | | | | Two segments are said to intersect if they share any point in common, even an endpoint of one or both of the segments. FJ is certain that no two horizontal segments in the original input diagram will intersect, and that similarly no two vertical segments in the input diagram will intersect. Please help FJ determine the maximum number of obstacles he can build.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_4","text":"Line 1: A single integer: N. Lines 2..N+1: Line i+1 contains four space-separated integers representing an obstacle: X1_i, Y1_i, X2_i, and Y2_i.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_5","text":"Line 1: The maximum number of non-crossing segments FJ can choose.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_6","text":"3 4 5 10 5 6 2 6 12 8 3 8 5","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_7","text":"2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_8","text":"There are three potential obstacles. The first is a horizontal segment connecting (4, 5) to (10, 5); the second and third are vertical segments connecting (6, 2) to (6, 12) and (8, 3) to (8, 5).The optimal solution is to choose both vertical segments.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_9","text":"\u7f51\u7edc\u6d41\u7b97\u6cd5\uff0c\u5c06\u6a2a\u5411\u76f4\u7ebf\u6807\u53f7\u5e76\u4e0e\u6e90\u70b9\u5efa\u8fb9\uff0c\u5e76\u8d4b\u6743\u503c1\uff1b\u5c06\u7eb5\u5411\u76f4\u7ebf\u6807\u53f7\u4e0e\u6c47\u70b9\u5efa\u8fb9\uff0c\u8d4b\u6743\u503c1\uff1b\u5c06\u6a2a\u7eb5\u4ea4\u53c9\u7684\u76f4\u7ebf\u5efa\u8fb9\uff0c\u8d4b\u6743\u503c\u4e3a\u6b63\u65e0\u7a77\uff1b\u7531\u6700\u5927\u6d41\u7b49\u4e8e\u6700\u5c0f\u5272\uff0c\u6240\u4ee5\u6839\u636eEK\u7b97\u6cd5\u6216\u8005Dinic\u7b97\u6cd5\u7b97\u51fa\u6700\u5927\u6d41\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_10","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll to , val , next ; }; node edge [ 100500 ] = { 0 }; ll head [ 4050 ] = { 0 }; ll cnt = 0 ; ll s = 1 , e = 1 ; void add_edge ( ll from , ll to , ll val ) { edge [ cnt ]. next = head [ from ]; edge [ cnt ]. to = to ; edge [ cnt ]. val = val ; head [ from ] = cnt ++ ; } ll pre [ 4050 ] = { 0 }, tag [ 4050 ] = { 0 }, vis [ 4050 ] = { 0 }; ll bfs () { queue < ll > que ; memset ( tag , 0 , sizeof ( tag )); memset ( pre , 0 , sizeof ( pre )); memset ( vis , 0 , sizeof ( vis )); que . push ( s ); vis [ s ] = 1 ; while ( ! que . empty ()) { ll now = que . front (); que . pop (); for ( ll i = head [ now ]; i != -1 ; i = edge [ i ]. next ) { ll to = edge [ i ]. to , val = edge [ i ]. val ; if ( ! vis [ to ] && val > 0 ) { vis [ to ] = 1 ; pre [ to ] = now ; tag [ to ] = i ; if ( to == e ) return 1 ; que . push ( to ); } } } return 0 ; } ll EK () { ll ans = 0 ; while ( bfs ()) { ll min1 = inf ; for ( ll i = e ; i != s ; i = pre [ i ]) { min1 = min ( min1 , edge [ tag [ i ]]. val ); } for ( ll i = e ; i != s ; i = pre [ i ]) { edge [ tag [ i ]]. val -= min1 ; edge [ tag [ i ] ^ 1 ]. val += min1 ; } ans += min1 ; } return ans ; } struct node1 { ll x1 , y1 , x2 , y2 , num ; }; node1 a [ 4050 ] = { 0 }, b [ 4050 ] = { 0 }; ll cnta = 0 , cntb = 0 ; int main () { //freopen(\"in.txt\", \"r\", stdin); ll n ; scanf ( \"%lld\" , & n ); ll x1 , x2 , y1 , y2 ; for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); if ( x1 > x2 ) swap ( x1 , x2 ); if ( y1 > y2 ) swap ( y1 , y2 ); if ( x1 == x2 ) a [ ++ cnta ] = { x1 , y1 , x2 , y2 , i }; else b [ ++ cntb ] = { x1 , y1 , x2 , y2 , i }; } for ( ll i = 0 ; i < 4050 ; i ++ ) head [ i ] = -1 ; e = 4000 , s = 0 ; for ( ll i = 1 ; i <= cnta ; i ++ ) { add_edge ( s , a [ i ]. num , 1 ); add_edge ( a [ i ]. num , s , 0 ); //cout << s << ' ' << a[i].num << ' ' << 1 << endl; } for ( ll i = 1 ; i <= cntb ; i ++ ) { add_edge ( e , b [ i ]. num , 0 ); add_edge ( b [ i ]. num , e , 1 ); //cout << e << ' ' << b[i].num << ' ' << 1 << endl; } for ( ll i = 1 ; i <= cnta ; i ++ ) { for ( ll j = 1 ; j <= cntb ; j ++ ) { if (( b [ j ]. x1 <= a [ i ]. x1 && a [ i ]. x1 <= b [ j ]. x2 ) && ( a [ i ]. y1 <= b [ j ]. y1 && b [ j ]. y1 <= a [ i ]. y2 )) { add_edge ( a [ i ]. num , b [ j ]. num , inf ); add_edge ( b [ j ]. num , a [ i ]. num , 0 ); //cout << a[i].num << ' ' << b[j].num << ' ' << inf << endl; } } } printf ( \"%lld \\n \" , n - EK ()); } \u8be5\u9898\u53e6\u5916\u4e00\u79cd\u505a\u6cd5\u4e3a\u4e8c\u5206\u56fe\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a #include <bits/stdc++.h> using namespace std ; typedef long long ll ; vector < int > v [ 1005 ]; map < int , int > mp , vis , mp1 ; int dfs ( int now ) { for ( int i = 0 ; i < v [ now ]. size (); i ++ ) { int to = v [ now ][ i ]; if ( ! vis [ to ]) { vis [ to ] = 1 ; if ( mp [ to ] == 0 || dfs ( mp [ to ])) { mp [ to ] = now ; mp1 [ now ] = to ; return 1 ; } } } return 0 ; } struct node1 { ll x1 , y1 , x2 , y2 , num ; }; node1 a [ 4050 ] = { 0 }, b [ 4050 ] = { 0 }; ll cnta = 0 , cntb = 0 ; int main () { ll n ; scanf ( \"%lld\" , & n ); ll x1 , x2 , y1 , y2 ; for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); if ( x1 > x2 ) swap ( x1 , x2 ); if ( y1 > y2 ) swap ( y1 , y2 ); if ( x1 == x2 ) { cnta ++ ; a [ cnta ] = { x1 , y1 , x2 , y2 , cnta }; } else { cntb ++ ; b [ cntb ] = { x1 , y1 , x2 , y2 , cntb }; } } for ( ll i = 1 ; i <= cnta ; i ++ ) { for ( ll j = 1 ; j <= cntb ; j ++ ) { if (( b [ j ]. x1 <= a [ i ]. x1 && a [ i ]. x1 <= b [ j ]. x2 ) && ( a [ i ]. y1 <= b [ j ]. y1 && b [ j ]. y1 <= a [ i ]. y2 )) { v [ a [ i ]. num ]. push_back ( b [ j ]. num ); } } } int ans = 0 ; for ( int i = 1 ; i <= cnta ; i ++ ) { vis . clear (); ans += dfs ( i ); } cout << n - ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_11","text":"Above the Median","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_12","text":"Farmer John has lined up his N (1 <= N <= 100,000) cows in a row to measure their heights; cow i has height H_i (1 <= H_i <= 1,000,000,000) nanometers--FJ believes in precise measurements! He wants to take a picture of some contiguous subsequence of the cows to submit to a bovine photography contest at the county fair. The fair has a very strange rule about all submitted photos: a photograph is only valid to submit if it depicts a group of cows whose median height is at least a certain threshold X (1 <= X <= 1,000,000,000). For purposes of this problem, we define the median of an array A[0...K] to be A[ceiling(K/2)] after A is sorted, where ceiling(K/2) gives K/2 rounded up to the nearest integer (or K/2 itself, it K/2 is an integer to begin with). For example the median of {7, 3, 2, 6} is 6, and the median of {5, 4, 8} is 5. Please help FJ count the number of different contiguous subsequences of his cows that he could potentially submit to the photography contest.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_13","text":"* Line 1: Two space-separated integers: N and X. * Lines 2..N+1: Line i+1 contains the single integer H_i.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_14","text":"* Line 1: The number of subsequences of FJ's cows that have median at least X. Note this may not fit into a 32-bit integer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_15","text":"4 6 10 5 6 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_16","text":"7","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_17","text":"FJ's four cows have heights 10, 5, 6, 2. We want to know how many contiguous subsequences have median at least 6.There are 10 possible contiguous subsequences to consider. Of these, only 7 have median at least 6. They are {10}, {6}, {10, 5}, {5, 6}, {6, 2}, {10,5, 6}, {10, 5, 6, 2}.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_18","text":"sum\u6570\u7ec4\u8bb0\u5f55\u6c42\u51fa\u5927\u4e8ek\u7684\u6570\u5b57\u4e2a\u6570\u7684\u524d\u7f00\u548c\uff0c\u5219\u9898\u76ee\u53ef\u4ee5\u8f6c\u53d8\u4e3a\u5bfb\u627e\u533a\u95f4[l,r]\u6ee1\u8db3sum[r]-sum[l-1]>=0\uff0c\u5229\u7528\u6811\u72b6\u6570\u7ec4\u67e5\u627e\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_19","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll tree [ 300500 ] = { 0 }; ll maxn = 300500 ; ll lowbit ( ll n ) { return n & ( - n ); } void add ( ll pos , ll val ) { for ( ll i = pos ; i <= maxn ; i += lowbit ( i )) tree [ i ] += val ; } ll query ( ll pos ) { ll ans = 0 ; for ( ll i = pos ; i > 0 ; i -= lowbit ( i )) ans += tree [ i ]; return ans ; } int main () { ll n , m , k , sum = 0 , ans = 0 ; scanf ( \"%lld%lld\" , & n , & k ) add ( n , 1 ); ///\u4e3a\u9632\u6b62\u8d1f\u6570\u51fa\u73b0\uff0c\u7edf\u4e00\u52a0n\uff0c\u8fd9\u91cc\u521d\u59cb\u5316\u589e\u6dfb\u4e00\u4e2a0 for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & m ); if ( m < k ) sum -= 1 ; else sum += 1 ; ans += query ( sum + n ); add ( sum + n , 1 ); } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_20","text":"Eddy Walker","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_21","text":"Eddy likes to walk around. Especially, he likes to walk in a loop called \"Infinite loop\". But, actually, it's just a loop with finite length(Anyway, the name doesn't matter). Eddy can walk in a fixed length. He finds that it takes him N steps to walk through the loop a cycle. Then, he puts N marks on the \"Infinite loop\" labeled with 0,1,\u2026,N\u22121, where i and i+1 are a step away each other, so as 0 and N-1. After that, Eddy stands on the mark labeled 0 and start walking around. For each step, Eddy will independently uniformly randomly choose to move forward or backward. If currently Eddy is on the mark labeled i, he will on the mark labeled i+1 if move forward or i-1 if move backward. If Eddy is on the mark labeled N-1 and moves forward, he will stand on the mark labeled 0. If Eddy is on the mark labeled 0 and moves backward, he will stand on the mark labeled N-1. Although, Eddy likes to walk around. He will get bored after he reaches each mark at least once. After that, Eddy will pick up all the marks, go back to work and stop walking around. You, somehow, notice the weird convention Eddy is doing. And, you record T scenarios that Eddy walks around. For i-th scenario, you record two numbers Ni, Mi, where Ni tells that in the i-th scenario, Eddy can walk through the loop a cycle in exactly Ni steps(Yes! Eddy can walk in different fixed length for different day.). While Mi tells that you found that in the i-th scenario, after Eddy stands on the mark labeled Mi, he reached all the marks. However, when you review your records, you are not sure whether the data is correct or even possible. Thus, you want to know the probability that those scenarios will happen. Precisely, you are going to compute the probability that first i scenarios will happen sequentially for each i.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_22","text":"The first line of input contains an integers T. Following T lines each contains two space-separated integers Ni and Mi. 1\u2264T\u22641021 0\u2264Mi<Ni\u2264109","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_23","text":"Output T lines each contains an integer representing the probability that first i scenarios will happen sequentially. you should output the number module 109+7(1000000007). Suppose the probability is P/Q, the desired output will be P\u00d7Q\u22121 mod 109+7","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_24","text":"3 1 0 2 1 3 0","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_25","text":"1 1 0","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_26","text":"\u6253\u8868\u627e\u89c4\u5f8b\uff0c\u6253\u8868\u4ee3\u7801\u5982\u4e0b\uff1a #include <iostream> #include <cstdlib> #include <cstring> #include <ctime> using namespace std ; int num [ 520 ]; bool vis [ 520 ]; int main (){ srand (( unsigned ) time ( NULL )); int n ; while ( cin >> n ){ memset ( num , 0 , sizeof ( num )); for ( int i = 1 ; i <= 10000000 ; i ++ ){ //\u6570\u636e\u5f00\u7684\u5927\uff0c\u8dd1\u5f97\u6162\uff0c\u8010\u5fc3\u7b49\u5f85\uff0c\u53ef\u4ee5\u8c03\u5c0f\u4e00\u70b9 memset ( vis , false , sizeof ( vis )); int pos = 0 ; int cnt = 1 ; vis [ 0 ] = true ; while ( cnt < n ){ int x = rand () % 2 ; if ( ! x ) x = -1 ; pos += x ; pos = ( pos + n ) % n ; if ( ! vis [ pos ]){ vis [ pos ] = true ; cnt ++ ; } if ( cnt == n ){ num [ pos ] ++ ; } } } for ( int i = 0 ; i < n ; i ++ ){ cout << i << \": \" << num [ i ] << endl ; } } return 0 ; } \u9644\uff1a C++\u4ea7\u751f\u4efb\u610f\u533a\u95f4\u7684\u968f\u673a\u6570\uff1anumber = (rand()%(maxValue - minValue +1)) + minValue; rand()\u4f1a\u8fd4\u56de\u4e00\u968f\u673a\u6570\u503c, \u8303\u56f4\u57280\u81f3RAND_MAX \u95f4\u3002RAND_MAX\u5b9a\u4e49\u5728stdlib.h, \u5176\u503c\u4e3a2147483647\u3002 srand()\u53ef\u7528\u6765\u8bbe\u7f6erand()\u4ea7\u751f\u968f\u673a\u6570\u65f6\u7684\u968f\u673a\u6570\u79cd\u5b50\u3002\u901a\u8fc7\u8bbe\u7f6e\u4e0d\u540c\u7684\u79cd\u5b50\uff0c\u6211\u4eec\u53ef\u4ee5\u83b7\u53d6\u4e0d\u540c\u7684\u968f\u673a\u6570\u5e8f\u5217\u3002\u53ef\u4ee5\u5229\u7528srand((int)(time(NULL))\u7684\u65b9\u6cd5\uff0c\u5229\u7528\u7cfb\u7edf\u65f6\u949f\uff0c\u4ea7\u751f\u4e0d\u540c\u7684\u968f\u673a\u6570\u79cd\u5b50\u3002 \u6253\u8868\u7ed3\u8bba\uff1a\u5982\u679cn==1\u663e\u7136\u6982\u7387\u662f1\uff0c\u5982\u679cm==0\uff0c\u4ece\u6837\u4f8b\u53ef\u4ee5\u770b\u51fa\u662f0\uff0c\u5176\u4ed6\u60c5\u51b5\u662f1/(n-1), \u53c2\u8003\u4e8e\uff1a https://blog.csdn.net/lgz0921/article/details/96695326","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%83%EF%BC%89/#_27","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b % 2 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } int main () { // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); ll t ; scanf ( \"%lld\" , & t ); ll n , m , ans = 1 ; while ( t -- ) { scanf ( \"%lld%lld\" , & n , & m ); if ( n == 1 ) ans *= 1 ; else if ( m == 0 ) ans = 0 ; else ans = ( ans * ksm ( n - 1 , mod - 2 )) % mod ; printf ( \"%lld \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e09\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 I love exam \u9898\u76ee\u63cf\u8ff0 \u00b6 Student Z doesn't love exams The exam was about to be done soon, but student Z didn't even read the book, He had collapsed. Student Z has a total of n exams, and there are still t days before the start of the exam, which means he still has t days to PREVIEW. But student Z couldn\u2019t even read the textbooks, and couldn\u2019t review it at all. Fortunately, a kind classmate gave him m sets of review materials. The i set of materials can improve the grades of the si course. The i set of materials needs to be studied for yi days. You can increase xi points later (the upper limit of each course is 100 points, so after it is upgraded to 100 points, there will be no further increase).and note that each set of review materials can only be used once. Student Z now has a zero-point level in every course. it is impossible to review all the materials, so he needs to choose some materials to review, but he can fail at most p courses in this semester (if the score of one course is less than 60 points will fail), otherwise he will be talked to by the professor. Student Z now wants to know the maximum points he can get in all courses under the premise of fail no more than p courses this semester. If he cannot meet the conditions, please output \u22121 . \u8f93\u5165 \u00b6 A positive integer T (T\u226410) in the first line represents the number of test cases. For each test case: The first line contains a positive integer n (n\u226450) represents the total number of courses in this semester. The second line contains n strings which length is no more than 15, representing the course name of each course in this semester. The third line contains a positive integer m (m\u226415000) represents the number of review materials he obtained. In the next m lines, each line have a string s and two positive integers x(1\u2264x\u226410) and y(1\u2264y\u226410) , representing the course of this set of materials review, the improved scores and The number of days required for learning(data assurance this course was studied this semester ). The last line has two integers t, p(1\u2264t\u2264500,0\u2264p\u22643) represents the number of review days that student Z has and the upper limit of the number of failed courses in this semester. \u8f93\u51fa \u00b6 For each test case, output a line with a positive integer representing the maximum score that student Z can obtain in the case of meeting the conditions .If he must be talked to by the professor, output \u22121\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 1 3 mathematics physics signals 20 physics 10 1 physics 10 1 physics 10 1 physics 10 1 physics 10 1 physics 10 1 physics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 signals 10 1 signals 10 1 signals 10 1 signals 10 1 signals 10 1 signals 10 2 19 1 \u6837\u4f8b\u8f93\u51fa \u00b6 190 \u9898\u89e3 \u00b6 \u9996\u514801\u80cc\u5305\u6c42\u51fa\u6bcf\u95e8\u8bfe\u82b1\u8d39k\u5929\u53ef\u4ee5\u6700\u591a\u5f97\u5230\u591a\u5c11\u5206\uff0c\u7136\u540edp[i][k][l]\u524di\u95e8\u8bfe\u7a0b,\u590d\u4e60\u4e86k\u5929\uff0c \u6302\u4e86l\u95e8\u8bfe\u7a0b\u7684\u6700\u5927\u5206\u6570\u3002 dp[i][k][l]=max(dp[i-1][k-j][l-x]+f[j],dp[i][k][l]); \u5177\u4f53\u53ef\u53c2\u7167\u535a\u5ba2\uff1a https://blog.csdn.net/m0_46062697/article/details/119008022 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int mx [ 600 ] = { 0 }; int dp [ 60 ][ 600 ][ 60 ] = { 0 }; ///dp[i][j][k]\u4ee3\u8868\u5b66\u4e60\u524di\u95e8\uff0c\u7528\u65f6j\u5929\u3002\u6302\u6389k\u95e8\u7684\u6700\u5927\u5206\u6570 map < string , int > mp ; string str ; vector < pair < int , int >> v [ 60 ]; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) v [ i ]. clear (); memset ( dp , -0x3f , sizeof ( dp )); mp . clear (); for ( int i = 1 ; i <= n ; i ++ ) { cin >> str ; mp [ str ] = i ; } int m , x , y ; scanf ( \"%d\" , & m ); for ( int i = 1 ; i <= m ; i ++ ) { cin >> str ; scanf ( \"%d %d\" , & x , & y ); int index = mp [ str ]; v [ index ]. push_back ({ x , y }); } int t , p ; scanf ( \"%d%d\" , & t , & p ); dp [ 0 ][ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { memset ( mx , -0x3f , sizeof ( mx )); mx [ 0 ] = 0 ; for ( int j = 0 ; j < v [ i ]. size (); j ++ ) for ( int k = t ; k >= v [ i ][ j ]. second ; k -- ) mx [ k ] = max ( mx [ k ], mx [ k - v [ i ][ j ]. second ] + v [ i ][ j ]. first ); for ( int j = 0 ; j <= t ; j ++ ) { for ( int k = j ; k <= t ; k ++ ) { for ( int l = 0 ; l <= p ; l ++ ) { if ( mx [ j ] < 0 ) continue ; int x = 0 ; if ( mx [ j ] < 60 ) x = 1 ; mx [ j ] = min ( mx [ j ], 100 ); if ( l >= x ) dp [ i ][ k ][ l ] = max ( dp [ i ][ k ][ l ], dp [ i - 1 ][ k - j ][ l - x ] + mx [ j ]); } } } } int ans = -0x3f ; for ( int i = 0 ; i <= t ; i ++ ) for ( int j = 0 ; j <= p ; j ++ ) ans = max ( ans , dp [ n ][ i ][ j ]); if ( ans < 0 ) puts ( \"-1\" ); else printf ( \"%d \\n \" , ans ); } }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e09\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e09\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_2","text":"I love exam","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_3","text":"Student Z doesn't love exams The exam was about to be done soon, but student Z didn't even read the book, He had collapsed. Student Z has a total of n exams, and there are still t days before the start of the exam, which means he still has t days to PREVIEW. But student Z couldn\u2019t even read the textbooks, and couldn\u2019t review it at all. Fortunately, a kind classmate gave him m sets of review materials. The i set of materials can improve the grades of the si course. The i set of materials needs to be studied for yi days. You can increase xi points later (the upper limit of each course is 100 points, so after it is upgraded to 100 points, there will be no further increase).and note that each set of review materials can only be used once. Student Z now has a zero-point level in every course. it is impossible to review all the materials, so he needs to choose some materials to review, but he can fail at most p courses in this semester (if the score of one course is less than 60 points will fail), otherwise he will be talked to by the professor. Student Z now wants to know the maximum points he can get in all courses under the premise of fail no more than p courses this semester. If he cannot meet the conditions, please output \u22121 .","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_4","text":"A positive integer T (T\u226410) in the first line represents the number of test cases. For each test case: The first line contains a positive integer n (n\u226450) represents the total number of courses in this semester. The second line contains n strings which length is no more than 15, representing the course name of each course in this semester. The third line contains a positive integer m (m\u226415000) represents the number of review materials he obtained. In the next m lines, each line have a string s and two positive integers x(1\u2264x\u226410) and y(1\u2264y\u226410) , representing the course of this set of materials review, the improved scores and The number of days required for learning(data assurance this course was studied this semester ). The last line has two integers t, p(1\u2264t\u2264500,0\u2264p\u22643) represents the number of review days that student Z has and the upper limit of the number of failed courses in this semester.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_5","text":"For each test case, output a line with a positive integer representing the maximum score that student Z can obtain in the case of meeting the conditions .If he must be talked to by the professor, output \u22121\u3002","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_6","text":"1 3 mathematics physics signals 20 physics 10 1 physics 10 1 physics 10 1 physics 10 1 physics 10 1 physics 10 1 physics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 mathematics 10 1 signals 10 1 signals 10 1 signals 10 1 signals 10 1 signals 10 1 signals 10 2 19 1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_7","text":"190","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_8","text":"\u9996\u514801\u80cc\u5305\u6c42\u51fa\u6bcf\u95e8\u8bfe\u82b1\u8d39k\u5929\u53ef\u4ee5\u6700\u591a\u5f97\u5230\u591a\u5c11\u5206\uff0c\u7136\u540edp[i][k][l]\u524di\u95e8\u8bfe\u7a0b,\u590d\u4e60\u4e86k\u5929\uff0c \u6302\u4e86l\u95e8\u8bfe\u7a0b\u7684\u6700\u5927\u5206\u6570\u3002 dp[i][k][l]=max(dp[i-1][k-j][l-x]+f[j],dp[i][k][l]); \u5177\u4f53\u53ef\u53c2\u7167\u535a\u5ba2\uff1a https://blog.csdn.net/m0_46062697/article/details/119008022","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/#_9","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int mx [ 600 ] = { 0 }; int dp [ 60 ][ 600 ][ 60 ] = { 0 }; ///dp[i][j][k]\u4ee3\u8868\u5b66\u4e60\u524di\u95e8\uff0c\u7528\u65f6j\u5929\u3002\u6302\u6389k\u95e8\u7684\u6700\u5927\u5206\u6570 map < string , int > mp ; string str ; vector < pair < int , int >> v [ 60 ]; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) v [ i ]. clear (); memset ( dp , -0x3f , sizeof ( dp )); mp . clear (); for ( int i = 1 ; i <= n ; i ++ ) { cin >> str ; mp [ str ] = i ; } int m , x , y ; scanf ( \"%d\" , & m ); for ( int i = 1 ; i <= m ; i ++ ) { cin >> str ; scanf ( \"%d %d\" , & x , & y ); int index = mp [ str ]; v [ index ]. push_back ({ x , y }); } int t , p ; scanf ( \"%d%d\" , & t , & p ); dp [ 0 ][ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { memset ( mx , -0x3f , sizeof ( mx )); mx [ 0 ] = 0 ; for ( int j = 0 ; j < v [ i ]. size (); j ++ ) for ( int k = t ; k >= v [ i ][ j ]. second ; k -- ) mx [ k ] = max ( mx [ k ], mx [ k - v [ i ][ j ]. second ] + v [ i ][ j ]. first ); for ( int j = 0 ; j <= t ; j ++ ) { for ( int k = j ; k <= t ; k ++ ) { for ( int l = 0 ; l <= p ; l ++ ) { if ( mx [ j ] < 0 ) continue ; int x = 0 ; if ( mx [ j ] < 60 ) x = 1 ; mx [ j ] = min ( mx [ j ], 100 ); if ( l >= x ) dp [ i ][ k ][ l ] = max ( dp [ i ][ k ][ l ], dp [ i - 1 ][ k - j ][ l - x ] + mx [ j ]); } } } } int ans = -0x3f ; for ( int i = 0 ; i <= t ; i ++ ) for ( int j = 0 ; j <= p ; j ++ ) ans = max ( ans , dp [ n ][ i ][ j ]); if ( ans < 0 ) puts ( \"-1\" ); else printf ( \"%d \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e5d\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Spread of Information \u9898\u76ee\u63cf\u8ff0 \u00b6 Takahashi Kingdom has N towns, called Town 1 through N. There are N\u22121 roads in this kingdom. The i-th road connects Town ui and Town vi bidirectionally. For any two towns a and b, it is possible to get from Town a to Town b by traversing some roads. Takahashi, the king, wants to spread some information all over the kingdom. Since he is busy, he can directly transmit this information to at most K towns. Assume that Takahashi finishes transmitting the information at time 0. Then, for each t=1,2,3,\u22ef, the following happens: For towns a and b directly connected by a road, if a has already received the information at time t\u22120.5 but b has not, b receives it at time t. Takahashi wants to choose the K towns to transmit the information to minimize the time taken until every town receives it. Find the minimum time this takes. Constraints All values in input are integers. 1\u2264K<N\u2264 2\u00d710^5 2\u00d710^5 1\u2264ui,vi\u2264N For any two towns a and b, it is possible to get from Town a to Town b by traversing some roads. \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N K u1 v1 u2 v2 \u22ee uN\u22121 vN\u22121 \u8f93\u51fa \u00b6 Print the answer. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 5 2 1 2 2 3 3 4 4 5 \u3010\u6837\u4f8b2\u3011 5 1 1 2 1 3 1 4 5 4 \u3010\u6837\u4f8b3\u3011 20 3 2 15 6 5 12 1 7 9 17 2 15 5 2 4 17 16 12 2 8 17 17 19 18 11 20 8 20 3 13 9 11 10 11 20 14 8 11 7 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 2 \u3010\u6837\u4f8b3\u3011 3 \u9898\u89e3 \u00b6 \u6811\u4e0aDP\uff0c\u8be6\u7ec6\u89c1\u4ee3\u7801\u6ce8\u91ca\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/qq_48099121/article/details/115670878 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; struct node { int to , next ; }; node edge [ 400500 ] = { 0 }; int head [ 200500 ] = { 0 }; int cnt = 0 , num = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } int f [ 200500 ] = { 0 }; ///f\u4ee3\u8868\u4ee5u\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u8ddd\u79bbu\u6700\u8fd1\u7684\u7279\u6b8a\u70b9 int g [ 200500 ] = { 0 }; ///g\u4ee3\u8868\u4ee5u\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u672a\u88ab\u8986\u76d6\u5230\u7684\u6700\u8fdc\u7684\u70b9 int dfs ( int now , int fa , int mid ) { f [ now ] = inf , g [ now ] = 0 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to == fa ) continue ; dfs ( to , now , mid ); f [ now ] = min ( f [ now ], f [ to ] + 1 ); g [ now ] = max ( g [ now ], g [ to ] + 1 ); } if ( g [ now ] + f [ now ] <= mid ) g [ now ] =- inf ; else if ( g [ now ] == mid ) g [ now ] =- inf , f [ now ] = 0 , num ++ ; } int check ( int mid ) { num = 0 ; dfs ( 1 , -1 , mid ); if ( g [ 1 ] >= 0 ) ///\u8fd8\u6709\u672a\u88ab\u8986\u76d6\u5230\u7684\u70b9 num ++ ; return num ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n -1 ; i ++ ) { int x , y ; scanf ( \"%d%d\" , & x , & y ); add_edge ( x , y ); add_edge ( y , x ); } int l = 0 , r = n ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( check ( mid ) <= m ) r = mid ; else l = mid + 1 ; } cout << l << endl ; } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2889&pid=5 \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has just received a new shipment of N (1 <= N <= 20) bales of hay, where bale i has size S_i (1 <= S_i <= 100). He wants to divide the bales between his three barns as fairly as possible. After some careful thought, FJ decides that a \"fair\" division of the hay bales should make the largest share as small as possible. That is, if B_1, B_2, and B_3 are the total sizes of all the bales placed in barns 1, 2, and 3, respectively (where B_1 >= B_2 >= B_3), then FJ wants to make B_1 as small as possible. For example, if there are 8 bales in these sizes: 2 4 5 8 9 14 15 20 A fair solution is Barn 1: 2 9 15 B_1 = 26 Barn 2: 4 8 14 B_2 = 26 Barn 3: 5 20 B_3 = 25 Please help FJ determine the value of B_1 for a fair division of the hay bales. \u8f93\u5165 \u00b6 * Line 1: The number of bales, N. * Lines 2..1+N: Line i+1 contains S_i, the size of the ith bale. \u8f93\u51fa \u00b6 * Line 1: Please output the value of B_1 in a fair division of the hay bales. \u6837\u4f8b\u8f93\u5165 \u00b6 8 14 2 5 15 8 9 20 4 \u6837\u4f8b\u8f93\u51fa \u00b6 26 \u9898\u89e3 \u00b6 \u4e09\u7ef4\u52a8\u6001\u89c4\u5212\u8f6c\u79fb\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll a [ 25 ] = { 0 }; bool dp [ 2 ][ 2005 ][ 2005 ] = { 0 }; int main () { ll n , sum = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); sum += a [ i ]; } dp [ 1 ][ 0 ][ 0 ] = true ; ll last = 1 , now = 0 ; ll ans = sum ; for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 0 ; j < 2005 ; j ++ ) { for ( ll k = 0 ; k < 2005 ; k ++ ) { if ( dp [ i & 1 ][ j ][ k ] == 1 ) { dp [( i + 1 ) & 1 ][ j ][ k ] = true ; if ( k + a [ i ] < 2005 ) dp [( i + 1 ) & 1 ][ j ][ k + a [ i ]] = true ; if ( j + a [ i ] < 2005 ) dp [( i + 1 ) & 1 ][ j + a [ i ]][ k ] = true ; } } } } for ( ll j = 0 ; j < 2005 ; j ++ ) { for ( ll k = 0 ; k < 2005 ; k ++ ) { if ( dp [ n & 1 ][ j ][ k ]) { ans = min ( ans , max ( sum - j - k , max ( j , k ))); } } } cout << ans << endl ; } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2889&pid=7 \u9898\u76ee\u63cf\u8ff0 \u00b6 Given are two sequences of length N each: A=(A1,A2,A3,\u2026,AN) and B=(B1,B2,B3,\u2026,BN). Determine whether it is possible to make A equal B by repeatedly doing the operation below (possibly zero times). If it is possible, find the minimum number of operations required to do so. Choose an integer i such that 1\u2264i<N, and do the following in order: swap Ai and Ai+1; add 1 to Ai; subtract 1 from Ai+1. Constraints 2\u2264N\u2264 2\u00d710^5 2\u00d710^5 \u200b\u200b 0\u2264Ai\u2264 10^9 10^9 \u200b 0\u2264Bi\u2264 10^9 10^9 All values in input are integers. \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N A1 A2 A3 \u2026 AN B1 B2 B3 \u2026 BN \u8f93\u51fa \u00b6 If it is impossible to make A equal B, print -1. Otherwise, print the minimum number of operations required to do so. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 3 3 1 4 6 2 0 \u3010\u6837\u4f8b2\u3011 3 1 1 1 1 1 2 \u3010\u6837\u4f8b3\u3011 5 5 4 1 3 2 5 4 1 3 2 \u3010\u6837\u4f8b4\u3011 6 8 5 4 7 4 5 10 5 6 7 4 1 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 2 \u3010\u6837\u4f8b2\u3011 -1 \u3010\u6837\u4f8b3\u3011 0 \u3010\u6837\u4f8b4\u3011 7 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca\uff1a We can match A with B in two operations, as follows: First, do the operation with i=2, making A=(3,5,0). Next, do the operation with i=1, making A=(6,2,0). We cannot meet our objective in one or fewer operations. \u6837\u4f8b2\u89e3\u91ca\uff1a In this case, it is impossible to match A with B. \u6837\u4f8b3\u89e3\u91ca\uff1a A may equal B before doing any operation. \u9898\u89e3 \u00b6 \u5bf9\u4e00\u4e2a\u6570\u7ec4\u8fdb\u884c\u5982\u4e0a\u7684\u4e09\u6b21\u64cd\u4f5c\u4e4b\u540e i+a[i] i+a[i] \u200b\u7684\u503c\u4fdd\u6301\u4e0d\u53d8\uff0c\u6240\u4ee5\u53ea\u8981\u628aa\u6570\u7ec4 i+a[i] i+a[i] \u200b\u8f6c\u53d8\u4e3ab\u6570\u7ec4\u4e2d j+b[j] j+b[j] \u200b\u5373\u53ef\uff0c\u53c8\u56e0\u4e3a\u4e3a\u76f8\u90bb\u4ea4\u6362\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u6c42\u51fa\u9006\u5e8f\u5bf9\u5373\u53ef\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/weixin_45483201/article/details/117699573 https://www.cnblogs.com/spnooyseed/p/14810702.html \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3.\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; const ll maxn = 400000 ; ll tree [ 400500 ] = { 0 }; ll a [ 200500 ] = { 0 }; ll b [ 200500 ] = { 0 }; unordered_map < int , vector < int > > mpa , mpb ; ll lowbit ( ll x ) { return x & ( - x ); } void add ( ll pos , ll val ) { for ( ll i = pos ; i <= 400000 ; i += lowbit ( i )) tree [ i ] += val ; } ll query ( ll pos ) { ll ans = 0 ; for ( ll i = pos ; i >= 1 ; i -= lowbit ( i )) ans += tree [ i ]; return ans ; } int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); a [ i ] += i ; mpa [ a [ i ]]. push_back ( i ); } for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & b [ i ]); b [ i ] += i ; mpb [ b [ i ]]. push_back ( i ); } for ( auto v : mpa ) { if ( v . second . size () != mpb [ v . first ]. size ()) return 0 * puts ( \"-1\" ); auto v2 = mpb [ v . first ]; for ( int i = 0 ; i < v . second . size (); i ++ ) a [ v . second [ i ]] = v2 [ i ]; } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { add ( a [ i ], 1 ); ans += i - query ( a [ i ]); } cout << ans << endl ; } \u9898\u76ee4 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2890&pid=3 \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has discovered that his cows produce higher quality milk when they are subject to strenuous exercise. He therefore decides to send his N cows (1 <= N <= 25,000) to climb up and then back down a nearby mountain! Cow i takes U(i) time to climb up the mountain and then D(i) time to climb down the mountain. Being domesticated cows, each cow needs the help of a farmer for each leg of the climb, but due to the poor economy, there are only two farmers available, Farmer John and his cousin Farmer Don. FJ plans to guide cows for the upward climb, and FD will then guide the cows for the downward climb. Since every cow needs a guide, and there is only one farmer for each part of the voyage, at most one cow may be climbing upward at any point in time (assisted by FJ), and at most one cow may be climbing down at any point in time (assisted by FD). A group of cows may temporarily accumulate at the top of the mountain if they climb up and then need to wait for FD's assistance before climbing down. Cows may climb down in a different order than they climbed up. Please determine the least possible amount of time for all N cows to make the entire journey. \u8f93\u5165 \u00b6 Line 1: The number of cows, N. Lines 2..1+N: Line i+1 contains two space-separated integers: U(i) and D(i). (1 <= U(i), D(i) <= 50,000). \u8f93\u51fa \u00b6 Line 1: A single integer representing the least amount of time for all the cows to cross the mountain. \u6837\u4f8b\u8f93\u5165 \u00b6 3 6 4 8 1 2 3 \u6837\u4f8b\u8f93\u51fa \u00b6 17 \u9898\u89e3 \u00b6 \u8d2a\u5fc3\uff0c\u8be6\u7ec6\u89c1\u4ee3\u7801\u6ce8\u91ca\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll u , d , sum , sum1 ; }; bool cmp ( node a , node b ) { if ( a . d > a . u && b . d <= b . u ) ///\u4e0b\u5c71\u6bd4\u4e0a\u5c71\u6162\u7684\u7684\u4f18\u5148\u4e0a return 1 ; else if ( a . d <= a . u && b . d > b . u ) return 0 ; else if ( a . d > a . u ) ///\u5148\u4e0a\u7684\u4f18\u5148\u8ba9\u4e0a\u5c71\u5feb\u7684\u4e0a\uff0c\u52a0\u901f\u65f6\u95f4 return a . u < b . u ; else return a . d > b . d ; ///\u540e\u4e0a\u7684\u4f18\u5148\u8ba9\u4e0b\u5c71\u7684\u6162\u7684\u4e0a\uff0c\u5c3d\u53ef\u80fd\u62d6\u5ef6\u65f6\u95f4 } node a [ 25500 ] = { 0 }; int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld%lld\" , & a [ i ]. u , & a [ i ]. d ); sort ( a + 1 , a + n + 1 , cmp ); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) a [ i ]. sum = a [ i -1 ]. sum + a [ i ]. u ; for ( ll i = 1 ; i <= n ; i ++ ) { a [ i ]. sum1 = max ( a [ i ]. sum , a [ i -1 ]. sum1 ) + a [ i ]. d ; ans = max ( ans , a [ i ]. sum1 ); } cout << ans << endl ; }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e5d\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e5d\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_2","text":"Spread of Information","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_3","text":"Takahashi Kingdom has N towns, called Town 1 through N. There are N\u22121 roads in this kingdom. The i-th road connects Town ui and Town vi bidirectionally. For any two towns a and b, it is possible to get from Town a to Town b by traversing some roads. Takahashi, the king, wants to spread some information all over the kingdom. Since he is busy, he can directly transmit this information to at most K towns. Assume that Takahashi finishes transmitting the information at time 0. Then, for each t=1,2,3,\u22ef, the following happens: For towns a and b directly connected by a road, if a has already received the information at time t\u22120.5 but b has not, b receives it at time t. Takahashi wants to choose the K towns to transmit the information to minimize the time taken until every town receives it. Find the minimum time this takes. Constraints All values in input are integers. 1\u2264K<N\u2264 2\u00d710^5 2\u00d710^5 1\u2264ui,vi\u2264N For any two towns a and b, it is possible to get from Town a to Town b by traversing some roads.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_4","text":"Input is given from Standard Input in the following format: N K u1 v1 u2 v2 \u22ee uN\u22121 vN\u22121","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_5","text":"Print the answer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_6","text":"\u3010\u6837\u4f8b1\u3011 5 2 1 2 2 3 3 4 4 5 \u3010\u6837\u4f8b2\u3011 5 1 1 2 1 3 1 4 5 4 \u3010\u6837\u4f8b3\u3011 20 3 2 15 6 5 12 1 7 9 17 2 15 5 2 4 17 16 12 2 8 17 17 19 18 11 20 8 20 3 13 9 11 10 11 20 14 8 11 7","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_7","text":"\u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 2 \u3010\u6837\u4f8b3\u3011 3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_8","text":"\u6811\u4e0aDP\uff0c\u8be6\u7ec6\u89c1\u4ee3\u7801\u6ce8\u91ca\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/qq_48099121/article/details/115670878","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_9","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; struct node { int to , next ; }; node edge [ 400500 ] = { 0 }; int head [ 200500 ] = { 0 }; int cnt = 0 , num = 0 ; void add_edge ( int from , int to ) { edge [ ++ cnt ] = { to , head [ from ]}; head [ from ] = cnt ; } int f [ 200500 ] = { 0 }; ///f\u4ee3\u8868\u4ee5u\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u8ddd\u79bbu\u6700\u8fd1\u7684\u7279\u6b8a\u70b9 int g [ 200500 ] = { 0 }; ///g\u4ee3\u8868\u4ee5u\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u672a\u88ab\u8986\u76d6\u5230\u7684\u6700\u8fdc\u7684\u70b9 int dfs ( int now , int fa , int mid ) { f [ now ] = inf , g [ now ] = 0 ; for ( int i = head [ now ]; i ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to == fa ) continue ; dfs ( to , now , mid ); f [ now ] = min ( f [ now ], f [ to ] + 1 ); g [ now ] = max ( g [ now ], g [ to ] + 1 ); } if ( g [ now ] + f [ now ] <= mid ) g [ now ] =- inf ; else if ( g [ now ] == mid ) g [ now ] =- inf , f [ now ] = 0 , num ++ ; } int check ( int mid ) { num = 0 ; dfs ( 1 , -1 , mid ); if ( g [ 1 ] >= 0 ) ///\u8fd8\u6709\u672a\u88ab\u8986\u76d6\u5230\u7684\u70b9 num ++ ; return num ; } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n -1 ; i ++ ) { int x , y ; scanf ( \"%d%d\" , & x , & y ); add_edge ( x , y ); add_edge ( y , x ); } int l = 0 , r = n ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( check ( mid ) <= m ) r = mid ; else l = mid + 1 ; } cout << l << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_10","text":"http://icpc.upc.edu.cn/problem.php?cid=2889&pid=5","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_11","text":"Farmer John has just received a new shipment of N (1 <= N <= 20) bales of hay, where bale i has size S_i (1 <= S_i <= 100). He wants to divide the bales between his three barns as fairly as possible. After some careful thought, FJ decides that a \"fair\" division of the hay bales should make the largest share as small as possible. That is, if B_1, B_2, and B_3 are the total sizes of all the bales placed in barns 1, 2, and 3, respectively (where B_1 >= B_2 >= B_3), then FJ wants to make B_1 as small as possible. For example, if there are 8 bales in these sizes: 2 4 5 8 9 14 15 20 A fair solution is Barn 1: 2 9 15 B_1 = 26 Barn 2: 4 8 14 B_2 = 26 Barn 3: 5 20 B_3 = 25 Please help FJ determine the value of B_1 for a fair division of the hay bales.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_12","text":"* Line 1: The number of bales, N. * Lines 2..1+N: Line i+1 contains S_i, the size of the ith bale.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_13","text":"* Line 1: Please output the value of B_1 in a fair division of the hay bales.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_14","text":"8 14 2 5 15 8 9 20 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_15","text":"26","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_16","text":"\u4e09\u7ef4\u52a8\u6001\u89c4\u5212\u8f6c\u79fb\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_17","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll a [ 25 ] = { 0 }; bool dp [ 2 ][ 2005 ][ 2005 ] = { 0 }; int main () { ll n , sum = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); sum += a [ i ]; } dp [ 1 ][ 0 ][ 0 ] = true ; ll last = 1 , now = 0 ; ll ans = sum ; for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = 0 ; j < 2005 ; j ++ ) { for ( ll k = 0 ; k < 2005 ; k ++ ) { if ( dp [ i & 1 ][ j ][ k ] == 1 ) { dp [( i + 1 ) & 1 ][ j ][ k ] = true ; if ( k + a [ i ] < 2005 ) dp [( i + 1 ) & 1 ][ j ][ k + a [ i ]] = true ; if ( j + a [ i ] < 2005 ) dp [( i + 1 ) & 1 ][ j + a [ i ]][ k ] = true ; } } } } for ( ll j = 0 ; j < 2005 ; j ++ ) { for ( ll k = 0 ; k < 2005 ; k ++ ) { if ( dp [ n & 1 ][ j ][ k ]) { ans = min ( ans , max ( sum - j - k , max ( j , k ))); } } } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_18","text":"http://icpc.upc.edu.cn/problem.php?cid=2889&pid=7","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_19","text":"Given are two sequences of length N each: A=(A1,A2,A3,\u2026,AN) and B=(B1,B2,B3,\u2026,BN). Determine whether it is possible to make A equal B by repeatedly doing the operation below (possibly zero times). If it is possible, find the minimum number of operations required to do so. Choose an integer i such that 1\u2264i<N, and do the following in order: swap Ai and Ai+1; add 1 to Ai; subtract 1 from Ai+1. Constraints 2\u2264N\u2264 2\u00d710^5 2\u00d710^5 \u200b\u200b 0\u2264Ai\u2264 10^9 10^9 \u200b 0\u2264Bi\u2264 10^9 10^9 All values in input are integers.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_20","text":"Input is given from Standard Input in the following format: N A1 A2 A3 \u2026 AN B1 B2 B3 \u2026 BN","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_21","text":"If it is impossible to make A equal B, print -1. Otherwise, print the minimum number of operations required to do so.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_22","text":"\u3010\u6837\u4f8b1\u3011 3 3 1 4 6 2 0 \u3010\u6837\u4f8b2\u3011 3 1 1 1 1 1 2 \u3010\u6837\u4f8b3\u3011 5 5 4 1 3 2 5 4 1 3 2 \u3010\u6837\u4f8b4\u3011 6 8 5 4 7 4 5 10 5 6 7 4 1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_23","text":"\u3010\u6837\u4f8b1\u3011 2 \u3010\u6837\u4f8b2\u3011 -1 \u3010\u6837\u4f8b3\u3011 0 \u3010\u6837\u4f8b4\u3011 7","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_24","text":"\u6837\u4f8b1\u89e3\u91ca\uff1a We can match A with B in two operations, as follows: First, do the operation with i=2, making A=(3,5,0). Next, do the operation with i=1, making A=(6,2,0). We cannot meet our objective in one or fewer operations. \u6837\u4f8b2\u89e3\u91ca\uff1a In this case, it is impossible to match A with B. \u6837\u4f8b3\u89e3\u91ca\uff1a A may equal B before doing any operation.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_25","text":"\u5bf9\u4e00\u4e2a\u6570\u7ec4\u8fdb\u884c\u5982\u4e0a\u7684\u4e09\u6b21\u64cd\u4f5c\u4e4b\u540e i+a[i] i+a[i] \u200b\u7684\u503c\u4fdd\u6301\u4e0d\u53d8\uff0c\u6240\u4ee5\u53ea\u8981\u628aa\u6570\u7ec4 i+a[i] i+a[i] \u200b\u8f6c\u53d8\u4e3ab\u6570\u7ec4\u4e2d j+b[j] j+b[j] \u200b\u5373\u53ef\uff0c\u53c8\u56e0\u4e3a\u4e3a\u76f8\u90bb\u4ea4\u6362\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u6c42\u51fa\u9006\u5e8f\u5bf9\u5373\u53ef\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/weixin_45483201/article/details/117699573 https://www.cnblogs.com/spnooyseed/p/14810702.html","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_26","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3.\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; const ll maxn = 400000 ; ll tree [ 400500 ] = { 0 }; ll a [ 200500 ] = { 0 }; ll b [ 200500 ] = { 0 }; unordered_map < int , vector < int > > mpa , mpb ; ll lowbit ( ll x ) { return x & ( - x ); } void add ( ll pos , ll val ) { for ( ll i = pos ; i <= 400000 ; i += lowbit ( i )) tree [ i ] += val ; } ll query ( ll pos ) { ll ans = 0 ; for ( ll i = pos ; i >= 1 ; i -= lowbit ( i )) ans += tree [ i ]; return ans ; } int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); a [ i ] += i ; mpa [ a [ i ]]. push_back ( i ); } for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & b [ i ]); b [ i ] += i ; mpb [ b [ i ]]. push_back ( i ); } for ( auto v : mpa ) { if ( v . second . size () != mpb [ v . first ]. size ()) return 0 * puts ( \"-1\" ); auto v2 = mpb [ v . first ]; for ( int i = 0 ; i < v . second . size (); i ++ ) a [ v . second [ i ]] = v2 [ i ]; } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { add ( a [ i ], 1 ); ans += i - query ( a [ i ]); } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#4","text":"","title":"\u9898\u76ee4"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_27","text":"http://icpc.upc.edu.cn/problem.php?cid=2890&pid=3","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_28","text":"Farmer John has discovered that his cows produce higher quality milk when they are subject to strenuous exercise. He therefore decides to send his N cows (1 <= N <= 25,000) to climb up and then back down a nearby mountain! Cow i takes U(i) time to climb up the mountain and then D(i) time to climb down the mountain. Being domesticated cows, each cow needs the help of a farmer for each leg of the climb, but due to the poor economy, there are only two farmers available, Farmer John and his cousin Farmer Don. FJ plans to guide cows for the upward climb, and FD will then guide the cows for the downward climb. Since every cow needs a guide, and there is only one farmer for each part of the voyage, at most one cow may be climbing upward at any point in time (assisted by FJ), and at most one cow may be climbing down at any point in time (assisted by FD). A group of cows may temporarily accumulate at the top of the mountain if they climb up and then need to wait for FD's assistance before climbing down. Cows may climb down in a different order than they climbed up. Please determine the least possible amount of time for all N cows to make the entire journey.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_29","text":"Line 1: The number of cows, N. Lines 2..1+N: Line i+1 contains two space-separated integers: U(i) and D(i). (1 <= U(i), D(i) <= 50,000).","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_30","text":"Line 1: A single integer representing the least amount of time for all the cows to cross the mountain.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_31","text":"3 6 4 8 1 2 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_32","text":"17","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_33","text":"\u8d2a\u5fc3\uff0c\u8be6\u7ec6\u89c1\u4ee3\u7801\u6ce8\u91ca\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B9%9D%EF%BC%89/#_34","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll u , d , sum , sum1 ; }; bool cmp ( node a , node b ) { if ( a . d > a . u && b . d <= b . u ) ///\u4e0b\u5c71\u6bd4\u4e0a\u5c71\u6162\u7684\u7684\u4f18\u5148\u4e0a return 1 ; else if ( a . d <= a . u && b . d > b . u ) return 0 ; else if ( a . d > a . u ) ///\u5148\u4e0a\u7684\u4f18\u5148\u8ba9\u4e0a\u5c71\u5feb\u7684\u4e0a\uff0c\u52a0\u901f\u65f6\u95f4 return a . u < b . u ; else return a . d > b . d ; ///\u540e\u4e0a\u7684\u4f18\u5148\u8ba9\u4e0b\u5c71\u7684\u6162\u7684\u4e0a\uff0c\u5c3d\u53ef\u80fd\u62d6\u5ef6\u65f6\u95f4 } node a [ 25500 ] = { 0 }; int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld%lld\" , & a [ i ]. u , & a [ i ]. d ); sort ( a + 1 , a + n + 1 , cmp ); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) a [ i ]. sum = a [ i -1 ]. sum + a [ i ]. u ; for ( ll i = 1 ; i <= n ; i ++ ) { a [ i ]. sum1 = max ( a [ i ]. sum , a [ i -1 ]. sum1 ) + a [ i ]. d ; ans = max ( ans , a [ i ]. sum1 ); } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e8c\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2852&pid=5 \u9898\u76ee\u63cf\u8ff0 \u00b6 Given a sequence of integers of length n, find the shortest consecutive subsequence witch XOR sum not less than k. If there are multiple consecutive subsequences of the same length, print the consecutive subsequence with the smallest left end point. If there are no consecutive subsequence witch XOR sum not less than k, just print \"-1\". \u8f93\u5165 \u00b6 The first line contains a single integer t (t<=100) representing the number of test cases in the input. Then t test cases follow. The first line of each test case contains two integers n (1<=n<=100000) and k (0<=k<2^30), representing the length of sequence. The second line of each test contains n integers ai (0<=ai<2^30), representing the integers in sequence. The number of test witch n>1000 does not exceed 5. \u8f93\u51fa \u00b6 For each test case, print two integers in one line, representing the left end point and right end point of the consecutive subsequence. If there are no consecutive subsequence witch XOR sum not less than k, print \"-1\" in one line. \u6837\u4f8b\u8f93\u5165 \u00b6 2 3 2 1 2 2 9 7 3 1 3 2 4 0 3 5 1 \u6837\u4f8b\u8f93\u51fa \u00b6 2 2 5 7 \u9898\u89e3 \u00b6 \u6784\u902001\u5b57\u5178\u6811\uff0c\u904d\u5386\u53f3\u8282\u70b9\uff0c\u67e5\u627e\u7b26\u5408\u6761\u4ef6\u7684\u5de6\u8282\u70b9\u6700\u5927\u503c\uff0c\u53ef\u53c2\u7167\u535a\u5ba2\uff1a https://www.cnblogs.com/lipoicyclic/p/15040070.html#4911382 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; int ch [ 3005000 ][ 2 ] = { 0 }; int val [ 3005000 ] = { 0 }; int max_pos [ 3005000 ] = { 0 }; int total = 0 ; int sum [ 100500 ] = { 0 }, a [ 100600 ] = { 0 }; int n , k ; void init () { ch [ 0 ][ 0 ] = ch [ 0 ][ 1 ] = 0 ; total = 1 ; for ( int i = 0 ; i <= 32 * n ; i ++ ) max_pos [ i ] = 0 ; } void insert ( int x , int pos ) { int u = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { int v = ( x >> i ) & 1 ; max_pos [ u ] = max ( max_pos [ u ], pos ); if ( ! ch [ u ][ v ]) { ch [ total ][ 0 ] = ch [ total ][ 1 ] = 0 ; ///\u521d\u59cb\u5316 val [ total ] = 0 ; ///\u672a\u5230\u5e95\u90e8\u8282\u70b9\uff0c\u4e3a0 ch [ u ][ v ] = total ++ ; } u = ch [ u ][ v ]; } val [ u ] = x ; max_pos [ u ] = max ( max_pos [ u ], pos ); } int dfs ( int p , int sum , int i , int k , int x ) { int ans = -1 ; if ( sum >= k ) return max_pos [ p ]; if ( sum + ((( 1l l << ( i + 1 )) - 1 )) < k ) return -1 ; if ( ch [ p ][ 0 ]) ans = max ( ans , dfs ( ch [ p ][ 0 ], sum + ( x & ( 1 << i )), i - 1 , k , x )); if ( ch [ p ][ 1 ]) ans = max ( ans , dfs ( ch [ p ][ 1 ], sum + (( x & ( 1 << i )) ^ ( 1 << i )), i - 1 , k , x )); return ans ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & k ); init (); insert ( 0 , 0 ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); sum [ i ] = sum [ i - 1 ] ^ a [ i ]; } int min_num = inf , ansl = -1 , ansr = -1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] >= k ) { min_num = 1 ; ansl = ansr = i ; break ; } int lpos = dfs ( 0 , 0 , 31 , k , sum [ i ]); if ( lpos != -1 && ( sum [ i ] ^ sum [ lpos ]) >= k ) { int len = i - lpos ; if ( len < min_num ) { min_num = len ; ansl = lpos + 1 ; ansr = i ; } else if ( len == min_num ) { if ( lpos + 1 < ansl ) ansl = lpos + 1 , ansr = i ; } } insert ( sum [ i ], i ); } if ( min_num != inf ) { printf ( \"%d %d \\n \" , ansl , ansr ); } else { printf ( \"-1 \\n \" ); } } } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 http://icpc.upc.edu.cn/problem.php?cid=2852&pid=7 \u9898\u76ee\u63cf\u8ff0 \u00b6 Given a matrix of n rows and m columns,find the largest area submatrix which is non decreasing on each column \u8f93\u5165 \u00b6 The first line contains an integer T(1\u2264T\u226410)representing the number of test cases. For each test case, the first line contains two integers n,m(1\u2264n,m\u22642\u2217103)representing the size of the matrix the next n line followed. the i-th line contains m integers vij(1\u2264vij\u22645\u2217103)representing the value of matrix It is guaranteed that there are no more than 2 testcases with n\u2217m>10000 \u8f93\u51fa \u00b6 For each test case, print a integer representing the Maximal submatrix \u6837\u4f8b\u8f93\u5165 \u00b6 1 2 3 1 2 4 2 3 3 \u6837\u4f8b\u8f93\u51fa \u00b6 4 \u9898\u89e3 \u00b6 \u627e\u6700\u5927\u7684\u4e0a\u5347\u5b50\u77e9\u9635\uff0c\u5229\u7528\u5355\u8c03\u6808\u7ef4\u62a4\u6bcf\u4e00\u884c\u7684\u5217\u6700\u5927\u4e0a\u5347\u503c\u548c\u5bbd\u5ea6\u7684\u4e58\u79ef\u5e76\u6c42\u51fa\u6700\u5927\u503c\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 2050 ][ 2050 ] = { 0 }; int sum [ 2050 ][ 2050 ] = { 0 }; struct node { int pos , val ; }; node s [ 100500 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d %d\" , & n , & m ); for ( int i = 0 ; i <= n + 1 ; i ++ ) for ( int j = 0 ; j <= m + 1 ; j ++ ) a [ i ][ j ] = sum [ i ][ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) scanf ( \"%d\" , & a [ i ][ j ]); for ( int j = 1 ; j <= m ; j ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ][ j ] >= a [ i - 1 ][ j ]) sum [ i ][ j ] = sum [ i - 1 ][ j ] + 1 ; else sum [ i ][ j ] = 1 ; } } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll top = 0 ; for ( ll j = 1 ; j <= m + 1 ; j ++ ) { if ( top == 0 ) { s [ ++ top ] = { j , sum [ i ][ j ]}; } else { while ( s [ top ]. val > sum [ i ][ j ]) { ll tmp = ( ll )( j - s [ top -1 ]. pos - 1 ) * ( ll ) s [ top ]. val ; top -- ; ans = max ( ans , tmp ); } s [ ++ top ] = { j , sum [ i ][ j ]}; } } } printf ( \"%lld \\n \" , ans ); } } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 https://ac.nowcoder.com/acm/contest/11255/J \u9898\u76ee\u622a\u56fe \u00b6 \u9898\u89e3 \u00b6 \u4e8c\u5206\u7b54\u6848\uff0c\u67e5\u627e\u957f\u5ea6\u5927\u4e8e\u67d0\u4e00\u7279\u5b9a\u503c\u7684\u5b50\u5e8f\u5217\u5e73\u5747\u503c\u6700\u5927\u503c\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; int a [ 100500 ] = { 0 }, b [ 100500 ] = { 0 }; int check ( int a [], double mid , int n , int k ) { double sum [ 100500 ] = { 0 }; double min1 [ 100500 ] = { 0 }; for ( int i = 1 ; i <= n ; i ++ ) min1 [ i ] = 2e5 ; for ( int i = 1 ; i <= n ; i ++ ) { sum [ i ] = sum [ i -1 ] + a [ i ] - mid ; min1 [ i ] = min ( min1 [ i -1 ], sum [ i ]); } for ( int i = k ; i <= n ; i ++ ) { if (( sum [ i ] - min1 [ i - k ]) >= 0.0000 ) return 1 ; } return 0 ; } int main () { int n , m , x , y ; scanf ( \"%d%d\" , & n , & m ); scanf ( \"%d%d\" , & x , & y ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); for ( int i = 1 ; i <= m ; i ++ ) scanf ( \"%d\" , & b [ i ]); double l = 0 , r = 1e5 ; while ( abs ( l - r ) > 1e-9 ) { double mid = ( l + r ) / 2.0 ; if ( check ( a , mid , n , x )) l = mid ; else r = mid ; } double ans1 = l ; l = 0 , r = 1e5 ; while ( abs ( l - r ) > 1e-9 ) { double mid = ( l + r ) / 2.0 ; if ( check ( b , mid , m , y )) l = mid ; else r = mid ; } double ans2 = l ; printf ( \"%.10f \\n \" , ans2 + ans1 ); }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e8c\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e8c\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_2","text":"http://icpc.upc.edu.cn/problem.php?cid=2852&pid=5","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_3","text":"Given a sequence of integers of length n, find the shortest consecutive subsequence witch XOR sum not less than k. If there are multiple consecutive subsequences of the same length, print the consecutive subsequence with the smallest left end point. If there are no consecutive subsequence witch XOR sum not less than k, just print \"-1\".","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_4","text":"The first line contains a single integer t (t<=100) representing the number of test cases in the input. Then t test cases follow. The first line of each test case contains two integers n (1<=n<=100000) and k (0<=k<2^30), representing the length of sequence. The second line of each test contains n integers ai (0<=ai<2^30), representing the integers in sequence. The number of test witch n>1000 does not exceed 5.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_5","text":"For each test case, print two integers in one line, representing the left end point and right end point of the consecutive subsequence. If there are no consecutive subsequence witch XOR sum not less than k, print \"-1\" in one line.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_6","text":"2 3 2 1 2 2 9 7 3 1 3 2 4 0 3 5 1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_7","text":"2 2 5 7","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_8","text":"\u6784\u902001\u5b57\u5178\u6811\uff0c\u904d\u5386\u53f3\u8282\u70b9\uff0c\u67e5\u627e\u7b26\u5408\u6761\u4ef6\u7684\u5de6\u8282\u70b9\u6700\u5927\u503c\uff0c\u53ef\u53c2\u7167\u535a\u5ba2\uff1a https://www.cnblogs.com/lipoicyclic/p/15040070.html#4911382","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_9","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; int ch [ 3005000 ][ 2 ] = { 0 }; int val [ 3005000 ] = { 0 }; int max_pos [ 3005000 ] = { 0 }; int total = 0 ; int sum [ 100500 ] = { 0 }, a [ 100600 ] = { 0 }; int n , k ; void init () { ch [ 0 ][ 0 ] = ch [ 0 ][ 1 ] = 0 ; total = 1 ; for ( int i = 0 ; i <= 32 * n ; i ++ ) max_pos [ i ] = 0 ; } void insert ( int x , int pos ) { int u = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { int v = ( x >> i ) & 1 ; max_pos [ u ] = max ( max_pos [ u ], pos ); if ( ! ch [ u ][ v ]) { ch [ total ][ 0 ] = ch [ total ][ 1 ] = 0 ; ///\u521d\u59cb\u5316 val [ total ] = 0 ; ///\u672a\u5230\u5e95\u90e8\u8282\u70b9\uff0c\u4e3a0 ch [ u ][ v ] = total ++ ; } u = ch [ u ][ v ]; } val [ u ] = x ; max_pos [ u ] = max ( max_pos [ u ], pos ); } int dfs ( int p , int sum , int i , int k , int x ) { int ans = -1 ; if ( sum >= k ) return max_pos [ p ]; if ( sum + ((( 1l l << ( i + 1 )) - 1 )) < k ) return -1 ; if ( ch [ p ][ 0 ]) ans = max ( ans , dfs ( ch [ p ][ 0 ], sum + ( x & ( 1 << i )), i - 1 , k , x )); if ( ch [ p ][ 1 ]) ans = max ( ans , dfs ( ch [ p ][ 1 ], sum + (( x & ( 1 << i )) ^ ( 1 << i )), i - 1 , k , x )); return ans ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & k ); init (); insert ( 0 , 0 ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); sum [ i ] = sum [ i - 1 ] ^ a [ i ]; } int min_num = inf , ansl = -1 , ansr = -1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] >= k ) { min_num = 1 ; ansl = ansr = i ; break ; } int lpos = dfs ( 0 , 0 , 31 , k , sum [ i ]); if ( lpos != -1 && ( sum [ i ] ^ sum [ lpos ]) >= k ) { int len = i - lpos ; if ( len < min_num ) { min_num = len ; ansl = lpos + 1 ; ansr = i ; } else if ( len == min_num ) { if ( lpos + 1 < ansl ) ansl = lpos + 1 , ansr = i ; } } insert ( sum [ i ], i ); } if ( min_num != inf ) { printf ( \"%d %d \\n \" , ansl , ansr ); } else { printf ( \"-1 \\n \" ); } } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_10","text":"http://icpc.upc.edu.cn/problem.php?cid=2852&pid=7","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_11","text":"Given a matrix of n rows and m columns,find the largest area submatrix which is non decreasing on each column","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_12","text":"The first line contains an integer T(1\u2264T\u226410)representing the number of test cases. For each test case, the first line contains two integers n,m(1\u2264n,m\u22642\u2217103)representing the size of the matrix the next n line followed. the i-th line contains m integers vij(1\u2264vij\u22645\u2217103)representing the value of matrix It is guaranteed that there are no more than 2 testcases with n\u2217m>10000","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_13","text":"For each test case, print a integer representing the Maximal submatrix","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_14","text":"1 2 3 1 2 4 2 3 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_15","text":"4","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_16","text":"\u627e\u6700\u5927\u7684\u4e0a\u5347\u5b50\u77e9\u9635\uff0c\u5229\u7528\u5355\u8c03\u6808\u7ef4\u62a4\u6bcf\u4e00\u884c\u7684\u5217\u6700\u5927\u4e0a\u5347\u503c\u548c\u5bbd\u5ea6\u7684\u4e58\u79ef\u5e76\u6c42\u51fa\u6700\u5927\u503c\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_17","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int a [ 2050 ][ 2050 ] = { 0 }; int sum [ 2050 ][ 2050 ] = { 0 }; struct node { int pos , val ; }; node s [ 100500 ] = { 0 }; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d %d\" , & n , & m ); for ( int i = 0 ; i <= n + 1 ; i ++ ) for ( int j = 0 ; j <= m + 1 ; j ++ ) a [ i ][ j ] = sum [ i ][ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) scanf ( \"%d\" , & a [ i ][ j ]); for ( int j = 1 ; j <= m ; j ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ][ j ] >= a [ i - 1 ][ j ]) sum [ i ][ j ] = sum [ i - 1 ][ j ] + 1 ; else sum [ i ][ j ] = 1 ; } } ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll top = 0 ; for ( ll j = 1 ; j <= m + 1 ; j ++ ) { if ( top == 0 ) { s [ ++ top ] = { j , sum [ i ][ j ]}; } else { while ( s [ top ]. val > sum [ i ][ j ]) { ll tmp = ( ll )( j - s [ top -1 ]. pos - 1 ) * ( ll ) s [ top ]. val ; top -- ; ans = max ( ans , tmp ); } s [ ++ top ] = { j , sum [ i ][ j ]}; } } } printf ( \"%lld \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_18","text":"https://ac.nowcoder.com/acm/contest/11255/J","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_19","text":"","title":"\u9898\u76ee\u622a\u56fe"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_20","text":"\u4e8c\u5206\u7b54\u6848\uff0c\u67e5\u627e\u957f\u5ea6\u5927\u4e8e\u67d0\u4e00\u7279\u5b9a\u503c\u7684\u5b50\u5e8f\u5217\u5e73\u5747\u503c\u6700\u5927\u503c\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/#_21","text":"#include <bits/stdc++.h> using namespace std ; int a [ 100500 ] = { 0 }, b [ 100500 ] = { 0 }; int check ( int a [], double mid , int n , int k ) { double sum [ 100500 ] = { 0 }; double min1 [ 100500 ] = { 0 }; for ( int i = 1 ; i <= n ; i ++ ) min1 [ i ] = 2e5 ; for ( int i = 1 ; i <= n ; i ++ ) { sum [ i ] = sum [ i -1 ] + a [ i ] - mid ; min1 [ i ] = min ( min1 [ i -1 ], sum [ i ]); } for ( int i = k ; i <= n ; i ++ ) { if (( sum [ i ] - min1 [ i - k ]) >= 0.0000 ) return 1 ; } return 0 ; } int main () { int n , m , x , y ; scanf ( \"%d%d\" , & n , & m ); scanf ( \"%d%d\" , & x , & y ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); for ( int i = 1 ; i <= m ; i ++ ) scanf ( \"%d\" , & b [ i ]); double l = 0 , r = 1e5 ; while ( abs ( l - r ) > 1e-9 ) { double mid = ( l + r ) / 2.0 ; if ( check ( a , mid , n , x )) l = mid ; else r = mid ; } double ans1 = l ; l = 0 , r = 1e5 ; while ( abs ( l - r ) > 1e-9 ) { double mid = ( l + r ) / 2.0 ; if ( check ( b , mid , m , y )) l = mid ; else r = mid ; } double ans2 = l ; printf ( \"%.10f \\n \" , ans2 + ans1 ); }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e94\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u9e3d\u5b50 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u4f60\u7684\u673a\u623f\u5171\u6709 n \u53f0\u7535\u8111\uff0c\u4f46\u662f\u7b2c k \u53f0\u7535\u8111\u574f\u4e86\u3002 \u4f60\u7684\u8001\u5e08\u7ed9\u4f60 m \u6b21\u8981\u6c42\uff0c\u6bcf\u6b21\u8981\u6c42\u4f60\u5c06\u7b2c ui \u548c vi \u53f0\u7535\u8111\u4ea4\u6362\uff0c\u8fd9\u6837\u574f\u7684\u7535\u8111\u5c31\u53ef\u80fd\u4f1a\u88ab\u4ea4\u6362\u5230\u4e00\u4e2a\u65b0\u7684\u4f4d\u7f6e\u3002 \u4f46\u7531\u4e8e\u4f60\u5e0c\u671b\u8fdb\u884c\u6697\u7bb1\u64cd\u4f5c\uff0c\u4f60\u53ef\u4ee5\u62d2\u7edd\u6267\u884c\u5176\u4e2d\u7684\u82e5\u5e72\u6761\u8981\u6c42\uff0c\u4f7f\u5f97\u574f\u7684\u7535\u8111\u6700\u7ec8\u4ea4\u6362\u5230 j \u53f7\u4f4d\u7f6e\u3002 \u7531\u4e8e\u9a97\u8fc7\u8001\u5e08\u5f88\u7d2f\uff0c\u8bf7\u5bf9\u4e8e j=1...n \u6c42\u51fa\u6700\u5c11\u53ef\u80fd\u7684\u4e0d\u6267\u884c\u8981\u6c42\u6761\u6570\uff0c\u4f7f\u5f97\u574f\u7684\u7535\u8111\u5728\u7b2c j \u4e2a\u4f4d\u7f6e\u3002 \u8f93\u5165 \u00b6 \u672c\u9898\u6709\u591a\u7ec4\u6d4b\u8bd5\u6570\u636e\u3002 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6570 T \u8868\u793a\u4e00\u5171\u6709 T \u7ec4\u6570\u636e\u3002\u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u6570\u636e\uff1a \u7b2c\u4e00\u884c\u4e09\u4e2a\u6574\u6570 n,m,k \uff0c\u8868\u793a\u7535\u8111\u4e2a\u6570\uff0c\u603b\u64cd\u4f5c\u6b21\u6570\u548c\u574f\u7535\u8111\u7684\u521d\u59cb\u4f4d\u7f6e\u3002 \u4e0b\u9762 m \u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6b63\u6574\u6570 ui , vi \uff0c\u8868\u793a\u8fd9\u6b21\u64cd\u4f5c\u9009\u62e9\u7684\u4e24\u4e2a\u4f4d\u7f6e\u3002 \u6ee1\u8db3 1\u2264T\u22645\uff0c1\u2264n\u226410 5\uff0c0\u2264m\u226410 5\uff0c1\u2264k\u2264n\u3002 \u8f93\u51fa \u00b6 \u5bf9\u6bcf\u7ec4\u6570\u636e\uff0c\u8f93\u51fa\u5171\u4e00\u884c n \u4e2a\u6574\u6570\uff0c\u7b2c i \u4e2a\u6574\u6570\u8868\u793a\u4f7f\u574f\u7535\u8111\u6700\u7ec8\u505c\u7559\u5728\u8be5\u4f4d\u7f6e\u6240\u9700\u7684\u6700\u5c11\u6697\u7bb1\u64cd\u4f5c\u6b21\u6570\u3002 \u82e5\u6700\u7ec8\u574f\u7535\u8111\u4e0d\u53ef\u80fd\u505c\u7559\u5728\u8be5\u4f4d\u7f6e\uff0c\u5219\u8f93\u51fa \u22121\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 1 5 5 1 3 5 2 1 4 1 3 1 3 1 \u6837\u4f8b\u8f93\u51fa \u00b6 2 0 3 1 -1 \u9898\u89e3 \u00b6 \u52a8\u6001\u89c4\u5212\uff0c\u5f53\u8981\u6c42\u8f6c\u79fbu\u548cv\u65f6\uff1a dp[i][u]=min(dp[i-1][u]+1,dp[i-1][v]); dp[i][v]=min(dp[i-1][v]+1,dp[i-1][u]); \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll dp [ 200500 ] = { 0 }; int main () { // freopen(\"in.txt\",\"r\",stdin); // freopen(\"out.txt\",\"w\",stdout); ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , m , k ; scanf ( \"%lld%lld%lld\" , & n , & m , & k ); for ( ll i = 1 ; i <= n ; i ++ ) dp [ i ] = inf ; dp [ k ] = 0 ; ll u , v ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld\" , & u , & v ); ll tmpv = min ( dp [ v ] + 1 , dp [ u ]); ll tmpu = min ( dp [ u ] + 1 , dp [ v ]); dp [ v ] = tmpv ; dp [ u ] = tmpu ; } for ( ll i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] == inf ) { if ( i != n ) printf ( \"-1 \" ); else printf ( \"-1\" ); } else { if ( i != n ) printf ( \"%lld \" , dp [ i ]); else printf ( \"%lld\" , dp [ i ]); } } printf ( \" \\n \" ); } } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u8ff7\u5931 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u5c0f T \u8ff7\u5931\u5728\u4e86\u4e00\u4e2a\u6709 n \u4e2a\u70b9\u7684\u7fa4\u5c9b\u4e0a\u3002 \u521d\u59cb\u65f6\u4ed6\u5728 1 \u53f7\u5c9b\uff0c\u4ed6\u8981\u901a\u8fc7\u67b6\u5728\u5c9b\u95f4\u7684 m \u5ea7\u53cc\u5411\u6865\uff0c\u5728\u6b63\u597d\u8fc7 k \u5ea7\u6865\u65f6\u8fbe\u5230 n \u53f7\u5c9b\u7684\u5927\u95e8\u3002 \u8fd9\u4e9b\u6865\u4e2d\u6709\u82e5\u5e72\u5ea7\u9644\u9b54\u6865\u3002\u5f53\u5c0f T \u7ecf\u8fc7\u4e00\u5ea7\u9644\u9b54\u6865\u65f6\uff0c\u5982\u679c\u4ed6\u8eab\u4e0a\u6ca1\u6709\u9644\u9b54\u6807\u8bb0\u5219\u88ab\u6807\u8bb0\uff0c\u5982\u679c\u4ed6\u8eab\u4e0a\u5df2\u6709\u9644\u9b54\u6807\u8bb0\u5219\u6807\u8bb0\u6d88\u5931\u3002 \u5927\u95e8\u53ea\u4f1a\u5728\u4ed6\u8eab\u4e0a\u6709\u9644\u9b54\u6807\u8bb0\u65f6\u624d\u4f1a\u5f00\u542f\uff0c\u53ea\u6709\u8fd9\u6837\u4ed6\u624d\u80fd\u9003\u79bb\u3002 \u5c0f T \u8ff7\u5931\u5728\u4e86\u7fa4\u5c9b\u4e4b\u95f4\uff0c\u4ed6\u6bcf\u6b21\u4f1a\u7b49\u6982\u7387\u968f\u673a\u6311\u9009\u4e00\u5ea7\u4e0e\u4ed6\u6240\u5728\u5c9b\u5c7f\u76f8\u8fde\u7684\u6865\u8d70\u3002\u5c0f T \u5411\u4f60\u8be2\u95ee\u4ed6\u80fd\u9003\u79bb\u7684\u6982\u7387\u3002 \u4fdd\u8bc1\u56fe\u65e0\u81ea\u73af\u65e0\u91cd\u8fb9\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6570 T \u8868\u793a\u4e00\u5171\u6709 T \u7ec4\u6570\u636e\u3002\u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u6570\u636e\uff1a \u7b2c\u4e00\u884c\u4e09\u4e2a\u6b63\u6574\u6570 n\uff0cm\uff0ck\u3002 \u6b64\u540e m \u884c\uff0c\u6bcf\u884c\u4e09\u4e2a\u6570 ui\uff0cvi\uff0cwi \uff0c\u8868\u793a\u4e00\u5ea7\u4ece ui \u5230 vi \u7684\u6865\u3002\u82e5 wi=1 \u5219\u8be5\u6865\u662f\u9644\u9b54\u6865\uff0c\u5426\u5219\uff08wi=0\uff09\u662f\u666e\u901a\u6865\u3002 \u4fdd\u8bc1\u65e0\u81ea\u73af\u65e0\u91cd\u8fb9\uff0cT\u226410\uff0c1\u2264ui,vi\u2264n\uff0cwi \u4e3a 0 \u5230 1 \u7684\u6574\u6570\uff0c\u6ee1\u8db3 2\u2264n\u2264100\uff0c1\u2264m\u2264n\u00d7(n\u22121)/2\uff0c1\u2264k\u226410^6\u3002 \u8f93\u51fa \u00b6 \u8f93\u51fa\u4e00\u5171 T \u884c\u3002\u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u6570\u636e\uff0c\u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570\uff1a\u4ed6\u80fd\u9003\u79bb\u7684\u6982\u7387\u5bf9 998244353 \u7684\u6a21\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 2 4 4 2 1 2 1 2 4 0 1 3 0 3 4 0 6 7 2 1 2 0 1 3 1 1 4 1 2 5 0 3 5 0 3 6 0 4 6 0 \u6837\u4f8b\u8f93\u51fa \u00b6 748683265 610038216 \u63d0\u793a \u00b6 \u7b2c\u4e00\u7ec4\u6570\u636e \u4ece 1 1 \u8d70\u5230 n n \u5e76\u4e14\u7ecf\u8fc7\u4e00\u6761\u9644\u9b54\u8fb9\u7684\u6982\u7387\u4e3a 1/4 1/4 \uff0c\u5bf9 998244353 998244353 \u53d6\u6a21\u540e\u4e3a 748683265 748683265 \u3002 \u7b2c\u4e8c\u7ec4\u6570\u636e \u6982\u7387\u4e3a 5/18 5/18 \uff0c\u5bf9 998244353 998244353 \u53d6\u6a21\u540e\u4e3a 610038216 610038216 \u200b\u3002 \u9898\u89e3 \u00b6 \u77e9\u9635\u5feb\u901f\u5e42\uff0c\u901a\u8fc7\u6784\u9020\u90bb\u63a5\u77e9\u9635\u505a\u4e58\u6cd5\u5e42\u8fd0\u7b97\u7684\u65b9\u5f0f\u8ba1\u7b97\u51fa\u6700\u7ec8\u7684\u6982\u7387\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b % 2 ) ans1 = ( ans2 * ans1 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } ll a [ 400 ][ 400 ] = { 0 }; ll ans1 [ 400 ][ 400 ] = { 0 }; ll ans2 [ 400 ][ 400 ] = { 0 }; vector < pair < int , int >> v [ 400 ]; int n , m , k ; void cf ( ll a [ 400 ][ 400 ], ll b [ 400 ][ 400 ]) { ll c [ 400 ][ 400 ] = { 0 }; for ( ll i = 1 ; i <= 2 * n ; i ++ ) { for ( ll j = 1 ; j <= 2 * n ; j ++ ) { for ( ll k = 1 ; k <= 2 * n ; k ++ ) { c [ i ][ j ] += a [ i ][ k ] * b [ k ][ j ]; c [ i ][ j ] %= mod ; } } } for ( ll i = 1 ; i <= 2 * n ; i ++ ) { for ( ll j = 1 ; j <= 2 * n ; j ++ ) { a [ i ][ j ] = c [ i ][ j ]; a [ i ][ j ] %= mod ; } } } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d %d\" , & n , & m , & k ); memset ( a , 0 , sizeof ( a )); for ( int i = 1 ; i <= n ; i ++ ) v [ i ]. clear (); int from , to , val ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d %d %d\" , & from , & to , & val ); v [ from ]. push_back ({ to , val }); v [ to ]. push_back ({ from , val }); } for ( int i = 1 ; i <= n ; i ++ ) { ll tmp = ksm (( ll ) v [ i ]. size (), mod - 2 ); for ( int k = 0 ; k < v [ i ]. size (); k ++ ) { pair < int , int > j = v [ i ][ k ]; if ( j . second == 0 ) { a [ i * 2 - 1 ][ j . first * 2 - 1 ] = tmp ; a [ i * 2 ][ j . first * 2 ] = tmp ; } else { a [ i * 2 - 1 ][ j . first * 2 ] = tmp ; a [ i * 2 ][ j . first * 2 - 1 ] = tmp ; } } } for ( ll i = 1 ; i <= 2 * n ; i ++ ) { for ( ll j = 1 ; j <= 2 * n ; j ++ ) { ans1 [ i ][ j ] = a [ i ][ j ]; if ( i == j ) ans2 [ i ][ j ] = 1 ; else ans2 [ i ][ j ] = 0 ; } } while ( k != 0 ) { if ( k % 2 ) cf ( ans2 , ans1 ); cf ( ans1 , ans1 ); k /= 2 ; } printf ( \"%lld \\n \" , ans2 [ 1 ][ 2 * n ]); } } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 https://ac.nowcoder.com/acm/contest/11256/K \u9898\u76ee \u00b6 \u9898\u89e3 \u00b6 \u7ef4\u62a4\u5355\u8c03\u5b50\u5e8f\u5217\uff0c\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u533a\u95f4\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); while ( m -- ) { ll k ; scanf ( \"%lld\" , & k ); deque < ll > que1 , que2 ; ///\u7ef4\u62a4\u9012\u589e\u5e8f\u5217\u548c\u9012\u51cf\u5e8f\u5217 ll ans = 0 , last = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { while ( ! que1 . empty () && a [ que1 . back ()] < a [ i ]) ///\u9012\u51cf que1 . pop_back (); que1 . push_back ( i ); while ( ! que2 . empty () && a [ que2 . back ()] > a [ i ]) ///\u9012\u589e que2 . pop_back (); que2 . push_back ( i ); while ( ! que1 . empty () && ! que2 . empty () && a [ que1 . front ()] - a [ que2 . front ()] > k ) { if ( que1 . front () < que2 . front ()) ans += ( n - que2 . front () + 1 ) * ( que1 . front () - last ), last = que1 . front (), que1 . pop_front (); else ans += ( n - que1 . front () + 1 ) * ( que2 . front () - last ), last = que2 . front (), que2 . pop_front (); } } printf ( \"%lld \\n \" , ans ); } }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e94\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u4e94\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_2","text":"\u9e3d\u5b50","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_3","text":"\u4f60\u7684\u673a\u623f\u5171\u6709 n \u53f0\u7535\u8111\uff0c\u4f46\u662f\u7b2c k \u53f0\u7535\u8111\u574f\u4e86\u3002 \u4f60\u7684\u8001\u5e08\u7ed9\u4f60 m \u6b21\u8981\u6c42\uff0c\u6bcf\u6b21\u8981\u6c42\u4f60\u5c06\u7b2c ui \u548c vi \u53f0\u7535\u8111\u4ea4\u6362\uff0c\u8fd9\u6837\u574f\u7684\u7535\u8111\u5c31\u53ef\u80fd\u4f1a\u88ab\u4ea4\u6362\u5230\u4e00\u4e2a\u65b0\u7684\u4f4d\u7f6e\u3002 \u4f46\u7531\u4e8e\u4f60\u5e0c\u671b\u8fdb\u884c\u6697\u7bb1\u64cd\u4f5c\uff0c\u4f60\u53ef\u4ee5\u62d2\u7edd\u6267\u884c\u5176\u4e2d\u7684\u82e5\u5e72\u6761\u8981\u6c42\uff0c\u4f7f\u5f97\u574f\u7684\u7535\u8111\u6700\u7ec8\u4ea4\u6362\u5230 j \u53f7\u4f4d\u7f6e\u3002 \u7531\u4e8e\u9a97\u8fc7\u8001\u5e08\u5f88\u7d2f\uff0c\u8bf7\u5bf9\u4e8e j=1...n \u6c42\u51fa\u6700\u5c11\u53ef\u80fd\u7684\u4e0d\u6267\u884c\u8981\u6c42\u6761\u6570\uff0c\u4f7f\u5f97\u574f\u7684\u7535\u8111\u5728\u7b2c j \u4e2a\u4f4d\u7f6e\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_4","text":"\u672c\u9898\u6709\u591a\u7ec4\u6d4b\u8bd5\u6570\u636e\u3002 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6570 T \u8868\u793a\u4e00\u5171\u6709 T \u7ec4\u6570\u636e\u3002\u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u6570\u636e\uff1a \u7b2c\u4e00\u884c\u4e09\u4e2a\u6574\u6570 n,m,k \uff0c\u8868\u793a\u7535\u8111\u4e2a\u6570\uff0c\u603b\u64cd\u4f5c\u6b21\u6570\u548c\u574f\u7535\u8111\u7684\u521d\u59cb\u4f4d\u7f6e\u3002 \u4e0b\u9762 m \u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6b63\u6574\u6570 ui , vi \uff0c\u8868\u793a\u8fd9\u6b21\u64cd\u4f5c\u9009\u62e9\u7684\u4e24\u4e2a\u4f4d\u7f6e\u3002 \u6ee1\u8db3 1\u2264T\u22645\uff0c1\u2264n\u226410 5\uff0c0\u2264m\u226410 5\uff0c1\u2264k\u2264n\u3002","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_5","text":"\u5bf9\u6bcf\u7ec4\u6570\u636e\uff0c\u8f93\u51fa\u5171\u4e00\u884c n \u4e2a\u6574\u6570\uff0c\u7b2c i \u4e2a\u6574\u6570\u8868\u793a\u4f7f\u574f\u7535\u8111\u6700\u7ec8\u505c\u7559\u5728\u8be5\u4f4d\u7f6e\u6240\u9700\u7684\u6700\u5c11\u6697\u7bb1\u64cd\u4f5c\u6b21\u6570\u3002 \u82e5\u6700\u7ec8\u574f\u7535\u8111\u4e0d\u53ef\u80fd\u505c\u7559\u5728\u8be5\u4f4d\u7f6e\uff0c\u5219\u8f93\u51fa \u22121\u3002","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_6","text":"1 5 5 1 3 5 2 1 4 1 3 1 3 1","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_7","text":"2 0 3 1 -1","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_8","text":"\u52a8\u6001\u89c4\u5212\uff0c\u5f53\u8981\u6c42\u8f6c\u79fbu\u548cv\u65f6\uff1a dp[i][u]=min(dp[i-1][u]+1,dp[i-1][v]); dp[i][v]=min(dp[i-1][v]+1,dp[i-1][u]);","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_9","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll dp [ 200500 ] = { 0 }; int main () { // freopen(\"in.txt\",\"r\",stdin); // freopen(\"out.txt\",\"w\",stdout); ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , m , k ; scanf ( \"%lld%lld%lld\" , & n , & m , & k ); for ( ll i = 1 ; i <= n ; i ++ ) dp [ i ] = inf ; dp [ k ] = 0 ; ll u , v ; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld%lld\" , & u , & v ); ll tmpv = min ( dp [ v ] + 1 , dp [ u ]); ll tmpu = min ( dp [ u ] + 1 , dp [ v ]); dp [ v ] = tmpv ; dp [ u ] = tmpu ; } for ( ll i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] == inf ) { if ( i != n ) printf ( \"-1 \" ); else printf ( \"-1\" ); } else { if ( i != n ) printf ( \"%lld \" , dp [ i ]); else printf ( \"%lld\" , dp [ i ]); } } printf ( \" \\n \" ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_10","text":"\u8ff7\u5931","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_11","text":"\u5c0f T \u8ff7\u5931\u5728\u4e86\u4e00\u4e2a\u6709 n \u4e2a\u70b9\u7684\u7fa4\u5c9b\u4e0a\u3002 \u521d\u59cb\u65f6\u4ed6\u5728 1 \u53f7\u5c9b\uff0c\u4ed6\u8981\u901a\u8fc7\u67b6\u5728\u5c9b\u95f4\u7684 m \u5ea7\u53cc\u5411\u6865\uff0c\u5728\u6b63\u597d\u8fc7 k \u5ea7\u6865\u65f6\u8fbe\u5230 n \u53f7\u5c9b\u7684\u5927\u95e8\u3002 \u8fd9\u4e9b\u6865\u4e2d\u6709\u82e5\u5e72\u5ea7\u9644\u9b54\u6865\u3002\u5f53\u5c0f T \u7ecf\u8fc7\u4e00\u5ea7\u9644\u9b54\u6865\u65f6\uff0c\u5982\u679c\u4ed6\u8eab\u4e0a\u6ca1\u6709\u9644\u9b54\u6807\u8bb0\u5219\u88ab\u6807\u8bb0\uff0c\u5982\u679c\u4ed6\u8eab\u4e0a\u5df2\u6709\u9644\u9b54\u6807\u8bb0\u5219\u6807\u8bb0\u6d88\u5931\u3002 \u5927\u95e8\u53ea\u4f1a\u5728\u4ed6\u8eab\u4e0a\u6709\u9644\u9b54\u6807\u8bb0\u65f6\u624d\u4f1a\u5f00\u542f\uff0c\u53ea\u6709\u8fd9\u6837\u4ed6\u624d\u80fd\u9003\u79bb\u3002 \u5c0f T \u8ff7\u5931\u5728\u4e86\u7fa4\u5c9b\u4e4b\u95f4\uff0c\u4ed6\u6bcf\u6b21\u4f1a\u7b49\u6982\u7387\u968f\u673a\u6311\u9009\u4e00\u5ea7\u4e0e\u4ed6\u6240\u5728\u5c9b\u5c7f\u76f8\u8fde\u7684\u6865\u8d70\u3002\u5c0f T \u5411\u4f60\u8be2\u95ee\u4ed6\u80fd\u9003\u79bb\u7684\u6982\u7387\u3002 \u4fdd\u8bc1\u56fe\u65e0\u81ea\u73af\u65e0\u91cd\u8fb9\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_12","text":"\u7b2c\u4e00\u884c\u4e00\u4e2a\u6570 T \u8868\u793a\u4e00\u5171\u6709 T \u7ec4\u6570\u636e\u3002\u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u6570\u636e\uff1a \u7b2c\u4e00\u884c\u4e09\u4e2a\u6b63\u6574\u6570 n\uff0cm\uff0ck\u3002 \u6b64\u540e m \u884c\uff0c\u6bcf\u884c\u4e09\u4e2a\u6570 ui\uff0cvi\uff0cwi \uff0c\u8868\u793a\u4e00\u5ea7\u4ece ui \u5230 vi \u7684\u6865\u3002\u82e5 wi=1 \u5219\u8be5\u6865\u662f\u9644\u9b54\u6865\uff0c\u5426\u5219\uff08wi=0\uff09\u662f\u666e\u901a\u6865\u3002 \u4fdd\u8bc1\u65e0\u81ea\u73af\u65e0\u91cd\u8fb9\uff0cT\u226410\uff0c1\u2264ui,vi\u2264n\uff0cwi \u4e3a 0 \u5230 1 \u7684\u6574\u6570\uff0c\u6ee1\u8db3 2\u2264n\u2264100\uff0c1\u2264m\u2264n\u00d7(n\u22121)/2\uff0c1\u2264k\u226410^6\u3002","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_13","text":"\u8f93\u51fa\u4e00\u5171 T \u884c\u3002\u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u6570\u636e\uff0c\u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570\uff1a\u4ed6\u80fd\u9003\u79bb\u7684\u6982\u7387\u5bf9 998244353 \u7684\u6a21\u3002","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_14","text":"2 4 4 2 1 2 1 2 4 0 1 3 0 3 4 0 6 7 2 1 2 0 1 3 1 1 4 1 2 5 0 3 5 0 3 6 0 4 6 0","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_15","text":"748683265 610038216","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_16","text":"\u7b2c\u4e00\u7ec4\u6570\u636e \u4ece 1 1 \u8d70\u5230 n n \u5e76\u4e14\u7ecf\u8fc7\u4e00\u6761\u9644\u9b54\u8fb9\u7684\u6982\u7387\u4e3a 1/4 1/4 \uff0c\u5bf9 998244353 998244353 \u53d6\u6a21\u540e\u4e3a 748683265 748683265 \u3002 \u7b2c\u4e8c\u7ec4\u6570\u636e \u6982\u7387\u4e3a 5/18 5/18 \uff0c\u5bf9 998244353 998244353 \u53d6\u6a21\u540e\u4e3a 610038216 610038216 \u200b\u3002","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_17","text":"\u77e9\u9635\u5feb\u901f\u5e42\uff0c\u901a\u8fc7\u6784\u9020\u90bb\u63a5\u77e9\u9635\u505a\u4e58\u6cd5\u5e42\u8fd0\u7b97\u7684\u65b9\u5f0f\u8ba1\u7b97\u51fa\u6700\u7ec8\u7684\u6982\u7387\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_18","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b % 2 ) ans1 = ( ans2 * ans1 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } ll a [ 400 ][ 400 ] = { 0 }; ll ans1 [ 400 ][ 400 ] = { 0 }; ll ans2 [ 400 ][ 400 ] = { 0 }; vector < pair < int , int >> v [ 400 ]; int n , m , k ; void cf ( ll a [ 400 ][ 400 ], ll b [ 400 ][ 400 ]) { ll c [ 400 ][ 400 ] = { 0 }; for ( ll i = 1 ; i <= 2 * n ; i ++ ) { for ( ll j = 1 ; j <= 2 * n ; j ++ ) { for ( ll k = 1 ; k <= 2 * n ; k ++ ) { c [ i ][ j ] += a [ i ][ k ] * b [ k ][ j ]; c [ i ][ j ] %= mod ; } } } for ( ll i = 1 ; i <= 2 * n ; i ++ ) { for ( ll j = 1 ; j <= 2 * n ; j ++ ) { a [ i ][ j ] = c [ i ][ j ]; a [ i ][ j ] %= mod ; } } } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d %d\" , & n , & m , & k ); memset ( a , 0 , sizeof ( a )); for ( int i = 1 ; i <= n ; i ++ ) v [ i ]. clear (); int from , to , val ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d %d %d\" , & from , & to , & val ); v [ from ]. push_back ({ to , val }); v [ to ]. push_back ({ from , val }); } for ( int i = 1 ; i <= n ; i ++ ) { ll tmp = ksm (( ll ) v [ i ]. size (), mod - 2 ); for ( int k = 0 ; k < v [ i ]. size (); k ++ ) { pair < int , int > j = v [ i ][ k ]; if ( j . second == 0 ) { a [ i * 2 - 1 ][ j . first * 2 - 1 ] = tmp ; a [ i * 2 ][ j . first * 2 ] = tmp ; } else { a [ i * 2 - 1 ][ j . first * 2 ] = tmp ; a [ i * 2 ][ j . first * 2 - 1 ] = tmp ; } } } for ( ll i = 1 ; i <= 2 * n ; i ++ ) { for ( ll j = 1 ; j <= 2 * n ; j ++ ) { ans1 [ i ][ j ] = a [ i ][ j ]; if ( i == j ) ans2 [ i ][ j ] = 1 ; else ans2 [ i ][ j ] = 0 ; } } while ( k != 0 ) { if ( k % 2 ) cf ( ans2 , ans1 ); cf ( ans1 , ans1 ); k /= 2 ; } printf ( \"%lld \\n \" , ans2 [ 1 ][ 2 * n ]); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_19","text":"https://ac.nowcoder.com/acm/contest/11256/K","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_20","text":"","title":"\u9898\u76ee"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_21","text":"\u7ef4\u62a4\u5355\u8c03\u5b50\u5e8f\u5217\uff0c\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u533a\u95f4\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/#_22","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 100500 ] = { 0 }; int main () { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); while ( m -- ) { ll k ; scanf ( \"%lld\" , & k ); deque < ll > que1 , que2 ; ///\u7ef4\u62a4\u9012\u589e\u5e8f\u5217\u548c\u9012\u51cf\u5e8f\u5217 ll ans = 0 , last = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { while ( ! que1 . empty () && a [ que1 . back ()] < a [ i ]) ///\u9012\u51cf que1 . pop_back (); que1 . push_back ( i ); while ( ! que2 . empty () && a [ que2 . back ()] > a [ i ]) ///\u9012\u589e que2 . pop_back (); que2 . push_back ( i ); while ( ! que1 . empty () && ! que2 . empty () && a [ que1 . front ()] - a [ que2 . front ()] > k ) { if ( que1 . front () < que2 . front ()) ans += ( n - que2 . front () + 1 ) * ( que1 . front () - last ), last = que1 . front (), que1 . pop_front (); else ans += ( n - que1 . front () + 1 ) * ( que2 . front () - last ), last = que2 . front (), que2 . pop_front (); } } printf ( \"%lld \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516b\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Grass Planting \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has N barren pastures (2 <= N <= 100,000) connected by N-1 bidirectional roads, such that there is exactly one path between any two pastures. Bessie, a cow who loves her grazing time, often complains about how there is no grass on the roads between pastures. Farmer John loves Bessie very much, and today he is finally going to plant grass on the roads. He will do so using a procedure consisting of M steps (1 <= M <=100,000). At each step one of two things will happen: - FJ will choose two pastures, and plant a patch of grass along each road in between the two pastures, or, - Bessie will ask about how many patches of grass on a particular road, and Farmer John must answer her question. Farmer John is a very poor counter -- help him answer Bessie's questions! \u8f93\u5165 \u00b6 Line 1: Two space-separated integers N and M Lines 2..N: Two space-separated integers describing the endpoints of a road. Lines N+1..N+M: Line i+1 describes step i. The first character of the line is either P or Q, which describes whether or not FJ is planting grass or simply querying. This is followed by two space-separated integers A_i and B_i (1 <= A_i, B_i <= N) which describe FJ's action or query. \u8f93\u51fa \u00b6 Lines 1..???: Each line has the answer to a query, appearing in the same order as the queries appear in the input. \u6837\u4f8b\u8f93\u5165 \u00b6 4 6 1 4 2 4 3 4 P 2 3 P 1 3 Q 3 4 P 1 4 Q 2 4 Q 1 4 \u6837\u4f8b\u8f93\u51fa \u00b6 2 1 2 \u9898\u89e3 \u00b6 \u6811\u94fe\u5256\u5206\uff0c\u5c06\u6811\u8fdb\u884c\u8fb9\u5256\u5206\u5229\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://oi-wiki.org/graph/hld/#_4 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll sum [ 400500 ] = { 0 }, lazy [ 400500 ] = { 0 }; ll dep [ 200500 ] = { 0 }, size1 [ 200500 ] = { 0 }, son [ 200500 ] = { 0 }, f [ 200500 ] = { 0 }, id [ 200500 ] = { 0 }, top [ 200500 ] = { 0 }; struct node { ll to , next ; }; node edge [ 400500 ] = { 0 }; ll head [ 400500 ] = { 0 }; ll num = 0 , cnt = 0 ; void add_edge ( ll from , ll to ) { edge [ ++ num ] = { to , head [ from ]}; head [ from ] = num ; } void dfs1 ( ll now , ll fa ) { size1 [ now ] = 1 ; for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == fa ) continue ; f [ to ] = now ; dep [ to ] = dep [ now ] + 1 ; dfs1 ( to , now ); size1 [ now ] += size1 [ to ]; if ( size1 [ to ] > size1 [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( ll now , ll fa ) { id [ now ] = ++ cnt ; top [ now ] = fa ; if ( son [ now ]) dfs2 ( son [ now ], fa ); for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == f [ now ] || to == son [ now ]) continue ; dfs2 ( to , to ); } } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t + 1 ] += lazy [ t ]; lazy [ 2 * t ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += ( mid - l + 1 ) * lazy [ t ]; sum [ 2 * t + 1 ] += ( r - mid ) * lazy [ t ]; lazy [ t ] = 0 ; } void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { lazy [ t ] += add ; sum [ t ] += add * ( R - L + 1 ); return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query ( ll t , ll l , ll r , ll L , ll R ) { if ( l <= L && R <= r ) return sum [ t ]; push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; ll ans = 0 ; if ( l <= mid ) ans += query ( 2 * t , l , r , L , mid ); if ( mid < r ) ans += query ( 2 * t + 1 , l , r , mid + 1 , R ); return ans ; } void update_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ]; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); update ( 1 , id [ fx ], id [ x ], 1 , cnt , 1 ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); update ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt , 1 ); } ll query_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ], ans = 0 ; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); ans += query ( 1 , id [ fx ], id [ x ], 1 , cnt ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); ans += query ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt ); return ans ; } int main () { ll n , m , from , to ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } f [ 1 ] = 0 , dep [ 1 ] = 1 ; dfs1 ( 1 , 0 ), dfs2 ( 1 , 1 ); char c [ 10 ]; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , c + 1 , & from , & to ); if ( c [ 1 ] == 'P' ) update_chain ( from , to ); else printf ( \"%lld \\n \" , query_chain ( from , to )); } }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516b\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516b\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_2","text":"Grass Planting","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_3","text":"Farmer John has N barren pastures (2 <= N <= 100,000) connected by N-1 bidirectional roads, such that there is exactly one path between any two pastures. Bessie, a cow who loves her grazing time, often complains about how there is no grass on the roads between pastures. Farmer John loves Bessie very much, and today he is finally going to plant grass on the roads. He will do so using a procedure consisting of M steps (1 <= M <=100,000). At each step one of two things will happen: - FJ will choose two pastures, and plant a patch of grass along each road in between the two pastures, or, - Bessie will ask about how many patches of grass on a particular road, and Farmer John must answer her question. Farmer John is a very poor counter -- help him answer Bessie's questions!","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_4","text":"Line 1: Two space-separated integers N and M Lines 2..N: Two space-separated integers describing the endpoints of a road. Lines N+1..N+M: Line i+1 describes step i. The first character of the line is either P or Q, which describes whether or not FJ is planting grass or simply querying. This is followed by two space-separated integers A_i and B_i (1 <= A_i, B_i <= N) which describe FJ's action or query.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_5","text":"Lines 1..???: Each line has the answer to a query, appearing in the same order as the queries appear in the input.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_6","text":"4 6 1 4 2 4 3 4 P 2 3 P 1 3 Q 3 4 P 1 4 Q 2 4 Q 1 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_7","text":"2 1 2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_8","text":"\u6811\u94fe\u5256\u5206\uff0c\u5c06\u6811\u8fdb\u884c\u8fb9\u5256\u5206\u5229\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://oi-wiki.org/graph/hld/#_4","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AB%EF%BC%89/#_9","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll sum [ 400500 ] = { 0 }, lazy [ 400500 ] = { 0 }; ll dep [ 200500 ] = { 0 }, size1 [ 200500 ] = { 0 }, son [ 200500 ] = { 0 }, f [ 200500 ] = { 0 }, id [ 200500 ] = { 0 }, top [ 200500 ] = { 0 }; struct node { ll to , next ; }; node edge [ 400500 ] = { 0 }; ll head [ 400500 ] = { 0 }; ll num = 0 , cnt = 0 ; void add_edge ( ll from , ll to ) { edge [ ++ num ] = { to , head [ from ]}; head [ from ] = num ; } void dfs1 ( ll now , ll fa ) { size1 [ now ] = 1 ; for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == fa ) continue ; f [ to ] = now ; dep [ to ] = dep [ now ] + 1 ; dfs1 ( to , now ); size1 [ now ] += size1 [ to ]; if ( size1 [ to ] > size1 [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( ll now , ll fa ) { id [ now ] = ++ cnt ; top [ now ] = fa ; if ( son [ now ]) dfs2 ( son [ now ], fa ); for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == f [ now ] || to == son [ now ]) continue ; dfs2 ( to , to ); } } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t + 1 ] += lazy [ t ]; lazy [ 2 * t ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += ( mid - l + 1 ) * lazy [ t ]; sum [ 2 * t + 1 ] += ( r - mid ) * lazy [ t ]; lazy [ t ] = 0 ; } void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { lazy [ t ] += add ; sum [ t ] += add * ( R - L + 1 ); return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query ( ll t , ll l , ll r , ll L , ll R ) { if ( l <= L && R <= r ) return sum [ t ]; push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; ll ans = 0 ; if ( l <= mid ) ans += query ( 2 * t , l , r , L , mid ); if ( mid < r ) ans += query ( 2 * t + 1 , l , r , mid + 1 , R ); return ans ; } void update_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ]; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); update ( 1 , id [ fx ], id [ x ], 1 , cnt , 1 ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); update ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt , 1 ); } ll query_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ], ans = 0 ; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); ans += query ( 1 , id [ fx ], id [ x ], 1 , cnt ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); ans += query ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt ); return ans ; } int main () { ll n , m , from , to ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } f [ 1 ] = 0 , dep [ 1 ] = 1 ; dfs1 ( 1 , 0 ), dfs2 ( 1 , 1 ); char c [ 10 ]; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , c + 1 , & from , & to ); if ( c [ 1 ] == 'P' ) update_chain ( from , to ); else printf ( \"%lld \\n \" , query_chain ( from , to )); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516d\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Hopping Rabbit \u9898\u76ee \u00b6 \u9898\u89e3 \u00b6 \u626b\u63cf\u7ebf+\u7ebf\u6bb5\u6811\uff0c\u5c06\u9677\u9631\u533a\u57df\u6620\u5c04\u5230(0,0)-(d-1,d-1)\u7684\u77e9\u5f62\u5f53\u4e2d\uff0c\u53ea\u8981\u67e5\u627e\u77e9\u5f62\u4e2d\u4e3a\u88ab\u9677\u9631\u8986\u76d6\u7684\u90e8\u5206\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <stdio.h> #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll n , d ; ll num [ 200500 ] = { 0 }; ll lazy [ 800500 ] = { 0 }; ll min1 [ 800500 ] = { 0 }; void push_up ( ll t ) { min1 [ t ] = min ( min1 [ 2 * t ], min1 [ 2 * t + 1 ]); } void push_down ( ll t ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t ] += lazy [ t ]; lazy [ 2 * t + 1 ] += lazy [ t ]; min1 [ 2 * t ] += lazy [ t ]; min1 [ 2 * t + 1 ] += lazy [ t ]; lazy [ t ] = 0 ; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( l <= L && r >= R ) { min1 [ t ] += add ; lazy [ t ] += add ; return ; } push_down ( t ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query_pos ( ll t , ll l , ll r ) { if ( l == r ) return l ; ll mid = ( l + r ) / 2 ; push_down ( t ); if ( min1 [ 2 * t ] == 0 ) return query_pos ( 2 * t , l , mid ); else return query_pos ( 2 * t + 1 , mid + 1 , r ); } struct node { ll l , r ; }; vector < node > v1 [ 100500 ], v2 [ 100500 ]; void clc ( ll & x ) { x = ( x % d + d ) % d ; } void option1 ( ll x1 , ll y1 , ll x2 , ll y2 ) { if ( x1 >= x2 || y1 >= y2 ) return ; v1 [ x1 ]. push_back ({ y1 + 1 , y2 }); v2 [ x2 ]. push_back ({ y1 + 1 , y2 }); } void option ( ll x1 , ll y1 , ll x2 , ll y2 ) { if ( y2 - y1 >= d ) { option1 ( x1 , 0 , x2 , d ); return ; } clc ( y1 ), clc ( y2 ); if ( y1 > y2 ) { option1 ( x1 , 0 , x2 , y2 ); option1 ( x1 , y1 , x2 , d ); return ; } else { option1 ( x1 , y1 , x2 , y2 ); return ; } } int main () { scanf ( \"%lld%lld\" , & n , & d ); for ( ll i = 1 ; i <= n ; i ++ ) { ll x1 , y1 , x2 , y2 ; scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); if ( x2 - x1 >= d ) { option ( 0 , y1 , d , y2 ); continue ; } clc ( x1 ), clc ( x2 ); if ( x1 > x2 ) { option ( 0 , y1 , x2 , y2 ); option ( x1 , y1 , d , y2 ); } else { option ( x1 , y1 , x2 , y2 ); } } for ( ll i = 0 ; i < d ; i ++ ) { for ( node x : v1 [ i ]) update ( 1 , x . l , x . r , 1 , d , 1 ); for ( node x : v2 [ i ]) update ( 1 , x . l , x . r , 1 , d , -1 ); if ( min1 [ 1 ] != 0 ) continue ; printf ( \"YES \\n %lld %lld \\n \" , i , query_pos ( 1 , 1 , d ) - 1 ); return 0 ; } printf ( \"NO \\n \" ); }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516d\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u516d\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/#_2","text":"Hopping Rabbit","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/#_3","text":"","title":"\u9898\u76ee"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/#_4","text":"\u626b\u63cf\u7ebf+\u7ebf\u6bb5\u6811\uff0c\u5c06\u9677\u9631\u533a\u57df\u6620\u5c04\u5230(0,0)-(d-1,d-1)\u7684\u77e9\u5f62\u5f53\u4e2d\uff0c\u53ea\u8981\u67e5\u627e\u77e9\u5f62\u4e2d\u4e3a\u88ab\u9677\u9631\u8986\u76d6\u7684\u90e8\u5206\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/#_5","text":"#include <stdio.h> #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; ll n , d ; ll num [ 200500 ] = { 0 }; ll lazy [ 800500 ] = { 0 }; ll min1 [ 800500 ] = { 0 }; void push_up ( ll t ) { min1 [ t ] = min ( min1 [ 2 * t ], min1 [ 2 * t + 1 ]); } void push_down ( ll t ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t ] += lazy [ t ]; lazy [ 2 * t + 1 ] += lazy [ t ]; min1 [ 2 * t ] += lazy [ t ]; min1 [ 2 * t + 1 ] += lazy [ t ]; lazy [ t ] = 0 ; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( l <= L && r >= R ) { min1 [ t ] += add ; lazy [ t ] += add ; return ; } push_down ( t ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query_pos ( ll t , ll l , ll r ) { if ( l == r ) return l ; ll mid = ( l + r ) / 2 ; push_down ( t ); if ( min1 [ 2 * t ] == 0 ) return query_pos ( 2 * t , l , mid ); else return query_pos ( 2 * t + 1 , mid + 1 , r ); } struct node { ll l , r ; }; vector < node > v1 [ 100500 ], v2 [ 100500 ]; void clc ( ll & x ) { x = ( x % d + d ) % d ; } void option1 ( ll x1 , ll y1 , ll x2 , ll y2 ) { if ( x1 >= x2 || y1 >= y2 ) return ; v1 [ x1 ]. push_back ({ y1 + 1 , y2 }); v2 [ x2 ]. push_back ({ y1 + 1 , y2 }); } void option ( ll x1 , ll y1 , ll x2 , ll y2 ) { if ( y2 - y1 >= d ) { option1 ( x1 , 0 , x2 , d ); return ; } clc ( y1 ), clc ( y2 ); if ( y1 > y2 ) { option1 ( x1 , 0 , x2 , y2 ); option1 ( x1 , y1 , x2 , d ); return ; } else { option1 ( x1 , y1 , x2 , y2 ); return ; } } int main () { scanf ( \"%lld%lld\" , & n , & d ); for ( ll i = 1 ; i <= n ; i ++ ) { ll x1 , y1 , x2 , y2 ; scanf ( \"%lld%lld%lld%lld\" , & x1 , & y1 , & x2 , & y2 ); if ( x2 - x1 >= d ) { option ( 0 , y1 , d , y2 ); continue ; } clc ( x1 ), clc ( x2 ); if ( x1 > x2 ) { option ( 0 , y1 , x2 , y2 ); option ( x1 , y1 , d , y2 ); } else { option ( x1 , y1 , x2 , y2 ); } } for ( ll i = 0 ; i < d ; i ++ ) { for ( node x : v1 [ i ]) update ( 1 , x . l , x . r , 1 , d , 1 ); for ( node x : v2 [ i ]) update ( 1 , x . l , x . r , 1 , d , -1 ); if ( min1 [ 1 ] != 0 ) continue ; printf ( \"YES \\n %lld %lld \\n \" , i , query_pos ( 1 , 1 , d ) - 1 ); return 0 ; } printf ( \"NO \\n \" ); }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e00\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Add or Multiply 1 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u6837\u4f8b\u8f93\u5165 \u00b6 3 2 1 5 5 100 100 \u6837\u4f8b\u8f93\u51fa \u00b6 4 329462 294770659 \u9898\u89e3 \u00b6 \u5c06+\u548c*\u5206\u522b\u8f6c\u6362\u4e3a\u767d\u7403\u548c\u9ed1\u7403\uff0c\u5c06\u9898\u76ee\u8f6c\u6362\u4e3an\u4e2a\u4e0d\u540c\u7684\u5c0f\u7403\u653e\u5230m\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u4e14\u4e0d\u4e3a\u7a7a\uff0c\u5373\u4e3a\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\uff0c\u8be6\u89c1\uff1a https://github.tim-wcx.ltd/#/icpc/?id=\u7ec4\u5408\u6570\u5b66 \uff0c\u7136\u540e\u679a\u4e3e\u767d\u8272\u5c0f\u7403\u76d2\u5b50\u6570\u76een\uff0c\u5219\u5bf9\u4e8e\u9ed1\u8272\u5c0f\u7403\uff0c\u6709\u4e09\u79cd\u5206\u6cd5\uff1an\u4e2a\u76d2\u5b50\uff0cn-1\u4e2a\u76d2\u5b50\u548cn+1\u4e2a\u76d2\u5b50\uff0c\u5bf9\u4e8e\u4e09\u79cd\u60c5\u51b5\u5206\u522b\u8ba1\u7b97\u6c42\u548c\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; ll dp [ 4000 ][ 4000 ] = { 0 }; ll jc [ 4000 ] = { 0 }; int main () { jc [ 0 ] = 1 ; for ( ll i = 1 ; i < 4000 ; i ++ ) { jc [ i ] = jc [ i - 1 ] * i % mod ; } dp [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i < 4000 ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { dp [ i ][ j ] = ( dp [ i -1 ][ j -1 ] + ( ll ) j * dp [ i -1 ][ j ] % mod ) % mod ; } } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); ll ans = 0 ; for ( ll i = 0 ; i <= max ( n , m ); i ++ ) { ll tmp1 = dp [ n ][ i ] * jc [ i ]; tmp1 %= mod ; ans += tmp1 * dp [ m ][ i - 1 ] % mod * jc [ i - 1 ] % mod ; ans %= mod ; ans += tmp1 * dp [ m ][ i ] % mod * jc [ i ] % mod * 2 % mod ; ans %= mod ; ans += tmp1 * dp [ m ][ i + 1 ] % mod * jc [ i + 1 ] % mod ; ans %= mod ; } printf ( \"%lld \\n \" , ans ); } } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u4ed3\u9889\u9020\u6570 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u9aa4\u98ce\u8d77\uff0c\u4ed3\u9889\u98d8\u98d8\u4e4e\u4e0d\u81ea\u89c9\u4e8e\u5b64\u5c9b\u7109\u3002\u5c9b\u65e0\u4eba\u8ff9\uff0c\u552f\u6709\u6709\u7406\u6570\u4e8c\u65cf\u5c14\u3002\u4e00\u65cf\u66f0\u7532\u5206\u4e4b\u4e59\uff0c \u4e00\u65cf\u66f0\u4e59\u5206\u4e4b\u7532\uff0c\u7532\u3001\u4e59\u7686\u6b63\u6574\u6570\u3002\u6570\u4e4b\uff0c\u5219\u65cf\u65cf\u4e0d\u7aed\u5176\u6570\u3002 \u9e66\u9e49\u8c13\u4ed3\u9889\uff1a\u201c\u65e5\u62e9\u4e8c\u6570\uff0c\u5408\u5176\u4e3a\u5e73\u5747\u6216\u8c03\u548c\u5e73\u5747\u3002\u9020\u5f97\u4e00\uff0c\u543e\u9001\u6c5d\u5f52\uff01\u201d \u4ed3\u9889\u80fd\u5f52\u4e8e\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d\u4ebf\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d\u4e07\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d\u65e5\u5426\uff1f \u4ed3\u9889\u88ab\u4e00\u9635\u98ce\u522e\u5230\u4e86\u4e00\u4e2a\u8352\u65e0\u4eba\u70df\u7684\u5c0f\u5c9b\u4e0a\uff0c\u90a3\u91cc\u6709\u4e24\u65cf\u6709\u7406\u6570\uff0cab\u548cba\uff0c\uff08a,b \u4e3a\u6b63\u6574\u6570\uff09\uff0c\u6bcf\u65cf\u6570\u6709\u65e0\u7a77\u591a\u4e2a\u3002 \u9e66\u9e49\u544a\u8bc9\u4ed3\u9889\uff1a\u201c\u6bcf\u5929\uff0c\u4f60\u53ef\u4ee5\u9009\u4e24\u4e2a\u5df2\u6709\u7684\u6570 x,y\uff0c\u5c06\u5b83\u4eec\u5408\u6210\u4e3a \\frac{x+y}{2} \\frac{x+y}{2} \u6216 \\frac{2x*y}{x+y} \\frac{2x*y}{x+y} \u3002\u5982\u679c\u4f60\u80fd\u5408\u6210 1\uff0c\u6211\u5c31\u9001\u4f60\u56de\u5bb6\uff01\u201d \u4ed3\u9889\u80fd\u5728 999999999999 \u5929\u5185\u56de\u5bb6\u5417\uff1f T \u7ec4\u6570\u636e\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570 T(1\u2264T\u2264400)\uff0c\u8868\u793a\u6570\u636e\u7ec4\u6570\u3002 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff1a \u8f93\u5165\u4e00\u884c\u4e24\u4e2a\u6574\u6570 a,b(1\u2264a,b\u2264 10^9 10^9 )\uff0c\u8868\u793a\u521d\u59cb\u7684\u6709\u7406\u6570\u4e3a \\frac{a}{b} \\frac{a}{b} \u548c \\frac{b}{a} \\frac{b}{a} \u3002 \u8f93\u51fa \u00b6 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff1a \u8f93\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 \u201cYes\u201d \u6216\u8005 \u201cNo\u201d\uff08\u5747\u4e0d\u542b\u5f15\u53f7\uff09\uff0c\u5206\u522b\u8868\u793a\u4ed3\u9889\u80fd\u6216\u8005\u4e0d\u80fd\u5728 999999999999 \u5929\u5185\u5408\u6210\u6570\u5b57 1\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 3 1 1 1 2 5 3 \u6837\u4f8b\u8f93\u51fa \u00b6 Yes No Yes \u9898\u89e3 \u00b6 \u89c4\u5f8b\u9898\uff0c\u7531\u4e8ea/b\u548cb/a\u662f\u4efb\u610f\u591a\u4e2a\u7684\uff0c\u53ef\u4ee5\u591a\u5199\u51e0\u9879\u627e\u627e\u89c4\u5f8b\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f #define inf1 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; map < ll , ll > mp ; int main () { ll sum = 1 ; for ( ll i = 1 ; i <= 40 ; i ++ ) { mp [ sum ] = 1 ; sum = sum * 2 ; } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll a , b ; scanf ( \"%lld%lld\" , & a , & b ); ll tmp = __gcd ( a , b ); a /= tmp , b /= tmp ; if ( a == b ) { puts ( \"Yes\" ); continue ; } if ( mp [ a + b ] && a % 2 == 1 && b % 2 == 1 ) puts ( \"Yes\" ); else puts ( \"No\" ); } } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 123 Triangle \u9898\u76ee\u63cf\u8ff0 \u00b6 Given is a sequence of N digits a1a2\u2026aN, where each element is 1, 2, or 3. Let xi,j defined as follows: \u00b7x_{1,j}:=a_j (1\u2264j\u2264N) \u00b7x_{1,j}:=a_j (1\u2264j\u2264N) \u00b7x_{i,j}:=|x_{i\u22121,j}\u2212x_{i\u22121,j+1}| (2\u2264i\u2264N and 1\u2264j\u2264N+1\u2212i) \u00b7x_{i,j}:=|x_{i\u22121,j}\u2212x_{i\u22121,j+1}| (2\u2264i\u2264N and 1\u2264j\u2264N+1\u2212i) Find xN,1. Constraints \u00b7 2\u2264N\u226410^6 2\u2264N\u226410^6 \u00b7ai=1,2,3 (1\u2264i\u2264N) \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N a1a2\u2026aN \u8f93\u51fa \u00b6 Print x_{N,1} x_{N,1} . \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 4 1231 \u3010\u6837\u4f8b2\u3011 10 2311312312 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 0 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca x1,1,x1,2,x1,3,x1,4 are respectively 1,2,3,1. x2,1,x2,2,x2,3 are respectively |1\u22122|=1,|2\u22123|=1,|3\u22121|=2. x3,1,x3,2 are respectively |1\u22121|=0,|1\u22122|=1. Finally, x4,1=|0\u22121|=1, so the answer is 1. \u9898\u89e3 \u00b6 \u51cf\u6cd5\u76f8\u5f53\u4e8e\u6a212\u52a0\uff0c\u5c06\u9898\u76ee\u8f6c\u53d8\u4e3a \u5373\u7edf\u8ba1\u6bcf\u4e00\u4f4d\u6570\u52a0\u4e86\u591a\u5c11\u6b21\uff0c\u901a\u8fc7\u89c2\u5bdf\uff0c\u6bcf\u4e00\u4f4d\u6570\u52a0 C_{i-1}^{n-1} C_{i-1}^{n-1} \uff0c\u5373\u5224\u65ad\u5947\u5076\u5373\u53ef\u3002 \u53c2\u8003\u535a\u5ba2\uff1a https://blog.csdn.net/weixin_45750972/article/details/105271373 https://blog.csdn.net/weixin_45750972/article/details/105272194 https://www.cnblogs.com/Willems/p/12552885.html \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; int b [ 10 ] = { 0 }; char a [ 1005000 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , a + 1 ); int f1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] -- ; ///\u7531\u4e8en>=2\uff0c123\u7b49\u4ef7\u4e8e012\u8ba1\u7b97 if ( a [ i ] == '1' ) f1 = 1 ; b [ a [ i ] - '0' ] += ( int )((( n - 1 ) & ( i - 1 )) == ( i - 1 )); } if ( b [ 1 ] & 1 ) puts ( \"1\" ); else if ( f1 == 0 && ( b [ 2 ] & 1 )) puts ( \"2\" ); else puts ( \"0\" ); }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e00\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e00\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_2","text":"Add or Multiply 1","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_3","text":"","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_4","text":"3 2 1 5 5 100 100","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_5","text":"4 329462 294770659","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_6","text":"\u5c06+\u548c*\u5206\u522b\u8f6c\u6362\u4e3a\u767d\u7403\u548c\u9ed1\u7403\uff0c\u5c06\u9898\u76ee\u8f6c\u6362\u4e3an\u4e2a\u4e0d\u540c\u7684\u5c0f\u7403\u653e\u5230m\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u4e14\u4e0d\u4e3a\u7a7a\uff0c\u5373\u4e3a\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\uff0c\u8be6\u89c1\uff1a https://github.tim-wcx.ltd/#/icpc/?id=\u7ec4\u5408\u6570\u5b66 \uff0c\u7136\u540e\u679a\u4e3e\u767d\u8272\u5c0f\u7403\u76d2\u5b50\u6570\u76een\uff0c\u5219\u5bf9\u4e8e\u9ed1\u8272\u5c0f\u7403\uff0c\u6709\u4e09\u79cd\u5206\u6cd5\uff1an\u4e2a\u76d2\u5b50\uff0cn-1\u4e2a\u76d2\u5b50\u548cn+1\u4e2a\u76d2\u5b50\uff0c\u5bf9\u4e8e\u4e09\u79cd\u60c5\u51b5\u5206\u522b\u8ba1\u7b97\u6c42\u548c\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_7","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; ll dp [ 4000 ][ 4000 ] = { 0 }; ll jc [ 4000 ] = { 0 }; int main () { jc [ 0 ] = 1 ; for ( ll i = 1 ; i < 4000 ; i ++ ) { jc [ i ] = jc [ i - 1 ] * i % mod ; } dp [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i < 4000 ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { dp [ i ][ j ] = ( dp [ i -1 ][ j -1 ] + ( ll ) j * dp [ i -1 ][ j ] % mod ) % mod ; } } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); ll ans = 0 ; for ( ll i = 0 ; i <= max ( n , m ); i ++ ) { ll tmp1 = dp [ n ][ i ] * jc [ i ]; tmp1 %= mod ; ans += tmp1 * dp [ m ][ i - 1 ] % mod * jc [ i - 1 ] % mod ; ans %= mod ; ans += tmp1 * dp [ m ][ i ] % mod * jc [ i ] % mod * 2 % mod ; ans %= mod ; ans += tmp1 * dp [ m ][ i + 1 ] % mod * jc [ i + 1 ] % mod ; ans %= mod ; } printf ( \"%lld \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_8","text":"\u4ed3\u9889\u9020\u6570","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_9","text":"\u9aa4\u98ce\u8d77\uff0c\u4ed3\u9889\u98d8\u98d8\u4e4e\u4e0d\u81ea\u89c9\u4e8e\u5b64\u5c9b\u7109\u3002\u5c9b\u65e0\u4eba\u8ff9\uff0c\u552f\u6709\u6709\u7406\u6570\u4e8c\u65cf\u5c14\u3002\u4e00\u65cf\u66f0\u7532\u5206\u4e4b\u4e59\uff0c \u4e00\u65cf\u66f0\u4e59\u5206\u4e4b\u7532\uff0c\u7532\u3001\u4e59\u7686\u6b63\u6574\u6570\u3002\u6570\u4e4b\uff0c\u5219\u65cf\u65cf\u4e0d\u7aed\u5176\u6570\u3002 \u9e66\u9e49\u8c13\u4ed3\u9889\uff1a\u201c\u65e5\u62e9\u4e8c\u6570\uff0c\u5408\u5176\u4e3a\u5e73\u5747\u6216\u8c03\u548c\u5e73\u5747\u3002\u9020\u5f97\u4e00\uff0c\u543e\u9001\u6c5d\u5f52\uff01\u201d \u4ed3\u9889\u80fd\u5f52\u4e8e\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d\u4ebf\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d\u4e07\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d\u65e5\u5426\uff1f \u4ed3\u9889\u88ab\u4e00\u9635\u98ce\u522e\u5230\u4e86\u4e00\u4e2a\u8352\u65e0\u4eba\u70df\u7684\u5c0f\u5c9b\u4e0a\uff0c\u90a3\u91cc\u6709\u4e24\u65cf\u6709\u7406\u6570\uff0cab\u548cba\uff0c\uff08a,b \u4e3a\u6b63\u6574\u6570\uff09\uff0c\u6bcf\u65cf\u6570\u6709\u65e0\u7a77\u591a\u4e2a\u3002 \u9e66\u9e49\u544a\u8bc9\u4ed3\u9889\uff1a\u201c\u6bcf\u5929\uff0c\u4f60\u53ef\u4ee5\u9009\u4e24\u4e2a\u5df2\u6709\u7684\u6570 x,y\uff0c\u5c06\u5b83\u4eec\u5408\u6210\u4e3a \\frac{x+y}{2} \\frac{x+y}{2} \u6216 \\frac{2x*y}{x+y} \\frac{2x*y}{x+y} \u3002\u5982\u679c\u4f60\u80fd\u5408\u6210 1\uff0c\u6211\u5c31\u9001\u4f60\u56de\u5bb6\uff01\u201d \u4ed3\u9889\u80fd\u5728 999999999999 \u5929\u5185\u56de\u5bb6\u5417\uff1f T \u7ec4\u6570\u636e\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_10","text":"\u7b2c\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570 T(1\u2264T\u2264400)\uff0c\u8868\u793a\u6570\u636e\u7ec4\u6570\u3002 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff1a \u8f93\u5165\u4e00\u884c\u4e24\u4e2a\u6574\u6570 a,b(1\u2264a,b\u2264 10^9 10^9 )\uff0c\u8868\u793a\u521d\u59cb\u7684\u6709\u7406\u6570\u4e3a \\frac{a}{b} \\frac{a}{b} \u548c \\frac{b}{a} \\frac{b}{a} \u3002","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_11","text":"\u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff1a \u8f93\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 \u201cYes\u201d \u6216\u8005 \u201cNo\u201d\uff08\u5747\u4e0d\u542b\u5f15\u53f7\uff09\uff0c\u5206\u522b\u8868\u793a\u4ed3\u9889\u80fd\u6216\u8005\u4e0d\u80fd\u5728 999999999999 \u5929\u5185\u5408\u6210\u6570\u5b57 1\u3002","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_12","text":"3 1 1 1 2 5 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_13","text":"Yes No Yes","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_14","text":"\u89c4\u5f8b\u9898\uff0c\u7531\u4e8ea/b\u548cb/a\u662f\u4efb\u610f\u591a\u4e2a\u7684\uff0c\u53ef\u4ee5\u591a\u5199\u51e0\u9879\u627e\u627e\u89c4\u5f8b\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_15","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f #define inf1 0x3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; map < ll , ll > mp ; int main () { ll sum = 1 ; for ( ll i = 1 ; i <= 40 ; i ++ ) { mp [ sum ] = 1 ; sum = sum * 2 ; } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll a , b ; scanf ( \"%lld%lld\" , & a , & b ); ll tmp = __gcd ( a , b ); a /= tmp , b /= tmp ; if ( a == b ) { puts ( \"Yes\" ); continue ; } if ( mp [ a + b ] && a % 2 == 1 && b % 2 == 1 ) puts ( \"Yes\" ); else puts ( \"No\" ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_16","text":"123 Triangle","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_17","text":"Given is a sequence of N digits a1a2\u2026aN, where each element is 1, 2, or 3. Let xi,j defined as follows: \u00b7x_{1,j}:=a_j (1\u2264j\u2264N) \u00b7x_{1,j}:=a_j (1\u2264j\u2264N) \u00b7x_{i,j}:=|x_{i\u22121,j}\u2212x_{i\u22121,j+1}| (2\u2264i\u2264N and 1\u2264j\u2264N+1\u2212i) \u00b7x_{i,j}:=|x_{i\u22121,j}\u2212x_{i\u22121,j+1}| (2\u2264i\u2264N and 1\u2264j\u2264N+1\u2212i) Find xN,1. Constraints \u00b7 2\u2264N\u226410^6 2\u2264N\u226410^6 \u00b7ai=1,2,3 (1\u2264i\u2264N)","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_18","text":"Input is given from Standard Input in the following format: N a1a2\u2026aN","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_19","text":"Print x_{N,1} x_{N,1} .","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_20","text":"\u3010\u6837\u4f8b1\u3011 4 1231 \u3010\u6837\u4f8b2\u3011 10 2311312312","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_21","text":"\u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 0","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_22","text":"\u6837\u4f8b1\u89e3\u91ca x1,1,x1,2,x1,3,x1,4 are respectively 1,2,3,1. x2,1,x2,2,x2,3 are respectively |1\u22122|=1,|2\u22123|=1,|3\u22121|=2. x3,1,x3,2 are respectively |1\u22121|=0,|1\u22122|=1. Finally, x4,1=|0\u22121|=1, so the answer is 1.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_23","text":"\u51cf\u6cd5\u76f8\u5f53\u4e8e\u6a212\u52a0\uff0c\u5c06\u9898\u76ee\u8f6c\u53d8\u4e3a \u5373\u7edf\u8ba1\u6bcf\u4e00\u4f4d\u6570\u52a0\u4e86\u591a\u5c11\u6b21\uff0c\u901a\u8fc7\u89c2\u5bdf\uff0c\u6bcf\u4e00\u4f4d\u6570\u52a0 C_{i-1}^{n-1} C_{i-1}^{n-1} \uff0c\u5373\u5224\u65ad\u5947\u5076\u5373\u53ef\u3002 \u53c2\u8003\u535a\u5ba2\uff1a https://blog.csdn.net/weixin_45750972/article/details/105271373 https://blog.csdn.net/weixin_45750972/article/details/105272194 https://www.cnblogs.com/Willems/p/12552885.html","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/#_24","text":"#include <bits/stdc++.h> using namespace std ; int b [ 10 ] = { 0 }; char a [ 1005000 ] = { 0 }; int main () { int n ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , a + 1 ); int f1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] -- ; ///\u7531\u4e8en>=2\uff0c123\u7b49\u4ef7\u4e8e012\u8ba1\u7b97 if ( a [ i ] == '1' ) f1 = 1 ; b [ a [ i ] - '0' ] += ( int )((( n - 1 ) & ( i - 1 )) == ( i - 1 )); } if ( b [ 1 ] & 1 ) puts ( \"1\" ); else if ( f1 == 0 && ( b [ 2 ] & 1 )) puts ( \"2\" ); else puts ( \"0\" ); }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e09\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Nuske vs Phantom Thnook \u9898\u76ee\u63cf\u8ff0 \u00b6 Nuske has a grid with N rows and M columns of squares. The rows are numbered 1 through N from top to bottom, and the columns are numbered 1 through M from left to right. Each square in the grid is painted in either blue or white. If S_{i,j} S_{i,j} is 1, the square at the i-th row and j-th column is blue; if S_{i,j} S_{i,j} is 0, the square is white. For every pair of two blue square a and b, there is at most one path that starts from a, repeatedly proceeds to an adjacent (side by side) blue square and finally reaches b, without traversing the same square more than once. Phantom Thnook, Nuske's eternal rival, gives Q queries to Nuske. The i-th query consists of four integers x_{i,1} x_{i,1} , y_{i,1} y_{i,1} , x_{i,2} x_{i,2} and y_{i,2} y_{i,2} and asks him the following: when the rectangular region of the grid bounded by (and including) the xi,1-th row, xi,2-th row, yi,1-th column and yi,2-th column is cut out, how many connected components consisting of blue squares there are in the region? Process all the queries. Constraints 1\u2264N,M\u22642000 1\u2264Q\u2264200000 Si,j is either 0 or 1. Si,j satisfies the condition explained in the statement. 1\u2264 x_{i,1} x_{i,1} \u2264 x_{i,2} x_{i,2} \u2264N(1\u2264i\u2264Q) 1\u2264 y_{i,1} y_{i,1} \u2264 y_{i,2} y_{i,2} \u2264M(1\u2264i\u2264Q) \u8f93\u5165 \u00b6 The input is given from Standard Input in the following format: N M Q S1,1..S1,M : SN,1..SN,M x1,1 yi,1 xi,2 yi,2 : xQ,1 yQ,1 xQ,2 yQ,2 \u8f93\u51fa \u00b6 For each query, print the number of the connected components consisting of blue squares in the region. \u6837\u4f8b\u8f93\u5165 \u00b6 3 4 4 1101 0110 1101 1 1 3 4 1 1 3 1 2 2 3 4 1 2 2 4 \u6837\u4f8b\u8f93\u51fa \u00b6 3 2 2 2 \u63d0\u793a \u00b6 In the first query, the whole grid is specified. There are three components consisting of blue squares, and thus 3 should be printed. In the second query, the region within the red frame is specified. There are two components consisting of blue squares, and thus 2 should be printed. Note that squares that belong to the same component in the original grid may belong to different components. \u9898\u89e3 \u00b6 \u524d\u7f00\u548c\u4ee5\u53ca\u6811\u7684\u6027\u8d28\uff0c\u68ee\u6797\u7684\u4e2a\u6570\u7b49\u4e8e\u70b9\u7684\u4e2a\u6570\u51cf\u53bb\u8fb9\u7684\u6570\u76ee\uff0c\u7528\u524d\u7f00\u548c\u7ef4\u62a4\u8fb9\u7684\u6570\u76ee\u548c\u70b9\u7684\u6570\u76ee\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; char a [ 2050 ][ 2050 ] = { 0 }; int qzh [ 2050 ][ 2050 ] = { 0 }; int qzl [ 2050 ][ 2050 ] = { 0 }; int sum [ 2050 ][ 2050 ] = { 0 }; int main () { int n , m , q ; scanf ( \"%d%d%d\" , & n , & m , & q ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { sum [ i ][ j ] = - sum [ i - 1 ][ j - 1 ] + sum [ i ][ j - 1 ] + sum [ i - 1 ][ j ] + a [ i ][ j ] - '0' ; if ( a [ i ][ j ] == '1' ) { int tmp1 = 0 , tmp2 = 0 ; if ( a [ i - 1 ][ j ] == '1' ) tmp2 ++ ; if ( a [ i ][ j - 1 ] == '1' ) tmp1 ++ ; qzh [ i ][ j ] = - qzh [ i - 1 ][ j - 1 ] + qzh [ i ][ j - 1 ] + qzh [ i - 1 ][ j ] + tmp1 ; qzl [ i ][ j ] = - qzl [ i - 1 ][ j - 1 ] + qzl [ i ][ j - 1 ] + qzl [ i - 1 ][ j ] + tmp2 ; } else { qzh [ i ][ j ] = - qzh [ i - 1 ][ j - 1 ] + qzh [ i ][ j - 1 ] + qzh [ i - 1 ][ j ]; qzl [ i ][ j ] = - qzl [ i - 1 ][ j - 1 ] + qzl [ i ][ j - 1 ] + qzl [ i - 1 ][ j ]; } } } while ( q -- ) { int x1 , y1 , x2 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & y1 , & x2 , & y2 ); int ans = sum [ x2 ][ y2 ] - sum [ x1 - 1 ][ y2 ] - sum [ x2 ][ y1 - 1 ] + sum [ x1 - 1 ][ y1 - 1 ]; ans = ans - ( qzh [ x2 ][ y2 ] - qzh [ x1 - 1 ][ y2 ] - qzh [ x2 ][ y1 ] + qzh [ x1 - 1 ][ y1 ]); ans = ans - ( qzl [ x2 ][ y2 ] - qzl [ x1 ][ y2 ] - qzl [ x2 ][ y1 - 1 ] + qzl [ x1 ][ y1 - 1 ]); printf ( \"%d \\n \" , ans ); } } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 A or...or B Problem \u9898\u76ee\u63cf\u8ff0 \u00b6 Nukes has an integer that can be represented as the bitwise OR of one or more integers between A and B (inclusive). How many possible candidates of the value of Nukes's integer there are? Constraints 1\u2264A\u2264B< 2^{60} 2^{60} A and B are integers. \u8f93\u5165 \u00b6 The input is given from Standard Input in the following format: A B \u8f93\u51fa \u00b6 Print the number of possible candidates of the value of Nukes's integer. \u6837\u4f8b\u8f93\u5165 \u00b6 7 9 \u6837\u4f8b\u8f93\u51fa \u00b6 4 \u63d0\u793a \u00b6 In this case, A=7 and B=9. There are four integers that can be represented as the bitwise OR of a non-empty subset of {7, 8, 9}: 7, 8, 9 and 15. \u9898\u89e3 \u00b6 \u5047\u8bbeA\uff0cB\u4e24\u4e2a\u6570\u7684\u4e8c\u8fdb\u5236\u5982\u4e0b\uff1a A\uff1axxxxxx..0***** B\uff1axxxxxx..10----- \u5219\uff1a C\uff1axxxxxx..011111 D\uff1axxxxxx..100000 C\u548cD\u4e00\u5b9a\u6ee1\u8db3A<=C<=D<=B \u5219\uff1a E\uff1axxxxxx..1***** F\uff1axxxxxx..111111 G\uff1axxxxxx..100111 \u5176\u4e2d [E,F] [E,F] \u53ef\u4ee5\u7531 [A,C] [A,C] \u548cD\u6216\u8fd0\u7b97\u5f97\u5230\uff0c [D,G] [D,G] \u53ef\u4ee5\u7531 [D,B] [D,B] \u6216\u8fd0\u7b97\u5f97\u5230\uff0c\u6240\u4ee5\u7b54\u6848\u5373\u4e3a [A,G]\\cup[E,F] [A,G]\\cup[E,F] \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll a , b ; cin >> a >> b ; if ( a > b ) swap ( a , b ); ll tmp = b , aa = a ; for ( ll i = 60 ; i >= 0 ; i -- ) { if ((( a ^ b ) >> i ) & 1 ) { for ( ll j = i - 1 ; j >= 0 ; j -- ) tmp |= ( 1l l << j ); ///\u7b49\u6548\u4e8exxxxx..111111 a |= ( 1l l << i ); ///\u7b49\u6548\u4e8exxxxx..1***** for ( i -- ; i >= 0 && ! (( b >> i ) & 1 ); i -- ) ; for (; i >= 0 ; i -- ) b |= ( 1l l << i ); ///\u7b49\u6548\u4e8exxxxx..100111 break ; } } ll ans = 0 ; if ( b >= a ) ans = tmp - aa + 1 ; else ans = tmp - a + 1 + b - aa + 1 ; cout << ans << endl ; } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u62a2\u5360\u57ce\u5821 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u51ac\u51ac\u6b63\u548c\u4ed6\u7684\u670b\u53cb\u4e00\u8d77\u73a9\u62a2\u5360\u57ce\u5821\u7684\u6e38\u620f\uff0c\u8be5\u6e38\u620f\u53ef\u4ee5\u8868\u793a\u4e3a\u5927\u5c0f\u4e3an\u00d7m\u7684\u7f51\u683c\uff0c\u6bcf\u4e2a\u683c\u5b50\u6700\u591a\u53ea\u80fd\u5bb9\u4e0b\u4e00\u5ea7\u57ce\u5821\uff0c\u6bcf\u4e2a\u683c\u5b50\u6709\u4e09\u79cd\u72b6\u6001\uff1a 1\u3001\u7a7a\u57ce\u5821\u7528\u201c.\u201d\u8868\u793a\uff1b 2\u3001\u969c\u788d\u7269\u7528\u201c*\u201d\u8868\u793a\uff0c\u6240\u6709\u73a9\u5bb6\u90fd\u4e0d\u80fd\u901a\u8fc7\u5b83\uff1b 3\u3001\u4e00\u540d\u6e38\u620f\u73a9\u5bb6\u7684\u7f16\u53f7\u5373\u4e3a\u6570\u5b57x\uff0c\u8868\u793a\u8be5\u57ce\u5821\u88abx\u5360\u9886\u3002 \u6e38\u620f\u662f\u6309\u73a9\u5bb6\u7f16\u53f7\u4ece\u5c0f\u5230\u5927\u8f6e\u6d41\u8fdb\u884c\u7684\uff0c\u5728\u6bcf\u4e00\u8f6e\u4e2d\uff0c\u73a9\u5bb6\u8f6e\u6d41\u6269\u5f20\u52bf\u529b\u8303\u56f4\uff1a\u9996\u5148\uff0c\u7b2c\u4e00\u4e2a\u73a9\u5bb6\u6269\u5f20\uff0c\u7136\u540e\u7b2c\u4e8c\u4e2a\u73a9\u5bb6\u6269\u5f20\uff0c\u4f9d\u6b64\u7c7b\u63a8\u3002\u6269\u5f20\u89c4\u5219\u5982\u4e0b\uff1a \u5bf9\u4e8e\u73a9\u5bb6\u73b0\u5728\u62e5\u6709\u7684\u6bcf\u4e2a\u57ce\u5821\uff0c\u53ef\u4ee5\u6269\u5f20\u5230\u9644\u8fd1\u7684\u7a7a\u57ce\u5821\uff08\u672a\u88ab\u4eba\u5360\u9886\u7684\uff09\u3002 \u73a9\u5bb6i\u53ef\u4ee5\u4ece\u4ed6\u5df2\u5360\u9886\u7684\u57ce\u5821\u5411\u4e0a\u3001\u4e0b\u3001\u5de6\u3001\u53f3\u56db\u4e2a\u65b9\u5411\u6269\u5f20\uff0c\u4e14\u6bcf\u540d\u73a9\u5bb6\u90fd\u6709\u4e00\u4e2a\u653b\u51fb\u529bsi\uff0c\u5982\u679c\u80fd\u5728si\u6b65\u5185\uff08\u542bsi\uff09\u5230\u8fbe\u9644\u8fd1\u7684\u7a7a\u57ce\u5821\u5219\u53ef\u4ee5\u62a2\u5360\u8be5\u57ce\u5821\u3002 \u5f53\u6240\u6709\u73a9\u5bb6\u90fd\u4e0d\u80fd\u7ee7\u7eed\u62a2\u5360\u7684\u65f6\u5019\u6e38\u620f\u7ed3\u675f\uff0c\u51ac\u51ac\u60f3\u77e5\u9053\u6e38\u620f\u7ed3\u675f\u65f6\u6bcf\u540d\u73a9\u5bb6\u6240\u5360\u7684\u57ce\u5821\u6570\u662f\u591a\u5c11\uff1f \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c\u5305\u542b\u4e09\u4e2a\u6574\u6570n\uff0cm\u548cp\uff081\u2264n\uff0cm\u22641000,1\u2264p\u22649\uff09\u8868\u793a\u7f51\u683c\u7684\u884c\u548c\u5217\u4ee5\u53ca\u73a9\u5bb6\u6570\u91cf\u3002 \u7b2c\u4e8c\u884c\u5305\u542bp\u6574\u6570si\uff081\u2264si\u22645000\uff09\u8868\u793a\u6bcf\u540d\u73a9\u5bb6\u7684\u6269\u5f20\u901f\u5ea6\u3002 \u4ee5\u4e0bn\u884c\u63cf\u8ff0\u4e86\u6e38\u620f\u7f51\u683c\uff0c\u6bcf\u884c\u7531m\u4e2a\u7b26\u53f7\u7ec4\u6210\uff0c\u5176\u4e2d'.'\u8868\u793a\u7a7a\u57ce\u5821\uff0c'*'\u8868\u793a\u969c\u788d\u4eec\uff0c\u6570\u5b57x\uff081\u2264x\u2264p\uff09\u8868\u793a\u7531\u73a9\u5bb6x\u62e5\u6709\u7684\u57ce\u5821\u3002 \u4fdd\u8bc1\u6bcf\u540d\u73a9\u5bb6\u5728\u7f51\u683c\u4e0a\u81f3\u5c11\u6709\u4e00\u5ea7\u57ce\u5821\u3002 \u8f93\u51fa \u00b6 \u8f93\u51fap\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6e38\u620f\u7ed3\u675f\u540e\u6bcf\u540d\u73a9\u5bb6\u62a2\u5360\u7684\u57ce\u5821\u6570\u91cf\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 3 3 2 1 1 1.. ... ..2 \u3010\u6837\u4f8b2\u3011 3 4 4 1 1 1 1 .... *... 1234 \u3010\u6837\u4f8b3\u3011 3 4 4 1 1 2 1 .... *... 1234 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 6 3 \u3010\u6837\u4f8b2\u3011 1 4 3 3 \u3010\u6837\u4f8b3\u3011 1 4 5 1 \u63d0\u793a \u00b6 \u5bf9\u4e8e10%\u7684\u6570\u636e\uff0c1\u2264n\uff0cm\u22641000\uff0cp=1\u3002 \u5bf9\u4e8e20%\u7684\u6570\u636e\uff0c1\u2264n\uff0cm\u22641000\uff0cp=2\u3002 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c1\u2264n\uff0cm\u22641000,1\u2264p\u22649\uff0c1\u2264si\u22645000\u3002 \u9898\u89e3 \u00b6 BFS\u76f4\u63a5\u641c\u7d22\u5373\u53ef\uff0c\u6ce8\u610f\u641c\u7d22\u6280\u5de7\uff0c\u6269\u5c55\u6280\u5de7\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char a [ 1050 ][ 1050 ] = { 0 }; int s [ 20 ] = { 0 }; int ans [ 20 ] = { 0 }; int vis [ 1050 ][ 1050 ] = { 0 }; int n , m , p ; int dx [] = { 0 , 1 , -1 , 0 , 0 }; int dy [] = { 0 , 0 , 0 , 1 , -1 }; struct node { int x , y ; }; queue < node > que [ 1005 ]; void bfs ( int k ) { for ( int p = 1 ; p <= s [ k ]; p ++ ) { int tmp = que [ k ]. size (); if ( tmp == 0 ) break ; for ( int i = 0 ; i < tmp ; i ++ ) { int x = que [ k ]. front (). x ; int y = que [ k ]. front (). y ; que [ k ]. pop (); for ( int j = 1 ; j <= 4 ; j ++ ) { int xx = x + dx [ j ]; int yy = y + dy [ j ]; if ( xx <= 0 || xx > n || yy <= 0 || yy > m || vis [ xx ][ yy ] != 0 ) continue ; vis [ xx ][ yy ] = k ; que [ k ]. push ({ xx , yy }); } } } } int main () { scanf ( \"%d%d%d\" , & n , & m , & p ); for ( int i = 1 ; i <= p ; i ++ ) scanf ( \"%d\" , & s [ i ]); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ][ j ] == '.' ) ; else { if ( a [ i ][ j ] == '*' ) { vis [ i ][ j ] = -1 ; } else { vis [ i ][ j ] = a [ i ][ j ] - '0' ; que [ a [ i ][ j ] - '0' ]. push ({ i , j }); } } } } while ( 1 ) { int flag = 1 ; for ( int p1 = 1 ; p1 <= p ; p1 ++ ) { if ( que [ p1 ]. size () > 0 ) { bfs ( p1 ); flag = 0 ; } } if ( flag ) break ; } for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) if ( vis [ i ][ j ] != -1 ) ans [ vis [ i ][ j ]] ++ ; for ( int i = 1 ; i <= p ; i ++ ) printf ( \"%d \" , ans [ i ]); }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e09\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e09\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_2","text":"Nuske vs Phantom Thnook","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_3","text":"Nuske has a grid with N rows and M columns of squares. The rows are numbered 1 through N from top to bottom, and the columns are numbered 1 through M from left to right. Each square in the grid is painted in either blue or white. If S_{i,j} S_{i,j} is 1, the square at the i-th row and j-th column is blue; if S_{i,j} S_{i,j} is 0, the square is white. For every pair of two blue square a and b, there is at most one path that starts from a, repeatedly proceeds to an adjacent (side by side) blue square and finally reaches b, without traversing the same square more than once. Phantom Thnook, Nuske's eternal rival, gives Q queries to Nuske. The i-th query consists of four integers x_{i,1} x_{i,1} , y_{i,1} y_{i,1} , x_{i,2} x_{i,2} and y_{i,2} y_{i,2} and asks him the following: when the rectangular region of the grid bounded by (and including) the xi,1-th row, xi,2-th row, yi,1-th column and yi,2-th column is cut out, how many connected components consisting of blue squares there are in the region? Process all the queries. Constraints 1\u2264N,M\u22642000 1\u2264Q\u2264200000 Si,j is either 0 or 1. Si,j satisfies the condition explained in the statement. 1\u2264 x_{i,1} x_{i,1} \u2264 x_{i,2} x_{i,2} \u2264N(1\u2264i\u2264Q) 1\u2264 y_{i,1} y_{i,1} \u2264 y_{i,2} y_{i,2} \u2264M(1\u2264i\u2264Q)","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_4","text":"The input is given from Standard Input in the following format: N M Q S1,1..S1,M : SN,1..SN,M x1,1 yi,1 xi,2 yi,2 : xQ,1 yQ,1 xQ,2 yQ,2","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_5","text":"For each query, print the number of the connected components consisting of blue squares in the region.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_6","text":"3 4 4 1101 0110 1101 1 1 3 4 1 1 3 1 2 2 3 4 1 2 2 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_7","text":"3 2 2 2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_8","text":"In the first query, the whole grid is specified. There are three components consisting of blue squares, and thus 3 should be printed. In the second query, the region within the red frame is specified. There are two components consisting of blue squares, and thus 2 should be printed. Note that squares that belong to the same component in the original grid may belong to different components.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_9","text":"\u524d\u7f00\u548c\u4ee5\u53ca\u6811\u7684\u6027\u8d28\uff0c\u68ee\u6797\u7684\u4e2a\u6570\u7b49\u4e8e\u70b9\u7684\u4e2a\u6570\u51cf\u53bb\u8fb9\u7684\u6570\u76ee\uff0c\u7528\u524d\u7f00\u548c\u7ef4\u62a4\u8fb9\u7684\u6570\u76ee\u548c\u70b9\u7684\u6570\u76ee\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_10","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; char a [ 2050 ][ 2050 ] = { 0 }; int qzh [ 2050 ][ 2050 ] = { 0 }; int qzl [ 2050 ][ 2050 ] = { 0 }; int sum [ 2050 ][ 2050 ] = { 0 }; int main () { int n , m , q ; scanf ( \"%d%d%d\" , & n , & m , & q ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { sum [ i ][ j ] = - sum [ i - 1 ][ j - 1 ] + sum [ i ][ j - 1 ] + sum [ i - 1 ][ j ] + a [ i ][ j ] - '0' ; if ( a [ i ][ j ] == '1' ) { int tmp1 = 0 , tmp2 = 0 ; if ( a [ i - 1 ][ j ] == '1' ) tmp2 ++ ; if ( a [ i ][ j - 1 ] == '1' ) tmp1 ++ ; qzh [ i ][ j ] = - qzh [ i - 1 ][ j - 1 ] + qzh [ i ][ j - 1 ] + qzh [ i - 1 ][ j ] + tmp1 ; qzl [ i ][ j ] = - qzl [ i - 1 ][ j - 1 ] + qzl [ i ][ j - 1 ] + qzl [ i - 1 ][ j ] + tmp2 ; } else { qzh [ i ][ j ] = - qzh [ i - 1 ][ j - 1 ] + qzh [ i ][ j - 1 ] + qzh [ i - 1 ][ j ]; qzl [ i ][ j ] = - qzl [ i - 1 ][ j - 1 ] + qzl [ i ][ j - 1 ] + qzl [ i - 1 ][ j ]; } } } while ( q -- ) { int x1 , y1 , x2 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & y1 , & x2 , & y2 ); int ans = sum [ x2 ][ y2 ] - sum [ x1 - 1 ][ y2 ] - sum [ x2 ][ y1 - 1 ] + sum [ x1 - 1 ][ y1 - 1 ]; ans = ans - ( qzh [ x2 ][ y2 ] - qzh [ x1 - 1 ][ y2 ] - qzh [ x2 ][ y1 ] + qzh [ x1 - 1 ][ y1 ]); ans = ans - ( qzl [ x2 ][ y2 ] - qzl [ x1 ][ y2 ] - qzl [ x2 ][ y1 - 1 ] + qzl [ x1 ][ y1 - 1 ]); printf ( \"%d \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_11","text":"A or...or B Problem","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_12","text":"Nukes has an integer that can be represented as the bitwise OR of one or more integers between A and B (inclusive). How many possible candidates of the value of Nukes's integer there are? Constraints 1\u2264A\u2264B< 2^{60} 2^{60} A and B are integers.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_13","text":"The input is given from Standard Input in the following format: A B","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_14","text":"Print the number of possible candidates of the value of Nukes's integer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_15","text":"7 9","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_16","text":"4","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_17","text":"In this case, A=7 and B=9. There are four integers that can be represented as the bitwise OR of a non-empty subset of {7, 8, 9}: 7, 8, 9 and 15.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_18","text":"\u5047\u8bbeA\uff0cB\u4e24\u4e2a\u6570\u7684\u4e8c\u8fdb\u5236\u5982\u4e0b\uff1a A\uff1axxxxxx..0***** B\uff1axxxxxx..10----- \u5219\uff1a C\uff1axxxxxx..011111 D\uff1axxxxxx..100000 C\u548cD\u4e00\u5b9a\u6ee1\u8db3A<=C<=D<=B \u5219\uff1a E\uff1axxxxxx..1***** F\uff1axxxxxx..111111 G\uff1axxxxxx..100111 \u5176\u4e2d [E,F] [E,F] \u53ef\u4ee5\u7531 [A,C] [A,C] \u548cD\u6216\u8fd0\u7b97\u5f97\u5230\uff0c [D,G] [D,G] \u53ef\u4ee5\u7531 [D,B] [D,B] \u6216\u8fd0\u7b97\u5f97\u5230\uff0c\u6240\u4ee5\u7b54\u6848\u5373\u4e3a [A,G]\\cup[E,F] [A,G]\\cup[E,F]","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_19","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { ll a , b ; cin >> a >> b ; if ( a > b ) swap ( a , b ); ll tmp = b , aa = a ; for ( ll i = 60 ; i >= 0 ; i -- ) { if ((( a ^ b ) >> i ) & 1 ) { for ( ll j = i - 1 ; j >= 0 ; j -- ) tmp |= ( 1l l << j ); ///\u7b49\u6548\u4e8exxxxx..111111 a |= ( 1l l << i ); ///\u7b49\u6548\u4e8exxxxx..1***** for ( i -- ; i >= 0 && ! (( b >> i ) & 1 ); i -- ) ; for (; i >= 0 ; i -- ) b |= ( 1l l << i ); ///\u7b49\u6548\u4e8exxxxx..100111 break ; } } ll ans = 0 ; if ( b >= a ) ans = tmp - aa + 1 ; else ans = tmp - a + 1 + b - aa + 1 ; cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_20","text":"\u62a2\u5360\u57ce\u5821","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_21","text":"\u51ac\u51ac\u6b63\u548c\u4ed6\u7684\u670b\u53cb\u4e00\u8d77\u73a9\u62a2\u5360\u57ce\u5821\u7684\u6e38\u620f\uff0c\u8be5\u6e38\u620f\u53ef\u4ee5\u8868\u793a\u4e3a\u5927\u5c0f\u4e3an\u00d7m\u7684\u7f51\u683c\uff0c\u6bcf\u4e2a\u683c\u5b50\u6700\u591a\u53ea\u80fd\u5bb9\u4e0b\u4e00\u5ea7\u57ce\u5821\uff0c\u6bcf\u4e2a\u683c\u5b50\u6709\u4e09\u79cd\u72b6\u6001\uff1a 1\u3001\u7a7a\u57ce\u5821\u7528\u201c.\u201d\u8868\u793a\uff1b 2\u3001\u969c\u788d\u7269\u7528\u201c*\u201d\u8868\u793a\uff0c\u6240\u6709\u73a9\u5bb6\u90fd\u4e0d\u80fd\u901a\u8fc7\u5b83\uff1b 3\u3001\u4e00\u540d\u6e38\u620f\u73a9\u5bb6\u7684\u7f16\u53f7\u5373\u4e3a\u6570\u5b57x\uff0c\u8868\u793a\u8be5\u57ce\u5821\u88abx\u5360\u9886\u3002 \u6e38\u620f\u662f\u6309\u73a9\u5bb6\u7f16\u53f7\u4ece\u5c0f\u5230\u5927\u8f6e\u6d41\u8fdb\u884c\u7684\uff0c\u5728\u6bcf\u4e00\u8f6e\u4e2d\uff0c\u73a9\u5bb6\u8f6e\u6d41\u6269\u5f20\u52bf\u529b\u8303\u56f4\uff1a\u9996\u5148\uff0c\u7b2c\u4e00\u4e2a\u73a9\u5bb6\u6269\u5f20\uff0c\u7136\u540e\u7b2c\u4e8c\u4e2a\u73a9\u5bb6\u6269\u5f20\uff0c\u4f9d\u6b64\u7c7b\u63a8\u3002\u6269\u5f20\u89c4\u5219\u5982\u4e0b\uff1a \u5bf9\u4e8e\u73a9\u5bb6\u73b0\u5728\u62e5\u6709\u7684\u6bcf\u4e2a\u57ce\u5821\uff0c\u53ef\u4ee5\u6269\u5f20\u5230\u9644\u8fd1\u7684\u7a7a\u57ce\u5821\uff08\u672a\u88ab\u4eba\u5360\u9886\u7684\uff09\u3002 \u73a9\u5bb6i\u53ef\u4ee5\u4ece\u4ed6\u5df2\u5360\u9886\u7684\u57ce\u5821\u5411\u4e0a\u3001\u4e0b\u3001\u5de6\u3001\u53f3\u56db\u4e2a\u65b9\u5411\u6269\u5f20\uff0c\u4e14\u6bcf\u540d\u73a9\u5bb6\u90fd\u6709\u4e00\u4e2a\u653b\u51fb\u529bsi\uff0c\u5982\u679c\u80fd\u5728si\u6b65\u5185\uff08\u542bsi\uff09\u5230\u8fbe\u9644\u8fd1\u7684\u7a7a\u57ce\u5821\u5219\u53ef\u4ee5\u62a2\u5360\u8be5\u57ce\u5821\u3002 \u5f53\u6240\u6709\u73a9\u5bb6\u90fd\u4e0d\u80fd\u7ee7\u7eed\u62a2\u5360\u7684\u65f6\u5019\u6e38\u620f\u7ed3\u675f\uff0c\u51ac\u51ac\u60f3\u77e5\u9053\u6e38\u620f\u7ed3\u675f\u65f6\u6bcf\u540d\u73a9\u5bb6\u6240\u5360\u7684\u57ce\u5821\u6570\u662f\u591a\u5c11\uff1f","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_22","text":"\u7b2c\u4e00\u884c\u5305\u542b\u4e09\u4e2a\u6574\u6570n\uff0cm\u548cp\uff081\u2264n\uff0cm\u22641000,1\u2264p\u22649\uff09\u8868\u793a\u7f51\u683c\u7684\u884c\u548c\u5217\u4ee5\u53ca\u73a9\u5bb6\u6570\u91cf\u3002 \u7b2c\u4e8c\u884c\u5305\u542bp\u6574\u6570si\uff081\u2264si\u22645000\uff09\u8868\u793a\u6bcf\u540d\u73a9\u5bb6\u7684\u6269\u5f20\u901f\u5ea6\u3002 \u4ee5\u4e0bn\u884c\u63cf\u8ff0\u4e86\u6e38\u620f\u7f51\u683c\uff0c\u6bcf\u884c\u7531m\u4e2a\u7b26\u53f7\u7ec4\u6210\uff0c\u5176\u4e2d'.'\u8868\u793a\u7a7a\u57ce\u5821\uff0c'*'\u8868\u793a\u969c\u788d\u4eec\uff0c\u6570\u5b57x\uff081\u2264x\u2264p\uff09\u8868\u793a\u7531\u73a9\u5bb6x\u62e5\u6709\u7684\u57ce\u5821\u3002 \u4fdd\u8bc1\u6bcf\u540d\u73a9\u5bb6\u5728\u7f51\u683c\u4e0a\u81f3\u5c11\u6709\u4e00\u5ea7\u57ce\u5821\u3002","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_23","text":"\u8f93\u51fap\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6e38\u620f\u7ed3\u675f\u540e\u6bcf\u540d\u73a9\u5bb6\u62a2\u5360\u7684\u57ce\u5821\u6570\u91cf\u3002","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_24","text":"\u3010\u6837\u4f8b1\u3011 3 3 2 1 1 1.. ... ..2 \u3010\u6837\u4f8b2\u3011 3 4 4 1 1 1 1 .... *... 1234 \u3010\u6837\u4f8b3\u3011 3 4 4 1 1 2 1 .... *... 1234","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_25","text":"\u3010\u6837\u4f8b1\u3011 6 3 \u3010\u6837\u4f8b2\u3011 1 4 3 3 \u3010\u6837\u4f8b3\u3011 1 4 5 1","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_26","text":"\u5bf9\u4e8e10%\u7684\u6570\u636e\uff0c1\u2264n\uff0cm\u22641000\uff0cp=1\u3002 \u5bf9\u4e8e20%\u7684\u6570\u636e\uff0c1\u2264n\uff0cm\u22641000\uff0cp=2\u3002 \u5bf9\u4e8e100%\u7684\u6570\u636e\uff0c1\u2264n\uff0cm\u22641000,1\u2264p\u22649\uff0c1\u2264si\u22645000\u3002","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_27","text":"BFS\u76f4\u63a5\u641c\u7d22\u5373\u53ef\uff0c\u6ce8\u610f\u641c\u7d22\u6280\u5de7\uff0c\u6269\u5c55\u6280\u5de7\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/#_28","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; char a [ 1050 ][ 1050 ] = { 0 }; int s [ 20 ] = { 0 }; int ans [ 20 ] = { 0 }; int vis [ 1050 ][ 1050 ] = { 0 }; int n , m , p ; int dx [] = { 0 , 1 , -1 , 0 , 0 }; int dy [] = { 0 , 0 , 0 , 1 , -1 }; struct node { int x , y ; }; queue < node > que [ 1005 ]; void bfs ( int k ) { for ( int p = 1 ; p <= s [ k ]; p ++ ) { int tmp = que [ k ]. size (); if ( tmp == 0 ) break ; for ( int i = 0 ; i < tmp ; i ++ ) { int x = que [ k ]. front (). x ; int y = que [ k ]. front (). y ; que [ k ]. pop (); for ( int j = 1 ; j <= 4 ; j ++ ) { int xx = x + dx [ j ]; int yy = y + dy [ j ]; if ( xx <= 0 || xx > n || yy <= 0 || yy > m || vis [ xx ][ yy ] != 0 ) continue ; vis [ xx ][ yy ] = k ; que [ k ]. push ({ xx , yy }); } } } } int main () { scanf ( \"%d%d%d\" , & n , & m , & p ); for ( int i = 1 ; i <= p ; i ++ ) scanf ( \"%d\" , & s [ i ]); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ][ j ] == '.' ) ; else { if ( a [ i ][ j ] == '*' ) { vis [ i ][ j ] = -1 ; } else { vis [ i ][ j ] = a [ i ][ j ] - '0' ; que [ a [ i ][ j ] - '0' ]. push ({ i , j }); } } } } while ( 1 ) { int flag = 1 ; for ( int p1 = 1 ; p1 <= p ; p1 ++ ) { if ( que [ p1 ]. size () > 0 ) { bfs ( p1 ); flag = 0 ; } } if ( flag ) break ; } for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) if ( vis [ i ][ j ] != -1 ) ans [ vis [ i ][ j ]] ++ ; for ( int i = 1 ; i <= p ; i ++ ) printf ( \"%d \" , ans [ i ]); }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e8c\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Flowerpot \u9898\u76ee\u63cf\u8ff0 \u00b6 \u8001\u677f\u9700\u8981\u4f60\u5e2e\u5fd9\u6d47\u82b1\u3002\u7ed9\u51faN\u6ef4\u6c34\u7684\u5750\u6807\uff0cy\u8868\u793a\u6c34\u6ef4\u7684\u9ad8\u5ea6\uff0cx\u8868\u793a\u5b83\u4e0b\u843d\u5230x\u8f74\u7684\u4f4d\u7f6e\u3002 \u6bcf\u6ef4\u6c34\u4ee5\u6bcf\u79d21\u4e2a\u5355\u4f4d\u957f\u5ea6\u7684\u901f\u5ea6\u4e0b\u843d\u3002\u4f60\u9700\u8981\u628a\u82b1\u76c6\u653e\u5728x\u8f74\u4e0a\u7684\u67d0\u4e2a\u4f4d\u7f6e\uff0c\u4f7f\u5f97\u4ece\u88ab\u82b1\u76c6\u63a5\u7740\u7684\u7b2c1\u6ef4\u6c34\u5f00\u59cb\uff0c\u5230\u88ab\u82b1\u76c6\u63a5\u7740\u7684\u6700\u540e1\u6ef4\u6c34\u7ed3\u675f\uff0c\u4e4b\u95f4\u7684\u65f6\u95f4\u5dee\u81f3\u5c11\u4e3aD\u3002 \u6211\u4eec\u8ba4\u4e3a\uff0c\u53ea\u8981\u6c34\u6ef4\u843d\u5230x\u8f74\u4e0a\uff0c\u4e0e\u82b1\u76c6\u7684\u8fb9\u6cbf\u5bf9\u9f50\uff0c\u5c31\u8ba4\u4e3a\u88ab\u63a5\u4f4f\u3002\u7ed9\u51faN\u6ef4\u6c34\u7684\u5750\u6807\u548cD\u7684\u5927\u5c0f\uff0c\u8bf7\u7b97\u51fa\u6700\u5c0f\u7684\u82b1\u76c6\u7684\u5bbd\u5ea6W\u3002 \u8f93\u5165 \u00b6 \u7b2c\u4e00\u884c2\u4e2a\u6574\u6570 N \u548c D\u3002 \u7b2c2.. N+1\u884c\u6bcf\u884c2\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6c34\u6ef4\u7684\u5750\u6807(x,y)\u3002 1 \u2264 N \u2264 100000\uff0c1 \u2264 D \u2264 1000000\uff0c0\u2264x,y\u2264106\u3002 \u8f93\u51fa \u00b6 \u4ec5\u4e00\u884c1\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6700\u5c0f\u7684\u82b1\u76c6\u7684\u5bbd\u5ea6\u3002\u5982\u679c\u65e0\u6cd5\u6784\u9020\u51fa\u8db3\u591f\u5bbd\u7684\u82b1\u76c6\uff0c\u4f7f\u5f97\u5728D\u5355\u4f4d\u7684\u65f6\u95f4\u63a5\u4f4f\u6ee1\u8db3\u8981\u6c42\u7684\u6c34\u6ef4\uff0c\u5219\u8f93\u51fa-1\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 4 5 6 3 2 4 4 10 12 15 \u6837\u4f8b\u8f93\u51fa \u00b6 2 \u63d0\u793a \u00b6 \u67094\u6ef4\u6c34\uff0c (6,3), (2,4), (4,10), (12,15).\u6c34\u6ef4\u5fc5\u987b\u7528\u81f3\u5c115\u79d2\u65f6\u95f4\u843d\u5165\u82b1\u76c6\u3002\u82b1\u76c6\u7684\u5bbd\u5ea6\u4e3a2\u662f\u5fc5\u987b\u4e14\u8db3\u591f\u7684\u3002\u628a\u82b1\u76c6\u653e\u5728x=4..6\u7684\u4f4d\u7f6e\uff0c\u5b83\u53ef\u4ee5\u63a5\u52301\u548c3\u6c34\u6ef4, \u4e4b\u95f4\u7684\u65f6\u95f4\u5dee\u4e3a10-3 = 7\u6ee1\u8db3\u6761\u4ef6\u3002 \u9898\u89e3 \u00b6 \u5355\u8c03\u6808\uff0c\u7ef4\u62a4\u5355\u8c03\u4e0a\u5347\u7684y\uff0c\u7136\u540e\u6c42x\u4e4b\u5dee\u7684\u6700\u5c0f\u503c\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; struct node { int x , y ; bool operator < ( const node & a ) const { if ( a . x != x ) return x < a . x ; else return y < a . y ; } }; node a [ 100500 ] = { 0 }, s [ 100500 ] = { 0 }; int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d%d\" , & a [ i ]. x , & a [ i ]. y ); sort ( a + 1 , a + n + 1 ); int head = 1 , tail = 1 , ans = inf ; s [ 1 ] = a [ 1 ]; for ( int i = 2 ; i <= n ; i ++ ) { while ( tail >= head && s [ tail ]. y > a [ i ]. y ) { if ( s [ tail ]. y - a [ i ]. y >= m ) ans = min ( ans , a [ i ]. x - s [ tail ]. x ); tail -- ; } s [ ++ tail ] = a [ i ]; while ( tail >= head && s [ tail ]. y - s [ head ]. y >= m ) ans = min ( ans , s [ tail ]. x - s [ head ]. x ), head ++ ; } printf ( \"%d \\n \" , ans == inf ? -1 : ans ); } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Haybale Restacking \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has just ordered a large number of bales of hay. He would like to organize these into N piles (1 <= N <= 100,000) arranged in a circle, where pile i contains B_i bales of hay. Unfortunately, the truck driver delivering the hay was not listening carefully when Farmer John provided this information, and only remembered to leave the hay in N piles arranged in a circle. After delivery, Farmer John notes that pile i contains A_i bales of hay. Of course, the A_i's and the B_i's have the same sum. Farmer John would like to move the bales of hay from their current configuration (described by the A_i's) into his desired target configuration (described by the B_i's). It takes him x units of work to move one hay bale from one pile to a pile that is x steps away around the circle. Please help him compute the minimum amount of work he will need to spend. \u8f93\u5165 \u00b6 * Line 1: The single integer N. * Lines 2..1+N: Line i+1 contains the two integers A_i and B_i (1 <= A_i, B_i <= 1000). \u8f93\u51fa \u00b6 * Line 1:the minimum amount of work he will need to spend. \u6837\u4f8b\u8f93\u5165 \u00b6 4 7 1 3 4 9 2 1 13 \u6837\u4f8b\u8f93\u51fa \u00b6 13 \u63d0\u793a \u00b6 \u8bbexi\u4e3a\u7b2ci\u5806\u5e72\u8349\u4e0e\u7b2ci-1\u5806\u5e72\u8349\u7684\u4ea4\u6362\u6570 \u4ee4B[i]\u7b49\u4e8eB[i]-A[i],\u5219\u6211\u4eec\u7684\u76ee\u6807\u662f\u8ba9B[i]\u5168\u90e8\u53d8\u4e3a0 B[1]-x1+x2=0 ==> x2=x1-B[1] B[2]-x2+x3=0 ==> x3=x2-B[2]=x1-B[1]-B[2] ......xn-1=x1-B[1]-B[2]-...-B[n-1] \u800c\u6211\u4eec\u8981\u4f7f x1+x2+x3+...+xn-1 \u6700\u5c0f, \u5373|x1|+|x1-B[1]|+...+|x1-B[1]-B[2]-...-B[n-1]| \u6700\u5c0f \u6240\u4ee5x1\u8981\u7b49\u4e8eB[1],B[1]+B[2],...,B[1]+B[2]+...+B[n-1]\u7684\u4e2d\u4f4d\u6570 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; ll b [ 100500 ] = { 0 }; ll a [ 100500 ] = { 0 }; ll sum [ 100500 ] = { 0 }; int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld\" , & a [ i ], & b [ i ]); b [ i ] -= a [ i ]; sum [ i ] = sum [ i -1 ] + b [ i ]; } sort ( sum + 1 , sum + n + 1 ); ll tmp = sum [( n + 1 ) / 2 ], ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) ans += abs ( sum [ i ] - tmp ); cout << ans << endl ; } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 123 Triangle \u9898\u76ee\u63cf\u8ff0 \u00b6 You are given four positive integers x0, x1, a, b. And you know x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} for all i\u22652. Given two positive integers n, and MOD, please calculate xn modulo MOD. Does the problem look simple? Surprise! The value of n may have many many digits! \u8f93\u5165 \u00b6 The input contains two lines. The first line contains four integers x0, x1, a, b,a,b (1\u2264x0,x1,a,b\u2264109). The second line contains two integers n, MOD ( , n has no leading zero). \u8f93\u51fa \u00b6 Print one integer representing the answer. \u6837\u4f8b\u8f93\u5165 \u00b6 1 1 1 1 10 1000000001 \u6837\u4f8b\u8f93\u51fa \u00b6 89 \u63d0\u793a \u00b6 The resulting sequence x is Fibonacci sequence. The 11-th item is 89. \u9898\u89e3 \u00b6 \u9996\u5148\u662f\u5341\u8fdb\u5236\u5feb\u901f\u5e42\uff0c\u4f8b\u5982\uff1a 3^{1234}=((((ans*3^1)^{10}*3^2)^{10}*3^3)^{10}*3^4)^{10} 3^{1234}=((((ans*3^1)^{10}*3^2)^{10}*3^3)^{10}*3^4)^{10} \u7136\u540e\u662f\u77e9\u9635\u5feb\u901f\u5e42\uff0c x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} \u53ef\u4ee5\u8f6c\u6362\u4e3a\uff1a $\\left( \\matrix{ a & b \\ 1& 0 } \\right) ^{n-1} * \\left(\\matrix {x1 \\ x0 } \\right) $ \u6c42\u51fa\u77e9\u9635\u53d8\u4e3a\u7b54\u6848\u3002 \u53c2\u8003\u4e0e\uff1a https://blog.csdn.net/qq_41650771/article/details/98108098 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll x0 , x1 , a , b , mod ; struct node { ll data [ 3 ][ 3 ]; void clear1 () { data [ 1 ][ 2 ] = data [ 2 ][ 1 ] = 0 ; data [ 1 ][ 1 ] = data [ 2 ][ 2 ] = 0 ; } void clear () { data [ 1 ][ 2 ] = data [ 2 ][ 1 ] = 0 ; data [ 1 ][ 1 ] = data [ 2 ][ 2 ] = 1 ; } node operator * ( const node & a ) const { node tmp ; tmp . clear1 (); for ( ll i = 1 ; i <= 2 ; i ++ ) { for ( ll j = 1 ; j <= 2 ; j ++ ) { for ( ll k = 1 ; k <= 2 ; k ++ ) { tmp . data [ i ][ j ] += data [ i ][ k ] * a . data [ k ][ j ]; tmp . data [ i ][ j ] %= mod ; } } } return tmp ; } void print () { printf ( \"%lld %lld \\n %lld %lld \\n ** \\n \" , data [ 1 ][ 1 ], data [ 1 ][ 2 ], data [ 2 ][ 1 ], data [ 2 ][ 2 ]); } }; char t [ 1005000 ] = { 0 }; node ksm ( node a , int b ) { node ans1 , ans2 = a ; ans1 . clear (); while ( b != 0 ) { if ( b % 2 ) ans1 = ans1 * ans2 ; ans2 = ans2 * ans2 ; b /= 2 ; } return ans1 ; } int main () { scanf ( \"%lld%lld%lld%lld\" , & x0 , & x1 , & a , & b ); scanf ( \"%s\" , t + 1 ); scanf ( \"%lld\" , & mod ); node tmp1 , tmp2 ; tmp2 . data [ 1 ][ 1 ] = a ; tmp2 . data [ 1 ][ 2 ] = 1 ; tmp2 . data [ 2 ][ 1 ] = b ; tmp2 . data [ 2 ][ 2 ] = 0 ; tmp1 . data [ 1 ][ 1 ] = x1 ; tmp1 . data [ 1 ][ 2 ] = x0 ; tmp1 . data [ 2 ][ 1 ] = 0 ; tmp1 . data [ 2 ][ 2 ] = 0 ; node tmp4 ; tmp4 . clear (); for ( int i = 1 ; t [ i ]; i ++ ) { tmp4 = ksm ( tmp4 , 10 ); node tmp3 = ksm ( tmp2 , t [ i ] - '0' ); tmp4 = tmp3 * tmp4 ; } tmp1 = tmp1 * tmp4 ; cout << tmp1 . data [ 1 ][ 2 ] << endl ; } \u9898\u76ee4 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 XOR Game \u9898\u76ee\u63cf\u8ff0 \u00b6 There are 2N integers written on a blackboard. The i-th integer is Ai. Alice and Bob will play a game consisting of N rounds. In each round, they do the following: First, Alice chooses an integer on the blackboard and erases it. Let x be the integer erased here. Second, Bob chooses an integer on the blackboard and erases it. Let y be the integer erased here. Finally, write the value x\u2295y on a notebook, where \u2295 denotes the bitwise XOR. In the end, all the integers on the blackboard will be erased, and the notebook will have N integers written on it. The greatest integer written on the notebook will be the score of the game. Alice wants to maximize this score, while Bob wants to minimize it. Find the score of the game when both players play optimally under their objectives. Constraints 1\u2264N\u2264 2\u00d710^5 2\u00d710^5 0\u2264Ai< 2^{30} 2^{30} All values in input are integers. \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N A1 A2 \u22ef A2N \u8f93\u51fa \u00b6 Print the answer. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 2 0 1 3 5 \u3010\u6837\u4f8b2\u3011 2 0 0 0 0 \u3010\u6837\u4f8b3\u3011 10 974654030 99760550 750234695 255777344 907989127 917878091 818948631 690392797 579845317 549202360 511962375 203530861 491981716 64663831 561104719 541423175 301832976 252317904 471905694 350223945 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 4 \u3010\u6837\u4f8b2\u3011 0 \u3010\u6837\u4f8b3\u3011 268507123 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca\uff1a Below is one possible progress of the game (it may contain suboptimal choices). Round 1: Alice chooses A1=0. Bob chooses A3=3. They write 0\u22953=3 on the notebook. Round 2: Alice chooses A4=5. Bob chooses A2=1. They write 5\u22951=4 on the notebook. The score of the game is max(3,4)=4. \u9898\u89e3 \u00b6 \u5b57\u5178\u6811\uff0c\u537301trai\uff0c\u7531\u4e8e\u4e00\u4e2a\u8981\u6700\u5927\u5316\u5f02\u6216\u503c\uff0c\u4e00\u4e2a\u8981\u6700\u5c0f\u5316\u5f02\u6216\u503c\uff0c\u5219\u7b54\u6848\u4e3a\u5f02\u6216\u540e\u6700\u5927\u503c\u7684\u6700\u5c0f\u503c\uff0c\u5373\u627e\u4e24\u4e2a\u6570\u4f7f\u5f97\u5176\u5f02\u6216\u503c\u6700\u5c0f\u5316\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; int tree [ 10000005 ][ 2 ] = { 0 }; int size1 [ 10000005 ] = { 0 }; int cnt = 1 ; void insert1 ( int k ) { int p = 1 ; size1 [ p ] ++ ; for ( int i = 29 ; i >= 0 ; i -- ) { int tmp = ( k & ( 1 << i )) ? 1 : 0 ; if ( tree [ p ][ tmp ] == 0 ) tree [ p ][ tmp ] =++ cnt ; p = tree [ p ][ tmp ]; size1 [ p ] ++ ; } } int solve ( int a , int b , int dp ) { if ( dp < 0 ) return 0 ; if ( size1 [ a ] == 0 || size1 [ b ] == 0 ) return inf ; ///\u5de6\u53f3\u65e0\u6cd5\u518d\u8fdb\u884c\u5339\u914d if ( a == b ) { if ( size1 [ tree [ a ][ 0 ]] % 2 == 1 ) { return solve ( tree [ a ][ 0 ], tree [ a ][ 1 ], dp -1 ) + ( 1 << dp ); } else { int tmp1 = solve ( tree [ a ][ 0 ], tree [ a ][ 0 ], dp -1 ); int tmp2 = solve ( tree [ a ][ 1 ], tree [ a ][ 1 ], dp -1 ); if ( tmp1 >= inf ) return tmp2 ; else if ( tmp2 >= inf ) return tmp1 ; else return max ( tmp1 , tmp2 ); } } else { int ans = inf ; if (( tree [ a ][ 0 ] && tree [ b ][ 0 ]) || ( tree [ a ][ 1 ] && tree [ b ][ 1 ])) { ans = min ( ans , solve ( tree [ a ][ 0 ], tree [ b ][ 0 ], dp -1 )); ans = min ( ans , solve ( tree [ a ][ 1 ], tree [ b ][ 1 ], dp -1 )); } else { ans = min ( ans , solve ( tree [ a ][ 1 ], tree [ b ][ 0 ], dp -1 ) + ( 1 << dp )); ans = min ( ans , solve ( tree [ a ][ 0 ], tree [ b ][ 1 ], dp -1 ) + ( 1 << dp )); } return ans ; } } int main () { int n , m ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= 2 * n ; i ++ ) { scanf ( \"%d\" , & m ); insert1 ( m ); } cout << solve ( 1 , 1 , 29 ) << endl ; } \u9898\u76ee5 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Mountain Climbing \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has discovered that his cows produce higher quality milk when they are subject to strenuous exercise. He therefore decides to send his N cows (1 <= N <= 25,000) to climb up and then back down a nearby mountain! Cow i takes U(i) time to climb up the mountain and then D(i) time to climb down the mountain. Being domesticated cows, each cow needs the help of a farmer for each leg of the climb, but due to the poor economy, there are only two farmers available, Farmer John and his cousin Farmer Don. FJ plans to guide cows for the upward climb, and FD will then guide the cows for the downward climb. Since every cow needs a guide, and there is only one farmer for each part of the voyage, at most one cow may be climbing upward at any point in time (assisted by FJ), and at most one cow may be climbing down at any point in time (assisted by FD). A group of cows may temporarily accumulate at the top of the mountain if they climb up and then need to wait for FD's assistance before climbing down. Cows may climb down in a different order than they climbed up. Please determine the least possible amount of time for all N cows to make the entire journey. \u8f93\u5165 \u00b6 * Line 1: The number of cows, N. * Lines 2..1+N: Line i+1 contains two space-separated integers: U(i) and D(i). (1 <= U(i), D(i) <= 50,000). \u8f93\u51fa \u00b6 * Line 1: A single integer representing the least amount of time for all the cows to cross the mountain. \u6837\u4f8b\u8f93\u5165 \u00b6 3 6 4 8 1 2 3 \u6837\u4f8b\u8f93\u51fa \u00b6 17 \u9898\u89e3 \u00b6 \u4e8c\u7ea7\u8f66\u95f4\u8c03\u5ea6\u95ee\u9898\uff0c\u8d2a\u5fc3\uff0c\u8ba9\u4e0b\u5c71\u6bd4\u4e0a\u5c71\u5feb\u7684\u5148\u4e0a\uff0c\u7136\u540e\u5728\u8d2a\u5fc3\u7684\u7f29\u77ed\u4e0a\u5c71\u65f6\u95f4\u548c\u6269\u5927\u4e0b\u5c71\u65f6\u95f4\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll u , d , sum , sum1 ; }; bool cmp ( node a , node b ) { if ( a . d > a . u && b . d <= b . u ) ///\u4e0b\u7684\u6162\u7684\u4f18\u5148 return 1 ; else if ( a . d <= a . u && b . d > b . u ) return 0 ; else if ( a . d > a . u ) return a . u < b . u ; ///\u4e0a\u7684\u5feb\u7684\u4f18\u5148 else return a . d > b . d ; ///\u4e0b\u7684\u6162\u7684\u4f18\u5148 } node a [ 25500 ] = { 0 }; int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld%lld\" , & a [ i ]. u , & a [ i ]. d ); sort ( a + 1 , a + n + 1 , cmp ); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) a [ i ]. sum = a [ i -1 ]. sum + a [ i ]. u ; for ( ll i = 1 ; i <= n ; i ++ ) { a [ i ]. sum1 = max ( a [ i ]. sum , a [ i -1 ]. sum1 ) + a [ i ]. d ; ans = max ( ans , a [ i ]. sum1 ); } cout << ans << endl ; } \u9898\u76ee6 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Tower \u9898\u76ee\u63cf\u8ff0 \u00b6 There are N blocks, numbered 1,2,\u2026,N. For each i (1\u2264i\u2264N), Block i has a weight of wi, a solidness of si and a value of vi. Taro has decided to build a tower by choosing some of the N blocks and stacking them vertically in some order. Here, the tower must satisfy the following condition: For each Block i contained in the tower, the sum of the weights of the blocks stacked above it is not greater than si. Find the maximum possible sum of the values of the blocks contained in the tower. Constraints All values in input are integers. 1\u2264N\u2264 10^3 10^3 1\u2264wi,si\u2264 10^4 10^4 1\u2264vi\u2264 10^9 10^9 \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N w1 s1 v1 w2 s2 v2 : wN sN vN \u8f93\u51fa \u00b6 Print the maximum possible sum of the values of the blocks contained in the tower. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010 \u6837\u4f8b1 \u3011 3 2 2 20 2 1 30 3 1 40 \u3010 \u6837\u4f8b2 \u3011 4 1 2 10 3 1 10 2 4 10 1 6 10 \u3010 \u6837\u4f8b3 \u3011 5 1 10000 1000000000 1 10000 1000000000 1 10000 1000000000 1 10000 1000000000 1 10000 1000000000 \u3010 \u6837\u4f8b4 \u3011 8 9 5 7 6 2 7 5 7 3 7 8 8 1 9 6 3 3 3 4 1 7 4 5 5 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 50 \u3010\u6837\u4f8b2\u3011 40 \u3010\u6837\u4f8b3\u3011 5000000000 \u3010\u6837\u4f8b4\u3011 22 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca\uff1aIf Blocks 2,1 are stacked in this order from top to bottom, this tower will satisfy the condition, with the total value of 30+20=50. \u6837\u4f8b2\u89e3\u91ca\uff1aBlocks 1,2,3,4 should be stacked in this order from top to bottom. \u6837\u4f8b3\u89e3\u91ca\uff1aThe answer may not fit into a 32-bit integer type. \u6837\u4f8b4\u89e3\u91ca\uff1aWe should, for example, stack Blocks 5,6,8,4 in this order from top to bottom. \u9898\u89e3 \u00b6 \u9996\u5148\u8d2a\u5fc3\u6392\u5e8f\uff0c\u5bf9\u4e8ea\u548cb\u4e24\u4e2a\u7269\u54c1\uff0c\u5982\u679ca\u653e\u5728b\u4e0a\u9762\u5219\u6743\u503c\u4e3as[b]-w[a]\uff0c\u5982\u679cb\u653e\u5728a\u4e0a\u9762\uff0c\u5219\u6743\u503c\u4e3as[a]-w[b]\uff0c\u5219a\u548cb\u7684\u987a\u5e8f\u7531s[b]-w[a]\u548cs[a]-w[b]\u6240\u51b3\u5b9a\uff0c\u79fb\u9879\u53ef\u5f97\u5373\u4e3a\u6bd4\u8f83s[a]+w[a]\u548cs[b]+w[b]\uff0c\u6240\u4ee5\u6839\u636es[a]+w[a]\u7684\u5927\u5c0f\u8d2a\u5fc3\u6392\u5e8f\uff0c\u540e\u6839\u636e\u91cd\u91cf\u9650\u5236\u52a8\u6001\u89c4\u5212\uff0c\u5373\u5047\u8bbedp[i]\u4e3a\u91cd\u91cf\u4e3ai\u65f6\u7684\u6700\u5927\u6743\u503c\uff0c\u5219\u8f6c\u79fb\u65b9\u7a0b\u4e3a\uff1a dp[j+w[i]]=max(dp[j+w[i]],dp[j]+v[i])(0<=j<=s[i]) dp[j+w[i]]=max(dp[j+w[i]],dp[j]+v[i])(0<=j<=s[i]) \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll w , s , v ; }; node a [ 1005 ] = { 0 }; ll dp [ 30050 ] = { 0 }; int main () { ll n ; scanf ( \"%d\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%d%d%d\" , & a [ i ]. w , & a [ i ]. s , & a [ i ]. v ); sort ( a + 1 , a + n + 1 , []( node a , node b ) { return a . s + a . w < b . s + b . w ; }); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = a [ i ]. s ; j >= 0 ; j -- ) dp [ j + a [ i ]. w ] = max ( dp [ j + a [ i ]. w ], dp [ j ] + a [ i ]. v ); } for ( ll j = 0 ; j < 30050 ; j ++ ) ans = max ( ans , dp [ j ]); cout << ans << endl ; }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e8c\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e8c\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_2","text":"Flowerpot","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_3","text":"\u8001\u677f\u9700\u8981\u4f60\u5e2e\u5fd9\u6d47\u82b1\u3002\u7ed9\u51faN\u6ef4\u6c34\u7684\u5750\u6807\uff0cy\u8868\u793a\u6c34\u6ef4\u7684\u9ad8\u5ea6\uff0cx\u8868\u793a\u5b83\u4e0b\u843d\u5230x\u8f74\u7684\u4f4d\u7f6e\u3002 \u6bcf\u6ef4\u6c34\u4ee5\u6bcf\u79d21\u4e2a\u5355\u4f4d\u957f\u5ea6\u7684\u901f\u5ea6\u4e0b\u843d\u3002\u4f60\u9700\u8981\u628a\u82b1\u76c6\u653e\u5728x\u8f74\u4e0a\u7684\u67d0\u4e2a\u4f4d\u7f6e\uff0c\u4f7f\u5f97\u4ece\u88ab\u82b1\u76c6\u63a5\u7740\u7684\u7b2c1\u6ef4\u6c34\u5f00\u59cb\uff0c\u5230\u88ab\u82b1\u76c6\u63a5\u7740\u7684\u6700\u540e1\u6ef4\u6c34\u7ed3\u675f\uff0c\u4e4b\u95f4\u7684\u65f6\u95f4\u5dee\u81f3\u5c11\u4e3aD\u3002 \u6211\u4eec\u8ba4\u4e3a\uff0c\u53ea\u8981\u6c34\u6ef4\u843d\u5230x\u8f74\u4e0a\uff0c\u4e0e\u82b1\u76c6\u7684\u8fb9\u6cbf\u5bf9\u9f50\uff0c\u5c31\u8ba4\u4e3a\u88ab\u63a5\u4f4f\u3002\u7ed9\u51faN\u6ef4\u6c34\u7684\u5750\u6807\u548cD\u7684\u5927\u5c0f\uff0c\u8bf7\u7b97\u51fa\u6700\u5c0f\u7684\u82b1\u76c6\u7684\u5bbd\u5ea6W\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_4","text":"\u7b2c\u4e00\u884c2\u4e2a\u6574\u6570 N \u548c D\u3002 \u7b2c2.. N+1\u884c\u6bcf\u884c2\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6c34\u6ef4\u7684\u5750\u6807(x,y)\u3002 1 \u2264 N \u2264 100000\uff0c1 \u2264 D \u2264 1000000\uff0c0\u2264x,y\u2264106\u3002","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_5","text":"\u4ec5\u4e00\u884c1\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6700\u5c0f\u7684\u82b1\u76c6\u7684\u5bbd\u5ea6\u3002\u5982\u679c\u65e0\u6cd5\u6784\u9020\u51fa\u8db3\u591f\u5bbd\u7684\u82b1\u76c6\uff0c\u4f7f\u5f97\u5728D\u5355\u4f4d\u7684\u65f6\u95f4\u63a5\u4f4f\u6ee1\u8db3\u8981\u6c42\u7684\u6c34\u6ef4\uff0c\u5219\u8f93\u51fa-1\u3002","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_6","text":"4 5 6 3 2 4 4 10 12 15","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_7","text":"2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_8","text":"\u67094\u6ef4\u6c34\uff0c (6,3), (2,4), (4,10), (12,15).\u6c34\u6ef4\u5fc5\u987b\u7528\u81f3\u5c115\u79d2\u65f6\u95f4\u843d\u5165\u82b1\u76c6\u3002\u82b1\u76c6\u7684\u5bbd\u5ea6\u4e3a2\u662f\u5fc5\u987b\u4e14\u8db3\u591f\u7684\u3002\u628a\u82b1\u76c6\u653e\u5728x=4..6\u7684\u4f4d\u7f6e\uff0c\u5b83\u53ef\u4ee5\u63a5\u52301\u548c3\u6c34\u6ef4, \u4e4b\u95f4\u7684\u65f6\u95f4\u5dee\u4e3a10-3 = 7\u6ee1\u8db3\u6761\u4ef6\u3002","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_9","text":"\u5355\u8c03\u6808\uff0c\u7ef4\u62a4\u5355\u8c03\u4e0a\u5347\u7684y\uff0c\u7136\u540e\u6c42x\u4e4b\u5dee\u7684\u6700\u5c0f\u503c\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_10","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; struct node { int x , y ; bool operator < ( const node & a ) const { if ( a . x != x ) return x < a . x ; else return y < a . y ; } }; node a [ 100500 ] = { 0 }, s [ 100500 ] = { 0 }; int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d%d\" , & a [ i ]. x , & a [ i ]. y ); sort ( a + 1 , a + n + 1 ); int head = 1 , tail = 1 , ans = inf ; s [ 1 ] = a [ 1 ]; for ( int i = 2 ; i <= n ; i ++ ) { while ( tail >= head && s [ tail ]. y > a [ i ]. y ) { if ( s [ tail ]. y - a [ i ]. y >= m ) ans = min ( ans , a [ i ]. x - s [ tail ]. x ); tail -- ; } s [ ++ tail ] = a [ i ]; while ( tail >= head && s [ tail ]. y - s [ head ]. y >= m ) ans = min ( ans , s [ tail ]. x - s [ head ]. x ), head ++ ; } printf ( \"%d \\n \" , ans == inf ? -1 : ans ); }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_11","text":"Haybale Restacking","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_12","text":"Farmer John has just ordered a large number of bales of hay. He would like to organize these into N piles (1 <= N <= 100,000) arranged in a circle, where pile i contains B_i bales of hay. Unfortunately, the truck driver delivering the hay was not listening carefully when Farmer John provided this information, and only remembered to leave the hay in N piles arranged in a circle. After delivery, Farmer John notes that pile i contains A_i bales of hay. Of course, the A_i's and the B_i's have the same sum. Farmer John would like to move the bales of hay from their current configuration (described by the A_i's) into his desired target configuration (described by the B_i's). It takes him x units of work to move one hay bale from one pile to a pile that is x steps away around the circle. Please help him compute the minimum amount of work he will need to spend.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_13","text":"* Line 1: The single integer N. * Lines 2..1+N: Line i+1 contains the two integers A_i and B_i (1 <= A_i, B_i <= 1000).","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_14","text":"* Line 1:the minimum amount of work he will need to spend.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_15","text":"4 7 1 3 4 9 2 1 13","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_16","text":"13","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_17","text":"\u8bbexi\u4e3a\u7b2ci\u5806\u5e72\u8349\u4e0e\u7b2ci-1\u5806\u5e72\u8349\u7684\u4ea4\u6362\u6570 \u4ee4B[i]\u7b49\u4e8eB[i]-A[i],\u5219\u6211\u4eec\u7684\u76ee\u6807\u662f\u8ba9B[i]\u5168\u90e8\u53d8\u4e3a0 B[1]-x1+x2=0 ==> x2=x1-B[1] B[2]-x2+x3=0 ==> x3=x2-B[2]=x1-B[1]-B[2] ......xn-1=x1-B[1]-B[2]-...-B[n-1] \u800c\u6211\u4eec\u8981\u4f7f x1+x2+x3+...+xn-1 \u6700\u5c0f, \u5373|x1|+|x1-B[1]|+...+|x1-B[1]-B[2]-...-B[n-1]| \u6700\u5c0f \u6240\u4ee5x1\u8981\u7b49\u4e8eB[1],B[1]+B[2],...,B[1]+B[2]+...+B[n-1]\u7684\u4e2d\u4f4d\u6570","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_18","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; ll b [ 100500 ] = { 0 }; ll a [ 100500 ] = { 0 }; ll sum [ 100500 ] = { 0 }; int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld\" , & a [ i ], & b [ i ]); b [ i ] -= a [ i ]; sum [ i ] = sum [ i -1 ] + b [ i ]; } sort ( sum + 1 , sum + n + 1 ); ll tmp = sum [( n + 1 ) / 2 ], ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) ans += abs ( sum [ i ] - tmp ); cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_19","text":"123 Triangle","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_20","text":"You are given four positive integers x0, x1, a, b. And you know x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} for all i\u22652. Given two positive integers n, and MOD, please calculate xn modulo MOD. Does the problem look simple? Surprise! The value of n may have many many digits!","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_21","text":"The input contains two lines. The first line contains four integers x0, x1, a, b,a,b (1\u2264x0,x1,a,b\u2264109). The second line contains two integers n, MOD ( , n has no leading zero).","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_22","text":"Print one integer representing the answer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_23","text":"1 1 1 1 10 1000000001","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_24","text":"89","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_25","text":"The resulting sequence x is Fibonacci sequence. The 11-th item is 89.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_26","text":"\u9996\u5148\u662f\u5341\u8fdb\u5236\u5feb\u901f\u5e42\uff0c\u4f8b\u5982\uff1a 3^{1234}=((((ans*3^1)^{10}*3^2)^{10}*3^3)^{10}*3^4)^{10} 3^{1234}=((((ans*3^1)^{10}*3^2)^{10}*3^3)^{10}*3^4)^{10} \u7136\u540e\u662f\u77e9\u9635\u5feb\u901f\u5e42\uff0c x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} x_i=a\u22c5x_{i\u22121}+b\u22c5x_{i\u22122} \u53ef\u4ee5\u8f6c\u6362\u4e3a\uff1a $\\left( \\matrix{ a & b \\ 1& 0 } \\right) ^{n-1} * \\left(\\matrix {x1 \\ x0 } \\right) $ \u6c42\u51fa\u77e9\u9635\u53d8\u4e3a\u7b54\u6848\u3002 \u53c2\u8003\u4e0e\uff1a https://blog.csdn.net/qq_41650771/article/details/98108098","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_27","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll x0 , x1 , a , b , mod ; struct node { ll data [ 3 ][ 3 ]; void clear1 () { data [ 1 ][ 2 ] = data [ 2 ][ 1 ] = 0 ; data [ 1 ][ 1 ] = data [ 2 ][ 2 ] = 0 ; } void clear () { data [ 1 ][ 2 ] = data [ 2 ][ 1 ] = 0 ; data [ 1 ][ 1 ] = data [ 2 ][ 2 ] = 1 ; } node operator * ( const node & a ) const { node tmp ; tmp . clear1 (); for ( ll i = 1 ; i <= 2 ; i ++ ) { for ( ll j = 1 ; j <= 2 ; j ++ ) { for ( ll k = 1 ; k <= 2 ; k ++ ) { tmp . data [ i ][ j ] += data [ i ][ k ] * a . data [ k ][ j ]; tmp . data [ i ][ j ] %= mod ; } } } return tmp ; } void print () { printf ( \"%lld %lld \\n %lld %lld \\n ** \\n \" , data [ 1 ][ 1 ], data [ 1 ][ 2 ], data [ 2 ][ 1 ], data [ 2 ][ 2 ]); } }; char t [ 1005000 ] = { 0 }; node ksm ( node a , int b ) { node ans1 , ans2 = a ; ans1 . clear (); while ( b != 0 ) { if ( b % 2 ) ans1 = ans1 * ans2 ; ans2 = ans2 * ans2 ; b /= 2 ; } return ans1 ; } int main () { scanf ( \"%lld%lld%lld%lld\" , & x0 , & x1 , & a , & b ); scanf ( \"%s\" , t + 1 ); scanf ( \"%lld\" , & mod ); node tmp1 , tmp2 ; tmp2 . data [ 1 ][ 1 ] = a ; tmp2 . data [ 1 ][ 2 ] = 1 ; tmp2 . data [ 2 ][ 1 ] = b ; tmp2 . data [ 2 ][ 2 ] = 0 ; tmp1 . data [ 1 ][ 1 ] = x1 ; tmp1 . data [ 1 ][ 2 ] = x0 ; tmp1 . data [ 2 ][ 1 ] = 0 ; tmp1 . data [ 2 ][ 2 ] = 0 ; node tmp4 ; tmp4 . clear (); for ( int i = 1 ; t [ i ]; i ++ ) { tmp4 = ksm ( tmp4 , 10 ); node tmp3 = ksm ( tmp2 , t [ i ] - '0' ); tmp4 = tmp3 * tmp4 ; } tmp1 = tmp1 * tmp4 ; cout << tmp1 . data [ 1 ][ 2 ] << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#4","text":"","title":"\u9898\u76ee4"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_28","text":"XOR Game","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_29","text":"There are 2N integers written on a blackboard. The i-th integer is Ai. Alice and Bob will play a game consisting of N rounds. In each round, they do the following: First, Alice chooses an integer on the blackboard and erases it. Let x be the integer erased here. Second, Bob chooses an integer on the blackboard and erases it. Let y be the integer erased here. Finally, write the value x\u2295y on a notebook, where \u2295 denotes the bitwise XOR. In the end, all the integers on the blackboard will be erased, and the notebook will have N integers written on it. The greatest integer written on the notebook will be the score of the game. Alice wants to maximize this score, while Bob wants to minimize it. Find the score of the game when both players play optimally under their objectives. Constraints 1\u2264N\u2264 2\u00d710^5 2\u00d710^5 0\u2264Ai< 2^{30} 2^{30} All values in input are integers.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_30","text":"Input is given from Standard Input in the following format: N A1 A2 \u22ef A2N","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_31","text":"Print the answer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_32","text":"\u3010\u6837\u4f8b1\u3011 2 0 1 3 5 \u3010\u6837\u4f8b2\u3011 2 0 0 0 0 \u3010\u6837\u4f8b3\u3011 10 974654030 99760550 750234695 255777344 907989127 917878091 818948631 690392797 579845317 549202360 511962375 203530861 491981716 64663831 561104719 541423175 301832976 252317904 471905694 350223945","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_33","text":"\u3010\u6837\u4f8b1\u3011 4 \u3010\u6837\u4f8b2\u3011 0 \u3010\u6837\u4f8b3\u3011 268507123","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_34","text":"\u6837\u4f8b1\u89e3\u91ca\uff1a Below is one possible progress of the game (it may contain suboptimal choices). Round 1: Alice chooses A1=0. Bob chooses A3=3. They write 0\u22953=3 on the notebook. Round 2: Alice chooses A4=5. Bob chooses A2=1. They write 5\u22951=4 on the notebook. The score of the game is max(3,4)=4.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_35","text":"\u5b57\u5178\u6811\uff0c\u537301trai\uff0c\u7531\u4e8e\u4e00\u4e2a\u8981\u6700\u5927\u5316\u5f02\u6216\u503c\uff0c\u4e00\u4e2a\u8981\u6700\u5c0f\u5316\u5f02\u6216\u503c\uff0c\u5219\u7b54\u6848\u4e3a\u5f02\u6216\u540e\u6700\u5927\u503c\u7684\u6700\u5c0f\u503c\uff0c\u5373\u627e\u4e24\u4e2a\u6570\u4f7f\u5f97\u5176\u5f02\u6216\u503c\u6700\u5c0f\u5316\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_36","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; int tree [ 10000005 ][ 2 ] = { 0 }; int size1 [ 10000005 ] = { 0 }; int cnt = 1 ; void insert1 ( int k ) { int p = 1 ; size1 [ p ] ++ ; for ( int i = 29 ; i >= 0 ; i -- ) { int tmp = ( k & ( 1 << i )) ? 1 : 0 ; if ( tree [ p ][ tmp ] == 0 ) tree [ p ][ tmp ] =++ cnt ; p = tree [ p ][ tmp ]; size1 [ p ] ++ ; } } int solve ( int a , int b , int dp ) { if ( dp < 0 ) return 0 ; if ( size1 [ a ] == 0 || size1 [ b ] == 0 ) return inf ; ///\u5de6\u53f3\u65e0\u6cd5\u518d\u8fdb\u884c\u5339\u914d if ( a == b ) { if ( size1 [ tree [ a ][ 0 ]] % 2 == 1 ) { return solve ( tree [ a ][ 0 ], tree [ a ][ 1 ], dp -1 ) + ( 1 << dp ); } else { int tmp1 = solve ( tree [ a ][ 0 ], tree [ a ][ 0 ], dp -1 ); int tmp2 = solve ( tree [ a ][ 1 ], tree [ a ][ 1 ], dp -1 ); if ( tmp1 >= inf ) return tmp2 ; else if ( tmp2 >= inf ) return tmp1 ; else return max ( tmp1 , tmp2 ); } } else { int ans = inf ; if (( tree [ a ][ 0 ] && tree [ b ][ 0 ]) || ( tree [ a ][ 1 ] && tree [ b ][ 1 ])) { ans = min ( ans , solve ( tree [ a ][ 0 ], tree [ b ][ 0 ], dp -1 )); ans = min ( ans , solve ( tree [ a ][ 1 ], tree [ b ][ 1 ], dp -1 )); } else { ans = min ( ans , solve ( tree [ a ][ 1 ], tree [ b ][ 0 ], dp -1 ) + ( 1 << dp )); ans = min ( ans , solve ( tree [ a ][ 0 ], tree [ b ][ 1 ], dp -1 ) + ( 1 << dp )); } return ans ; } } int main () { int n , m ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= 2 * n ; i ++ ) { scanf ( \"%d\" , & m ); insert1 ( m ); } cout << solve ( 1 , 1 , 29 ) << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#5","text":"","title":"\u9898\u76ee5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_37","text":"Mountain Climbing","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_38","text":"Farmer John has discovered that his cows produce higher quality milk when they are subject to strenuous exercise. He therefore decides to send his N cows (1 <= N <= 25,000) to climb up and then back down a nearby mountain! Cow i takes U(i) time to climb up the mountain and then D(i) time to climb down the mountain. Being domesticated cows, each cow needs the help of a farmer for each leg of the climb, but due to the poor economy, there are only two farmers available, Farmer John and his cousin Farmer Don. FJ plans to guide cows for the upward climb, and FD will then guide the cows for the downward climb. Since every cow needs a guide, and there is only one farmer for each part of the voyage, at most one cow may be climbing upward at any point in time (assisted by FJ), and at most one cow may be climbing down at any point in time (assisted by FD). A group of cows may temporarily accumulate at the top of the mountain if they climb up and then need to wait for FD's assistance before climbing down. Cows may climb down in a different order than they climbed up. Please determine the least possible amount of time for all N cows to make the entire journey.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_39","text":"* Line 1: The number of cows, N. * Lines 2..1+N: Line i+1 contains two space-separated integers: U(i) and D(i). (1 <= U(i), D(i) <= 50,000).","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_40","text":"* Line 1: A single integer representing the least amount of time for all the cows to cross the mountain.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_41","text":"3 6 4 8 1 2 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_42","text":"17","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_43","text":"\u4e8c\u7ea7\u8f66\u95f4\u8c03\u5ea6\u95ee\u9898\uff0c\u8d2a\u5fc3\uff0c\u8ba9\u4e0b\u5c71\u6bd4\u4e0a\u5c71\u5feb\u7684\u5148\u4e0a\uff0c\u7136\u540e\u5728\u8d2a\u5fc3\u7684\u7f29\u77ed\u4e0a\u5c71\u65f6\u95f4\u548c\u6269\u5927\u4e0b\u5c71\u65f6\u95f4\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_44","text":"#include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; struct node { ll u , d , sum , sum1 ; }; bool cmp ( node a , node b ) { if ( a . d > a . u && b . d <= b . u ) ///\u4e0b\u7684\u6162\u7684\u4f18\u5148 return 1 ; else if ( a . d <= a . u && b . d > b . u ) return 0 ; else if ( a . d > a . u ) return a . u < b . u ; ///\u4e0a\u7684\u5feb\u7684\u4f18\u5148 else return a . d > b . d ; ///\u4e0b\u7684\u6162\u7684\u4f18\u5148 } node a [ 25500 ] = { 0 }; int main () { ll n ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld%lld\" , & a [ i ]. u , & a [ i ]. d ); sort ( a + 1 , a + n + 1 , cmp ); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) a [ i ]. sum = a [ i -1 ]. sum + a [ i ]. u ; for ( ll i = 1 ; i <= n ; i ++ ) { a [ i ]. sum1 = max ( a [ i ]. sum , a [ i -1 ]. sum1 ) + a [ i ]. d ; ans = max ( ans , a [ i ]. sum1 ); } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#6","text":"","title":"\u9898\u76ee6"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_45","text":"Tower","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_46","text":"There are N blocks, numbered 1,2,\u2026,N. For each i (1\u2264i\u2264N), Block i has a weight of wi, a solidness of si and a value of vi. Taro has decided to build a tower by choosing some of the N blocks and stacking them vertically in some order. Here, the tower must satisfy the following condition: For each Block i contained in the tower, the sum of the weights of the blocks stacked above it is not greater than si. Find the maximum possible sum of the values of the blocks contained in the tower. Constraints All values in input are integers. 1\u2264N\u2264 10^3 10^3 1\u2264wi,si\u2264 10^4 10^4 1\u2264vi\u2264 10^9 10^9","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_47","text":"Input is given from Standard Input in the following format: N w1 s1 v1 w2 s2 v2 : wN sN vN","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_48","text":"Print the maximum possible sum of the values of the blocks contained in the tower.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_49","text":"\u3010 \u6837\u4f8b1 \u3011 3 2 2 20 2 1 30 3 1 40 \u3010 \u6837\u4f8b2 \u3011 4 1 2 10 3 1 10 2 4 10 1 6 10 \u3010 \u6837\u4f8b3 \u3011 5 1 10000 1000000000 1 10000 1000000000 1 10000 1000000000 1 10000 1000000000 1 10000 1000000000 \u3010 \u6837\u4f8b4 \u3011 8 9 5 7 6 2 7 5 7 3 7 8 8 1 9 6 3 3 3 4 1 7 4 5 5","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_50","text":"\u3010\u6837\u4f8b1\u3011 50 \u3010\u6837\u4f8b2\u3011 40 \u3010\u6837\u4f8b3\u3011 5000000000 \u3010\u6837\u4f8b4\u3011 22","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_51","text":"\u6837\u4f8b1\u89e3\u91ca\uff1aIf Blocks 2,1 are stacked in this order from top to bottom, this tower will satisfy the condition, with the total value of 30+20=50. \u6837\u4f8b2\u89e3\u91ca\uff1aBlocks 1,2,3,4 should be stacked in this order from top to bottom. \u6837\u4f8b3\u89e3\u91ca\uff1aThe answer may not fit into a 32-bit integer type. \u6837\u4f8b4\u89e3\u91ca\uff1aWe should, for example, stack Blocks 5,6,8,4 in this order from top to bottom.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_52","text":"\u9996\u5148\u8d2a\u5fc3\u6392\u5e8f\uff0c\u5bf9\u4e8ea\u548cb\u4e24\u4e2a\u7269\u54c1\uff0c\u5982\u679ca\u653e\u5728b\u4e0a\u9762\u5219\u6743\u503c\u4e3as[b]-w[a]\uff0c\u5982\u679cb\u653e\u5728a\u4e0a\u9762\uff0c\u5219\u6743\u503c\u4e3as[a]-w[b]\uff0c\u5219a\u548cb\u7684\u987a\u5e8f\u7531s[b]-w[a]\u548cs[a]-w[b]\u6240\u51b3\u5b9a\uff0c\u79fb\u9879\u53ef\u5f97\u5373\u4e3a\u6bd4\u8f83s[a]+w[a]\u548cs[b]+w[b]\uff0c\u6240\u4ee5\u6839\u636es[a]+w[a]\u7684\u5927\u5c0f\u8d2a\u5fc3\u6392\u5e8f\uff0c\u540e\u6839\u636e\u91cd\u91cf\u9650\u5236\u52a8\u6001\u89c4\u5212\uff0c\u5373\u5047\u8bbedp[i]\u4e3a\u91cd\u91cf\u4e3ai\u65f6\u7684\u6700\u5927\u6743\u503c\uff0c\u5219\u8f6c\u79fb\u65b9\u7a0b\u4e3a\uff1a dp[j+w[i]]=max(dp[j+w[i]],dp[j]+v[i])(0<=j<=s[i]) dp[j+w[i]]=max(dp[j+w[i]],dp[j]+v[i])(0<=j<=s[i])","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/#_53","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; struct node { ll w , s , v ; }; node a [ 1005 ] = { 0 }; ll dp [ 30050 ] = { 0 }; int main () { ll n ; scanf ( \"%d\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%d%d%d\" , & a [ i ]. w , & a [ i ]. s , & a [ i ]. v ); sort ( a + 1 , a + n + 1 , []( node a , node b ) { return a . s + a . w < b . s + b . w ; }); ll ans = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { for ( ll j = a [ i ]. s ; j >= 0 ; j -- ) dp [ j + a [ i ]. w ] = max ( dp [ j + a [ i ]. w ], dp [ j ] + a [ i ]. v ); } for ( ll j = 0 ; j < 30050 ; j ++ ) ans = max ( ans , dp [ j ]); cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e94\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u95ee\u9898 C: Safe Distance \u9898\u76ee\u63cf\u8ff0 \u00b6 The past year has been difficult, with a virus spreading among the population. Fortunately, Alice knows that one of the keys to be healthy is to keep a safe distance from other people. Alice is currently in a closed room, represented in the 2D plane, with width X and height Y. There are N other people inside the room, and we\u2019re given their (xi, yi) coordinates. We consider Alice and the N people as points in the 2D plane. Alice\u2019s initial position is (0, 0) and she wants to move to the exit at position (X, Y). She can move freely in any direction inside the room,but can not step outside the room bounds. Find the maximum distance Alice can keep from other people while moving from (0, 0) to (X, Y). \u8f93\u5165 \u00b6 The input begins with one line containing two space-separated integers, X and Y, where X is the width, and Y is the height of the room. The second line consists of a single integer N, the number of people in the room. Then N lines follow, each of them consisting of two floating-point numbers xi and yi, the coordinates of the ith person in the room. \u2022 1\u2264X, Y\u22641 000 000 \u2022 1\u2264N\u22641 000 \u2022 0\u2264xi\u2264X \u2022 0\u2264yi\u2264Y \u8f93\u51fa \u00b6 The output consists of a single value d, the maximum safe distance, as a floating-point number. An additive or multiplicative error of 10\u22125 is tolerated: if d is the answer, any number either within [d \u2212 10^{\u22125} 10^{\u22125} ; d + 10^{\u22125} 10^{\u22125} ] or within [(1 \u2212 10^{\u22125} 10^{\u22125} )d; (1 + 10^{\u22125} 10^{\u22125} )d] is accepted. \u6837\u4f8b\u8f93\u5165 \u00b6 8 6 3 3 1 3 5.5 6.5 1.5 \u6837\u4f8b\u8f93\u51fa \u00b6 2.250000 \u63d0\u793a \u00b6 Alice can keep a distance of 2.25 from every other person, and this is the best she can do. The picture below shows a possible path (in green). \u9898\u89e3 \u00b6 \u5e76\u67e5\u96c6\u9898\u76ee\uff0c\u5c06\u5de6\u548c\u4e0a\u9762\u7684\u4e24\u6761\u8fb9\u770b\u4f5c\u8d77\u70b9\uff0c\u5c06\u53f3\u548c\u4e0b\u9762\u7684\u4e24\u6761\u8fb9\u770b\u4f5c\u7ec8\u70b9\uff0c\u5982\u679c\u8d77\u70b9\u548c\u7ec8\u70b9\u76f8\u4e92\u8fde\u901a\uff0c\u5219S\u548cF\u70b9\u5c06\u65e0\u6cd5\u8fde\u901a\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int from , to ; double val ; }; vector < node > v ; int fa [ 100500 ] = { 0 }; double xx [ 100500 ] = { 0 }, yy [ 100500 ] = { 0 }; int findfa ( int x ) { if ( x == fa [ x ]) return x ; return fa [ x ] = findfa ( fa [ x ]); } bool cmp ( node a , node b ) { return a . val < b . val ; } int main () { double x , y ; scanf ( \"%lf%lf\" , & x , & y ); int n ; scanf ( \"%d\" , & n ); int s = n + 1 , e = n + 2 ; fa [ s ] = s , fa [ e ] = e ; for ( int i = 1 ; i <= n ; i ++ ) { fa [ i ] = i ; scanf ( \"%lf%lf\" , & xx [ i ], & yy [ i ]); v . push_back ({ s , i , min ( xx [ i ], y - yy [ i ])}); v . push_back ({ e , i , min ( x - xx [ i ], yy [ i ])}); for ( int j = 1 ; j < i ; j ++ ) v . push_back ({ i , j , sqrt (( xx [ i ] - xx [ j ]) * ( xx [ i ] - xx [ j ]) + ( yy [ i ] - yy [ j ]) * ( yy [ i ] - yy [ j ])) / 2.0 }); } sort ( v . begin (), v . end (), cmp ); for ( int i = 0 ; i < v . size (); i ++ ) { int fx = findfa ( v [ i ]. from ); int fy = findfa ( v [ i ]. to ); if ( fx == fy ) continue ; fa [ fx ] = fy ; if ( findfa ( s ) == findfa ( e )) { printf ( \"%.8f \\n \" , v [ i ]. val ); return 0 ; } } }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e94\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u4e94\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_2","text":"\u95ee\u9898 C: Safe Distance","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_3","text":"The past year has been difficult, with a virus spreading among the population. Fortunately, Alice knows that one of the keys to be healthy is to keep a safe distance from other people. Alice is currently in a closed room, represented in the 2D plane, with width X and height Y. There are N other people inside the room, and we\u2019re given their (xi, yi) coordinates. We consider Alice and the N people as points in the 2D plane. Alice\u2019s initial position is (0, 0) and she wants to move to the exit at position (X, Y). She can move freely in any direction inside the room,but can not step outside the room bounds. Find the maximum distance Alice can keep from other people while moving from (0, 0) to (X, Y).","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_4","text":"The input begins with one line containing two space-separated integers, X and Y, where X is the width, and Y is the height of the room. The second line consists of a single integer N, the number of people in the room. Then N lines follow, each of them consisting of two floating-point numbers xi and yi, the coordinates of the ith person in the room. \u2022 1\u2264X, Y\u22641 000 000 \u2022 1\u2264N\u22641 000 \u2022 0\u2264xi\u2264X \u2022 0\u2264yi\u2264Y","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_5","text":"The output consists of a single value d, the maximum safe distance, as a floating-point number. An additive or multiplicative error of 10\u22125 is tolerated: if d is the answer, any number either within [d \u2212 10^{\u22125} 10^{\u22125} ; d + 10^{\u22125} 10^{\u22125} ] or within [(1 \u2212 10^{\u22125} 10^{\u22125} )d; (1 + 10^{\u22125} 10^{\u22125} )d] is accepted.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_6","text":"8 6 3 3 1 3 5.5 6.5 1.5","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_7","text":"2.250000","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_8","text":"Alice can keep a distance of 2.25 from every other person, and this is the best she can do. The picture below shows a possible path (in green).","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_9","text":"\u5e76\u67e5\u96c6\u9898\u76ee\uff0c\u5c06\u5de6\u548c\u4e0a\u9762\u7684\u4e24\u6761\u8fb9\u770b\u4f5c\u8d77\u70b9\uff0c\u5c06\u53f3\u548c\u4e0b\u9762\u7684\u4e24\u6761\u8fb9\u770b\u4f5c\u7ec8\u70b9\uff0c\u5982\u679c\u8d77\u70b9\u548c\u7ec8\u70b9\u76f8\u4e92\u8fde\u901a\uff0c\u5219S\u548cF\u70b9\u5c06\u65e0\u6cd5\u8fde\u901a\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/#_10","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; struct node { int from , to ; double val ; }; vector < node > v ; int fa [ 100500 ] = { 0 }; double xx [ 100500 ] = { 0 }, yy [ 100500 ] = { 0 }; int findfa ( int x ) { if ( x == fa [ x ]) return x ; return fa [ x ] = findfa ( fa [ x ]); } bool cmp ( node a , node b ) { return a . val < b . val ; } int main () { double x , y ; scanf ( \"%lf%lf\" , & x , & y ); int n ; scanf ( \"%d\" , & n ); int s = n + 1 , e = n + 2 ; fa [ s ] = s , fa [ e ] = e ; for ( int i = 1 ; i <= n ; i ++ ) { fa [ i ] = i ; scanf ( \"%lf%lf\" , & xx [ i ], & yy [ i ]); v . push_back ({ s , i , min ( xx [ i ], y - yy [ i ])}); v . push_back ({ e , i , min ( x - xx [ i ], yy [ i ])}); for ( int j = 1 ; j < i ; j ++ ) v . push_back ({ i , j , sqrt (( xx [ i ] - xx [ j ]) * ( xx [ i ] - xx [ j ]) + ( yy [ i ] - yy [ j ]) * ( yy [ i ] - yy [ j ])) / 2.0 }); } sort ( v . begin (), v . end (), cmp ); for ( int i = 0 ; i < v . size (); i ++ ) { int fx = findfa ( v [ i ]. from ); int fy = findfa ( v [ i ]. to ); if ( fx == fy ) continue ; fa [ fx ] = fy ; if ( findfa ( s ) == findfa ( e )) { printf ( \"%.8f \\n \" , v [ i ]. val ); return 0 ; } } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u56db\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u95ee\u9898 F: Fair Distribution \u9898\u76ee\u63cf\u8ff0 \u00b6 There are n robots and m energy bars in the Dream Kingdom. DreamGrid, the king, is trying to make a fair distribution of the energy bars. A fair distribution exists if and only if the number of the energy bars is a multiple of the number of robots. The only tool DreamGrid has is a powerful laser gun. Every time he turns on the laser gun, he can do exactly one of the two things: Create a new energy bar. Destroy a robot. To avoid the extinction of robots, it's forbidden to destroy all the n robots. It takes one dollar to turn on the laser gun once. You are asked to find the minimum cost of making a fair distribution. \u8f93\u5165 \u00b6 There are multiple test cases. The first line of the input contains an integer T (1\u2264T\u22641000), indicating the number of test cases. For each test case: The only line contains two integers n and m (1\u2264n,m\u2264108), indicating the initial number of robots and energy bars. \u8f93\u51fa \u00b6 For each test case output one line containing an integer, indicating the minimum cost to get a fair distribution. \u6837\u4f8b\u8f93\u5165 \u00b6 3 3 12 10 6 8 20 \u6837\u4f8b\u8f93\u51fa \u00b6 0 4 2 \u63d0\u793a \u00b6 For the third sample, the best way is to destroy a robot and create an energy bar. After that, we have 7 robots and 21 energy bars, which leads to a fair distribution. \u9898\u89e3 \u00b6 \u679a\u4e3e\u673a\u5668\u4eba\u5c11\u4e86x\u4e2a\uff0c\u5219\u53ef\u5f97\u5f53\u524d\u7684\u7b54\u6848\uff1a n-(n-x)+(\\frac{m+n-x-1}{n-x})*(n-x)-m=n-m+\\frac{m-1}{n-x}*(n-x) n-(n-x)+(\\frac{m+n-x-1}{n-x})*(n-x)-m=n-m+\\frac{m-1}{n-x}*(n-x) \u5176\u4e2d \\frac{m-1}{n-x}*(n-x) \\frac{m-1}{n-x}*(n-x) \u53ef\u4ee5\u7531\u6574\u6570\u5206\u5757\u5f97\u5230\uff0c\u7c7b\u4f3c\u4e8e \\sum{\\frac{n}{i}} \\sum{\\frac{n}{i}} \uff0c\u6700\u540e\u7edf\u8ba1\u7b54\u6848\u53d6\u6700\u5c0f\u503c\u5373\u53ef\u3002 \u53c2\u8003\u535a\u5ba2\uff1a https://blog.csdn.net/qq_50377393/article/details/119151746 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); if ( n >= m ) { printf ( \"%d \\n \" , n - m ); continue ; } int ans = 0x3f3f3f3f ; for ( int l = 1 , r ; l <= n ; l = r + 1 ) { r = min ( n , ( m - 1 ) / (( m - 1 ) / l )); ans = min ( ans , n - m + ( m - 1 ) / l * l ); } printf ( \"%d \\n \" , ans ); } }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u56db\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\u56db\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_2","text":"\u95ee\u9898 F: Fair Distribution","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_3","text":"There are n robots and m energy bars in the Dream Kingdom. DreamGrid, the king, is trying to make a fair distribution of the energy bars. A fair distribution exists if and only if the number of the energy bars is a multiple of the number of robots. The only tool DreamGrid has is a powerful laser gun. Every time he turns on the laser gun, he can do exactly one of the two things: Create a new energy bar. Destroy a robot. To avoid the extinction of robots, it's forbidden to destroy all the n robots. It takes one dollar to turn on the laser gun once. You are asked to find the minimum cost of making a fair distribution.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_4","text":"There are multiple test cases. The first line of the input contains an integer T (1\u2264T\u22641000), indicating the number of test cases. For each test case: The only line contains two integers n and m (1\u2264n,m\u2264108), indicating the initial number of robots and energy bars.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_5","text":"For each test case output one line containing an integer, indicating the minimum cost to get a fair distribution.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_6","text":"3 3 12 10 6 8 20","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_7","text":"0 4 2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_8","text":"For the third sample, the best way is to destroy a robot and create an energy bar. After that, we have 7 robots and 21 energy bars, which leads to a fair distribution.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_9","text":"\u679a\u4e3e\u673a\u5668\u4eba\u5c11\u4e86x\u4e2a\uff0c\u5219\u53ef\u5f97\u5f53\u524d\u7684\u7b54\u6848\uff1a n-(n-x)+(\\frac{m+n-x-1}{n-x})*(n-x)-m=n-m+\\frac{m-1}{n-x}*(n-x) n-(n-x)+(\\frac{m+n-x-1}{n-x})*(n-x)-m=n-m+\\frac{m-1}{n-x}*(n-x) \u5176\u4e2d \\frac{m-1}{n-x}*(n-x) \\frac{m-1}{n-x}*(n-x) \u53ef\u4ee5\u7531\u6574\u6570\u5206\u5757\u5f97\u5230\uff0c\u7c7b\u4f3c\u4e8e \\sum{\\frac{n}{i}} \\sum{\\frac{n}{i}} \uff0c\u6700\u540e\u7edf\u8ba1\u7b54\u6848\u53d6\u6700\u5c0f\u503c\u5373\u53ef\u3002 \u53c2\u8003\u535a\u5ba2\uff1a https://blog.csdn.net/qq_50377393/article/details/119151746","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/#_10","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); if ( n >= m ) { printf ( \"%d \\n \" , n - m ); continue ; } int ans = 0x3f3f3f3f ; for ( int l = 1 , r ; l <= n ; l = r + 1 ) { r = min ( n , ( m - 1 ) / (( m - 1 ) / l )); ans = min ( ans , n - m + ( m - 1 ) / l * l ); } printf ( \"%d \\n \" , ans ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Multiple Sequences \u9898\u76ee\u63cf\u8ff0 \u00b6 Given are integers N and M. How many sequences A of N integers satisfy the following conditions? 1\u2264Ai\u2264M(i=1,2,\u2026,N) Ai+1 is a multiple of Ai. (i=1,2,\u2026,N\u22121) Since the answer can be enormous, report it modulo 998244353. Constraints All values in input are integers. 1\u2264N\u22642\u00d7 10^5 10^5 1\u2264M\u22642\u00d7 10^5 10^5 \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N M \u8f93\u51fa \u00b6 Print the answer. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 3 4 \u3010\u6837\u4f8b2\u3011 20 30 \u3010\u6837\u4f8b3\u3011 200000 200000 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 13 \u3010\u6837\u4f8b2\u3011 71166 \u3010\u6837\u4f8b3\u3011 835917264 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca Some of the sequences A satisfying the conditions follow: A=(1,1,4) A=(3,3,3) A=(1,2,4) \u9898\u89e3 \u00b6 \u6392\u5217\u7ec4\u5408+\u8d28\u56e0\u6570\u5206\u89e3\uff0c\u679a\u4e3eAn\u7684\u53d6\u503c\u8303\u56f4\uff0c\u53731-m\uff0c\u540e\u5bf9An\u8fdb\u884c\u8d28\u56e0\u6570\u5206\u89e3\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u56e0\u5b50p\uff0c\u8bbe\u5176\u4e3ae\u6b21\u5e42\uff0c\u5219\u5bf9\u4e8ep\u56e0\u5b50\uff0c\u53ef\u4ee5\u653e\u5728n\u4e2a\u4f4d\u7f6e\u4e0a\uff0c\u6a21\u578b\u8f6c\u4e3a\u5c06e\u4e2a\u5c0f\u7403\u653e\u5230n\u4e2a\u76d2\u5b50\u4e2d\u4e14\u76d2\u5b50\u53ef\u4ee5\u4e3a\u7a7a\uff0c\u5219\u7b54\u6848\u4e3a$ \\tbinom{n+e-1}{e}$\u200b \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/weixin_43184669/article/details/116059248 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b % 2 ) ans1 = ( ans2 * ans1 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } ll inv [ 300500 ] = { 0 }; ll jc [ 300500 ] = { 0 }; ll C ( ll a , ll b ) { if ( a == b ) return 1 ; if ( b > a || a == 0 ) return 0 ; ll res = jc [ a ] * inv [ b ] % mod * inv [ a - b ] % mod ; return res ; } int main () { jc [ 0 ] = 1 ; for ( ll i = 1 ; i <= 300100 ; i ++ ) jc [ i ] = ( jc [ i -1 ] * i ) % mod ; inv [ 300100 ] = ksm ( jc [ 300100 ], mod -2 ); for ( ll i = 300100-1 ; i >= 1 ; i -- ) inv [ i ] = inv [ i + 1 ] * ( i + 1 ) % mod ; ll n , m , ans = 0 ; cin >> n >> m ; for ( ll i = 1 ; i <= m ; i ++ ) { vector < ll > v ; ll tmp = i ; for ( ll j = 2 ; j * j <= tmp ; j ++ ) { if ( tmp % j != 0 ) continue ; ll cnt = 0 ; while ( tmp % j == 0 ) { tmp /= j ; cnt ++ ; } v . push_back ( cnt ); } if ( tmp != 1 ) v . push_back ( 1 ); tmp = 1 ; for ( int i = 0 ; i < v . size (); i ++ ) tmp = ( tmp * C ( n + v [ i ] -1 , v [ i ])) % mod ; ans = ( ans + tmp ) % mod ; } cout << ans << endl ; } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Grass Planting \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has N barren pastures (2 <= N <= 100,000) connected by N-1 bidirectional roads, such that there is exactly one path between any two pastures. Bessie, a cow who loves her grazing time, often complains about how there is no grass on the roads between pastures. Farmer John loves Bessie very much, and today he is finally going to plant grass on the roads. He will do so using a procedure consisting of M steps (1 <= M <=100,000). At each step one of two things will happen: - FJ will choose two pastures, and plant a patch of grass along each road in between the two pastures, or, - Bessie will ask about how many patches of grass on a particular road, and Farmer John must answer her question. Farmer John is a very poor counter -- help him answer Bessie's questions! \u8f93\u5165 \u00b6 Line 1: Two space-separated integers N and M Lines 2..N: Two space-separated integers describing the endpoints of a road. Lines N+1..N+M: Line i+1 describes step i. The first character of the line is either P or Q, which describes whether or not FJ is planting grass or simply querying. This is followed by two space-separated integers A_i and B_i (1 <= A_i, B_i <= N) which describe FJ's action or query. \u8f93\u51fa \u00b6 Lines 1..???: Each line has the answer to a query, appearing in the same order as the queries appear in the input. \u6837\u4f8b\u8f93\u5165 \u00b6 4 6 1 4 2 4 3 4 P 2 3 P 1 3 Q 3 4 P 1 4 Q 2 4 Q 1 4 \u6837\u4f8b\u8f93\u51fa \u00b6 2 1 2 \u9898\u89e3 \u00b6 \u6811\u94fe\u5256\u5206\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll sum [ 400500 ] = { 0 }, lazy [ 400500 ] = { 0 }; ll dep [ 200500 ] = { 0 }, size1 [ 200500 ] = { 0 }, son [ 200500 ] = { 0 }, f [ 200500 ] = { 0 }, id [ 200500 ] = { 0 }, top [ 200500 ] = { 0 }; struct node { ll to , next ; }; node edge [ 400500 ] = { 0 }; ll head [ 400500 ] = { 0 }; ll num = 0 , cnt = 0 ; void add_edge ( ll from , ll to ) { edge [ ++ num ] = { to , head [ from ]}; head [ from ] = num ; } void dfs1 ( ll now , ll fa ) { size1 [ now ] = 1 ; for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == fa ) continue ; f [ to ] = now ; dep [ to ] = dep [ now ] + 1 ; dfs1 ( to , now ); size1 [ now ] += size1 [ to ]; if ( size1 [ to ] > size1 [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( ll now , ll fa ) { id [ now ] = ++ cnt ; top [ now ] = fa ; if ( son [ now ]) dfs2 ( son [ now ], fa ); for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == f [ now ] || to == son [ now ]) continue ; dfs2 ( to , to ); } } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t + 1 ] += lazy [ t ]; lazy [ 2 * t ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += ( mid - l + 1 ) * lazy [ t ]; sum [ 2 * t + 1 ] += ( r - mid ) * lazy [ t ]; lazy [ t ] = 0 ; } void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { lazy [ t ] += add ; sum [ t ] += add * ( R - L + 1 ); return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query ( ll t , ll l , ll r , ll L , ll R ) { if ( l <= L && R <= r ) return sum [ t ]; push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; ll ans = 0 ; if ( l <= mid ) ans += query ( 2 * t , l , r , L , mid ); if ( mid < r ) ans += query ( 2 * t + 1 , l , r , mid + 1 , R ); return ans ; } void update_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ]; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); update ( 1 , id [ fx ], id [ x ], 1 , cnt , 1 ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); update ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt , 1 ); } ll query_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ], ans = 0 ; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); ans += query ( 1 , id [ fx ], id [ x ], 1 , cnt ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); ans += query ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt ); return ans ; } int main () { ll n , m , from , to ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } f [ 1 ] = 0 , dep [ 1 ] = 1 ; dfs1 ( 1 , 0 ), dfs2 ( 1 , 1 ); char c [ 10 ]; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , c + 1 , & from , & to ); if ( c [ 1 ] == 'P' ) update_chain ( from , to ); else printf ( \"%lld \\n \" , query_chain ( from , to )); } } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Eyjafjalla \u9898\u76ee \u00b6 \u9898\u89e3 \u00b6 \u6811\u94fe\u5256\u5206\uff0c\u5c06\u6811\u4e0a\u7684\u70b9\u6620\u5c04\u4e3a\u7ebf\u6bb5\u6811\u4e2d\u7684\u70b9\uff0c\u7136\u540e\u8be2\u95ee\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; vector < ll > v [ 100500 ]; ll size1 [ 100500 ] = { 0 }, id [ 100500 ] = { 0 }, fa [ 100500 ][ 30 ] = { 0 }, dep [ 100500 ] = { 0 }, tem [ 100500 ] = { 0 }, w [ 100500 ] = { 0 }; ll cnt = 0 ; ll max1 [ 400500 ] = { 0 }, min1 [ 400500 ] = { 0 }; void dfs ( ll now , ll fa1 ) { id [ now ] = ++ cnt ; dep [ now ] = dep [ fa1 ] + 1 ; size1 [ now ] = 1 ; w [ cnt ] = tem [ now ]; fa [ now ][ 0 ] = fa1 ; for ( ll i = 1 ; ( 1 << i ) <= dep [ now ]; i ++ ) fa [ now ][ i ] = fa [ fa [ now ][ i - 1 ]][ i - 1 ]; for ( ll i = 0 ; i < v [ now ]. size (); i ++ ) { ll to = v [ now ][ i ]; if ( to == fa1 ) continue ; dfs ( to , now ); size1 [ now ] += size1 [ to ]; } } bool check ( ll x , ll l , ll r ) { if ( x <= r && x >= l ) return 1 ; return 0 ; } void push_up ( ll t ) { min1 [ t ] = min ( min1 [ 2 * t ], min1 [ 2 * t + 1 ]); max1 [ t ] = max ( max1 [ 2 * t ], max1 [ 2 * t + 1 ]); } void build ( ll t , ll l , ll r ) { if ( l == r ) { max1 [ t ] = min1 [ t ] = w [ l ]; return ; } ll mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); push_up ( t ); } ll query_sum ( ll t , ll l , ll r , ll L , ll R , ll lt , ll rt ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( min1 [ t ] > rt || max1 [ t ] < lt ) return 0 ; else if ( l <= L && R <= r ) { if ( check ( max1 [ t ], lt , rt ) && check ( min1 [ t ], lt , rt )) return R - L + 1 ; } ll mid = ( L + R ) / 2 , sum = 0 ; if ( l <= mid ) sum += query_sum ( 2 * t , l , r , L , mid , lt , rt ); if ( mid < r ) sum += query_sum ( 2 * t + 1 , l , r , mid + 1 , R , lt , rt ); return sum ; } int main () { ll n , from , to ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i < n ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); v [ from ]. push_back ( to ); v [ to ]. push_back ( from ); } for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & tem [ i ]); dfs ( 1 , 0 ); build ( 1 , 1 , n ); ll x , l , r , q ; scanf ( \"%lld\" , & q ); for ( ll i = 1 ; i <= q ; i ++ ) { scanf ( \"%lld%lld%lld\" , & x , & l , & r ); if ( ! check ( tem [ x ], l , r )) { puts ( \"0\" ); continue ; } for ( int i = 21 ; i >= 0 ; i -- ) { int fa1 = fa [ x ][ i ]; if ( fa1 != 0 ) { if ( check ( tem [ fa1 ], l , r )) x = fa1 ; } } printf ( \"%lld \\n \" , query_sum ( 1 , id [ x ], id [ x ] + size1 [ x ] - 1 , 1 , n , l , r )); } } \u9898\u76ee4 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Simplifying the Farm \u9898\u76ee\u63cf\u8ff0 \u00b6 Farmer John has been taking an evening algorithms course at his local university, and he has just learned about minimum spanning trees. However, Farmer John now realizes that the design of his farm is not as efficient as it could be, and he wants to simplify the layout of his farm. The farm is currently arranged like a graph, with vertices representing fields and edges representing pathways between these fields, each having an associated length. Farmer John notes that for each distinct length, at most three pathways on his farm share this length. FJ would like to remove some of the pathways on his farm so that it becomes a tree -- that is, so that there is one unique route between any pair of fields. Moreover, Farmer John would like this to be a minimum spanning tree -- a tree having the smallest possible sum of edge lengths. Help Farmer John compute not only the sum of edge lengths in a minimum spanning tree derived from his farm graph, but also the number of different possible minimum spanning trees he can create. \u8f93\u5165 \u00b6 Line 1: Two integers N and M (1 <= N <= 40,000; 1 <= M <= 100,000), representing the number of vertices and edges in the farm graph, respectively. Vertices are numbered as 1..N. Lines 2..M+1: Three integers a_i, b_i and n_i (1 <= a_i, b_i <= N; 1<= n_i <= 1,000,000) representing an edge from vertex a_i to b_i with length n_i. No edge length n_i will occur more than three times. \u8f93\u51fa \u00b6 Line 1: Two integers representing the length of the minimal spanning tree and the number of minimal spanning trees (mod 1,000,000,007). \u6837\u4f8b\u8f93\u5165 \u00b6 4 5 1 2 1 3 4 1 1 3 2 1 4 2 2 3 2 \u6837\u4f8b\u8f93\u51fa \u00b6 4 3 \u63d0\u793a \u00b6 Picking both edges with length 1 and any edge with length 2 yields a minimum spanning tree of length 4. \u9898\u89e3 \u00b6 \u6700\u5c0f\u751f\u6210\u6811\uff0c\u5206\u7c7b\u8ba8\u8bba\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; struct node { int from , to , val ; }; node a [ 100500 ] = { 0 }; bool cmp ( node a , node b ) { return a . val < b . val ; } int fa [ 100500 ] = { 0 }; int findfa ( int n ) { if ( n == fa [ n ]) return n ; return fa [ n ] = findfa ( fa [ n ]); } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) scanf ( \"%d%d%d\" , & a [ i ]. from , & a [ i ]. to , & a [ i ]. val ); for ( int i = 1 ; i <= n ; i ++ ) fa [ i ] = i ; sort ( a + 1 , a + m + 1 , cmp ); ll ans = 0 , sum = 1 ; for ( int i = 1 ; i <= m ;) { int cnt = 0 , num = 0 ; set < pair < int , int >> s ; int j ; for ( j = i ; a [ j ]. val == a [ i ]. val && j <= m ; j ++ ) { int fx = findfa ( a [ j ]. from ); int fy = findfa ( a [ j ]. to ); if ( fx > fy ) swap ( fx , fy ); if ( fx != fy ) { cnt ++ ; s . insert ({ fx , fy }); } } for (; i < j ; i ++ ) { int fx = findfa ( a [ i ]. from ); int fy = findfa ( a [ i ]. to ); if ( fx != fy ) { num ++ ; fa [ fx ] = fy ; ans += a [ i ]. val ; } } if ( num == 1 ) { sum = sum * cnt % mod ; } else if ( num == 2 ) { if ( cnt == 3 && s . size () == 2 ) sum = sum * 2 % mod ; else if ( cnt == 3 && s . size () == 3 ) sum = sum * 3 % mod ; } } cout << ans << ' ' << sum << endl ; } \u9898\u76ee5 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 GCD Game \u9898\u76ee\u63cf\u8ff0 \u00b6 Alice and Bob are playing a game. They take turns to operate. There are n numbers, a1 , a2 , ... , an. Every time, the player plays in 3 steps. 1.Arbitrarily chooses one number ai. 2.Arbitrarily chooses another number x(1\u2264x<ai). 3.Replace the number ai with gcd(ai,x). Here, gcd(u,v) refers to the Greatest Common Divisor of u and v. When a player can not make a single move he/she loses the game. Alice moves the first and she asks you to tell her who will win the game if both player play optimally. \u8f93\u5165 \u00b6 The first line contains a number T(1\u2264T\u2264100), the number of testcases. For each testcase, there are two lines. The first line contains one number n(1\u2264n\u2264 10^6 10^6 ). The second line contains n numbers a1 , a2 , ... , an(1\u2264ai\u2264 10^7 10^7 ). It is guaranteed that for all testcases, \u2211n\u2264 10^6 10^6 \u200b. \u8f93\u51fa \u00b6 Line 1: Two integers representing the length of the minimal spanning tree and the number of minimal spanning trees (mod 1,000,000,007). \u6837\u4f8b\u8f93\u5165 \u00b6 2 1 1 1 2 \u6837\u4f8b\u8f93\u51fa \u00b6 Bob Alice \u9898\u89e3 \u00b6 \u5c3c\u5c14\u535a\u5f08\u53d8\u5f62\uff0c\u6c42\u89e3\u8d28\u56e0\u6570\u7684\u4e2a\u6570\u3002 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; const ll maxn = 1e7 + 5 ; ll low_prime [ 10050000 ] = { 0 }; ll prime [ 700500 ] = { 0 }; ll cnt = 0 ; int main () { for ( ll i = 2 ; i <= maxn ; i ++ ) { if ( low_prime [ i ] == 0 ) { low_prime [ i ] = i ; prime [ ++ cnt ] = i ; } for ( ll j = 1 ; j <= cnt && prime [ j ] * i <= maxn ; j ++ ) { low_prime [ prime [ j ] * i ] = prime [ j ]; if ( i % prime [ j ] == 0 ) break ; } } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , flag = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { ll m , sum = 0 ; scanf ( \"%lld\" , & m ); while ( m > 1 ) { m /= low_prime [ m ]; sum ++ ; } flag ^= sum ; } if ( ! flag ) puts ( \"Bob\" ); else puts ( \"Alice\" ); } }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u5341\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_2","text":"Multiple Sequences","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_3","text":"Given are integers N and M. How many sequences A of N integers satisfy the following conditions? 1\u2264Ai\u2264M(i=1,2,\u2026,N) Ai+1 is a multiple of Ai. (i=1,2,\u2026,N\u22121) Since the answer can be enormous, report it modulo 998244353. Constraints All values in input are integers. 1\u2264N\u22642\u00d7 10^5 10^5 1\u2264M\u22642\u00d7 10^5 10^5","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_4","text":"Input is given from Standard Input in the following format: N M","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_5","text":"Print the answer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_6","text":"\u3010\u6837\u4f8b1\u3011 3 4 \u3010\u6837\u4f8b2\u3011 20 30 \u3010\u6837\u4f8b3\u3011 200000 200000","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_7","text":"\u3010\u6837\u4f8b1\u3011 13 \u3010\u6837\u4f8b2\u3011 71166 \u3010\u6837\u4f8b3\u3011 835917264","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_8","text":"\u6837\u4f8b1\u89e3\u91ca Some of the sequences A satisfying the conditions follow: A=(1,1,4) A=(3,3,3) A=(1,2,4)","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_9","text":"\u6392\u5217\u7ec4\u5408+\u8d28\u56e0\u6570\u5206\u89e3\uff0c\u679a\u4e3eAn\u7684\u53d6\u503c\u8303\u56f4\uff0c\u53731-m\uff0c\u540e\u5bf9An\u8fdb\u884c\u8d28\u56e0\u6570\u5206\u89e3\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u56e0\u5b50p\uff0c\u8bbe\u5176\u4e3ae\u6b21\u5e42\uff0c\u5219\u5bf9\u4e8ep\u56e0\u5b50\uff0c\u53ef\u4ee5\u653e\u5728n\u4e2a\u4f4d\u7f6e\u4e0a\uff0c\u6a21\u578b\u8f6c\u4e3a\u5c06e\u4e2a\u5c0f\u7403\u653e\u5230n\u4e2a\u76d2\u5b50\u4e2d\u4e14\u76d2\u5b50\u53ef\u4ee5\u4e3a\u7a7a\uff0c\u5219\u7b54\u6848\u4e3a$ \\tbinom{n+e-1}{e}$\u200b \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/weixin_43184669/article/details/116059248","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_10","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b % 2 ) ans1 = ( ans2 * ans1 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } ll inv [ 300500 ] = { 0 }; ll jc [ 300500 ] = { 0 }; ll C ( ll a , ll b ) { if ( a == b ) return 1 ; if ( b > a || a == 0 ) return 0 ; ll res = jc [ a ] * inv [ b ] % mod * inv [ a - b ] % mod ; return res ; } int main () { jc [ 0 ] = 1 ; for ( ll i = 1 ; i <= 300100 ; i ++ ) jc [ i ] = ( jc [ i -1 ] * i ) % mod ; inv [ 300100 ] = ksm ( jc [ 300100 ], mod -2 ); for ( ll i = 300100-1 ; i >= 1 ; i -- ) inv [ i ] = inv [ i + 1 ] * ( i + 1 ) % mod ; ll n , m , ans = 0 ; cin >> n >> m ; for ( ll i = 1 ; i <= m ; i ++ ) { vector < ll > v ; ll tmp = i ; for ( ll j = 2 ; j * j <= tmp ; j ++ ) { if ( tmp % j != 0 ) continue ; ll cnt = 0 ; while ( tmp % j == 0 ) { tmp /= j ; cnt ++ ; } v . push_back ( cnt ); } if ( tmp != 1 ) v . push_back ( 1 ); tmp = 1 ; for ( int i = 0 ; i < v . size (); i ++ ) tmp = ( tmp * C ( n + v [ i ] -1 , v [ i ])) % mod ; ans = ( ans + tmp ) % mod ; } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_11","text":"Grass Planting","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_12","text":"Farmer John has N barren pastures (2 <= N <= 100,000) connected by N-1 bidirectional roads, such that there is exactly one path between any two pastures. Bessie, a cow who loves her grazing time, often complains about how there is no grass on the roads between pastures. Farmer John loves Bessie very much, and today he is finally going to plant grass on the roads. He will do so using a procedure consisting of M steps (1 <= M <=100,000). At each step one of two things will happen: - FJ will choose two pastures, and plant a patch of grass along each road in between the two pastures, or, - Bessie will ask about how many patches of grass on a particular road, and Farmer John must answer her question. Farmer John is a very poor counter -- help him answer Bessie's questions!","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_13","text":"Line 1: Two space-separated integers N and M Lines 2..N: Two space-separated integers describing the endpoints of a road. Lines N+1..N+M: Line i+1 describes step i. The first character of the line is either P or Q, which describes whether or not FJ is planting grass or simply querying. This is followed by two space-separated integers A_i and B_i (1 <= A_i, B_i <= N) which describe FJ's action or query.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_14","text":"Lines 1..???: Each line has the answer to a query, appearing in the same order as the queries appear in the input.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_15","text":"4 6 1 4 2 4 3 4 P 2 3 P 1 3 Q 3 4 P 1 4 Q 2 4 Q 1 4","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_16","text":"2 1 2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_17","text":"\u6811\u94fe\u5256\u5206\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_18","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll sum [ 400500 ] = { 0 }, lazy [ 400500 ] = { 0 }; ll dep [ 200500 ] = { 0 }, size1 [ 200500 ] = { 0 }, son [ 200500 ] = { 0 }, f [ 200500 ] = { 0 }, id [ 200500 ] = { 0 }, top [ 200500 ] = { 0 }; struct node { ll to , next ; }; node edge [ 400500 ] = { 0 }; ll head [ 400500 ] = { 0 }; ll num = 0 , cnt = 0 ; void add_edge ( ll from , ll to ) { edge [ ++ num ] = { to , head [ from ]}; head [ from ] = num ; } void dfs1 ( ll now , ll fa ) { size1 [ now ] = 1 ; for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == fa ) continue ; f [ to ] = now ; dep [ to ] = dep [ now ] + 1 ; dfs1 ( to , now ); size1 [ now ] += size1 [ to ]; if ( size1 [ to ] > size1 [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( ll now , ll fa ) { id [ now ] = ++ cnt ; top [ now ] = fa ; if ( son [ now ]) dfs2 ( son [ now ], fa ); for ( ll i = head [ now ]; i ; i = edge [ i ]. next ) { ll to = edge [ i ]. to ; if ( to == f [ now ] || to == son [ now ]) continue ; dfs2 ( to , to ); } } void push_down ( ll t , ll l , ll r ) { if ( lazy [ t ] == 0 ) return ; lazy [ 2 * t + 1 ] += lazy [ t ]; lazy [ 2 * t ] += lazy [ t ]; ll mid = ( l + r ) / 2 ; sum [ 2 * t ] += ( mid - l + 1 ) * lazy [ t ]; sum [ 2 * t + 1 ] += ( r - mid ) * lazy [ t ]; lazy [ t ] = 0 ; } void push_up ( ll t ) { sum [ t ] = sum [ 2 * t ] + sum [ 2 * t + 1 ]; } void update ( ll t , ll l , ll r , ll L , ll R , ll add ) { if ( l <= L && R <= r ) { lazy [ t ] += add ; sum [ t ] += add * ( R - L + 1 ); return ; } push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; if ( l <= mid ) update ( 2 * t , l , r , L , mid , add ); if ( mid < r ) update ( 2 * t + 1 , l , r , mid + 1 , R , add ); push_up ( t ); } ll query ( ll t , ll l , ll r , ll L , ll R ) { if ( l <= L && R <= r ) return sum [ t ]; push_down ( t , L , R ); ll mid = ( L + R ) / 2 ; ll ans = 0 ; if ( l <= mid ) ans += query ( 2 * t , l , r , L , mid ); if ( mid < r ) ans += query ( 2 * t + 1 , l , r , mid + 1 , R ); return ans ; } void update_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ]; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); update ( 1 , id [ fx ], id [ x ], 1 , cnt , 1 ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); update ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt , 1 ); } ll query_chain ( ll x , ll y ) { ll fx = top [ x ], fy = top [ y ], ans = 0 ; while ( fx != fy ) ///\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a { if ( dep [ fx ] < dep [ fy ]) swap ( x , y ), swap ( fx , fy ); ans += query ( 1 , id [ fx ], id [ x ], 1 , cnt ); x = f [ fx ], fx = top [ x ]; ///\u8df3\u8f6c\u5230\u53e6\u4e00\u6761\u91cd\u94fe } if ( id [ x ] > id [ y ]) swap ( x , y ); ans += query ( 1 , id [ x ] + 1 , id [ y ], 1 , cnt ); return ans ; } int main () { ll n , m , from , to ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); add_edge ( from , to ); add_edge ( to , from ); } f [ 1 ] = 0 , dep [ 1 ] = 1 ; dfs1 ( 1 , 0 ), dfs2 ( 1 , 1 ); char c [ 10 ]; for ( ll i = 1 ; i <= m ; i ++ ) { scanf ( \"%s%lld%lld\" , c + 1 , & from , & to ); if ( c [ 1 ] == 'P' ) update_chain ( from , to ); else printf ( \"%lld \\n \" , query_chain ( from , to )); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_19","text":"Eyjafjalla","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_20","text":"","title":"\u9898\u76ee"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_21","text":"\u6811\u94fe\u5256\u5206\uff0c\u5c06\u6811\u4e0a\u7684\u70b9\u6620\u5c04\u4e3a\u7ebf\u6bb5\u6811\u4e2d\u7684\u70b9\uff0c\u7136\u540e\u8be2\u95ee\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_22","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; vector < ll > v [ 100500 ]; ll size1 [ 100500 ] = { 0 }, id [ 100500 ] = { 0 }, fa [ 100500 ][ 30 ] = { 0 }, dep [ 100500 ] = { 0 }, tem [ 100500 ] = { 0 }, w [ 100500 ] = { 0 }; ll cnt = 0 ; ll max1 [ 400500 ] = { 0 }, min1 [ 400500 ] = { 0 }; void dfs ( ll now , ll fa1 ) { id [ now ] = ++ cnt ; dep [ now ] = dep [ fa1 ] + 1 ; size1 [ now ] = 1 ; w [ cnt ] = tem [ now ]; fa [ now ][ 0 ] = fa1 ; for ( ll i = 1 ; ( 1 << i ) <= dep [ now ]; i ++ ) fa [ now ][ i ] = fa [ fa [ now ][ i - 1 ]][ i - 1 ]; for ( ll i = 0 ; i < v [ now ]. size (); i ++ ) { ll to = v [ now ][ i ]; if ( to == fa1 ) continue ; dfs ( to , now ); size1 [ now ] += size1 [ to ]; } } bool check ( ll x , ll l , ll r ) { if ( x <= r && x >= l ) return 1 ; return 0 ; } void push_up ( ll t ) { min1 [ t ] = min ( min1 [ 2 * t ], min1 [ 2 * t + 1 ]); max1 [ t ] = max ( max1 [ 2 * t ], max1 [ 2 * t + 1 ]); } void build ( ll t , ll l , ll r ) { if ( l == r ) { max1 [ t ] = min1 [ t ] = w [ l ]; return ; } ll mid = ( l + r ) / 2 ; build ( 2 * t , l , mid ); build ( 2 * t + 1 , mid + 1 , r ); push_up ( t ); } ll query_sum ( ll t , ll l , ll r , ll L , ll R , ll lt , ll rt ) ///l,r\u4e3a\u66f4\u65b0\u533a\u95f4\uff0cL,R\u4e3a\u7ebf\u6bb5\u6811\u533a\u95f4 { if ( min1 [ t ] > rt || max1 [ t ] < lt ) return 0 ; else if ( l <= L && R <= r ) { if ( check ( max1 [ t ], lt , rt ) && check ( min1 [ t ], lt , rt )) return R - L + 1 ; } ll mid = ( L + R ) / 2 , sum = 0 ; if ( l <= mid ) sum += query_sum ( 2 * t , l , r , L , mid , lt , rt ); if ( mid < r ) sum += query_sum ( 2 * t + 1 , l , r , mid + 1 , R , lt , rt ); return sum ; } int main () { ll n , from , to ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i < n ; i ++ ) { scanf ( \"%lld%lld\" , & from , & to ); v [ from ]. push_back ( to ); v [ to ]. push_back ( from ); } for ( ll i = 1 ; i <= n ; i ++ ) scanf ( \"%lld\" , & tem [ i ]); dfs ( 1 , 0 ); build ( 1 , 1 , n ); ll x , l , r , q ; scanf ( \"%lld\" , & q ); for ( ll i = 1 ; i <= q ; i ++ ) { scanf ( \"%lld%lld%lld\" , & x , & l , & r ); if ( ! check ( tem [ x ], l , r )) { puts ( \"0\" ); continue ; } for ( int i = 21 ; i >= 0 ; i -- ) { int fa1 = fa [ x ][ i ]; if ( fa1 != 0 ) { if ( check ( tem [ fa1 ], l , r )) x = fa1 ; } } printf ( \"%lld \\n \" , query_sum ( 1 , id [ x ], id [ x ] + size1 [ x ] - 1 , 1 , n , l , r )); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#4","text":"","title":"\u9898\u76ee4"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_23","text":"Simplifying the Farm","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_24","text":"Farmer John has been taking an evening algorithms course at his local university, and he has just learned about minimum spanning trees. However, Farmer John now realizes that the design of his farm is not as efficient as it could be, and he wants to simplify the layout of his farm. The farm is currently arranged like a graph, with vertices representing fields and edges representing pathways between these fields, each having an associated length. Farmer John notes that for each distinct length, at most three pathways on his farm share this length. FJ would like to remove some of the pathways on his farm so that it becomes a tree -- that is, so that there is one unique route between any pair of fields. Moreover, Farmer John would like this to be a minimum spanning tree -- a tree having the smallest possible sum of edge lengths. Help Farmer John compute not only the sum of edge lengths in a minimum spanning tree derived from his farm graph, but also the number of different possible minimum spanning trees he can create.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_25","text":"Line 1: Two integers N and M (1 <= N <= 40,000; 1 <= M <= 100,000), representing the number of vertices and edges in the farm graph, respectively. Vertices are numbered as 1..N. Lines 2..M+1: Three integers a_i, b_i and n_i (1 <= a_i, b_i <= N; 1<= n_i <= 1,000,000) representing an edge from vertex a_i to b_i with length n_i. No edge length n_i will occur more than three times.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_26","text":"Line 1: Two integers representing the length of the minimal spanning tree and the number of minimal spanning trees (mod 1,000,000,007).","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_27","text":"4 5 1 2 1 3 4 1 1 3 2 1 4 2 2 3 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_28","text":"4 3","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_29","text":"Picking both edges with length 1 and any edge with length 2 yields a minimum spanning tree of length 4.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_30","text":"\u6700\u5c0f\u751f\u6210\u6811\uff0c\u5206\u7c7b\u8ba8\u8bba\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_31","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 1e9 + 7 ; struct node { int from , to , val ; }; node a [ 100500 ] = { 0 }; bool cmp ( node a , node b ) { return a . val < b . val ; } int fa [ 100500 ] = { 0 }; int findfa ( int n ) { if ( n == fa [ n ]) return n ; return fa [ n ] = findfa ( fa [ n ]); } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) scanf ( \"%d%d%d\" , & a [ i ]. from , & a [ i ]. to , & a [ i ]. val ); for ( int i = 1 ; i <= n ; i ++ ) fa [ i ] = i ; sort ( a + 1 , a + m + 1 , cmp ); ll ans = 0 , sum = 1 ; for ( int i = 1 ; i <= m ;) { int cnt = 0 , num = 0 ; set < pair < int , int >> s ; int j ; for ( j = i ; a [ j ]. val == a [ i ]. val && j <= m ; j ++ ) { int fx = findfa ( a [ j ]. from ); int fy = findfa ( a [ j ]. to ); if ( fx > fy ) swap ( fx , fy ); if ( fx != fy ) { cnt ++ ; s . insert ({ fx , fy }); } } for (; i < j ; i ++ ) { int fx = findfa ( a [ i ]. from ); int fy = findfa ( a [ i ]. to ); if ( fx != fy ) { num ++ ; fa [ fx ] = fy ; ans += a [ i ]. val ; } } if ( num == 1 ) { sum = sum * cnt % mod ; } else if ( num == 2 ) { if ( cnt == 3 && s . size () == 2 ) sum = sum * 2 % mod ; else if ( cnt == 3 && s . size () == 3 ) sum = sum * 3 % mod ; } } cout << ans << ' ' << sum << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#5","text":"","title":"\u9898\u76ee5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_32","text":"GCD Game","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_33","text":"Alice and Bob are playing a game. They take turns to operate. There are n numbers, a1 , a2 , ... , an. Every time, the player plays in 3 steps. 1.Arbitrarily chooses one number ai. 2.Arbitrarily chooses another number x(1\u2264x<ai). 3.Replace the number ai with gcd(ai,x). Here, gcd(u,v) refers to the Greatest Common Divisor of u and v. When a player can not make a single move he/she loses the game. Alice moves the first and she asks you to tell her who will win the game if both player play optimally.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_34","text":"The first line contains a number T(1\u2264T\u2264100), the number of testcases. For each testcase, there are two lines. The first line contains one number n(1\u2264n\u2264 10^6 10^6 ). The second line contains n numbers a1 , a2 , ... , an(1\u2264ai\u2264 10^7 10^7 ). It is guaranteed that for all testcases, \u2211n\u2264 10^6 10^6 \u200b.","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_35","text":"Line 1: Two integers representing the length of the minimal spanning tree and the number of minimal spanning trees (mod 1,000,000,007).","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_36","text":"2 1 1 1 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_37","text":"Bob Alice","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_38","text":"\u5c3c\u5c14\u535a\u5f08\u53d8\u5f62\uff0c\u6c42\u89e3\u8d28\u56e0\u6570\u7684\u4e2a\u6570\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%8D%81%EF%BC%89/#_39","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> #define inf 0x3f3f3f3f3f3f3f3f using namespace std ; typedef long long ll ; const ll maxn = 1e7 + 5 ; ll low_prime [ 10050000 ] = { 0 }; ll prime [ 700500 ] = { 0 }; ll cnt = 0 ; int main () { for ( ll i = 2 ; i <= maxn ; i ++ ) { if ( low_prime [ i ] == 0 ) { low_prime [ i ] = i ; prime [ ++ cnt ] = i ; } for ( ll j = 1 ; j <= cnt && prime [ j ] * i <= maxn ; j ++ ) { low_prime [ prime [ j ] * i ] = prime [ j ]; if ( i % prime [ j ] == 0 ) break ; } } ll t ; scanf ( \"%lld\" , & t ); while ( t -- ) { ll n , flag = 0 ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { ll m , sum = 0 ; scanf ( \"%lld\" , & m ); while ( m > 1 ) { m /= low_prime [ m ]; sum ++ ; } flag ^= sum ; } if ( ! flag ) puts ( \"Bob\" ); else puts ( \"Alice\" ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u56db\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Reversible Cards \u9898\u76ee\u63cf\u8ff0 \u00b6 We have N cards numbered 1 to N. Each side of each card has a color represented by a positive integer. One side of Card i has a color ai, and the other side has a color bi. For each card, you can choose which side shows up. Find the maximum possible number of different colors showing up. Constraints 1\u2264N\u2264200000 1\u2264ai,bi\u2264400000 All numbers in input are integers. \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N a1 b1 a2 b2 : aN bN \u8f93\u51fa \u00b6 Print the answer. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 4 1 2 1 3 4 2 2 3 \u3010\u6837\u4f8b2\u3011 2 111 111 111 111 \u3010\u6837\u4f8b3\u3011 12 5 2 5 6 1 2 9 7 2 7 5 5 4 2 6 7 2 2 7 8 9 7 1 8 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 4 \u3010\u6837\u4f8b2\u3011 1 \u3010\u6837\u4f8b3\u3011 8 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca We can choose the sides with 1, 3, 4, 2 to have four colors. \u6837\u4f8b2\u89e3\u91ca They are painted with just one color. \u9898\u89e3 \u00b6 \u5e76\u67e5\u96c6\uff0c\u5efa\u7acb\u8fde\u901a\u5757\u3002\u5206\u4e24\u79cd\u60c5\u51b5\uff1a \u8fde\u901a\u5757\u65e0\u73af\uff0c\u4e3a\u4e00\u68f5\u6811\uff0c\u5219\u8be5\u8fde\u901a\u5757\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u5ea6\u4e3a\u70b9\u7684\u4e2a\u6570\u51cf1\uff0c\u4f8b\u59821-2\uff0c2-3\uff0c3-4\uff0c\u8fd9\u79cd\u60c5\u51b5\u7b54\u6848\u4e3a3 \u8fde\u901a\u5757\u6709\u73af\uff0c\u5219\u8be5\u8fde\u901a\u5757\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u5ea6\u4e3a\u70b9\u7684\u6570\u76ee\uff0c\u4f8b\u59821-2\uff0c2-3\uff0c3-1\uff0c\u8be5\u60c5\u51b5\u7b54\u6848\u4e3a4 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll fa [ 400500 ] = { 0 }; ll huan [ 400500 ] = { 0 }; ll sum [ 400500 ] = { 0 }; ll findfa ( ll n ) { if ( n == fa [ n ]) return n ; return fa [ n ] = findfa ( fa [ n ]); } int main () { ll n , s , e ; for ( ll i = 1 ; i <= 400000 ; i ++ ) fa [ i ] = i ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { ll x , y ; scanf ( \"%lld%lld\" , & x , & y ); ll fx = findfa ( x ); ll fy = findfa ( y ); if ( fx == fy ) huan [ fx ] = huan [ fy ] = 1 ; else fa [ fy ] = fx ; } for ( ll i = 1 ; i <= 400000 ; i ++ ) { findfa ( i ); huan [ fa [ i ]] |= huan [ i ]; sum [ fa [ i ]] ++ ; } ll ans = 0 ; for ( ll i = 1 ; i <= 400000 ; i ++ ) { if ( sum [ i ] != 0 ) { if ( huan [ i ]) ans += sum [ i ]; else ans += sum [ i ] -1 ; } } cout << ans << endl ; } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Second Large Rectangle \u9898\u76ee\u63cf\u8ff0 \u00b6 Given a N\u00d7M binary matrix. Please output the size of second large rectangle containing all \"1\". Containing all \"1\" means that the entries of the rectangle are all \"1\". A rectangle can be defined as four integers x1,y1,x2,y2 where 1\u2264x1\u2264x2\u2264N and 1\u2264y1\u2264y2\u2264M. Then, the rectangle is composed of all the cell (x, y) where x1\u2264x\u2264x2 and y1\u2264y\u2264y2. If all of the cell in the rectangle is \"1\", this is a valid rectangle. Please find out the size of the second largest rectangle, two rectangles are different if exists a cell belonged to one of them but not belonged to the other. \u8f93\u5165 \u00b6 The first line of input contains two space-separated integers N and M. Following N lines each contains M characters cij. 1\u2264N,M\u22641000 N\u00d7M\u22652 cij\u2208\"01\" \u8f93\u51fa \u00b6 Output one line containing an integer representing the answer. If there are less than 2 rectangles containning all \"1\", output \"0\". \u6837\u4f8b\u8f93\u5165 \u00b6 1 2 01 \u6837\u4f8b\u8f93\u51fa \u00b6 0 \u9898\u89e3 \u00b6 \u6784\u9020\u5217\u65b9\u5411\u7684\u524d\u7f00\u548c\uff0c\u540e\u7528\u5355\u8c03\u6808\u6c42\u51fa\u533a\u95f4\u6700\u5c0f\u503c\u548c\u533a\u95f4\u957f\u5ea6\u4e58\u79ef\u7684\u7b2c\u4e8c\u5927\u503c\u5373\u53ef\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int sum [ 2050 ][ 2050 ] = { 0 }; int a [ 2050 ][ 2050 ] = { 0 }; struct node { ll pos , val ; }; node s [ 100500 ] = { 0 }; int main () { int n , m ; scanf ( \"%d %d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) scanf ( \"%1d\" , & a [ i ][ j ]); for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ][ j ]) sum [ i ][ j ] = sum [ i - 1 ][ j ] + a [ i ][ j ]; else sum [ i ][ j ] = 0 ; } ll ans = 0 ; ll max1 = 0 , max2 = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll top = 0 ; for ( ll j = 1 ; j <= m + 1 ; j ++ ) { if ( top == 0 ) { s [ ++ top ] = { j , sum [ i ][ j ]}; } else { while ( s [ top ]. val > sum [ i ][ j ]) { ll tmp = ( ll )( j - s [ top - 1 ]. pos - 1 ) * ( ll ) s [ top ]. val ; ll tmp1 = ( ll )( j - s [ top - 1 ]. pos - 2 ) * ( ll ) s [ top ]. val ; ll tmp2 = ( ll )( j - s [ top - 1 ]. pos - 1 ) * ( ll )( s [ top ]. val - 1 ); top -- ; if ( tmp > max1 ) swap ( max1 , tmp ); if ( tmp > max2 ) swap ( max2 , tmp ); if ( tmp1 > max1 ) swap ( max1 , tmp1 ); if ( tmp1 > max2 ) swap ( max2 , tmp1 ); if ( tmp2 > max1 ) swap ( max1 , tmp2 ); if ( tmp2 > max2 ) swap ( max2 , tmp2 ); } s [ ++ top ] = { j , sum [ i ][ j ]}; } } } cout << max2 << endl ; } \u9898\u76ee3 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 Simple Math 2 \u9898\u76ee\u63cf\u8ff0 \u00b6 Given positive integers N and M, find the remainder when \u230a10^N/M\u230b \u230a10^N/M\u230b \u200b\u200b is divided by M. What is \u230ax\u230b?\u230ax\u230b denotes the greatest integer not exceeding x. For example: \u230a2.5\u230b=2 \u230a3\u230b=3 \u230a9.9999999\u230b=9 \u230a100/3\u230b=\u230a33.33...\u230b=33 Constraints 1\u2264N\u2264 10^{18} 10^{18} 1\u2264M\u226410000 \u8f93\u5165 \u00b6 Input is given from Standard Input in the following format: N a1 b1 a2 b2 : aN bN \u8f93\u51fa \u00b6 Print the answer. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 1 2 \u3010\u6837\u4f8b2\u3011 2 7 \u3010\u6837\u4f8b3\u3011 1000000000000000000 9997 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 0 \u3010\u6837\u4f8b3\u3011 9015 \u63d0\u793a \u00b6 \u6837\u4f8b1\u89e3\u91ca\uff1a We have \u230a10^\u00bd\u230b=5, so we should print the remainder when 5 is divided by 2, that is, 1. \u9898\u89e3 \u00b6 \u230a\\frac{10^N}{M}\u230b \\% m =\u230a\\frac{10^N}{M}-k*m\u230b \\% m =\u230a\\frac{10^N-k*m^2}{M}\u230b\\% m=\u230a\\frac{10^N \\% m^2}{M}\u230b\\% m \u230a\\frac{10^N}{M}\u230b \\% m =\u230a\\frac{10^N}{M}-k*m\u230b \\% m =\u230a\\frac{10^N-k*m^2}{M}\u230b\\% m=\u230a\\frac{10^N \\% m^2}{M}\u230b\\% m \u200b\u200b\u200b\u200b\u200b\u200b \u6240\u4ee5\uff0c\u53ea\u9700\u8981\u5229\u7528\u5feb\u901f\u5e42\u7b97\u6cd5\u8ba1\u7b97\u51fa $ 10 ^N \\% m^2$\u200b\u200b \u5373\u53ef \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; map < ll , ll > mp ; vector < ll > v ; int main () { ll n , m ; cin >> n >> m ; ll mod = m * m , ans1 = 1 , ans2 = 10 ; while ( n != 0 ) { if ( n % 2 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; n /= 2 ; } ll ans = ( ans1 / m + m ) % m ; cout << ans << endl ; }","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u56db\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u7cfb\u5217\u9898\u89e3\uff08\u56db\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_2","text":"Reversible Cards","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_3","text":"We have N cards numbered 1 to N. Each side of each card has a color represented by a positive integer. One side of Card i has a color ai, and the other side has a color bi. For each card, you can choose which side shows up. Find the maximum possible number of different colors showing up. Constraints 1\u2264N\u2264200000 1\u2264ai,bi\u2264400000 All numbers in input are integers.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_4","text":"Input is given from Standard Input in the following format: N a1 b1 a2 b2 : aN bN","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_5","text":"Print the answer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_6","text":"\u3010\u6837\u4f8b1\u3011 4 1 2 1 3 4 2 2 3 \u3010\u6837\u4f8b2\u3011 2 111 111 111 111 \u3010\u6837\u4f8b3\u3011 12 5 2 5 6 1 2 9 7 2 7 5 5 4 2 6 7 2 2 7 8 9 7 1 8","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_7","text":"\u3010\u6837\u4f8b1\u3011 4 \u3010\u6837\u4f8b2\u3011 1 \u3010\u6837\u4f8b3\u3011 8","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_8","text":"\u6837\u4f8b1\u89e3\u91ca We can choose the sides with 1, 3, 4, 2 to have four colors. \u6837\u4f8b2\u89e3\u91ca They are painted with just one color.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_9","text":"\u5e76\u67e5\u96c6\uff0c\u5efa\u7acb\u8fde\u901a\u5757\u3002\u5206\u4e24\u79cd\u60c5\u51b5\uff1a \u8fde\u901a\u5757\u65e0\u73af\uff0c\u4e3a\u4e00\u68f5\u6811\uff0c\u5219\u8be5\u8fde\u901a\u5757\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u5ea6\u4e3a\u70b9\u7684\u4e2a\u6570\u51cf1\uff0c\u4f8b\u59821-2\uff0c2-3\uff0c3-4\uff0c\u8fd9\u79cd\u60c5\u51b5\u7b54\u6848\u4e3a3 \u8fde\u901a\u5757\u6709\u73af\uff0c\u5219\u8be5\u8fde\u901a\u5757\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u5ea6\u4e3a\u70b9\u7684\u6570\u76ee\uff0c\u4f8b\u59821-2\uff0c2-3\uff0c3-1\uff0c\u8be5\u60c5\u51b5\u7b54\u6848\u4e3a4","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_10","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll fa [ 400500 ] = { 0 }; ll huan [ 400500 ] = { 0 }; ll sum [ 400500 ] = { 0 }; ll findfa ( ll n ) { if ( n == fa [ n ]) return n ; return fa [ n ] = findfa ( fa [ n ]); } int main () { ll n , s , e ; for ( ll i = 1 ; i <= 400000 ; i ++ ) fa [ i ] = i ; scanf ( \"%lld\" , & n ); for ( ll i = 1 ; i <= n ; i ++ ) { ll x , y ; scanf ( \"%lld%lld\" , & x , & y ); ll fx = findfa ( x ); ll fy = findfa ( y ); if ( fx == fy ) huan [ fx ] = huan [ fy ] = 1 ; else fa [ fy ] = fx ; } for ( ll i = 1 ; i <= 400000 ; i ++ ) { findfa ( i ); huan [ fa [ i ]] |= huan [ i ]; sum [ fa [ i ]] ++ ; } ll ans = 0 ; for ( ll i = 1 ; i <= 400000 ; i ++ ) { if ( sum [ i ] != 0 ) { if ( huan [ i ]) ans += sum [ i ]; else ans += sum [ i ] -1 ; } } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_11","text":"Second Large Rectangle","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_12","text":"Given a N\u00d7M binary matrix. Please output the size of second large rectangle containing all \"1\". Containing all \"1\" means that the entries of the rectangle are all \"1\". A rectangle can be defined as four integers x1,y1,x2,y2 where 1\u2264x1\u2264x2\u2264N and 1\u2264y1\u2264y2\u2264M. Then, the rectangle is composed of all the cell (x, y) where x1\u2264x\u2264x2 and y1\u2264y\u2264y2. If all of the cell in the rectangle is \"1\", this is a valid rectangle. Please find out the size of the second largest rectangle, two rectangles are different if exists a cell belonged to one of them but not belonged to the other.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_13","text":"The first line of input contains two space-separated integers N and M. Following N lines each contains M characters cij. 1\u2264N,M\u22641000 N\u00d7M\u22652 cij\u2208\"01\"","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_14","text":"Output one line containing an integer representing the answer. If there are less than 2 rectangles containning all \"1\", output \"0\".","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_15","text":"1 2 01","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_16","text":"0","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_17","text":"\u6784\u9020\u5217\u65b9\u5411\u7684\u524d\u7f00\u548c\uff0c\u540e\u7528\u5355\u8c03\u6808\u6c42\u51fa\u533a\u95f4\u6700\u5c0f\u503c\u548c\u533a\u95f4\u957f\u5ea6\u4e58\u79ef\u7684\u7b2c\u4e8c\u5927\u503c\u5373\u53ef\u3002","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_18","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; int sum [ 2050 ][ 2050 ] = { 0 }; int a [ 2050 ][ 2050 ] = { 0 }; struct node { ll pos , val ; }; node s [ 100500 ] = { 0 }; int main () { int n , m ; scanf ( \"%d %d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) scanf ( \"%1d\" , & a [ i ][ j ]); for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i ][ j ]) sum [ i ][ j ] = sum [ i - 1 ][ j ] + a [ i ][ j ]; else sum [ i ][ j ] = 0 ; } ll ans = 0 ; ll max1 = 0 , max2 = 0 ; for ( ll i = 1 ; i <= n ; i ++ ) { ll top = 0 ; for ( ll j = 1 ; j <= m + 1 ; j ++ ) { if ( top == 0 ) { s [ ++ top ] = { j , sum [ i ][ j ]}; } else { while ( s [ top ]. val > sum [ i ][ j ]) { ll tmp = ( ll )( j - s [ top - 1 ]. pos - 1 ) * ( ll ) s [ top ]. val ; ll tmp1 = ( ll )( j - s [ top - 1 ]. pos - 2 ) * ( ll ) s [ top ]. val ; ll tmp2 = ( ll )( j - s [ top - 1 ]. pos - 1 ) * ( ll )( s [ top ]. val - 1 ); top -- ; if ( tmp > max1 ) swap ( max1 , tmp ); if ( tmp > max2 ) swap ( max2 , tmp ); if ( tmp1 > max1 ) swap ( max1 , tmp1 ); if ( tmp1 > max2 ) swap ( max2 , tmp1 ); if ( tmp2 > max1 ) swap ( max1 , tmp2 ); if ( tmp2 > max2 ) swap ( max2 , tmp2 ); } s [ ++ top ] = { j , sum [ i ][ j ]}; } } } cout << max2 << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#3","text":"","title":"\u9898\u76ee3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_19","text":"Simple Math 2","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_20","text":"Given positive integers N and M, find the remainder when \u230a10^N/M\u230b \u230a10^N/M\u230b \u200b\u200b is divided by M. What is \u230ax\u230b?\u230ax\u230b denotes the greatest integer not exceeding x. For example: \u230a2.5\u230b=2 \u230a3\u230b=3 \u230a9.9999999\u230b=9 \u230a100/3\u230b=\u230a33.33...\u230b=33 Constraints 1\u2264N\u2264 10^{18} 10^{18} 1\u2264M\u226410000","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_21","text":"Input is given from Standard Input in the following format: N a1 b1 a2 b2 : aN bN","title":"\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_22","text":"Print the answer.","title":"\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_23","text":"\u3010\u6837\u4f8b1\u3011 1 2 \u3010\u6837\u4f8b2\u3011 2 7 \u3010\u6837\u4f8b3\u3011 1000000000000000000 9997","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_24","text":"\u3010\u6837\u4f8b1\u3011 1 \u3010\u6837\u4f8b2\u3011 0 \u3010\u6837\u4f8b3\u3011 9015","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_25","text":"\u6837\u4f8b1\u89e3\u91ca\uff1a We have \u230a10^\u00bd\u230b=5, so we should print the remainder when 5 is divided by 2, that is, 1.","title":"\u63d0\u793a"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_26","text":"\u230a\\frac{10^N}{M}\u230b \\% m =\u230a\\frac{10^N}{M}-k*m\u230b \\% m =\u230a\\frac{10^N-k*m^2}{M}\u230b\\% m=\u230a\\frac{10^N \\% m^2}{M}\u230b\\% m \u230a\\frac{10^N}{M}\u230b \\% m =\u230a\\frac{10^N}{M}-k*m\u230b \\% m =\u230a\\frac{10^N-k*m^2}{M}\u230b\\% m=\u230a\\frac{10^N \\% m^2}{M}\u230b\\% m \u200b\u200b\u200b\u200b\u200b\u200b \u6240\u4ee5\uff0c\u53ea\u9700\u8981\u5229\u7528\u5feb\u901f\u5e42\u7b97\u6cd5\u8ba1\u7b97\u51fa $ 10 ^N \\% m^2$\u200b\u200b \u5373\u53ef","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/#_27","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> using namespace std ; typedef long long ll ; map < ll , ll > mp ; vector < ll > v ; int main () { ll n , m ; cin >> n >> m ; ll mod = m * m , ans1 = 1 , ans2 = 10 ; while ( n != 0 ) { if ( n % 2 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; n /= 2 ; } ll ans = ( ans1 / m + m ) % m ; cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/","text":"\u6691\u5047\u96c6\u8bad\u9898\u89e3\u7cfb\u5217\uff08\u4e00\uff09 \u00b6 \u9898\u76ee1 \u00b6 Alice and Bob \u9898\u89e3 \u00b6 \u6253\u8868\u66b4\u529b\u9898\u76ee\uff08\u6bd4\u8d5b\u65f6\u9ad8\u4f30\u4e86\u65f6\u95f4\u590d\u6742\u5ea6\uff0cQAQ\uff09 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; bool a [ 5050 ][ 5050 ] = { 0 }; ///\u7528bool\uff0cint\u4f1a\u8d85\u65f6 int main () { for ( int i = 0 ; i <= 5000 ; i ++ ) for ( int j = 0 ; j <= 5000 ; j ++ ) { if ( ! a [ i ][ j ]) { for ( int k = 1 ; i + k <= 5000 ; k ++ ) for ( int x = 0 ; x * k + j <= 5000 ; x ++ ) a [ i + k ][ x * k + j ] = 1 ; for ( int k = 1 ; j + k <= 5000 ; k ++ ) for ( int x = 0 ; x * k + i <= 5000 ; x ++ ) a [ i + x * k ][ k + j ] = 1 ; } } int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); if ( a [ n ][ m ]) puts ( \"Alice\" ); else puts ( \"Bob\" ); } } \u9898\u76ee2 \u00b6 Hash Function \u9898\u89e3 \u00b6 \u4e24\u4e2afor\u5faa\u73af\u904d\u5386\uff0c\u5bfb\u627e\u6700\u4f18\u7b54\u6848\uff0c\u5982\u679c\u7b54\u6848\u4e0d\u7b26\u5408\uff0c\u5219\u9000\u56de\u8c03\u6574\u7b54\u6848\u3002 \u53e6\u8be5\u9898\u76ee\u53ef\u4ee5\u7528NTT\u6765\u5b8c\u6210\uff0c\u53ef\u53c2\u8003\u535a\u5ba2\uff1a https://blog.nowcoder.net/n/9e67ea84ea1f4b8fa1046762f6e41210 https://blog.nowcoder.net/n/97fe1e13d21141349751df63315eaa97 \u4ee3\u7801 \u00b6 #pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int a [ 500500 ] = { 0 }; int num [ 500500 ] = { 0 }; int main () { std :: ios :: sync_with_stdio ( 0 ); cin . tie ( 0 ); int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ], num [ a [ i ]] = 1 ; sort ( a + 1 , a + n + 1 ); int idx = 1 , jdx = 1 , ans = n , ndx = 1 ; while ( idx <= n ) { int jdx = a [ idx ] % ans ; int flag = 1 ; for (; jdx <= a [ n ]; jdx += ans ) { if ( num [ jdx ]) { if ( flag == 2 ) ///\u6709\u4e24\u4e2a\u6570\u540c\u4f59\uff0c\u8df3\u51fa\u5faa\u73af { flag = 0 ; break ; } flag ++ ; } } if ( flag == 0 ) idx = ndx , ans ++ ; ///\u56de\u9000 if ( a [ idx ] <= ans ) ndx = idx ; ///\u8bb0\u5f55\u4e0a\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7b54\u6848\uff08\u7531\u4e8e\u5df2\u6392\u5e8f\u4e14\u5f53\u524d\u503c\u5c0f\u4e8e\u53d6\u6a21\u7684\u503c\uff0c\u6240\u4ee5\u524d\u9762\u7684\u80af\u5b9a\u7b26\u5408\u3002 idx ++ ; } cout << ans << endl ; }","title":"\u6691\u5047\u96c6\u8bad\u9898\u89e3\u7cfb\u5217\uff08\u4e00\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/#_1","text":"","title":"\u6691\u5047\u96c6\u8bad\u9898\u89e3\u7cfb\u5217\uff08\u4e00\uff09"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/#1","text":"Alice and Bob","title":"\u9898\u76ee1"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/#_2","text":"\u6253\u8868\u66b4\u529b\u9898\u76ee\uff08\u6bd4\u8d5b\u65f6\u9ad8\u4f30\u4e86\u65f6\u95f4\u590d\u6742\u5ea6\uff0cQAQ\uff09","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/#_3","text":"#include <bits/stdc++.h> using namespace std ; bool a [ 5050 ][ 5050 ] = { 0 }; ///\u7528bool\uff0cint\u4f1a\u8d85\u65f6 int main () { for ( int i = 0 ; i <= 5000 ; i ++ ) for ( int j = 0 ; j <= 5000 ; j ++ ) { if ( ! a [ i ][ j ]) { for ( int k = 1 ; i + k <= 5000 ; k ++ ) for ( int x = 0 ; x * k + j <= 5000 ; x ++ ) a [ i + k ][ x * k + j ] = 1 ; for ( int k = 1 ; j + k <= 5000 ; k ++ ) for ( int x = 0 ; x * k + i <= 5000 ; x ++ ) a [ i + x * k ][ k + j ] = 1 ; } } int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n , m ; scanf ( \"%d%d\" , & n , & m ); if ( a [ n ][ m ]) puts ( \"Alice\" ); else puts ( \"Bob\" ); } }","title":"\u4ee3\u7801"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/#2","text":"Hash Function","title":"\u9898\u76ee2"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/#_4","text":"\u4e24\u4e2afor\u5faa\u73af\u904d\u5386\uff0c\u5bfb\u627e\u6700\u4f18\u7b54\u6848\uff0c\u5982\u679c\u7b54\u6848\u4e0d\u7b26\u5408\uff0c\u5219\u9000\u56de\u8c03\u6574\u7b54\u6848\u3002 \u53e6\u8be5\u9898\u76ee\u53ef\u4ee5\u7528NTT\u6765\u5b8c\u6210\uff0c\u53ef\u53c2\u8003\u535a\u5ba2\uff1a https://blog.nowcoder.net/n/9e67ea84ea1f4b8fa1046762f6e41210 https://blog.nowcoder.net/n/97fe1e13d21141349751df63315eaa97","title":"\u9898\u89e3"},{"location":"problem/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/#_5","text":"#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,\"Ofast\",\"inline\") #include <bits/stdc++.h> using namespace std ; int a [ 500500 ] = { 0 }; int num [ 500500 ] = { 0 }; int main () { std :: ios :: sync_with_stdio ( 0 ); cin . tie ( 0 ); int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ], num [ a [ i ]] = 1 ; sort ( a + 1 , a + n + 1 ); int idx = 1 , jdx = 1 , ans = n , ndx = 1 ; while ( idx <= n ) { int jdx = a [ idx ] % ans ; int flag = 1 ; for (; jdx <= a [ n ]; jdx += ans ) { if ( num [ jdx ]) { if ( flag == 2 ) ///\u6709\u4e24\u4e2a\u6570\u540c\u4f59\uff0c\u8df3\u51fa\u5faa\u73af { flag = 0 ; break ; } flag ++ ; } } if ( flag == 0 ) idx = ndx , ans ++ ; ///\u56de\u9000 if ( a [ idx ] <= ans ) ndx = idx ; ///\u8bb0\u5f55\u4e0a\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7b54\u6848\uff08\u7531\u4e8e\u5df2\u6392\u5e8f\u4e14\u5f53\u524d\u503c\u5c0f\u4e8e\u53d6\u6a21\u7684\u503c\uff0c\u6240\u4ee5\u524d\u9762\u7684\u80af\u5b9a\u7b26\u5408\u3002 idx ++ ; } cout << ans << endl ; }","title":"\u4ee3\u7801"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/","text":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e00\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u95ee\u9898 A: Matrix Equation \u9898\u76ee\u63cf\u8ff0 \u00b6 We call a matrix \u201c01 Square\u201d if and only if it\u2019s a N \u00d7 N matrix and its elements are all 0 or 1. For two 01 Squares X,Y , we de\ufb01ne two operators X \u00d7 Y and X Y . The value of them are also 01 Square matrices and calculated below(we use Z to abbreviate X \u00d7 Y and D to abbreviate X Y ): Now MianKing has two 01 Squares A, B, he wants to solve the matrix equation below: A \u00d7 C = B C You need to help MainKing solve this problem by calculating how many 01 Squares C satisfy this equation. The answer may be very large, so you only need to output the answer module 998244353. \u8f93\u5165 \u00b6 The first line has one integer N Then there are N lines and each line has N integers, the j-th integer of the i-th line denotes A_{i,j} A_{i,j} Then there are N lines and each line has N integers, the j-th integer of the i-th line denotes B_{i,j} B_{i,j} 1\u2264N\u2264200, A_{i,j} A_{i,j} ,$ B_{i,j}$\u2208{ 0, 1 } \u8f93\u51fa \u00b6 Output the answer module 998244353. \u6837\u4f8b\u8f93\u5165 \u00b6 \u3010\u6837\u4f8b1\u3011 2 0 1 1 1 1 0 0 1 \u3010\u6837\u4f8b2\u3011 3 1 0 0 0 1 0 0 0 1 1 1 1 1 1 1 1 1 1 \u3010\u6837\u4f8b3\u3011 4 0 1 0 1 0 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 0 1 1 1 1 0 0 1 1 1 1 0 \u6837\u4f8b\u8f93\u51fa \u00b6 \u3010\u6837\u4f8b1\u3011 2 \u3010\u6837\u4f8b2\u3011 512 \u3010\u6837\u4f8b3\u3011 8 \u9898\u89e3 \u00b6 \u9ad8\u65af\u6d88\u5143\u6cd5\u6c42\u89e3\u77e9\u9635\u7684\u79e9\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u5217\u5355\u72ec\u8003\u8651\u53ef\u4ee5\u5c06\u9898\u76ee\u8f6c\u6362\u4e3a\u4ee5\u4e0b\u65b9\u7a0b\uff1a \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u65b9\u7a0b\u7ec4\u7cfb\u6570\u77e9\u9635\uff0c\u5982\u679c\u79e9\u4e3ak\uff0c\u5219 C_k,C_{K+1} .... C_n C_k,C_{K+1} .... C_n \uff0c\u53ef\u4ee5\u4efb\u610f\u9009\u62e90\u548c1\uff0c\u5219\u5bf9\u5e94\u7b54\u6848\u4e3a 2^{n-k} 2^{n-k} \uff0c\u6700\u540e\u5c06\u6bcf\u4e00\u5217\u7684\u7b54\u6848\u4e58\u8d77\u6765\u5373\u4e3a\u7b54\u6848\u3002 \u53c2\u8003\u4e8e\uff1a https://blog.csdn.net/hddddh/article/details/111828336 https://blog.csdn.net/weixin_45697774/article/details/113198407 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; bitset < 330 > a [ 330 ]; int A [ 330 ][ 330 ] = { 0 }; int C [ 330 ][ 330 ] = { 0 }; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } ll guess ( ll n ) { ll maxx = 0 , row = 0 ; for ( ll col = 0 ; col < n ; col ++ ) { for ( maxx = row ; maxx < n ; maxx ++ ) if ( a [ maxx ][ col ] != 0 ) break ; if ( maxx == n ) continue ; if ( a [ maxx ][ col ] == 0 ) continue ; swap ( a [ maxx ], a [ row ]); for ( ll i = row + 1 ; i < n ; i ++ ) { if ( a [ i ][ col ] != 0 ) a [ i ] ^= a [ row ]; } row ++ ; } return ksm ( 2 , n - row ); } int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) scanf ( \"%d\" , & A [ i ][ j ]); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) scanf ( \"%d\" , & C [ i ][ j ]); ll ans = 1 ; for ( int col = 0 ; col < n ; col ++ ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) a [ i ][ j ] = A [ i ][ j ]; for ( int i = 0 ; i < n ; i ++ ) a [ i ][ i ] = A [ i ][ i ] ^ C [ i ][ col ]; ans = ( ans * guess ( n )) % mod ; } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e00\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_1","text":"","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e00\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_2","text":"\u95ee\u9898 A: Matrix Equation","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_3","text":"We call a matrix \u201c01 Square\u201d if and only if it\u2019s a N \u00d7 N matrix and its elements are all 0 or 1. For two 01 Squares X,Y , we de\ufb01ne two operators X \u00d7 Y and X Y . The value of them are also 01 Square matrices and calculated below(we use Z to abbreviate X \u00d7 Y and D to abbreviate X Y ): Now MianKing has two 01 Squares A, B, he wants to solve the matrix equation below: A \u00d7 C = B C You need to help MainKing solve this problem by calculating how many 01 Squares C satisfy this equation. The answer may be very large, so you only need to output the answer module 998244353.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_4","text":"The first line has one integer N Then there are N lines and each line has N integers, the j-th integer of the i-th line denotes A_{i,j} A_{i,j} Then there are N lines and each line has N integers, the j-th integer of the i-th line denotes B_{i,j} B_{i,j} 1\u2264N\u2264200, A_{i,j} A_{i,j} ,$ B_{i,j}$\u2208{ 0, 1 }","title":"\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_5","text":"Output the answer module 998244353.","title":"\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_6","text":"\u3010\u6837\u4f8b1\u3011 2 0 1 1 1 1 0 0 1 \u3010\u6837\u4f8b2\u3011 3 1 0 0 0 1 0 0 0 1 1 1 1 1 1 1 1 1 1 \u3010\u6837\u4f8b3\u3011 4 0 1 0 1 0 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 0 1 1 1 1 0 0 1 1 1 1 0","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_7","text":"\u3010\u6837\u4f8b1\u3011 2 \u3010\u6837\u4f8b2\u3011 512 \u3010\u6837\u4f8b3\u3011 8","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_8","text":"\u9ad8\u65af\u6d88\u5143\u6cd5\u6c42\u89e3\u77e9\u9635\u7684\u79e9\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u5217\u5355\u72ec\u8003\u8651\u53ef\u4ee5\u5c06\u9898\u76ee\u8f6c\u6362\u4e3a\u4ee5\u4e0b\u65b9\u7a0b\uff1a \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u65b9\u7a0b\u7ec4\u7cfb\u6570\u77e9\u9635\uff0c\u5982\u679c\u79e9\u4e3ak\uff0c\u5219 C_k,C_{K+1} .... C_n C_k,C_{K+1} .... C_n \uff0c\u53ef\u4ee5\u4efb\u610f\u9009\u62e90\u548c1\uff0c\u5219\u5bf9\u5e94\u7b54\u6848\u4e3a 2^{n-k} 2^{n-k} \uff0c\u6700\u540e\u5c06\u6bcf\u4e00\u5217\u7684\u7b54\u6848\u4e58\u8d77\u6765\u5373\u4e3a\u7b54\u6848\u3002 \u53c2\u8003\u4e8e\uff1a https://blog.csdn.net/hddddh/article/details/111828336 https://blog.csdn.net/weixin_45697774/article/details/113198407","title":"\u9898\u89e3"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%80%EF%BC%89/#_9","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; bitset < 330 > a [ 330 ]; int A [ 330 ][ 330 ] = { 0 }; int C [ 330 ][ 330 ] = { 0 }; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } ll guess ( ll n ) { ll maxx = 0 , row = 0 ; for ( ll col = 0 ; col < n ; col ++ ) { for ( maxx = row ; maxx < n ; maxx ++ ) if ( a [ maxx ][ col ] != 0 ) break ; if ( maxx == n ) continue ; if ( a [ maxx ][ col ] == 0 ) continue ; swap ( a [ maxx ], a [ row ]); for ( ll i = row + 1 ; i < n ; i ++ ) { if ( a [ i ][ col ] != 0 ) a [ i ] ^= a [ row ]; } row ++ ; } return ksm ( 2 , n - row ); } int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) scanf ( \"%d\" , & A [ i ][ j ]); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) scanf ( \"%d\" , & C [ i ][ j ]); ll ans = 1 ; for ( int col = 0 ; col < n ; col ++ ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) a [ i ][ j ] = A [ i ][ j ]; for ( int i = 0 ; i < n ; i ++ ) a [ i ][ i ] = A [ i ][ i ] ^ C [ i ][ col ]; ans = ( ans * guess ( n )) % mod ; } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/","text":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e09\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u667a\u4e43\u9171\u7684\u5b50\u96c6\u4e0e\u8d85\u96c6 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u6837\u4f8b\u8f93\u5165 \u00b6 2 2 2 1 3 1 2 2 2 3 2 \u6837\u4f8b\u8f93\u51fa \u00b6 15 168 \u9898\u89e3 \u00b6 \u628a N \u4e2a\u7269\u54c1\u7406\u89e3\u4e3a\u5411\u91cf\uff0c\u5148\u60f3\u4e8c\u7ef4\u7684\u60c5\u51b5 F[A][B] = v[A][B] F[A][B] += F[0][B] + F[A][0] \u63a8\u5e7f\u5230 N \u7ef4\uff1a F[A][B][C][D][E]... = v[A][B][C][D][E]... F[A][B][C][D][E]... += v[A][0][0][0][0]... + ... \u5199\u6210\u5bb9\u65a5\uff0c\u5728\u7ef4\u5ea6\u4e0a\u662f\u4e0d\u597d\u6269\u5c55\u7684\u3002\u800c\u5199\u6210\u7a7a\u95f4\u5411\u91cf\u7684\u7406\u89e3\uff0c\u662f\u5f88\u597d\u6269\u5c55\u7684 \u52a0\u4e0a\u4e8c\u8fdb\u5236\u4f4d\u8fd0\u7b97 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.nowcoder.net/n/fba9bdd58cda4937a10bbd293bd3a7ec https://blog.csdn.net/eternity19/article/details/119735293 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 50 ] = { 0 }; ll ans [ 1050000 ] = { 0 }; ll sum1 [ 1050000 ] = { 0 }; ll sum2 [ 1050000 ] = { 0 }; int main () { // freopen(\"in.txt\", \"r\", stdin); ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 0 ; i < n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); for ( ll i = 0 ; i < ( 1 << n ); i ++ ) { for ( ll j = 0 ; j < n ; j ++ ) if (( i >> j ) & 1 ) ans [ i ] ^= a [ j ]; sum1 [ i ] = ans [ i ]; sum2 [ i ] = ans [ i ]; } for ( ll j = 0 ; j < n ; j ++ ) \\\\ \u4f9d\u6b21\u8003\u8651\u653e\u7f6e\u6bcf\u4e00\u4e2a\u7269\u54c1 { for ( ll i = 0 ; i < ( 1 << n ); i ++ ) { if (( i >> j ) & 1 ) sum1 [ i ] += sum1 [ i ^ ( 1 << j )]; else sum2 [ i ] += sum2 [ i ^ ( 1 << j )]; } } for ( ll i = 1 ; i <= m ; i ++ ) { ll k , m , p = 0 ; scanf ( \"%lld\" , & k ); for ( ll j = 1 ; j <= k ; j ++ ) { scanf ( \"%lld\" , & m ); m -- ; p += ( 1 << m ); } printf ( \"%lld %lld \\n \" , sum1 [ p ], sum2 [ p ]); } return 0 ; }","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e09\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#_1","text":"","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e09\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#_2","text":"\u667a\u4e43\u9171\u7684\u5b50\u96c6\u4e0e\u8d85\u96c6","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#_3","text":"","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#_4","text":"2 2 2 1 3 1 2 2 2 3 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#_5","text":"15 168","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#_6","text":"\u628a N \u4e2a\u7269\u54c1\u7406\u89e3\u4e3a\u5411\u91cf\uff0c\u5148\u60f3\u4e8c\u7ef4\u7684\u60c5\u51b5 F[A][B] = v[A][B] F[A][B] += F[0][B] + F[A][0] \u63a8\u5e7f\u5230 N \u7ef4\uff1a F[A][B][C][D][E]... = v[A][B][C][D][E]... F[A][B][C][D][E]... += v[A][0][0][0][0]... + ... \u5199\u6210\u5bb9\u65a5\uff0c\u5728\u7ef4\u5ea6\u4e0a\u662f\u4e0d\u597d\u6269\u5c55\u7684\u3002\u800c\u5199\u6210\u7a7a\u95f4\u5411\u91cf\u7684\u7406\u89e3\uff0c\u662f\u5f88\u597d\u6269\u5c55\u7684 \u52a0\u4e0a\u4e8c\u8fdb\u5236\u4f4d\u8fd0\u7b97 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.nowcoder.net/n/fba9bdd58cda4937a10bbd293bd3a7ec https://blog.csdn.net/eternity19/article/details/119735293","title":"\u9898\u89e3"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%B8%89%EF%BC%89/#_7","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll a [ 50 ] = { 0 }; ll ans [ 1050000 ] = { 0 }; ll sum1 [ 1050000 ] = { 0 }; ll sum2 [ 1050000 ] = { 0 }; int main () { // freopen(\"in.txt\", \"r\", stdin); ll n , m ; scanf ( \"%lld%lld\" , & n , & m ); for ( ll i = 0 ; i < n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); for ( ll i = 0 ; i < ( 1 << n ); i ++ ) { for ( ll j = 0 ; j < n ; j ++ ) if (( i >> j ) & 1 ) ans [ i ] ^= a [ j ]; sum1 [ i ] = ans [ i ]; sum2 [ i ] = ans [ i ]; } for ( ll j = 0 ; j < n ; j ++ ) \\\\ \u4f9d\u6b21\u8003\u8651\u653e\u7f6e\u6bcf\u4e00\u4e2a\u7269\u54c1 { for ( ll i = 0 ; i < ( 1 << n ); i ++ ) { if (( i >> j ) & 1 ) sum1 [ i ] += sum1 [ i ^ ( 1 << j )]; else sum2 [ i ] += sum2 [ i ^ ( 1 << j )]; } } for ( ll i = 1 ; i <= m ; i ++ ) { ll k , m , p = 0 ; scanf ( \"%lld\" , & k ); for ( ll j = 1 ; j <= k ; j ++ ) { scanf ( \"%lld\" , & m ); m -- ; p += ( 1 << m ); } printf ( \"%lld %lld \\n \" , sum1 [ p ], sum2 [ p ]); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/","text":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e8c\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u95ee\u9898 A: Matrix Equation \u9898\u76ee\u63cf\u8ff0 \u00b6 You are given an integer n. Please output the answer of modulo 998244353. n is represented in the form of factorization. \u03c6(n) is Euler\u2019s totient function, and it is defi ned more formally as the number of integers k in the interval 1\u2264k\u2264n for which the greatest common divisor gcd(n,k) is equal to 1. For example, the totatives of n = 9 are the six numbers 1, 2, 4, 5, 7 and 8. They are all co-prime to 9, but the other three numbers in this interval, 3, 6, and 9 are not, because gcd(9,3) = gcd(9,6) = 3 and gcd(9,9) = 9. Therefore, \u03c6(9) = 6. As another example, \u03c6(1) = 1 since for n = 1 the only integer in the interval from 1 to n is 1 itself, and gcd(1,1) = 1. And there are several formulas for computing \u03c6(n), for example, Euler\u2019s product formula states like: where the product is all the distinct prime numbers (p in the formula) dividing n. \u8f93\u5165 \u00b6 The fi rst line contains an integer T (1\u2264T\u226420) representing the number of test cases. For each test case, the fi rst line contains an integer m\uffff(1\u2264m\u226420) is the number of prime factors. The following m lines each contains two integers pi and qi (2\u2264pi\u2264108 , 1\u2264qi\u2264108 ) describing that n contains the factor piqi , in other words, . It is guaranteed that all pi are prime numbers and diff erent from each other. \u8f93\u51fa \u00b6 For each test case, print the the answer modulo 998244353 in one line. \u6837\u4f8b\u8f93\u5165 \u00b6 2 2 2 1 3 1 2 2 2 3 2 \u6837\u4f8b\u8f93\u51fa \u00b6 15 168 \u63d0\u793a \u00b6 For first test case, n = 21*31= 6, and the answer is (\u03c6(1)*n/1+\u03c6(2)*n/2+\u03c6(3)*n/3+\u03c6(6)*n/6) mod 998244353 = (6 + 3 + 4 + 2) mod 998244353 = 15. \u9898\u89e3 \u00b6 \u9898\u76ee\u8981\u6c42\u6c42\u89e3 F(n)=\\sum_{d|n} \\varphi(d)*\\frac{n}{d} F(n)=\\sum_{d|n} \\varphi(d)*\\frac{n}{d} \uff0c\u7531\u4e8e\u6b27\u62c9\u51fd\u6570\u548c \\frac{n}{d} \\frac{n}{d} \u5747\u4e3a\u79ef\u6027\u51fd\u6570\uff0c\u5219\u6709 F(m*n)=F(m)*F(n) F(m*n)=F(m)*F(n) \u5373\u4e3a F( \\prod p_i^{q_i})=\\prod F(p_i^{q_i}) F( \\prod p_i^{q_i})=\\prod F(p_i^{q_i}) \uff0c\u5219 F(p_i^{q_i})=\\sum_{d|n}\\varphi(d)*\\frac{n}{d}=\\varphi(1)*n+\\sum_{i=1}^{q} \\varphi(p^i)*\\frac{n}{p^i}=p_i^{q_i}+\\sum _{i=1} ^{q_i}(p_i-1)*(p_i^{i-1}*\\frac{p_i^{q_i}}{p_i}) F(p_i^{q_i})=\\sum_{d|n}\\varphi(d)*\\frac{n}{d}=\\varphi(1)*n+\\sum_{i=1}^{q} \\varphi(p^i)*\\frac{n}{p^i}=p_i^{q_i}+\\sum _{i=1} ^{q_i}(p_i-1)*(p_i^{i-1}*\\frac{p_i^{q_i}}{p_i}) =p_i^{q_i}+p_i^{q_i-1}*(p_i-1)*{q_i}=p_i^{q_i-1}*(p_i+q_i*(p_i-1)) =p_i^{q_i}+p_i^{q_i-1}*(p_i-1)*{q_i}=p_i^{q_i-1}*(p_i+q_i*(p_i-1)) \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/xiongshuxian2019/article/details/109631325 https://blog.csdn.net/consciousman/article/details/77888386 https://www.cnblogs.com/letlifestop/p/10262791.html \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ll n , p , q , ans = 1 ; scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld\" , & p , & q ); ans = ( ans * ksm ( p , q - 1 ) % mod * (( p + q * ( p - 1 )) % mod + mod ) % mod ) % mod ; } printf ( \"%lld \\n \" , ans % mod ); } return 0 ; } \u9898\u76ee2 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u95ee\u9898 D: Master of Random \u9898\u76ee\u63cf\u8ff0 \u00b6 Hakase provides Nano with a problem. There is a rooted tree with values on nodes. For each query,you are asked to calculate the sum of the values in the subtree. However, Nano is a rookie so she decides to guess the answer. She has known how the data generator works: it identifi es the nodes with labels from 0 to n-1 and then visits them one by one. For each i (1\u2264i\u2264n), the generator selects a node whose label is smaller than i to be its father. The pseudocode is like this: \u200b for i = 1 to n - 1: \u200b father[i] = random(0, i - 1); where random(a, b) randomly generates a uniformly distributed random integer in range [a, b]. Knowing n and the value of the i-th node ai , Nano decides to randomly choose a subtree and sum up all of the values in the subtree as the answer. Now Hakase wants to know what the expectation of the answer is. Can you help her? \u8f93\u5165 \u00b6 The first line contains an integer T (1\u2264T\u226410) representing the number of test cases. For each test case, the fi rst line contains an integer n (1\u2264n\u2264100000), the number of the nodes in the rooted tree. The second line contains n integers a0,a1,..., a_{n-1} a_{n-1} (1\u2264ai\u2264100000) represent the values of nodes. \u8f93\u51fa \u00b6 It can be proven that the answer equals to an irreducible fraction p/q. For each test case, print p*q^{-1} p*q^{-1} mod 998244353 in one line. q^{-1} q^{-1} is the inverse of q under module number 998244353. \u6837\u4f8b\u8f93\u5165 \u00b6 2 2 1 1 3 1 2 3 \u6837\u4f8b\u8f93\u51fa \u00b6 499122178 166374063 \u63d0\u793a \u00b6 The shape of the tree in the first test case is unique. The father of node 1 is 0. It is possible to choose node 0 or 1 with equal possibility. The sum of the subtree with 0 as the root is 2 while the sum of the subtree with 1 as the root is 1. So the expectation is (2 + 1)/2 = 3/2. The output is 3*2-1 mod 998244353 = 400122178. There are two possible shapes in the second test case, node 1\u2019s father destines to be 0, but node 2\u2019s father might be node 0 or node 1. Both conditions are equally possible. If node 2\u2019s father is node 0, we randomly choose a node. The sum of the subtree with node 0 as the root is 6. The sum of the subtree with node 1 as the root is 2. The sum of the subtree with node 2 as the root is 3. If node 2\u2019s father is node 1, we randomly choose a node. The sum of the subtree with node 0 as the root is 6. The sum of the subtree with node 1 as the root is 5. The sum of the subtree with node 2 as the root is 3. So the expectation is (6 + 2 + 3 + 6 + 5 + 3)/6 = 25/6. The output is 25* 6^{-1} 6^{-1} mod 998244353 = 166374063. \u9898\u89e3 \u00b6 n\u4e2a\u70b9\u53ef\u4ee5\u5f62\u6210\u6811\u7684\u79cd\u7c7b\u4e3a(n-1)!\uff0c\u7136\u540e\u968f\u673a\u9009\u53d6\u4e00\u4e2a\u70b9\u8ba1\u7b97\u5b50\u6811\u7684\u6743\u503c\uff0c\u6240\u4ee5\u603b\u5171\u6709n!\u79cd\u53ef\u80fd\u3002 \u8003\u8651\u6bcf\u4e00\u4e2a\u70b9\u5bf9\u7b54\u6848\u7684\u8d21\u732e\uff0c\u5373\u8003\u8651\u6bcf\u4e2a\u70b9\u5728\u6240\u9009\u51fa\u7684\u5b50\u6811\u4e2d\u6709\u591a\u5c11\u79cd\u53ef\u80fd\u88ab\u5305\u542b\u3002 0: (n-1)! 0: (n-1)! \u200b 0\u70b9\u53ea\u6709\u9009\u53d60\u8fd9\u4e2a\u8282\u70b9\u65f6\u624d\u4f1a\u88ab\u9009\u62e9\uff0c\u5171\u6709(n-1)!\u79cd\u5f62\u6001\u7684\u6811\uff0c\u6240\u4ee5\u4e3a(n-1)! 1: (n-1)!+(n-1)! 1: (n-1)!+(n-1)! \u200b 1\u70b9\u53ea\u6709\u9009\u53d60\u548c1\u8fd9\u4e24\u4e2a\u8282\u70b9\u65f6\u624d\u4f1a\u88ab\u9009\u62e9 2:(n-1)!+(n-1)!/2+(n-1)! 2:(n-1)!+(n-1)!/2+(n-1)! \u200b 2\u70b9\u53ea\u6709\u9009\u53d60\u70b9\u65f6\u548c\u9009\u53d61\u70b9\uff082\u70b9\u4e0d\u57280\u4e0b\u9762\uff09\u548c\u9009\u53d62\u70b9\u65f6\u624d\u4f1a\u88ab\u9009\u62e9 ... k:(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! k:(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u70b9\uff0c\u5047\u8bbek\u51fa\u73b0\u7684\u79cd\u6811\u4e3a cnt[k]=(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! cnt[k]=(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! \uff0c\u6743\u503c\u4e3aa[k]\uff0c\u5219\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u4e3a cnt[k]*a[k]*(n!)^{-1} cnt[k]*a[k]*(n!)^{-1} \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/weixin_44178736/article/details/113450079 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll jc [ 100500 ] = { 0 }; ll a [ 100500 ] = { 0 }; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } int main () { jc [ 0 ] = 1 ; for ( int i = 1 ; i <= 100000 ; i ++ ) jc [ i ] = jc [ i - 1 ] * i % mod ; int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); ll cnt = jc [ n - 1 ] % mod , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt = ( cnt + jc [ n - 1 ] * ksm ( i , mod - 2 ) % mod ) % mod ; ans = ( ans + a [ i ] * cnt ) % mod ; } ans = ans * ksm ( jc [ n ], mod - 2 ); printf ( \"%lld \\n \" , ans % mod ); } return 0 ; }","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e8c\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_1","text":"","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u4e8c\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_2","text":"\u95ee\u9898 A: Matrix Equation","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_3","text":"You are given an integer n. Please output the answer of modulo 998244353. n is represented in the form of factorization. \u03c6(n) is Euler\u2019s totient function, and it is defi ned more formally as the number of integers k in the interval 1\u2264k\u2264n for which the greatest common divisor gcd(n,k) is equal to 1. For example, the totatives of n = 9 are the six numbers 1, 2, 4, 5, 7 and 8. They are all co-prime to 9, but the other three numbers in this interval, 3, 6, and 9 are not, because gcd(9,3) = gcd(9,6) = 3 and gcd(9,9) = 9. Therefore, \u03c6(9) = 6. As another example, \u03c6(1) = 1 since for n = 1 the only integer in the interval from 1 to n is 1 itself, and gcd(1,1) = 1. And there are several formulas for computing \u03c6(n), for example, Euler\u2019s product formula states like: where the product is all the distinct prime numbers (p in the formula) dividing n.","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_4","text":"The fi rst line contains an integer T (1\u2264T\u226420) representing the number of test cases. For each test case, the fi rst line contains an integer m\uffff(1\u2264m\u226420) is the number of prime factors. The following m lines each contains two integers pi and qi (2\u2264pi\u2264108 , 1\u2264qi\u2264108 ) describing that n contains the factor piqi , in other words, . It is guaranteed that all pi are prime numbers and diff erent from each other.","title":"\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_5","text":"For each test case, print the the answer modulo 998244353 in one line.","title":"\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_6","text":"2 2 2 1 3 1 2 2 2 3 2","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_7","text":"15 168","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_8","text":"For first test case, n = 21*31= 6, and the answer is (\u03c6(1)*n/1+\u03c6(2)*n/2+\u03c6(3)*n/3+\u03c6(6)*n/6) mod 998244353 = (6 + 3 + 4 + 2) mod 998244353 = 15.","title":"\u63d0\u793a"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_9","text":"\u9898\u76ee\u8981\u6c42\u6c42\u89e3 F(n)=\\sum_{d|n} \\varphi(d)*\\frac{n}{d} F(n)=\\sum_{d|n} \\varphi(d)*\\frac{n}{d} \uff0c\u7531\u4e8e\u6b27\u62c9\u51fd\u6570\u548c \\frac{n}{d} \\frac{n}{d} \u5747\u4e3a\u79ef\u6027\u51fd\u6570\uff0c\u5219\u6709 F(m*n)=F(m)*F(n) F(m*n)=F(m)*F(n) \u5373\u4e3a F( \\prod p_i^{q_i})=\\prod F(p_i^{q_i}) F( \\prod p_i^{q_i})=\\prod F(p_i^{q_i}) \uff0c\u5219 F(p_i^{q_i})=\\sum_{d|n}\\varphi(d)*\\frac{n}{d}=\\varphi(1)*n+\\sum_{i=1}^{q} \\varphi(p^i)*\\frac{n}{p^i}=p_i^{q_i}+\\sum _{i=1} ^{q_i}(p_i-1)*(p_i^{i-1}*\\frac{p_i^{q_i}}{p_i}) F(p_i^{q_i})=\\sum_{d|n}\\varphi(d)*\\frac{n}{d}=\\varphi(1)*n+\\sum_{i=1}^{q} \\varphi(p^i)*\\frac{n}{p^i}=p_i^{q_i}+\\sum _{i=1} ^{q_i}(p_i-1)*(p_i^{i-1}*\\frac{p_i^{q_i}}{p_i}) =p_i^{q_i}+p_i^{q_i-1}*(p_i-1)*{q_i}=p_i^{q_i-1}*(p_i+q_i*(p_i-1)) =p_i^{q_i}+p_i^{q_i-1}*(p_i-1)*{q_i}=p_i^{q_i-1}*(p_i+q_i*(p_i-1)) \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/xiongshuxian2019/article/details/109631325 https://blog.csdn.net/consciousman/article/details/77888386 https://www.cnblogs.com/letlifestop/p/10262791.html","title":"\u9898\u89e3"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_10","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ll n , p , q , ans = 1 ; scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld\" , & p , & q ); ans = ( ans * ksm ( p , q - 1 ) % mod * (( p + q * ( p - 1 )) % mod + mod ) % mod ) % mod ; } printf ( \"%lld \\n \" , ans % mod ); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_11","text":"\u95ee\u9898 D: Master of Random","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_12","text":"Hakase provides Nano with a problem. There is a rooted tree with values on nodes. For each query,you are asked to calculate the sum of the values in the subtree. However, Nano is a rookie so she decides to guess the answer. She has known how the data generator works: it identifi es the nodes with labels from 0 to n-1 and then visits them one by one. For each i (1\u2264i\u2264n), the generator selects a node whose label is smaller than i to be its father. The pseudocode is like this: \u200b for i = 1 to n - 1: \u200b father[i] = random(0, i - 1); where random(a, b) randomly generates a uniformly distributed random integer in range [a, b]. Knowing n and the value of the i-th node ai , Nano decides to randomly choose a subtree and sum up all of the values in the subtree as the answer. Now Hakase wants to know what the expectation of the answer is. Can you help her?","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_13","text":"The first line contains an integer T (1\u2264T\u226410) representing the number of test cases. For each test case, the fi rst line contains an integer n (1\u2264n\u2264100000), the number of the nodes in the rooted tree. The second line contains n integers a0,a1,..., a_{n-1} a_{n-1} (1\u2264ai\u2264100000) represent the values of nodes.","title":"\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_14","text":"It can be proven that the answer equals to an irreducible fraction p/q. For each test case, print p*q^{-1} p*q^{-1} mod 998244353 in one line. q^{-1} q^{-1} is the inverse of q under module number 998244353.","title":"\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_15","text":"2 2 1 1 3 1 2 3","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_16","text":"499122178 166374063","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_17","text":"The shape of the tree in the first test case is unique. The father of node 1 is 0. It is possible to choose node 0 or 1 with equal possibility. The sum of the subtree with 0 as the root is 2 while the sum of the subtree with 1 as the root is 1. So the expectation is (2 + 1)/2 = 3/2. The output is 3*2-1 mod 998244353 = 400122178. There are two possible shapes in the second test case, node 1\u2019s father destines to be 0, but node 2\u2019s father might be node 0 or node 1. Both conditions are equally possible. If node 2\u2019s father is node 0, we randomly choose a node. The sum of the subtree with node 0 as the root is 6. The sum of the subtree with node 1 as the root is 2. The sum of the subtree with node 2 as the root is 3. If node 2\u2019s father is node 1, we randomly choose a node. The sum of the subtree with node 0 as the root is 6. The sum of the subtree with node 1 as the root is 5. The sum of the subtree with node 2 as the root is 3. So the expectation is (6 + 2 + 3 + 6 + 5 + 3)/6 = 25/6. The output is 25* 6^{-1} 6^{-1} mod 998244353 = 166374063.","title":"\u63d0\u793a"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_18","text":"n\u4e2a\u70b9\u53ef\u4ee5\u5f62\u6210\u6811\u7684\u79cd\u7c7b\u4e3a(n-1)!\uff0c\u7136\u540e\u968f\u673a\u9009\u53d6\u4e00\u4e2a\u70b9\u8ba1\u7b97\u5b50\u6811\u7684\u6743\u503c\uff0c\u6240\u4ee5\u603b\u5171\u6709n!\u79cd\u53ef\u80fd\u3002 \u8003\u8651\u6bcf\u4e00\u4e2a\u70b9\u5bf9\u7b54\u6848\u7684\u8d21\u732e\uff0c\u5373\u8003\u8651\u6bcf\u4e2a\u70b9\u5728\u6240\u9009\u51fa\u7684\u5b50\u6811\u4e2d\u6709\u591a\u5c11\u79cd\u53ef\u80fd\u88ab\u5305\u542b\u3002 0: (n-1)! 0: (n-1)! \u200b 0\u70b9\u53ea\u6709\u9009\u53d60\u8fd9\u4e2a\u8282\u70b9\u65f6\u624d\u4f1a\u88ab\u9009\u62e9\uff0c\u5171\u6709(n-1)!\u79cd\u5f62\u6001\u7684\u6811\uff0c\u6240\u4ee5\u4e3a(n-1)! 1: (n-1)!+(n-1)! 1: (n-1)!+(n-1)! \u200b 1\u70b9\u53ea\u6709\u9009\u53d60\u548c1\u8fd9\u4e24\u4e2a\u8282\u70b9\u65f6\u624d\u4f1a\u88ab\u9009\u62e9 2:(n-1)!+(n-1)!/2+(n-1)! 2:(n-1)!+(n-1)!/2+(n-1)! \u200b 2\u70b9\u53ea\u6709\u9009\u53d60\u70b9\u65f6\u548c\u9009\u53d61\u70b9\uff082\u70b9\u4e0d\u57280\u4e0b\u9762\uff09\u548c\u9009\u53d62\u70b9\u65f6\u624d\u4f1a\u88ab\u9009\u62e9 ... k:(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! k:(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u70b9\uff0c\u5047\u8bbek\u51fa\u73b0\u7684\u79cd\u6811\u4e3a cnt[k]=(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! cnt[k]=(n-1)!+(n-1)!/2+(n-1)!/3+....+(n-1)!/k+(n-1)! \uff0c\u6743\u503c\u4e3aa[k]\uff0c\u5219\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u4e3a cnt[k]*a[k]*(n!)^{-1} cnt[k]*a[k]*(n!)^{-1} \u53c2\u8003\u94fe\u63a5\uff1a https://blog.csdn.net/weixin_44178736/article/details/113450079","title":"\u9898\u89e3"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%89/#_19","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; ll jc [ 100500 ] = { 0 }; ll a [ 100500 ] = { 0 }; ll ksm ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ( ans1 * ans2 ) % mod ; ans2 = ( ans2 * ans2 ) % mod ; b /= 2 ; } return ans1 ; } int main () { jc [ 0 ] = 1 ; for ( int i = 1 ; i <= 100000 ; i ++ ) jc [ i ] = jc [ i - 1 ] * i % mod ; int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); ll cnt = jc [ n - 1 ] % mod , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt = ( cnt + jc [ n - 1 ] * ksm ( i , mod - 2 ) % mod ) % mod ; ans = ( ans + a [ i ] * cnt ) % mod ; } ans = ans * ksm ( jc [ n ], mod - 2 ); printf ( \"%lld \\n \" , ans % mod ); } return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/","text":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u56db\uff09 \u00b6 \u9898\u76ee1 \u00b6 \u9898\u76ee\u94fe\u63a5 \u00b6 \u667a\u4e43\u9171\u7684\u524d\u7f00\u548c\u4e0e\u5dee\u5206 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u6837\u4f8b\u8f93\u5165 \u00b6 10 2 11 1000 1000 1000 100000 1000 1000 10000 10000 10000 100000 1 10 0 100 1 10 1 1 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 1 10 \u6837\u4f8b\u8f93\u51fa \u00b6 1101 1102 1103 100104 1105 1106 10107 10108 10109 100110 236055 \u9898\u89e3 \u00b6 \u7531\u4e8e\u6a21\u6570\u5927\u4e8e\u5e8f\u5217\u957f\u5ea6\uff0c\u6240\u4ee5\u5bf9\u8d1f\u6570\u7684\u5dee\u5206\u53ef\u4ee5\u8f6c\u5316\u4e3a\u53d6\u6a21\u540e\u7684\u524d\u7f00\u548c\u3002 \u5bf9\u5e8f\u5217{ a_0 a_0 ,0,0,0,0}\u505a\u524d\u7f00\u53ef\u5f97 \u5e8f\u53f7 0 1 2 3 4 \u539f\u5e8f\u5217 a_0 a_0 0 0 0 0 \u4e00\u6b21\u524d\u7f00\u548c a_0 a_0 a_0 a_0 a_0 a_0 a_0 a_0 a_0 a_0 \u4e8c\u6b21\u524d\u7f00\u548c a_0 a_0 2 a_0 a_0 3 a_0 a_0 4 a_0 a_0 5 a_0 a_0 \u4e09\u6b21\u524d\u7f00\u548c a_0 a_0 3 a_0 a_0 6 a_0 a_0 10 a_0 a_0 15 a_0 a_0 \u5219\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u9012\u63a8\u5f0f\uff1a b[k][i]=b[k-1][i]+b[k][i-1] b[k][i]=b[k-1][i]+b[k][i-1] \uff0c\u8be5\u516c\u5f0f\u5373\u4e3a\u4ece(0,0)\u70b9\u8d70\u5230(k,i)\u70b9\u7684\u8def\u5f84\u79cd\u7c7b\u6570\uff0c\u4e14\u901a\u9879\u516c\u5f0f\u5373\u4e3a\uff1a b[k][i]=C_{i+k-1}^{i-1} b[k][i]=C_{i+k-1}^{i-1} \u56e0\u6b64\u53ef\u4ee5\u901a\u8fc7\u7ec4\u5408\u6570\u9012\u63a8\u7684\u65b9\u5f0f\u6c42\u51fa\u7cfb\u6570\u3002 \u5982\u679c\u8003\u8651 {a_0,a_1,a_2,.....,a_k} {a_0,a_1,a_2,.....,a_k} \u5e8f\u5217\uff0c\u5219\u53ef\u5f97\u5230\u4e00\u4e0b\u8ba1\u7b97\uff1a \u7b54\u6848\u5373\u4e3a {a_0,a_1,a_2,...,a_k} {a_0,a_1,a_2,...,a_k} \u548c {b_0,b_1,b_2,...,b_k} {b_0,b_1,b_2,...,b_k} \u5377\u79ef\u7684\u7ed3\u679c\uff0c\u6839\u636eNTT\u7b97\u6cd5\u53ef\u4ee5\u5728 O(nlogn) O(nlogn) \u65f6\u95f4\u590d\u6742\u5ea6\u5185\u5f97\u51fa\u7b54\u6848\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.nowcoder.net/n/d1e592fc44b648668bcddc3fe44b7927 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; const ll G = 3 ; ll n , m , L , R [ 600500 ] = { 0 }; ll a [ 600500 ] = { 0 }, b [ 600500 ] = { 0 }, inv [ 600500 ] = { 0 }; ll qpow ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ans1 * ans2 % mod ; ans2 = ans2 * ans2 % mod ; b /= 2 ; } return ans1 % mod ; } void NTT ( ll * a , ll f ) { for ( ll i = 0 ; i < n ; i ++ ) { if ( i < R [ i ]) swap ( a [ i ], a [ R [ i ]]); } for ( ll i = 1 ; i < n ; i <<= 1 ) { ll gn = qpow ( G , ( mod - 1 ) / ( i << 1 )); for ( ll j = 0 ; j < n ; j += ( i << 1 )) { ll g = 1 ; for ( ll k = 0 ; k < i ; k ++ , g = g * gn % mod ) { ll x = a [ j + k ], y = g * a [ j + k + i ] % mod ; a [ j + k ] = ( x + y ) % mod ; a [ j + k + i ] = ( x - y + mod ) % mod ; } } } if ( f == 1 ) return ; ll inv = qpow ( n , mod - 2 ); reverse ( a + 1 , a + n ); for ( ll i = 0 ; i < n ; i ++ ) a [ i ] = 1l l * a [ i ] * inv % mod ; } void solve ( ll * A , ll * B ) { m = n + m ; for ( n = 1 ; n <= m ; n <<= 1 ) L ++ ; for ( int i = 0 ; i < n ; i ++ ) R [ i ] = ( R [ i >> 1 ] >> 1 ) | (( i & 1 ) << ( L - 1 )); NTT ( A , 1 ); NTT ( B , 1 ); for ( int i = 0 ; i < n ; i ++ ) A [ i ] = ( A [ i ] % mod * B [ i ] % mod + mod ) % mod ; NTT ( A , -1 ); } int main () { ll k ; scanf ( \"%lld%lld\" , & n , & k ); m = n ; ll nn = n ; for ( ll i = 0 ; i < n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); inv [ 1 ] = 1 ; for ( ll i = 2 ; i < 200500 ; i ++ ) inv [ i ] = ( ll )( mod - mod / i ) * inv [ mod % i ] % mod ; b [ 0 ] = 1 ; ll kk = ( k % mod + mod ) % mod ; for ( ll i = 1 ; i < n ; i ++ ) b [ i ] = b [ i - 1 ] * ( i + kk - 1 ) % mod * inv [ i ] % mod ; solve ( a , b ); for ( ll i = 0 ; i < nn ; i ++ ) printf ( \"%lld \" , a [ i ]); return 0 ; } \u9898\u76ee2 \u00b6 \u9898\u76ee\u63cf\u8ff0 \u00b6 \u7ed9\u5b9a\u6b63\u6574\u6570 n n \uff0c\u6c42 1\\le x,y\\le n 1\\le x,y\\le n \u4e14 gcd(x,y) gcd(x,y) \u4e3a\u7d20\u6570\u7684\u6570\u5bf9 (x,y) (x,y) \u6709\u591a\u5c11\u5bf9\u3002 \u8f93\u5165\u683c\u5f0f \u00b6 \u53ea\u6709\u4e00\u884c\u4e00\u4e2a\u6574\u6570\uff0c\u4ee3\u8868 n n \u3002 \u8f93\u51fa\u683c\u5f0f \u00b6 \u4e00\u884c\u4e00\u4e2a\u6574\u6570\u8868\u793a\u7b54\u6848\u3002 \u8f93\u5165 \u00b6 4 \u8f93\u51fa \u00b6 4 \u63d0\u793a \u00b6 \u5bf9\u4e8e\u6837\u4f8b\uff0c\u6ee1\u8db3\u6761\u4ef6\u7684 (x,y) \u4e3a (2,2)\uff0c(2,4)\uff0c(3,3)\uff0c(4,2) \u6570\u636e\u89c4\u6a21\u4e0e\u7ea6\u5b9a \u00b6 \u5bf9\u4e8e 100% \u7684\u6570\u636e\uff0c\u4fdd\u8bc1 1\\le n\\le10^7 1\\le n\\le10^7 \u3002 \u9898\u89e3 \u00b6 \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u3002 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; bool is_prime [ 10050000 ] = { 0 }; ll prime [ 5005000 ] = { 0 }; ll mu [ 10050000 ] = { 0 }; ll sum [ 10050000 ] = { 0 }; ll cnt = 0 ; void get_mu ( ll n ) { mu [ 1 ] = 1 ; for ( ll i = 2 ; i <= n ; i ++ ) { if ( ! is_prime [ i ]) { prime [ ++ cnt ] = i ; mu [ i ] = -1 ; } for ( ll j = 1 ; j <= cnt && prime [ j ] * i <= n ; j ++ ) { is_prime [ prime [ j ] * i ] = 1 ; if ( i % prime [ j ] == 0 ) break ; else mu [ i * prime [ j ]] = - mu [ i ]; } } } int main () { ll n ; scanf ( \"%lld\" , & n ); get_mu ( n ); for ( ll i = 1 ; i <= cnt ; i ++ ) for ( ll j = 1 ; j * prime [ i ] <= n ; j ++ ) sum [ j * prime [ i ]] += mu [ j ]; for ( int i = 1 ; i <= n ; i ++ ) sum [ i ] += sum [ i - 1 ]; ll ans = 0 ; for ( ll l = 1 , r ; l <= n ; l = r + 1 ) { r = n / ( n / l ); ans += ( sum [ r ] - sum [ l - 1 ]) * ( n / l ) * ( n / l ); } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u56db\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_1","text":"","title":"\u7ec4\u961f\u8bad\u7ec3\u8d5b\uff08\u56db\uff09"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#1","text":"","title":"\u9898\u76ee1"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_2","text":"\u667a\u4e43\u9171\u7684\u524d\u7f00\u548c\u4e0e\u5dee\u5206","title":"\u9898\u76ee\u94fe\u63a5"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_3","text":"","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_4","text":"10 2 11 1000 1000 1000 100000 1000 1000 10000 10000 10000 100000 1 10 0 100 1 10 1 1 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 1 10","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_5","text":"1101 1102 1103 100104 1105 1106 10107 10108 10109 100110 236055","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_6","text":"\u7531\u4e8e\u6a21\u6570\u5927\u4e8e\u5e8f\u5217\u957f\u5ea6\uff0c\u6240\u4ee5\u5bf9\u8d1f\u6570\u7684\u5dee\u5206\u53ef\u4ee5\u8f6c\u5316\u4e3a\u53d6\u6a21\u540e\u7684\u524d\u7f00\u548c\u3002 \u5bf9\u5e8f\u5217{ a_0 a_0 ,0,0,0,0}\u505a\u524d\u7f00\u53ef\u5f97 \u5e8f\u53f7 0 1 2 3 4 \u539f\u5e8f\u5217 a_0 a_0 0 0 0 0 \u4e00\u6b21\u524d\u7f00\u548c a_0 a_0 a_0 a_0 a_0 a_0 a_0 a_0 a_0 a_0 \u4e8c\u6b21\u524d\u7f00\u548c a_0 a_0 2 a_0 a_0 3 a_0 a_0 4 a_0 a_0 5 a_0 a_0 \u4e09\u6b21\u524d\u7f00\u548c a_0 a_0 3 a_0 a_0 6 a_0 a_0 10 a_0 a_0 15 a_0 a_0 \u5219\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u9012\u63a8\u5f0f\uff1a b[k][i]=b[k-1][i]+b[k][i-1] b[k][i]=b[k-1][i]+b[k][i-1] \uff0c\u8be5\u516c\u5f0f\u5373\u4e3a\u4ece(0,0)\u70b9\u8d70\u5230(k,i)\u70b9\u7684\u8def\u5f84\u79cd\u7c7b\u6570\uff0c\u4e14\u901a\u9879\u516c\u5f0f\u5373\u4e3a\uff1a b[k][i]=C_{i+k-1}^{i-1} b[k][i]=C_{i+k-1}^{i-1} \u56e0\u6b64\u53ef\u4ee5\u901a\u8fc7\u7ec4\u5408\u6570\u9012\u63a8\u7684\u65b9\u5f0f\u6c42\u51fa\u7cfb\u6570\u3002 \u5982\u679c\u8003\u8651 {a_0,a_1,a_2,.....,a_k} {a_0,a_1,a_2,.....,a_k} \u5e8f\u5217\uff0c\u5219\u53ef\u5f97\u5230\u4e00\u4e0b\u8ba1\u7b97\uff1a \u7b54\u6848\u5373\u4e3a {a_0,a_1,a_2,...,a_k} {a_0,a_1,a_2,...,a_k} \u548c {b_0,b_1,b_2,...,b_k} {b_0,b_1,b_2,...,b_k} \u5377\u79ef\u7684\u7ed3\u679c\uff0c\u6839\u636eNTT\u7b97\u6cd5\u53ef\u4ee5\u5728 O(nlogn) O(nlogn) \u65f6\u95f4\u590d\u6742\u5ea6\u5185\u5f97\u51fa\u7b54\u6848\u3002 \u53c2\u8003\u94fe\u63a5\uff1a https://blog.nowcoder.net/n/d1e592fc44b648668bcddc3fe44b7927","title":"\u9898\u89e3"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_7","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; const ll G = 3 ; ll n , m , L , R [ 600500 ] = { 0 }; ll a [ 600500 ] = { 0 }, b [ 600500 ] = { 0 }, inv [ 600500 ] = { 0 }; ll qpow ( ll a , ll b ) { ll ans1 = 1 , ans2 = a ; while ( b != 0 ) { if ( b & 1 ) ans1 = ans1 * ans2 % mod ; ans2 = ans2 * ans2 % mod ; b /= 2 ; } return ans1 % mod ; } void NTT ( ll * a , ll f ) { for ( ll i = 0 ; i < n ; i ++ ) { if ( i < R [ i ]) swap ( a [ i ], a [ R [ i ]]); } for ( ll i = 1 ; i < n ; i <<= 1 ) { ll gn = qpow ( G , ( mod - 1 ) / ( i << 1 )); for ( ll j = 0 ; j < n ; j += ( i << 1 )) { ll g = 1 ; for ( ll k = 0 ; k < i ; k ++ , g = g * gn % mod ) { ll x = a [ j + k ], y = g * a [ j + k + i ] % mod ; a [ j + k ] = ( x + y ) % mod ; a [ j + k + i ] = ( x - y + mod ) % mod ; } } } if ( f == 1 ) return ; ll inv = qpow ( n , mod - 2 ); reverse ( a + 1 , a + n ); for ( ll i = 0 ; i < n ; i ++ ) a [ i ] = 1l l * a [ i ] * inv % mod ; } void solve ( ll * A , ll * B ) { m = n + m ; for ( n = 1 ; n <= m ; n <<= 1 ) L ++ ; for ( int i = 0 ; i < n ; i ++ ) R [ i ] = ( R [ i >> 1 ] >> 1 ) | (( i & 1 ) << ( L - 1 )); NTT ( A , 1 ); NTT ( B , 1 ); for ( int i = 0 ; i < n ; i ++ ) A [ i ] = ( A [ i ] % mod * B [ i ] % mod + mod ) % mod ; NTT ( A , -1 ); } int main () { ll k ; scanf ( \"%lld%lld\" , & n , & k ); m = n ; ll nn = n ; for ( ll i = 0 ; i < n ; i ++ ) scanf ( \"%lld\" , & a [ i ]); inv [ 1 ] = 1 ; for ( ll i = 2 ; i < 200500 ; i ++ ) inv [ i ] = ( ll )( mod - mod / i ) * inv [ mod % i ] % mod ; b [ 0 ] = 1 ; ll kk = ( k % mod + mod ) % mod ; for ( ll i = 1 ; i < n ; i ++ ) b [ i ] = b [ i - 1 ] * ( i + kk - 1 ) % mod * inv [ i ] % mod ; solve ( a , b ); for ( ll i = 0 ; i < nn ; i ++ ) printf ( \"%lld \" , a [ i ]); return 0 ; }","title":"\u4ee3\u7801"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#2","text":"","title":"\u9898\u76ee2"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_8","text":"\u7ed9\u5b9a\u6b63\u6574\u6570 n n \uff0c\u6c42 1\\le x,y\\le n 1\\le x,y\\le n \u4e14 gcd(x,y) gcd(x,y) \u4e3a\u7d20\u6570\u7684\u6570\u5bf9 (x,y) (x,y) \u6709\u591a\u5c11\u5bf9\u3002","title":"\u9898\u76ee\u63cf\u8ff0"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_9","text":"\u53ea\u6709\u4e00\u884c\u4e00\u4e2a\u6574\u6570\uff0c\u4ee3\u8868 n n \u3002","title":"\u8f93\u5165\u683c\u5f0f"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_10","text":"\u4e00\u884c\u4e00\u4e2a\u6574\u6570\u8868\u793a\u7b54\u6848\u3002","title":"\u8f93\u51fa\u683c\u5f0f"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_11","text":"4","title":"\u8f93\u5165"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_12","text":"4","title":"\u8f93\u51fa"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_13","text":"\u5bf9\u4e8e\u6837\u4f8b\uff0c\u6ee1\u8db3\u6761\u4ef6\u7684 (x,y) \u4e3a (2,2)\uff0c(2,4)\uff0c(3,3)\uff0c(4,2)","title":"\u63d0\u793a"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_14","text":"\u5bf9\u4e8e 100% \u7684\u6570\u636e\uff0c\u4fdd\u8bc1 1\\le n\\le10^7 1\\le n\\le10^7 \u3002","title":"\u6570\u636e\u89c4\u6a21\u4e0e\u7ea6\u5b9a"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_15","text":"\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\u3002","title":"\u9898\u89e3"},{"location":"problem/%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E8%B5%9B%EF%BC%88%E5%9B%9B%EF%BC%89/#_16","text":"#include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll mod = 998244353 ; bool is_prime [ 10050000 ] = { 0 }; ll prime [ 5005000 ] = { 0 }; ll mu [ 10050000 ] = { 0 }; ll sum [ 10050000 ] = { 0 }; ll cnt = 0 ; void get_mu ( ll n ) { mu [ 1 ] = 1 ; for ( ll i = 2 ; i <= n ; i ++ ) { if ( ! is_prime [ i ]) { prime [ ++ cnt ] = i ; mu [ i ] = -1 ; } for ( ll j = 1 ; j <= cnt && prime [ j ] * i <= n ; j ++ ) { is_prime [ prime [ j ] * i ] = 1 ; if ( i % prime [ j ] == 0 ) break ; else mu [ i * prime [ j ]] = - mu [ i ]; } } } int main () { ll n ; scanf ( \"%lld\" , & n ); get_mu ( n ); for ( ll i = 1 ; i <= cnt ; i ++ ) for ( ll j = 1 ; j * prime [ i ] <= n ; j ++ ) sum [ j * prime [ i ]] += mu [ j ]; for ( int i = 1 ; i <= n ; i ++ ) sum [ i ] += sum [ i - 1 ]; ll ans = 0 ; for ( ll l = 1 , r ; l <= n ; l = r + 1 ) { r = n / ( n / l ); ans += ( sum [ r ] - sum [ l - 1 ]) * ( n / l ) * ( n / l ); } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"\u4ee3\u7801"},{"location":"question/","text":"\u9898\u5355 \u00b6 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u516b\u573a \u00b6 \u95ee\u9898 A: Radio Prize \u00b6 \u7b97\u6cd5\uff1a\u6811\u4e0aDP \u95ee\u9898 B: Perfect Flush \u00b6 \u7b97\u6cd5\uff1a\u6a21\u62df \u95ee\u9898 C: Coloring Contention \u00b6 \u7b97\u6cd5\uff1a\u6a21\u62df \u95ee\u9898 L: Party Invitations \u00b6 \u7b97\u6cd5\uff1aBFS \u95ee\u9898 M: Liars and Truth Tellers \u00b6 \u7b97\u6cd5\uff1a\u5e76\u67e5\u96c6 \u95ee\u9898 K: Seating \u00b6 \u7b97\u6cd5\uff1a\u7ebf\u6bb5\u6811\u7ef4\u62a4\u524d\u7f00 \u95ee\u9898 J: Interstellar Travel \u00b6 \u7b97\u6cd5\uff1a\u5dee\u5206 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e94\u573a \u00b6 \u95ee\u9898 A: Almost Origami \u00b6 \u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55 \u95ee\u9898 D: Dividing Candy \u00b6 \u7b97\u6cd5\uff1a\u6a21\u62df \u95ee\u9898 C: Crisis at the Wedding \u00b6 \u7b97\u6cd5\uff1a\u6a21\u62df \u95ee\u9898 E: Excellent Views \u00b6 \u7b97\u6cd5\uff1a\u5355\u8c03\u6808 \u95ee\u9898 H: Halting Wolf \u00b6 \u7b97\u6cd5\uff1a\u7f51\u7edc\u6d41 \u95ee\u9898 J: Job Allocator \u00b6 \u7b97\u6cd5\uff1a\u66b4\u529b\u679a\u4e3e \u95ee\u9898 F: Fascinating Partitions \u00b6 \u7b97\u6cd5\uff1aDP+\u4f18\u5316 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e8c\u573a \u00b6 \u95ee\u9898 J: Tree Constructer \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe \u95ee\u9898 D: Fight against involution \u00b6 \u7b97\u6cd5\uff1a\u8d2a\u5fc3 \u95ee\u9898 G: Xor Transformation \u00b6 \u7b97\u6cd5\uff1a\u6784\u9020 \u95ee\u9898 A: Matrix Equation \u00b6 \u7b97\u6cd5\uff1a\u7ebf\u6027\u4ee3\u6570--\u9ad8\u65af\u6d88\u5143\u6cd5 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u56db\u573a \u00b6 \u95ee\u9898 C: Hakase and Nano \u00b6 \u7b97\u6cd5\uff1a\u535a\u5f08\u8bba \u95ee\u9898 B: Master of Phi \u00b6 \u7b97\u6cd5\uff1a\u6570\u8bba\uff08\u6b27\u62c9\u5b9a\u7406\uff09 \u95ee\u9898 K: Master of Sequence \u00b6 \u7b97\u6cd5\uff1a\u968f\u673a\u5316 \u95ee\u9898 D: Master of Random \u00b6 \u7b97\u6cd5\uff1a\u89c4\u5f8b 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e8c\u573a \u00b6 \u95ee\u9898 J: Tree Constructer \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe \u95ee\u9898 D: Fight against involution \u00b6 \u7b97\u6cd5\uff1a\u8d2a\u5fc3 \u95ee\u9898 G: Xor Transformation \u00b6 \u7b97\u6cd5\uff1a\u6784\u9020 \u95ee\u9898 A: Matrix Equation \u00b6 \u7b97\u6cd5\uff1a\u7ebf\u6027\u4ee3\u6570--\u9ad8\u65af\u6d88\u5143\u6cd5 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e00\u573a \u00b6 \u95ee\u9898 B: Collatz Conjecture \u00b6 \u7b97\u6cd5\uff1aGCD \u6027\u8d28 \u95ee\u9898 G: Hoarse Horses \u00b6 \u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55+\u56fe\u7684\u6027\u8d28 \u95ee\u9898 K: Lemonade Trade \u00b6 \u7b97\u6cd5\uff1a\u6570\u5b66\uff0c\u4e58\u6cd5---\u5bf9\u6570\u53d8\u6362--->\u52a0\u6cd5 \u95ee\u9898 L: Manhattan Mornings \u00b6 \u7b97\u6cd5\uff1a\u6700\u5927\u4e0a\u5347\u5b50\u5e8f\u5217 \u95ee\u9898 H: Irrational Division \u00b6 \u7b97\u6cd5\uff1a\u89c4\u5f8b\u9898 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e5d\u573a \u00b6 \u95ee\u9898 H: Prime Set \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe\u5339\u914d+\u5308\u7259\u5229\u7f51\u8def \u95ee\u9898 G: NumbersI \u00b6 \u7b97\u6cd5\uff1aJava\u9ad8\u7cbe\u5ea6+\u8d2a\u5fc3 \u95ee\u9898 C: Crusaders Quest \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32 \u95ee\u9898 E: String of CCPC \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32 \u95ee\u9898 L: One-Dimensional Maze \u00b6 \u7b97\u6cd5\uff1a\u524d\u540e\u7f00 \u95ee\u9898 A: Balloon Robot \u00b6 \u7b97\u6cd5\uff1a\u524d\u540e\u7f00 \u95ee\u9898 M: Safest Buildings \u00b6 \u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u516b\u573a \u00b6 \u95ee\u9898 F: Hopscotch \u00b6 \u7b97\u6cd5\uff1a\u591a\u6e90\u6700\u77ed\u8def \u95ee\u9898 H: Letter Wheels \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u54c8\u5e0c \u95ee\u9898 G: ICPC Camp \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206+\u5339\u914d \u95ee\u9898 K: Rooted Subtrees \u00b6 \u7b97\u6cd5\uff1aLCA+ST\u500d\u589e \u95ee\u9898 B: Mini Battleship \u00b6 \u7b97\u6cd5\uff1a\u641c\u7d22 \u95ee\u9898 D: All Kill \u00b6 \u7b97\u6cd5\uff1a\u6982\u7387\u8bba+\u6253\u8868/\u627e\u89c4\u5f8b 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e03\u573a \u00b6 \u95ee\u9898 A: Anagram \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u6a21\u62df \u95ee\u9898 C: Cities \u00b6 \u7b97\u6cd5\uff1a\u6700\u5c0f\u751f\u6210\u6811 \u95ee\u9898 F: Four-tuples \u00b6 \u7b97\u6cd5\uff1a\u5bb9\u65a5\u539f\u7406 \u95ee\u9898 B: Bullet \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206+\u4e8c\u5206\u56fe\u5339\u914d \u95ee\u9898 G: Games \u00b6 \u7b97\u6cd5\uff1a\u535a\u5f08\u8bba+\u52a8\u6001\u89c4\u5212 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u516d\u573a \u00b6 \u95ee\u9898 L: Mixtape Management \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u6784\u9020\u9898\u76ee \u95ee\u9898 A: Adolescent Architecture \u00b6 \u7b97\u6cd5\uff1a\u6392\u5e8f \u95ee\u9898 B: Bookshelf Building \u00b6 \u7b97\u6cd5\uff1a\u52a8\u6001\u89c4\u5212 \u95ee\u9898 J: Knightly Knowledge \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206\u67e5\u627e \u95ee\u9898 K: Lexicographical Lecturing \u00b6 \u7b97\u6cd5\uff1a\u601d\u7ef4+\u5b57\u7b26\u4e32 \u95ee\u9898 C: Decorative Dominoes \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe\u7684\u5339\u914d \u95ee\u9898 F: Gravity Grid \u00b6 \u7b97\u6cd5\uff1a\u5927\u6a21\u62df 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e94\u573a \u00b6 \u95ee\u9898 C: Safe Distance \u00b6 \u7b97\u6cd5\uff1a\u5e76\u67e5\u96c6 \u95ee\u9898 G: Decoration \u00b6 \u7b97\u6cd5\uff1a\u56fe\u8bba+\u6570\u8bba \u95ee\u9898 I: Emails \u00b6 \u7b97\u6cd5\uff1aBFS\uff0c\u65e0\u5411\u56fe\u76f4\u5f84 \u95ee\u9898 K: Unique Activities \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32+\u4e8c\u5206check 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u56db\u573a \u00b6 \u95ee\u9898 F: Fair Distribution \u00b6 \u7b97\u6cd5\uff1a\u6570\u8bba+\u6574\u6570\u5206\u5757 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e09\u573a \u00b6 \u95ee\u9898 E: Interview Queue \u00b6 \u7b97\u6cd5\uff1aSTL+\u6a21\u62df \u95ee\u9898 F: Conquest \u00b6 \u7b97\u6cd5\uff1a\u4f18\u5148\u961f\u5217+BFS \u95ee\u9898 H: Antimatter Rain \u00b6 \u7b97\u6cd5\uff1a\u626b\u63cf\u7ebf+\u7ebf\u6bb5\u6811 \u95ee\u9898 J: Pegs and Legs \u00b6 \u7b97\u6cd5\uff1a\u56fe\u8bba+\u6982\u7387\u8bba 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e8c\u573a \u00b6 \u95ee\u9898 A: Three-Axis Views \u00b6 \u7b97\u6cd5\uff1a\u4e09\u89c6\u56fe\u6a21\u62df \u95ee\u9898 B: Secrets of Legendary Treasure \u00b6 \u7b97\u6cd5\uff1a\u6784\u9020+\u6a21\u62df\u9898\u76ee \u95ee\u9898 E: Jewelry Size \u00b6 \u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55 \u95ee\u9898 G: To be Connected, or not to be, that is the Question \u00b6 \u7b97\u6cd5\uff1a\u5e76\u67e5\u96c6\u7684\u64a4\u9500 \u95ee\u9898 H: LCM of GCDs \u00b6 \u7b97\u6cd5\uff1a\u7ebf\u6bb5\u6811+GCD&LCM\u6027\u8d28 \u95ee\u9898 I: High-Tech Detective \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32+\u52a8\u6001\u89c4\u5212 \u95ee\u9898 J: Formica Sokobanica \u00b6 \u7b97\u6cd5\uff1a\u641c\u7d22 2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e00\u573a \u00b6 \u95ee\u9898 F: Agamemnon\u2019s Odyssey \u00b6 \u7b97\u6cd5\uff1a\u6811\u7684\u76f4\u5f84 \u95ee\u9898 D: Substring Characters \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32 \u95ee\u9898 J: Ada Loveslaces \u00b6 \u7b97\u6cd5\uff1a\u72b6\u538b \u95ee\u9898 I: Staggering to the Finish \u00b6 \u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55\uff0c\u6709\u70b9\u96be \u95ee\u9898 K: ICPC Record Matching \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u54c8\u5e0c\uff0c\u6a21\u62df \u95ee\u9898 A: LogDB \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u6a21\u62df \u95ee\u9898 B: Ride-Hailing \u00b6 \u7b97\u6cd5\uff1a\u56fe\u5339\u914d+\u6700\u5927\u6d41Dinic\u7b97\u6cd5 2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c52\u573a \u00b6 \u95ee\u9898 C: \u62a2\u5360\u57ce\u5821 \u00b6 \u7b97\u6cd5\uff1a\u76f4\u63a5\u641c\u7d22\uff0c\u6ce8\u610f\u6709\u5751\uff01\uff01\uff01 \u95ee\u9898 H: \u5305\u542b \u00b6 \u7b97\u6cd5\uff1a\u5b57\u5178\u6811+\u641c\u7d20 \u95ee\u9898 K: GCD \u00b6 \u7b97\u6cd5\uff1a\u8d28\u56e0\u6570 \u95ee\u9898 B: \u653e\u725b\u5976\u7684\u51b0\u7bb1 \u00b6 \u7b97\u6cd5\uff1a\u672a\u77e5\uff0c\u8fd8\u6ca1\u8865\uff0cqaq\uff0c\u53ef\u4ee5\u66b4\u529b\u6216\u4e8c\u5206\u8bd5\u8bd5 \u95ee\u9898 I: Reverse and Compare \u00b6 \u7b97\u6cd5\uff1a\u89c4\u5f8b\u9898\uff0c\u7ed9\u4e2a\u6837\u4f8b\u63d0\u793a\uff1aabca\uff0c\u6682\u65f6\u8fd8\u6ca1\u8865 \u95ee\u9898 J: Fountain Walk \u00b6 \u7b97\u6cd5\uff1a\u6700\u5927\u4e0a\u5347\u5b50\u5e8f\u5217\uff0c\u53ef\u4ee5\u5148\u653e\u4e00\u653e\uff0c\u6211\u8fd8\u6ca1\u8865\u51fa\u6765\uff0cqaq 2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c51\u573a \u00b6 \u95ee\u9898 B: Getting Difference \u00b6 \u7b97\u6cd5\uff1a\u601d\u7ef4+\u6570\u8bba \u95ee\u9898 C: \u91ce\u725b\u4e0e\u72fc \u00b6 \u7b97\u6cd5\uff1a\u524d\u7f00+\u601d\u7ef4 \u95ee\u9898 D: \u8001\u6b7b\u4e0d\u76f8\u5f80\u6765 \u00b6 \u7b97\u6cd5\uff1a\u79bb\u6563\u5316 \u95ee\u9898 G: Cow Lineup I \u00b6 \u7b97\u6cd5\uff1a\u4e8c\u5206\u6216\u8005\u66b4\u529b \u95ee\u9898 K: Painting the Fence \u00b6 \u7b97\u6cd5\uff1a\u79bb\u6563\u5316+\u524d\u7f00 2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c50\u573a \u00b6 \u95ee\u9898 C: \u725b\u725b\u7684\u65b9\u7a0b\u5f0f \u00b6 \u7b97\u6cd5\uff1a\u7b7e\u5230\u9898\uff0c\u6570\u8bba \u95ee\u9898 M: Milk Routing \u00b6 \u7b97\u6cd5\uff1a\u56fe\u8bba\uff0c\u6700\u77ed\u8def\uff0c\u641c\u7d20 \u95ee\u9898 D: \u725b\u725b\u7684\u731c\u7403\u6e38\u620f \u00b6 \u7b97\u6cd5\uff1a\u601d\u7ef4\u9898\u76ee \u95ee\u9898 A: LH \u64b8\u4e32\u4e32 \u00b6 \u7b97\u6cd5\uff1a\u65e0\u8111\u66b4\u529b \u95ee\u9898 J: Moderate Differences \u00b6 \u7b97\u6cd5\uff1a\u601d\u7ef4+\u679a\u4e3e \u95ee\u9898 K: Biscuits \u00b6 \u7b97\u6cd5\uff1a\u52a8\u6001\u89c4\u5212/\u7ec4\u5408\u6570\u5b66 2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c49\u573a \u00b6 \u95ee\u9898 A: \u00b1 Rectangle \u00b6 \u7b97\u6cd5\uff1a\u6bd4\u8f83\u96be\u7684\u6784\u9020\u9898\uff0c\u4e0d\u8fc7\u6a21\u62df\u4e5f\u53ef\u4ee5\u8fc7\uff0c\u989d \u95ee\u9898 H: Wifi Setup \u00b6 \u7b97\u6cd5\uff1aDP\uff1f\u53ef\u80fd\u662f\u5427 \u95ee\u9898 J: Shrinking \u00b6 \u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32 \u95ee\u9898 G: Colorful Hats \u00b6 \u7b97\u6cd5\uff1a\u672a\u77e5\uff0c\u8fd8\u6ca1\u8865\u51fa\u6765\uff0c \u95ee\u9898 D: Scrambled Letters \u00b6 \u7b97\u6cd5\uff1a\u672a\u77e5\uff0c\u8fd8\u6ca1\u8865\u51fa\u6765\uff0c 2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c48\u573a \u00b6 \u95ee\u9898F\uff1a\u62ec\u53f7\u5e8f\u5217 \u00b6 \u7b97\u6cd5\uff1a\u6808\u7684\u5e94\u7528 \u95ee\u9898 L: A or...or B Problem \u00b6 \u7b97\u6cd5\uff1a\u601d\u7ef4\uff0c\u4f4d\u8fd0\u7b97 \u95ee\u9898 H: Nuske vs Phantom Thnook \u00b6 \u7b97\u6cd5\uff1a\u524d\u7f00\u548c\u3001\u6811\u7684\u6027\u8d28 \u95ee\u9898 K: \u5b57\u6bcd\u91d1\u5b57\u5854 \u00b6 \u7b97\u6cd5\uff1a\u5927\u6a21\u62df\uff0c\u53ef\u4ee5\u5148\u653e\u4e00\u653e console.log(\"Hello World!\"); console.log(\"\u4f60\u597d\u554a\uff01\");","title":"ICPC\u9898\u5355"},{"location":"question/#_1","text":"","title":"\u9898\u5355"},{"location":"question/#2021","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u516b\u573a"},{"location":"question/#a-radio-prize","text":"\u7b97\u6cd5\uff1a\u6811\u4e0aDP","title":"\u95ee\u9898 A: Radio Prize"},{"location":"question/#b-perfect-flush","text":"\u7b97\u6cd5\uff1a\u6a21\u62df","title":"\u95ee\u9898 B: Perfect Flush"},{"location":"question/#c-coloring-contention","text":"\u7b97\u6cd5\uff1a\u6a21\u62df","title":"\u95ee\u9898 C: Coloring Contention"},{"location":"question/#l-party-invitations","text":"\u7b97\u6cd5\uff1aBFS","title":"\u95ee\u9898 L: Party Invitations"},{"location":"question/#m-liars-and-truth-tellers","text":"\u7b97\u6cd5\uff1a\u5e76\u67e5\u96c6","title":"\u95ee\u9898 M: Liars and Truth Tellers"},{"location":"question/#k-seating","text":"\u7b97\u6cd5\uff1a\u7ebf\u6bb5\u6811\u7ef4\u62a4\u524d\u7f00","title":"\u95ee\u9898 K: Seating"},{"location":"question/#j-interstellar-travel","text":"\u7b97\u6cd5\uff1a\u5dee\u5206","title":"\u95ee\u9898 J: Interstellar Travel"},{"location":"question/#2021_1","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e94\u573a"},{"location":"question/#a-almost-origami","text":"\u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55","title":"\u95ee\u9898 A: Almost Origami"},{"location":"question/#d-dividing-candy","text":"\u7b97\u6cd5\uff1a\u6a21\u62df","title":"\u95ee\u9898 D: Dividing Candy"},{"location":"question/#c-crisis-at-the-wedding","text":"\u7b97\u6cd5\uff1a\u6a21\u62df","title":"\u95ee\u9898 C: Crisis at the Wedding"},{"location":"question/#e-excellent-views","text":"\u7b97\u6cd5\uff1a\u5355\u8c03\u6808","title":"\u95ee\u9898 E: Excellent Views"},{"location":"question/#h-halting-wolf","text":"\u7b97\u6cd5\uff1a\u7f51\u7edc\u6d41","title":"\u95ee\u9898 H: Halting Wolf"},{"location":"question/#j-job-allocator","text":"\u7b97\u6cd5\uff1a\u66b4\u529b\u679a\u4e3e","title":"\u95ee\u9898 J: Job Allocator"},{"location":"question/#f-fascinating-partitions","text":"\u7b97\u6cd5\uff1aDP+\u4f18\u5316","title":"\u95ee\u9898 F: Fascinating Partitions"},{"location":"question/#2021_2","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e8c\u573a"},{"location":"question/#j-tree-constructer","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe","title":"\u95ee\u9898 J: Tree Constructer"},{"location":"question/#d-fight-against-involution","text":"\u7b97\u6cd5\uff1a\u8d2a\u5fc3","title":"\u95ee\u9898 D: Fight against involution"},{"location":"question/#g-xor-transformation","text":"\u7b97\u6cd5\uff1a\u6784\u9020","title":"\u95ee\u9898 G: Xor Transformation"},{"location":"question/#a-matrix-equation","text":"\u7b97\u6cd5\uff1a\u7ebf\u6027\u4ee3\u6570--\u9ad8\u65af\u6d88\u5143\u6cd5","title":"\u95ee\u9898 A: Matrix Equation"},{"location":"question/#2021_3","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u56db\u573a"},{"location":"question/#c-hakase-and-nano","text":"\u7b97\u6cd5\uff1a\u535a\u5f08\u8bba","title":"\u95ee\u9898 C: Hakase and Nano"},{"location":"question/#b-master-of-phi","text":"\u7b97\u6cd5\uff1a\u6570\u8bba\uff08\u6b27\u62c9\u5b9a\u7406\uff09","title":"\u95ee\u9898 B: Master of Phi"},{"location":"question/#k-master-of-sequence","text":"\u7b97\u6cd5\uff1a\u968f\u673a\u5316","title":"\u95ee\u9898 K: Master of Sequence"},{"location":"question/#d-master-of-random","text":"\u7b97\u6cd5\uff1a\u89c4\u5f8b","title":"\u95ee\u9898 D: Master of Random"},{"location":"question/#2021_4","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e8c\u573a"},{"location":"question/#j-tree-constructer_1","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe","title":"\u95ee\u9898 J: Tree Constructer"},{"location":"question/#d-fight-against-involution_1","text":"\u7b97\u6cd5\uff1a\u8d2a\u5fc3","title":"\u95ee\u9898 D: Fight against involution"},{"location":"question/#g-xor-transformation_1","text":"\u7b97\u6cd5\uff1a\u6784\u9020","title":"\u95ee\u9898 G: Xor Transformation"},{"location":"question/#a-matrix-equation_1","text":"\u7b97\u6cd5\uff1a\u7ebf\u6027\u4ee3\u6570--\u9ad8\u65af\u6d88\u5143\u6cd5","title":"\u95ee\u9898 A: Matrix Equation"},{"location":"question/#2021_5","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u5341\u4e00\u573a"},{"location":"question/#b-collatz-conjecture","text":"\u7b97\u6cd5\uff1aGCD \u6027\u8d28","title":"\u95ee\u9898 B: Collatz Conjecture"},{"location":"question/#g-hoarse-horses","text":"\u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55+\u56fe\u7684\u6027\u8d28","title":"\u95ee\u9898 G: Hoarse Horses"},{"location":"question/#k-lemonade-trade","text":"\u7b97\u6cd5\uff1a\u6570\u5b66\uff0c\u4e58\u6cd5---\u5bf9\u6570\u53d8\u6362--->\u52a0\u6cd5","title":"\u95ee\u9898 K: Lemonade Trade"},{"location":"question/#l-manhattan-mornings","text":"\u7b97\u6cd5\uff1a\u6700\u5927\u4e0a\u5347\u5b50\u5e8f\u5217","title":"\u95ee\u9898 L: Manhattan Mornings"},{"location":"question/#h-irrational-division","text":"\u7b97\u6cd5\uff1a\u89c4\u5f8b\u9898","title":"\u95ee\u9898 H: Irrational Division"},{"location":"question/#2021_6","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e5d\u573a"},{"location":"question/#h-prime-set","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe\u5339\u914d+\u5308\u7259\u5229\u7f51\u8def","title":"\u95ee\u9898 H: Prime Set"},{"location":"question/#g-numbersi","text":"\u7b97\u6cd5\uff1aJava\u9ad8\u7cbe\u5ea6+\u8d2a\u5fc3","title":"\u95ee\u9898 G: NumbersI"},{"location":"question/#c-crusaders-quest","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32","title":"\u95ee\u9898 C: Crusaders Quest"},{"location":"question/#e-string-of-ccpc","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32","title":"\u95ee\u9898 E: String of CCPC"},{"location":"question/#l-one-dimensional-maze","text":"\u7b97\u6cd5\uff1a\u524d\u540e\u7f00","title":"\u95ee\u9898 L: One-Dimensional Maze"},{"location":"question/#a-balloon-robot","text":"\u7b97\u6cd5\uff1a\u524d\u540e\u7f00","title":"\u95ee\u9898 A: Balloon Robot"},{"location":"question/#m-safest-buildings","text":"\u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55","title":"\u95ee\u9898 M: Safest Buildings"},{"location":"question/#2021_7","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u516b\u573a"},{"location":"question/#f-hopscotch","text":"\u7b97\u6cd5\uff1a\u591a\u6e90\u6700\u77ed\u8def","title":"\u95ee\u9898 F: Hopscotch"},{"location":"question/#h-letter-wheels","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u54c8\u5e0c","title":"\u95ee\u9898 H: Letter Wheels"},{"location":"question/#g-icpc-camp","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206+\u5339\u914d","title":"\u95ee\u9898 G: ICPC Camp"},{"location":"question/#k-rooted-subtrees","text":"\u7b97\u6cd5\uff1aLCA+ST\u500d\u589e","title":"\u95ee\u9898 K: Rooted Subtrees"},{"location":"question/#b-mini-battleship","text":"\u7b97\u6cd5\uff1a\u641c\u7d22","title":"\u95ee\u9898 B: Mini Battleship"},{"location":"question/#d-all-kill","text":"\u7b97\u6cd5\uff1a\u6982\u7387\u8bba+\u6253\u8868/\u627e\u89c4\u5f8b","title":"\u95ee\u9898 D: All Kill"},{"location":"question/#2021_8","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e03\u573a"},{"location":"question/#a-anagram","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u6a21\u62df","title":"\u95ee\u9898 A: Anagram"},{"location":"question/#c-cities","text":"\u7b97\u6cd5\uff1a\u6700\u5c0f\u751f\u6210\u6811","title":"\u95ee\u9898 C: Cities"},{"location":"question/#f-four-tuples","text":"\u7b97\u6cd5\uff1a\u5bb9\u65a5\u539f\u7406","title":"\u95ee\u9898 F: Four-tuples"},{"location":"question/#b-bullet","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206+\u4e8c\u5206\u56fe\u5339\u914d","title":"\u95ee\u9898 B: Bullet"},{"location":"question/#g-games","text":"\u7b97\u6cd5\uff1a\u535a\u5f08\u8bba+\u52a8\u6001\u89c4\u5212","title":"\u95ee\u9898 G: Games"},{"location":"question/#2021_9","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u516d\u573a"},{"location":"question/#l-mixtape-management","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u6784\u9020\u9898\u76ee","title":"\u95ee\u9898 L: Mixtape Management"},{"location":"question/#a-adolescent-architecture","text":"\u7b97\u6cd5\uff1a\u6392\u5e8f","title":"\u95ee\u9898 A: Adolescent Architecture"},{"location":"question/#b-bookshelf-building","text":"\u7b97\u6cd5\uff1a\u52a8\u6001\u89c4\u5212","title":"\u95ee\u9898 B: Bookshelf Building"},{"location":"question/#j-knightly-knowledge","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206\u67e5\u627e","title":"\u95ee\u9898 J: Knightly Knowledge"},{"location":"question/#k-lexicographical-lecturing","text":"\u7b97\u6cd5\uff1a\u601d\u7ef4+\u5b57\u7b26\u4e32","title":"\u95ee\u9898 K: Lexicographical Lecturing"},{"location":"question/#c-decorative-dominoes","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206\u56fe\u7684\u5339\u914d","title":"\u95ee\u9898 C: Decorative Dominoes"},{"location":"question/#f-gravity-grid","text":"\u7b97\u6cd5\uff1a\u5927\u6a21\u62df","title":"\u95ee\u9898 F: Gravity Grid"},{"location":"question/#2021_10","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e94\u573a"},{"location":"question/#c-safe-distance","text":"\u7b97\u6cd5\uff1a\u5e76\u67e5\u96c6","title":"\u95ee\u9898 C: Safe Distance"},{"location":"question/#g-decoration","text":"\u7b97\u6cd5\uff1a\u56fe\u8bba+\u6570\u8bba","title":"\u95ee\u9898 G: Decoration"},{"location":"question/#i-emails","text":"\u7b97\u6cd5\uff1aBFS\uff0c\u65e0\u5411\u56fe\u76f4\u5f84","title":"\u95ee\u9898 I: Emails"},{"location":"question/#k-unique-activities","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32+\u4e8c\u5206check","title":"\u95ee\u9898 K: Unique Activities"},{"location":"question/#2021_11","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u56db\u573a"},{"location":"question/#f-fair-distribution","text":"\u7b97\u6cd5\uff1a\u6570\u8bba+\u6574\u6570\u5206\u5757","title":"\u95ee\u9898 F: Fair Distribution"},{"location":"question/#2021_12","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e09\u573a"},{"location":"question/#e-interview-queue","text":"\u7b97\u6cd5\uff1aSTL+\u6a21\u62df","title":"\u95ee\u9898 E: Interview Queue"},{"location":"question/#f-conquest","text":"\u7b97\u6cd5\uff1a\u4f18\u5148\u961f\u5217+BFS","title":"\u95ee\u9898 F: Conquest"},{"location":"question/#h-antimatter-rain","text":"\u7b97\u6cd5\uff1a\u626b\u63cf\u7ebf+\u7ebf\u6bb5\u6811","title":"\u95ee\u9898 H: Antimatter Rain"},{"location":"question/#j-pegs-and-legs","text":"\u7b97\u6cd5\uff1a\u56fe\u8bba+\u6982\u7387\u8bba","title":"\u95ee\u9898 J: Pegs and Legs"},{"location":"question/#2021_13","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e8c\u573a"},{"location":"question/#a-three-axis-views","text":"\u7b97\u6cd5\uff1a\u4e09\u89c6\u56fe\u6a21\u62df","title":"\u95ee\u9898 A: Three-Axis Views"},{"location":"question/#b-secrets-of-legendary-treasure","text":"\u7b97\u6cd5\uff1a\u6784\u9020+\u6a21\u62df\u9898\u76ee","title":"\u95ee\u9898 B: Secrets of Legendary Treasure"},{"location":"question/#e-jewelry-size","text":"\u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55","title":"\u95ee\u9898 E: Jewelry Size"},{"location":"question/#g-to-be-connected-or-not-to-be-that-is-the-question","text":"\u7b97\u6cd5\uff1a\u5e76\u67e5\u96c6\u7684\u64a4\u9500","title":"\u95ee\u9898 G: To be Connected, or not to be, that is the Question"},{"location":"question/#h-lcm-of-gcds","text":"\u7b97\u6cd5\uff1a\u7ebf\u6bb5\u6811+GCD&LCM\u6027\u8d28","title":"\u95ee\u9898 H: LCM of GCDs"},{"location":"question/#i-high-tech-detective","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32+\u52a8\u6001\u89c4\u5212","title":"\u95ee\u9898 I: High-Tech Detective"},{"location":"question/#j-formica-sokobanica","text":"\u7b97\u6cd5\uff1a\u641c\u7d22","title":"\u95ee\u9898 J: Formica Sokobanica"},{"location":"question/#2021_14","text":"","title":"2021\u79cb\u7ec4\u961f\u8bad\u7ec3\u8d5b\u7b2c\u4e00\u573a"},{"location":"question/#f-agamemnons-odyssey","text":"\u7b97\u6cd5\uff1a\u6811\u7684\u76f4\u5f84","title":"\u95ee\u9898 F: Agamemnon\u2019s Odyssey"},{"location":"question/#d-substring-characters","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32","title":"\u95ee\u9898 D: Substring Characters"},{"location":"question/#j-ada-loveslaces","text":"\u7b97\u6cd5\uff1a\u72b6\u538b","title":"\u95ee\u9898 J: Ada Loveslaces"},{"location":"question/#i-staggering-to-the-finish","text":"\u7b97\u6cd5\uff1a\u8ba1\u7b97\u51e0\u4f55\uff0c\u6709\u70b9\u96be","title":"\u95ee\u9898 I: Staggering to the Finish"},{"location":"question/#k-icpc-record-matching","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u54c8\u5e0c\uff0c\u6a21\u62df","title":"\u95ee\u9898 K: ICPC Record Matching"},{"location":"question/#a-logdb","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32\u6a21\u62df","title":"\u95ee\u9898 A: LogDB"},{"location":"question/#b-ride-hailing","text":"\u7b97\u6cd5\uff1a\u56fe\u5339\u914d+\u6700\u5927\u6d41Dinic\u7b97\u6cd5","title":"\u95ee\u9898 B: Ride-Hailing"},{"location":"question/#202152","text":"","title":"2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c52\u573a"},{"location":"question/#c","text":"\u7b97\u6cd5\uff1a\u76f4\u63a5\u641c\u7d22\uff0c\u6ce8\u610f\u6709\u5751\uff01\uff01\uff01","title":"\u95ee\u9898 C: \u62a2\u5360\u57ce\u5821"},{"location":"question/#h","text":"\u7b97\u6cd5\uff1a\u5b57\u5178\u6811+\u641c\u7d20","title":"\u95ee\u9898 H: \u5305\u542b"},{"location":"question/#k-gcd","text":"\u7b97\u6cd5\uff1a\u8d28\u56e0\u6570","title":"\u95ee\u9898 K: GCD"},{"location":"question/#b","text":"\u7b97\u6cd5\uff1a\u672a\u77e5\uff0c\u8fd8\u6ca1\u8865\uff0cqaq\uff0c\u53ef\u4ee5\u66b4\u529b\u6216\u4e8c\u5206\u8bd5\u8bd5","title":"\u95ee\u9898 B: \u653e\u725b\u5976\u7684\u51b0\u7bb1"},{"location":"question/#i-reverse-and-compare","text":"\u7b97\u6cd5\uff1a\u89c4\u5f8b\u9898\uff0c\u7ed9\u4e2a\u6837\u4f8b\u63d0\u793a\uff1aabca\uff0c\u6682\u65f6\u8fd8\u6ca1\u8865","title":"\u95ee\u9898 I: Reverse and Compare"},{"location":"question/#j-fountain-walk","text":"\u7b97\u6cd5\uff1a\u6700\u5927\u4e0a\u5347\u5b50\u5e8f\u5217\uff0c\u53ef\u4ee5\u5148\u653e\u4e00\u653e\uff0c\u6211\u8fd8\u6ca1\u8865\u51fa\u6765\uff0cqaq","title":"\u95ee\u9898 J: Fountain Walk"},{"location":"question/#202151","text":"","title":"2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c51\u573a"},{"location":"question/#b-getting-difference","text":"\u7b97\u6cd5\uff1a\u601d\u7ef4+\u6570\u8bba","title":"\u95ee\u9898 B: Getting Difference"},{"location":"question/#c_1","text":"\u7b97\u6cd5\uff1a\u524d\u7f00+\u601d\u7ef4","title":"\u95ee\u9898 C: \u91ce\u725b\u4e0e\u72fc"},{"location":"question/#d","text":"\u7b97\u6cd5\uff1a\u79bb\u6563\u5316","title":"\u95ee\u9898 D: \u8001\u6b7b\u4e0d\u76f8\u5f80\u6765"},{"location":"question/#g-cow-lineup-i","text":"\u7b97\u6cd5\uff1a\u4e8c\u5206\u6216\u8005\u66b4\u529b","title":"\u95ee\u9898 G: Cow Lineup I"},{"location":"question/#k-painting-the-fence","text":"\u7b97\u6cd5\uff1a\u79bb\u6563\u5316+\u524d\u7f00","title":"\u95ee\u9898 K: Painting the Fence"},{"location":"question/#202150","text":"","title":"2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c50\u573a"},{"location":"question/#c_2","text":"\u7b97\u6cd5\uff1a\u7b7e\u5230\u9898\uff0c\u6570\u8bba","title":"\u95ee\u9898 C: \u725b\u725b\u7684\u65b9\u7a0b\u5f0f"},{"location":"question/#m-milk-routing","text":"\u7b97\u6cd5\uff1a\u56fe\u8bba\uff0c\u6700\u77ed\u8def\uff0c\u641c\u7d20","title":"\u95ee\u9898 M: Milk Routing"},{"location":"question/#d_1","text":"\u7b97\u6cd5\uff1a\u601d\u7ef4\u9898\u76ee","title":"\u95ee\u9898 D: \u725b\u725b\u7684\u731c\u7403\u6e38\u620f"},{"location":"question/#a-lh","text":"\u7b97\u6cd5\uff1a\u65e0\u8111\u66b4\u529b","title":"\u95ee\u9898 A: LH \u64b8\u4e32\u4e32"},{"location":"question/#j-moderate-differences","text":"\u7b97\u6cd5\uff1a\u601d\u7ef4+\u679a\u4e3e","title":"\u95ee\u9898 J: Moderate Differences"},{"location":"question/#k-biscuits","text":"\u7b97\u6cd5\uff1a\u52a8\u6001\u89c4\u5212/\u7ec4\u5408\u6570\u5b66","title":"\u95ee\u9898 K: Biscuits"},{"location":"question/#202149","text":"","title":"2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c49\u573a"},{"location":"question/#a-rectangle","text":"\u7b97\u6cd5\uff1a\u6bd4\u8f83\u96be\u7684\u6784\u9020\u9898\uff0c\u4e0d\u8fc7\u6a21\u62df\u4e5f\u53ef\u4ee5\u8fc7\uff0c\u989d","title":"\u95ee\u9898 A: +/- Rectangle"},{"location":"question/#h-wifi-setup","text":"\u7b97\u6cd5\uff1aDP\uff1f\u53ef\u80fd\u662f\u5427","title":"\u95ee\u9898 H: Wifi Setup"},{"location":"question/#j-shrinking","text":"\u7b97\u6cd5\uff1a\u5b57\u7b26\u4e32","title":"\u95ee\u9898 J: Shrinking"},{"location":"question/#g-colorful-hats","text":"\u7b97\u6cd5\uff1a\u672a\u77e5\uff0c\u8fd8\u6ca1\u8865\u51fa\u6765\uff0c","title":"\u95ee\u9898 G: Colorful Hats"},{"location":"question/#d-scrambled-letters","text":"\u7b97\u6cd5\uff1a\u672a\u77e5\uff0c\u8fd8\u6ca1\u8865\u51fa\u6765\uff0c","title":"\u95ee\u9898 D: Scrambled Letters"},{"location":"question/#202148","text":"","title":"2021\u4e2a\u4eba\u8bad\u7ec3\u8d5b\u7b2c48\u573a"},{"location":"question/#f","text":"\u7b97\u6cd5\uff1a\u6808\u7684\u5e94\u7528","title":"\u95ee\u9898F\uff1a\u62ec\u53f7\u5e8f\u5217"},{"location":"question/#l-a-oror-b-problem","text":"\u7b97\u6cd5\uff1a\u601d\u7ef4\uff0c\u4f4d\u8fd0\u7b97","title":"\u95ee\u9898 L: A or...or B Problem"},{"location":"question/#h-nuske-vs-phantom-thnook","text":"\u7b97\u6cd5\uff1a\u524d\u7f00\u548c\u3001\u6811\u7684\u6027\u8d28","title":"\u95ee\u9898 H: Nuske vs Phantom Thnook"},{"location":"question/#k","text":"\u7b97\u6cd5\uff1a\u5927\u6a21\u62df\uff0c\u53ef\u4ee5\u5148\u653e\u4e00\u653e console.log(\"Hello World!\"); console.log(\"\u4f60\u597d\u554a\uff01\");","title":"\u95ee\u9898 K: \u5b57\u6bcd\u91d1\u5b57\u5854"},{"location":"question/_coverpage/","text":"Tim-wcx \u00b6 \u4e2a\u4eba\u6587\u6863\u7f51\u7ad9 \u00b6 GitHub Get Started","title":"Tim-wcx"},{"location":"question/_coverpage/#tim-wcx","text":"","title":"Tim-wcx"},{"location":"question/_coverpage/#_1","text":"GitHub Get Started","title":"\u4e2a\u4eba\u6587\u6863\u7f51\u7ad9"},{"location":"question/_sidebar/","text":"\u4e0a\u4e00\u7ea7 ICPC\u9898\u5355","title":" sidebar"}]}